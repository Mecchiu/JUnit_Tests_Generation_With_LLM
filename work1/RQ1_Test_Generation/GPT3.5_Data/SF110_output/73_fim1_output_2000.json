[
{
    "id": "chatcmpl-A5VbvpoYm6vp0bLIRORot3oKMkNQu",
    "object": "chat.completion",
    "created": 1725876515,
    "model": "gpt-3.5-turbo-0125",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "```java\npackage osa.ora.server;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.logging.Logger;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass ModernChatServer_0Test {\n\n    @Test\n    void testGetLoggerNotNull() {\n        Logger logger = ModernChatServer.getLogger();\n        assertNotNull(logger);\n    }\n\n    @Test\n    void testGetLoggerSameInstance() {\n        Logger logger1 = ModernChatServer.getLogger();\n        Logger logger2 = ModernChatServer.getLogger();\n        assertSame(logger1, logger2);\n    }\n\n    @Test\n    void testGetLoggerName() {\n        Logger logger = ModernChatServer.getLogger();\n        assertEquals(\"ModernChatServer\", logger.getName());\n    }\n\n    @Test\n    void testGetLoggerParent() {\n        Logger logger = ModernChatServer.getLogger();\n        assertNull(logger.getParent());\n    }\n\n    @Test\n    void testGetLoggerLevel() {\n        Logger logger = ModernChatServer.getLogger();\n        assertEquals(null, logger.getLevel());\n    }\n\n    @Test\n    void testGetLoggerUseParentHandlers() {\n        Logger logger = ModernChatServer.getLogger();\n        assertTrue(logger.getUseParentHandlers());\n    }\n\n    @Test\n    void testGetLoggerAddHandler() {\n        Logger logger = ModernChatServer.getLogger();\n        assertEquals(1, logger.getHandlers().length);\n    }\n\n    @Test\n    void testGetLoggerHandlerName() {\n        Logger logger = ModernChatServer.getLogger();\n        assertEquals(\"java.util.logging.ConsoleHandler\", logger.getHandlers()[0].getClass().getName());\n    }\n\n    @Test\n    void testGetLoggerHandlerLevel() {\n        Logger logger = ModernChatServer.getLogger();\n        assertEquals(null, logger.getHandlers()[0].getLevel());\n    }\n\n    @Test\n    void testGetLoggerHandlerFormatter() {\n        Logger logger = ModernChatServer.getLogger();\n        assertEquals(\"java.util.logging.SimpleFormatter\", logger.getHandlers()[0].getFormatter().getClass().getName());\n    }\n}\n```",
                "refusal": null
            },
            "logprobs": null,
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 11829,
        "completion_tokens": 398,
        "total_tokens": 12227
    },
    "system_fingerprint": null,
    "time_taken": 6.785840272903442,
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_0Test.java",
    "original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
    "test_prompt": "// ModernChatServer_0Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#getLogger()} method.\n*/\nclass ModernChatServer_0Test {"
}
,{
    "id": "chatcmpl-A5VcykCEFPTZFdY31Kkymcr2ourF8",
    "object": "chat.completion",
    "created": 1725876580,
    "model": "gpt-3.5-turbo-0125",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "```java\npackage osa.ora.server;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass ModernChatServer_1Test {\n\n    @Test\n    void testPingReturnsTrue() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        boolean result = modernChatServer.ping();\n        assertTrue(result);\n    }\n\n    @Test\n    void testPingReturnsTrueAfterSignIn() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        ClientInterface clientInterface = new ClientInterfaceImpl();\n        String emailAddr = \"test@example.com\";\n        String password = \"password123\";\n        String ipAddress = \"192.168.1.1\";\n        try {\n            LoginBean loginBean = modernChatServer.signIn(clientInterface, emailAddr, password, ipAddress);\n            assertNotNull(loginBean);\n            boolean result = modernChatServer.ping();\n            assertTrue(result);\n        } catch (RemoteException e) {\n            fail(\"Exception thrown during sign in: \" + e.getMessage());\n        }\n    }\n\n    @Test\n    void testPingReturnsTrueAfterSignOut() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        ClientInterface clientInterface = new ClientInterfaceImpl();\n        String emailAddr = \"test@example.com\";\n        String password = \"password123\";\n        String ipAddress = \"192.168.1.1\";\n        try {\n            LoginBean loginBean = modernChatServer.signIn(clientInterface, emailAddr, password, ipAddress);\n            assertNotNull(loginBean);\n            User user = loginBean.getUser();\n            modernChatServer.signOut(user);\n            boolean result = modernChatServer.ping();\n            assertTrue(result);\n        } catch (RemoteException e) {\n            fail(\"Exception thrown during sign in or sign out: \" + e.getMessage());\n        }\n    }\n\n    @Test\n    void testPingReturnsTrueAfterMultipleSignInsAndSignOuts() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        ClientInterface clientInterface = new ClientInterfaceImpl();\n        String emailAddr1 = \"test1@example.com\";\n        String emailAddr2 = \"test2@example.com\";\n        String password = \"password123\";\n        String ipAddress = \"192.168.1.1\";\n        try {\n            LoginBean loginBean1 = modernChatServer.signIn(clientInterface, emailAddr1, password, ipAddress);\n            assertNotNull(loginBean1);\n            User user1 = loginBean1.getUser();\n            modernChatServer.signOut(user1);\n\n            LoginBean loginBean2 = modernChatServer.signIn(clientInterface, emailAddr2, password, ipAddress);\n            assertNotNull(loginBean2);\n            User user2 = loginBean2.getUser();\n            modernChatServer.signOut(user2);\n\n            boolean result = modernChatServer.ping();\n            assertTrue(result);\n        } catch (RemoteException e) {\n            fail(\"Exception thrown during sign in or sign out: \" + e.getMessage());\n        }\n    }\n\n    @Test\n    void testPingReturnsTrueAfterMultipleUsersSignInAndSignOut() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        ClientInterface clientInterface = new ClientInterfaceImpl();\n        String password = \"password123\";\n        String ipAddress = \"192.168.1.1\";\n        try {\n            for (int i = 1; i <= 5; i++) {\n                String emailAddr = \"test\" + i + \"@example.com\";\n                LoginBean loginBean = modernChatServer.signIn(clientInterface, emailAddr, password, ipAddress);\n                assertNotNull(loginBean);\n                User user = loginBean.getUser();\n                modernChatServer.signOut(user);\n            }\n\n            boolean result = modernChatServer.ping();\n            assertTrue(result);\n        } catch (RemoteException e) {\n            fail(\"Exception thrown during sign in or sign out: \" + e.getMessage());\n        }\n    }\n\n    @Test\n    void testPingReturnsTrueAfterKickOffUser() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        ClientInterface clientInterface = new ClientInterfaceImpl();\n        String emailAddr = \"test@example.com\";\n        String password = \"password123\";\n        String ipAddress = \"192.168.1.1\";\n        try {\n            LoginBean loginBean = modernChatServer.signIn(clientInterface, emailAddr, password, ipAddress);\n            assertNotNull(loginBean);\n            User user = loginBean.getUser();\n            modernChatServer.kickOffUser(user.getId(), modernChatServer.getAuthToken());\n            boolean result = modernChatServer.ping();\n            assertTrue(result);\n        } catch (RemoteException e) {\n            fail(\"Exception thrown during sign in or kick off: \" + e.getMessage());\n        }\n    }\n\n    @Test\n    void testPingReturnsTrueAfterKickOffUsers() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        ClientInterface clientInterface = new ClientInterfaceImpl();\n        String password = \"password123\";\n        String ipAddress = \"192.168.1.1\";\n        try {\n            for (int i = 1; i <= 5; i++) {\n                String emailAddr = \"test\" + i + \"@example.com\";\n                LoginBean loginBean = modernChatServer.signIn(clientInterface, emailAddr, password, ipAddress);\n                assertNotNull(loginBean);\n            }\n\n            modernChatServer.kickOffUsers(\"Justification\", modernChatServer.getAuthToken());\n            boolean result = modernChatServer.ping();\n            assertTrue(result);\n        } catch (RemoteException e) {\n            fail(\"Exception thrown during sign in or kick off: \" + e.getMessage());\n        }\n    }\n\n    @Test\n    void testPingReturnsTrueAfterShutdownServer() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        ClientInterface clientInterface = new ClientInterfaceImpl();\n        String password = \"password123\";\n        String ipAddress = \"192.168.1.1\";\n        try {\n            for (int i = 1; i <= 5; i++) {\n                String emailAddr = \"test\" + i + \"@example.com\";\n                LoginBean loginBean = modernChatServer.signIn(clientInterface, emailAddr, password, ipAddress);\n                assertNotNull(loginBean);\n            }\n\n            modernChatServer.shutdownServer(\"Justification\", modernChatServer.getAuthToken());\n            boolean result = modernChatServer.ping();\n            assertTrue(result);\n        } catch (RemoteException e) {\n            fail(\"Exception thrown during sign in or shutdown: \" + e.getMessage());\n        }\n    }\n\n    @Test\n    void testPingReturnsTrueAfterRefreshContactList() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        ClientInterface clientInterface = new ClientInterfaceImpl();\n        String password = \"password123\";\n        String ipAddress = \"192.168.1.1\";\n        try {\n            for (int i = 1; i <= 5; i++) {\n                String emailAddr = \"test\" + i + \"@example.com\";\n                LoginBean loginBean = modernChatServer.signIn(clientInterface, emailAddr, password, ipAddress);\n                assertNotNull(loginBean);\n            }\n\n            modernChatServer.refreshContactList(modernChatServer.getAuthToken());\n            boolean result = modernChatServer.ping();\n            assertTrue(result);\n        } catch (RemoteException e) {\n            fail(\"Exception thrown during sign in or refresh contact list: \" + e.getMessage());\n        }\n    }\n\n    private static class ClientInterfaceImpl implements ClientInterface {\n        @Override\n        public boolean ping() {\n            return true;\n        }\n\n        @Override\n        public boolean receiveTextMessage(TextMessage msg) {\n            return true;\n        }\n\n        @Override\n        public boolean receiveSecureTextMessage(TextMessage msg) {\n            return true;\n        }\n\n        @Override\n        public ResultBean receiveBinaryMessageRequest(BinaryMessage msg) {\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n\n        @Override\n        public void receiveBinaryMessageLoad(BinaryMessage msg) {\n            // do nothing\n        }\n\n        @Override\n        public ResultBean receiveSecureBinaryMessageRequest(BinaryMessage msg) {\n            return new ResultBean(true, IConstant.SUCCESS, null);\n        }\n\n        @Override\n        public void receiveSecureBinaryMessageLoad(BinaryMessage msg) {\n            // do nothing\n        }\n\n        @Override\n        public void receiveTextAnnouncement(TextMessage msg) {\n            // do nothing\n        }\n\n        @Override\n        public void receiveSecureTextAnnouncement(TextMessage msg) {\n            // do nothing\n        }\n    }\n}\n```",
                "refusal": null
            },
            "logprobs": null,
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 11829,
        "completion_tokens": 1726,
        "total_tokens": 13555
    },
    "system_fingerprint": null,
    "time_taken": 28.629977464675903,
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_1Test.java",
    "original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
    "test_prompt": "// ModernChatServer_1Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#ping()} method.\n*/\nclass ModernChatServer_1Test {"
}
,{
    "id": "chatcmpl-A5Ve1aVzCiOXekHLAXM7rfn5lf72M",
    "object": "chat.completion",
    "created": 1725876645,
    "model": "gpt-3.5-turbo-0125",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "```java\nclass ModernChatServer_2Test {\n\n    @Test\n    void testSignIn_ValidCredentials() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        ClientInterface cf = null;\n        String emailAddr = \"test@example.com\";\n        String password = \"password123\";\n        String ipAddress = \"192.168.1.1\";\n\n        try {\n            LoginBean loginBean = modernChatServer.signIn(cf, emailAddr, password, ipAddress);\n            assertNotNull(loginBean);\n            assertNotNull(loginBean.getUser());\n        } catch (RemoteException e) {\n            fail(\"Exception thrown: \" + e.getMessage());\n        }\n    }\n\n    @Test\n    void testSignIn_InvalidCredentials() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        ClientInterface cf = null;\n        String emailAddr = \"invalid@example.com\";\n        String password = \"invalidpassword\";\n        String ipAddress = \"192.168.1.1\";\n\n        try {\n            LoginBean loginBean = modernChatServer.signIn(cf, emailAddr, password, ipAddress);\n            assertNull(loginBean);\n        } catch (RemoteException e) {\n            fail(\"Exception thrown: \" + e.getMessage());\n        }\n    }\n\n    @Test\n    void testSignIn_NullCredentials() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        ClientInterface cf = null;\n        String emailAddr = null;\n        String password = null;\n        String ipAddress = null;\n\n        try {\n            LoginBean loginBean = modernChatServer.signIn(cf, emailAddr, password, ipAddress);\n            assertNull(loginBean);\n        } catch (RemoteException e) {\n            fail(\"Exception thrown: \" + e.getMessage());\n        }\n    }\n\n    @Test\n    void testSignIn_NullEmail() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        ClientInterface cf = null;\n        String emailAddr = null;\n        String password = \"password123\";\n        String ipAddress = \"192.168.1.1\";\n\n        try {\n            LoginBean loginBean = modernChatServer.signIn(cf, emailAddr, password, ipAddress);\n            assertNull(loginBean);\n        } catch (RemoteException e) {\n            fail(\"Exception thrown: \" + e.getMessage());\n        }\n    }\n\n    @Test\n    void testSignIn_NullPassword() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        ClientInterface cf = null;\n        String emailAddr = \"test@example.com\";\n        String password = null;\n        String ipAddress = \"192.168.1.1\";\n\n        try {\n            LoginBean loginBean = modernChatServer.signIn(cf, emailAddr, password, ipAddress);\n            assertNull(loginBean);\n        } catch (RemoteException e) {\n            fail(\"Exception thrown: \" + e.getMessage());\n        }\n    }\n\n    @Test\n    void testSignIn_NullIPAddress() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        ClientInterface cf = null;\n        String emailAddr = \"test@example.com\";\n        String password = \"password123\";\n        String ipAddress = null;\n\n        try {\n            LoginBean loginBean = modernChatServer.signIn(cf, emailAddr, password, ipAddress);\n            assertNull(loginBean);\n        } catch (RemoteException e) {\n            fail(\"Exception thrown: \" + e.getMessage());\n        }\n    }\n\n    @Test\n    void testSignIn_EmptyCredentials() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        ClientInterface cf = null;\n        String emailAddr = \"\";\n        String password = \"\";\n        String ipAddress = \"\";\n\n        try {\n            LoginBean loginBean = modernChatServer.signIn(cf, emailAddr, password, ipAddress);\n            assertNull(loginBean);\n        } catch (RemoteException e) {\n            fail(\"Exception thrown: \" + e.getMessage());\n        }\n    }\n\n    @Test\n    void testSignIn_ValidCredentials_ReturnsUser() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        ClientInterface cf = null;\n        String emailAddr = \"test@example.com\";\n        String password = \"password123\";\n        String ipAddress = \"192.168.1.1\";\n\n        try {\n            LoginBean loginBean = modernChatServer.signIn(cf, emailAddr, password, ipAddress);\n            assertNotNull(loginBean);\n            assertNotNull(loginBean.getUser());\n            assertEquals(emailAddr, loginBean.getUser().getEmail());\n        } catch (RemoteException e) {\n            fail(\"Exception thrown: \" + e.getMessage());\n        }\n    }\n\n    @Test\n    void testSignIn_ValidCredentials_ReturnsAuthToken() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        ClientInterface cf = null;\n        String emailAddr = \"test@example.com\";\n        String password = \"password123\";\n        String ipAddress = \"192.168.1.1\";\n\n        try {\n            LoginBean loginBean = modernChatServer.signIn(cf, emailAddr, password, ipAddress);\n            assertNotNull(loginBean);\n            assertNotNull(loginBean.getAuthToken());\n        } catch (RemoteException e) {\n            fail(\"Exception thrown: \" + e.getMessage());\n        }\n    }\n}\n```",
                "refusal": null
            },
            "logprobs": null,
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 11837,
        "completion_tokens": 1038,
        "total_tokens": 12875
    },
    "system_fingerprint": null,
    "time_taken": 17.258126735687256,
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_2Test.java",
    "original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
    "test_prompt": "// ModernChatServer_2Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#signIn(ClientInterface, String, String, String)} method.\n*/\nclass ModernChatServer_2Test {"
}
,{
    "id": "chatcmpl-A5Vf4VwpKNNBfM3csXIrOFjqWpEAQ",
    "object": "chat.completion",
    "created": 1725876710,
    "model": "gpt-3.5-turbo-0125",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "```java\nclass ModernChatServer_3Test {\n\n    @Test\n    void testChangePassword_Success() {\n        ModernChatServer server = new ModernChatServer();\n        User user = new User();\n        user.setId(1);\n        String email = \"test@example.com\";\n        String oldPass = \"oldPassword\";\n        String newPass = \"newPassword\";\n        ResultBean result = server.changePassword(email, oldPass, newPass);\n        assertTrue(result.isSuccess());\n    }\n\n    @Test\n    void testChangePassword_InvalidPassword() {\n        ModernChatServer server = new ModernChatServer();\n        User user = new User();\n        user.setId(1);\n        String email = \"test@example.com\";\n        String oldPass = \"invalidPassword\";\n        String newPass = \"newPassword\";\n        ResultBean result = server.changePassword(email, oldPass, newPass);\n        assertFalse(result.isSuccess());\n        assertEquals(IConstant.ERROR, result.getCode());\n    }\n\n    @Test\n    void testChangePassword_NullCredentials() {\n        ModernChatServer server = new ModernChatServer();\n        String email = null;\n        String oldPass = null;\n        String newPass = null;\n        ResultBean result = server.changePassword(email, oldPass, newPass);\n        assertNull(result);\n    }\n\n    @Test\n    void testChangePassword_AdminUser() {\n        ModernChatServer server = new ModernChatServer();\n        User adminUser = server.getAdminUser();\n        String email = adminUser.getEmail();\n        String oldPass = \"adminPassword\";\n        String newPass = \"newAdminPassword\";\n        ResultBean result = server.changePassword(email, oldPass, newPass);\n        assertTrue(result.isSuccess());\n    }\n\n    @Test\n    void testChangePassword_UpdatePassword() {\n        ModernChatServer server = new ModernChatServer();\n        User user = new User();\n        user.setId(1);\n        String email = \"test@example.com\";\n        String oldPass = \"oldPassword\";\n        String newPass = \"newPassword\";\n        server.changePassword(email, oldPass, newPass);\n        User updatedUser = server.authenticateUser(email, newPass);\n        assertNotNull(updatedUser);\n    }\n\n    @Test\n    void testChangePassword_AdminUserUpdatePassword() {\n        ModernChatServer server = new ModernChatServer();\n        User adminUser = server.getAdminUser();\n        String email = adminUser.getEmail();\n        String oldPass = \"adminPassword\";\n        String newPass = \"newAdminPassword\";\n        server.changePassword(email, oldPass, newPass);\n        User updatedAdminUser = server.authenticateUser(email, newPass);\n        assertNotNull(updatedAdminUser);\n    }\n\n    @Test\n    void testChangePassword_InvalidAuthToken() {\n        ModernChatServer server = new ModernChatServer();\n        String authToken = \"invalidToken\";\n        String email = \"test@example.com\";\n        String oldPass = \"oldPassword\";\n        String newPass = \"newPassword\";\n        assertThrows(RemoteException.class, () -> {\n            server.changePassword(email, oldPass, newPass, authToken);\n        });\n    }\n\n    @Test\n    void testChangePassword_NullResult() {\n        ModernChatServer server = new ModernChatServer();\n        User user = new User();\n        user.setId(1);\n        String email = \"test@example.com\";\n        String oldPass = \"oldPassword\";\n        String newPass = \"newPassword\";\n        ResultBean result = server.changePassword(email, oldPass, newPass);\n        assertNull(result.getMessage());\n    }\n\n    @Test\n    void testChangePassword_UpdatePasswordFailure() {\n        ModernChatServer server = new ModernChatServer();\n        User user = new User();\n        user.setId(1);\n        String email = \"test@example.com\";\n        String oldPass = \"oldPassword\";\n        String newPass = \"newPassword\";\n        server.changePassword(email, oldPass, newPass);\n        User updatedUser = server.authenticateUser(email, oldPass);\n        assertNull(updatedUser);\n    }\n}\n```",
                "refusal": null
            },
            "logprobs": null,
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 11835,
        "completion_tokens": 813,
        "total_tokens": 12648
    },
    "system_fingerprint": null,
    "time_taken": 16.097042083740234,
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_3Test.java",
    "original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
    "test_prompt": "// ModernChatServer_3Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#changePassword(String, String, String)} method.\n*/\nclass ModernChatServer_3Test {"
}
,{
    "id": "chatcmpl-A5Vg7XQAvF4UkD29ERsjizoheAhpo",
    "object": "chat.completion",
    "created": 1725876775,
    "model": "gpt-3.5-turbo-0125",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "```java\npublic class ModernChatServer_4Test {\n\n    @Test\n    void testChangeAdminPassword_Success() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        String emailAddr = \"admin@example.com\";\n        String oldPass = \"oldPassword\";\n        String newPass = \"newPassword\";\n        ResultBean result = modernChatServer.changeAdminPassword(emailAddr, oldPass, newPass);\n        assertTrue(result.isSuccess());\n    }\n\n    @Test\n    void testChangeAdminPassword_InvalidPassword() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        String emailAddr = \"admin@example.com\";\n        String oldPass = \"invalidPassword\";\n        String newPass = \"newPassword\";\n        ResultBean result = modernChatServer.changeAdminPassword(emailAddr, oldPass, newPass);\n        assertFalse(result.isSuccess());\n        assertEquals(\"Invalid Password!\", result.getMessage());\n    }\n\n    @Test\n    void testChangeAdminPassword_Error() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        String emailAddr = \"admin@example.com\";\n        String oldPass = \"oldPassword\";\n        String newPass = \"newPassword\";\n        // Simulate an error during password update\n        modernChatServer.getServerSettingBean().setServerURL(null);\n        ResultBean result = modernChatServer.changeAdminPassword(emailAddr, oldPass, newPass);\n        assertFalse(result.isSuccess());\n        assertEquals(\"Error During Applying New Password!\", result.getMessage());\n    }\n\n    @Test\n    void testChangeAdminPassword_NullCredentials() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        ResultBean result = modernChatServer.changeAdminPassword(null, null, null);\n        assertNull(result);\n    }\n\n    @Test\n    void testChangeAdminPassword_InvalidToken() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        String emailAddr = \"admin@example.com\";\n        String oldPass = \"oldPassword\";\n        String newPass = \"newPassword\";\n        assertThrows(RemoteException.class, () -> modernChatServer.changeAdminPassword(emailAddr, oldPass, newPass, \"invalidToken\"));\n    }\n\n    @Test\n    void testChangeAdminPassword_NullUser() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        String emailAddr = \"invalid@example.com\";\n        String oldPass = \"oldPassword\";\n        String newPass = \"newPassword\";\n        ResultBean result = modernChatServer.changeAdminPassword(emailAddr, oldPass, newPass);\n        assertNull(result);\n    }\n\n    @Test\n    void testChangeAdminPassword_NullUserPassword() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        String emailAddr = \"admin@example.com\";\n        String oldPass = \"oldPassword\";\n        String newPass = \"newPassword\";\n        modernChatServer.getPasswords().put(1000, null);\n        ResultBean result = modernChatServer.changeAdminPassword(emailAddr, oldPass, newPass);\n        assertFalse(result.isSuccess());\n        assertEquals(\"Invalid Password!\", result.getMessage());\n    }\n\n    @Test\n    void testChangeAdminPassword_NullUserEmail() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        String emailAddr = null;\n        String oldPass = \"oldPassword\";\n        String newPass = \"newPassword\";\n        ResultBean result = modernChatServer.changeAdminPassword(emailAddr, oldPass, newPass);\n        assertFalse(result.isSuccess());\n        assertEquals(\"Invalid Password!\", result.getMessage());\n    }\n\n    @Test\n    void testChangeAdminPassword_NullOldPassword() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        String emailAddr = \"admin@example.com\";\n        String oldPass = null;\n        String newPass = \"newPassword\";\n        ResultBean result = modernChatServer.changeAdminPassword(emailAddr, oldPass, newPass);\n        assertFalse(result.isSuccess());\n        assertEquals(\"Invalid Password!\", result.getMessage());\n    }\n\n    @Test\n    void testChangeAdminPassword_NullNewPassword() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        String emailAddr = \"admin@example.com\";\n        String oldPass = \"oldPassword\";\n        String newPass = null;\n        ResultBean result = modernChatServer.changeAdminPassword(emailAddr, oldPass, newPass);\n        assertFalse(result.isSuccess());\n        assertEquals(\"Invalid Password!\", result.getMessage());\n    }\n}\n```",
                "refusal": null
            },
            "logprobs": null,
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 11836,
        "completion_tokens": 897,
        "total_tokens": 12733
    },
    "system_fingerprint": null,
    "time_taken": 15.086920738220215,
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_4Test.java",
    "original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
    "test_prompt": "// ModernChatServer_4Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#changeAdminPassword(String, String, String)} method.\n*/\nclass ModernChatServer_4Test {"
}
,{
    "id": "chatcmpl-A5VhAANmuOfa9IT7SFtTbgirZuL8g",
    "object": "chat.completion",
    "created": 1725876840,
    "model": "gpt-3.5-turbo-0125",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "```java\nclass ModernChatServer_7Test {\n\n    @Test\n    void testSendSecureTextMessage_UserChat_Success() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        TextMessage textMessage = new TextMessage();\n        textMessage.setTargetType(IConstant.USER_CHAT);\n        textMessage.setToUserId(1);\n        textMessage.setFromUserId(2);\n        textMessage.setMessage(\"Test message\");\n\n        boolean result = modernChatServer.sendSecureTextMessage(textMessage);\n\n        assertTrue(result);\n    }\n\n    @Test\n    void testSendSecureTextMessage_GroupChat_Success() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        TextMessage textMessage = new TextMessage();\n        textMessage.setTargetType(IConstant.GROUP_CHAT);\n        textMessage.setToUserId(1);\n        textMessage.setFromUserId(2);\n        textMessage.setMessage(\"Test message\");\n\n        boolean result = modernChatServer.sendSecureTextMessage(textMessage);\n\n        assertTrue(result);\n    }\n\n    @Test\n    void testSendSecureTextMessage_RoomChat_Success() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        TextMessage textMessage = new TextMessage();\n        textMessage.setTargetType(IConstant.ROOM_CHAT);\n        textMessage.setToUserId(1);\n        textMessage.setFromUserId(2);\n        textMessage.setMessage(\"Test message\");\n\n        boolean result = modernChatServer.sendSecureTextMessage(textMessage);\n\n        assertTrue(result);\n    }\n\n    @Test\n    void testSendSecureTextMessage_UserChat_Failure() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        TextMessage textMessage = new TextMessage();\n        textMessage.setTargetType(IConstant.USER_CHAT);\n        textMessage.setToUserId(1);\n        textMessage.setFromUserId(2);\n        textMessage.setMessage(\"Test message\");\n\n        boolean result = modernChatServer.sendSecureTextMessage(textMessage);\n\n        assertFalse(result);\n    }\n\n    @Test\n    void testSendSecureTextMessage_GroupChat_Failure() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        TextMessage textMessage = new TextMessage();\n        textMessage.setTargetType(IConstant.GROUP_CHAT);\n        textMessage.setToUserId(1);\n        textMessage.setFromUserId(2);\n        textMessage.setMessage(\"Test message\");\n\n        boolean result = modernChatServer.sendSecureTextMessage(textMessage);\n\n        assertFalse(result);\n    }\n\n    @Test\n    void testSendSecureTextMessage_RoomChat_Failure() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        TextMessage textMessage = new TextMessage();\n        textMessage.setTargetType(IConstant.ROOM_CHAT);\n        textMessage.setToUserId(1);\n        textMessage.setFromUserId(2);\n        textMessage.setMessage(\"Test message\");\n\n        boolean result = modernChatServer.sendSecureTextMessage(textMessage);\n\n        assertFalse(result);\n    }\n\n    @Test\n    void testSendSecureTextMessage_NullMessage() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n\n        boolean result = modernChatServer.sendSecureTextMessage(null);\n\n        assertFalse(result);\n    }\n\n    @Test\n    void testSendSecureTextMessage_NullClientInterface() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        TextMessage textMessage = new TextMessage();\n        textMessage.setTargetType(IConstant.USER_CHAT);\n        textMessage.setToUserId(1);\n        textMessage.setFromUserId(2);\n        textMessage.setMessage(\"Test message\");\n\n        boolean result = modernChatServer.sendSecureTextMessageToUser(textMessage, null);\n\n        assertFalse(result);\n    }\n\n    @Test\n    void testSendSecureTextMessageToUser_Success() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        TextMessage textMessage = new TextMessage();\n        textMessage.setTargetType(IConstant.USER_CHAT);\n        textMessage.setToUserId(1);\n        textMessage.setFromUserId(2);\n        textMessage.setMessage(\"Test message\");\n\n        boolean result = modernChatServer.sendSecureTextMessageToUser(textMessage, new ClientInterface() {\n            @Override\n            public boolean receiveSecureTextMessage(TextMessage msg) {\n                return true;\n            }\n        });\n\n        assertTrue(result);\n    }\n\n    @Test\n    void testSendSecureTextMessageToUser_Failure() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        TextMessage textMessage = new TextMessage();\n        textMessage.setTargetType(IConstant.USER_CHAT);\n        textMessage.setToUserId(1);\n        textMessage.setFromUserId(2);\n        textMessage.setMessage(\"Test message\");\n\n        boolean result = modernChatServer.sendSecureTextMessageToUser(textMessage, new ClientInterface() {\n            @Override\n            public boolean receiveSecureTextMessage(TextMessage msg) {\n                return false;\n            }\n        });\n\n        assertFalse(result);\n    }\n}\n```",
                "refusal": null
            },
            "logprobs": null,
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 11834,
        "completion_tokens": 991,
        "total_tokens": 12825
    },
    "system_fingerprint": null,
    "time_taken": 18.772169828414917,
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_7Test.java",
    "original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
    "test_prompt": "// ModernChatServer_7Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#sendSecureTextMessage(TextMessage)} method.\n*/\nclass ModernChatServer_7Test {"
}
,{
    "id": "chatcmpl-A5ViDP5hpGgDro2jEraStqVxRbMDk",
    "object": "chat.completion",
    "created": 1725876905,
    "model": "gpt-3.5-turbo-0125",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "```java\nclass ModernChatServer_8Test {\n\n    @Test\n    void testSendBinaryMessage_WhenTargetTypeIsUserChat_ThenReturnTrue() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        BinaryMessage binaryMessage = new BinaryMessage();\n        binaryMessage.setToUserId(1);\n        binaryMessage.setAction(IConstant.REQUEST);\n        boolean result = modernChatServer.sendBinaryMessage(binaryMessage);\n        assertTrue(result);\n    }\n\n    @Test\n    void testSendBinaryMessage_WhenTargetTypeIsGroupChat_ThenReturnTrue() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        BinaryMessage binaryMessage = new BinaryMessage();\n        binaryMessage.setToUserId(1);\n        binaryMessage.setAction(IConstant.REQUEST);\n        binaryMessage.setTargetType(IConstant.GROUP_CHAT);\n        boolean result = modernChatServer.sendBinaryMessage(binaryMessage);\n        assertTrue(result);\n    }\n\n    @Test\n    void testSendBinaryMessage_WhenTargetTypeIsRoomChat_ThenReturnTrue() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        BinaryMessage binaryMessage = new BinaryMessage();\n        binaryMessage.setToUserId(1);\n        binaryMessage.setAction(IConstant.REQUEST);\n        binaryMessage.setTargetType(IConstant.ROOM_CHAT);\n        boolean result = modernChatServer.sendBinaryMessage(binaryMessage);\n        assertTrue(result);\n    }\n\n    @Test\n    void testSendBinaryMessage_WhenTargetTypeIsInvalid_ThenReturnFalse() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        BinaryMessage binaryMessage = new BinaryMessage();\n        binaryMessage.setToUserId(1);\n        binaryMessage.setAction(IConstant.REQUEST);\n        binaryMessage.setTargetType(100);\n        boolean result = modernChatServer.sendBinaryMessage(binaryMessage);\n        assertFalse(result);\n    }\n\n    @Test\n    void testSendBinaryMessage_WhenClientInterfaceIsNull_ThenReturnFalse() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        BinaryMessage binaryMessage = new BinaryMessage();\n        binaryMessage.setToUserId(1);\n        binaryMessage.setAction(IConstant.REQUEST);\n        assertFalse(modernChatServer.sendBinaryMessage(binaryMessage));\n    }\n\n    @Test\n    void testSendBinaryMessage_WhenClientInterfaceThrowsRemoteException_ThenReturnFalse() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        BinaryMessage binaryMessage = new BinaryMessage();\n        binaryMessage.setToUserId(1);\n        binaryMessage.setAction(IConstant.REQUEST);\n        ClientInterface clientInterface = new ClientInterface() {\n            @Override\n            public boolean ping() throws RemoteException {\n                throw new RemoteException(\"Test Exception\");\n            }\n\n            @Override\n            public boolean receiveBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\n                return false;\n            }\n\n            @Override\n            public void receiveBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\n            }\n\n            @Override\n            public boolean receiveSecureBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\n                return false;\n            }\n\n            @Override\n            public void receiveSecureBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\n            }\n\n            @Override\n            public void receiveTextAnnouncement(TextMessage msg) throws RemoteException {\n            }\n\n            @Override\n            public boolean receiveTextMessage(TextMessage msg) throws RemoteException {\n                return false;\n            }\n\n            @Override\n            public boolean receiveSecureTextAnnouncement(TextMessage msg) throws RemoteException {\n                return false;\n            }\n\n            @Override\n            public boolean receiveSecureTextMessage(TextMessage msg) throws RemoteException {\n                return false;\n            }\n        };\n        modernChatServer.connectedClients.put(1, clientInterface);\n        assertFalse(modernChatServer.sendBinaryMessage(binaryMessage));\n    }\n\n    @Test\n    void testSendBinaryMessage_WhenActionIsNotRequest_ThenReturnFalse() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        BinaryMessage binaryMessage = new BinaryMessage();\n        binaryMessage.setToUserId(1);\n        binaryMessage.setAction(0);\n        assertFalse(modernChatServer.sendBinaryMessage(binaryMessage));\n    }\n\n    @Test\n    void testSendBinaryMessage_WhenActionIsRequestAndClientInterfaceReceivesRequest_ThenReturnTrue() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        BinaryMessage binaryMessage = new BinaryMessage();\n        binaryMessage.setToUserId(1);\n        binaryMessage.setAction(IConstant.REQUEST);\n        ClientInterface clientInterface = new ClientInterface() {\n            @Override\n            public boolean ping() throws RemoteException {\n                return true;\n            }\n\n            @Override\n            public boolean receiveBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\n                return true;\n            }\n\n            @Override\n            public void receiveBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\n            }\n\n            @Override\n            public boolean receiveSecureBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\n                return true;\n            }\n\n            @Override\n            public void receiveSecureBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\n            }\n\n            @Override\n            public void receiveTextAnnouncement(TextMessage msg) throws RemoteException {\n            }\n\n            @Override\n            public boolean receiveTextMessage(TextMessage msg) throws RemoteException {\n                return true;\n            }\n\n            @Override\n            public boolean receiveSecureTextAnnouncement(TextMessage msg) throws RemoteException {\n                return true;\n            }\n\n            @Override\n            public boolean receiveSecureTextMessage(TextMessage msg) throws RemoteException {\n                return true;\n            }\n        };\n        modernChatServer.connectedClients.put(1, clientInterface);\n        assertTrue(modernChatServer.sendBinaryMessage(binaryMessage));\n    }\n\n    @Test\n    void testSendBinaryMessage_WhenActionIsRequestAndClientInterfaceReceivesRequestReturnsFalse_ThenReturnFalse() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        BinaryMessage binaryMessage = new BinaryMessage();\n        binaryMessage.setToUserId(1);\n        binaryMessage.setAction(IConstant.REQUEST);\n        ClientInterface clientInterface = new ClientInterface() {\n            @Override\n            public boolean ping() throws RemoteException {\n                return true;\n            }\n\n            @Override\n            public boolean receiveBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\n                return false;\n            }\n\n            @Override\n            public void receiveBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\n            }\n\n            @Override\n            public boolean receiveSecureBinaryMessageRequest(BinaryMessage msg) throws RemoteException {\n                return false;\n            }\n\n            @Override\n            public void receiveSecureBinaryMessageLoad(BinaryMessage msg) throws RemoteException {\n            }\n\n            @Override\n            public void receiveTextAnnouncement(TextMessage msg) throws RemoteException {\n            }\n\n            @Override\n            public boolean receiveTextMessage(TextMessage msg) throws RemoteException {\n                return true;\n            }\n\n            @Override\n            public boolean receiveSecureTextAnnouncement(TextMessage msg) throws RemoteException {\n                return true;\n            }\n\n            @Override\n            public boolean receiveSecureTextMessage(TextMessage msg) throws RemoteException {\n                return true;\n            }\n        };\n        modernChatServer.connectedClients.put(1, clientInterface);\n        assertFalse(modernChatServer.sendBinaryMessage(binaryMessage));\n    }\n}\n```",
                "refusal": null
            },
            "logprobs": null,
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 11833,
        "completion_tokens": 1439,
        "total_tokens": 13272
    },
    "system_fingerprint": null,
    "time_taken": 25.104796409606934,
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_8Test.java",
    "original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
    "test_prompt": "// ModernChatServer_8Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#sendBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_8Test {"
}
,{
    "id": "chatcmpl-A5VjG4PCUkRt27Qxh7giOpyKYZf3d",
    "object": "chat.completion",
    "created": 1725876970,
    "model": "gpt-3.5-turbo-0125",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "```java\nclass ModernChatServer_9Test {\n\n    @Test\n    void testSendSecureBinaryMessage_UserChat_Success() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        BinaryMessage binaryMessage = new BinaryMessage();\n        binaryMessage.setToUserId(1);\n        binaryMessage.setFromUserId(2);\n        binaryMessage.setAction(IConstant.REQUEST);\n\n        boolean result = modernChatServer.sendSecureBinaryMessage(binaryMessage);\n\n        assertTrue(result);\n    }\n\n    @Test\n    void testSendSecureBinaryMessage_GroupChat_Success() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        BinaryMessage binaryMessage = new BinaryMessage();\n        binaryMessage.setToUserId(1);\n        binaryMessage.setFromUserId(2);\n        binaryMessage.setAction(IConstant.REQUEST);\n        binaryMessage.setTargetType(IConstant.GROUP_CHAT);\n\n        boolean result = modernChatServer.sendSecureBinaryMessage(binaryMessage);\n\n        assertTrue(result);\n    }\n\n    @Test\n    void testSendSecureBinaryMessage_RoomChat_Success() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        BinaryMessage binaryMessage = new BinaryMessage();\n        binaryMessage.setToUserId(1);\n        binaryMessage.setFromUserId(2);\n        binaryMessage.setAction(IConstant.REQUEST);\n        binaryMessage.setTargetType(IConstant.ROOM_CHAT);\n\n        boolean result = modernChatServer.sendSecureBinaryMessage(binaryMessage);\n\n        assertTrue(result);\n    }\n\n    @Test\n    void testSendSecureBinaryMessage_UserChat_Failure() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        BinaryMessage binaryMessage = new BinaryMessage();\n        binaryMessage.setToUserId(1);\n        binaryMessage.setFromUserId(2);\n        binaryMessage.setAction(IConstant.REQUEST);\n\n        boolean result = modernChatServer.sendSecureBinaryMessage(binaryMessage);\n\n        assertFalse(result);\n    }\n\n    @Test\n    void testSendSecureBinaryMessage_GroupChat_Failure() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        BinaryMessage binaryMessage = new BinaryMessage();\n        binaryMessage.setToUserId(1);\n        binaryMessage.setFromUserId(2);\n        binaryMessage.setAction(IConstant.REQUEST);\n        binaryMessage.setTargetType(IConstant.GROUP_CHAT);\n\n        boolean result = modernChatServer.sendSecureBinaryMessage(binaryMessage);\n\n        assertFalse(result);\n    }\n\n    @Test\n    void testSendSecureBinaryMessage_RoomChat_Failure() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        BinaryMessage binaryMessage = new BinaryMessage();\n        binaryMessage.setToUserId(1);\n        binaryMessage.setFromUserId(2);\n        binaryMessage.setAction(IConstant.REQUEST);\n        binaryMessage.setTargetType(IConstant.ROOM_CHAT);\n\n        boolean result = modernChatServer.sendSecureBinaryMessage(binaryMessage);\n\n        assertFalse(result);\n    }\n\n    @Test\n    void testSendSecureBinaryMessage_NullMessage() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n\n        assertThrows(RemoteException.class, () -> modernChatServer.sendSecureBinaryMessage(null));\n    }\n\n    @Test\n    void testSendSecureBinaryMessage_Exception() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        BinaryMessage binaryMessage = new BinaryMessage();\n        binaryMessage.setToUserId(1);\n        binaryMessage.setFromUserId(2);\n        binaryMessage.setAction(IConstant.REQUEST);\n\n        assertThrows(RemoteException.class, () -> modernChatServer.sendSecureBinaryMessage(binaryMessage));\n    }\n}\n```",
                "refusal": null
            },
            "logprobs": null,
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 11834,
        "completion_tokens": 705,
        "total_tokens": 12539
    },
    "system_fingerprint": null,
    "time_taken": 10.136739730834961,
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_9Test.java",
    "original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
    "test_prompt": "// ModernChatServer_9Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)} method.\n*/\nclass ModernChatServer_9Test {"
}
,{
    "id": "chatcmpl-A5VkJ2ZpgIsOEfssFoNMkhtMFcghb",
    "object": "chat.completion",
    "created": 1725877035,
    "model": "gpt-3.5-turbo-0125",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "```java\nclass ModernChatServer_11Test {\n\n    @Test\n    void testSendSecureTextAnnouncementToUser_WhenClientInterfaceIsNull_ExpectFalse() {\n        // Arrange\n        ModernChatServer modernChatServer = new ModernChatServer();\n        TextMessage msg = new TextMessage();\n        msg.setToUserId(1);\n        \n        // Act\n        boolean result = modernChatServer.sendSecureTextAnnouncementToUser(msg, null);\n        \n        // Assert\n        assertFalse(result);\n    }\n\n    @Test\n    void testSendSecureTextAnnouncementToUser_WhenClientInterfaceThrowsRemoteException_ExpectFalse() {\n        // Arrange\n        ModernChatServer modernChatServer = new ModernChatServer();\n        TextMessage msg = new TextMessage();\n        msg.setToUserId(1);\n        ClientInterface cf = new ClientInterface() {\n            @Override\n            public boolean receiveSecureTextAnnouncement(TextMessage msg) throws RemoteException {\n                throw new RemoteException(\"Test Exception\");\n            }\n        };\n        \n        // Act\n        boolean result = modernChatServer.sendSecureTextAnnouncementToUser(msg, cf);\n        \n        // Assert\n        assertFalse(result);\n    }\n\n    @Test\n    void testSendSecureTextAnnouncementToUser_WhenClientInterfaceReceivesMessage_ExpectTrue() {\n        // Arrange\n        ModernChatServer modernChatServer = new ModernChatServer();\n        TextMessage msg = new TextMessage();\n        msg.setToUserId(1);\n        ClientInterface cf = new ClientInterface() {\n            @Override\n            public boolean receiveSecureTextAnnouncement(TextMessage msg) throws RemoteException {\n                return true;\n            }\n        };\n        \n        // Act\n        boolean result = modernChatServer.sendSecureTextAnnouncementToUser(msg, cf);\n        \n        // Assert\n        assertTrue(result);\n    }\n\n    @Test\n    void testSendSecureTextAnnouncement_WhenMessageTypeIsUserChat_ExpectTrue() {\n        // Arrange\n        ModernChatServer modernChatServer = new ModernChatServer();\n        TextMessage msg = new TextMessage();\n        msg.setTargetType(IConstant.USER_CHAT);\n        msg.setToUserId(1);\n        ClientInterface cf = new ClientInterface() {\n            @Override\n            public boolean receiveSecureTextAnnouncement(TextMessage msg) throws RemoteException {\n                return true;\n            }\n        };\n        modernChatServer.getConnectedClients().put(1, cf);\n        \n        // Act\n        boolean result = modernChatServer.sendSecureTextAnnouncement(msg);\n        \n        // Assert\n        assertTrue(result);\n    }\n\n    @Test\n    void testSendSecureTextAnnouncement_WhenMessageTypeIsGroupChat_ExpectTrue() {\n        // Arrange\n        ModernChatServer modernChatServer = new ModernChatServer();\n        TextMessage msg = new TextMessage();\n        msg.setTargetType(IConstant.GROUP_CHAT);\n        msg.setToUserId(1);\n        ClientInterface cf = new ClientInterface() {\n            @Override\n            public boolean receiveSecureTextAnnouncement(TextMessage msg) throws RemoteException {\n                return true;\n            }\n        };\n        modernChatServer.getConnectedClients().put(1, cf);\n        \n        // Act\n        boolean result = modernChatServer.sendSecureTextAnnouncement(msg);\n        \n        // Assert\n        assertTrue(result);\n    }\n\n    @Test\n    void testSendSecureTextAnnouncement_WhenMessageTypeIsRoomChat_ExpectTrue() {\n        // Arrange\n        ModernChatServer modernChatServer = new ModernChatServer();\n        TextMessage msg = new TextMessage();\n        msg.setTargetType(IConstant.ROOM_CHAT);\n        msg.setToUserId(1);\n        ClientInterface cf = new ClientInterface() {\n            @Override\n            public boolean receiveSecureTextAnnouncement(TextMessage msg) throws RemoteException {\n                return true;\n            }\n        };\n        modernChatServer.getConnectedClients().put(1, cf);\n        \n        // Act\n        boolean result = modernChatServer.sendSecureTextAnnouncement(msg);\n        \n        // Assert\n        assertTrue(result);\n    }\n\n    @Test\n    void testSendSecureTextAnnouncement_WhenMessageTypeIsInvalid_ExpectFalse() {\n        // Arrange\n        ModernChatServer modernChatServer = new ModernChatServer();\n        TextMessage msg = new TextMessage();\n        msg.setTargetType(100);\n        \n        // Act\n        boolean result = modernChatServer.sendSecureTextAnnouncement(msg);\n        \n        // Assert\n        assertFalse(result);\n    }\n\n    @Test\n    void testSendSecureTextAnnouncement_WhenUserNotConnected_ExpectFalse() {\n        // Arrange\n        ModernChatServer modernChatServer = new ModernChatServer();\n        TextMessage msg = new TextMessage();\n        msg.setTargetType(IConstant.USER_CHAT);\n        msg.setToUserId(1);\n        \n        // Act\n        boolean result = modernChatServer.sendSecureTextAnnouncement(msg);\n        \n        // Assert\n        assertFalse(result);\n    }\n}\n```",
                "refusal": null
            },
            "logprobs": null,
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 11835,
        "completion_tokens": 993,
        "total_tokens": 12828
    },
    "system_fingerprint": null,
    "time_taken": 13.991286754608154,
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_11Test.java",
    "original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
    "test_prompt": "// ModernChatServer_11Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#sendSecureTextAnnouncement(TextMessage)} method.\n*/\nclass ModernChatServer_11Test {"
}
,{
    "id": "chatcmpl-A5VlM1ST1inN6XwzShLU7QezRmkag",
    "object": "chat.completion",
    "created": 1725877100,
    "model": "gpt-3.5-turbo-0125",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "```java\nclass ModernChatServer_24Test {\n\n    @Test\n    void testSignInAsAdmin_ValidCredentials() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        String email = \"admin@example.com\";\n        String password = \"admin123\";\n        LoginBean loginBean = modernChatServer.signInAsAdmin(StringEncoder64.encodeStringUTF8(email), StringEncrypter.getInstance(\"FIS2009\").encrypt(password));\n        assertNotNull(loginBean);\n        assertEquals(\"System Admin\", loginBean.getUser().getUsername());\n    }\n\n    @Test\n    void testSignInAsAdmin_InvalidCredentials() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        String email = \"invalid@example.com\";\n        String password = \"invalid123\";\n        LoginBean loginBean = modernChatServer.signInAsAdmin(StringEncoder64.encodeStringUTF8(email), StringEncrypter.getInstance(\"FIS2009\").encrypt(password));\n        assertNull(loginBean);\n    }\n\n    @Test\n    void testSignInAsAdmin_NullCredentials() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        LoginBean loginBean = modernChatServer.signInAsAdmin(null, null);\n        assertNull(loginBean);\n    }\n\n    @Test\n    void testSignInAsAdmin_EmptyCredentials() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        LoginBean loginBean = modernChatServer.signInAsAdmin(\"\", \"\");\n        assertNull(loginBean);\n    }\n\n    @Test\n    void testSignInAsAdmin_IncorrectPassword() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        String email = \"admin@example.com\";\n        String password = \"incorrect\";\n        LoginBean loginBean = modernChatServer.signInAsAdmin(StringEncoder64.encodeStringUTF8(email), StringEncrypter.getInstance(\"FIS2009\").encrypt(password));\n        assertNull(loginBean);\n    }\n\n    @Test\n    void testSignInAsAdmin_NullEmail() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        String password = \"admin123\";\n        LoginBean loginBean = modernChatServer.signInAsAdmin(null, StringEncrypter.getInstance(\"FIS2009\").encrypt(password));\n        assertNull(loginBean);\n    }\n\n    @Test\n    void testSignInAsAdmin_NullPassword() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        String email = \"admin@example.com\";\n        LoginBean loginBean = modernChatServer.signInAsAdmin(StringEncoder64.encodeStringUTF8(email), null);\n        assertNull(loginBean);\n    }\n\n    @Test\n    void testSignInAsAdmin_EmptyEmail() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        String password = \"admin123\";\n        LoginBean loginBean = modernChatServer.signInAsAdmin(\"\", StringEncrypter.getInstance(\"FIS2009\").encrypt(password));\n        assertNull(loginBean);\n    }\n\n    @Test\n    void testSignInAsAdmin_EmptyPassword() {\n        ModernChatServer modernChatServer = new ModernChatServer();\n        String email = \"admin@example.com\";\n        LoginBean loginBean = modernChatServer.signInAsAdmin(StringEncoder64.encodeStringUTF8(email), \"\");\n        assertNull(loginBean);\n    }\n}\n```",
                "refusal": null
            },
            "logprobs": null,
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 11834,
        "completion_tokens": 651,
        "total_tokens": 12485
    },
    "system_fingerprint": null,
    "time_taken": 12.529191732406616,
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/ModernChatServer_24Test.java",
    "original_code": "// ModernChatServer.java\n/*\r\n * ModernChatServer.java\r\n *\r\n * Created on October 27, 2009, 12:20 AM\r\n *\r\n * To change this template, choose Tools | Template Manager\r\n * and open the template in the editor.\r\n */\r\npackage osa.ora.server;\r\n\r\nimport java.net.URISyntaxException;\r\nimport java.rmi.Naming;\r\nimport java.rmi.RemoteException;\r\nimport java.rmi.registry.LocateRegistry;\r\nimport java.rmi.registry.Registry;\r\nimport java.rmi.server.UnicastRemoteObject;\r\nimport java.util.Calendar;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Vector;\r\nimport java.util.logging.FileHandler;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport java.util.logging.SimpleFormatter;\r\nimport javax.swing.JOptionPane;\r\nimport osa.ora.server.bd.UsersBD;\r\nimport osa.ora.server.beans.BinaryMessage;\r\nimport osa.ora.server.beans.Group;\r\nimport osa.ora.server.beans.IConstant;\r\nimport osa.ora.server.beans.LoginBean;\r\nimport osa.ora.server.beans.ResultBean;\r\nimport osa.ora.server.beans.Room;\r\nimport osa.ora.server.beans.ServerSettingBean;\r\nimport osa.ora.server.beans.TextMessage;\r\nimport osa.ora.server.beans.User;\r\nimport osa.ora.server.client.ClientInterface;\r\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\r\nimport osa.ora.server.threads.SendKickOffMessageThread;\r\nimport osa.ora.server.threads.SendRefreshContactThread;\r\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\r\nimport osa.ora.server.utils.StringEncoder64;\r\nimport osa.ora.server.utils.StringEncrypter;\r\n\r\n/**\r\n * @author ooransa\r\n * Class implements 2 interfaces:\r\n * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.\r\n * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used\r\n * As the RMI view of the server for the connected client.\r\n */\r\npublic class ModernChatServer implements ServerInterface, Runnable {\r\n\r\n    //Logger object\r\n    private static Logger logger = Logger.getLogger(\"ModernChatServer\");\r\n\r\n    private static FileHandler fh;\r\n\r\n    private String authToken;\r\n\r\n    private String clientAuthToken;\r\n\r\n    private String secToken;\r\n\r\n    private StringEncrypter passwordEnc;\r\n\r\n    /**\r\n     * @return the logger\r\n     */\r\n    public static Logger getLogger() {\r\n        return logger;\r\n    }\r\n\r\n    //password, groups and rooms hashtable\r\n    private Hashtable<Integer, String> passwords;\r\n\r\n    private Vector<Group> groups;\r\n\r\n    private Vector<Room> rooms;\r\n\r\n    //admin user object\r\n    private User adminUser;\r\n\r\n    //connected clients connections\r\n    private Hashtable<Integer, ClientInterface> connectedClients;\r\n\r\n    private Hashtable<Integer, String> connectedClientsIPs;\r\n\r\n    //Business Deligate to load all data.\r\n    private UsersBD userBD;\r\n\r\n    private Thread checkupThread;\r\n\r\n    private boolean serverRunning = false;\r\n\r\n    //current run path\r\n    private String path = \"/\";\r\n\r\n    //security securityMode\r\n    private int securityMode = 0;\r\n\r\n    //server setting bean\r\n    private ServerSettingBean serverSettingBean;\r\n\r\n    //main method\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"Starting Modern Chat Server .....\");\r\n            ModernChatServer modernChatServer = new ModernChatServer();\r\n        } catch (Exception e) {\r\n            System.out.println(\"Non-Specific Exception occur\");\r\n            e.printStackTrace();\r\n            JOptionPane.showMessageDialog(null, \"Error in starting up the server:\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to start the RMI registry\r\n     * @throws Exception\r\n     */\r\n    private void startRMIRegistry() throws Exception {\r\n        //binding\r\n        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));\r\n        //Registry registry=LocateRegistry.getRegistry();\r\n        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);\r\n        //Naming.rebind(\"//localhost:1190/ModernChatServer\", c);\r\n        Naming.rebind(\"//\" + getServerSettingBean().getServerURL() + \":\" + getServerSettingBean().getServerPort() + \"/ModernChatServer\", c);\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ModernChatServer\r\n     */\r\n    public ModernChatServer() {\r\n        //security & authentication tokens\r\n        authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n        clientAuthToken = \"FI\" + Calendar.getInstance().getTimeInMillis();\r\n        secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n        passwordEnc = StringEncrypter.getInstance(\"FIS2009\");\r\n        //instantiate correct jar path\r\n        try {\r\n            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();\r\n            path = path.substring(0, path.lastIndexOf('/') + 1);\r\n            System.out.println(\"Path=\" + path);\r\n        } catch (URISyntaxException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        //instantiate setting Bean\r\n        serverSettingBean = new ServerSettingBean(path);\r\n        //set the logger according to settings\r\n        try {\r\n            fh = new FileHandler(path + \"/log%g.txt\", 1000000, 10, true);\r\n            fh.setFormatter(new SimpleFormatter());\r\n            logger.addHandler(fh);\r\n            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error while creating log file!\", ex);\r\n        }\r\n        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());\r\n        logger.log(Level.INFO, \"FIM Server IP and Port=\" + serverSettingBean.getServerURL() + \":\" + serverSettingBean.getServerPort());\r\n        //load groups/users table\r\n        try {\r\n            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"FIM Server Data Error!, Terminating ...!\", e);\r\n            System.exit(-1);\r\n        }\r\n        groups = userBD.loadGroupsAndUsers();\r\n        rooms = userBD.loadRooms();\r\n        passwords = userBD.getPasswords();\r\n        adminUser = userBD.getAdminUser();\r\n        logger.log(Level.INFO, \"Groups and Users loaded=\" + groups.size());\r\n        logger.log(Level.INFO, \"Rooms loaded=\" + rooms.size());\r\n        //initialize client connected...\r\n        connectedClients = new Hashtable<Integer, ClientInterface>();\r\n        connectedClientsIPs = new Hashtable<Integer, String>();\r\n        logger.log(Level.INFO, \"Starting FIM Server .....\");\r\n        try {\r\n            startRMIRegistry();\r\n        } catch (Exception ex) {\r\n            logger.log(Level.SEVERE, \"Error During starting RMI Registry!\", ex);\r\n            JOptionPane.showMessageDialog(null, \"Error During starting RMI Registry!:\" + ex.getMessage());\r\n            System.exit(1);\r\n        }\r\n        logger.log(Level.INFO, \"FIM Server Started.\");\r\n        JOptionPane.showMessageDialog(null, \"FIM Server Started Successfully!\");\r\n        //run checkup thread\r\n        checkupThread = new Thread(this);\r\n        serverRunning = true;\r\n        checkupThread.start();\r\n    }\r\n\r\n    /**\r\n     * any clinet ping it should receive true\r\n     * @return true always\r\n     */\r\n    public boolean ping() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Method to sing in ..\r\n     * @param cf : user client interface to communicate with the client\r\n     * @param emailAddr : user email\r\n     * @param password : user password\r\n     * @param ipAddress : user ip address\r\n     * @return User object if authentication correctly , or null if not exist.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {\r\n        LoginBean loginBean = null;\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null && ipAddress != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            //System.out.println(\"email=\"+email);\r\n            User user = authenticateUser(email, password);\r\n            if (user != null) {\r\n                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);\r\n                //System.out.println(\"ip=\"+ipAddress);\r\n                ClientInterface oldOne = connectedClients.get(user.getId());\r\n                if (oldOne != null) {\r\n                    String ipAdd = connectedClientsIPs.get(user.getId());\r\n                    if (ipAdd != null && ipAdd.equals(ipAddress)) {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    } else {\r\n                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);\r\n                        sendKickOffByLoginMessageThread.start();\r\n                    }\r\n                }\r\n                connectedClients.put(user.getId(), cf);\r\n                connectedClientsIPs.put(user.getId(), ipAddress);\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                loginBean = new LoginBean();\r\n                loginBean.setUser(user);\r\n                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                loginBean.setAuthToken(clientAuthToken);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * method to sign out\r\n     * @param user\r\n     * @throws RemoteException\r\n     */\r\n    public void signOut(User user) throws RemoteException {\r\n        //update user in the group list\r\n        if (user == null)\r\n            return;\r\n        connectedClients.remove(user.getId());\r\n        connectedClientsIPs.remove(user.getId());\r\n        user.setStatus_id(IConstant.SIGN_OUT);\r\n        updateUserStatus(user);\r\n    }\r\n\r\n    /**\r\n     * change user password\r\n     * @param email : user email\r\n     * @param oldPass : current password\r\n     * @param newPass : new password\r\n     * @return ResultBean with either true or false\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {\r\n        email = StringEncoder64.decodeStringUTF8(email);\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        User user = authenticateUser(email, newOldPass);\r\n        if (user == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {\r\n            passwords.put(user.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * Change admin password\r\n     * @param emailAddr : email of the admin\r\n     * @param oldPass   : current password\r\n     * @param newPass   : new password\r\n     * @return ResultBean : return status\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {\r\n        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);\r\n        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);\r\n        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);\r\n        if (loginBean == null) {\r\n            return new ResultBean(false, IConstant.ERROR, \"Invalid Password!\");\r\n        }\r\n        oldPass = passwordEnc.encrypt(oldPass);\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {\r\n            passwords.put(adminUser.getId(), newPass);\r\n            return new ResultBean(true, IConstant.SUCCESS, null);\r\n        }\r\n        return new ResultBean(false, IConstant.ERROR, \"Error During Applying New Password!\");\r\n    }\r\n\r\n    /**\r\n     * load groups and users to admin user\r\n     * @return All Groups with there users\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * Send text message between users\r\n     * @param msg\r\n     * @return true/false if message delivered or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send text message to a user\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send text message but securly (i.e. encrypted)\r\n     * @param msg : the message to be send\r\n     * @return boolean : true/false if the text message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextMessageToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean success = false;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                boolean success = false;\r\n                //loop on users\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (sendSecureTextMessageToUser(msg, cf)) {\r\n                            success = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (success) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to send secure text message to a user (encrypted)\r\n     * @param msg : the message to be send\r\n     * @param cf  : the client interface of the user\r\n     * @return boolean : true/false if the text message send or not.\r\n     */\r\n    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {\r\n        if (cf == null) {\r\n            return false;\r\n        } else {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online TextMessage=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                return cf.receiveSecureTextMessage(msg);\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user \");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send Binary message (files) but secure (files not secure)\r\n     * @param msg : the message to be send\r\n     * @return ResultBean include the status of message send or not.\r\n     * @throws RemoteException\r\n     */\r\n    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {\r\n        ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n        if (cf == null) {\r\n            return new ResultBean(false, IConstant.OFFLINE, null);\r\n        } else {\r\n            try {\r\n                //online message, send it..\r\n                if (msg.getAction() == IConstant.REQUEST) {\r\n                    getLogger().log(Level.FINE, \"Request send\");\r\n                    return cf.receiveSecureBinaryMessageRequest(msg);\r\n                } else {\r\n                    getLogger().log(Level.FINE, \"Online BinaryMessage size=\" + msg.getData().length + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                    cf.receiveSecureBinaryMessageLoad(msg);\r\n                    return new ResultBean(true, IConstant.SUCCESS, null);\r\n                }\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                } catch (RemoteException ex1) {\r\n                }\r\n                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt.\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send announcemnt but securly (encrypted)\r\n     * @param msg : the announcemnt to be send\r\n     * @throws RemoteException\r\n     */\r\n    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {\r\n        if (msg.getTargetType() == IConstant.USER_CHAT) {\r\n            ClientInterface cf = connectedClients.get(msg.getToUserId());\r\n            return sendSecureTextAnnouncementToUser(msg, cf);\r\n        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {\r\n            Vector<User> tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (getGroups().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.size(); i++) {\r\n                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers.get(i).getId());\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {\r\n            int[] tempUsers = null;\r\n            ClientInterface cf = null;\r\n            for (int i = 0; i < getRooms().size(); i++) {\r\n                if (getRooms().get(i).getId() == msg.getToUserId()) {\r\n                    tempUsers = getRooms().get(i).getUserId();\r\n                    break;\r\n                }\r\n            }\r\n            if (tempUsers != null && tempUsers.length > 0) {\r\n                //loop on users\r\n                boolean deliverToAll = true;\r\n                for (int i = 0; i < tempUsers.length; i++) {\r\n                    if (tempUsers[i] != msg.getFromUserId()) {\r\n                        cf = connectedClients.get(tempUsers[i]);\r\n                        if (deliverToAll) {\r\n                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);\r\n                        } else {\r\n                            sendSecureTextAnnouncementToUser(msg, cf);\r\n                        }\r\n                    }\r\n                }\r\n                return deliverToAll;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * private method to send announcemnt securly (encrypted)\r\n     * @param msg : the announcemnt to send\r\n     * @param cf  : the user client interface.\r\n     */\r\n    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {\r\n        if (cf != null) {\r\n            try {\r\n                getLogger().log(Level.FINE, \"Online Announcement=\" + msg.getMessage() + \" From=\" + msg.getFromUserId() + \" To=\" + msg.getToUserId());\r\n                //online message, send it..\r\n                cf.receiveSecureTextAnnouncement(msg);\r\n                return true;\r\n            } catch (RemoteException ex) {\r\n                try {\r\n                    getLogger().log(Level.FINE, \"Exception happen, will logoff this user\");\r\n                    connectedClients.remove(msg.getToUserId());\r\n                    connectedClientsIPs.remove(msg.getToUserId());\r\n                    offlineStatus(msg.getToUserId());\r\n                    return false;\r\n                } catch (RemoteException ex1) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Method used to update user status\r\n     * @param updatedUser : the user with the new method included.\r\n     * @throws RemoteException\r\n     */\r\n    public void updateUserStatus(User updatedUser) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"update user status for id=\" + updatedUser.getId() + \" in group_id=\" + updatedUser.getGroup_id() + \" with Status=\" + updatedUser.getStatus_id());\r\n        boolean userFound = false;\r\n        Vector<User> tempUsers = null;\r\n        if (updatedUser != null && updatedUser.getId() > 0) {\r\n            for (int i = 0; i < getGroups().size(); i++) {\r\n                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {\r\n                    tempUsers = getGroups().get(i).getUsers();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (tempUsers != null && tempUsers.size() > 0) {\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (updatedUser.getId() == tempUsers.get(n).getId()) {\r\n                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());\r\n                    userFound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (userFound) {\r\n            getLogger().log(Level.FINE, \"sending the status of the user to around \" + connectedClients.size() + \" user(s)\");\r\n            Enumeration<ClientInterface> allCF = connectedClients.elements();\r\n            while (allCF.hasMoreElements()) {\r\n                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);\r\n                sendUserUpdatedStatusThread.start();\r\n            }\r\n        }\r\n        System.gc();\r\n    }\r\n\r\n    /**\r\n     * return user rooms\r\n     * @param user\r\n     * @return : Vector of rooms where this user is memeber of them.\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {\r\n        if (!this.clientAuthToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        Vector<Room> myRooms = new Vector<Room>(0);\r\n        for (int i = 0; i < getRooms().size(); i++) {\r\n            int[] temp = getRooms().get(i).getUserId();\r\n            if (temp != null) {\r\n                for (int n = 0; n < temp.length; n++) {\r\n                    if (user.getId() == temp[n]) {\r\n                        myRooms.add(getRooms().get(i));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return myRooms;\r\n    }\r\n\r\n    /**\r\n     * Run method to periodic ping all user to check if any user lost the connection with the server\r\n     * so the server offline his/her status.\r\n     * It run each 5 minutes.\r\n     */\r\n    public void run() {\r\n        while (serverRunning) {\r\n            try {\r\n                Thread.sleep(5 * 60 * 1000);\r\n            } catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            getLogger().log(Level.FINE, \"sending ping to all users to ensure they are still connected!\");\r\n            getLogger().log(Level.FINE, \"size before ping=\" + connectedClients.size() + \" user(s)\");\r\n            if (connectedClients.size() > 0) {\r\n                int n = 0;\r\n                ClientInterface cf = null;\r\n                Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n                while (listOfUserIds.hasMoreElements()) {\r\n                    n = listOfUserIds.nextElement();\r\n                    cf = connectedClients.get(n);\r\n                    try {\r\n                        if (cf.ping() == false) {\r\n                            connectedClients.remove(n);\r\n                            connectedClientsIPs.remove(n);\r\n                            offlineStatus(n);\r\n                        }\r\n                    } catch (Throwable e) {\r\n                        connectedClients.remove(n);\r\n                        connectedClientsIPs.remove(n);\r\n                        try {\r\n                            offlineStatus(n);\r\n                        } catch (Throwable ex) {\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                synchronized (connectedClients) {\r\n                    secToken = \"F\" + Calendar.getInstance().getTimeInMillis();\r\n                }\r\n            }\r\n            getLogger().log(Level.FINE, \"size after ping=\" + connectedClients.size() + \" user(s)\");\r\n            System.gc();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and update other users with the user new status (offline)\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatus(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        updateUserStatus(tempUsers.get(n));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to offline user status and NOT update other users with the user new status (offline)\r\n     * Typically used when shutdown the server, don't care about informing users with the new status.\r\n     * @param userId\r\n     * @throws RemoteException\r\n     */\r\n    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {\r\n        getLogger().log(Level.FINE, \"will switch status to be sign off , for userID=\" + userId);\r\n        for (int i = 0; i < getGroups().size(); i++) {\r\n            Vector<User> tempUsers = getGroups().get(i).getUsers();\r\n            if (tempUsers != null && tempUsers.size() > 0) {\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    if (userId == tempUsers.get(n).getId()) {\r\n                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * private method to authenticate the user and return its full detailed bean.\r\n     * @param emailAddr : email of the user\r\n     * @param password  : password of the user.\r\n     * @return User or Null according to the authentication results.\r\n     */\r\n    private User authenticateUser(String emailAddr, String password) {\r\n        //User user = null;\r\n        getLogger().log(Level.FINE, \"authenticate the user....\");\r\n        for (int i = 0; i < groups.size(); i++) {\r\n            Vector<User> tempUsers = groups.get(i).getUsers();\r\n            for (int n = 0; n < tempUsers.size(); n++) {\r\n                if (emailAddr.equals(tempUsers.get(n).getEmail())) {\r\n                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));\r\n                    //System.out.println(\"original pass=\"+orignalPass);\r\n                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n                    //System.out.println(\"send pass=\"+password);\r\n                    if (password != null && password.equals(orignalPass)) {\r\n                        return tempUsers.get(n);\r\n                    } else {\r\n                        //failed authentication\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @return the groups\r\n     */\r\n    public Vector<Group> getGroups() {\r\n        return groups;\r\n    }\r\n\r\n    /**\r\n     * @return the rooms\r\n     */\r\n    public Vector<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * public method to create new user , used by the admin user\r\n     * @param user : the user details\r\n     * @return User : with the user Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public User createUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        user = userBD.createUser(user);\r\n        if (user != null) {\r\n            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n            return user;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to create new group , used by the admin user\r\n     * @param Group : the group details\r\n     * @return Group : with the group Id included or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Group createGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createGroup(group);\r\n    }\r\n\r\n    /**\r\n     * public method to create new room , used by the admin user\r\n     * @param room : the room details\r\n     * @return Room : with room id or null if failed to create it.\r\n     * @throws RemoteException\r\n     */\r\n    public Room createRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.createRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to delete user\r\n     * @param user : to be deleted\r\n     * @return User\r\n     * @throws RemoteException\r\n     */\r\n    public User delUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to delete Group\r\n     * @param Group : to be deleted\r\n     * @return Group\r\n     * @throws RemoteException\r\n     */\r\n    public Group delGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to delete Room\r\n     * @param Room : to be deleted\r\n     * @return Room\r\n     * @throws RemoteException\r\n     */\r\n    public Room delRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.delRoom(room);\r\n    }\r\n\r\n    /**\r\n     * method to update user\r\n     * @param user to be updated\r\n     * @return User after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUser(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUser(user);\r\n    }\r\n\r\n    /**\r\n     * method to update Group\r\n     * @param Group to be updated\r\n     * @return Group after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Group updateGroup(Group group, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateGroup(group);\r\n    }\r\n\r\n    /**\r\n     * method to update Room\r\n     * @param Room to be updated\r\n     * @return Room after updated or null if failed to update it\r\n     * @throws RemoteException\r\n     */\r\n    public Room updateRoom(Room room, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateRoom(room);\r\n    }\r\n\r\n    /**\r\n     * public method to shutdown the server, it will include kick off of all users.\r\n     * @throws RemoteException\r\n     */\r\n    public void shutdownServer(String justification, String authToken) throws RemoteException {\r\n        if (this.authToken.equals(authToken) || \"FIM\".equals(authToken)) {\r\n            getLogger().log(Level.SEVERE, \"Shutdown Server by the admin\");\r\n            for (int i = 0; i < groups.size(); i++) {\r\n                Vector<User> tempUsers = groups.get(i).getUsers();\r\n                for (int n = 0; n < tempUsers.size(); n++) {\r\n                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);\r\n                    sendKickOffMessageThread.start();\r\n                }\r\n            }\r\n            try {\r\n                Thread.sleep(500 * 1);\r\n            } catch (InterruptedException ex) {\r\n                //do no thing!\r\n            }\r\n            System.exit(-1);\r\n        } else {\r\n            getLogger().log(Level.SEVERE, \"Invalid authentication token!\");\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to kick of all users\r\n     * @return boolean true after kicking off all users\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off All Users Server by the admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);\r\n            sendKickOffMessageThread.start();\r\n            offlineStatusAndNoUpdate(n);\r\n        }\r\n        connectedClients.clear();\r\n        connectedClientsIPs.clear();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return all rooms\r\n     * @return : Vector of all rooms\r\n     * @throws RemoteException\r\n     */\r\n    public Vector<Room> loadRooms(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return rooms;\r\n    }\r\n\r\n    /**\r\n     * method used for sign in by the admin user\r\n     * @param emailAddr : email of the admin user\r\n     * @param password  : password of the admin user.\r\n     * @return User either adminUser object or null if authentication failed.\r\n     * @throws RemoteException\r\n     */\r\n    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {\r\n        //authenticate User\r\n        //DB authentication....\r\n        if (emailAddr != null && password != null) {\r\n            String email = StringEncoder64.decodeStringUTF8(emailAddr);\r\n            User user = null;\r\n            String orignalPass = passwordEnc.decrypt(passwords.get(1000));\r\n            password = StringEncrypter.getInstance(orignalPass).decrypt(password);\r\n            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {\r\n                user = getAdminUser();\r\n            }\r\n            if (user != null) {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" has logged in.\");\r\n                authToken = \"FIM\" + Calendar.getInstance().getTimeInMillis();\r\n                LoginBean loginBean = new LoginBean();\r\n                loginBean.setUser(adminUser);\r\n                loginBean.setAuthToken(authToken);\r\n                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);\r\n                loginBean.setSecureToken(tokenUsed);\r\n                return loginBean;\r\n            } else {\r\n                getLogger().log(Level.FINE, \"User \" + email + \" is not valid!\");\r\n                return null;\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"Credentials is null!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * public method to set a new default password for newly created users\r\n     * @param newPass : the new default password.\r\n     * @return true after set the new default password.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);\r\n        newPass = passwordEnc.encrypt(newPass);\r\n        getServerSettingBean().setDefualtPassword(newPass);\r\n        getServerSettingBean().updateSettings();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to reset user password , used by the admin user to reset user password.\r\n     * @param user : to reset its password.\r\n     * @return User or null if failed to reset his/her password.\r\n     * @throws RemoteException\r\n     */\r\n    public User resetUserPass(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        if (user != null) {\r\n            getLogger().log(Level.FINE, \"Reset User \" + user.getId() + \" password!\");\r\n            user = userBD.resetUserPass(user);\r\n            if (user != null) {\r\n                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());\r\n                return user;\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the serverSettingBean\r\n     */\r\n    public ServerSettingBean getServerSettingBean() {\r\n        return serverSettingBean;\r\n    }\r\n\r\n    /**\r\n     * public method to move user from a group into another group\r\n     * @param user : to be moved included the group id of the new group\r\n     * @return User or null if failed to move this user.\r\n     * @throws RemoteException\r\n     */\r\n    public User updateUserGroup(User user, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return userBD.updateUserGroup(user);\r\n    }\r\n\r\n    /**\r\n     * public method to set the log level of the server.\r\n     * @param level integer from 0 - 5 (0 = no logging , 5 = All)\r\n     * @param saveValue , save the log level or just set it without saving it.\r\n     * @return true after set it.\r\n     * @throws RemoteException\r\n     */\r\n    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        switch(level) {\r\n            case 0:\r\n                getLogger().setLevel(Level.OFF);\r\n                break;\r\n            case 1:\r\n                getLogger().setLevel(Level.SEVERE);\r\n                break;\r\n            case 2:\r\n                getLogger().setLevel(Level.WARNING);\r\n                break;\r\n            case 3:\r\n                getLogger().setLevel(Level.INFO);\r\n                break;\r\n            case 4:\r\n                getLogger().setLevel(Level.FINE);\r\n                break;\r\n            case 5:\r\n                getLogger().setLevel(Level.ALL);\r\n                break;\r\n        }\r\n        if (saveValue) {\r\n            serverSettingBean.setLogLevel(\"\" + level);\r\n            serverSettingBean.updateSettings();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to return online users ips\r\n     * @return Hashtable of the online users ips\r\n     * @throws RemoteException\r\n     */\r\n    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return connectedClientsIPs;\r\n    }\r\n\r\n    /**\r\n     * public method to get security mode\r\n     * @return int the security level.\r\n     * @throws RemoteException\r\n     */\r\n    public int getSecurityMode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to kick off a user\r\n     * @param userId : of the user to be kicked off\r\n     * @return true when the user kicked off\r\n     * @throws RemoteException\r\n     */\r\n    public boolean kickOffUser(int userId, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Kick Off User by the admin\");\r\n        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), \"\");\r\n        sendKickOffMessageThread.start();\r\n        if (connectedClients.get(userId) != null)\r\n            offlineStatus(userId);\r\n        connectedClients.remove(userId);\r\n        connectedClientsIPs.remove(userId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * public method to set the security level\r\n     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.\r\n     * @return int of the security level after set the level\r\n     * @throws RemoteException\r\n     */\r\n    public int setSecurityMode(int level, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setSecureMode(\"\" + level);\r\n        serverSettingBean.updateSettings();\r\n        securityMode = level;\r\n        return securityMode;\r\n    }\r\n\r\n    /**\r\n     * public method to get log level\r\n     * @return int of the got level\r\n     * @throws RemoteException\r\n     */\r\n    public int getLogLevel(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return Integer.parseInt(serverSettingBean.getLogLevel());\r\n    }\r\n\r\n    /**\r\n     * @return the adminUser\r\n     */\r\n    public User getAdminUser() {\r\n        return adminUser;\r\n    }\r\n\r\n    public String getRootNode(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        serverSettingBean.setRootNode(rootNode);\r\n        serverSettingBean.updateSettings();\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(\"System Admin\");\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Send Global Secure Text Announcement by the admin\");\r\n        TextMessage tm = new TextMessage();\r\n        tm.setFromUserId(0);\r\n        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(\"System Admin\"));\r\n        tm.setMessage(msg);\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            sendSecureTextAnnouncementToUser(tm, cf);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int getSecurityMode() throws RemoteException {\r\n        return securityMode;\r\n    }\r\n\r\n    public String getRootNode() throws RemoteException {\r\n        return serverSettingBean.getRootNode();\r\n    }\r\n\r\n    public boolean refreshContactList(String authToken) throws RemoteException {\r\n        if (!this.authToken.equals(authToken)) {\r\n            throw new RemoteException(\"Invalid Login Token\");\r\n        }\r\n        getLogger().log(Level.SEVERE, \"Refresh Users contact list by admin\");\r\n        ClientInterface cf = null;\r\n        Enumeration<Integer> listOfUserIds = connectedClients.keys();\r\n        while (listOfUserIds.hasMoreElements()) {\r\n            int n = listOfUserIds.nextElement();\r\n            cf = connectedClients.get(n);\r\n            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);\r\n            sendRefreshContactThread.start();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @return the passwordEnc\r\n     */\r\n    public StringEncrypter getPasswordEnc() {\r\n        return passwordEnc;\r\n    }\r\n}\r\n",
    "test_prompt": "// ModernChatServer_24Test.java\npackage osa.ora.server;\n\nimport java.net.URISyntaxException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Calendar;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.swing.JOptionPane;\nimport osa.ora.server.bd.UsersBD;\nimport osa.ora.server.beans.BinaryMessage;\nimport osa.ora.server.beans.Group;\nimport osa.ora.server.beans.IConstant;\nimport osa.ora.server.beans.LoginBean;\nimport osa.ora.server.beans.ResultBean;\nimport osa.ora.server.beans.Room;\nimport osa.ora.server.beans.ServerSettingBean;\nimport osa.ora.server.beans.TextMessage;\nimport osa.ora.server.beans.User;\nimport osa.ora.server.client.ClientInterface;\nimport osa.ora.server.threads.SendKickOffByLoginMessageThread;\nimport osa.ora.server.threads.SendKickOffMessageThread;\nimport osa.ora.server.threads.SendRefreshContactThread;\nimport osa.ora.server.threads.SendUserUpdatedStatusThread;\nimport osa.ora.server.utils.StringEncoder64;\nimport osa.ora.server.utils.StringEncrypter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModernChatServer}.\n* It contains ten unit test cases for the {@link ModernChatServer#signInAsAdmin(String, String)} method.\n*/\nclass ModernChatServer_24Test {"
}
,{
    "id": "chatcmpl-A5VmRimJqoQSCw3R4PXebs0rS2obN",
    "object": "chat.completion",
    "created": 1725877167,
    "model": "gpt-3.5-turbo-0125",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "```java\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\nimport osa.ora.server.utils.FileEncrypter;\n\nclass FileEncrypter_0Test {\n\n    @Test\n    void testGetInstance() {\n        FileEncrypter instance1 = FileEncrypter.getInstance();\n        FileEncrypter instance2 = FileEncrypter.getInstance();\n        assertSame(instance1, instance2);\n    }\n\n    @Test\n    void testGetInstanceInit() {\n        byte[] key = \"TestKey\".getBytes();\n        FileEncrypter instance = FileEncrypter.getInstanceInit(key);\n        assertNotNull(instance);\n    }\n\n    @Test\n    void testEncryptBlowfish() {\n        FileEncrypter fileEncrypter = FileEncrypter.getInstance();\n        byte[] data = \"Test Data\".getBytes();\n        byte[] encryptedData = fileEncrypter.encryptBlowfish(data);\n        assertNotNull(encryptedData);\n    }\n\n    @Test\n    void testDecryptBlowfish() {\n        FileEncrypter fileEncrypter = FileEncrypter.getInstance();\n        byte[] data = \"Test Data\".getBytes();\n        byte[] encryptedData = fileEncrypter.encryptBlowfish(data);\n        byte[] decryptedData = fileEncrypter.decryptBlowfish(encryptedData);\n        assertNotNull(decryptedData);\n    }\n\n    @Test\n    void testFileEncrypt() {\n        FileEncrypter fileEncrypter = FileEncrypter.getInstance();\n        File inputFile = new File(\"input.txt\");\n        File outputFile = new File(\"output.txt\");\n        byte[] encryptedData = fileEncrypter.fileEncrypt(inputFile, outputFile);\n        assertNotNull(encryptedData);\n    }\n\n    @Test\n    void testFileDecrypt() {\n        FileEncrypter fileEncrypter = FileEncrypter.getInstance();\n        byte[] inputData = \"Test Data\".getBytes();\n        File outputFile = new File(\"output.txt\");\n        fileEncrypter.fileDecrypt(inputData, outputFile);\n        assertTrue(outputFile.exists());\n    }\n\n    @Test\n    void testMainMethod() {\n        FileEncrypter.main(new String[]{});\n        // No assertion as this method is for testing main method execution\n    }\n}\n```\n",
                "refusal": null
            },
            "logprobs": null,
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 1669,
        "completion_tokens": 431,
        "total_tokens": 2100
    },
    "system_fingerprint": null,
    "time_taken": 7.567164421081543,
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/utils/FileEncrypter_0Test.java",
    "original_code": "// FileEncrypter.java\npackage osa.ora.server.utils;\n\n// -----------------------------------------------------------------------------\n// FileEncrypter.java\n// -----------------------------------------------------------------------------\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport javax.crypto.Cipher;\nimport java.io.IOException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class FileEncrypter {\n\n    private static FileEncrypter fileEncrypter = null;\n\n    private Cipher enCipther;\n\n    private Cipher deCipther;\n\n    /**\n     * Singleton\n     */\n    public static FileEncrypter getInstance() {\n        if (fileEncrypter == null)\n            fileEncrypter = new FileEncrypter(\"FIM\".getBytes());\n        return fileEncrypter;\n    }\n\n    public static FileEncrypter getInstanceInit(byte[] strkey) {\n        fileEncrypter = new FileEncrypter(strkey);\n        return fileEncrypter;\n    }\n\n    /**\n     * private Constructor used to create this object.  Responsible for setting\n     * and initializing this object's encrypter and decrypter Chipher instances\n     * given a Pass Phrase and algorithm.\n     * @param strkey Pass the key used to initialize both the encrypter and\n     *                   decrypter instances.\n     */\n    private FileEncrypter(byte[] strkey) {\n        byte[] ivr = { (byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32, (byte) 0x56, (byte) 0x34, (byte) 0xE3, (byte) 0x03 };\n        try {\n            SecretKeySpec key = new SecretKeySpec(strkey, \"Blowfish\");\n            enCipther = Cipher.getInstance(\"Blowfish/CBC/PKCS5Padding\");\n            deCipther = Cipher.getInstance(\"Blowfish/CBC/PKCS5Padding\");\n            IvParameterSpec oIV = new IvParameterSpec(ivr);\n            enCipther.init(Cipher.ENCRYPT_MODE, key, oIV);\n            deCipther.init(Cipher.DECRYPT_MODE, key, oIV);\n        } catch (Exception e) {\n            System.out.println(\"EXCEPTION:\" + e.getMessage());\n        }\n    }\n\n    /**\n     * to encrypt a box of byte array\n     * @param to_encrypt\n     * @return byte[]\n     */\n    private byte[] encryptBlowfish(byte[] to_encrypt) {\n        try {\n            //to_encrypt=StringEncoder64.encode(to_encrypt).getBytes(\"UTF8\");\n            return enCipther.doFinal(to_encrypt);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return null;\n        }\n    }\n\n    /**\n     * to decrypt a box of byte array\n     * @param to_decrypt\n     * @return byte[]\n     */\n    private byte[] decryptBlowfish(byte[] to_decrypt) {\n        try {\n            to_decrypt = deCipther.doFinal(to_decrypt);\n            //to_decrypt=StringEncoder64.decode(new String(to_decrypt,\"UTF8\"));\n            return to_decrypt;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return null;\n        }\n    }\n\n    /**\n     * to encrypt file using temp file and return the data into byte[]\n     * and delete the temp file\n     * @param file\n     * @param file2\n     * @return byte[] of encrypted file\n     */\n    public byte[] fileEncrypt(File file, File file2) {\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fos = new FileOutputStream(file2);\n            fis = new FileInputStream(file);\n            int lenght = fis.available();\n            //System.out.println(\"Length=\"+lenght);\n            String len = \"\" + lenght;\n            while (len.length() < 8) {\n                len = \"0\" + len;\n            }\n            fos.write(len.getBytes());\n            byte[] data = null;\n            for (int i = 0; i < lenght; i = i + 8) {\n                data = new byte[8];\n                fis.read(data);\n                data = StringEncoder64.encode(data).getBytes(\"UTF8\");\n                byte[] enc = encryptBlowfish(new String(data).getBytes(\"UTF8\"));\n                //System.out.println(\"Length=\"+enc.length);\n                fos.write(enc);\n            }\n            fos.close();\n            fis.close();\n            fis = new FileInputStream(file2);\n            int n = fis.available();\n            data = new byte[n];\n            fis.read(data);\n            fis.close();\n            file2.delete();\n            return data;\n        } catch (Exception ex) {\n            //ex.printStackTrace();\n            return null;\n        } finally {\n            try {\n                if (fis != null)\n                    fis.close();\n                if (fos != null)\n                    fos.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n\n    /**\n     * to decrypt array of bytes and create an output file\n     * @param inputData\n     * @param file2 the decrypted file.\n     */\n    public void fileDecrypt(byte[] inputData, File file2) {\n        FileOutputStream fos = null;\n        try {\n            fos = new FileOutputStream(file2);\n            byte[] data = new byte[8];\n            System.arraycopy(inputData, 0, data, 0, 8);\n            int lenght = Integer.parseInt(new String(data));\n            //System.out.println(\"Original size=\"+lenght);\n            int partitions = lenght / 8;\n            //System.out.println(\"partitions=\"+partitions);\n            int last = lenght % 8;\n            //System.out.println(\"last size=\"+last);\n            int current = 0;\n            for (int i = 0; i < partitions; i++) {\n                data = new byte[16];\n                System.arraycopy(inputData, 8 + i * 16, data, 0, 16);\n                byte[] dec = decryptBlowfish(data);\n                dec = StringEncoder64.decode(new String(dec, \"UTF8\"));\n                fos.write(dec);\n                //System.out.println(\"Current=\"+current);\n                current++;\n            }\n            if (last != 0) {\n                //System.out.println(\"in last\");\n                data = new byte[16];\n                System.arraycopy(inputData, 8 + partitions * 16, data, 0, 16);\n                byte[] dec = decryptBlowfish(data);\n                dec = StringEncoder64.decode(new String(dec, \"UTF8\"));\n                byte[] temp = new byte[last];\n                System.arraycopy(dec, 0, temp, 0, last);\n                //System.out.println(\"last=\"+temp);\n                fos.write(temp);\n            }\n        } catch (Exception ex) {\n            //ex.printStackTrace();\n            return;\n        } finally {\n            try {\n                if (fos != null)\n                    fos.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n\n    /**\n     * main test method\n     * @param args\n     */\n    public static void main(String[] args) {\n        FileEncrypter stringEnc = FileEncrypter.getInstanceInit(\"Modern Chat\".getBytes());\n        try {\n            byte[] data = stringEnc.fileEncrypt(new File(\"/osama2.zip\"), new File(\"/osama3.zip\"));\n            stringEnc.fileDecrypt(data, new File(\"/osama4.zip\"));\n        } catch (Exception ex) {\n        }\n    }\n}\n",
    "test_prompt": "// FileEncrypter_0Test.java\npackage osa.ora.server.utils;\n\n// -----------------------------------------------------------------------------\n// FileEncrypter.java\n// -----------------------------------------------------------------------------\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport javax.crypto.Cipher;\nimport java.io.IOException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileEncrypter}.\n* It contains ten unit test cases for the {@link FileEncrypter#getInstance()} method.\n*/\nclass FileEncrypter_0Test {"
}
,{
    "id": "chatcmpl-A5VnSrT3BRvIL2TE4Re6kcKbxBXTO",
    "object": "chat.completion",
    "created": 1725877230,
    "model": "gpt-3.5-turbo-0125",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "```java\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass StringEncrypter_1Test {\n\n    @Test\n    void testEncrypt_NullInput_ReturnsNull() {\n        StringEncrypter encrypter = StringEncrypter.getInstance(\"test\");\n        String encrypted = encrypter.encrypt(null);\n        assertEquals(null, encrypted);\n    }\n\n    @Test\n    void testEncrypt_EmptyInput_ReturnsEmpty() {\n        StringEncrypter encrypter = StringEncrypter.getInstance(\"test\");\n        String encrypted = encrypter.encrypt(\"\");\n        assertEquals(\"\", encrypted);\n    }\n\n    @Test\n    void testEncrypt_ValidInput_ReturnsEncryptedString() {\n        StringEncrypter encrypter = StringEncrypter.getInstance(\"test\");\n        String encrypted = encrypter.encrypt(\"Hello, World!\");\n        assertNotEquals(\"Hello, World!\", encrypted);\n    }\n\n    @Test\n    void testEncrypt_Decrypt_ReturnsOriginalString() {\n        StringEncrypter encrypter = StringEncrypter.getInstance(\"test\");\n        String original = \"Hello, World!\";\n        String encrypted = encrypter.encrypt(original);\n        String decrypted = encrypter.decrypt(encrypted);\n        assertEquals(original, decrypted);\n    }\n\n    @Test\n    void testEncrypt_SameInput_ReturnsDifferentEncryptedStrings() {\n        StringEncrypter encrypter = StringEncrypter.getInstance(\"test\");\n        String input = \"Hello, World!\";\n        String encrypted1 = encrypter.encrypt(input);\n        String encrypted2 = encrypter.encrypt(input);\n        assertNotEquals(encrypted1, encrypted2);\n    }\n\n    @Test\n    void testEncrypt_LongInput_ReturnsEncryptedString() {\n        StringEncrypter encrypter = StringEncrypter.getInstance(\"test\");\n        String input = \"This is a long input string to test encryption.\";\n        String encrypted = encrypter.encrypt(input);\n        assertNotEquals(input, encrypted);\n    }\n\n    @Test\n    void testEncrypt_SpecialCharacters_ReturnsEncryptedString() {\n        StringEncrypter encrypter = StringEncrypter.getInstance(\"test\");\n        String input = \"!@#$%^&*()_+\";\n        String encrypted = encrypter.encrypt(input);\n        assertNotEquals(input, encrypted);\n    }\n\n    @Test\n    void testEncrypt_Numbers_ReturnsEncryptedString() {\n        StringEncrypter encrypter = StringEncrypter.getInstance(\"test\");\n        String input = \"1234567890\";\n        String encrypted = encrypter.encrypt(input);\n        assertNotEquals(input, encrypted);\n    }\n\n    @Test\n    void testEncrypt_Alphanumeric_ReturnsEncryptedString() {\n        StringEncrypter encrypter = StringEncrypter.getInstance(\"test\");\n        String input = \"abc123XYZ\";\n        String encrypted = encrypter.encrypt(input);\n        assertNotEquals(input, encrypted);\n    }\n}\n```\n```",
                "refusal": null
            },
            "logprobs": null,
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 944,
        "completion_tokens": 561,
        "total_tokens": 1505
    },
    "system_fingerprint": null,
    "time_taken": 8.237051248550415,
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/utils/StringEncrypter_1Test.java",
    "original_code": "// StringEncrypter.java\npackage osa.ora.server.utils;\r\n\r\n// -----------------------------------------------------------------------------\r\n// StringEncrypter.java\r\n// -----------------------------------------------------------------------------\r\nimport javax.crypto.Cipher;\r\nimport javax.crypto.SecretKey;\r\nimport java.security.spec.KeySpec;\r\nimport java.security.spec.AlgorithmParameterSpec;\r\nimport javax.crypto.spec.PBEKeySpec;\r\nimport javax.crypto.SecretKeyFactory;\r\nimport javax.crypto.spec.PBEParameterSpec;\r\n\r\npublic class StringEncrypter {\r\n\r\n    public char[] keyUsed = \"FIM\".toCharArray();\r\n\r\n    Cipher ecipher;\r\n\r\n    Cipher dcipher;\r\n\r\n    //private static StringEncrypter stringEncrypter = null;\r\n    /**\r\n     * Singleton\r\n     */\r\n    public static StringEncrypter getInstance(String initKey) {\r\n        return new StringEncrypter(initKey);\r\n    }\r\n\r\n    /**\r\n     * private Constructor used to create this object.  Responsible for setting\r\n     * and initializing this object's encrypter and decrypter Chipher instances\r\n     * given a Pass Phrase and algorithm.\r\n     * @param passPhrase Pass Phrase used to initialize both the encrypter and\r\n     *                   decrypter instances.\r\n     */\r\n    private StringEncrypter(String initKey) {\r\n        keyUsed = initKey.toCharArray();\r\n        // 8-bytes Salt\r\n        byte[] salt = { (byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32, (byte) 0x56, (byte) 0x34, (byte) 0xE3, (byte) 0x03 };\r\n        // Iteration count\r\n        int iterationCount = 19;\r\n        try {\r\n            KeySpec keySpec = new PBEKeySpec(keyUsed, salt, iterationCount);\r\n            SecretKey key = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\").generateSecret(keySpec);\r\n            ecipher = Cipher.getInstance(key.getAlgorithm());\r\n            dcipher = Cipher.getInstance(key.getAlgorithm());\r\n            // Prepare the parameters to the cipthers\r\n            AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterationCount);\r\n            ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\r\n            dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);\r\n        } catch (Exception e) {\r\n            System.out.println(\"EXCEPTION: \" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a single String as an argument and returns an Encrypted version\r\n     * of that String.\r\n     * @param str String to be encrypted\r\n     * @return <code>String</code> Encrypted version of the provided String\r\n     */\r\n    public String encrypt(String str) {\r\n        if (str == null)\r\n            return null;\r\n        try {\r\n            // Encode the string into bytes using utf-8\r\n            byte[] utf8 = str.getBytes(\"UTF8\");\r\n            // Encrypt\r\n            byte[] enc = ecipher.doFinal(utf8);\r\n            // Encode bytes to base64 to get a string\r\n            return StringEncoder64.encode(enc);\r\n        } catch (Exception e) {\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Takes a encrypted String as an argument, decrypts and returns the\r\n     * decrypted String.\r\n     * @param str Encrypted String to be decrypted\r\n     * @return <code>String</code> Decrypted version of the provided String\r\n     */\r\n    public String decrypt(String str) {\r\n        if (str == null)\r\n            return null;\r\n        try {\r\n            // Decode base64 to get bytes\r\n            byte[] dec = StringEncoder64.decode(str);\r\n            // Decrypt\r\n            byte[] utf8 = dcipher.doFinal(dec);\r\n            // Decode using utf-8\r\n            return new String(utf8, \"UTF8\");\r\n        } catch (Exception e) {\r\n        }\r\n        return null;\r\n    }\r\n}\r\n",
    "test_prompt": "// StringEncrypter_1Test.java\npackage osa.ora.server.utils;\n\n// -----------------------------------------------------------------------------\n// StringEncrypter.java\n// -----------------------------------------------------------------------------\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport java.security.spec.KeySpec;\nimport java.security.spec.AlgorithmParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEParameterSpec;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringEncrypter}.\n* It contains ten unit test cases for the {@link StringEncrypter#encrypt(String)} method.\n*/\nclass StringEncrypter_1Test {"
}
,{
    "id": "chatcmpl-A5VoV6AXveFIIIcg5IG2sDb0ZEtDO",
    "object": "chat.completion",
    "created": 1725877295,
    "model": "gpt-3.5-turbo-0125",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "```java\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class StringEncrypter_2Test {\n\n    @Test\n    void testDecrypt_NullInput() {\n        StringEncrypter encrypter = StringEncrypter.getInstance(\"testKey\");\n        assertNull(encrypter.decrypt(null));\n    }\n\n    @Test\n    void testDecrypt_EmptyInput() {\n        StringEncrypter encrypter = StringEncrypter.getInstance(\"testKey\");\n        assertEquals(\"\", encrypter.decrypt(\"\"));\n    }\n\n    @Test\n    void testDecrypt_ValidInput() {\n        StringEncrypter encrypter = StringEncrypter.getInstance(\"testKey\");\n        String encrypted = encrypter.encrypt(\"Hello, World!\");\n        assertEquals(\"Hello, World!\", encrypter.decrypt(encrypted));\n    }\n\n    @Test\n    void testDecrypt_InvalidInput() {\n        StringEncrypter encrypter = StringEncrypter.getInstance(\"testKey\");\n        assertNull(encrypter.decrypt(\"InvalidInput\"));\n    }\n\n    @Test\n    void testDecrypt_LongInput() {\n        StringEncrypter encrypter = StringEncrypter.getInstance(\"testKey\");\n        String longString = \"This is a very long string that will be encrypted and decrypted successfully.\";\n        String encrypted = encrypter.encrypt(longString);\n        assertEquals(longString, encrypter.decrypt(encrypted));\n    }\n\n    @Test\n    void testDecrypt_SpecialCharactersInput() {\n        StringEncrypter encrypter = StringEncrypter.getInstance(\"testKey\");\n        String specialChars = \"!@#$%^&*()_+\";\n        String encrypted = encrypter.encrypt(specialChars);\n        assertEquals(specialChars, encrypter.decrypt(encrypted));\n    }\n\n    @Test\n    void testDecrypt_UnicodeInput() {\n        StringEncrypter encrypter = StringEncrypter.getInstance(\"testKey\");\n        String unicodeString = \"\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c\uff01\";\n        String encrypted = encrypter.encrypt(unicodeString);\n        assertEquals(unicodeString, encrypter.decrypt(encrypted));\n    }\n\n    @Test\n    void testDecrypt_RepeatedEncryptionDecryption() {\n        StringEncrypter encrypter = StringEncrypter.getInstance(\"testKey\");\n        String input = \"Test String for repeated encryption and decryption.\";\n        String encrypted = encrypter.encrypt(input);\n        assertEquals(input, encrypter.decrypt(encrypter.decrypt(encrypted)));\n    }\n\n    @Test\n    void testDecrypt_InvalidKey() {\n        StringEncrypter encrypter = StringEncrypter.getInstance(\"invalidKey\");\n        assertNull(encrypter.decrypt(\"TestString\"));\n    }\n}\n```\n```",
                "refusal": null
            },
            "logprobs": null,
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 948,
        "completion_tokens": 512,
        "total_tokens": 1460
    },
    "system_fingerprint": null,
    "time_taken": 6.0416014194488525,
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/utils/StringEncrypter_2Test.java",
    "original_code": "// StringEncrypter.java\npackage osa.ora.server.utils;\r\n\r\n// -----------------------------------------------------------------------------\r\n// StringEncrypter.java\r\n// -----------------------------------------------------------------------------\r\nimport javax.crypto.Cipher;\r\nimport javax.crypto.SecretKey;\r\nimport java.security.spec.KeySpec;\r\nimport java.security.spec.AlgorithmParameterSpec;\r\nimport javax.crypto.spec.PBEKeySpec;\r\nimport javax.crypto.SecretKeyFactory;\r\nimport javax.crypto.spec.PBEParameterSpec;\r\n\r\npublic class StringEncrypter {\r\n\r\n    public char[] keyUsed = \"FIM\".toCharArray();\r\n\r\n    Cipher ecipher;\r\n\r\n    Cipher dcipher;\r\n\r\n    //private static StringEncrypter stringEncrypter = null;\r\n    /**\r\n     * Singleton\r\n     */\r\n    public static StringEncrypter getInstance(String initKey) {\r\n        return new StringEncrypter(initKey);\r\n    }\r\n\r\n    /**\r\n     * private Constructor used to create this object.  Responsible for setting\r\n     * and initializing this object's encrypter and decrypter Chipher instances\r\n     * given a Pass Phrase and algorithm.\r\n     * @param passPhrase Pass Phrase used to initialize both the encrypter and\r\n     *                   decrypter instances.\r\n     */\r\n    private StringEncrypter(String initKey) {\r\n        keyUsed = initKey.toCharArray();\r\n        // 8-bytes Salt\r\n        byte[] salt = { (byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32, (byte) 0x56, (byte) 0x34, (byte) 0xE3, (byte) 0x03 };\r\n        // Iteration count\r\n        int iterationCount = 19;\r\n        try {\r\n            KeySpec keySpec = new PBEKeySpec(keyUsed, salt, iterationCount);\r\n            SecretKey key = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\").generateSecret(keySpec);\r\n            ecipher = Cipher.getInstance(key.getAlgorithm());\r\n            dcipher = Cipher.getInstance(key.getAlgorithm());\r\n            // Prepare the parameters to the cipthers\r\n            AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterationCount);\r\n            ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\r\n            dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);\r\n        } catch (Exception e) {\r\n            System.out.println(\"EXCEPTION: \" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a single String as an argument and returns an Encrypted version\r\n     * of that String.\r\n     * @param str String to be encrypted\r\n     * @return <code>String</code> Encrypted version of the provided String\r\n     */\r\n    public String encrypt(String str) {\r\n        if (str == null)\r\n            return null;\r\n        try {\r\n            // Encode the string into bytes using utf-8\r\n            byte[] utf8 = str.getBytes(\"UTF8\");\r\n            // Encrypt\r\n            byte[] enc = ecipher.doFinal(utf8);\r\n            // Encode bytes to base64 to get a string\r\n            return StringEncoder64.encode(enc);\r\n        } catch (Exception e) {\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Takes a encrypted String as an argument, decrypts and returns the\r\n     * decrypted String.\r\n     * @param str Encrypted String to be decrypted\r\n     * @return <code>String</code> Decrypted version of the provided String\r\n     */\r\n    public String decrypt(String str) {\r\n        if (str == null)\r\n            return null;\r\n        try {\r\n            // Decode base64 to get bytes\r\n            byte[] dec = StringEncoder64.decode(str);\r\n            // Decrypt\r\n            byte[] utf8 = dcipher.doFinal(dec);\r\n            // Decode using utf-8\r\n            return new String(utf8, \"UTF8\");\r\n        } catch (Exception e) {\r\n        }\r\n        return null;\r\n    }\r\n}\r\n",
    "test_prompt": "// StringEncrypter_2Test.java\npackage osa.ora.server.utils;\n\n// -----------------------------------------------------------------------------\r\n// StringEncrypter.java\r\n// -----------------------------------------------------------------------------\r\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport java.security.spec.KeySpec;\nimport java.security.spec.AlgorithmParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEParameterSpec;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringEncrypter}.\n* It contains ten unit test cases for the {@link StringEncrypter#decrypt(String)} method.\n*/\nclass StringEncrypter_2Test {"
}
,{
    "id": "chatcmpl-A5VpYJJbzlfyuvlSz0c12VBSorswS",
    "object": "chat.completion",
    "created": 1725877360,
    "model": "gpt-3.5-turbo-0125",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "```java\n    @Test\n    void testShowDialog_FontSelected() {\n        JFontChooser fontChooser = new JFontChooser();\n        Font selectedFont = fontChooser.showDialog(null, \"Select Font\");\n        assertNotNull(selectedFont);\n    }\n\n    @Test\n    void testShowDialog_FontNotSelected() {\n        JFontChooser fontChooser = new JFontChooser();\n        Font selectedFont = fontChooser.showDialog(null, \"Select Font\");\n        assertNull(selectedFont);\n    }\n\n    @Test\n    void testShowDialog_TitleNotNull() {\n        JFontChooser fontChooser = new JFontChooser();\n        Font selectedFont = fontChooser.showDialog(null, \"Select Font\");\n        assertNotNull(selectedFont);\n    }\n\n    @Test\n    void testShowDialog_TitleNull() {\n        JFontChooser fontChooser = new JFontChooser();\n        Font selectedFont = fontChooser.showDialog(null, null);\n        assertNotNull(selectedFont);\n    }\n\n    @Test\n    void testShowDialog_ComponentNotNull() {\n        JFontChooser fontChooser = new JFontChooser();\n        Font selectedFont = fontChooser.showDialog(new JPanel(), \"Select Font\");\n        assertNotNull(selectedFont);\n    }\n\n    @Test\n    void testShowDialog_ComponentNull() {\n        JFontChooser fontChooser = new JFontChooser();\n        Font selectedFont = fontChooser.showDialog(null, \"Select Font\");\n        assertNotNull(selectedFont);\n    }\n\n    @Test\n    void testShowDialog_ModalTrue() {\n        JFontChooser fontChooser = new JFontChooser();\n        Font selectedFont = fontChooser.showDialog(null, \"Select Font\");\n        assertNotNull(selectedFont);\n    }\n\n    @Test\n    void testShowDialog_ModalFalse() {\n        JFontChooser fontChooser = new JFontChooser();\n        Font selectedFont = fontChooser.showDialog(null, \"Select Font\");\n        assertNotNull(selectedFont);\n    }\n\n    @Test\n    void testShowDialog_OkButtonPressed() {\n        JFontChooser fontChooser = new JFontChooser();\n        Font selectedFont = fontChooser.showDialog(null, \"Select Font\");\n        assertNotNull(selectedFont);\n    }\n\n    @Test\n    void testShowDialog_CancelButtonPressed() {\n        JFontChooser fontChooser = new JFontChooser();\n        Font selectedFont = fontChooser.showDialog(null, \"Select Font\");\n        assertNull(selectedFont);\n    }\n}\n```",
                "refusal": null
            },
            "logprobs": null,
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 4859,
        "completion_tokens": 480,
        "total_tokens": 5339
    },
    "system_fingerprint": null,
    "time_taken": 7.166313886642456,
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/client/ui/utils/JFontChooser_0Test.java",
    "original_code": "// JFontChooser.java\npackage osa.ora.server.client.ui.utils;\n\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.FlowLayout;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.GridBagConstraints;\nimport java.awt.GridBagLayout;\nimport java.awt.Insets;\nimport java.awt.Window;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.Serializable;\nimport javax.swing.AbstractAction;\nimport javax.swing.Action;\nimport javax.swing.ActionMap;\nimport javax.swing.InputMap;\nimport javax.swing.JButton;\nimport javax.swing.JCheckBox;\nimport javax.swing.JComponent;\nimport javax.swing.JDialog;\nimport javax.swing.JLabel;\nimport javax.swing.JList;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.KeyStroke;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.UIManager;\nimport javax.swing.event.ChangeEvent;\nimport javax.swing.event.ChangeListener;\nimport javax.swing.event.EventListenerList;\nimport javax.swing.event.ListSelectionEvent;\nimport javax.swing.event.ListSelectionListener;\n\n/**\n * <code>JFontChooser</code> provides a pane of controls designed to allow\n * a user to manipulate and select a font.\n *\n * This class provides three levels of API:\n * <ol>\n * <li>A static convenience method which shows a modal font-chooser\n * dialog and returns the font selected by the user.\n * <li>A static convenience method for creating a font-chooser dialog\n * where <code>ActionListeners</code> can be specified to be invoked when\n * the user presses one of the dialog buttons.\n * <li>The ability to create instances of <code>JFontChooser</code> panes\n * directly (within any container). <code>PropertyChange</code> listeners\n * can be added to detect when the current \"font\" property changes.\n * </ol>\n * <p>\n *\n * @author Adrian BER\n */\npublic class JFontChooser extends JComponent {\n\n    /**\n     * The list of possible font sizes.\n     */\n    private static final Integer[] SIZES = { 8, 9, 10, 11, 12, 13, 14, 16, 18, 20, 24, 26, 28, 32, 36, 40, 48, 56, 64, 72 };\n\n    /**\n     * The list of possible fonts.\n     */\n    private static final String[] FONTS = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n\n    private FontSelectionModel selectionModel;\n\n    private JList fontList;\n\n    private JList sizeList;\n\n    private JCheckBox boldCheckBox;\n\n    private JCheckBox italicCheckBox;\n\n    private JLabel previewLabel;\n\n    /**\n     * The preview text, if null the font name will be the preview text.\n     */\n    private String previewText;\n\n    /**\n     * Listener used to update the font of the selection model.\n     */\n    private SelectionUpdater selectionUpdater = new SelectionUpdater();\n\n    /**\n     * Listener used to update the font in the components. This should be registered\n     * with the selection model.\n     */\n    private LabelUpdater labelUpdater = new LabelUpdater();\n\n    /**\n     * True if the components are being updated and no event should be generated.\n     */\n    private boolean updatingComponents = false;\n\n    /**\n     * Listener class used to update the font in the components. This should be registered\n     * with the selection model.\n     */\n    private class LabelUpdater implements ChangeListener {\n\n        public void stateChanged(ChangeEvent e) {\n            updateComponents();\n        }\n    }\n\n    /**\n     * Listener class used to update the font of the preview label.\n     */\n    private class SelectionUpdater implements ChangeListener, ListSelectionListener {\n\n        public void stateChanged(ChangeEvent e) {\n            if (!updatingComponents) {\n                setFont(buildFont());\n            }\n        }\n\n        public void valueChanged(ListSelectionEvent e) {\n            if (!updatingComponents) {\n                setFont(buildFont());\n            }\n        }\n    }\n\n    /**\n     * Shows a modal font-chooser dialog and blocks until the\n     * dialog is hidden.  If the user presses the \"OK\" button, then\n     * this method hides/disposes the dialog and returns the selected color.\n     * If the user presses the \"Cancel\" button or closes the dialog without\n     * pressing \"OK\", then this method hides/disposes the dialog and returns\n     * <code>null</code>.\n     *\n     * @param component    the parent <code>Component</code> for the dialog\n     * @param title        the String containing the dialog's title\n     * @return the selected font or <code>null</code> if the user opted out\n     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n     * returns true.\n     * @see java.awt.GraphicsEnvironment#isHeadless\n     */\n    public Font showDialog(Component component, String title) {\n        FontTracker ok = new FontTracker(this);\n        JDialog dialog = createDialog(component, title, true, ok, null);\n        dialog.addWindowListener(new FontChooserDialog.Closer());\n        dialog.addComponentListener(new FontChooserDialog.DisposeOnClose());\n        dialog.setAlwaysOnTop(true);\n        // blocks until user brings dialog down...\n        dialog.setVisible(true);\n        return ok.getFont();\n    }\n\n    /**\n     * Creates and returns a new dialog containing the specified\n     * <code>ColorChooser</code> pane along with \"OK\", \"Cancel\", and \"Reset\"\n     * buttons. If the \"OK\" or \"Cancel\" buttons are pressed, the dialog is\n     * automatically hidden (but not disposed).  If the \"Reset\"\n     * button is pressed, the color-chooser's color will be reset to the\n     * font which was set the last time <code>show</code> was invoked on the\n     * dialog and the dialog will remain showing.\n     *\n     * @param c              the parent component for the dialog\n     * @param title          the title for the dialog\n     * @param modal          a boolean. When true, the remainder of the program\n     *                       is inactive until the dialog is closed.\n     * @param okListener     the ActionListener invoked when \"OK\" is pressed\n     * @param cancelListener the ActionListener invoked when \"Cancel\" is pressed\n     * @return a new dialog containing the font-chooser pane\n     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n     * returns true.\n     * @see java.awt.GraphicsEnvironment#isHeadless\n     */\n    public JDialog createDialog(Component c, String title, boolean modal, ActionListener okListener, ActionListener cancelListener) {\n        return new FontChooserDialog(c, title, modal, this, okListener, cancelListener);\n    }\n\n    /**\n     * Creates a color chooser pane with an initial font which is the same font\n     * as the default font for labels.\n     */\n    public JFontChooser() {\n        this(new DefaultFontSelectionModel());\n    }\n\n    /**\n     * Creates a font chooser pane with the specified initial font.\n     *\n     * @param initialFont the initial font set in the chooser\n     */\n    public JFontChooser(Font initialFont) {\n        this(new DefaultFontSelectionModel(initialFont));\n    }\n\n    /**\n     * Creates a font chooser pane with the specified\n     * <code>FontSelectionModel</code>.\n     *\n     * @param model the font selection model used by this component\n     */\n    public JFontChooser(FontSelectionModel model) {\n        selectionModel = model;\n        init(model.getSelectedFont());\n        selectionModel.addChangeListener(labelUpdater);\n    }\n\n    private void init(Font font) {\n        setLayout(new GridBagLayout());\n        Insets ins = new Insets(2, 2, 2, 2);\n        fontList = new JList(FONTS);\n        fontList.setVisibleRowCount(10);\n        fontList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        add(new JScrollPane(fontList), new GridBagConstraints(0, 0, 1, 1, 2, 2, GridBagConstraints.CENTER, GridBagConstraints.BOTH, ins, 0, 0));\n        sizeList = new JList(SIZES);\n        ((JLabel) sizeList.getCellRenderer()).setHorizontalAlignment(JLabel.RIGHT);\n        sizeList.setVisibleRowCount(10);\n        sizeList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        add(new JScrollPane(sizeList), new GridBagConstraints(1, 0, 1, 1, 1, 2, GridBagConstraints.CENTER, GridBagConstraints.BOTH, ins, 0, 0));\n        boldCheckBox = new JCheckBox(\"Bold\");\n        add(boldCheckBox, new GridBagConstraints(0, 1, 2, 1, 1, 0, GridBagConstraints.WEST, GridBagConstraints.NONE, ins, 0, 0));\n        italicCheckBox = new JCheckBox(\"Italic\");\n        add(italicCheckBox, new GridBagConstraints(0, 2, 2, 1, 1, 0, GridBagConstraints.WEST, GridBagConstraints.NONE, ins, 0, 0));\n        previewLabel = new JLabel(\"\");\n        previewLabel.setHorizontalAlignment(JLabel.CENTER);\n        previewLabel.setVerticalAlignment(JLabel.CENTER);\n        add(new JScrollPane(previewLabel), new GridBagConstraints(0, 3, 2, 1, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.BOTH, ins, 0, 0));\n        setFont(font == null ? previewLabel.getFont() : font);\n        fontList.addListSelectionListener(selectionUpdater);\n        sizeList.addListSelectionListener(selectionUpdater);\n        boldCheckBox.addChangeListener(selectionUpdater);\n        italicCheckBox.addChangeListener(selectionUpdater);\n    }\n\n    private Font buildFont() {\n        //        Font labelFont = previewLabel.getFont();\n        String fontName = (String) fontList.getSelectedValue();\n        if (fontName == null) {\n            return null;\n            //            fontName = labelFont.getName();\n        }\n        Integer sizeInt = (Integer) sizeList.getSelectedValue();\n        if (sizeInt == null) {\n            //            size = labelFont.getSize();\n            return null;\n        }\n        // create the font\n        //        // first create the font attributes\n        //        HashMap map = new HashMap();\n        //        map.put(TextAttribute.BACKGROUND, Color.white);\n        //        map.put(TextAttribute.FAMILY, fontName);\n        //        map.put(TextAttribute.FOREGROUND, Color.black);\n        //        map.put(TextAttribute.SIZE , new Float(size));\n        //        map.put(TextAttribute.UNDERLINE, italicCheckBox.isSelected() ? TextAttribute.UNDERLINE_LOW_ONE_PIXEL : TextAttribute.UNDERLINE_LOW_TWO_PIXEL);\n        //        map.put(TextAttribute.STRIKETHROUGH, italicCheckBox.isSelected() ? TextAttribute.STRIKETHROUGH_ON : Boolean.FALSE);\n        //        map.put(TextAttribute.WEIGHT, boldCheckBox.isSelected() ? TextAttribute.WEIGHT_BOLD : TextAttribute.WEIGHT_REGULAR);\n        //        map.put(TextAttribute.POSTURE,\n        //                italicCheckBox.isSelected() ? TextAttribute.POSTURE_OBLIQUE : TextAttribute.POSTURE_REGULAR);\n        //\n        //        return new Font(map);\n        return new Font(fontName, (italicCheckBox.isSelected() ? Font.ITALIC : Font.PLAIN) | (boldCheckBox.isSelected() ? Font.BOLD : Font.PLAIN), sizeInt);\n    }\n\n    /**\n     * Updates the font in the preview component according to the selected values.\n     */\n    private void updateComponents() {\n        updatingComponents = true;\n        Font font = getFont();\n        fontList.setSelectedValue(font.getName(), true);\n        sizeList.setSelectedValue(font.getSize(), true);\n        boldCheckBox.setSelected(font.isBold());\n        italicCheckBox.setSelected(font.isItalic());\n        if (previewText == null) {\n            previewLabel.setText(font.getName());\n        }\n        // set the font and fire a property change\n        Font oldValue = previewLabel.getFont();\n        previewLabel.setFont(font);\n        firePropertyChange(\"font\", oldValue, font);\n        updatingComponents = false;\n    }\n\n    /**\n     * Returns the data model that handles font selections.\n     *\n     * @return a FontSelectionModel object\n     */\n    public FontSelectionModel getSelectionModel() {\n        return selectionModel;\n    }\n\n    /**\n     * Set the model containing the selected font.\n     *\n     * @param newModel   the new FontSelectionModel object\n     */\n    public void setSelectionModel(FontSelectionModel newModel) {\n        FontSelectionModel oldModel = selectionModel;\n        selectionModel = newModel;\n        oldModel.removeChangeListener(labelUpdater);\n        newModel.addChangeListener(labelUpdater);\n        firePropertyChange(\"selectionModel\", oldModel, newModel);\n    }\n\n    /**\n     * Gets the current font value from the font chooser.\n     *\n     * @return the current font value of the font chooser\n     */\n    public Font getFont() {\n        return selectionModel.getSelectedFont();\n    }\n\n    /**\n     * Sets the current font of the font chooser to the specified font.\n     * The <code>ColorSelectionModel</code> will fire a <code>ChangeEvent</code>\n     * @param font the font to be set in the font chooser\n     * @see JComponent#addPropertyChangeListener\n     */\n    public void setFont(Font font) {\n        selectionModel.setSelectedFont(font);\n    }\n\n    /**\n     * Returns the preview text displayed in the preview component.\n     * @return the preview text, if null the font name will be displayed\n     */\n    public String getPreviewText() {\n        return previewText;\n    }\n\n    /**\n     * Sets the preview text displayed in the preview component.\n     * @param previewText the preview text, if null the font name will be displayed\n     */\n    public void setPreviewText(String previewText) {\n        this.previewText = previewText;\n        previewLabel.setText(\"\");\n        updateComponents();\n    }\n}\n\n/*\n * Class which builds a font chooser dialog consisting of\n * a JFontChooser with \"Ok\", \"Cancel\", and \"Reset\" buttons.\n *\n * Note: This needs to be fixed to deal with localization!\n */\nclass FontChooserDialog extends JDialog {\n\n    private Font initialFont;\n\n    private JFontChooser chooserPane;\n\n    public FontChooserDialog(Component c, String title, boolean modal, JFontChooser chooserPane, ActionListener okListener, ActionListener cancelListener) {\n        super(JOptionPane.getFrameForComponent(c), title, modal);\n        //setResizable(false);\n        String okString = UIManager.getString(\"ColorChooser.okText\");\n        String cancelString = UIManager.getString(\"ColorChooser.cancelText\");\n        String resetString = UIManager.getString(\"ColorChooser.resetText\");\n        /*\n         * Create Lower button panel\n         */\n        JPanel buttonPane = new JPanel();\n        buttonPane.setLayout(new FlowLayout(FlowLayout.CENTER));\n        JButton okButton = new JButton(okString);\n        getRootPane().setDefaultButton(okButton);\n        okButton.setActionCommand(\"OK\");\n        if (okListener != null) {\n            okButton.addActionListener(okListener);\n        }\n        okButton.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                setVisible(false);\n            }\n        });\n        buttonPane.add(okButton);\n        JButton cancelButton = new JButton(cancelString);\n        // The following few lines are used to register esc to close the dialog\n        Action cancelKeyAction = new AbstractAction() {\n\n            public void actionPerformed(ActionEvent e) {\n                // todo make it in 1.3\n                //                ActionListener[] listeners\n                //                        = ((AbstractButton) e.getSource()).getActionListeners();\n                //                for (int i = 0; i < listeners.length; i++) {\n                //                    listeners[i].actionPerformed(e);\n                //                }\n            }\n        };\n        KeyStroke cancelKeyStroke = KeyStroke.getKeyStroke((char) KeyEvent.VK_ESCAPE);\n        InputMap inputMap = cancelButton.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);\n        ActionMap actionMap = cancelButton.getActionMap();\n        if (inputMap != null && actionMap != null) {\n            inputMap.put(cancelKeyStroke, \"cancel\");\n            actionMap.put(\"cancel\", cancelKeyAction);\n        }\n        // end esc handling\n        cancelButton.setActionCommand(\"cancel\");\n        if (cancelListener != null) {\n            cancelButton.addActionListener(cancelListener);\n        }\n        cancelButton.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                setVisible(false);\n            }\n        });\n        buttonPane.add(cancelButton);\n        JButton resetButton = new JButton(resetString);\n        resetButton.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                reset();\n            }\n        });\n        int mnemonic = UIManager.getInt(\"ColorChooser.resetMnemonic\");\n        if (mnemonic != -1) {\n            resetButton.setMnemonic(mnemonic);\n        }\n        buttonPane.add(resetButton);\n        // initialiase the content pane\n        this.chooserPane = chooserPane;\n        Container contentPane = getContentPane();\n        contentPane.setLayout(new BorderLayout());\n        contentPane.add(chooserPane, BorderLayout.CENTER);\n        contentPane.add(buttonPane, BorderLayout.SOUTH);\n        pack();\n        setLocationRelativeTo(c);\n    }\n\n    public void setVisible(boolean visible) {\n        if (visible)\n            initialFont = chooserPane.getFont();\n        super.setVisible(visible);\n    }\n\n    public void reset() {\n        chooserPane.setFont(initialFont);\n    }\n\n    static class Closer extends WindowAdapter implements Serializable {\n\n        public void windowClosing(WindowEvent e) {\n            Window w = e.getWindow();\n            w.setVisible(false);\n        }\n    }\n\n    static class DisposeOnClose extends ComponentAdapter implements Serializable {\n\n        public void componentHidden(ComponentEvent e) {\n            Window w = (Window) e.getComponent();\n            w.dispose();\n        }\n    }\n}\n\nclass FontTracker implements ActionListener, Serializable {\n\n    JFontChooser chooser;\n\n    Font color;\n\n    public FontTracker(JFontChooser c) {\n        chooser = c;\n    }\n\n    public void actionPerformed(ActionEvent e) {\n        color = chooser.getFont();\n    }\n\n    public Font getFont() {\n        return color;\n    }\n}\n\n/**\n * A generic implementation of <code>{@link FontSelectionModel}</code>.\n *\n * @author Adrian BER\n */\nclass DefaultFontSelectionModel implements FontSelectionModel {\n\n    /**\n     * The default selected font.\n     */\n    private static final Font DEFAULT_INITIAL_FONT = new Font(\"Dialog\", Font.PLAIN, 12);\n\n    /**\n     * The selected font.\n     */\n    private Font selectedFont;\n\n    /**\n     * The change listeners notified by a change in this model.\n     */\n    private EventListenerList listeners = new EventListenerList();\n\n    /**\n     * Creates a <code>DefaultFontSelectionModel</code> with the\n     * current font set to <code>Dialog, 12</code>.  This is\n     * the default constructor.\n     */\n    public DefaultFontSelectionModel() {\n        this(DEFAULT_INITIAL_FONT);\n    }\n\n    /**\n     * Creates a <code>DefaultFontSelectionModel</code> with the\n     * current font set to <code>font</code>, which should be\n     * non-<code>null</code>.  Note that setting the font to\n     * <code>null</code> is undefined and may have unpredictable\n     * results.\n     *\n     * @param selectedFont the new <code>Font</code>\n     */\n    public DefaultFontSelectionModel(Font selectedFont) {\n        if (selectedFont == null) {\n            selectedFont = DEFAULT_INITIAL_FONT;\n        }\n        this.selectedFont = selectedFont;\n    }\n\n    public Font getSelectedFont() {\n        return selectedFont;\n    }\n\n    public void setSelectedFont(Font selectedFont) {\n        if (selectedFont != null) {\n            this.selectedFont = selectedFont;\n            fireChangeListeners();\n        }\n    }\n\n    public void addChangeListener(ChangeListener listener) {\n        listeners.add(ChangeListener.class, listener);\n    }\n\n    public void removeChangeListener(ChangeListener listener) {\n        listeners.remove(ChangeListener.class, listener);\n    }\n\n    /**\n     * Fires the listeners registered with this model.\n     */\n    protected void fireChangeListeners() {\n        ChangeEvent ev = new ChangeEvent(this);\n        Object[] l = listeners.getListeners(ChangeListener.class);\n        for (Object listener : l) {\n            ((ChangeListener) listener).stateChanged(ev);\n        }\n    }\n}\n\n/**\n * A model that supports selecting a <code>Font</code>.\n *\n * @author Adrian BER\n *\n * @see java.awt.Font\n */\ninterface FontSelectionModel {\n\n    /**\n     * Returns the selected <code>Font</code> which should be\n     * non-<code>null</code>.\n     *\n     * @return  the selected <code>Font</code>\n     * @see     #setSelectedFont\n     */\n    Font getSelectedFont();\n\n    /**\n     * Sets the selected font to <code>font</code>.\n     * Note that setting the font to <code>null</code>\n     * is undefined and may have unpredictable results.\n     * This method fires a state changed event if it sets the\n     * current font to a new non-<code>null</code> font.\n     *\n     * @param font the new <code>Font</code>\n     * @see   #getSelectedFont\n     * @see   #addChangeListener\n     */\n    void setSelectedFont(Font font);\n\n    /**\n     * Adds <code>listener</code> as a listener to changes in the model.\n     * @param listener the <code>ChangeListener</code> to be added\n     */\n    void addChangeListener(ChangeListener listener);\n\n    /**\n     * Removes <code>listener</code> as a listener to changes in the model.\n     * @param listener the <code>ChangeListener</code> to be removed\n     */\n    void removeChangeListener(ChangeListener listener);\n}\n",
    "test_prompt": "// JFontChooser_0Test.java\npackage osa.ora.server.client.ui.utils;\n\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.FlowLayout;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.GridBagConstraints;\nimport java.awt.GridBagLayout;\nimport java.awt.Insets;\nimport java.awt.Window;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.Serializable;\nimport javax.swing.AbstractAction;\nimport javax.swing.Action;\nimport javax.swing.ActionMap;\nimport javax.swing.InputMap;\nimport javax.swing.JButton;\nimport javax.swing.JCheckBox;\nimport javax.swing.JComponent;\nimport javax.swing.JDialog;\nimport javax.swing.JLabel;\nimport javax.swing.JList;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.KeyStroke;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.UIManager;\nimport javax.swing.event.ChangeEvent;\nimport javax.swing.event.ChangeListener;\nimport javax.swing.event.EventListenerList;\nimport javax.swing.event.ListSelectionEvent;\nimport javax.swing.event.ListSelectionListener;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JFontChooser}.\n* It contains ten unit test cases for the {@link JFontChooser#showDialog(Component, String)} method.\n*/\nclass JFontChooser_0Test {"
}
,{
    "id": "chatcmpl-A5VqbqRJzv6CrGmqO54JoOuRRWukm",
    "object": "chat.completion",
    "created": 1725877425,
    "model": "gpt-3.5-turbo-0125",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "```java\n    @Test\n    void testCreateDialog_WithOkListener() {\n        JFontChooser fontChooser = new JFontChooser();\n        ActionListener okListener = new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                // OK button action\n            }\n        };\n        JDialog dialog = fontChooser.createDialog(new JPanel(), \"Choose Font\", true, okListener, null);\n        assertNotNull(dialog);\n    }\n\n    @Test\n    void testCreateDialog_WithCancelListener() {\n        JFontChooser fontChooser = new JFontChooser();\n        ActionListener cancelListener = new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                // Cancel button action\n            }\n        };\n        JDialog dialog = fontChooser.createDialog(new JPanel(), \"Choose Font\", true, null, cancelListener);\n        assertNotNull(dialog);\n    }\n\n    @Test\n    void testCreateDialog_WithOkAndCancelListeners() {\n        JFontChooser fontChooser = new JFontChooser();\n        ActionListener okListener = new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                // OK button action\n            }\n        };\n        ActionListener cancelListener = new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                // Cancel button action\n            }\n        };\n        JDialog dialog = fontChooser.createDialog(new JPanel(), \"Choose Font\", true, okListener, cancelListener);\n        assertNotNull(dialog);\n    }\n\n    @Test\n    void testCreateDialog_WithoutListeners() {\n        JFontChooser fontChooser = new JFontChooser();\n        JDialog dialog = fontChooser.createDialog(new JPanel(), \"Choose Font\", true, null, null);\n        assertNotNull(dialog);\n    }\n\n    @Test\n    void testCreateDialog_WithNullComponent() {\n        JFontChooser fontChooser = new JFontChooser();\n        JDialog dialog = fontChooser.createDialog(null, \"Choose Font\", true, null, null);\n        assertNotNull(dialog);\n    }\n\n    @Test\n    void testCreateDialog_WithEmptyTitle() {\n        JFontChooser fontChooser = new JFontChooser();\n        JDialog dialog = fontChooser.createDialog(new JPanel(), \"\", true, null, null);\n        assertNotNull(dialog);\n    }\n\n    @Test\n    void testCreateDialog_WithNullTitle() {\n        JFontChooser fontChooser = new JFontChooser();\n        JDialog dialog = fontChooser.createDialog(new JPanel(), null, true, null, null);\n        assertNotNull(dialog);\n    }\n\n    @Test\n    void testCreateDialog_WithNonModal() {\n        JFontChooser fontChooser = new JFontChooser();\n        JDialog dialog = fontChooser.createDialog(new JPanel(), \"Choose Font\", false, null, null);\n        assertNotNull(dialog);\n    }\n\n    @Test\n    void testCreateDialog_WithNullChooserPane() {\n        JFontChooser fontChooser = new JFontChooser();\n        JDialog dialog = fontChooser.createDialog(new JPanel(), \"Choose Font\", true, null, null);\n        assertNotNull(dialog);\n    }\n\n    @Test\n    void testCreateDialog_Visibility() {\n        JFontChooser fontChooser = new JFontChooser();\n        ActionListener okListener = new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                // OK button action\n            }\n        };\n        JDialog dialog = fontChooser.createDialog(new JPanel(), \"Choose Font\", true, okListener, null);\n        dialog.setVisible(true);\n        assertTrue(dialog.isVisible());\n    }\n```\n",
                "refusal": null
            },
            "logprobs": null,
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 4864,
        "completion_tokens": 716,
        "total_tokens": 5580
    },
    "system_fingerprint": null,
    "time_taken": 10.43741750717163,
    "prompt_id": "/EvoSuiteBenchmark/original/73_fim1/src/main/java/osa/ora/server/client/ui/utils/JFontChooser_1Test.java",
    "original_code": "// JFontChooser.java\npackage osa.ora.server.client.ui.utils;\n\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.FlowLayout;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.GridBagConstraints;\nimport java.awt.GridBagLayout;\nimport java.awt.Insets;\nimport java.awt.Window;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.Serializable;\nimport javax.swing.AbstractAction;\nimport javax.swing.Action;\nimport javax.swing.ActionMap;\nimport javax.swing.InputMap;\nimport javax.swing.JButton;\nimport javax.swing.JCheckBox;\nimport javax.swing.JComponent;\nimport javax.swing.JDialog;\nimport javax.swing.JLabel;\nimport javax.swing.JList;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.KeyStroke;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.UIManager;\nimport javax.swing.event.ChangeEvent;\nimport javax.swing.event.ChangeListener;\nimport javax.swing.event.EventListenerList;\nimport javax.swing.event.ListSelectionEvent;\nimport javax.swing.event.ListSelectionListener;\n\n/**\n * <code>JFontChooser</code> provides a pane of controls designed to allow\n * a user to manipulate and select a font.\n *\n * This class provides three levels of API:\n * <ol>\n * <li>A static convenience method which shows a modal font-chooser\n * dialog and returns the font selected by the user.\n * <li>A static convenience method for creating a font-chooser dialog\n * where <code>ActionListeners</code> can be specified to be invoked when\n * the user presses one of the dialog buttons.\n * <li>The ability to create instances of <code>JFontChooser</code> panes\n * directly (within any container). <code>PropertyChange</code> listeners\n * can be added to detect when the current \"font\" property changes.\n * </ol>\n * <p>\n *\n * @author Adrian BER\n */\npublic class JFontChooser extends JComponent {\n\n    /**\n     * The list of possible font sizes.\n     */\n    private static final Integer[] SIZES = { 8, 9, 10, 11, 12, 13, 14, 16, 18, 20, 24, 26, 28, 32, 36, 40, 48, 56, 64, 72 };\n\n    /**\n     * The list of possible fonts.\n     */\n    private static final String[] FONTS = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n\n    private FontSelectionModel selectionModel;\n\n    private JList fontList;\n\n    private JList sizeList;\n\n    private JCheckBox boldCheckBox;\n\n    private JCheckBox italicCheckBox;\n\n    private JLabel previewLabel;\n\n    /**\n     * The preview text, if null the font name will be the preview text.\n     */\n    private String previewText;\n\n    /**\n     * Listener used to update the font of the selection model.\n     */\n    private SelectionUpdater selectionUpdater = new SelectionUpdater();\n\n    /**\n     * Listener used to update the font in the components. This should be registered\n     * with the selection model.\n     */\n    private LabelUpdater labelUpdater = new LabelUpdater();\n\n    /**\n     * True if the components are being updated and no event should be generated.\n     */\n    private boolean updatingComponents = false;\n\n    /**\n     * Listener class used to update the font in the components. This should be registered\n     * with the selection model.\n     */\n    private class LabelUpdater implements ChangeListener {\n\n        public void stateChanged(ChangeEvent e) {\n            updateComponents();\n        }\n    }\n\n    /**\n     * Listener class used to update the font of the preview label.\n     */\n    private class SelectionUpdater implements ChangeListener, ListSelectionListener {\n\n        public void stateChanged(ChangeEvent e) {\n            if (!updatingComponents) {\n                setFont(buildFont());\n            }\n        }\n\n        public void valueChanged(ListSelectionEvent e) {\n            if (!updatingComponents) {\n                setFont(buildFont());\n            }\n        }\n    }\n\n    /**\n     * Shows a modal font-chooser dialog and blocks until the\n     * dialog is hidden.  If the user presses the \"OK\" button, then\n     * this method hides/disposes the dialog and returns the selected color.\n     * If the user presses the \"Cancel\" button or closes the dialog without\n     * pressing \"OK\", then this method hides/disposes the dialog and returns\n     * <code>null</code>.\n     *\n     * @param component    the parent <code>Component</code> for the dialog\n     * @param title        the String containing the dialog's title\n     * @return the selected font or <code>null</code> if the user opted out\n     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n     * returns true.\n     * @see java.awt.GraphicsEnvironment#isHeadless\n     */\n    public Font showDialog(Component component, String title) {\n        FontTracker ok = new FontTracker(this);\n        JDialog dialog = createDialog(component, title, true, ok, null);\n        dialog.addWindowListener(new FontChooserDialog.Closer());\n        dialog.addComponentListener(new FontChooserDialog.DisposeOnClose());\n        dialog.setAlwaysOnTop(true);\n        // blocks until user brings dialog down...\n        dialog.setVisible(true);\n        return ok.getFont();\n    }\n\n    /**\n     * Creates and returns a new dialog containing the specified\n     * <code>ColorChooser</code> pane along with \"OK\", \"Cancel\", and \"Reset\"\n     * buttons. If the \"OK\" or \"Cancel\" buttons are pressed, the dialog is\n     * automatically hidden (but not disposed).  If the \"Reset\"\n     * button is pressed, the color-chooser's color will be reset to the\n     * font which was set the last time <code>show</code> was invoked on the\n     * dialog and the dialog will remain showing.\n     *\n     * @param c              the parent component for the dialog\n     * @param title          the title for the dialog\n     * @param modal          a boolean. When true, the remainder of the program\n     *                       is inactive until the dialog is closed.\n     * @param okListener     the ActionListener invoked when \"OK\" is pressed\n     * @param cancelListener the ActionListener invoked when \"Cancel\" is pressed\n     * @return a new dialog containing the font-chooser pane\n     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n     * returns true.\n     * @see java.awt.GraphicsEnvironment#isHeadless\n     */\n    public JDialog createDialog(Component c, String title, boolean modal, ActionListener okListener, ActionListener cancelListener) {\n        return new FontChooserDialog(c, title, modal, this, okListener, cancelListener);\n    }\n\n    /**\n     * Creates a color chooser pane with an initial font which is the same font\n     * as the default font for labels.\n     */\n    public JFontChooser() {\n        this(new DefaultFontSelectionModel());\n    }\n\n    /**\n     * Creates a font chooser pane with the specified initial font.\n     *\n     * @param initialFont the initial font set in the chooser\n     */\n    public JFontChooser(Font initialFont) {\n        this(new DefaultFontSelectionModel(initialFont));\n    }\n\n    /**\n     * Creates a font chooser pane with the specified\n     * <code>FontSelectionModel</code>.\n     *\n     * @param model the font selection model used by this component\n     */\n    public JFontChooser(FontSelectionModel model) {\n        selectionModel = model;\n        init(model.getSelectedFont());\n        selectionModel.addChangeListener(labelUpdater);\n    }\n\n    private void init(Font font) {\n        setLayout(new GridBagLayout());\n        Insets ins = new Insets(2, 2, 2, 2);\n        fontList = new JList(FONTS);\n        fontList.setVisibleRowCount(10);\n        fontList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        add(new JScrollPane(fontList), new GridBagConstraints(0, 0, 1, 1, 2, 2, GridBagConstraints.CENTER, GridBagConstraints.BOTH, ins, 0, 0));\n        sizeList = new JList(SIZES);\n        ((JLabel) sizeList.getCellRenderer()).setHorizontalAlignment(JLabel.RIGHT);\n        sizeList.setVisibleRowCount(10);\n        sizeList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        add(new JScrollPane(sizeList), new GridBagConstraints(1, 0, 1, 1, 1, 2, GridBagConstraints.CENTER, GridBagConstraints.BOTH, ins, 0, 0));\n        boldCheckBox = new JCheckBox(\"Bold\");\n        add(boldCheckBox, new GridBagConstraints(0, 1, 2, 1, 1, 0, GridBagConstraints.WEST, GridBagConstraints.NONE, ins, 0, 0));\n        italicCheckBox = new JCheckBox(\"Italic\");\n        add(italicCheckBox, new GridBagConstraints(0, 2, 2, 1, 1, 0, GridBagConstraints.WEST, GridBagConstraints.NONE, ins, 0, 0));\n        previewLabel = new JLabel(\"\");\n        previewLabel.setHorizontalAlignment(JLabel.CENTER);\n        previewLabel.setVerticalAlignment(JLabel.CENTER);\n        add(new JScrollPane(previewLabel), new GridBagConstraints(0, 3, 2, 1, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.BOTH, ins, 0, 0));\n        setFont(font == null ? previewLabel.getFont() : font);\n        fontList.addListSelectionListener(selectionUpdater);\n        sizeList.addListSelectionListener(selectionUpdater);\n        boldCheckBox.addChangeListener(selectionUpdater);\n        italicCheckBox.addChangeListener(selectionUpdater);\n    }\n\n    private Font buildFont() {\n        //        Font labelFont = previewLabel.getFont();\n        String fontName = (String) fontList.getSelectedValue();\n        if (fontName == null) {\n            return null;\n            //            fontName = labelFont.getName();\n        }\n        Integer sizeInt = (Integer) sizeList.getSelectedValue();\n        if (sizeInt == null) {\n            //            size = labelFont.getSize();\n            return null;\n        }\n        // create the font\n        //        // first create the font attributes\n        //        HashMap map = new HashMap();\n        //        map.put(TextAttribute.BACKGROUND, Color.white);\n        //        map.put(TextAttribute.FAMILY, fontName);\n        //        map.put(TextAttribute.FOREGROUND, Color.black);\n        //        map.put(TextAttribute.SIZE , new Float(size));\n        //        map.put(TextAttribute.UNDERLINE, italicCheckBox.isSelected() ? TextAttribute.UNDERLINE_LOW_ONE_PIXEL : TextAttribute.UNDERLINE_LOW_TWO_PIXEL);\n        //        map.put(TextAttribute.STRIKETHROUGH, italicCheckBox.isSelected() ? TextAttribute.STRIKETHROUGH_ON : Boolean.FALSE);\n        //        map.put(TextAttribute.WEIGHT, boldCheckBox.isSelected() ? TextAttribute.WEIGHT_BOLD : TextAttribute.WEIGHT_REGULAR);\n        //        map.put(TextAttribute.POSTURE,\n        //                italicCheckBox.isSelected() ? TextAttribute.POSTURE_OBLIQUE : TextAttribute.POSTURE_REGULAR);\n        //\n        //        return new Font(map);\n        return new Font(fontName, (italicCheckBox.isSelected() ? Font.ITALIC : Font.PLAIN) | (boldCheckBox.isSelected() ? Font.BOLD : Font.PLAIN), sizeInt);\n    }\n\n    /**\n     * Updates the font in the preview component according to the selected values.\n     */\n    private void updateComponents() {\n        updatingComponents = true;\n        Font font = getFont();\n        fontList.setSelectedValue(font.getName(), true);\n        sizeList.setSelectedValue(font.getSize(), true);\n        boldCheckBox.setSelected(font.isBold());\n        italicCheckBox.setSelected(font.isItalic());\n        if (previewText == null) {\n            previewLabel.setText(font.getName());\n        }\n        // set the font and fire a property change\n        Font oldValue = previewLabel.getFont();\n        previewLabel.setFont(font);\n        firePropertyChange(\"font\", oldValue, font);\n        updatingComponents = false;\n    }\n\n    /**\n     * Returns the data model that handles font selections.\n     *\n     * @return a FontSelectionModel object\n     */\n    public FontSelectionModel getSelectionModel() {\n        return selectionModel;\n    }\n\n    /**\n     * Set the model containing the selected font.\n     *\n     * @param newModel   the new FontSelectionModel object\n     */\n    public void setSelectionModel(FontSelectionModel newModel) {\n        FontSelectionModel oldModel = selectionModel;\n        selectionModel = newModel;\n        oldModel.removeChangeListener(labelUpdater);\n        newModel.addChangeListener(labelUpdater);\n        firePropertyChange(\"selectionModel\", oldModel, newModel);\n    }\n\n    /**\n     * Gets the current font value from the font chooser.\n     *\n     * @return the current font value of the font chooser\n     */\n    public Font getFont() {\n        return selectionModel.getSelectedFont();\n    }\n\n    /**\n     * Sets the current font of the font chooser to the specified font.\n     * The <code>ColorSelectionModel</code> will fire a <code>ChangeEvent</code>\n     * @param font the font to be set in the font chooser\n     * @see JComponent#addPropertyChangeListener\n     */\n    public void setFont(Font font) {\n        selectionModel.setSelectedFont(font);\n    }\n\n    /**\n     * Returns the preview text displayed in the preview component.\n     * @return the preview text, if null the font name will be displayed\n     */\n    public String getPreviewText() {\n        return previewText;\n    }\n\n    /**\n     * Sets the preview text displayed in the preview component.\n     * @param previewText the preview text, if null the font name will be displayed\n     */\n    public void setPreviewText(String previewText) {\n        this.previewText = previewText;\n        previewLabel.setText(\"\");\n        updateComponents();\n    }\n}\n\n/*\n * Class which builds a font chooser dialog consisting of\n * a JFontChooser with \"Ok\", \"Cancel\", and \"Reset\" buttons.\n *\n * Note: This needs to be fixed to deal with localization!\n */\nclass FontChooserDialog extends JDialog {\n\n    private Font initialFont;\n\n    private JFontChooser chooserPane;\n\n    public FontChooserDialog(Component c, String title, boolean modal, JFontChooser chooserPane, ActionListener okListener, ActionListener cancelListener) {\n        super(JOptionPane.getFrameForComponent(c), title, modal);\n        //setResizable(false);\n        String okString = UIManager.getString(\"ColorChooser.okText\");\n        String cancelString = UIManager.getString(\"ColorChooser.cancelText\");\n        String resetString = UIManager.getString(\"ColorChooser.resetText\");\n        /*\n         * Create Lower button panel\n         */\n        JPanel buttonPane = new JPanel();\n        buttonPane.setLayout(new FlowLayout(FlowLayout.CENTER));\n        JButton okButton = new JButton(okString);\n        getRootPane().setDefaultButton(okButton);\n        okButton.setActionCommand(\"OK\");\n        if (okListener != null) {\n            okButton.addActionListener(okListener);\n        }\n        okButton.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                setVisible(false);\n            }\n        });\n        buttonPane.add(okButton);\n        JButton cancelButton = new JButton(cancelString);\n        // The following few lines are used to register esc to close the dialog\n        Action cancelKeyAction = new AbstractAction() {\n\n            public void actionPerformed(ActionEvent e) {\n                // todo make it in 1.3\n                //                ActionListener[] listeners\n                //                        = ((AbstractButton) e.getSource()).getActionListeners();\n                //                for (int i = 0; i < listeners.length; i++) {\n                //                    listeners[i].actionPerformed(e);\n                //                }\n            }\n        };\n        KeyStroke cancelKeyStroke = KeyStroke.getKeyStroke((char) KeyEvent.VK_ESCAPE);\n        InputMap inputMap = cancelButton.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);\n        ActionMap actionMap = cancelButton.getActionMap();\n        if (inputMap != null && actionMap != null) {\n            inputMap.put(cancelKeyStroke, \"cancel\");\n            actionMap.put(\"cancel\", cancelKeyAction);\n        }\n        // end esc handling\n        cancelButton.setActionCommand(\"cancel\");\n        if (cancelListener != null) {\n            cancelButton.addActionListener(cancelListener);\n        }\n        cancelButton.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                setVisible(false);\n            }\n        });\n        buttonPane.add(cancelButton);\n        JButton resetButton = new JButton(resetString);\n        resetButton.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                reset();\n            }\n        });\n        int mnemonic = UIManager.getInt(\"ColorChooser.resetMnemonic\");\n        if (mnemonic != -1) {\n            resetButton.setMnemonic(mnemonic);\n        }\n        buttonPane.add(resetButton);\n        // initialiase the content pane\n        this.chooserPane = chooserPane;\n        Container contentPane = getContentPane();\n        contentPane.setLayout(new BorderLayout());\n        contentPane.add(chooserPane, BorderLayout.CENTER);\n        contentPane.add(buttonPane, BorderLayout.SOUTH);\n        pack();\n        setLocationRelativeTo(c);\n    }\n\n    public void setVisible(boolean visible) {\n        if (visible)\n            initialFont = chooserPane.getFont();\n        super.setVisible(visible);\n    }\n\n    public void reset() {\n        chooserPane.setFont(initialFont);\n    }\n\n    static class Closer extends WindowAdapter implements Serializable {\n\n        public void windowClosing(WindowEvent e) {\n            Window w = e.getWindow();\n            w.setVisible(false);\n        }\n    }\n\n    static class DisposeOnClose extends ComponentAdapter implements Serializable {\n\n        public void componentHidden(ComponentEvent e) {\n            Window w = (Window) e.getComponent();\n            w.dispose();\n        }\n    }\n}\n\nclass FontTracker implements ActionListener, Serializable {\n\n    JFontChooser chooser;\n\n    Font color;\n\n    public FontTracker(JFontChooser c) {\n        chooser = c;\n    }\n\n    public void actionPerformed(ActionEvent e) {\n        color = chooser.getFont();\n    }\n\n    public Font getFont() {\n        return color;\n    }\n}\n\n/**\n * A generic implementation of <code>{@link FontSelectionModel}</code>.\n *\n * @author Adrian BER\n */\nclass DefaultFontSelectionModel implements FontSelectionModel {\n\n    /**\n     * The default selected font.\n     */\n    private static final Font DEFAULT_INITIAL_FONT = new Font(\"Dialog\", Font.PLAIN, 12);\n\n    /**\n     * The selected font.\n     */\n    private Font selectedFont;\n\n    /**\n     * The change listeners notified by a change in this model.\n     */\n    private EventListenerList listeners = new EventListenerList();\n\n    /**\n     * Creates a <code>DefaultFontSelectionModel</code> with the\n     * current font set to <code>Dialog, 12</code>.  This is\n     * the default constructor.\n     */\n    public DefaultFontSelectionModel() {\n        this(DEFAULT_INITIAL_FONT);\n    }\n\n    /**\n     * Creates a <code>DefaultFontSelectionModel</code> with the\n     * current font set to <code>font</code>, which should be\n     * non-<code>null</code>.  Note that setting the font to\n     * <code>null</code> is undefined and may have unpredictable\n     * results.\n     *\n     * @param selectedFont the new <code>Font</code>\n     */\n    public DefaultFontSelectionModel(Font selectedFont) {\n        if (selectedFont == null) {\n            selectedFont = DEFAULT_INITIAL_FONT;\n        }\n        this.selectedFont = selectedFont;\n    }\n\n    public Font getSelectedFont() {\n        return selectedFont;\n    }\n\n    public void setSelectedFont(Font selectedFont) {\n        if (selectedFont != null) {\n            this.selectedFont = selectedFont;\n            fireChangeListeners();\n        }\n    }\n\n    public void addChangeListener(ChangeListener listener) {\n        listeners.add(ChangeListener.class, listener);\n    }\n\n    public void removeChangeListener(ChangeListener listener) {\n        listeners.remove(ChangeListener.class, listener);\n    }\n\n    /**\n     * Fires the listeners registered with this model.\n     */\n    protected void fireChangeListeners() {\n        ChangeEvent ev = new ChangeEvent(this);\n        Object[] l = listeners.getListeners(ChangeListener.class);\n        for (Object listener : l) {\n            ((ChangeListener) listener).stateChanged(ev);\n        }\n    }\n}\n\n/**\n * A model that supports selecting a <code>Font</code>.\n *\n * @author Adrian BER\n *\n * @see java.awt.Font\n */\ninterface FontSelectionModel {\n\n    /**\n     * Returns the selected <code>Font</code> which should be\n     * non-<code>null</code>.\n     *\n     * @return  the selected <code>Font</code>\n     * @see     #setSelectedFont\n     */\n    Font getSelectedFont();\n\n    /**\n     * Sets the selected font to <code>font</code>.\n     * Note that setting the font to <code>null</code>\n     * is undefined and may have unpredictable results.\n     * This method fires a state changed event if it sets the\n     * current font to a new non-<code>null</code> font.\n     *\n     * @param font the new <code>Font</code>\n     * @see   #getSelectedFont\n     * @see   #addChangeListener\n     */\n    void setSelectedFont(Font font);\n\n    /**\n     * Adds <code>listener</code> as a listener to changes in the model.\n     * @param listener the <code>ChangeListener</code> to be added\n     */\n    void addChangeListener(ChangeListener listener);\n\n    /**\n     * Removes <code>listener</code> as a listener to changes in the model.\n     * @param listener the <code>ChangeListener</code> to be removed\n     */\n    void removeChangeListener(ChangeListener listener);\n}\n",
    "test_prompt": "// JFontChooser_1Test.java\npackage osa.ora.server.client.ui.utils;\n\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.FlowLayout;\nimport java.awt.Font;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.GridBagConstraints;\nimport java.awt.GridBagLayout;\nimport java.awt.Insets;\nimport java.awt.Window;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.Serializable;\nimport javax.swing.AbstractAction;\nimport javax.swing.Action;\nimport javax.swing.ActionMap;\nimport javax.swing.InputMap;\nimport javax.swing.JButton;\nimport javax.swing.JCheckBox;\nimport javax.swing.JComponent;\nimport javax.swing.JDialog;\nimport javax.swing.JLabel;\nimport javax.swing.JList;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.KeyStroke;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.UIManager;\nimport javax.swing.event.ChangeEvent;\nimport javax.swing.event.ChangeListener;\nimport javax.swing.event.EventListenerList;\nimport javax.swing.event.ListSelectionEvent;\nimport javax.swing.event.ListSelectionListener;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JFontChooser}.\n* It contains ten unit test cases for the {@link JFontChooser#createDialog(Component, String, boolean, ActionListener, ActionListener)} method.\n*/\nclass JFontChooser_1Test {"
}
]