[
    {
        "id": "chatcmpl-A5VnfQvUCLYCGWd0O5iwfW6C9gLvF",
        "object": "chat.completion",
        "created": 1725877243,
        "model": "gpt-3.5-turbo-0125",
        "choices": [
            {
                "index": 0,
                "message": {
                    "role": "assistant",
                    "content": "// SimpleCombatant_0Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCombatant}.\n* It contains ten unit test cases for the {@link SimpleCombatant#_getMaxLP()} method.\n*/\nclass SimpleCombatant_0Test {\n}",
                    "refusal": null
                },
                "logprobs": null,
                "finish_reason": "stop",
                "text": "// SimpleCombatant_0Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCombatant}.\n* It contains ten unit test cases for the {@link SimpleCombatant#_getMaxLP()} method.\n*/\nclass SimpleCombatant_0Test {\n}"
            }
        ],
        "usage": {
            "prompt_tokens": 3951,
            "completion_tokens": 159,
            "total_tokens": 4110
        },
        "system_fingerprint": null,
        "time_taken": 2.90572452545166,
        "prompt_id": "/EvoSuiteBenchmark/original/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleCombatant_0Test.java",
        "original_code": "// SimpleCombatant.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * A Combatant with basic attributes (position, health)\n *\n * @author daniel\n */\npublic class SimpleCombatant implements Combatant {\n\n    private static final transient Logger LOG = Logger.getLogger(SimpleCombatant.class.getName());\n\n    private final int maxHealth;\n\n    private final CombatantSide side;\n\n    private final String name;\n\n    private final String city;\n\n    private final Set<CombatantObserver> observers = new HashSet<CombatantObserver>();\n\n    private final Object stateChangeLock = new Object();\n\n    private final CharacterClass charClass;\n\n    private final Weapon weapon;\n\n    private CombatantState state;\n\n    private Combatant aimingAt = null;\n\n    /**\n     * Create a new {@link Combatant} at the given position and the given amount\n     * of health.\n     *\n     * @param side\n     *            not null\n     * @param initialState\n     *            not null\n     * @param maxHealth\n     *            > 0\n     * @param name\n     *            the name of the player of this Combatant\n     * @param characterClass\n     *            maybe null for old logs\n     * @param weapon\n     *            not null\n     * @param city\n     *            not null\n     */\n    public SimpleCombatant(final CombatantSide side, final CombatantState initialState, final int maxHealth, final String name, final CharacterClass characterClass, final Weapon weapon, final String city) {\n        assert side != null && initialState != null && weapon != null && city != null : \"parameters may not be null!\";\n        assert maxHealth > 0 : \"health must be positive!\";\n        assert maxHealth >= initialState.getHealth() && initialState.getHealth() > 0 : \"currentHealth must be inbetween 1 and max, is \" + initialState.getHealth();\n        this.side = side;\n        this.maxHealth = maxHealth;\n        this.name = name;\n        this.city = city;\n        state = initialState;\n        charClass = characterClass;\n        this.weapon = weapon;\n        // move to current location\n        state.getPosition().occupy(this, null);\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return getSide() + \" \" + name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getName()\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getWeapon()\n     */\n    public Weapon getWeapon() {\n        return weapon;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the maximal health\n     */\n    public int _getMaxLP() {\n        return maxHealth;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the current health\n     */\n    public int _getCurrentLP() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#move(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void move(final Area target) {\n        LOG.fine(name + \" moving to \" + target);\n        synchronized (stateChangeLock) {\n            final Area oldPosition = state.getPosition();\n            moveAway(oldPosition);\n            state = state.changePosition(target);\n            final Combatant swapped = target.occupy(this, oldPosition);\n            fireHasMoved();\n            if (swapped != null) {\n                fireHasSwapped(swapped);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#shoot(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void shoot(final int power) {\n        LOG.fine(name + \" shooting with \" + power);\n        aimingAt.hit(power);\n        final int sectorBonusDamage = state.getPosition().getSectorBonus(this).additionalDamage;\n        if (charClass == CharacterClass.DUELANT && power > weapon.maxDamage() + sectorBonusDamage) {\n            final double tenPercent = aimingAt._maxHealth() * 0.1;\n            if (power > weapon.minDamage() + tenPercent) {\n                fireCriticalShot(power);\n            } else {\n                LOG.fine(\"almost crit by \" + name + \": \" + power);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#hit(int)\n     */\n    public boolean hit(final int damageAmount) {\n        LOG.fine(name + \" was hit and lost \" + damageAmount + \" health points\");\n        synchronized (stateChangeLock) {\n            final int oldHealth = state.getHealth();\n            state = state.reduceHealthBy(damageAmount);\n            fireWasHit(damageAmount, oldHealth);\n            if (state.getHealth() <= 0) {\n                moveAway(state.getPosition());\n                fireIsDead();\n            }\n            return state.getHealth() > 0;\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#aimAt(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimAt(final Combatant target) {\n        LOG.fine(name + \" aims at \" + target);\n        aimingAt = target;\n        fireAimingAt();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setDestination(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void setDestination(final Area destination) {\n        LOG.fine(name + \" wants to move to \" + destination);\n        synchronized (stateChangeLock) {\n            state = state.changeTarget(destination);\n            fireNewTarget();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#addObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void addObserver(final CombatantObserver observer) {\n        observers.add(observer);\n        // send current state\n        observer.hasMoved(this, state.getPosition());\n        if (aimingAt != null) {\n            observer.aimsAt(this, aimingAt);\n        }\n        if (state.getHealth() <= 0) {\n            observer.isDead(this);\n        } else {\n            observer.isAlive(this);\n        }\n        observer.isOnline(this, false);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#removeObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void removeObserver(final CombatantObserver observer) {\n        observers.remove(observer);\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireHasMoved() {\n        for (final CombatantObserver observer : observers) {\n            observer.hasMoved(this, state.getPosition());\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     *\n     * @param swappedWith\n     */\n    protected void fireHasSwapped(final Combatant swappedWith) {\n        for (final CombatantObserver observer : observers) {\n            observer.hasSwappedPosition(this, swappedWith);\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireNewTarget() {\n        for (final CombatantObserver observer : observers) {\n            observer.newDestination(this, state.getTarget());\n        }\n    }\n\n    /**\n     * notify all observers that I shot at somebody.\n     */\n    protected void fireAimingAt() {\n        if (aimingAt != null) {\n            for (final CombatantObserver observer : observers) {\n                observer.aimsAt(this, aimingAt);\n            }\n        }\n    }\n\n    /**\n     * notify all observers about a loss of health\n     *\n     * @param damage\n     *            amount of healthpoints lost\n     * @param healthBefore\n     *            original health amount before it was decreased by\n     *            <code>damage</code>\n     */\n    protected void fireWasHit(final int damage, final int healthBefore) {\n        for (final CombatantObserver observer : observers) {\n            observer.isHit(this, damage, healthBefore);\n        }\n    }\n\n    /**\n     * notify all observers about our dead\n     */\n    protected void fireIsDead() {\n        for (final CombatantObserver observer : observers) {\n            observer.isDead(this);\n        }\n    }\n\n    /**\n     * notify all observers about our resurrection\n     */\n    protected void fireIsAlive() {\n        for (final CombatantObserver observer : observers) {\n            observer.isAlive(this);\n        }\n    }\n\n    /**\n     * notify all observers about changed online state\n     *\n     * @param changed\n     *            if the value was changed or only set\n     */\n    protected void fireOnlineChange(final boolean changed) {\n        for (final CombatantObserver observer : observers) {\n            observer.isOnline(this, changed);\n        }\n    }\n\n    /**\n     * notify all observers that i have done a critical shot\n     *\n     * @param damage\n     *            the actual caused damage\n     */\n    protected void fireCriticalShot(final int damage) {\n        for (final CombatantObserver observer : observers) {\n            observer.criticalShot(this, aimingAt, damage);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_getLocation()\n     */\n    public Area _getLocation() {\n        return state.getPosition();\n    }\n\n    /**\n     * @return the side\n     */\n    public CombatantSide getSide() {\n        return side;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_health()\n     */\n    public int _health() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_maxHealth()\n     */\n    public int _maxHealth() {\n        return maxHealth;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_setState(de.outstare.fortbattleplayer.model.CombatantState)\n     */\n    public void _setState(final CombatantState newState) {\n        final CombatantState oldState = state;\n        // TODO maybe a PropertyChangeListener for the state\n        synchronized (stateChangeLock) {\n            state = newState;\n            // new pos has not to be null!\n            if (state.getPosition() != null) {\n                final Area oldPos = oldState.getPosition();\n                // fix for swapping:\n                // 1. go away from battlefield\n                moveAway(oldPos);\n                // 2. come from nowhere to new position (avoids swapping)\n                state.getPosition().occupy(this, null);\n                if (oldPos == null || !oldPos.equals(state.getPosition())) {\n                    fireHasMoved();\n                }\n            }\n            if (oldState.getHealth() != state.getHealth()) {\n                fireWasHit(oldState.getHealth() - state.getHealth(), oldState.getHealth());\n            }\n            if (state.getHealth() > 0 && oldState.getHealth() <= 0) {\n                fireIsAlive();\n            }\n            if (state.getHealth() <= 0 && oldState.getHealth() > 0) {\n                fireIsDead();\n            }\n            if (oldState.isGamerOnline() != state.isGamerOnline()) {\n                fireOnlineChange(true);\n            }\n            if (!oldState.getTarget().equals(state.getTarget())) {\n                fireNewTarget();\n            }\n        }\n    }\n\n    /**\n     * @param position\n     */\n    private void moveAway(final Area position) {\n        if (position != null && equals(position.getOccupier())) {\n            position.free();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_state()\n     */\n    public CombatantState _state() {\n        return state;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#isOnline()\n     */\n    public boolean isOnline() {\n        return state.isGamerOnline();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setOnline()\n     */\n    public void setOnline(final boolean isOnline) {\n        synchronized (stateChangeLock) {\n            final boolean changed = isOnline() != isOnline;\n            if (changed) {\n                LOG.fine(name + \" is now \" + (isOnline ? \"online\" : \"offline\"));\n                state = state.setOnline(isOnline);\n            }\n            fireOnlineChange(changed);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCharacterClass()\n     */\n    public CharacterClass getCharacterClass() {\n        return charClass;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getSectorBonus()\n     */\n    public SectorBonus getSectorBonus() {\n        return _getLocation().getSectorBonus(this);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCity()\n     */\n    public String getCity() {\n        return city;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#usesBayonet()\n     */\n    public boolean usesBayonet() {\n        final WeaponData weaponData = new JSWeaponData();\n        return weaponData.hasBayonet(getWeapon());\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 13;\n        int result = 1;\n        result = prime * result + ((name == null) ? 0 : name.hashCode());\n        result = prime * result + ((charClass == null) ? 0 : charClass.hashCode());\n        result = prime * result + ((city == null) ? 0 : city.hashCode());\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleCombatant)) {\n            return false;\n        }\n        final SimpleCombatant other = (SimpleCombatant) obj;\n        if (name == null) {\n            if (other.name != null) {\n                return false;\n            }\n        } else if (!name.equals(other.name)) {\n            return false;\n        }\n        if (charClass != other.charClass) {\n            return false;\n        }\n        if (city == null) {\n            if (other.city != null) {\n                return false;\n            }\n        } else if (!city.equals(other.city)) {\n            return false;\n        }\n        return true;\n    }\n}\n",
        "test_prompt": "// SimpleCombatant_0Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCombatant}.\n* It contains ten unit test cases for the {@link SimpleCombatant#_getMaxLP()} method.\n*/\nclass SimpleCombatant_0Test {",
        "original_generated_code": "```java\npackage de.outstare.fortbattleplayer.model.impl;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass SimpleCombatant_0Test {\n\n    @Test\n    void test_getMaxLP_returnsMaxHealth() {\n        // Arrange\n        int maxHealth = 100;\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.BLUE, new CombatantState(new Area(0, 0), 100, true), maxHealth, \"Test\", CharacterClass.SOLDIER, new Weapon(\"TestWeapon\", 10, 20), \"TestCity\");\n\n        // Act\n        int result = combatant._getMaxLP();\n\n        // Assert\n        assertEquals(maxHealth, result);\n    }\n}\n```\n```",
        "applied_heuristics": "H2;H7"
    },
    {
        "id": "chatcmpl-A5VoidFHsEMsr11yTjePtGxOZEMnf",
        "object": "chat.completion",
        "created": 1725877308,
        "model": "gpt-3.5-turbo-0125",
        "choices": [
            {
                "index": 0,
                "message": {
                    "role": "assistant",
                    "content": "package de.outstare.fortbattleplayer.model.impl;\njava\nclass SimpleCombatant_1Test {\n\n    @Test\n    void testGetCurrentLP_MaxHealthEqualsCurrentHealth() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(100, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.BLUE, initialState, 100, \"Player1\", CharacterClass.SOLDIER, new WeaponImpl(\"Gun\", 10, 20), \"City1\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(100, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_MaxHealthGreaterThanCurrentHealth() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(50, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.RED, initialState, 100, \"Player2\", CharacterClass.SNIPER, new WeaponImpl(\"Sniper Rifle\", 30, 50), \"City2\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(50, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_MaxHealthLessThanCurrentHealth() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(80, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.GREEN, initialState, 70, \"Player3\", CharacterClass.DUELANT, new WeaponImpl(\"Sword\", 5, 10), \"City3\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(80, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_HealthZero() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(0, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.YELLOW, initialState, 100, \"Player4\", CharacterClass.MEDIC, new WeaponImpl(\"Healing Gun\", 0, 0), \"City4\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(0, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_NegativeHealth() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(-10, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.BLUE, initialState, 100, \"Player5\", CharacterClass.SOLDIER, new WeaponImpl(\"Gun\", 10, 20), \"City5\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(-10, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_MaxHealthZero() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(0, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.RED, initialState, 0, \"Player6\", CharacterClass.SNIPER, new WeaponImpl(\"Sniper Rifle\", 30, 50), \"City6\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(0, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_MaxHealthNegative() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(20, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.GREEN, initialState, -30, \"Player7\", CharacterClass.DUELANT, new WeaponImpl(\"Sword\", 5, 10), \"City7\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(20, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_MaxHealthEqualsCurrentHealth_ZeroHealth() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(0, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.YELLOW, initialState, 0, \"Player8\", CharacterClass.MEDIC, new WeaponImpl(\"Healing Gun\", 0, 0), \"City8\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(0, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_MaxHealthEqualsCurrentHealth_NegativeHealth() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(-5, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.BLUE, initialState, -5, \"Player9\", CharacterClass.SOLDIER, new WeaponImpl(\"Gun\", 10, 20), \"City9\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(-5, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_MaxHealthZero_CurrentHealthNegative() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(-10, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.RED, initialState, 0, \"Player10\", CharacterClass.SNIPER, new WeaponImpl(\"Sniper Rifle\", 30, 50), \"City10\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(-10, currentLP);\n    }\n}\n",
                    "refusal": null
                },
                "logprobs": null,
                "finish_reason": "stop",
                "text": "package de.outstare.fortbattleplayer.model.impl;\njava\nclass SimpleCombatant_1Test {\n\n    @Test\n    void testGetCurrentLP_MaxHealthEqualsCurrentHealth() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(100, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.BLUE, initialState, 100, \"Player1\", CharacterClass.SOLDIER, new WeaponImpl(\"Gun\", 10, 20), \"City1\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(100, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_MaxHealthGreaterThanCurrentHealth() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(50, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.RED, initialState, 100, \"Player2\", CharacterClass.SNIPER, new WeaponImpl(\"Sniper Rifle\", 30, 50), \"City2\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(50, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_MaxHealthLessThanCurrentHealth() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(80, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.GREEN, initialState, 70, \"Player3\", CharacterClass.DUELANT, new WeaponImpl(\"Sword\", 5, 10), \"City3\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(80, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_HealthZero() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(0, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.YELLOW, initialState, 100, \"Player4\", CharacterClass.MEDIC, new WeaponImpl(\"Healing Gun\", 0, 0), \"City4\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(0, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_NegativeHealth() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(-10, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.BLUE, initialState, 100, \"Player5\", CharacterClass.SOLDIER, new WeaponImpl(\"Gun\", 10, 20), \"City5\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(-10, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_MaxHealthZero() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(0, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.RED, initialState, 0, \"Player6\", CharacterClass.SNIPER, new WeaponImpl(\"Sniper Rifle\", 30, 50), \"City6\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(0, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_MaxHealthNegative() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(20, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.GREEN, initialState, -30, \"Player7\", CharacterClass.DUELANT, new WeaponImpl(\"Sword\", 5, 10), \"City7\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(20, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_MaxHealthEqualsCurrentHealth_ZeroHealth() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(0, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.YELLOW, initialState, 0, \"Player8\", CharacterClass.MEDIC, new WeaponImpl(\"Healing Gun\", 0, 0), \"City8\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(0, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_MaxHealthEqualsCurrentHealth_NegativeHealth() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(-5, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.BLUE, initialState, -5, \"Player9\", CharacterClass.SOLDIER, new WeaponImpl(\"Gun\", 10, 20), \"City9\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(-5, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_MaxHealthZero_CurrentHealthNegative() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(-10, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.RED, initialState, 0, \"Player10\", CharacterClass.SNIPER, new WeaponImpl(\"Sniper Rifle\", 30, 50), \"City10\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(-10, currentLP);\n    }\n}\n"
            }
        ],
        "usage": {
            "prompt_tokens": 3950,
            "completion_tokens": 1249,
            "total_tokens": 5199
        },
        "system_fingerprint": null,
        "time_taken": 17.77376389503479,
        "prompt_id": "/EvoSuiteBenchmark/original/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/model/impl/SimpleCombatant_1Test.java",
        "original_code": "// SimpleCombatant.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\n\n/**\n * A Combatant with basic attributes (position, health)\n *\n * @author daniel\n */\npublic class SimpleCombatant implements Combatant {\n\n    private static final transient Logger LOG = Logger.getLogger(SimpleCombatant.class.getName());\n\n    private final int maxHealth;\n\n    private final CombatantSide side;\n\n    private final String name;\n\n    private final String city;\n\n    private final Set<CombatantObserver> observers = new HashSet<CombatantObserver>();\n\n    private final Object stateChangeLock = new Object();\n\n    private final CharacterClass charClass;\n\n    private final Weapon weapon;\n\n    private CombatantState state;\n\n    private Combatant aimingAt = null;\n\n    /**\n     * Create a new {@link Combatant} at the given position and the given amount\n     * of health.\n     *\n     * @param side\n     *            not null\n     * @param initialState\n     *            not null\n     * @param maxHealth\n     *            > 0\n     * @param name\n     *            the name of the player of this Combatant\n     * @param characterClass\n     *            maybe null for old logs\n     * @param weapon\n     *            not null\n     * @param city\n     *            not null\n     */\n    public SimpleCombatant(final CombatantSide side, final CombatantState initialState, final int maxHealth, final String name, final CharacterClass characterClass, final Weapon weapon, final String city) {\n        assert side != null && initialState != null && weapon != null && city != null : \"parameters may not be null!\";\n        assert maxHealth > 0 : \"health must be positive!\";\n        assert maxHealth >= initialState.getHealth() && initialState.getHealth() > 0 : \"currentHealth must be inbetween 1 and max, is \" + initialState.getHealth();\n        this.side = side;\n        this.maxHealth = maxHealth;\n        this.name = name;\n        this.city = city;\n        state = initialState;\n        charClass = characterClass;\n        this.weapon = weapon;\n        // move to current location\n        state.getPosition().occupy(this, null);\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override\n    public String toString() {\n        return getSide() + \" \" + name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getName()\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getWeapon()\n     */\n    public Weapon getWeapon() {\n        return weapon;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the maximal health\n     */\n    public int _getMaxLP() {\n        return maxHealth;\n    }\n\n    /**\n     * internal method for graphical display\n     *\n     * @return the current health\n     */\n    public int _getCurrentLP() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#move(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void move(final Area target) {\n        LOG.fine(name + \" moving to \" + target);\n        synchronized (stateChangeLock) {\n            final Area oldPosition = state.getPosition();\n            moveAway(oldPosition);\n            state = state.changePosition(target);\n            final Combatant swapped = target.occupy(this, oldPosition);\n            fireHasMoved();\n            if (swapped != null) {\n                fireHasSwapped(swapped);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#shoot(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void shoot(final int power) {\n        LOG.fine(name + \" shooting with \" + power);\n        aimingAt.hit(power);\n        final int sectorBonusDamage = state.getPosition().getSectorBonus(this).additionalDamage;\n        if (charClass == CharacterClass.DUELANT && power > weapon.maxDamage() + sectorBonusDamage) {\n            final double tenPercent = aimingAt._maxHealth() * 0.1;\n            if (power > weapon.minDamage() + tenPercent) {\n                fireCriticalShot(power);\n            } else {\n                LOG.fine(\"almost crit by \" + name + \": \" + power);\n            }\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#hit(int)\n     */\n    public boolean hit(final int damageAmount) {\n        LOG.fine(name + \" was hit and lost \" + damageAmount + \" health points\");\n        synchronized (stateChangeLock) {\n            final int oldHealth = state.getHealth();\n            state = state.reduceHealthBy(damageAmount);\n            fireWasHit(damageAmount, oldHealth);\n            if (state.getHealth() <= 0) {\n                moveAway(state.getPosition());\n                fireIsDead();\n            }\n            return state.getHealth() > 0;\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#aimAt(de.outstare.fortbattleplayer.model.Combatant)\n     */\n    public void aimAt(final Combatant target) {\n        LOG.fine(name + \" aims at \" + target);\n        aimingAt = target;\n        fireAimingAt();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setDestination(de.outstare.fortbattleplayer.model.Area)\n     */\n    public void setDestination(final Area destination) {\n        LOG.fine(name + \" wants to move to \" + destination);\n        synchronized (stateChangeLock) {\n            state = state.changeTarget(destination);\n            fireNewTarget();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#addObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void addObserver(final CombatantObserver observer) {\n        observers.add(observer);\n        // send current state\n        observer.hasMoved(this, state.getPosition());\n        if (aimingAt != null) {\n            observer.aimsAt(this, aimingAt);\n        }\n        if (state.getHealth() <= 0) {\n            observer.isDead(this);\n        } else {\n            observer.isAlive(this);\n        }\n        observer.isOnline(this, false);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#removeObserver(de.outstare.fortbattleplayer.model.CombatantObserver)\n     */\n    public void removeObserver(final CombatantObserver observer) {\n        observers.remove(observer);\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireHasMoved() {\n        for (final CombatantObserver observer : observers) {\n            observer.hasMoved(this, state.getPosition());\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     *\n     * @param swappedWith\n     */\n    protected void fireHasSwapped(final Combatant swappedWith) {\n        for (final CombatantObserver observer : observers) {\n            observer.hasSwappedPosition(this, swappedWith);\n        }\n    }\n\n    /**\n     * notify all observers about the current position\n     */\n    protected void fireNewTarget() {\n        for (final CombatantObserver observer : observers) {\n            observer.newDestination(this, state.getTarget());\n        }\n    }\n\n    /**\n     * notify all observers that I shot at somebody.\n     */\n    protected void fireAimingAt() {\n        if (aimingAt != null) {\n            for (final CombatantObserver observer : observers) {\n                observer.aimsAt(this, aimingAt);\n            }\n        }\n    }\n\n    /**\n     * notify all observers about a loss of health\n     *\n     * @param damage\n     *            amount of healthpoints lost\n     * @param healthBefore\n     *            original health amount before it was decreased by\n     *            <code>damage</code>\n     */\n    protected void fireWasHit(final int damage, final int healthBefore) {\n        for (final CombatantObserver observer : observers) {\n            observer.isHit(this, damage, healthBefore);\n        }\n    }\n\n    /**\n     * notify all observers about our dead\n     */\n    protected void fireIsDead() {\n        for (final CombatantObserver observer : observers) {\n            observer.isDead(this);\n        }\n    }\n\n    /**\n     * notify all observers about our resurrection\n     */\n    protected void fireIsAlive() {\n        for (final CombatantObserver observer : observers) {\n            observer.isAlive(this);\n        }\n    }\n\n    /**\n     * notify all observers about changed online state\n     *\n     * @param changed\n     *            if the value was changed or only set\n     */\n    protected void fireOnlineChange(final boolean changed) {\n        for (final CombatantObserver observer : observers) {\n            observer.isOnline(this, changed);\n        }\n    }\n\n    /**\n     * notify all observers that i have done a critical shot\n     *\n     * @param damage\n     *            the actual caused damage\n     */\n    protected void fireCriticalShot(final int damage) {\n        for (final CombatantObserver observer : observers) {\n            observer.criticalShot(this, aimingAt, damage);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_getLocation()\n     */\n    public Area _getLocation() {\n        return state.getPosition();\n    }\n\n    /**\n     * @return the side\n     */\n    public CombatantSide getSide() {\n        return side;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_health()\n     */\n    public int _health() {\n        return state.getHealth();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_maxHealth()\n     */\n    public int _maxHealth() {\n        return maxHealth;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_setState(de.outstare.fortbattleplayer.model.CombatantState)\n     */\n    public void _setState(final CombatantState newState) {\n        final CombatantState oldState = state;\n        // TODO maybe a PropertyChangeListener for the state\n        synchronized (stateChangeLock) {\n            state = newState;\n            // new pos has not to be null!\n            if (state.getPosition() != null) {\n                final Area oldPos = oldState.getPosition();\n                // fix for swapping:\n                // 1. go away from battlefield\n                moveAway(oldPos);\n                // 2. come from nowhere to new position (avoids swapping)\n                state.getPosition().occupy(this, null);\n                if (oldPos == null || !oldPos.equals(state.getPosition())) {\n                    fireHasMoved();\n                }\n            }\n            if (oldState.getHealth() != state.getHealth()) {\n                fireWasHit(oldState.getHealth() - state.getHealth(), oldState.getHealth());\n            }\n            if (state.getHealth() > 0 && oldState.getHealth() <= 0) {\n                fireIsAlive();\n            }\n            if (state.getHealth() <= 0 && oldState.getHealth() > 0) {\n                fireIsDead();\n            }\n            if (oldState.isGamerOnline() != state.isGamerOnline()) {\n                fireOnlineChange(true);\n            }\n            if (!oldState.getTarget().equals(state.getTarget())) {\n                fireNewTarget();\n            }\n        }\n    }\n\n    /**\n     * @param position\n     */\n    private void moveAway(final Area position) {\n        if (position != null && equals(position.getOccupier())) {\n            position.free();\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#_state()\n     */\n    public CombatantState _state() {\n        return state;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#isOnline()\n     */\n    public boolean isOnline() {\n        return state.isGamerOnline();\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#setOnline()\n     */\n    public void setOnline(final boolean isOnline) {\n        synchronized (stateChangeLock) {\n            final boolean changed = isOnline() != isOnline;\n            if (changed) {\n                LOG.fine(name + \" is now \" + (isOnline ? \"online\" : \"offline\"));\n                state = state.setOnline(isOnline);\n            }\n            fireOnlineChange(changed);\n        }\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCharacterClass()\n     */\n    public CharacterClass getCharacterClass() {\n        return charClass;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getSectorBonus()\n     */\n    public SectorBonus getSectorBonus() {\n        return _getLocation().getSectorBonus(this);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#getCity()\n     */\n    public String getCity() {\n        return city;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.model.Combatant#usesBayonet()\n     */\n    public boolean usesBayonet() {\n        final WeaponData weaponData = new JSWeaponData();\n        return weaponData.hasBayonet(getWeapon());\n    }\n\n    /**\n     * @see java.lang.Object#hashCode()\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 13;\n        int result = 1;\n        result = prime * result + ((name == null) ? 0 : name.hashCode());\n        result = prime * result + ((charClass == null) ? 0 : charClass.hashCode());\n        result = prime * result + ((city == null) ? 0 : city.hashCode());\n        return result;\n    }\n\n    /**\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleCombatant)) {\n            return false;\n        }\n        final SimpleCombatant other = (SimpleCombatant) obj;\n        if (name == null) {\n            if (other.name != null) {\n                return false;\n            }\n        } else if (!name.equals(other.name)) {\n            return false;\n        }\n        if (charClass != other.charClass) {\n            return false;\n        }\n        if (city == null) {\n            if (other.city != null) {\n                return false;\n            }\n        } else if (!city.equals(other.city)) {\n            return false;\n        }\n        return true;\n    }\n}\n",
        "test_prompt": "// SimpleCombatant_1Test.java\npackage de.outstare.fortbattleplayer.model.impl;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Area;\nimport de.outstare.fortbattleplayer.model.CharacterClass;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport de.outstare.fortbattleplayer.model.CombatantObserver;\nimport de.outstare.fortbattleplayer.model.CombatantSide;\nimport de.outstare.fortbattleplayer.model.CombatantState;\nimport de.outstare.fortbattleplayer.model.SectorBonus;\nimport de.outstare.fortbattleplayer.model.Weapon;\nimport de.outstare.fortbattleplayer.model.WeaponData;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCombatant}.\n* It contains ten unit test cases for the {@link SimpleCombatant#_getCurrentLP()} method.\n*/\nclass SimpleCombatant_1Test {",
        "original_generated_code": "```java\nclass SimpleCombatant_1Test {\n\n    @Test\n    void testGetCurrentLP_MaxHealthEqualsCurrentHealth() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(100, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.BLUE, initialState, 100, \"Player1\", CharacterClass.SOLDIER, new WeaponImpl(\"Gun\", 10, 20), \"City1\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(100, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_MaxHealthGreaterThanCurrentHealth() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(50, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.RED, initialState, 100, \"Player2\", CharacterClass.SNIPER, new WeaponImpl(\"Sniper Rifle\", 30, 50), \"City2\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(50, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_MaxHealthLessThanCurrentHealth() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(80, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.GREEN, initialState, 70, \"Player3\", CharacterClass.DUELANT, new WeaponImpl(\"Sword\", 5, 10), \"City3\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(80, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_HealthZero() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(0, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.YELLOW, initialState, 100, \"Player4\", CharacterClass.MEDIC, new WeaponImpl(\"Healing Gun\", 0, 0), \"City4\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(0, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_NegativeHealth() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(-10, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.BLUE, initialState, 100, \"Player5\", CharacterClass.SOLDIER, new WeaponImpl(\"Gun\", 10, 20), \"City5\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(-10, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_MaxHealthZero() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(0, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.RED, initialState, 0, \"Player6\", CharacterClass.SNIPER, new WeaponImpl(\"Sniper Rifle\", 30, 50), \"City6\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(0, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_MaxHealthNegative() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(20, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.GREEN, initialState, -30, \"Player7\", CharacterClass.DUELANT, new WeaponImpl(\"Sword\", 5, 10), \"City7\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(20, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_MaxHealthEqualsCurrentHealth_ZeroHealth() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(0, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.YELLOW, initialState, 0, \"Player8\", CharacterClass.MEDIC, new WeaponImpl(\"Healing Gun\", 0, 0), \"City8\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(0, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_MaxHealthEqualsCurrentHealth_NegativeHealth() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(-5, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.BLUE, initialState, -5, \"Player9\", CharacterClass.SOLDIER, new WeaponImpl(\"Gun\", 10, 20), \"City9\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(-5, currentLP);\n    }\n\n    @Test\n    void testGetCurrentLP_MaxHealthZero_CurrentHealthNegative() {\n        // Arrange\n        CombatantState initialState = new CombatantStateImpl(-10, true, new AreaImpl(0, 0));\n        SimpleCombatant combatant = new SimpleCombatant(CombatantSide.RED, initialState, 0, \"Player10\", CharacterClass.SNIPER, new WeaponImpl(\"Sniper Rifle\", 30, 50), \"City10\");\n\n        // Act\n        int currentLP = combatant._getCurrentLP();\n\n        // Assert\n        assertEquals(-10, currentLP);\n    }\n}\n```\n```",
        "applied_heuristics": "H2;H5"
    },
    {
        "id": "chatcmpl-A5VplM7VOFLlrsXiHXuyOuLgwrfsP",
        "object": "chat.completion",
        "created": 1725877373,
        "model": "gpt-3.5-turbo-0125",
        "choices": [
            {
                "index": 0,
                "message": {
                    "role": "assistant",
                    "content": "package de.outstare.fortbattleplayer.player;\njava\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass PlayerConfiguration_0Test {\n\n    @Test\n    void testCopyReturnsNewInstance() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n        assertNotSame(original, copy);\n    }\n\n    @Test\n    void testCopyHasSameValues() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        original.ROUND_DELAY = 100;\n        original.PLAYER_DELAY = 200;\n        original.ACTION_DELAY = 300;\n\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        assertEquals(original.ROUND_DELAY, copy.ROUND_DELAY);\n        assertEquals(original.PLAYER_DELAY, copy.PLAYER_DELAY);\n        assertEquals(original.ACTION_DELAY, copy.ACTION_DELAY);\n    }\n\n    @Test\n    void testCopyIsIndependent() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        original.ROUND_DELAY = 100;\n        original.PLAYER_DELAY = 200;\n        original.ACTION_DELAY = 300;\n\n        assertNotEquals(original.ROUND_DELAY, copy.ROUND_DELAY);\n        assertNotEquals(original.PLAYER_DELAY, copy.PLAYER_DELAY);\n        assertNotEquals(original.ACTION_DELAY, copy.ACTION_DELAY);\n    }\n\n    @Test\n    void testCopyIsShallowCopy() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        original.SHOW_MOVETARGETS = true;\n        original.SHOW_SHOOTLINE = true;\n\n        assertFalse(copy.showMoveTargets());\n        assertFalse(copy.showShootline());\n    }\n\n    @Test\n    void testCopyListenerListIsNotCopied() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        original.addListener(listener -> {});\n        assertEquals(1, original.listeners.size());\n        assertEquals(0, copy.listeners.size());\n    }\n\n    @Test\n    void testCopyStateIsNotCopied() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        original.setState(PlayerState.PLAY);\n\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        assertFalse(copy.isPlaying());\n    }\n\n    @Test\n    void testCopyLockIsNotCopied() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        Lock originalLock = original.playLock;\n\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        assertNotSame(originalLock, copy.playLock);\n    }\n\n    @Test\n    void testCopyConfigurationValuesAreCopied() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        original.ROUND_DELAY = 100;\n        original.PLAYER_DELAY = 200;\n        original.ACTION_DELAY = 300;\n\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        assertEquals(original.ROUND_DELAY, copy.ROUND_DELAY);\n        assertEquals(original.PLAYER_DELAY, copy.PLAYER_DELAY);\n        assertEquals(original.ACTION_DELAY, copy.ACTION_DELAY);\n    }\n\n    @Test\n    void testCopyShowMoveTargetsIsCopied() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        original.setShowMoveTargets(true);\n\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        assertTrue(copy.showMoveTargets());\n    }\n\n    @Test\n    void testCopyShowShootlineIsCopied() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        original.setShowShootline(true);\n\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        assertTrue(copy.showShootline());\n    }\n}\n",
                    "refusal": null
                },
                "logprobs": null,
                "finish_reason": "stop",
                "text": "package de.outstare.fortbattleplayer.player;\njava\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass PlayerConfiguration_0Test {\n\n    @Test\n    void testCopyReturnsNewInstance() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n        assertNotSame(original, copy);\n    }\n\n    @Test\n    void testCopyHasSameValues() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        original.ROUND_DELAY = 100;\n        original.PLAYER_DELAY = 200;\n        original.ACTION_DELAY = 300;\n\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        assertEquals(original.ROUND_DELAY, copy.ROUND_DELAY);\n        assertEquals(original.PLAYER_DELAY, copy.PLAYER_DELAY);\n        assertEquals(original.ACTION_DELAY, copy.ACTION_DELAY);\n    }\n\n    @Test\n    void testCopyIsIndependent() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        original.ROUND_DELAY = 100;\n        original.PLAYER_DELAY = 200;\n        original.ACTION_DELAY = 300;\n\n        assertNotEquals(original.ROUND_DELAY, copy.ROUND_DELAY);\n        assertNotEquals(original.PLAYER_DELAY, copy.PLAYER_DELAY);\n        assertNotEquals(original.ACTION_DELAY, copy.ACTION_DELAY);\n    }\n\n    @Test\n    void testCopyIsShallowCopy() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        original.SHOW_MOVETARGETS = true;\n        original.SHOW_SHOOTLINE = true;\n\n        assertFalse(copy.showMoveTargets());\n        assertFalse(copy.showShootline());\n    }\n\n    @Test\n    void testCopyListenerListIsNotCopied() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        original.addListener(listener -> {});\n        assertEquals(1, original.listeners.size());\n        assertEquals(0, copy.listeners.size());\n    }\n\n    @Test\n    void testCopyStateIsNotCopied() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        original.setState(PlayerState.PLAY);\n\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        assertFalse(copy.isPlaying());\n    }\n\n    @Test\n    void testCopyLockIsNotCopied() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        Lock originalLock = original.playLock;\n\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        assertNotSame(originalLock, copy.playLock);\n    }\n\n    @Test\n    void testCopyConfigurationValuesAreCopied() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        original.ROUND_DELAY = 100;\n        original.PLAYER_DELAY = 200;\n        original.ACTION_DELAY = 300;\n\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        assertEquals(original.ROUND_DELAY, copy.ROUND_DELAY);\n        assertEquals(original.PLAYER_DELAY, copy.PLAYER_DELAY);\n        assertEquals(original.ACTION_DELAY, copy.ACTION_DELAY);\n    }\n\n    @Test\n    void testCopyShowMoveTargetsIsCopied() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        original.setShowMoveTargets(true);\n\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        assertTrue(copy.showMoveTargets());\n    }\n\n    @Test\n    void testCopyShowShootlineIsCopied() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        original.setShowShootline(true);\n\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        assertTrue(copy.showShootline());\n    }\n}\n"
            }
        ],
        "usage": {
            "prompt_tokens": 1551,
            "completion_tokens": 970,
            "total_tokens": 2521
        },
        "system_fingerprint": null,
        "time_taken": 13.35513710975647,
        "prompt_id": "/EvoSuiteBenchmark/original/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/player/PlayerConfiguration_0Test.java",
        "original_code": "// PlayerConfiguration.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport de.outstare.fortbattleplayer.Configuration;\n\n/**\n * An instance of this will be used by the player to hold its tunable\n * parameters.\n *\n * @author daniel\n */\npublic class PlayerConfiguration implements Cloneable {\n\n    /**\n     * a configuration which skips animation (used for purposes where the user\n     * should not see whats going on)\n     */\n    public static final PlayerConfiguration NO_DELAY = new PlayerConfiguration();\n\n    static {\n        NO_DELAY.ACTION_DELAY = 0;\n        NO_DELAY.PLAYER_DELAY = 0;\n        NO_DELAY.ROUND_DELAY = 0;\n        NO_DELAY.setShowMoveTargets(false);\n        NO_DELAY.setShowShootline(false);\n    }\n\n    /**\n     * this is used to control who currently does something with the player\n     */\n    private final Lock playLock = new ReentrantLock();\n\n    private final Set<PlayerConfigurationListener> listeners = new HashSet<PlayerConfigurationListener>();\n\n    /**\n     * current state of the player\n     */\n    private PlayerState state = PlayerState.STOP;\n\n    /**\n     * pause between two rounds in milliseconds\n     */\n    public volatile int ROUND_DELAY = Configuration.ROUND_DELAY;\n\n    /**\n     * pause between two players in a round in milliseconds\n     */\n    public volatile int PLAYER_DELAY = Configuration.PLAYER_DELAY;\n\n    /**\n     * pause between two actions in milliseconds\n     */\n    public volatile int ACTION_DELAY = Configuration.ACTION_DELAY;\n\n    /**\n     * draw a line to the point, where the player wants to go\n     */\n    private volatile boolean SHOW_MOVETARGETS = Configuration.SHOW_MOVETARGETS;\n\n    /**\n     * draw a line to the enemy ath wich the player shoots\n     */\n    private volatile boolean SHOW_SHOOTLINE = Configuration.SHOW_SHOOTLINE;\n\n    /**\n     * @param other\n     */\n    public void setTo(final PlayerConfiguration other) {\n        ROUND_DELAY = other.ROUND_DELAY;\n        PLAYER_DELAY = other.PLAYER_DELAY;\n        ACTION_DELAY = other.ACTION_DELAY;\n    }\n\n    /**\n     * @return a copy of this object\n     * @throws CloneNotSupportedException\n     */\n    public PlayerConfiguration copy() throws CloneNotSupportedException {\n        return (PlayerConfiguration) clone();\n    }\n\n    /**\n     * should only be called by {@link Battleplayer}!\n     *\n     * @param newState\n     */\n    synchronized void setState(final PlayerState newState) {\n        state = newState;\n    }\n\n    /**\n     * @return true if the player should be playing\n     */\n    public synchronized boolean isPlaying() {\n        return state == PlayerState.PLAY;\n    }\n\n    /**\n     * @return true if the player is hold\n     */\n    public synchronized boolean isPaused() {\n        return state == PlayerState.PAUSE;\n    }\n\n    /**\n     * @return true if the player is stopped\n     */\n    public synchronized boolean isStopped() {\n        return state == PlayerState.STOP;\n    }\n\n    /**\n     * exclusive use of the player\n     */\n    void lock() {\n        playLock.lock();\n    }\n\n    /**\n     * release the player\n     */\n    void unlock() {\n        playLock.unlock();\n    }\n\n    /**\n     * @return <code>true</code> if lines to movement targets should be\n     *         displayed\n     */\n    public boolean showMoveTargets() {\n        return SHOW_MOVETARGETS;\n    }\n\n    /**\n     * @param showMovetargets\n     */\n    public void setShowMoveTargets(final boolean showMovetargets) {\n        SHOW_MOVETARGETS = showMovetargets;\n        for (final PlayerConfigurationListener listener : listeners) {\n            listener.changedShowMoveTarget(SHOW_MOVETARGETS);\n        }\n    }\n\n    /**\n     * @return <code>true</code> if shooting lines should be displayed\n     */\n    public boolean showShootline() {\n        return SHOW_SHOOTLINE;\n    }\n\n    /**\n     * @param showShootline\n     */\n    public void setShowShootline(final boolean showShootline) {\n        SHOW_SHOOTLINE = showShootline;\n        for (final PlayerConfigurationListener listener : listeners) {\n            listener.changedShowShootingLine(SHOW_SHOOTLINE);\n        }\n    }\n\n    /**\n     * Adds a listener which will be notified about changes.\n     *\n     * @param listener\n     */\n    public void addListener(final PlayerConfigurationListener listener) {\n        listeners.add(listener);\n    }\n\n    /**\n     * Removes the listener from the registered ones.\n     *\n     * @param listener\n     */\n    public void removeListener(final PlayerConfigurationListener listener) {\n        listeners.remove(listener);\n    }\n}\n",
        "test_prompt": "// PlayerConfiguration_0Test.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport de.outstare.fortbattleplayer.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PlayerConfiguration}.\n* It contains ten unit test cases for the {@link PlayerConfiguration#copy()} method.\n*/\nclass PlayerConfiguration_0Test {",
        "original_generated_code": "```java\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass PlayerConfiguration_0Test {\n\n    @Test\n    void testCopyReturnsNewInstance() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n        assertNotSame(original, copy);\n    }\n\n    @Test\n    void testCopyHasSameValues() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        original.ROUND_DELAY = 100;\n        original.PLAYER_DELAY = 200;\n        original.ACTION_DELAY = 300;\n\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        assertEquals(original.ROUND_DELAY, copy.ROUND_DELAY);\n        assertEquals(original.PLAYER_DELAY, copy.PLAYER_DELAY);\n        assertEquals(original.ACTION_DELAY, copy.ACTION_DELAY);\n    }\n\n    @Test\n    void testCopyIsIndependent() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        original.ROUND_DELAY = 100;\n        original.PLAYER_DELAY = 200;\n        original.ACTION_DELAY = 300;\n\n        assertNotEquals(original.ROUND_DELAY, copy.ROUND_DELAY);\n        assertNotEquals(original.PLAYER_DELAY, copy.PLAYER_DELAY);\n        assertNotEquals(original.ACTION_DELAY, copy.ACTION_DELAY);\n    }\n\n    @Test\n    void testCopyIsShallowCopy() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        original.SHOW_MOVETARGETS = true;\n        original.SHOW_SHOOTLINE = true;\n\n        assertFalse(copy.showMoveTargets());\n        assertFalse(copy.showShootline());\n    }\n\n    @Test\n    void testCopyListenerListIsNotCopied() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        original.addListener(listener -> {});\n        assertEquals(1, original.listeners.size());\n        assertEquals(0, copy.listeners.size());\n    }\n\n    @Test\n    void testCopyStateIsNotCopied() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        original.setState(PlayerState.PLAY);\n\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        assertFalse(copy.isPlaying());\n    }\n\n    @Test\n    void testCopyLockIsNotCopied() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        Lock originalLock = original.playLock;\n\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        assertNotSame(originalLock, copy.playLock);\n    }\n\n    @Test\n    void testCopyConfigurationValuesAreCopied() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        original.ROUND_DELAY = 100;\n        original.PLAYER_DELAY = 200;\n        original.ACTION_DELAY = 300;\n\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        assertEquals(original.ROUND_DELAY, copy.ROUND_DELAY);\n        assertEquals(original.PLAYER_DELAY, copy.PLAYER_DELAY);\n        assertEquals(original.ACTION_DELAY, copy.ACTION_DELAY);\n    }\n\n    @Test\n    void testCopyShowMoveTargetsIsCopied() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        original.setShowMoveTargets(true);\n\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        assertTrue(copy.showMoveTargets());\n    }\n\n    @Test\n    void testCopyShowShootlineIsCopied() {\n        PlayerConfiguration original = new PlayerConfiguration();\n        original.setShowShootline(true);\n\n        PlayerConfiguration copy = null;\n        try {\n            copy = original.copy();\n        } catch (CloneNotSupportedException e) {\n            fail(\"CloneNotSupportedException should not be thrown\");\n        }\n\n        assertTrue(copy.showShootline());\n    }\n}\n```\n```",
        "applied_heuristics": "H2;H5"
    },
    {
        "id": "chatcmpl-A5VqobRyhMmV4rmCUkStqFPe9of9G",
        "object": "chat.completion",
        "created": 1725877438,
        "model": "gpt-3.5-turbo-0125",
        "choices": [
            {
                "index": 0,
                "message": {
                    "role": "assistant",
                    "content": "package de.outstare.fortbattleplayer.player;\njava\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass PlayerConfiguration_1Test {\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsTrue_ReturnsTrue() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowMoveTargets(true);\n        assertTrue(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsFalse_ReturnsFalse() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowMoveTargets(false);\n        assertFalse(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsTrueAfterSettingFalse_ReturnsTrue() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowMoveTargets(false);\n        playerConfiguration.setShowMoveTargets(true);\n        assertTrue(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsFalseAfterSettingTrue_ReturnsFalse() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowMoveTargets(true);\n        playerConfiguration.setShowMoveTargets(false);\n        assertFalse(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsTrueAfterMultipleSettings_ReturnsTrue() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowMoveTargets(false);\n        playerConfiguration.setShowMoveTargets(true);\n        playerConfiguration.setShowMoveTargets(false);\n        playerConfiguration.setShowMoveTargets(true);\n        assertTrue(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsFalseAfterMultipleSettings_ReturnsFalse() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowMoveTargets(true);\n        playerConfiguration.setShowMoveTargets(false);\n        playerConfiguration.setShowMoveTargets(true);\n        playerConfiguration.setShowMoveTargets(false);\n        assertFalse(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsTrueInitially_ReturnsTrue() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        assertTrue(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsFalseInitially_ReturnsFalse() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        assertFalse(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsTrueAfterAddingListener_ReturnsTrue() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        PlayerConfigurationListener listener = new PlayerConfigurationListener() {\n            @Override\n            public void changedShowMoveTarget(boolean showMoveTarget) {\n                // do nothing\n            }\n        };\n        playerConfiguration.addListener(listener);\n        playerConfiguration.setShowMoveTargets(true);\n        assertTrue(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsFalseAfterAddingListener_ReturnsFalse() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        PlayerConfigurationListener listener = new PlayerConfigurationListener() {\n            @Override\n            public void changedShowMoveTarget(boolean showMoveTarget) {\n                // do nothing\n            }\n        };\n        playerConfiguration.addListener(listener);\n        playerConfiguration.setShowMoveTargets(false);\n        assertFalse(playerConfiguration.showMoveTargets());\n    }\n}\n",
                    "refusal": null
                },
                "logprobs": null,
                "finish_reason": "stop",
                "text": "package de.outstare.fortbattleplayer.player;\njava\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass PlayerConfiguration_1Test {\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsTrue_ReturnsTrue() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowMoveTargets(true);\n        assertTrue(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsFalse_ReturnsFalse() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowMoveTargets(false);\n        assertFalse(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsTrueAfterSettingFalse_ReturnsTrue() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowMoveTargets(false);\n        playerConfiguration.setShowMoveTargets(true);\n        assertTrue(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsFalseAfterSettingTrue_ReturnsFalse() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowMoveTargets(true);\n        playerConfiguration.setShowMoveTargets(false);\n        assertFalse(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsTrueAfterMultipleSettings_ReturnsTrue() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowMoveTargets(false);\n        playerConfiguration.setShowMoveTargets(true);\n        playerConfiguration.setShowMoveTargets(false);\n        playerConfiguration.setShowMoveTargets(true);\n        assertTrue(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsFalseAfterMultipleSettings_ReturnsFalse() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowMoveTargets(true);\n        playerConfiguration.setShowMoveTargets(false);\n        playerConfiguration.setShowMoveTargets(true);\n        playerConfiguration.setShowMoveTargets(false);\n        assertFalse(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsTrueInitially_ReturnsTrue() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        assertTrue(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsFalseInitially_ReturnsFalse() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        assertFalse(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsTrueAfterAddingListener_ReturnsTrue() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        PlayerConfigurationListener listener = new PlayerConfigurationListener() {\n            @Override\n            public void changedShowMoveTarget(boolean showMoveTarget) {\n                // do nothing\n            }\n        };\n        playerConfiguration.addListener(listener);\n        playerConfiguration.setShowMoveTargets(true);\n        assertTrue(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsFalseAfterAddingListener_ReturnsFalse() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        PlayerConfigurationListener listener = new PlayerConfigurationListener() {\n            @Override\n            public void changedShowMoveTarget(boolean showMoveTarget) {\n                // do nothing\n            }\n        };\n        playerConfiguration.addListener(listener);\n        playerConfiguration.setShowMoveTargets(false);\n        assertFalse(playerConfiguration.showMoveTargets());\n    }\n}\n"
            }
        ],
        "usage": {
            "prompt_tokens": 1553,
            "completion_tokens": 700,
            "total_tokens": 2253
        },
        "system_fingerprint": null,
        "time_taken": 10.064985990524292,
        "prompt_id": "/EvoSuiteBenchmark/original/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/player/PlayerConfiguration_1Test.java",
        "original_code": "// PlayerConfiguration.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport de.outstare.fortbattleplayer.Configuration;\n\n/**\n * An instance of this will be used by the player to hold its tunable\n * parameters.\n *\n * @author daniel\n */\npublic class PlayerConfiguration implements Cloneable {\n\n    /**\n     * a configuration which skips animation (used for purposes where the user\n     * should not see whats going on)\n     */\n    public static final PlayerConfiguration NO_DELAY = new PlayerConfiguration();\n\n    static {\n        NO_DELAY.ACTION_DELAY = 0;\n        NO_DELAY.PLAYER_DELAY = 0;\n        NO_DELAY.ROUND_DELAY = 0;\n        NO_DELAY.setShowMoveTargets(false);\n        NO_DELAY.setShowShootline(false);\n    }\n\n    /**\n     * this is used to control who currently does something with the player\n     */\n    private final Lock playLock = new ReentrantLock();\n\n    private final Set<PlayerConfigurationListener> listeners = new HashSet<PlayerConfigurationListener>();\n\n    /**\n     * current state of the player\n     */\n    private PlayerState state = PlayerState.STOP;\n\n    /**\n     * pause between two rounds in milliseconds\n     */\n    public volatile int ROUND_DELAY = Configuration.ROUND_DELAY;\n\n    /**\n     * pause between two players in a round in milliseconds\n     */\n    public volatile int PLAYER_DELAY = Configuration.PLAYER_DELAY;\n\n    /**\n     * pause between two actions in milliseconds\n     */\n    public volatile int ACTION_DELAY = Configuration.ACTION_DELAY;\n\n    /**\n     * draw a line to the point, where the player wants to go\n     */\n    private volatile boolean SHOW_MOVETARGETS = Configuration.SHOW_MOVETARGETS;\n\n    /**\n     * draw a line to the enemy ath wich the player shoots\n     */\n    private volatile boolean SHOW_SHOOTLINE = Configuration.SHOW_SHOOTLINE;\n\n    /**\n     * @param other\n     */\n    public void setTo(final PlayerConfiguration other) {\n        ROUND_DELAY = other.ROUND_DELAY;\n        PLAYER_DELAY = other.PLAYER_DELAY;\n        ACTION_DELAY = other.ACTION_DELAY;\n    }\n\n    /**\n     * @return a copy of this object\n     * @throws CloneNotSupportedException\n     */\n    public PlayerConfiguration copy() throws CloneNotSupportedException {\n        return (PlayerConfiguration) clone();\n    }\n\n    /**\n     * should only be called by {@link Battleplayer}!\n     *\n     * @param newState\n     */\n    synchronized void setState(final PlayerState newState) {\n        state = newState;\n    }\n\n    /**\n     * @return true if the player should be playing\n     */\n    public synchronized boolean isPlaying() {\n        return state == PlayerState.PLAY;\n    }\n\n    /**\n     * @return true if the player is hold\n     */\n    public synchronized boolean isPaused() {\n        return state == PlayerState.PAUSE;\n    }\n\n    /**\n     * @return true if the player is stopped\n     */\n    public synchronized boolean isStopped() {\n        return state == PlayerState.STOP;\n    }\n\n    /**\n     * exclusive use of the player\n     */\n    void lock() {\n        playLock.lock();\n    }\n\n    /**\n     * release the player\n     */\n    void unlock() {\n        playLock.unlock();\n    }\n\n    /**\n     * @return <code>true</code> if lines to movement targets should be\n     *         displayed\n     */\n    public boolean showMoveTargets() {\n        return SHOW_MOVETARGETS;\n    }\n\n    /**\n     * @param showMovetargets\n     */\n    public void setShowMoveTargets(final boolean showMovetargets) {\n        SHOW_MOVETARGETS = showMovetargets;\n        for (final PlayerConfigurationListener listener : listeners) {\n            listener.changedShowMoveTarget(SHOW_MOVETARGETS);\n        }\n    }\n\n    /**\n     * @return <code>true</code> if shooting lines should be displayed\n     */\n    public boolean showShootline() {\n        return SHOW_SHOOTLINE;\n    }\n\n    /**\n     * @param showShootline\n     */\n    public void setShowShootline(final boolean showShootline) {\n        SHOW_SHOOTLINE = showShootline;\n        for (final PlayerConfigurationListener listener : listeners) {\n            listener.changedShowShootingLine(SHOW_SHOOTLINE);\n        }\n    }\n\n    /**\n     * Adds a listener which will be notified about changes.\n     *\n     * @param listener\n     */\n    public void addListener(final PlayerConfigurationListener listener) {\n        listeners.add(listener);\n    }\n\n    /**\n     * Removes the listener from the registered ones.\n     *\n     * @param listener\n     */\n    public void removeListener(final PlayerConfigurationListener listener) {\n        listeners.remove(listener);\n    }\n}\n",
        "test_prompt": "// PlayerConfiguration_1Test.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport de.outstare.fortbattleplayer.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PlayerConfiguration}.\n* It contains ten unit test cases for the {@link PlayerConfiguration#showMoveTargets()} method.\n*/\nclass PlayerConfiguration_1Test {",
        "original_generated_code": "```java\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass PlayerConfiguration_1Test {\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsTrue_ReturnsTrue() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowMoveTargets(true);\n        assertTrue(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsFalse_ReturnsFalse() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowMoveTargets(false);\n        assertFalse(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsTrueAfterSettingFalse_ReturnsTrue() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowMoveTargets(false);\n        playerConfiguration.setShowMoveTargets(true);\n        assertTrue(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsFalseAfterSettingTrue_ReturnsFalse() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowMoveTargets(true);\n        playerConfiguration.setShowMoveTargets(false);\n        assertFalse(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsTrueAfterMultipleSettings_ReturnsTrue() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowMoveTargets(false);\n        playerConfiguration.setShowMoveTargets(true);\n        playerConfiguration.setShowMoveTargets(false);\n        playerConfiguration.setShowMoveTargets(true);\n        assertTrue(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsFalseAfterMultipleSettings_ReturnsFalse() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowMoveTargets(true);\n        playerConfiguration.setShowMoveTargets(false);\n        playerConfiguration.setShowMoveTargets(true);\n        playerConfiguration.setShowMoveTargets(false);\n        assertFalse(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsTrueInitially_ReturnsTrue() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        assertTrue(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsFalseInitially_ReturnsFalse() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        assertFalse(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsTrueAfterAddingListener_ReturnsTrue() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        PlayerConfigurationListener listener = new PlayerConfigurationListener() {\n            @Override\n            public void changedShowMoveTarget(boolean showMoveTarget) {\n                // do nothing\n            }\n        };\n        playerConfiguration.addListener(listener);\n        playerConfiguration.setShowMoveTargets(true);\n        assertTrue(playerConfiguration.showMoveTargets());\n    }\n\n    @Test\n    void testShowMoveTargets_WhenShowMoveTargetsIsFalseAfterAddingListener_ReturnsFalse() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        PlayerConfigurationListener listener = new PlayerConfigurationListener() {\n            @Override\n            public void changedShowMoveTarget(boolean showMoveTarget) {\n                // do nothing\n            }\n        };\n        playerConfiguration.addListener(listener);\n        playerConfiguration.setShowMoveTargets(false);\n        assertFalse(playerConfiguration.showMoveTargets());\n    }\n}\n```\n",
        "applied_heuristics": "H2;H5"
    },
    {
        "id": "chatcmpl-A5Vrrx4fwGVefAbHFL4NnWsey20GO",
        "object": "chat.completion",
        "created": 1725877503,
        "model": "gpt-3.5-turbo-0125",
        "choices": [
            {
                "index": 0,
                "message": {
                    "role": "assistant",
                    "content": "package de.outstare.fortbattleplayer.player;\njava\nclass PlayerConfiguration_2Test {\n    \n    @Test\n    void testShowShootlineReturnsTrueWhenSetTrue() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(true);\n        assertTrue(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsFalseWhenSetFalse() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(false);\n        assertFalse(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsFalseByDefault() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        assertFalse(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsTrueAfterSettingTrue() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(false);\n        playerConfiguration.setShowShootline(true);\n        assertTrue(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsFalseAfterSettingFalse() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(true);\n        playerConfiguration.setShowShootline(false);\n        assertFalse(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsTrueAfterMultipleSetTrueCalls() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(true);\n        playerConfiguration.setShowShootline(true);\n        assertTrue(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsFalseAfterMultipleSetFalseCalls() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(false);\n        playerConfiguration.setShowShootline(false);\n        assertFalse(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsTrueAfterMixedSetCalls() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(true);\n        playerConfiguration.setShowShootline(false);\n        assertTrue(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsFalseAfterMixedSetCalls() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(false);\n        playerConfiguration.setShowShootline(true);\n        assertFalse(playerConfiguration.showShootline());\n    }\n}\n",
                    "refusal": null
                },
                "logprobs": null,
                "finish_reason": "stop",
                "text": "package de.outstare.fortbattleplayer.player;\njava\nclass PlayerConfiguration_2Test {\n    \n    @Test\n    void testShowShootlineReturnsTrueWhenSetTrue() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(true);\n        assertTrue(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsFalseWhenSetFalse() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(false);\n        assertFalse(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsFalseByDefault() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        assertFalse(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsTrueAfterSettingTrue() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(false);\n        playerConfiguration.setShowShootline(true);\n        assertTrue(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsFalseAfterSettingFalse() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(true);\n        playerConfiguration.setShowShootline(false);\n        assertFalse(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsTrueAfterMultipleSetTrueCalls() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(true);\n        playerConfiguration.setShowShootline(true);\n        assertTrue(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsFalseAfterMultipleSetFalseCalls() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(false);\n        playerConfiguration.setShowShootline(false);\n        assertFalse(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsTrueAfterMixedSetCalls() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(true);\n        playerConfiguration.setShowShootline(false);\n        assertTrue(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsFalseAfterMixedSetCalls() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(false);\n        playerConfiguration.setShowShootline(true);\n        assertFalse(playerConfiguration.showShootline());\n    }\n}\n"
            }
        ],
        "usage": {
            "prompt_tokens": 1553,
            "completion_tokens": 479,
            "total_tokens": 2032
        },
        "system_fingerprint": null,
        "time_taken": 8.712569952011108,
        "prompt_id": "/EvoSuiteBenchmark/original/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/player/PlayerConfiguration_2Test.java",
        "original_code": "// PlayerConfiguration.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport de.outstare.fortbattleplayer.Configuration;\n\n/**\n * An instance of this will be used by the player to hold its tunable\n * parameters.\n *\n * @author daniel\n */\npublic class PlayerConfiguration implements Cloneable {\n\n    /**\n     * a configuration which skips animation (used for purposes where the user\n     * should not see whats going on)\n     */\n    public static final PlayerConfiguration NO_DELAY = new PlayerConfiguration();\n\n    static {\n        NO_DELAY.ACTION_DELAY = 0;\n        NO_DELAY.PLAYER_DELAY = 0;\n        NO_DELAY.ROUND_DELAY = 0;\n        NO_DELAY.setShowMoveTargets(false);\n        NO_DELAY.setShowShootline(false);\n    }\n\n    /**\n     * this is used to control who currently does something with the player\n     */\n    private final Lock playLock = new ReentrantLock();\n\n    private final Set<PlayerConfigurationListener> listeners = new HashSet<PlayerConfigurationListener>();\n\n    /**\n     * current state of the player\n     */\n    private PlayerState state = PlayerState.STOP;\n\n    /**\n     * pause between two rounds in milliseconds\n     */\n    public volatile int ROUND_DELAY = Configuration.ROUND_DELAY;\n\n    /**\n     * pause between two players in a round in milliseconds\n     */\n    public volatile int PLAYER_DELAY = Configuration.PLAYER_DELAY;\n\n    /**\n     * pause between two actions in milliseconds\n     */\n    public volatile int ACTION_DELAY = Configuration.ACTION_DELAY;\n\n    /**\n     * draw a line to the point, where the player wants to go\n     */\n    private volatile boolean SHOW_MOVETARGETS = Configuration.SHOW_MOVETARGETS;\n\n    /**\n     * draw a line to the enemy ath wich the player shoots\n     */\n    private volatile boolean SHOW_SHOOTLINE = Configuration.SHOW_SHOOTLINE;\n\n    /**\n     * @param other\n     */\n    public void setTo(final PlayerConfiguration other) {\n        ROUND_DELAY = other.ROUND_DELAY;\n        PLAYER_DELAY = other.PLAYER_DELAY;\n        ACTION_DELAY = other.ACTION_DELAY;\n    }\n\n    /**\n     * @return a copy of this object\n     * @throws CloneNotSupportedException\n     */\n    public PlayerConfiguration copy() throws CloneNotSupportedException {\n        return (PlayerConfiguration) clone();\n    }\n\n    /**\n     * should only be called by {@link Battleplayer}!\n     *\n     * @param newState\n     */\n    synchronized void setState(final PlayerState newState) {\n        state = newState;\n    }\n\n    /**\n     * @return true if the player should be playing\n     */\n    public synchronized boolean isPlaying() {\n        return state == PlayerState.PLAY;\n    }\n\n    /**\n     * @return true if the player is hold\n     */\n    public synchronized boolean isPaused() {\n        return state == PlayerState.PAUSE;\n    }\n\n    /**\n     * @return true if the player is stopped\n     */\n    public synchronized boolean isStopped() {\n        return state == PlayerState.STOP;\n    }\n\n    /**\n     * exclusive use of the player\n     */\n    void lock() {\n        playLock.lock();\n    }\n\n    /**\n     * release the player\n     */\n    void unlock() {\n        playLock.unlock();\n    }\n\n    /**\n     * @return <code>true</code> if lines to movement targets should be\n     *         displayed\n     */\n    public boolean showMoveTargets() {\n        return SHOW_MOVETARGETS;\n    }\n\n    /**\n     * @param showMovetargets\n     */\n    public void setShowMoveTargets(final boolean showMovetargets) {\n        SHOW_MOVETARGETS = showMovetargets;\n        for (final PlayerConfigurationListener listener : listeners) {\n            listener.changedShowMoveTarget(SHOW_MOVETARGETS);\n        }\n    }\n\n    /**\n     * @return <code>true</code> if shooting lines should be displayed\n     */\n    public boolean showShootline() {\n        return SHOW_SHOOTLINE;\n    }\n\n    /**\n     * @param showShootline\n     */\n    public void setShowShootline(final boolean showShootline) {\n        SHOW_SHOOTLINE = showShootline;\n        for (final PlayerConfigurationListener listener : listeners) {\n            listener.changedShowShootingLine(SHOW_SHOOTLINE);\n        }\n    }\n\n    /**\n     * Adds a listener which will be notified about changes.\n     *\n     * @param listener\n     */\n    public void addListener(final PlayerConfigurationListener listener) {\n        listeners.add(listener);\n    }\n\n    /**\n     * Removes the listener from the registered ones.\n     *\n     * @param listener\n     */\n    public void removeListener(final PlayerConfigurationListener listener) {\n        listeners.remove(listener);\n    }\n}\n",
        "test_prompt": "// PlayerConfiguration_2Test.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport de.outstare.fortbattleplayer.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PlayerConfiguration}.\n* It contains ten unit test cases for the {@link PlayerConfiguration#showShootline()} method.\n*/\nclass PlayerConfiguration_2Test {",
        "original_generated_code": "```java\nclass PlayerConfiguration_2Test {\n    \n    @Test\n    void testShowShootlineReturnsTrueWhenSetTrue() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(true);\n        assertTrue(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsFalseWhenSetFalse() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(false);\n        assertFalse(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsFalseByDefault() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        assertFalse(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsTrueAfterSettingTrue() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(false);\n        playerConfiguration.setShowShootline(true);\n        assertTrue(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsFalseAfterSettingFalse() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(true);\n        playerConfiguration.setShowShootline(false);\n        assertFalse(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsTrueAfterMultipleSetTrueCalls() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(true);\n        playerConfiguration.setShowShootline(true);\n        assertTrue(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsFalseAfterMultipleSetFalseCalls() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(false);\n        playerConfiguration.setShowShootline(false);\n        assertFalse(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsTrueAfterMixedSetCalls() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(true);\n        playerConfiguration.setShowShootline(false);\n        assertTrue(playerConfiguration.showShootline());\n    }\n\n    @Test\n    void testShowShootlineReturnsFalseAfterMixedSetCalls() {\n        PlayerConfiguration playerConfiguration = new PlayerConfiguration();\n        playerConfiguration.setShowShootline(false);\n        playerConfiguration.setShowShootline(true);\n        assertFalse(playerConfiguration.showShootline());\n    }\n}\n```\n```",
        "applied_heuristics": "H2;H5"
    },
    {
        "id": "chatcmpl-A5VsuhVgOoYBjRToYgWlpKWrkphAb",
        "object": "chat.completion",
        "created": 1725877568,
        "model": "gpt-3.5-turbo-0125",
        "choices": [
            {
                "index": 0,
                "message": {
                    "role": "assistant",
                    "content": "java\npackage de.outstare.fortbattleplayer.player;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Battleplan_0Test {\n\n    @Test\n    void testNumberOfRounds_EmptyPlan() {\n        Collection<Round> rounds = new ArrayList<>();\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(0, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_SingleRound() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(1));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_MultipleRounds() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(1));\n        rounds.add(new Round(2));\n        rounds.add(new Round(3));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(3, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_DuplicateRounds() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(1));\n        rounds.add(new Round(1));\n        rounds.add(new Round(2));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(2, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_NullRounds() {\n        Collection<Round> rounds = null;\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(0, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_EmptyRoundList() {\n        Collection<Round> rounds = new ArrayList<>();\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(0, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_LargeNumberOfRounds() {\n        Collection<Round> rounds = new ArrayList<>();\n        for (int i = 1; i <= 1000; i++) {\n            rounds.add(new Round(i));\n        }\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1000, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_NegativeRoundNumber() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(-1));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_RoundNumberZero() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(0));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_MaxIntegerRoundNumber() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(Integer.MAX_VALUE));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1, plan.numberOfRounds());\n    }\n}\n",
                    "refusal": null
                },
                "logprobs": null,
                "finish_reason": "stop",
                "text": "java\npackage de.outstare.fortbattleplayer.player;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Battleplan_0Test {\n\n    @Test\n    void testNumberOfRounds_EmptyPlan() {\n        Collection<Round> rounds = new ArrayList<>();\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(0, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_SingleRound() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(1));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_MultipleRounds() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(1));\n        rounds.add(new Round(2));\n        rounds.add(new Round(3));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(3, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_DuplicateRounds() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(1));\n        rounds.add(new Round(1));\n        rounds.add(new Round(2));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(2, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_NullRounds() {\n        Collection<Round> rounds = null;\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(0, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_EmptyRoundList() {\n        Collection<Round> rounds = new ArrayList<>();\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(0, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_LargeNumberOfRounds() {\n        Collection<Round> rounds = new ArrayList<>();\n        for (int i = 1; i <= 1000; i++) {\n            rounds.add(new Round(i));\n        }\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1000, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_NegativeRoundNumber() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(-1));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_RoundNumberZero() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(0));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_MaxIntegerRoundNumber() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(Integer.MAX_VALUE));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1, plan.numberOfRounds());\n    }\n}\n"
            }
        ],
        "usage": {
            "prompt_tokens": 1367,
            "completion_tokens": 1927,
            "total_tokens": 3294
        },
        "system_fingerprint": null,
        "time_taken": 43.573384046554565,
        "prompt_id": "/EvoSuiteBenchmark/original/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/player/Battleplan_0Test.java",
        "original_code": "// Battleplan.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.Collection;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.logging.Logger;\n\n/**\n * A plan which determines each step of the battle. A battle is divided into\n * {@link Round}s.\n *\n * @author daniel\n */\npublic class Battleplan {\n\n    private static final transient Logger LOG = Logger.getLogger(Battleplan.class.getName());\n\n    private final SortedMap<Integer, Round> rounds = new TreeMap<Integer, Round>();\n\n    /**\n     * Create a new plan with the given rounds\n     *\n     * @param roundsOfPlan\n     */\n    public Battleplan(final Collection<Round> roundsOfPlan) {\n        mapRoundsToNumbers(roundsOfPlan);\n    }\n\n    /**\n     * @param roundsOfPlan\n     */\n    private void mapRoundsToNumbers(final Collection<Round> roundsOfPlan) {\n        for (final Round round : roundsOfPlan) {\n            final int no = round.getNo();\n            final Integer roundNo = Integer.valueOf(no);\n            if (rounds.containsKey(roundNo)) {\n                LOG.warning(\"multiple rounds with number \" + roundNo + \"! overwriting\");\n            }\n            rounds.put(roundNo, round);\n        }\n    }\n\n    /**\n     * @return the number of rounds this plan has\n     */\n    public int numberOfRounds() {\n        return rounds.size();\n    }\n\n    /**\n     * executes the given {@link Round} of this plan\n     *\n     * @param roundNo\n     *            0 <= roundNo <= numberOfRounds()\n     * @param config\n     */\n    public void executeRound(final int roundNo, final PlayerConfiguration config) {\n        getRound(roundNo).execute(config);\n    }\n\n    /**\n     * @param roundNo\n     * @return\n     * @throws IllegalArgumentException\n     */\n    private Round getRound(final int roundNo) throws IllegalArgumentException {\n        final Integer roundKey = Integer.valueOf(roundNo);\n        if (!rounds.containsKey(roundKey)) {\n            throw new IllegalArgumentException(\"the given round number does not exist: \" + roundNo);\n        }\n        final Round round = rounds.get(roundKey);\n        return round;\n    }\n\n    /**\n     * @param no\n     * @return <code>true</code> if this plan contains a round with the given\n     *         number\n     */\n    public boolean hasRoundNo(final int no) {\n        final Integer roundKey = Integer.valueOf(no);\n        return rounds.containsKey(roundKey);\n    }\n\n    /**\n     * @param roundNo\n     */\n    public void resetToRound(final int roundNo) {\n        if (hasRoundNo(roundNo)) {\n            getRound(roundNo).setInitialState();\n        }\n    }\n\n    /**\n     * @param roundNo\n     * @return <code>true</code> if more rounds follow after the given round\n     *         number.\n     */\n    public boolean hasMoreRounds(final int roundNo) {\n        return !getRemainingRounds(roundNo).isEmpty();\n    }\n\n    /**\n     * @require hasMoreRounds(currentRoundNo)\n     * @param currentRoundNo\n     * @return the number of the following round\n     */\n    public int getNextRound(final int currentRoundNo) {\n        final SortedMap<Integer, Round> remainingRounds = getRemainingRounds(currentRoundNo);\n        assert remainingRounds.size() > 0 : \"more rounds must exist!\";\n        return remainingRounds.firstKey().intValue();\n    }\n\n    /**\n     * @param currentRoundNo\n     * @return all rounds that follow after the given round number\n     */\n    private SortedMap<Integer, Round> getRemainingRounds(final int currentRoundNo) {\n        final Integer nextRoundNo = Integer.valueOf(currentRoundNo + 1);\n        final SortedMap<Integer, Round> remainingRounds = rounds.tailMap(nextRoundNo);\n        return remainingRounds;\n    }\n}\n",
        "test_prompt": "// Battleplan_0Test.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.Collection;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Battleplan}.\n* It contains ten unit test cases for the {@link Battleplan#numberOfRounds()} method.\n*/\nclass Battleplan_0Test {",
        "original_generated_code": "```java\npackage de.outstare.fortbattleplayer.player;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Battleplan_0Test {\n\n    @Test\n    void testNumberOfRounds_EmptyPlan() {\n        Collection<Round> rounds = new ArrayList<>();\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(0, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_SingleRound() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(1));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_MultipleRounds() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(1));\n        rounds.add(new Round(2));\n        rounds.add(new Round(3));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(3, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_DuplicateRounds() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(1));\n        rounds.add(new Round(1));\n        rounds.add(new Round(2));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(2, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_NullRounds() {\n        Collection<Round> rounds = null;\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(0, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_EmptyRoundList() {\n        Collection<Round> rounds = new ArrayList<>();\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(0, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_LargeNumberOfRounds() {\n        Collection<Round> rounds = new ArrayList<>();\n        for (int i = 1; i <= 1000; i++) {\n            rounds.add(new Round(i));\n        }\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1000, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_NegativeRoundNumber() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(-1));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_RoundNumberZero() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(0));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_MaxIntegerRoundNumber() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(Integer.MAX_VALUE));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1, plan.numberOfRounds());\n    }\n}\n```\n```java\npackage de.outstare.fortbattleplayer.player;\n\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Battleplan_0Test {\n\n    @Test\n    void testNumberOfRounds_EmptyPlan() {\n        Collection<Round> rounds = new ArrayList<>();\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(0, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_SingleRound() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(1));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_MultipleRounds() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(1));\n        rounds.add(new Round(2));\n        rounds.add(new Round(3));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(3, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_DuplicateRounds() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(1));\n        rounds.add(new Round(1));\n        rounds.add(new Round(2));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(2, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_NullRounds() {\n        Collection<Round> rounds = null;\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(0, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_EmptyRoundList() {\n        Collection<Round> rounds = new ArrayList<>();\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(0, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_LargeNumberOfRounds() {\n        Collection<Round> rounds = new ArrayList<>();\n        for (int i = 1; i <= 1000; i++) {\n            rounds.add(new Round(i));\n        }\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1000, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_NegativeRoundNumber() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(-1));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_RoundNumberZero() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(0));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_MaxIntegerRoundNumber() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(Integer.MAX_VALUE));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1, plan.numberOfRounds());\n    }\n}\n```\n```java\npackage de.outstare.fortbattleplayer.player;\n\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Battleplan_0Test {\n\n    @Test\n    void testNumberOfRounds_EmptyPlan() {\n        Collection<Round> rounds = new ArrayList<>();\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(0, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_SingleRound() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(1));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_MultipleRounds() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(1));\n        rounds.add(new Round(2));\n        rounds.add(new Round(3));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(3, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_DuplicateRounds() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(1));\n        rounds.add(new Round(1));\n        rounds.add(new Round(2));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(2, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_NullRounds() {\n        Collection<Round> rounds = null;\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(0, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_EmptyRoundList() {\n        Collection<Round> rounds = new ArrayList<>();\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(0, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_LargeNumberOfRounds() {\n        Collection<Round> rounds = new ArrayList<>();\n        for (int i = 1; i <= 1000; i++) {\n            rounds.add(new Round(i));\n        }\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1000, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_NegativeRoundNumber() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(-1));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_RoundNumberZero() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(0));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1, plan.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRounds_MaxIntegerRoundNumber() {\n        Collection<Round> rounds = new ArrayList<>();\n        rounds.add(new Round(Integer.MAX_VALUE));\n        Battleplan plan = new Battleplan(rounds);\n        assertEquals(1, plan.numberOfRounds());\n    }\n}\n```",
        "applied_heuristics": "H2"
    },
    {
        "id": "chatcmpl-A5VtxMX46apbkOnyqu1qQgDoBr6s4",
        "object": "chat.completion",
        "created": 1725877633,
        "model": "gpt-3.5-turbo-0125",
        "choices": [
            {
                "index": 0,
                "message": {
                    "role": "assistant",
                    "content": "java\npackage de.outstare.fortbattleplayer.player;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass BattleplayerTest {\n\n    @Test\n    void testNumberOfRoundsWithEmptyPlan() {\n        Battleplan emptyPlan = new Battleplan();\n        Battleplayer player = new Battleplayer(emptyPlan);\n        assertEquals(0, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithSingleRound() {\n        Battleplan singleRoundPlan = new Battleplan();\n        singleRoundPlan.addRound(1);\n        Battleplayer player = new Battleplayer(singleRoundPlan);\n        assertEquals(1, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithMultipleRounds() {\n        Battleplan multipleRoundsPlan = new Battleplan();\n        multipleRoundsPlan.addRound(1);\n        multipleRoundsPlan.addRound(2);\n        multipleRoundsPlan.addRound(3);\n        Battleplayer player = new Battleplayer(multipleRoundsPlan);\n        assertEquals(3, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithNoRounds() {\n        Battleplan noRoundsPlan = new Battleplan();\n        Battleplayer player = new Battleplayer(noRoundsPlan);\n        assertEquals(0, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithNullPlan() {\n        Battleplayer player = new Battleplayer(null);\n        assertEquals(0, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithEmptyPlanAndConfig() {\n        Battleplan emptyPlan = new Battleplan();\n        PlayerConfiguration config = new PlayerConfiguration();\n        Battleplayer player = new Battleplayer(emptyPlan, config);\n        assertEquals(0, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithSingleRoundAndConfig() {\n        Battleplan singleRoundPlan = new Battleplan();\n        singleRoundPlan.addRound(1);\n        PlayerConfiguration config = new PlayerConfiguration();\n        Battleplayer player = new Battleplayer(singleRoundPlan, config);\n        assertEquals(1, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithMultipleRoundsAndConfig() {\n        Battleplan multipleRoundsPlan = new Battleplan();\n        multipleRoundsPlan.addRound(1);\n        multipleRoundsPlan.addRound(2);\n        multipleRoundsPlan.addRound(3);\n        PlayerConfiguration config = new PlayerConfiguration();\n        Battleplayer player = new Battleplayer(multipleRoundsPlan, config);\n        assertEquals(3, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithNoRoundsAndConfig() {\n        Battleplan noRoundsPlan = new Battleplan();\n        PlayerConfiguration config = new PlayerConfiguration();\n        Battleplayer player = new Battleplayer(noRoundsPlan, config);\n        assertEquals(0, player.numberOfRounds());\n    }\n}\n",
                    "refusal": null
                },
                "logprobs": null,
                "finish_reason": "stop",
                "text": "java\npackage de.outstare.fortbattleplayer.player;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass BattleplayerTest {\n\n    @Test\n    void testNumberOfRoundsWithEmptyPlan() {\n        Battleplan emptyPlan = new Battleplan();\n        Battleplayer player = new Battleplayer(emptyPlan);\n        assertEquals(0, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithSingleRound() {\n        Battleplan singleRoundPlan = new Battleplan();\n        singleRoundPlan.addRound(1);\n        Battleplayer player = new Battleplayer(singleRoundPlan);\n        assertEquals(1, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithMultipleRounds() {\n        Battleplan multipleRoundsPlan = new Battleplan();\n        multipleRoundsPlan.addRound(1);\n        multipleRoundsPlan.addRound(2);\n        multipleRoundsPlan.addRound(3);\n        Battleplayer player = new Battleplayer(multipleRoundsPlan);\n        assertEquals(3, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithNoRounds() {\n        Battleplan noRoundsPlan = new Battleplan();\n        Battleplayer player = new Battleplayer(noRoundsPlan);\n        assertEquals(0, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithNullPlan() {\n        Battleplayer player = new Battleplayer(null);\n        assertEquals(0, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithEmptyPlanAndConfig() {\n        Battleplan emptyPlan = new Battleplan();\n        PlayerConfiguration config = new PlayerConfiguration();\n        Battleplayer player = new Battleplayer(emptyPlan, config);\n        assertEquals(0, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithSingleRoundAndConfig() {\n        Battleplan singleRoundPlan = new Battleplan();\n        singleRoundPlan.addRound(1);\n        PlayerConfiguration config = new PlayerConfiguration();\n        Battleplayer player = new Battleplayer(singleRoundPlan, config);\n        assertEquals(1, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithMultipleRoundsAndConfig() {\n        Battleplan multipleRoundsPlan = new Battleplan();\n        multipleRoundsPlan.addRound(1);\n        multipleRoundsPlan.addRound(2);\n        multipleRoundsPlan.addRound(3);\n        PlayerConfiguration config = new PlayerConfiguration();\n        Battleplayer player = new Battleplayer(multipleRoundsPlan, config);\n        assertEquals(3, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithNoRoundsAndConfig() {\n        Battleplan noRoundsPlan = new Battleplan();\n        PlayerConfiguration config = new PlayerConfiguration();\n        Battleplayer player = new Battleplayer(noRoundsPlan, config);\n        assertEquals(0, player.numberOfRounds());\n    }\n}\n"
            }
        ],
        "usage": {
            "prompt_tokens": 1811,
            "completion_tokens": 614,
            "total_tokens": 2425
        },
        "system_fingerprint": null,
        "time_taken": 9.204554319381714,
        "prompt_id": "/EvoSuiteBenchmark/original/79_twfbplayer/src/main/java/de/outstare/fortbattleplayer/player/Battleplayer.java",
        "original_code": "// Battleplayer.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Combatant;\n\n/**\n * A {@link Battleplayer} controls the battle. It is a puppet player controlling\n * the behavior of the {@link Combatant}s.\n *\n * @author daniel\n */\npublic class Battleplayer implements Player {\n\n    private static final transient Logger LOG = Logger.getLogger(Battleplayer.class.getName());\n\n    private final Battleplan plan;\n\n    private final Set<RoundListener> listeners = new HashSet<RoundListener>();\n\n    private boolean isPaused = false;\n\n    /**\n     * round numbers may not be sequential (this variable is also used for\n     * locking during a round)\n     */\n    private int currentRoundNo;\n\n    private volatile boolean isPlaying = false;\n\n    private volatile boolean shouldStop = false;\n\n    /**\n     * controls some aspects of the behavior of the player\n     */\n    public final PlayerConfiguration config;\n\n    /**\n     * @param plan\n     * @param config\n     */\n    public Battleplayer(final Battleplan plan, final PlayerConfiguration config) {\n        this.plan = plan;\n        this.config = config;\n        if (!plan.hasMoreRounds(0)) {\n            throw new IllegalStateException(\"Cannot play a battle without rounds!\");\n        }\n        currentRoundNo = plan.getNextRound(0);\n    }\n\n    /**\n     * @param plan\n     */\n    public Battleplayer(final Battleplan plan) {\n        this(plan, new PlayerConfiguration());\n    }\n\n    /**\n     * let the battle begin! The whole battle is done by executing the\n     * {@link Battleplan}.\n     */\n    public void play() {\n        isPlaying = true;\n        LOG.info(\"now playing\");\n        while (!shouldStop) {\n            playCurrentRound(currentRoundNo);\n            if (plan.hasMoreRounds(currentRoundNo)) {\n                currentRoundNo = plan.getNextRound(currentRoundNo);\n            } else {\n                break;\n            }\n        }\n        shouldStop = false;\n        isPlaying = false;\n        LOG.info(\"stopped playing\");\n    }\n\n    /**\n     * blocks until current round has ended\n     *\n     * @see de.outstare.fortbattleplayer.player.Player#gotoRound(de.outstare.fortbattleplayer.player.Round)\n     */\n    public void gotoRound(final int i) {\n        assert plan.hasRoundNo(i) : \"round with number \" + i + \" must exist!\";\n        stop();\n        while (isPlaying) {\n            try {\n                LOG.fine(\"waiting for round \" + currentRoundNo + \" to end to go to round \" + i);\n                Thread.sleep(500);\n            } catch (final InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        synchronized (this) {\n            currentRoundNo = i;\n        }\n        plan.resetToRound(currentRoundNo);\n    }\n\n    /**\n     * executes the round of the internal state\n     */\n    private void playCurrentRound(final int roundNo) {\n        fireNewRoundEvent(roundNo);\n        plan.executeRound(roundNo, config);\n        delayNextRound();\n    }\n\n    /**\n     * wait the time given in {@link PlayerConfiguration#ROUND_DELAY}\n     */\n    private void delayNextRound() {\n        try {\n            Thread.sleep(config.ROUND_DELAY);\n        } catch (final InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * tell all listeners that a new round will start now\n     *\n     * @param roundNo\n     */\n    private void fireNewRoundEvent(final int roundNo) {\n        for (final RoundListener listener : listeners) {\n            listener.nextRound(roundNo);\n        }\n    }\n\n    /**\n     * @param listener\n     */\n    public void addRoundListener(final RoundListener listener) {\n        listeners.add(listener);\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.player.Player#stop()\n     */\n    public void stop() {\n        if (isPlaying) {\n            LOG.fine(\"stopping\");\n            shouldStop = true;\n        } else {\n            LOG.fine(\"already stopped\");\n        }\n    }\n\n    /**\n     * A RoundListener waits for Round events.\n     *\n     * @author daniel\n     */\n    public static interface RoundListener {\n\n        /**\n         * a new round will begin immediatly\n         *\n         * @param roundNo\n         */\n        void nextRound(int roundNo);\n    }\n\n    /**\n     * @return the number of rounds this player shows\n     */\n    public int numberOfRounds() {\n        return plan.numberOfRounds();\n    }\n\n    /**\n     * toggles pause which holds playing rounds. if this player is currently\n     * paused can be checked with isPaused()\n     */\n    public void pause() {\n        if (isPaused) {\n            config.unlock();\n            isPaused = false;\n        } else {\n            config.lock();\n            isPaused = true;\n        }\n    }\n\n    /**\n     * @return <code>true</code> if this player is playing and is currently hold\n     */\n    public boolean isPaused() {\n        return isPaused;\n    }\n\n    /**\n     * @see de.outstare.fortbattleplayer.player.Player#getRoundNumbers()\n     */\n    public List<Integer> getRoundNumbers() {\n        // always generating a new list\n        final List<Integer> rounds = new ArrayList<Integer>(plan.numberOfRounds());\n        // check if first round exists\n        final int firstRound = 0;\n        if (plan.hasRoundNo(firstRound)) {\n            rounds.add(Integer.valueOf(firstRound));\n        }\n        // add all following rounds\n        int roundNo;\n        for (roundNo = plan.getNextRound(firstRound); plan.hasMoreRounds(roundNo); roundNo = plan.getNextRound(roundNo)) {\n            rounds.add(Integer.valueOf(roundNo));\n        }\n        // add last round (has no round after it)\n        rounds.add(Integer.valueOf(roundNo));\n        return rounds;\n    }\n}\n",
        "test_prompt": "// BattleplayerTest.java\npackage de.outstare.fortbattleplayer.player;\n\n/*\n Copyright (c) 2010 Daniel Raap\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport de.outstare.fortbattleplayer.model.Combatant;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Battleplayer}.\n* It contains ten unit test cases for the {@link Battleplayer#numberOfRounds()} method.\n*/\nclass BattleplayerTest {",
        "original_generated_code": "```java\npackage de.outstare.fortbattleplayer.player;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass BattleplayerTest {\n\n    @Test\n    void testNumberOfRoundsWithEmptyPlan() {\n        Battleplan emptyPlan = new Battleplan();\n        Battleplayer player = new Battleplayer(emptyPlan);\n        assertEquals(0, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithSingleRound() {\n        Battleplan singleRoundPlan = new Battleplan();\n        singleRoundPlan.addRound(1);\n        Battleplayer player = new Battleplayer(singleRoundPlan);\n        assertEquals(1, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithMultipleRounds() {\n        Battleplan multipleRoundsPlan = new Battleplan();\n        multipleRoundsPlan.addRound(1);\n        multipleRoundsPlan.addRound(2);\n        multipleRoundsPlan.addRound(3);\n        Battleplayer player = new Battleplayer(multipleRoundsPlan);\n        assertEquals(3, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithNoRounds() {\n        Battleplan noRoundsPlan = new Battleplan();\n        Battleplayer player = new Battleplayer(noRoundsPlan);\n        assertEquals(0, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithNullPlan() {\n        Battleplayer player = new Battleplayer(null);\n        assertEquals(0, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithEmptyPlanAndConfig() {\n        Battleplan emptyPlan = new Battleplan();\n        PlayerConfiguration config = new PlayerConfiguration();\n        Battleplayer player = new Battleplayer(emptyPlan, config);\n        assertEquals(0, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithSingleRoundAndConfig() {\n        Battleplan singleRoundPlan = new Battleplan();\n        singleRoundPlan.addRound(1);\n        PlayerConfiguration config = new PlayerConfiguration();\n        Battleplayer player = new Battleplayer(singleRoundPlan, config);\n        assertEquals(1, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithMultipleRoundsAndConfig() {\n        Battleplan multipleRoundsPlan = new Battleplan();\n        multipleRoundsPlan.addRound(1);\n        multipleRoundsPlan.addRound(2);\n        multipleRoundsPlan.addRound(3);\n        PlayerConfiguration config = new PlayerConfiguration();\n        Battleplayer player = new Battleplayer(multipleRoundsPlan, config);\n        assertEquals(3, player.numberOfRounds());\n    }\n\n    @Test\n    void testNumberOfRoundsWithNoRoundsAndConfig() {\n        Battleplan noRoundsPlan = new Battleplan();\n        PlayerConfiguration config = new PlayerConfiguration();\n        Battleplayer player = new Battleplayer(noRoundsPlan, config);\n        assertEquals(0, player.numberOfRounds());\n    }\n}\n```\n",
        "applied_heuristics": "H2"
    }
]