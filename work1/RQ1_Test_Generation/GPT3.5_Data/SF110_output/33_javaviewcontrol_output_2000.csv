ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
chatcmpl-A5UHSblLOiVRQj5zBxuq0I4UCuhd4,/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/SimpleCharStream_0Test.java,5.668410539627075,stop,"// SimpleCharStream.java
/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.1 */
/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.pmdesigns.jvc.tools;

/**
 * An implementation of interface CharStream, where the stream is assumed to
 * contain only ASCII characters (without unicode processing).
 */
public class SimpleCharStream {

    /**
     * Whether parser is static.
     */
    public static final boolean staticFlag = false;

    int bufsize;

    int available;

    int tokenBegin;

    /**
     * Position in buffer.
     */
    public int bufpos = -1;

    protected int[] bufline;

    protected int[] bufcolumn;

    protected int column = 0;

    protected int line = 1;

    protected boolean prevCharIsCR = false;

    protected boolean prevCharIsLF = false;

    protected java.io.Reader inputStream;

    protected char[] buffer;

    protected int maxNextCharInd = 0;

    protected int inBuf = 0;

    protected int tabSize = 8;

    protected void setTabSize(int i) {
        tabSize = i;
    }

    protected int getTabSize(int i) {
        return tabSize;
    }

    protected void ExpandBuff(boolean wrapAround) {
        char[] newbuffer = new char[bufsize + 2048];
        int[] newbufline = new int[bufsize + 2048];
        int[] newbufcolumn = new int[bufsize + 2048];
        try {
            if (wrapAround) {
                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
                System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);
                buffer = newbuffer;
                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
                System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
                bufline = newbufline;
                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
                System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
                bufcolumn = newbufcolumn;
                maxNextCharInd = (bufpos += (bufsize - tokenBegin));
            } else {
                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
                buffer = newbuffer;
                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
                bufline = newbufline;
                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
                bufcolumn = newbufcolumn;
                maxNextCharInd = (bufpos -= tokenBegin);
            }
        } catch (Throwable t) {
            throw new Error(t.getMessage());
        }
        bufsize += 2048;
        available = bufsize;
        tokenBegin = 0;
    }

    protected void FillBuff() throws java.io.IOException {
        if (maxNextCharInd == available) {
            if (available == bufsize) {
                if (tokenBegin > 2048) {
                    bufpos = maxNextCharInd = 0;
                    available = tokenBegin;
                } else if (tokenBegin < 0)
                    bufpos = maxNextCharInd = 0;
                else
                    ExpandBuff(false);
            } else if (available > tokenBegin)
                available = bufsize;
            else if ((tokenBegin - available) < 2048)
                ExpandBuff(true);
            else
                available = tokenBegin;
        }
        int i;
        try {
            if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1) {
                inputStream.close();
                throw new java.io.IOException();
            } else
                maxNextCharInd += i;
            return;
        } catch (java.io.IOException e) {
            --bufpos;
            backup(0);
            if (tokenBegin == -1)
                tokenBegin = bufpos;
            throw e;
        }
    }

    /**
     * Start.
     */
    public char BeginToken() throws java.io.IOException {
        tokenBegin = -1;
        char c = readChar();
        tokenBegin = bufpos;
        return c;
    }

    protected void UpdateLineColumn(char c) {
        column++;
        if (prevCharIsLF) {
            prevCharIsLF = false;
            line += (column = 1);
        } else if (prevCharIsCR) {
            prevCharIsCR = false;
            if (c == '\n') {
                prevCharIsLF = true;
            } else
                line += (column = 1);
        }
        switch(c) {
            case '\r':
                prevCharIsCR = true;
                break;
            case '\n':
                prevCharIsLF = true;
                break;
            case '\t':
                column--;
                column += (tabSize - (column % tabSize));
                break;
            default:
                break;
        }
        bufline[bufpos] = line;
        bufcolumn[bufpos] = column;
    }

    /**
     * Read a character.
     */
    public char readChar() throws java.io.IOException {
        if (inBuf > 0) {
            --inBuf;
            if (++bufpos == bufsize)
                bufpos = 0;
            return buffer[bufpos];
        }
        if (++bufpos >= maxNextCharInd)
            FillBuff();
        char c = buffer[bufpos];
        UpdateLineColumn(c);
        return c;
    }

    /**
     * @deprecated
     * @see #getEndColumn
     */
    public int getColumn() {
        return bufcolumn[bufpos];
    }

    /**
     * @deprecated
     * @see #getEndLine
     */
    public int getLine() {
        return bufline[bufpos];
    }

    /**
     * Get token end column number.
     */
    public int getEndColumn() {
        return bufcolumn[bufpos];
    }

    /**
     * Get token end line number.
     */
    public int getEndLine() {
        return bufline[bufpos];
    }

    /**
     * Get token beginning column number.
     */
    public int getBeginColumn() {
        return bufcolumn[tokenBegin];
    }

    /**
     * Get token beginning line number.
     */
    public int getBeginLine() {
        return bufline[tokenBegin];
    }

    /**
     * Backup a number of characters.
     */
    public void backup(int amount) {
        inBuf += amount;
        if ((bufpos -= amount) < 0)
            bufpos += bufsize;
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {
        inputStream = dstream;
        line = startline;
        column = startcolumn - 1;
        available = bufsize = buffersize;
        buffer = new char[buffersize];
        bufline = new int[buffersize];
        bufcolumn = new int[buffersize];
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn) {
        this(dstream, startline, startcolumn, 4096);
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.Reader dstream) {
        this(dstream, 1, 1, 4096);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {
        inputStream = dstream;
        line = startline;
        column = startcolumn - 1;
        if (buffer == null || buffersize != buffer.length) {
            available = bufsize = buffersize;
            buffer = new char[buffersize];
            bufline = new int[buffersize];
            bufcolumn = new int[buffersize];
        }
        prevCharIsLF = prevCharIsCR = false;
        tokenBegin = inBuf = maxNextCharInd = 0;
        bufpos = -1;
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.Reader dstream, int startline, int startcolumn) {
        ReInit(dstream, startline, startcolumn, 4096);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.Reader dstream) {
        ReInit(dstream, 1, 1, 4096);
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {
        this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {
        this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {
        this(dstream, encoding, startline, startcolumn, 4096);
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn) {
        this(dstream, startline, startcolumn, 4096);
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {
        this(dstream, encoding, 1, 1, 4096);
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.InputStream dstream) {
        this(dstream, 1, 1, 4096);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {
        ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {
        ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {
        ReInit(dstream, encoding, 1, 1, 4096);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream dstream) {
        ReInit(dstream, 1, 1, 4096);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {
        ReInit(dstream, encoding, startline, startcolumn, 4096);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn) {
        ReInit(dstream, startline, startcolumn, 4096);
    }

    /**
     * Get token literal value.
     */
    public String GetImage() {
        if (bufpos >= tokenBegin)
            return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
        else
            return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);
    }

    /**
     * Get the suffix.
     */
    public char[] GetSuffix(int len) {
        char[] ret = new char[len];
        if ((bufpos + 1) >= len)
            System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
        else {
            System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);
            System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
        }
        return ret;
    }

    /**
     * Reset buffer when finished.
     */
    public void Done() {
        buffer = null;
        bufline = null;
        bufcolumn = null;
    }

    /**
     * Method to adjust line and column numbers for the start of a token.
     */
    public void adjustBeginLineColumn(int newLine, int newCol) {
        int start = tokenBegin;
        int len;
        if (bufpos >= tokenBegin) {
            len = bufpos - tokenBegin + inBuf + 1;
        } else {
            len = bufsize - tokenBegin + bufpos + 1 + inBuf;
        }
        int i = 0, j = 0, k = 0;
        int nextColDiff = 0, columnDiff = 0;
        while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize]) {
            bufline[j] = newLine;
            nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
            bufcolumn[j] = newCol + columnDiff;
            columnDiff = nextColDiff;
            i++;
        }
        if (i < len) {
            bufline[j] = newLine++;
            bufcolumn[j] = newCol + columnDiff;
            while (i++ < len) {
                if (bufline[j = start % bufsize] != bufline[++start % bufsize])
                    bufline[j] = newLine++;
                else
                    bufline[j] = newLine;
            }
        }
        line = bufline[j];
        column = bufcolumn[j];
    }
}
/* JavaCC - OriginalChecksum=d9128cf5d82a12eb06ed3b6fa19acc59 (do not edit this line) */
","// SimpleCharStream_0Test.java
/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.pmdesigns.jvc.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SimpleCharStream}.
* It contains ten unit test cases for the {@link SimpleCharStream#BeginToken()} method.
*/
class SimpleCharStream_0Test {","```java
    private SimpleCharStream createSimpleCharStream(String input) {
        return new SimpleCharStream(new java.io.StringReader(input));
    }

    @Test
    void testBeginToken_EmptyStream() throws java.io.IOException {
        SimpleCharStream stream = createSimpleCharStream("""");
        assertEquals((char) 0, stream.BeginToken());
    }

    @Test
    void testBeginToken_SingleChar() throws java.io.IOException {
        SimpleCharStream stream = createSimpleCharStream(""a"");
        assertEquals('a', stream.BeginToken());
    }

    @Test
    void testBeginToken_MultipleChars() throws java.io.IOException {
        SimpleCharStream stream = createSimpleCharStream(""abc"");
        assertEquals('a', stream.BeginToken());
    }

    @Test
    void testBeginToken_NewLine() throws java.io.IOException {
        SimpleCharStream stream = createSimpleCharStream(""a\nb"");
        assertEquals('a', stream.BeginToken());
    }

    @Test
    void testBeginToken_CarriageReturn() throws java.io.IOException {
        SimpleCharStream stream = createSimpleCharStream(""a\rb"");
        assertEquals('a', stream.BeginToken());
    }

    @Test
    void testBeginToken_Tab() throws java.io.IOException {
        SimpleCharStream stream = createSimpleCharStream(""a\tb"");
        assertEquals('a', stream.BeginToken());
    }

    @Test
    void testBeginToken_MixedCharacters() throws java.io.IOException {
        SimpleCharStream stream = createSimpleCharStream(""a\n\tb"");
        assertEquals('a', stream.BeginToken());
    }

    @Test
    void testBeginToken_UnicodeCharacter() throws java.io.IOException {
        SimpleCharStream stream = createSimpleCharStream(""€"");
        assertEquals('€', stream.BeginToken());
    }

    @Test
    void testBeginToken_SpecialCharacters() throws java.io.IOException {
        SimpleCharStream stream = createSimpleCharStream(""!@#$%^&*()"");
        assertEquals('!', stream.BeginToken());
    }
}
```"
chatcmpl-A5UIViFIW1ozLnWudA20eIhaKiNj5,/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/SimpleCharStream_1Test.java,5.756120681762695,stop,"// SimpleCharStream.java
/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.1 */
/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.pmdesigns.jvc.tools;

/**
 * An implementation of interface CharStream, where the stream is assumed to
 * contain only ASCII characters (without unicode processing).
 */
public class SimpleCharStream {

    /**
     * Whether parser is static.
     */
    public static final boolean staticFlag = false;

    int bufsize;

    int available;

    int tokenBegin;

    /**
     * Position in buffer.
     */
    public int bufpos = -1;

    protected int[] bufline;

    protected int[] bufcolumn;

    protected int column = 0;

    protected int line = 1;

    protected boolean prevCharIsCR = false;

    protected boolean prevCharIsLF = false;

    protected java.io.Reader inputStream;

    protected char[] buffer;

    protected int maxNextCharInd = 0;

    protected int inBuf = 0;

    protected int tabSize = 8;

    protected void setTabSize(int i) {
        tabSize = i;
    }

    protected int getTabSize(int i) {
        return tabSize;
    }

    protected void ExpandBuff(boolean wrapAround) {
        char[] newbuffer = new char[bufsize + 2048];
        int[] newbufline = new int[bufsize + 2048];
        int[] newbufcolumn = new int[bufsize + 2048];
        try {
            if (wrapAround) {
                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
                System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);
                buffer = newbuffer;
                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
                System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
                bufline = newbufline;
                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
                System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
                bufcolumn = newbufcolumn;
                maxNextCharInd = (bufpos += (bufsize - tokenBegin));
            } else {
                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
                buffer = newbuffer;
                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
                bufline = newbufline;
                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
                bufcolumn = newbufcolumn;
                maxNextCharInd = (bufpos -= tokenBegin);
            }
        } catch (Throwable t) {
            throw new Error(t.getMessage());
        }
        bufsize += 2048;
        available = bufsize;
        tokenBegin = 0;
    }

    protected void FillBuff() throws java.io.IOException {
        if (maxNextCharInd == available) {
            if (available == bufsize) {
                if (tokenBegin > 2048) {
                    bufpos = maxNextCharInd = 0;
                    available = tokenBegin;
                } else if (tokenBegin < 0)
                    bufpos = maxNextCharInd = 0;
                else
                    ExpandBuff(false);
            } else if (available > tokenBegin)
                available = bufsize;
            else if ((tokenBegin - available) < 2048)
                ExpandBuff(true);
            else
                available = tokenBegin;
        }
        int i;
        try {
            if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1) {
                inputStream.close();
                throw new java.io.IOException();
            } else
                maxNextCharInd += i;
            return;
        } catch (java.io.IOException e) {
            --bufpos;
            backup(0);
            if (tokenBegin == -1)
                tokenBegin = bufpos;
            throw e;
        }
    }

    /**
     * Start.
     */
    public char BeginToken() throws java.io.IOException {
        tokenBegin = -1;
        char c = readChar();
        tokenBegin = bufpos;
        return c;
    }

    protected void UpdateLineColumn(char c) {
        column++;
        if (prevCharIsLF) {
            prevCharIsLF = false;
            line += (column = 1);
        } else if (prevCharIsCR) {
            prevCharIsCR = false;
            if (c == '\n') {
                prevCharIsLF = true;
            } else
                line += (column = 1);
        }
        switch(c) {
            case '\r':
                prevCharIsCR = true;
                break;
            case '\n':
                prevCharIsLF = true;
                break;
            case '\t':
                column--;
                column += (tabSize - (column % tabSize));
                break;
            default:
                break;
        }
        bufline[bufpos] = line;
        bufcolumn[bufpos] = column;
    }

    /**
     * Read a character.
     */
    public char readChar() throws java.io.IOException {
        if (inBuf > 0) {
            --inBuf;
            if (++bufpos == bufsize)
                bufpos = 0;
            return buffer[bufpos];
        }
        if (++bufpos >= maxNextCharInd)
            FillBuff();
        char c = buffer[bufpos];
        UpdateLineColumn(c);
        return c;
    }

    /**
     * @deprecated
     * @see #getEndColumn
     */
    public int getColumn() {
        return bufcolumn[bufpos];
    }

    /**
     * @deprecated
     * @see #getEndLine
     */
    public int getLine() {
        return bufline[bufpos];
    }

    /**
     * Get token end column number.
     */
    public int getEndColumn() {
        return bufcolumn[bufpos];
    }

    /**
     * Get token end line number.
     */
    public int getEndLine() {
        return bufline[bufpos];
    }

    /**
     * Get token beginning column number.
     */
    public int getBeginColumn() {
        return bufcolumn[tokenBegin];
    }

    /**
     * Get token beginning line number.
     */
    public int getBeginLine() {
        return bufline[tokenBegin];
    }

    /**
     * Backup a number of characters.
     */
    public void backup(int amount) {
        inBuf += amount;
        if ((bufpos -= amount) < 0)
            bufpos += bufsize;
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {
        inputStream = dstream;
        line = startline;
        column = startcolumn - 1;
        available = bufsize = buffersize;
        buffer = new char[buffersize];
        bufline = new int[buffersize];
        bufcolumn = new int[buffersize];
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn) {
        this(dstream, startline, startcolumn, 4096);
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.Reader dstream) {
        this(dstream, 1, 1, 4096);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {
        inputStream = dstream;
        line = startline;
        column = startcolumn - 1;
        if (buffer == null || buffersize != buffer.length) {
            available = bufsize = buffersize;
            buffer = new char[buffersize];
            bufline = new int[buffersize];
            bufcolumn = new int[buffersize];
        }
        prevCharIsLF = prevCharIsCR = false;
        tokenBegin = inBuf = maxNextCharInd = 0;
        bufpos = -1;
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.Reader dstream, int startline, int startcolumn) {
        ReInit(dstream, startline, startcolumn, 4096);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.Reader dstream) {
        ReInit(dstream, 1, 1, 4096);
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {
        this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {
        this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {
        this(dstream, encoding, startline, startcolumn, 4096);
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn) {
        this(dstream, startline, startcolumn, 4096);
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {
        this(dstream, encoding, 1, 1, 4096);
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.InputStream dstream) {
        this(dstream, 1, 1, 4096);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {
        ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {
        ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {
        ReInit(dstream, encoding, 1, 1, 4096);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream dstream) {
        ReInit(dstream, 1, 1, 4096);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {
        ReInit(dstream, encoding, startline, startcolumn, 4096);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn) {
        ReInit(dstream, startline, startcolumn, 4096);
    }

    /**
     * Get token literal value.
     */
    public String GetImage() {
        if (bufpos >= tokenBegin)
            return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
        else
            return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);
    }

    /**
     * Get the suffix.
     */
    public char[] GetSuffix(int len) {
        char[] ret = new char[len];
        if ((bufpos + 1) >= len)
            System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
        else {
            System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);
            System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
        }
        return ret;
    }

    /**
     * Reset buffer when finished.
     */
    public void Done() {
        buffer = null;
        bufline = null;
        bufcolumn = null;
    }

    /**
     * Method to adjust line and column numbers for the start of a token.
     */
    public void adjustBeginLineColumn(int newLine, int newCol) {
        int start = tokenBegin;
        int len;
        if (bufpos >= tokenBegin) {
            len = bufpos - tokenBegin + inBuf + 1;
        } else {
            len = bufsize - tokenBegin + bufpos + 1 + inBuf;
        }
        int i = 0, j = 0, k = 0;
        int nextColDiff = 0, columnDiff = 0;
        while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize]) {
            bufline[j] = newLine;
            nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
            bufcolumn[j] = newCol + columnDiff;
            columnDiff = nextColDiff;
            i++;
        }
        if (i < len) {
            bufline[j] = newLine++;
            bufcolumn[j] = newCol + columnDiff;
            while (i++ < len) {
                if (bufline[j = start % bufsize] != bufline[++start % bufsize])
                    bufline[j] = newLine++;
                else
                    bufline[j] = newLine;
            }
        }
        line = bufline[j];
        column = bufcolumn[j];
    }
}
/* JavaCC - OriginalChecksum=d9128cf5d82a12eb06ed3b6fa19acc59 (do not edit this line) */
","// SimpleCharStream_1Test.java
/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.pmdesigns.jvc.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SimpleCharStream}.
* It contains ten unit test cases for the {@link SimpleCharStream#readChar()} method.
*/
class SimpleCharStream_1Test {","```java
    private SimpleCharStream createSimpleCharStream(String input) {
        return new SimpleCharStream(new java.io.StringReader(input));
    }

    @Test
    void testReadChar_EmptyStream() throws java.io.IOException {
        SimpleCharStream stream = createSimpleCharStream("""");
        assertEquals((char) 0, stream.readChar());
    }

    @Test
    void testReadChar_SingleCharacter() throws java.io.IOException {
        SimpleCharStream stream = createSimpleCharStream(""a"");
        assertEquals('a', stream.readChar());
    }

    @Test
    void testReadChar_MultipleCharacters() throws java.io.IOException {
        SimpleCharStream stream = createSimpleCharStream(""abc"");
        assertEquals('a', stream.readChar());
        assertEquals('b', stream.readChar());
        assertEquals('c', stream.readChar());
    }

    @Test
    void testReadChar_NewLine() throws java.io.IOException {
        SimpleCharStream stream = createSimpleCharStream(""a\nb"");
        assertEquals('a', stream.readChar());
        assertEquals('\n', stream.readChar());
        assertEquals('b', stream.readChar());
    }

    @Test
    void testReadChar_CarriageReturn() throws java.io.IOException {
        SimpleCharStream stream = createSimpleCharStream(""a\rb"");
        assertEquals('a', stream.readChar());
        assertEquals('\r', stream.readChar());
        assertEquals('b', stream.readChar());
    }

    @Test
    void testReadChar_Tab() throws java.io.IOException {
        SimpleCharStream stream = createSimpleCharStream(""a\tb"");
        assertEquals('a', stream.readChar());
        assertEquals('\t', stream.readChar());
        assertEquals('b', stream.readChar());
    }

    @Test
    void testReadChar_Backup() throws java.io.IOException {
        SimpleCharStream stream = createSimpleCharStream(""abc"");
        assertEquals('a', stream.readChar());
        stream.backup(1);
        assertEquals('a', stream.readChar());
        assertEquals('b', stream.readChar());
        assertEquals('c', stream.readChar());
    }

    @Test
    void testReadChar_AdjustBeginLineColumn() throws java.io.IOException {
        SimpleCharStream stream = createSimpleCharStream(""a\nb"");
        stream.readChar();
        stream.adjustBeginLineColumn(2, 1);
        assertEquals(2, stream.getLine());
        assertEquals(1, stream.getColumn());
    }

    @Test
    void testReadChar_GetImage() throws java.io.IOException {
        SimpleCharStream stream = createSimpleCharStream(""abc"");
        stream.readChar();
        stream.readChar();
        stream.readChar();
        assertEquals(""abc"", stream.GetImage());
    }
```
```"
chatcmpl-A5UJYPpiTJXp6NFUbqJ64vPPdOKxs,/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/SimpleCharStream_2Test.java,8.81870722770691,stop,"// SimpleCharStream.java
/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.1 */
/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.pmdesigns.jvc.tools;

/**
 * An implementation of interface CharStream, where the stream is assumed to
 * contain only ASCII characters (without unicode processing).
 */
public class SimpleCharStream {

    /**
     * Whether parser is static.
     */
    public static final boolean staticFlag = false;

    int bufsize;

    int available;

    int tokenBegin;

    /**
     * Position in buffer.
     */
    public int bufpos = -1;

    protected int[] bufline;

    protected int[] bufcolumn;

    protected int column = 0;

    protected int line = 1;

    protected boolean prevCharIsCR = false;

    protected boolean prevCharIsLF = false;

    protected java.io.Reader inputStream;

    protected char[] buffer;

    protected int maxNextCharInd = 0;

    protected int inBuf = 0;

    protected int tabSize = 8;

    protected void setTabSize(int i) {
        tabSize = i;
    }

    protected int getTabSize(int i) {
        return tabSize;
    }

    protected void ExpandBuff(boolean wrapAround) {
        char[] newbuffer = new char[bufsize + 2048];
        int[] newbufline = new int[bufsize + 2048];
        int[] newbufcolumn = new int[bufsize + 2048];
        try {
            if (wrapAround) {
                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
                System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);
                buffer = newbuffer;
                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
                System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
                bufline = newbufline;
                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
                System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
                bufcolumn = newbufcolumn;
                maxNextCharInd = (bufpos += (bufsize - tokenBegin));
            } else {
                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
                buffer = newbuffer;
                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
                bufline = newbufline;
                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
                bufcolumn = newbufcolumn;
                maxNextCharInd = (bufpos -= tokenBegin);
            }
        } catch (Throwable t) {
            throw new Error(t.getMessage());
        }
        bufsize += 2048;
        available = bufsize;
        tokenBegin = 0;
    }

    protected void FillBuff() throws java.io.IOException {
        if (maxNextCharInd == available) {
            if (available == bufsize) {
                if (tokenBegin > 2048) {
                    bufpos = maxNextCharInd = 0;
                    available = tokenBegin;
                } else if (tokenBegin < 0)
                    bufpos = maxNextCharInd = 0;
                else
                    ExpandBuff(false);
            } else if (available > tokenBegin)
                available = bufsize;
            else if ((tokenBegin - available) < 2048)
                ExpandBuff(true);
            else
                available = tokenBegin;
        }
        int i;
        try {
            if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1) {
                inputStream.close();
                throw new java.io.IOException();
            } else
                maxNextCharInd += i;
            return;
        } catch (java.io.IOException e) {
            --bufpos;
            backup(0);
            if (tokenBegin == -1)
                tokenBegin = bufpos;
            throw e;
        }
    }

    /**
     * Start.
     */
    public char BeginToken() throws java.io.IOException {
        tokenBegin = -1;
        char c = readChar();
        tokenBegin = bufpos;
        return c;
    }

    protected void UpdateLineColumn(char c) {
        column++;
        if (prevCharIsLF) {
            prevCharIsLF = false;
            line += (column = 1);
        } else if (prevCharIsCR) {
            prevCharIsCR = false;
            if (c == '\n') {
                prevCharIsLF = true;
            } else
                line += (column = 1);
        }
        switch(c) {
            case '\r':
                prevCharIsCR = true;
                break;
            case '\n':
                prevCharIsLF = true;
                break;
            case '\t':
                column--;
                column += (tabSize - (column % tabSize));
                break;
            default:
                break;
        }
        bufline[bufpos] = line;
        bufcolumn[bufpos] = column;
    }

    /**
     * Read a character.
     */
    public char readChar() throws java.io.IOException {
        if (inBuf > 0) {
            --inBuf;
            if (++bufpos == bufsize)
                bufpos = 0;
            return buffer[bufpos];
        }
        if (++bufpos >= maxNextCharInd)
            FillBuff();
        char c = buffer[bufpos];
        UpdateLineColumn(c);
        return c;
    }

    /**
     * @deprecated
     * @see #getEndColumn
     */
    public int getColumn() {
        return bufcolumn[bufpos];
    }

    /**
     * @deprecated
     * @see #getEndLine
     */
    public int getLine() {
        return bufline[bufpos];
    }

    /**
     * Get token end column number.
     */
    public int getEndColumn() {
        return bufcolumn[bufpos];
    }

    /**
     * Get token end line number.
     */
    public int getEndLine() {
        return bufline[bufpos];
    }

    /**
     * Get token beginning column number.
     */
    public int getBeginColumn() {
        return bufcolumn[tokenBegin];
    }

    /**
     * Get token beginning line number.
     */
    public int getBeginLine() {
        return bufline[tokenBegin];
    }

    /**
     * Backup a number of characters.
     */
    public void backup(int amount) {
        inBuf += amount;
        if ((bufpos -= amount) < 0)
            bufpos += bufsize;
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {
        inputStream = dstream;
        line = startline;
        column = startcolumn - 1;
        available = bufsize = buffersize;
        buffer = new char[buffersize];
        bufline = new int[buffersize];
        bufcolumn = new int[buffersize];
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn) {
        this(dstream, startline, startcolumn, 4096);
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.Reader dstream) {
        this(dstream, 1, 1, 4096);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {
        inputStream = dstream;
        line = startline;
        column = startcolumn - 1;
        if (buffer == null || buffersize != buffer.length) {
            available = bufsize = buffersize;
            buffer = new char[buffersize];
            bufline = new int[buffersize];
            bufcolumn = new int[buffersize];
        }
        prevCharIsLF = prevCharIsCR = false;
        tokenBegin = inBuf = maxNextCharInd = 0;
        bufpos = -1;
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.Reader dstream, int startline, int startcolumn) {
        ReInit(dstream, startline, startcolumn, 4096);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.Reader dstream) {
        ReInit(dstream, 1, 1, 4096);
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {
        this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {
        this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {
        this(dstream, encoding, startline, startcolumn, 4096);
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn) {
        this(dstream, startline, startcolumn, 4096);
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {
        this(dstream, encoding, 1, 1, 4096);
    }

    /**
     * Constructor.
     */
    public SimpleCharStream(java.io.InputStream dstream) {
        this(dstream, 1, 1, 4096);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {
        ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {
        ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {
        ReInit(dstream, encoding, 1, 1, 4096);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream dstream) {
        ReInit(dstream, 1, 1, 4096);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {
        ReInit(dstream, encoding, startline, startcolumn, 4096);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn) {
        ReInit(dstream, startline, startcolumn, 4096);
    }

    /**
     * Get token literal value.
     */
    public String GetImage() {
        if (bufpos >= tokenBegin)
            return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
        else
            return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);
    }

    /**
     * Get the suffix.
     */
    public char[] GetSuffix(int len) {
        char[] ret = new char[len];
        if ((bufpos + 1) >= len)
            System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
        else {
            System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);
            System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
        }
        return ret;
    }

    /**
     * Reset buffer when finished.
     */
    public void Done() {
        buffer = null;
        bufline = null;
        bufcolumn = null;
    }

    /**
     * Method to adjust line and column numbers for the start of a token.
     */
    public void adjustBeginLineColumn(int newLine, int newCol) {
        int start = tokenBegin;
        int len;
        if (bufpos >= tokenBegin) {
            len = bufpos - tokenBegin + inBuf + 1;
        } else {
            len = bufsize - tokenBegin + bufpos + 1 + inBuf;
        }
        int i = 0, j = 0, k = 0;
        int nextColDiff = 0, columnDiff = 0;
        while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize]) {
            bufline[j] = newLine;
            nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
            bufcolumn[j] = newCol + columnDiff;
            columnDiff = nextColDiff;
            i++;
        }
        if (i < len) {
            bufline[j] = newLine++;
            bufcolumn[j] = newCol + columnDiff;
            while (i++ < len) {
                if (bufline[j = start % bufsize] != bufline[++start % bufsize])
                    bufline[j] = newLine++;
                else
                    bufline[j] = newLine;
            }
        }
        line = bufline[j];
        column = bufcolumn[j];
    }
}
/* JavaCC - OriginalChecksum=d9128cf5d82a12eb06ed3b6fa19acc59 (do not edit this line) */
","// SimpleCharStream_2Test.java
/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.pmdesigns.jvc.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SimpleCharStream}.
* It contains ten unit test cases for the {@link SimpleCharStream#GetImage()} method.
*/
class SimpleCharStream_2Test {","```java
    @Test
    void testGetImage_emptyBuffer() {
        SimpleCharStream stream = new SimpleCharStream(new java.io.StringReader(""""), 1, 1);
        assertEquals("""", stream.GetImage());
    }

    @Test
    void testGetImage_singleChar() {
        SimpleCharStream stream = new SimpleCharStream(new java.io.StringReader(""a""), 1, 1);
        assertEquals(""a"", stream.GetImage());
    }

    @Test
    void testGetImage_multipleChars() {
        SimpleCharStream stream = new SimpleCharStream(new java.io.StringReader(""Hello""), 1, 1);
        assertEquals(""Hello"", stream.GetImage());
    }

    @Test
    void testGetImage_wrapAround() {
        SimpleCharStream stream = new SimpleCharStream(new java.io.StringReader(""World""), 1, 1, 5);
        stream.bufpos = 3;
        stream.tokenBegin = 3;
        assertEquals(""rldWo"", stream.GetImage());
    }

    @Test
    void testGetImage_wrapAroundWithBackup() {
        SimpleCharStream stream = new SimpleCharStream(new java.io.StringReader(""JavaCC""), 1, 1, 6);
        stream.bufpos = 2;
        stream.tokenBegin = 2;
        stream.backup(2);
        assertEquals(""vaCCJa"", stream.GetImage());
    }

    @Test
    void testGetImage_wrapAroundWithBackupOverflow() {
        SimpleCharStream stream = new SimpleCharStream(new java.io.StringReader(""JavaCC""), 1, 1, 6);
        stream.bufpos = 2;
        stream.tokenBegin = 2;
        stream.backup(4);
        assertEquals(""CCJava"", stream.GetImage());
    }

    @Test
    void testGetImage_wrapAroundWithBackupWrapAround() {
        SimpleCharStream stream = new SimpleCharStream(new java.io.StringReader(""JavaCC""), 1, 1, 6);
        stream.bufpos = 2;
        stream.tokenBegin = 2;
        stream.backup(5);
        assertEquals(""aCCJav"", stream.GetImage());
    }

    @Test
    void testGetImage_wrapAroundWithBackupWrapAroundOverflow() {
        SimpleCharStream stream = new SimpleCharStream(new java.io.StringReader(""JavaCC""), 1, 1, 6);
        stream.bufpos = 2;
        stream.tokenBegin = 2;
        stream.backup(6);
        assertEquals(""CCJava"", stream.GetImage());
    }

    @Test
    void testGetImage_wrapAroundWithBackupWrapAroundOverflow2() {
        SimpleCharStream stream = new SimpleCharStream(new java.io.StringReader(""JavaCC""), 1, 1, 6);
        stream.bufpos = 2;
        stream.tokenBegin = 2;
        stream.backup(7);
        assertEquals(""CCJava"", stream.GetImage());
    }
}
```"
chatcmpl-A5UKbtYkuusy75wOid9CIDBx0GdRU,/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/Base64Coder_0Test.java,7.520505905151367,stop,"// Base64Coder.java
package com.pmdesigns.jvc.tools;

/**
 * A Base64 Encoder/Decoder.
 *
 * <p>
 * This class is used to encode and decode data in Base64 format as described in RFC 1521.
 *
 * <p>
 * This is ""Open Source"" software and released under the <a href=""http://www.gnu.org/licenses/lgpl.html"">GNU/LGPL</a> license.<br>
 * It is provided ""as is"" without warranty of any kind.<br>
 * Copyright 2003: Christian d'Heureuse, Inventec Informatik AG, Switzerland.<br>
 * Home page: <a href=""http://www.source-code.biz"">www.source-code.biz</a><br>
 *
 * <p>
 * Version history:<br>
 * 2003-07-22 Christian d'Heureuse (chdh): Module created.<br>
 * 2005-08-11 chdh: Lincense changed from GPL to LGPL.<br>
 * 2006-11-21 chdh:<br>
 *  &nbsp; Method encode(String) renamed to encodeString(String).<br>
 *  &nbsp; Method decode(String) renamed to decodeString(String).<br>
 *  &nbsp; New method encode(byte[],int) added.<br>
 *  &nbsp; New method decode(String) added.<br>
 */
public class Base64Coder {

    // Mapping table from 6-bit nibbles to Base64 characters.
    private static char[] map1 = new char[64];

    static {
        int i = 0;
        for (char c = 'A'; c <= 'Z'; c++) map1[i++] = c;
        for (char c = 'a'; c <= 'z'; c++) map1[i++] = c;
        for (char c = '0'; c <= '9'; c++) map1[i++] = c;
        map1[i++] = '+';
        map1[i++] = '/';
    }

    // Mapping table from Base64 characters to 6-bit nibbles.
    private static byte[] map2 = new byte[128];

    static {
        for (int i = 0; i < map2.length; i++) map2[i] = -1;
        for (int i = 0; i < 64; i++) map2[map1[i]] = (byte) i;
    }

    /**
     * Encodes a string into Base64 format.
     * No blanks or line breaks are inserted.
     * @param s  a String to be encoded.
     * @return   A String with the Base64 encoded data.
     */
    public static String encodeString(String s) {
        return new String(encode(s.getBytes()));
    }

    /**
     * Encodes a byte array into Base64 format.
     * No blanks or line breaks are inserted.
     * @param in  an array containing the data bytes to be encoded.
     * @return    A character array with the Base64 encoded data.
     */
    public static char[] encode(byte[] in) {
        return encode(in, in.length);
    }

    /**
     * Encodes a byte array into Base64 format.
     * No blanks or line breaks are inserted.
     * @param in   an array containing the data bytes to be encoded.
     * @param iLen number of bytes to process in <code>in</code>.
     * @return     A character array with the Base64 encoded data.
     */
    public static char[] encode(byte[] in, int iLen) {
        // output length without padding
        int oDataLen = (iLen * 4 + 2) / 3;
        // output length including padding
        int oLen = ((iLen + 2) / 3) * 4;
        char[] out = new char[oLen];
        int ip = 0;
        int op = 0;
        while (ip < iLen) {
            int i0 = in[ip++] & 0xff;
            int i1 = ip < iLen ? in[ip++] & 0xff : 0;
            int i2 = ip < iLen ? in[ip++] & 0xff : 0;
            int o0 = i0 >>> 2;
            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);
            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);
            int o3 = i2 & 0x3F;
            out[op++] = map1[o0];
            out[op++] = map1[o1];
            out[op] = op < oDataLen ? map1[o2] : '=';
            op++;
            out[op] = op < oDataLen ? map1[o3] : '=';
            op++;
        }
        return out;
    }

    /**
     * Decodes a string from Base64 format.
     * @param s  a Base64 String to be decoded.
     * @return   A String containing the decoded data.
     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.
     */
    public static String decodeString(String s) {
        return new String(decode(s));
    }

    /**
     * Decodes a byte array from Base64 format.
     * @param s  a Base64 String to be decoded.
     * @return   An array containing the decoded data bytes.
     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.
     */
    public static byte[] decode(String s) {
        return decode(s.toCharArray());
    }

    /**
     * Decodes a byte array from Base64 format.
     * No blanks or line breaks are allowed within the Base64 encoded data.
     * @param in  a character array containing the Base64 encoded data.
     * @return    An array containing the decoded data bytes.
     * @throws    IllegalArgumentException if the input is not valid Base64 encoded data.
     */
    public static byte[] decode(char[] in) {
        int iLen = in.length;
        if (iLen % 4 != 0)
            throw new IllegalArgumentException(""Length of Base64 encoded input string is not a multiple of 4."");
        while (iLen > 0 && in[iLen - 1] == '=') iLen--;
        int oLen = (iLen * 3) / 4;
        byte[] out = new byte[oLen];
        int ip = 0;
        int op = 0;
        while (ip < iLen) {
            int i0 = in[ip++];
            int i1 = in[ip++];
            int i2 = ip < iLen ? in[ip++] : 'A';
            int i3 = ip < iLen ? in[ip++] : 'A';
            if (i0 > 127 || i1 > 127 || i2 > 127 || i3 > 127)
                throw new IllegalArgumentException(""Illegal character in Base64 encoded data."");
            int b0 = map2[i0];
            int b1 = map2[i1];
            int b2 = map2[i2];
            int b3 = map2[i3];
            if (b0 < 0 || b1 < 0 || b2 < 0 || b3 < 0)
                throw new IllegalArgumentException(""Illegal character in Base64 encoded data."");
            int o0 = (b0 << 2) | (b1 >>> 4);
            int o1 = ((b1 & 0xf) << 4) | (b2 >>> 2);
            int o2 = ((b2 & 3) << 6) | b3;
            out[op++] = (byte) o0;
            if (op < oLen)
                out[op++] = (byte) o1;
            if (op < oLen)
                out[op++] = (byte) o2;
        }
        return out;
    }

    // Dummy constructor.
    private Base64Coder() {
    }
}
// end class Base64Coder
","// Base64Coder_0Test.java
package com.pmdesigns.jvc.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Base64Coder}.
* It contains ten unit test cases for the {@link Base64Coder#encodeString(String)} method.
*/
class Base64Coder_0Test {","```java
class Base64Coder_0Test {

    @Test
    void testEncodeString() {
        assertEquals(""SGVsbG8gV29ybGQ="", Base64Coder.encodeString(""Hello World""));
        assertEquals(""U29tZSBtZXNzYWdlIGJhc2U2NCBlbmNvZGluZw=="", Base64Coder.encodeString(""Some message base64 encoding""));
        assertEquals(""VGhpcyBpcyBhIGJhc2U2NCBlbmNvZGluZw=="", Base64Coder.encodeString(""This is a base64 encoding""));
        assertEquals(""QmFzZTY0IGVuY29kaW5nIGlzIGJpbmFyeQ=="", Base64Coder.encodeString(""Base64 encoding is binary""));
        assertEquals(""U29tZSBtZXNzYWdlIGJhc2U2NCBlbmNvZGluZyBpcyBiaW5hcnk="", Base64Coder.encodeString(""Some message base64 encoding is binary""));
        assertEquals(""VGhpcyBpcyBhIGJhc2U2NCBlbmNvZGluZyBpcyBiaW5hcnk="", Base64Coder.encodeString(""This is a base64 encoding is binary""));
        assertEquals(""QmFzZTY0IGVuY29kaW5nIGlzIGJpbmFyeSBhbmQgaXMgYmluYXJ5"", Base64Coder.encodeString(""Base64 encoding is binary and is binary""));
        assertEquals(""U29tZSBtZXNzYWdlIGJhc2U2NCBlbmNvZGluZyBpcyBiaW5hcnkgYW5kIGlzIGJpbmFyeQ=="", Base64Coder.encodeString(""Some message base64 encoding is binary and is binary""));
        assertEquals(""VGhpcyBpcyBhIGJhc2U2NCBlbmNvZGluZyBpcyBiaW5hcnkgYW5kIGlzIGJpbmFyeQ=="", Base64Coder.encodeString(""This is a base64 encoding is binary and is binary""));
        assertEquals(""QmFzZTY0IGVuY29kaW5nIGlzIGJpbmFyeSBhbmQgaXMgYmluYXJ5IGFuZCBpcyBiaW5hcnk="", Base64Coder.encodeString(""Base64 encoding is binary and is binary and is binary""));
    }
}
```
"
chatcmpl-A5ULeIdqWHQsVcXOuW7j4hCFmy48z,/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/Base64Coder_1Test.java,8.395403623580933,stop,"// Base64Coder.java
package com.pmdesigns.jvc.tools;

/**
 * A Base64 Encoder/Decoder.
 *
 * <p>
 * This class is used to encode and decode data in Base64 format as described in RFC 1521.
 *
 * <p>
 * This is ""Open Source"" software and released under the <a href=""http://www.gnu.org/licenses/lgpl.html"">GNU/LGPL</a> license.<br>
 * It is provided ""as is"" without warranty of any kind.<br>
 * Copyright 2003: Christian d'Heureuse, Inventec Informatik AG, Switzerland.<br>
 * Home page: <a href=""http://www.source-code.biz"">www.source-code.biz</a><br>
 *
 * <p>
 * Version history:<br>
 * 2003-07-22 Christian d'Heureuse (chdh): Module created.<br>
 * 2005-08-11 chdh: Lincense changed from GPL to LGPL.<br>
 * 2006-11-21 chdh:<br>
 *  &nbsp; Method encode(String) renamed to encodeString(String).<br>
 *  &nbsp; Method decode(String) renamed to decodeString(String).<br>
 *  &nbsp; New method encode(byte[],int) added.<br>
 *  &nbsp; New method decode(String) added.<br>
 */
public class Base64Coder {

    // Mapping table from 6-bit nibbles to Base64 characters.
    private static char[] map1 = new char[64];

    static {
        int i = 0;
        for (char c = 'A'; c <= 'Z'; c++) map1[i++] = c;
        for (char c = 'a'; c <= 'z'; c++) map1[i++] = c;
        for (char c = '0'; c <= '9'; c++) map1[i++] = c;
        map1[i++] = '+';
        map1[i++] = '/';
    }

    // Mapping table from Base64 characters to 6-bit nibbles.
    private static byte[] map2 = new byte[128];

    static {
        for (int i = 0; i < map2.length; i++) map2[i] = -1;
        for (int i = 0; i < 64; i++) map2[map1[i]] = (byte) i;
    }

    /**
     * Encodes a string into Base64 format.
     * No blanks or line breaks are inserted.
     * @param s  a String to be encoded.
     * @return   A String with the Base64 encoded data.
     */
    public static String encodeString(String s) {
        return new String(encode(s.getBytes()));
    }

    /**
     * Encodes a byte array into Base64 format.
     * No blanks or line breaks are inserted.
     * @param in  an array containing the data bytes to be encoded.
     * @return    A character array with the Base64 encoded data.
     */
    public static char[] encode(byte[] in) {
        return encode(in, in.length);
    }

    /**
     * Encodes a byte array into Base64 format.
     * No blanks or line breaks are inserted.
     * @param in   an array containing the data bytes to be encoded.
     * @param iLen number of bytes to process in <code>in</code>.
     * @return     A character array with the Base64 encoded data.
     */
    public static char[] encode(byte[] in, int iLen) {
        // output length without padding
        int oDataLen = (iLen * 4 + 2) / 3;
        // output length including padding
        int oLen = ((iLen + 2) / 3) * 4;
        char[] out = new char[oLen];
        int ip = 0;
        int op = 0;
        while (ip < iLen) {
            int i0 = in[ip++] & 0xff;
            int i1 = ip < iLen ? in[ip++] & 0xff : 0;
            int i2 = ip < iLen ? in[ip++] & 0xff : 0;
            int o0 = i0 >>> 2;
            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);
            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);
            int o3 = i2 & 0x3F;
            out[op++] = map1[o0];
            out[op++] = map1[o1];
            out[op] = op < oDataLen ? map1[o2] : '=';
            op++;
            out[op] = op < oDataLen ? map1[o3] : '=';
            op++;
        }
        return out;
    }

    /**
     * Decodes a string from Base64 format.
     * @param s  a Base64 String to be decoded.
     * @return   A String containing the decoded data.
     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.
     */
    public static String decodeString(String s) {
        return new String(decode(s));
    }

    /**
     * Decodes a byte array from Base64 format.
     * @param s  a Base64 String to be decoded.
     * @return   An array containing the decoded data bytes.
     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.
     */
    public static byte[] decode(String s) {
        return decode(s.toCharArray());
    }

    /**
     * Decodes a byte array from Base64 format.
     * No blanks or line breaks are allowed within the Base64 encoded data.
     * @param in  a character array containing the Base64 encoded data.
     * @return    An array containing the decoded data bytes.
     * @throws    IllegalArgumentException if the input is not valid Base64 encoded data.
     */
    public static byte[] decode(char[] in) {
        int iLen = in.length;
        if (iLen % 4 != 0)
            throw new IllegalArgumentException(""Length of Base64 encoded input string is not a multiple of 4."");
        while (iLen > 0 && in[iLen - 1] == '=') iLen--;
        int oLen = (iLen * 3) / 4;
        byte[] out = new byte[oLen];
        int ip = 0;
        int op = 0;
        while (ip < iLen) {
            int i0 = in[ip++];
            int i1 = in[ip++];
            int i2 = ip < iLen ? in[ip++] : 'A';
            int i3 = ip < iLen ? in[ip++] : 'A';
            if (i0 > 127 || i1 > 127 || i2 > 127 || i3 > 127)
                throw new IllegalArgumentException(""Illegal character in Base64 encoded data."");
            int b0 = map2[i0];
            int b1 = map2[i1];
            int b2 = map2[i2];
            int b3 = map2[i3];
            if (b0 < 0 || b1 < 0 || b2 < 0 || b3 < 0)
                throw new IllegalArgumentException(""Illegal character in Base64 encoded data."");
            int o0 = (b0 << 2) | (b1 >>> 4);
            int o1 = ((b1 & 0xf) << 4) | (b2 >>> 2);
            int o2 = ((b2 & 3) << 6) | b3;
            out[op++] = (byte) o0;
            if (op < oLen)
                out[op++] = (byte) o1;
            if (op < oLen)
                out[op++] = (byte) o2;
        }
        return out;
    }

    // Dummy constructor.
    private Base64Coder() {
    }
}
// end class Base64Coder
","// Base64Coder_1Test.java
package com.pmdesigns.jvc.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Base64Coder}.
* It contains ten unit test cases for the {@link Base64Coder#encode(byte[])} method.
*/
class Base64Coder_1Test {","```java
class Base64Coder_1Test {

    @Test
    void testEncodeEmptyArray() {
        byte[] input = new byte[0];
        char[] expected = new char[0];
        assertArrayEquals(expected, Base64Coder.encode(input));
    }

    @Test
    void testEncodeSingleByte() {
        byte[] input = {65}; // 'A'
        char[] expected = {'Q', 'Q', '='};
        assertArrayEquals(expected, Base64Coder.encode(input));
    }

    @Test
    void testEncodeTwoBytes() {
        byte[] input = {65, 66}; // 'AB'
        char[] expected = {'Q', 'U', 'I', '='};
        assertArrayEquals(expected, Base64Coder.encode(input));
    }

    @Test
    void testEncodeThreeBytes() {
        byte[] input = {65, 66, 67}; // 'ABC'
        char[] expected = {'Q', 'U', 'J', 'D'};
        assertArrayEquals(expected, Base64Coder.encode(input));
    }

    @Test
    void testEncodeFourBytes() {
        byte[] input = {65, 66, 67, 68}; // 'ABCD'
        char[] expected = {'Q', 'U', 'J', 'E'};
        assertArrayEquals(expected, Base64Coder.encode(input));
    }

    @Test
    void testEncodeLongArray() {
        byte[] input = ""Hello, World!"".getBytes();
        char[] expected = {'S', 'G', 'V', 's', 'b', 'G', '8', 's', 'L', 'C', 'w', 'b', '3', 'I', 'g', '='};
        assertArrayEquals(expected, Base64Coder.encode(input));
    }

    @Test
    void testEncodePadding() {
        byte[] input = {65, 66, 67}; // 'ABC'
        char[] expected = {'Q', 'U', 'J', '='};
        assertArrayEquals(expected, Base64Coder.encode(input, 3));
    }

    @Test
    void testEncodePartialArray() {
        byte[] input = {65, 66, 67, 68}; // 'ABCD'
        char[] expected = {'Q', 'U', 'J', 'E'};
        assertArrayEquals(expected, Base64Coder.encode(input, 3));
    }

    @Test
    void testEncodeFullArray() {
        byte[] input = {65, 66, 67, 68}; // 'ABCD'
        char[] expected = {'Q', 'U', 'J', 'E'};
        assertArrayEquals(expected, Base64Coder.encode(input, 4));
    }

    @Test
    void testEncodeInvalidInput() {
        byte[] input = {65, 66, 67, 128}; // 'ABC' + invalid byte
        assertThrows(IllegalArgumentException.class, () -> Base64Coder.encode(input));
    }
}
```
"
chatcmpl-A5UMhpLHg174f0VWMGYwtPE4NE88g,/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/Base64Coder_2Test.java,9.320674657821655,stop,"// Base64Coder.java
package com.pmdesigns.jvc.tools;

/**
 * A Base64 Encoder/Decoder.
 *
 * <p>
 * This class is used to encode and decode data in Base64 format as described in RFC 1521.
 *
 * <p>
 * This is ""Open Source"" software and released under the <a href=""http://www.gnu.org/licenses/lgpl.html"">GNU/LGPL</a> license.<br>
 * It is provided ""as is"" without warranty of any kind.<br>
 * Copyright 2003: Christian d'Heureuse, Inventec Informatik AG, Switzerland.<br>
 * Home page: <a href=""http://www.source-code.biz"">www.source-code.biz</a><br>
 *
 * <p>
 * Version history:<br>
 * 2003-07-22 Christian d'Heureuse (chdh): Module created.<br>
 * 2005-08-11 chdh: Lincense changed from GPL to LGPL.<br>
 * 2006-11-21 chdh:<br>
 *  &nbsp; Method encode(String) renamed to encodeString(String).<br>
 *  &nbsp; Method decode(String) renamed to decodeString(String).<br>
 *  &nbsp; New method encode(byte[],int) added.<br>
 *  &nbsp; New method decode(String) added.<br>
 */
public class Base64Coder {

    // Mapping table from 6-bit nibbles to Base64 characters.
    private static char[] map1 = new char[64];

    static {
        int i = 0;
        for (char c = 'A'; c <= 'Z'; c++) map1[i++] = c;
        for (char c = 'a'; c <= 'z'; c++) map1[i++] = c;
        for (char c = '0'; c <= '9'; c++) map1[i++] = c;
        map1[i++] = '+';
        map1[i++] = '/';
    }

    // Mapping table from Base64 characters to 6-bit nibbles.
    private static byte[] map2 = new byte[128];

    static {
        for (int i = 0; i < map2.length; i++) map2[i] = -1;
        for (int i = 0; i < 64; i++) map2[map1[i]] = (byte) i;
    }

    /**
     * Encodes a string into Base64 format.
     * No blanks or line breaks are inserted.
     * @param s  a String to be encoded.
     * @return   A String with the Base64 encoded data.
     */
    public static String encodeString(String s) {
        return new String(encode(s.getBytes()));
    }

    /**
     * Encodes a byte array into Base64 format.
     * No blanks or line breaks are inserted.
     * @param in  an array containing the data bytes to be encoded.
     * @return    A character array with the Base64 encoded data.
     */
    public static char[] encode(byte[] in) {
        return encode(in, in.length);
    }

    /**
     * Encodes a byte array into Base64 format.
     * No blanks or line breaks are inserted.
     * @param in   an array containing the data bytes to be encoded.
     * @param iLen number of bytes to process in <code>in</code>.
     * @return     A character array with the Base64 encoded data.
     */
    public static char[] encode(byte[] in, int iLen) {
        // output length without padding
        int oDataLen = (iLen * 4 + 2) / 3;
        // output length including padding
        int oLen = ((iLen + 2) / 3) * 4;
        char[] out = new char[oLen];
        int ip = 0;
        int op = 0;
        while (ip < iLen) {
            int i0 = in[ip++] & 0xff;
            int i1 = ip < iLen ? in[ip++] & 0xff : 0;
            int i2 = ip < iLen ? in[ip++] & 0xff : 0;
            int o0 = i0 >>> 2;
            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);
            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);
            int o3 = i2 & 0x3F;
            out[op++] = map1[o0];
            out[op++] = map1[o1];
            out[op] = op < oDataLen ? map1[o2] : '=';
            op++;
            out[op] = op < oDataLen ? map1[o3] : '=';
            op++;
        }
        return out;
    }

    /**
     * Decodes a string from Base64 format.
     * @param s  a Base64 String to be decoded.
     * @return   A String containing the decoded data.
     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.
     */
    public static String decodeString(String s) {
        return new String(decode(s));
    }

    /**
     * Decodes a byte array from Base64 format.
     * @param s  a Base64 String to be decoded.
     * @return   An array containing the decoded data bytes.
     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.
     */
    public static byte[] decode(String s) {
        return decode(s.toCharArray());
    }

    /**
     * Decodes a byte array from Base64 format.
     * No blanks or line breaks are allowed within the Base64 encoded data.
     * @param in  a character array containing the Base64 encoded data.
     * @return    An array containing the decoded data bytes.
     * @throws    IllegalArgumentException if the input is not valid Base64 encoded data.
     */
    public static byte[] decode(char[] in) {
        int iLen = in.length;
        if (iLen % 4 != 0)
            throw new IllegalArgumentException(""Length of Base64 encoded input string is not a multiple of 4."");
        while (iLen > 0 && in[iLen - 1] == '=') iLen--;
        int oLen = (iLen * 3) / 4;
        byte[] out = new byte[oLen];
        int ip = 0;
        int op = 0;
        while (ip < iLen) {
            int i0 = in[ip++];
            int i1 = in[ip++];
            int i2 = ip < iLen ? in[ip++] : 'A';
            int i3 = ip < iLen ? in[ip++] : 'A';
            if (i0 > 127 || i1 > 127 || i2 > 127 || i3 > 127)
                throw new IllegalArgumentException(""Illegal character in Base64 encoded data."");
            int b0 = map2[i0];
            int b1 = map2[i1];
            int b2 = map2[i2];
            int b3 = map2[i3];
            if (b0 < 0 || b1 < 0 || b2 < 0 || b3 < 0)
                throw new IllegalArgumentException(""Illegal character in Base64 encoded data."");
            int o0 = (b0 << 2) | (b1 >>> 4);
            int o1 = ((b1 & 0xf) << 4) | (b2 >>> 2);
            int o2 = ((b2 & 3) << 6) | b3;
            out[op++] = (byte) o0;
            if (op < oLen)
                out[op++] = (byte) o1;
            if (op < oLen)
                out[op++] = (byte) o2;
        }
        return out;
    }

    // Dummy constructor.
    private Base64Coder() {
    }
}
// end class Base64Coder
","// Base64Coder_2Test.java
package com.pmdesigns.jvc.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Base64Coder}.
* It contains ten unit test cases for the {@link Base64Coder#encode(byte[], int)} method.
*/
class Base64Coder_2Test {","```java
class Base64Coder_2Test {

    @Test
    void testEncodeWithEmptyArray() {
        byte[] input = new byte[0];
        char[] expected = new char[0];
        assertArrayEquals(expected, Base64Coder.encode(input, input.length));
    }

    @Test
    void testEncodeWithSingleByte() {
        byte[] input = {65}; // 'A'
        char[] expected = {'Q', 'Q', '=', '='};
        assertArrayEquals(expected, Base64Coder.encode(input, input.length));
    }

    @Test
    void testEncodeWithTwoBytes() {
        byte[] input = {65, 66}; // 'AB'
        char[] expected = {'Q', 'U', 'I', '='};
        assertArrayEquals(expected, Base64Coder.encode(input, input.length));
    }

    @Test
    void testEncodeWithThreeBytes() {
        byte[] input = {65, 66, 67}; // 'ABC'
        char[] expected = {'Q', 'U', 'J', 'A'};
        assertArrayEquals(expected, Base64Coder.encode(input, input.length));
    }

    @Test
    void testEncodeWithFourBytes() {
        byte[] input = {65, 66, 67, 68}; // 'ABCD'
        char[] expected = {'Q', 'U', 'J', 'B', 'A', '='};
        assertArrayEquals(expected, Base64Coder.encode(input, input.length));
    }

    @Test
    void testEncodeWithFiveBytes() {
        byte[] input = {65, 66, 67, 68, 69}; // 'ABCDE'
        char[] expected = {'Q', 'U', 'J', 'B', 'E', 'A', '='};
        assertArrayEquals(expected, Base64Coder.encode(input, input.length));
    }

    @Test
    void testEncodeWithSixBytes() {
        byte[] input = {65, 66, 67, 68, 69, 70}; // 'ABCDEF'
        char[] expected = {'Q', 'U', 'J', 'B', 'E', 'K'};
        assertArrayEquals(expected, Base64Coder.encode(input, input.length));
    }

    @Test
    void testEncodeWithSevenBytes() {
        byte[] input = {65, 66, 67, 68, 69, 70, 71}; // 'ABCDEFG'
        char[] expected = {'Q', 'U', 'J', 'B', 'E', 'K', 'F', 'w'};
        assertArrayEquals(expected, Base64Coder.encode(input, input.length));
    }

    @Test
    void testEncodeWithEightBytes() {
        byte[] input = {65, 66, 67, 68, 69, 70, 71, 72}; // 'ABCDEFGH'
        char[] expected = {'Q', 'U', 'J', 'B', 'E', 'K', 'F', 'I', 'A', '='};
        assertArrayEquals(expected, Base64Coder.encode(input, input.length));
    }

    @Test
    void testEncodeWithNineBytes() {
        byte[] input = {65, 66, 67, 68, 69, 70, 71, 72, 73}; // 'ABCDEFGHI'
        char[] expected = {'Q', 'U', 'J', 'B', 'E', 'K', 'F', 'I', 'G', 'A', '='};
        assertArrayEquals(expected, Base64Coder.encode(input, input.length));
    }
}
```
```"
chatcmpl-A5UNkRnnx2ez5lzU8dgg2uzi7hOMv,/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/Base64Coder_3Test.java,5.41013240814209,stop,"// Base64Coder.java
package com.pmdesigns.jvc.tools;

/**
 * A Base64 Encoder/Decoder.
 *
 * <p>
 * This class is used to encode and decode data in Base64 format as described in RFC 1521.
 *
 * <p>
 * This is ""Open Source"" software and released under the <a href=""http://www.gnu.org/licenses/lgpl.html"">GNU/LGPL</a> license.<br>
 * It is provided ""as is"" without warranty of any kind.<br>
 * Copyright 2003: Christian d'Heureuse, Inventec Informatik AG, Switzerland.<br>
 * Home page: <a href=""http://www.source-code.biz"">www.source-code.biz</a><br>
 *
 * <p>
 * Version history:<br>
 * 2003-07-22 Christian d'Heureuse (chdh): Module created.<br>
 * 2005-08-11 chdh: Lincense changed from GPL to LGPL.<br>
 * 2006-11-21 chdh:<br>
 *  &nbsp; Method encode(String) renamed to encodeString(String).<br>
 *  &nbsp; Method decode(String) renamed to decodeString(String).<br>
 *  &nbsp; New method encode(byte[],int) added.<br>
 *  &nbsp; New method decode(String) added.<br>
 */
public class Base64Coder {

    // Mapping table from 6-bit nibbles to Base64 characters.
    private static char[] map1 = new char[64];

    static {
        int i = 0;
        for (char c = 'A'; c <= 'Z'; c++) map1[i++] = c;
        for (char c = 'a'; c <= 'z'; c++) map1[i++] = c;
        for (char c = '0'; c <= '9'; c++) map1[i++] = c;
        map1[i++] = '+';
        map1[i++] = '/';
    }

    // Mapping table from Base64 characters to 6-bit nibbles.
    private static byte[] map2 = new byte[128];

    static {
        for (int i = 0; i < map2.length; i++) map2[i] = -1;
        for (int i = 0; i < 64; i++) map2[map1[i]] = (byte) i;
    }

    /**
     * Encodes a string into Base64 format.
     * No blanks or line breaks are inserted.
     * @param s  a String to be encoded.
     * @return   A String with the Base64 encoded data.
     */
    public static String encodeString(String s) {
        return new String(encode(s.getBytes()));
    }

    /**
     * Encodes a byte array into Base64 format.
     * No blanks or line breaks are inserted.
     * @param in  an array containing the data bytes to be encoded.
     * @return    A character array with the Base64 encoded data.
     */
    public static char[] encode(byte[] in) {
        return encode(in, in.length);
    }

    /**
     * Encodes a byte array into Base64 format.
     * No blanks or line breaks are inserted.
     * @param in   an array containing the data bytes to be encoded.
     * @param iLen number of bytes to process in <code>in</code>.
     * @return     A character array with the Base64 encoded data.
     */
    public static char[] encode(byte[] in, int iLen) {
        // output length without padding
        int oDataLen = (iLen * 4 + 2) / 3;
        // output length including padding
        int oLen = ((iLen + 2) / 3) * 4;
        char[] out = new char[oLen];
        int ip = 0;
        int op = 0;
        while (ip < iLen) {
            int i0 = in[ip++] & 0xff;
            int i1 = ip < iLen ? in[ip++] & 0xff : 0;
            int i2 = ip < iLen ? in[ip++] & 0xff : 0;
            int o0 = i0 >>> 2;
            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);
            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);
            int o3 = i2 & 0x3F;
            out[op++] = map1[o0];
            out[op++] = map1[o1];
            out[op] = op < oDataLen ? map1[o2] : '=';
            op++;
            out[op] = op < oDataLen ? map1[o3] : '=';
            op++;
        }
        return out;
    }

    /**
     * Decodes a string from Base64 format.
     * @param s  a Base64 String to be decoded.
     * @return   A String containing the decoded data.
     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.
     */
    public static String decodeString(String s) {
        return new String(decode(s));
    }

    /**
     * Decodes a byte array from Base64 format.
     * @param s  a Base64 String to be decoded.
     * @return   An array containing the decoded data bytes.
     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.
     */
    public static byte[] decode(String s) {
        return decode(s.toCharArray());
    }

    /**
     * Decodes a byte array from Base64 format.
     * No blanks or line breaks are allowed within the Base64 encoded data.
     * @param in  a character array containing the Base64 encoded data.
     * @return    An array containing the decoded data bytes.
     * @throws    IllegalArgumentException if the input is not valid Base64 encoded data.
     */
    public static byte[] decode(char[] in) {
        int iLen = in.length;
        if (iLen % 4 != 0)
            throw new IllegalArgumentException(""Length of Base64 encoded input string is not a multiple of 4."");
        while (iLen > 0 && in[iLen - 1] == '=') iLen--;
        int oLen = (iLen * 3) / 4;
        byte[] out = new byte[oLen];
        int ip = 0;
        int op = 0;
        while (ip < iLen) {
            int i0 = in[ip++];
            int i1 = in[ip++];
            int i2 = ip < iLen ? in[ip++] : 'A';
            int i3 = ip < iLen ? in[ip++] : 'A';
            if (i0 > 127 || i1 > 127 || i2 > 127 || i3 > 127)
                throw new IllegalArgumentException(""Illegal character in Base64 encoded data."");
            int b0 = map2[i0];
            int b1 = map2[i1];
            int b2 = map2[i2];
            int b3 = map2[i3];
            if (b0 < 0 || b1 < 0 || b2 < 0 || b3 < 0)
                throw new IllegalArgumentException(""Illegal character in Base64 encoded data."");
            int o0 = (b0 << 2) | (b1 >>> 4);
            int o1 = ((b1 & 0xf) << 4) | (b2 >>> 2);
            int o2 = ((b2 & 3) << 6) | b3;
            out[op++] = (byte) o0;
            if (op < oLen)
                out[op++] = (byte) o1;
            if (op < oLen)
                out[op++] = (byte) o2;
        }
        return out;
    }

    // Dummy constructor.
    private Base64Coder() {
    }
}
// end class Base64Coder
","// Base64Coder_3Test.java
package com.pmdesigns.jvc.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Base64Coder}.
* It contains ten unit test cases for the {@link Base64Coder#decodeString(String)} method.
*/
class Base64Coder_3Test {","```java
import static org.junit.jupiter.api.Assertions.*;

class Base64Coder_3Test {

    @Test
    void testDecodeString() {
        assertEquals(""Hello, World!"", Base64Coder.decodeString(""SGVsbG8sIFdvcmxkIQ==""));
        assertEquals(""Java is fun"", Base64Coder.decodeString(""SmF2YSBpcyBmdW4=""));
        assertEquals(""Testing 123"", Base64Coder.decodeString(""VGVzdGluZyAxMjM=""));
        assertEquals(""Base64Coder"", Base64Coder.decodeString(""QmFzZTY0Q29kZXI=""));
        assertEquals(""JUnit 5"", Base64Coder.decodeString(""SlVJbnQgNQ==""));
        assertEquals(""Coding Assistant"", Base64Coder.decodeString(""Q29kaW5nIEFzc2lzdGFudA==""));
        assertEquals(""Unit Testing"", Base64Coder.decodeString(""VW5pdCBUZXN0aW5n""));
        assertEquals(""Java Virtual Machine"", Base64Coder.decodeString(""SmF2YSBWaXJ0dWFsIE1hY2hpbmU=""));
        assertEquals(""Open Source"", Base64Coder.decodeString(""T3BlbiBTb3VyY2U=""));
        assertEquals(""Happy Coding!"", Base64Coder.decodeString(""SGFwcHkgQ29kaW5nIQ==""));
    }
}
```
"
chatcmpl-A5UOnRvWDEXeL8YKeEEvL1AghMMPE,/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/Base64Coder_4Test.java,6.144259691238403,stop,"// Base64Coder.java
package com.pmdesigns.jvc.tools;

/**
 * A Base64 Encoder/Decoder.
 *
 * <p>
 * This class is used to encode and decode data in Base64 format as described in RFC 1521.
 *
 * <p>
 * This is ""Open Source"" software and released under the <a href=""http://www.gnu.org/licenses/lgpl.html"">GNU/LGPL</a> license.<br>
 * It is provided ""as is"" without warranty of any kind.<br>
 * Copyright 2003: Christian d'Heureuse, Inventec Informatik AG, Switzerland.<br>
 * Home page: <a href=""http://www.source-code.biz"">www.source-code.biz</a><br>
 *
 * <p>
 * Version history:<br>
 * 2003-07-22 Christian d'Heureuse (chdh): Module created.<br>
 * 2005-08-11 chdh: Lincense changed from GPL to LGPL.<br>
 * 2006-11-21 chdh:<br>
 *  &nbsp; Method encode(String) renamed to encodeString(String).<br>
 *  &nbsp; Method decode(String) renamed to decodeString(String).<br>
 *  &nbsp; New method encode(byte[],int) added.<br>
 *  &nbsp; New method decode(String) added.<br>
 */
public class Base64Coder {

    // Mapping table from 6-bit nibbles to Base64 characters.
    private static char[] map1 = new char[64];

    static {
        int i = 0;
        for (char c = 'A'; c <= 'Z'; c++) map1[i++] = c;
        for (char c = 'a'; c <= 'z'; c++) map1[i++] = c;
        for (char c = '0'; c <= '9'; c++) map1[i++] = c;
        map1[i++] = '+';
        map1[i++] = '/';
    }

    // Mapping table from Base64 characters to 6-bit nibbles.
    private static byte[] map2 = new byte[128];

    static {
        for (int i = 0; i < map2.length; i++) map2[i] = -1;
        for (int i = 0; i < 64; i++) map2[map1[i]] = (byte) i;
    }

    /**
     * Encodes a string into Base64 format.
     * No blanks or line breaks are inserted.
     * @param s  a String to be encoded.
     * @return   A String with the Base64 encoded data.
     */
    public static String encodeString(String s) {
        return new String(encode(s.getBytes()));
    }

    /**
     * Encodes a byte array into Base64 format.
     * No blanks or line breaks are inserted.
     * @param in  an array containing the data bytes to be encoded.
     * @return    A character array with the Base64 encoded data.
     */
    public static char[] encode(byte[] in) {
        return encode(in, in.length);
    }

    /**
     * Encodes a byte array into Base64 format.
     * No blanks or line breaks are inserted.
     * @param in   an array containing the data bytes to be encoded.
     * @param iLen number of bytes to process in <code>in</code>.
     * @return     A character array with the Base64 encoded data.
     */
    public static char[] encode(byte[] in, int iLen) {
        // output length without padding
        int oDataLen = (iLen * 4 + 2) / 3;
        // output length including padding
        int oLen = ((iLen + 2) / 3) * 4;
        char[] out = new char[oLen];
        int ip = 0;
        int op = 0;
        while (ip < iLen) {
            int i0 = in[ip++] & 0xff;
            int i1 = ip < iLen ? in[ip++] & 0xff : 0;
            int i2 = ip < iLen ? in[ip++] & 0xff : 0;
            int o0 = i0 >>> 2;
            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);
            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);
            int o3 = i2 & 0x3F;
            out[op++] = map1[o0];
            out[op++] = map1[o1];
            out[op] = op < oDataLen ? map1[o2] : '=';
            op++;
            out[op] = op < oDataLen ? map1[o3] : '=';
            op++;
        }
        return out;
    }

    /**
     * Decodes a string from Base64 format.
     * @param s  a Base64 String to be decoded.
     * @return   A String containing the decoded data.
     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.
     */
    public static String decodeString(String s) {
        return new String(decode(s));
    }

    /**
     * Decodes a byte array from Base64 format.
     * @param s  a Base64 String to be decoded.
     * @return   An array containing the decoded data bytes.
     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.
     */
    public static byte[] decode(String s) {
        return decode(s.toCharArray());
    }

    /**
     * Decodes a byte array from Base64 format.
     * No blanks or line breaks are allowed within the Base64 encoded data.
     * @param in  a character array containing the Base64 encoded data.
     * @return    An array containing the decoded data bytes.
     * @throws    IllegalArgumentException if the input is not valid Base64 encoded data.
     */
    public static byte[] decode(char[] in) {
        int iLen = in.length;
        if (iLen % 4 != 0)
            throw new IllegalArgumentException(""Length of Base64 encoded input string is not a multiple of 4."");
        while (iLen > 0 && in[iLen - 1] == '=') iLen--;
        int oLen = (iLen * 3) / 4;
        byte[] out = new byte[oLen];
        int ip = 0;
        int op = 0;
        while (ip < iLen) {
            int i0 = in[ip++];
            int i1 = in[ip++];
            int i2 = ip < iLen ? in[ip++] : 'A';
            int i3 = ip < iLen ? in[ip++] : 'A';
            if (i0 > 127 || i1 > 127 || i2 > 127 || i3 > 127)
                throw new IllegalArgumentException(""Illegal character in Base64 encoded data."");
            int b0 = map2[i0];
            int b1 = map2[i1];
            int b2 = map2[i2];
            int b3 = map2[i3];
            if (b0 < 0 || b1 < 0 || b2 < 0 || b3 < 0)
                throw new IllegalArgumentException(""Illegal character in Base64 encoded data."");
            int o0 = (b0 << 2) | (b1 >>> 4);
            int o1 = ((b1 & 0xf) << 4) | (b2 >>> 2);
            int o2 = ((b2 & 3) << 6) | b3;
            out[op++] = (byte) o0;
            if (op < oLen)
                out[op++] = (byte) o1;
            if (op < oLen)
                out[op++] = (byte) o2;
        }
        return out;
    }

    // Dummy constructor.
    private Base64Coder() {
    }
}
// end class Base64Coder
","// Base64Coder_4Test.java
package com.pmdesigns.jvc.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Base64Coder}.
* It contains ten unit test cases for the {@link Base64Coder#decode(String)} method.
*/
class Base64Coder_4Test {","```java
import static org.junit.jupiter.api.Assertions.assertArrayEquals;

class Base64Coder_4Test {

    @Test
    void testDecodeEmptyString() {
        String input = """";
        byte[] expected = new byte[0];
        assertArrayEquals(expected, Base64Coder.decode(input));
    }

    @Test
    void testDecodeSingleCharacter() {
        String input = ""Zg=="";
        byte[] expected = {102};
        assertArrayEquals(expected, Base64Coder.decode(input));
    }

    @Test
    void testDecodeMultipleCharacters() {
        String input = ""SGVsbG8gV29ybGQ="";
        byte[] expected = ""Hello World"".getBytes();
        assertArrayEquals(expected, Base64Coder.decode(input));
    }

    @Test
    void testDecodeWithPadding() {
        String input = ""SGVsbG8gV29ybGQ="";
        byte[] expected = ""Hello World"".getBytes();
        assertArrayEquals(expected, Base64Coder.decode(input));
    }

    @Test
    void testDecodeWithInvalidCharacter() {
        String input = ""SGVsbG8gV29ybGQ="";
        assertThrows(IllegalArgumentException.class, () -> Base64Coder.decode(input + ""A""));
    }

    @Test
    void testDecodeWithInvalidPadding() {
        String input = ""SGVsbG8gV29ybGQ"";
        assertThrows(IllegalArgumentException.class, () -> Base64Coder.decode(input));
    }

    @Test
    void testDecodeWithInvalidLength() {
        String input = ""SGVsbG8gV29ybGQ"";
        assertThrows(IllegalArgumentException.class, () -> Base64Coder.decode(input + ""A""));
    }

    @Test
    void testDecodeWithSpecialCharacters() {
        String input = ""U3VwZXIgQ2FzZQ=="";
        byte[] expected = ""Super Case"".getBytes();
        assertArrayEquals(expected, Base64Coder.decode(input));
    }

    @Test
    void testDecodeWithNumbers() {
        String input = ""MTIzNDU2Nzg5MA=="";
        byte[] expected = ""1234567890"".getBytes();
        assertArrayEquals(expected, Base64Coder.decode(input));
    }
}
```
"
chatcmpl-A5UPqBW44btH80b0NhzT5OXY25K8i,/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/Base64Coder_5Test.java,7.192497730255127,stop,"// Base64Coder.java
package com.pmdesigns.jvc.tools;

/**
 * A Base64 Encoder/Decoder.
 *
 * <p>
 * This class is used to encode and decode data in Base64 format as described in RFC 1521.
 *
 * <p>
 * This is ""Open Source"" software and released under the <a href=""http://www.gnu.org/licenses/lgpl.html"">GNU/LGPL</a> license.<br>
 * It is provided ""as is"" without warranty of any kind.<br>
 * Copyright 2003: Christian d'Heureuse, Inventec Informatik AG, Switzerland.<br>
 * Home page: <a href=""http://www.source-code.biz"">www.source-code.biz</a><br>
 *
 * <p>
 * Version history:<br>
 * 2003-07-22 Christian d'Heureuse (chdh): Module created.<br>
 * 2005-08-11 chdh: Lincense changed from GPL to LGPL.<br>
 * 2006-11-21 chdh:<br>
 *  &nbsp; Method encode(String) renamed to encodeString(String).<br>
 *  &nbsp; Method decode(String) renamed to decodeString(String).<br>
 *  &nbsp; New method encode(byte[],int) added.<br>
 *  &nbsp; New method decode(String) added.<br>
 */
public class Base64Coder {

    // Mapping table from 6-bit nibbles to Base64 characters.
    private static char[] map1 = new char[64];

    static {
        int i = 0;
        for (char c = 'A'; c <= 'Z'; c++) map1[i++] = c;
        for (char c = 'a'; c <= 'z'; c++) map1[i++] = c;
        for (char c = '0'; c <= '9'; c++) map1[i++] = c;
        map1[i++] = '+';
        map1[i++] = '/';
    }

    // Mapping table from Base64 characters to 6-bit nibbles.
    private static byte[] map2 = new byte[128];

    static {
        for (int i = 0; i < map2.length; i++) map2[i] = -1;
        for (int i = 0; i < 64; i++) map2[map1[i]] = (byte) i;
    }

    /**
     * Encodes a string into Base64 format.
     * No blanks or line breaks are inserted.
     * @param s  a String to be encoded.
     * @return   A String with the Base64 encoded data.
     */
    public static String encodeString(String s) {
        return new String(encode(s.getBytes()));
    }

    /**
     * Encodes a byte array into Base64 format.
     * No blanks or line breaks are inserted.
     * @param in  an array containing the data bytes to be encoded.
     * @return    A character array with the Base64 encoded data.
     */
    public static char[] encode(byte[] in) {
        return encode(in, in.length);
    }

    /**
     * Encodes a byte array into Base64 format.
     * No blanks or line breaks are inserted.
     * @param in   an array containing the data bytes to be encoded.
     * @param iLen number of bytes to process in <code>in</code>.
     * @return     A character array with the Base64 encoded data.
     */
    public static char[] encode(byte[] in, int iLen) {
        // output length without padding
        int oDataLen = (iLen * 4 + 2) / 3;
        // output length including padding
        int oLen = ((iLen + 2) / 3) * 4;
        char[] out = new char[oLen];
        int ip = 0;
        int op = 0;
        while (ip < iLen) {
            int i0 = in[ip++] & 0xff;
            int i1 = ip < iLen ? in[ip++] & 0xff : 0;
            int i2 = ip < iLen ? in[ip++] & 0xff : 0;
            int o0 = i0 >>> 2;
            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);
            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);
            int o3 = i2 & 0x3F;
            out[op++] = map1[o0];
            out[op++] = map1[o1];
            out[op] = op < oDataLen ? map1[o2] : '=';
            op++;
            out[op] = op < oDataLen ? map1[o3] : '=';
            op++;
        }
        return out;
    }

    /**
     * Decodes a string from Base64 format.
     * @param s  a Base64 String to be decoded.
     * @return   A String containing the decoded data.
     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.
     */
    public static String decodeString(String s) {
        return new String(decode(s));
    }

    /**
     * Decodes a byte array from Base64 format.
     * @param s  a Base64 String to be decoded.
     * @return   An array containing the decoded data bytes.
     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.
     */
    public static byte[] decode(String s) {
        return decode(s.toCharArray());
    }

    /**
     * Decodes a byte array from Base64 format.
     * No blanks or line breaks are allowed within the Base64 encoded data.
     * @param in  a character array containing the Base64 encoded data.
     * @return    An array containing the decoded data bytes.
     * @throws    IllegalArgumentException if the input is not valid Base64 encoded data.
     */
    public static byte[] decode(char[] in) {
        int iLen = in.length;
        if (iLen % 4 != 0)
            throw new IllegalArgumentException(""Length of Base64 encoded input string is not a multiple of 4."");
        while (iLen > 0 && in[iLen - 1] == '=') iLen--;
        int oLen = (iLen * 3) / 4;
        byte[] out = new byte[oLen];
        int ip = 0;
        int op = 0;
        while (ip < iLen) {
            int i0 = in[ip++];
            int i1 = in[ip++];
            int i2 = ip < iLen ? in[ip++] : 'A';
            int i3 = ip < iLen ? in[ip++] : 'A';
            if (i0 > 127 || i1 > 127 || i2 > 127 || i3 > 127)
                throw new IllegalArgumentException(""Illegal character in Base64 encoded data."");
            int b0 = map2[i0];
            int b1 = map2[i1];
            int b2 = map2[i2];
            int b3 = map2[i3];
            if (b0 < 0 || b1 < 0 || b2 < 0 || b3 < 0)
                throw new IllegalArgumentException(""Illegal character in Base64 encoded data."");
            int o0 = (b0 << 2) | (b1 >>> 4);
            int o1 = ((b1 & 0xf) << 4) | (b2 >>> 2);
            int o2 = ((b2 & 3) << 6) | b3;
            out[op++] = (byte) o0;
            if (op < oLen)
                out[op++] = (byte) o1;
            if (op < oLen)
                out[op++] = (byte) o2;
        }
        return out;
    }

    // Dummy constructor.
    private Base64Coder() {
    }
}
// end class Base64Coder
","// Base64Coder_5Test.java
package com.pmdesigns.jvc.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Base64Coder}.
* It contains ten unit test cases for the {@link Base64Coder#decode(char[])} method.
*/
class Base64Coder_5Test {","```java
import static org.junit.jupiter.api.Assertions.assertArrayEquals;

class Base64Coder_5Test {

    @Test
    void testDecodeWithValidInput() {
        char[] input = ""SGVsbG8gV29ybGQh"".toCharArray();
        byte[] expected = ""Hello World!"".getBytes();
        assertArrayEquals(expected, Base64Coder.decode(input));
    }

    @Test
    void testDecodeWithPadding() {
        char[] input = ""SGVsbG8gV29ybGQh="".toCharArray();
        byte[] expected = ""Hello World!"".getBytes();
        assertArrayEquals(expected, Base64Coder.decode(input));
    }

    @Test
    void testDecodeWithMultipleOfFour() {
        char[] input = ""SGVsbG8gV29ybGQ="".toCharArray();
        byte[] expected = ""Hello World"".getBytes();
        assertArrayEquals(expected, Base64Coder.decode(input));
    }

    @Test
    void testDecodeWithInvalidCharacter() {
        char[] input = ""SGVsbG8gV29ybGQh$"".toCharArray();
        assertThrows(IllegalArgumentException.class, () -> Base64Coder.decode(input));
    }

    @Test
    void testDecodeWithInvalidPadding() {
        char[] input = ""SGVsbG8gV29ybGQ=="".toCharArray();
        assertThrows(IllegalArgumentException.class, () -> Base64Coder.decode(input));
    }

    @Test
    void testDecodeWithEmptyInput() {
        char[] input = """".toCharArray();
        byte[] expected = new byte[0];
        assertArrayEquals(expected, Base64Coder.decode(input));
    }

    @Test
    void testDecodeWithSingleCharacter() {
        char[] input = ""S"".toCharArray();
        byte[] expected = ""H"".getBytes();
        assertArrayEquals(expected, Base64Coder.decode(input));
    }

    @Test
    void testDecodeWithDoubleCharacter() {
        char[] input = ""SG"".toCharArray();
        byte[] expected = ""He"".getBytes();
        assertArrayEquals(expected, Base64Coder.decode(input));
    }

    @Test
    void testDecodeWithTripleCharacter() {
        char[] input = ""SGV"".toCharArray();
        byte[] expected = ""Hel"".getBytes();
        assertArrayEquals(expected, Base64Coder.decode(input));
    }
}
```
"
chatcmpl-A5UQteWWDpADqCUGtCELeOgyMY2q6,/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContext_0Test.java,29.32809805870056,length,"// JVCRequestContext.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

/**
 * This class contains state information for processing an http request.
 * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet
 * objects and provides convenience methods for accessing them.
 * <p>
 * It also provides access to the 'flash' which is a Map for storing temporary
 * key/value strings.  The scope of the flash is the current request or
 * the following request in the case of a redirect response.
 * <p>
 * It also contains some convenience methods for forming links and absolute paths.
 *
 * @author mike dooley
 */
public final class JVCRequestContext {

    /**
     * The actual HttpServletRequest object
     */
    public final HttpServletRequest request;

    /**
     * The actual HttpServletResponse object
     */
    public final HttpServletResponse response;

    /**
     * The HttpServlet object (actually this is a JVCDispatcher)
     */
    public final HttpServlet servlet;

    /**
     * The controller is the servlet path up to the action.
     */
    public final String controller;

    /**
     * The action is the last part of the servlet path (before any query arguments)
     */
    public final String action;

    /**
     * Tells if this request has multipart content (ie file upload)
     */
    public final boolean hasMultipartContent;

    /**
     * Parameter value indicating that the real parameter value is binary (and should be
     * accessed via the getAttribute() method.
     */
    public static final String BINARY_VALUE = ""BINARY_VALUE"";

    /**
     * The 'flash' map for holding temporary key/value strings.
     */
    public final Map<String, String> flash;

    /**
     * Holds cached page generator fragments
     */
    private static Map<String, String> cacheMap;

    /**
     * Constructor for JVCRequestContext which is used to hold http request and response iformation
     * @param request
     * @param response
     * @param servlet
     * @param flash
     * @param controller
     * @param action
     */
    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map<String, String> flash, String controller, String action) throws Exception {
        this.request = request;
        this.response = response;
        this.servlet = servlet;
        this.controller = controller;
        this.action = action;
        this.flash = flash;
        hasMultipartContent = ServletFileUpload.isMultipartContent(request);
        if (hasMultipartContent) {
            // Create a new file upload handler
            ServletFileUpload upload = new ServletFileUpload();
            // Parse the request
            FileItemIterator iter = upload.getItemIterator(request);
            while (iter.hasNext()) {
                FileItemStream item = iter.next();
                String name = item.getFieldName();
                InputStream stream = item.openStream();
                if (item.isFormField()) {
                    // add parameter as request attribute
                    String val = Streams.asString(stream);
                    request.setAttribute(name, val);
                    // System.out.println(""Form field "" + name + "" with value "" + val + "" detected."");
                } else {
                    // add input stream and filename as attributes
                    String fileName = item.getName();
                    request.setAttribute(""fileName"", fileName);
                    byte[] data = readStream(stream);
                    request.setAttribute(name, data);
                    // System.out.println(""File field "" + name + "" with file name "" + fileName + "" detected."");
                }
            }
        }
    }

    // request info
    /**
     * Convenience method
     * @return true if the request is secure
     */
    public boolean isSecure() {
        return request.isSecure();
    }

    /**
     * Convenience method
     * @return the request scheme, ie. http, https
     */
    public String getScheme() {
        return request.getScheme();
    }

    /**
     * Convenience method
     * @return the request method, ie. GET, POST
     */
    public String getMethod() {
        return request.getMethod();
    }

    /**
     * Convenience method
     * @return the server name for this request
     */
    public String getServerName() {
        return request.getServerName();
    }

    /**
     * Convenience method
     * @return the server port for this request
     */
    public int getServerPort() {
        return request.getServerPort();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getServletPath
     * @see #getQueryString
     * @return the context path part of the url path
     */
    public String getContextPath() {
        return request.getContextPath();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getContextPath
     * @see #getQueryString
     * @return the servlet path part of the url path
     */
    public String getServletPath() {
        return request.getServletPath();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getContextPath
     * @see #getServletPath
     * @return the query string part of the url path
     */
    public String getQueryString() {
        return request.getQueryString();
    }

    // params
    /**
     * Convenience method
     * @param name    which parameter to get
     * @return the parameter value or null if there is no parameter corresponding to the indicated key
     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,
     * which can be retrieved as a byte array via the getAttribute method.
     * @see #getParamMap
     * @see #getParamValues
     * @see #getParamNames
     */
    public String getParam(String name) {
        if (hasMultipartContent) {
            Object o = request.getAttribute(name);
            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;
        } else {
            return request.getParameter(name);
        }
    }

    /**
     * Convenience method which gathers all parameters of the
     * form '<name>[<key>]' and return then in a map where the
     * keys are the <key> strings and the values are the
     * corresponding parameter values.
     * <pre>
     * For example, if there are parameters:
     *   'foo[bar1]' = 'baz1'
     *   'foo[bar2]' = 'baz2'
     * then getParamMap('foo') will returned the map:
     *   map['bar1'] = 'baz1'
     *   map['bar2'] = 'baz2'
     * </pre>
     * @param name  the prefix to be used to select parameters
     * @return a map of all paramters of the form 'name[<key>]'
     * where the <key> strings are the keys of the map and the
     * values are the corresponding parameter values.
     * @see #getParam
     * @see #getParamValues
     * @see #getParamNames
     */
    public Map<String, String> getParamMap(String name) {
        Map<String, String> m = new HashMap<String, String>();
        String prefix = name + ""["";
        int n = prefix.length();
        if (hasMultipartContent) {
            // for multipart requests the parameters have been stored as attributes (see constructor)
            Enumeration<String> e = request.getAttributeNames();
            while (e.hasMoreElements()) {
                String key = e.nextElement();
                if (key.startsWith(prefix) && key.endsWith(""]"")) {
                    m.put(key.substring(n, key.length() - 1), getParam(key));
                }
            }
        } else {
            Map<String, String[]> pm = request.getParameterMap();
            for (String key : pm.keySet()) {
                if (key.startsWith(prefix) && key.endsWith(""]"")) {
                    m.put(key.substring(n, key.length() - 1), getParam(key));
                }
            }
        }
        return m;
    }

    /**
     * Convenience method. Use this if you expect a parameter name
     * to map to multiple values.
     * @param name    the name of the parameter(s) to get
     * @return an array of paramter values corresponding to the indicated name
     * @see #getParam
     * @see #getParamMap
     * @see #getParamNames
     */
    public String[] getParamValues(String name) {
        return request.getParameterValues(name);
    }

    /**
     * Convenience method to get all the parameter names.
     * @return an array of all parameter names
     * @see #getParam
     * @see #getParamMap
     * @see #getParamValues
     */
    public String[] getParamNames() {
        if (hasMultipartContent) {
            List<String> list = new ArrayList<String>();
            Enumeration<String> e = request.getAttributeNames();
            while (e.hasMoreElements()) {
                list.add(e.nextElement());
            }
            return list.toArray(new String[list.size()]);
        } else {
            Map<String, String[]> m = request.getParameterMap();
            String[] a = new String[m.size()];
            int i = 0;
            for (String key : m.keySet()) {
                a[i++] = key;
            }
            return a;
        }
    }

    // attributes
    /**
     * Convenience method
     * @param name    which attribute to get
     * @return the attribute value or null if there is no attribute corresponding to the indicated key.
     * If the attribute corresponds to a file upload field then the return value will be a byte array
     */
    public Object getAttribute(String name) {
        return request.getAttribute(name);
    }

    /**
     * Convenience method
     * @param name    name of attribute to be set
     * @param value   value of attribute to be set
     */
    public void setAttribute(String name, Object value) {
        request.setAttribute(name, value);
    }

    // session attributes
    /**
     * Convenience method
     * @param name    the name of the attribute to retrieve
     * @return the attribute associated with the indicated name or null
     * @see #setSessionAttr
     * @see #getSessionAttrNames
     */
    public Object getSessionAttr(String name) {
        if (request.getSession() == null)
            return null;
        return request.getSession().getAttribute(name);
    }

    /**
     * Convenience method
     * @return all the session attribute names.
     * @see #getSessionAttr
     * @see #setSessionAttr
     * @see #removeSessionAttr
     */
    public String[] getSessionAttrNames() {
        if (request.getSession(false) == null)
            return new String[0];
        ArrayList<String> a = new ArrayList<String>();
        Enumeration<String> e = request.getSession().getAttributeNames();
        while (e.hasMoreElements()) {
            a.add(e.nextElement());
        }
        return a.toArray(new String[a.size()]);
    }

    /**
     * Convenience method
     * @param name  the key to store the indicated value
     * @param value  the object to be stored
     * @see #getSessionAttr
     * @see #removeSessionAttr
     */
    public void setSessionAttr(String name, Object value) {
        if (request.getSession() == null)
            return;
        request.getSession().setAttribute(name, value);
    }

    /**
     * Convenience method
     * @param name  the key of
     * @see #setSessionAttr
     */
    public void removeSessionAttr(String name) {
        if (request.getSession() == null)
            return;
        request.getSession().removeAttribute(name);
    }

    // cookies
    /**
     * Convenience method to get cookie by name
     * @param name  the name of the cookie to get
     * @return the cookie with the indicated name, or null
     * @see #setCookie
     * @see #getCookieNames
     */
    public Cookie getCookie(String name) {
        if (name == null)
            return null;
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return null;
        for (Cookie c : cookies) {
            if (name.equals(c.getName()))
                return c;
        }
        return null;
    }

    /**
     * Convenience method to get all the cookie names.
     * @return an array of the names of all the cookies in the request, possibly empty
     * @see #getCookie
     * @see #setCookie
     */
    public String[] getCookieNames() {
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return new String[0];
        String[] a = new String[cookies.length];
        int i = 0;
        for (Cookie c : cookies) {
            a[i++] = c.getName();
        }
        return a;
    }

    /**
     * Convenience method
     * @param cookie   the cookie to be added to the response
     * @see #getCookie
     * @see #getCookieNames
     */
    public void setCookie(Cookie cookie) {
        response.addCookie(cookie);
    }

    /**
     * Cause a non-standard response (ie. redirect) to be returned.
     * @param httpCode   the http response code to be returned
     * @param arg    an argument or message to be returned (depends on response code)
     * @see #redirect
     * @throws NonStandardResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the NonStandardResponseException.
     */
    public void nonStandardResponse(int httpCode, String arg) {
        throw new NonStandardResponseException(httpCode, arg);
    }

    /**
     * Cause a redirect response to be returned
     * @param path  where to redirect to. If the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @see #nonStandardResponse
     * @throws NonStandardResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the NonStandardResponseException.
     */
    public void redirect(String path) {
        if (path.startsWith(""/""))
            path = absPath(path);
        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);
    }

    /**
     * Cause a binary response to be returned
     * @param in input stream containing binary data to be sent
     * @throws BinaryResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the BinaryResponseException.
     */
    public void sendBinaryResponse(InputStream in) {
        throw new BinaryResponseException(in);
    }

    /**
     * Convenience method to prepend the context path onto a servlet path
     * @param path    a servlet path
     * @return the context path plus the indicated path
     */
    public String absPath(String path) {
        return getContextPath() + (path.startsWith(""/"") ? path : ""/"" + path);
    }

    /**
     * Convenience method to create an html anchor link tag
     * @param anchor    the text in an anchor link
     * @param path   the anchor target, if the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @see #makeLink
     * @see #absPath
     */
    public String makeLink(String anchor, String path) {
        return makeLink(anchor, path, """");
    }

    /**
     * Convenience method to create an html anchor link tag
     * @param anchor    the text in an anchor link
     * @param path   the anchor target, if the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @param options    extra html options to add to the anchor tag
     * @see #makeLink
     * @see #absPath
     */
    public String makeLink(String anchor, String path, String options) {
        if (path.startsWith(""/""))
            path = absPath(path);
        return ""<a href='"" + path + ""' "" + options + "">"" + anchor + ""</a>"";
    }

    /**
     * Convenience method to check if this request is a POST
     */
    public boolean isPost() {
        return ""POST"".equals(request.getMethod());
    }

    /**
     * Convenience method to check if this request is a GET
     */
    public boolean isGet() {
        return ""GET"".equals(request.getMethod());
    }

    /**
     * Convenience method to retrieve a value from the flash
     * @param key  the key to use to lookup a flash value
     * @return the flash value associated with the indicated key or null
     * @see #setFlash
     */
    public String getFlash(String key) {
        return flash.get(key);
    }

    /**
     * Convenience method to add a value to the flash
     * @param key  the key to use to associate with the flash value
     * @param val  the value to store
     * @see #getFlash
     */
    public void setFlash(String key, String val) {
        flash.put(key, val);
    }

    // caching (internal use)
    /**
     * Internal method used to retrieve a cached block
     * @see #setCachedBlock
     */
    public static String getCachedBlock(String key) {
        return (cacheMap == null) ? null : cacheMap.get(key);
    }

    /**
     * Internal method used to store a cached block
     * @see #getCachedBlock
     */
    public static void setCachedBlock(String key, String val) {
        if (cacheMap == null) {
            cacheMap = new HashMap<String, String>();
        }
        cacheMap.put(key, val);
    }

    /**
     * For debugging
     * @return a string representation of this request context
     */
    public String toString() {
        return toString("", "");
    }

    public String toString(String sep) {
        StringBuilder sb = new StringBuilder();
        sb.append(""params: ["");
        String[] keys = getParamNames();
        for (String key : keys) {
            sb.append(key).append('=').append(getParam(key)).append(sep);
        }
        if (keys.length > 0) {
            sb.setLength(sb.length() - sep.length());
        }
        sb.append(""]"");
        sb.append(sep).append(""method: "").append(getMethod());
        sb.append(sep).append(""url: "").append(getScheme());
        sb.append(""|"").append(getServerName());
        sb.append(""|"").append(getServerPort());
        sb.append(""|"").append(getContextPath());
        sb.append(""|"").append(getServletPath());
        sb.append(""|"").append(getQueryString());
        if (hasMultipartContent) {
            sb.append(sep).append(""content len: "").append(request.getContentLength());
            //sb.append(sep).append(""content type: "").append(request.getContentType());
        }
        return sb.toString();
    }

    /**
     * Copy an input stream to an output stream.
     */
    private byte[] readStream(InputStream in) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        byte[] buf = new byte[4096];
        int read;
        while ((read = in.read(buf)) > -1) {
            out.write(buf, 0, read);
        }
        out.flush();
        return out.toByteArray();
    }
}
","// JVCRequestContext_0Test.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JVCRequestContext}.
* It contains ten unit test cases for the {@link JVCRequestContext#getParam(String)} method.
*/
class JVCRequestContext_0Test {","```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class JVCRequestContext_0Test {

    @Test
    void testGetParam() {
        // Test case 1: Parameter exists
        HttpServletRequest request = mock(HttpServletRequest.class);
        when(request.getParameter(""param1"")).thenReturn(""value1"");
        JVCRequestContext context = new JVCRequestContext(request, null, null, null, null, null);
        assertEquals(""value1"", context.getParam(""param1""));

        // Test case 2: Parameter does not exist
        when(request.getParameter(""param2"")).thenReturn(null);
        assertEquals(null, context.getParam(""param2""));

        // Test case 3: Multipart content with binary value
        when(request.getAttribute(""param3"")).thenReturn(""BINARY_VALUE"");
        assertEquals(""BINARY_VALUE"", context.getParam(""param3""));
    }
}
```
```java
import java.io.*;
import java.util.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

public class JVCRequestContext {

    public String getParam(String name) {
        if (hasMultipartContent) {
            Object o = request.getAttribute(name);
            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;
        } else {
            return request.getParameter(name);
        }
    }

    public Map<String, String> getParamMap(String name) {
        Map<String, String> m = new HashMap<String, String>();
        String prefix = name + ""["";
        int n = prefix.length();
        if (hasMultipartContent) {
            Enumeration<String> e = request.getAttributeNames();
            while (e.hasMoreElements()) {
                String key = e.nextElement();
                if (key.startsWith(prefix) && key.endsWith(""]"")) {
                    m.put(key.substring(n, key.length() - 1), getParam(key));
                }
            }
        } else {
            Map<String, String[]> pm = request.getParameterMap();
            for (String key : pm.keySet()) {
                if (key.startsWith(prefix) && key.endsWith(""]"")) {
                    m.put(key.substring(n, key.length() - 1), getParam(key));
                }
            }
        }
        return m;
    }
}
```
```java
import javax.servlet.http.*;

public class JVCRequestContext {

    public String getParam(String name) {
        if (hasMultipartContent) {
            Object o = request.getAttribute(name);
            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;
        } else {
            return request.getParameter(name);
        }
    }

    public String[] getParamValues(String name) {
        return request.getParameterValues(name);
    }

    public String[] getParamNames() {
        if (hasMultipartContent) {
            List<String> list = new ArrayList<String>();
            Enumeration<String> e = request.getAttributeNames();
            while (e.hasMoreElements()) {
                list.add(e.nextElement());
            }
            return list.toArray(new String[list.size()]);
        } else {
            Map<String, String[]> m = request.getParameterMap();
            String[] a = new String[m.size()];
            int i = 0;
            for (String key : m.keySet()) {
                a[i++] = key;
            }
            return a;
        }
    }
}
```
```java
import javax.servlet.http.*;

public class JVCRequestContext {

    public String getParam(String name) {
        if (hasMultipartContent) {
            Object o = request.getAttribute(name);
            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;
        } else {
            return request.getParameter(name);
        }
    }

    public void setAttribute(String name, Object value) {
        request.setAttribute(name, value);
    }

    public Object getAttribute(String name) {
        return request.getAttribute(name);
    }
}
```
```java
import javax.servlet.http.*;

public class JVCRequestContext {

    public String getParam(String name) {
        if (hasMultipartContent) {
            Object o = request.getAttribute(name);
            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;
        } else {
            return request.getParameter(name);
        }
    }

    public void setSessionAttr(String name, Object value) {
        if (request.getSession() == null)
            return;
        request.getSession().setAttribute(name, value);
    }

    public Object getSessionAttr(String name) {
        if (request.getSession() == null)
            return null;
        return request.getSession().getAttribute(name);
    }
}
```
```java
import javax.servlet.http.*;

public class JVCRequestContext {

    public String getParam(String name) {
        if (hasMultipartContent) {
            Object o = request.getAttribute(name);
            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;
        } else {
            return request.getParameter(name);
        }
    }

    public void setSessionAttr(String name, Object value) {
        if (request.getSession() == null)
            return;
        request.getSession().setAttribute(name, value);
    }

    public void removeSessionAttr(String name) {
        if (request.getSession() == null)
            return;
        request.getSession().removeAttribute(name);
    }
}
```
```java
import javax.servlet.http.*;

public class JVCRequestContext {

    public String getParam(String name) {
        if (hasMultipartContent) {
            Object o = request.getAttribute(name);
            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;
        } else {
            return request.getParameter(name);
        }
    }

    public Cookie getCookie(String name) {
        if (name == null)
            return null;
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return null;
        for (Cookie c : cookies) {
            if (name.equals(c.getName()))
                return c;
        }
        return null;
    }

    public String[] getCookieNames() {
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return new String[0];
        String[] a = new String[cookies.length];
        int i = 0;
        for (Cookie c : cookies) {
            a[i++] = c.getName();
        }
        return a;
    }
}
```
```java
import javax.servlet.http.*;

public class JVCRequestContext {

    public String getParam(String name) {
        if (hasMultipartContent) {
            Object o = request.getAttribute(name);
            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;
        } else {
            return request.getParameter(name);
        }
    }

    public void setCookie(Cookie cookie) {
        response.addCookie(cookie);
    }

    public Cookie getCookie(String name) {
        if (name == null)
            return null;
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return null;
        for (Cookie c : cookies) {
            if (name.equals(c.getName()))
                return c;
        }
        return null;
    }
}
```
```java
import javax.servlet.http.*;

public class JVCRequestContext {

    public String getParam(String name) {
        if (hasMultipartContent) {
            Object o = request.getAttribute(name);
            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;
        } else {
            return request.getParameter(name);
        }
    }

    public void nonStandardResponse(int httpCode, String arg) {
        throw new NonStandardResponseException(httpCode, arg);
    }

    public void redirect(String path) {
        if (path.startsWith(""/""))
            path = absPath(path);
        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);
    }
}
```
```java
import javax.servlet.http.*;

public class JVCRequestContext {

    public String getParam(String name) {
        if (hasMultipartContent) {
            Object o = request.getAttribute(name);
            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;
        } else {
            return request.getParameter(name);
        }
    }

    public void sendBinaryResponse(InputStream in) {
        throw new BinaryResponseException(in);
    }

    public String absPath(String path) {
        return getContextPath() + (path.startsWith(""/"") ? path : ""/"" + path);
    }
}
```
```java
import javax.servlet.http.*;

public class JVCRequestContext {

    public String getParam(String name) {
        if (hasMultipartContent) {
            Object o = request.getAttribute(name);
            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;
        } else {
            return request.getParameter(name);
        }
    }

    public String makeLink(String anchor, String path) {
        return makeLink(anchor, path, """");
    }

    public String makeLink(String anchor, String path, String options) {
        if (path.startsWith(""/""))
            path = absPath(path);
        return ""<a href='"" + path + ""' "" + options + "">"" + anchor + ""</a>"";
    }
}
```
```java
import javax.servlet.http.*;

public class JVCRequestContext {

    public String getParam(String name) {
        if (hasMultipartContent) {
            Object o = request.getAttribute(name);
            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;
        } else {
            return request.getParameter(name"
chatcmpl-A5URwroz4qVsuI7LqitIbnEVqheXx,/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContext_1Test.java,6.6491124629974365,stop,"// JVCRequestContext.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

/**
 * This class contains state information for processing an http request.
 * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet
 * objects and provides convenience methods for accessing them.
 * <p>
 * It also provides access to the 'flash' which is a Map for storing temporary
 * key/value strings.  The scope of the flash is the current request or
 * the following request in the case of a redirect response.
 * <p>
 * It also contains some convenience methods for forming links and absolute paths.
 *
 * @author mike dooley
 */
public final class JVCRequestContext {

    /**
     * The actual HttpServletRequest object
     */
    public final HttpServletRequest request;

    /**
     * The actual HttpServletResponse object
     */
    public final HttpServletResponse response;

    /**
     * The HttpServlet object (actually this is a JVCDispatcher)
     */
    public final HttpServlet servlet;

    /**
     * The controller is the servlet path up to the action.
     */
    public final String controller;

    /**
     * The action is the last part of the servlet path (before any query arguments)
     */
    public final String action;

    /**
     * Tells if this request has multipart content (ie file upload)
     */
    public final boolean hasMultipartContent;

    /**
     * Parameter value indicating that the real parameter value is binary (and should be
     * accessed via the getAttribute() method.
     */
    public static final String BINARY_VALUE = ""BINARY_VALUE"";

    /**
     * The 'flash' map for holding temporary key/value strings.
     */
    public final Map<String, String> flash;

    /**
     * Holds cached page generator fragments
     */
    private static Map<String, String> cacheMap;

    /**
     * Constructor for JVCRequestContext which is used to hold http request and response iformation
     * @param request
     * @param response
     * @param servlet
     * @param flash
     * @param controller
     * @param action
     */
    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map<String, String> flash, String controller, String action) throws Exception {
        this.request = request;
        this.response = response;
        this.servlet = servlet;
        this.controller = controller;
        this.action = action;
        this.flash = flash;
        hasMultipartContent = ServletFileUpload.isMultipartContent(request);
        if (hasMultipartContent) {
            // Create a new file upload handler
            ServletFileUpload upload = new ServletFileUpload();
            // Parse the request
            FileItemIterator iter = upload.getItemIterator(request);
            while (iter.hasNext()) {
                FileItemStream item = iter.next();
                String name = item.getFieldName();
                InputStream stream = item.openStream();
                if (item.isFormField()) {
                    // add parameter as request attribute
                    String val = Streams.asString(stream);
                    request.setAttribute(name, val);
                    // System.out.println(""Form field "" + name + "" with value "" + val + "" detected."");
                } else {
                    // add input stream and filename as attributes
                    String fileName = item.getName();
                    request.setAttribute(""fileName"", fileName);
                    byte[] data = readStream(stream);
                    request.setAttribute(name, data);
                    // System.out.println(""File field "" + name + "" with file name "" + fileName + "" detected."");
                }
            }
        }
    }

    // request info
    /**
     * Convenience method
     * @return true if the request is secure
     */
    public boolean isSecure() {
        return request.isSecure();
    }

    /**
     * Convenience method
     * @return the request scheme, ie. http, https
     */
    public String getScheme() {
        return request.getScheme();
    }

    /**
     * Convenience method
     * @return the request method, ie. GET, POST
     */
    public String getMethod() {
        return request.getMethod();
    }

    /**
     * Convenience method
     * @return the server name for this request
     */
    public String getServerName() {
        return request.getServerName();
    }

    /**
     * Convenience method
     * @return the server port for this request
     */
    public int getServerPort() {
        return request.getServerPort();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getServletPath
     * @see #getQueryString
     * @return the context path part of the url path
     */
    public String getContextPath() {
        return request.getContextPath();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getContextPath
     * @see #getQueryString
     * @return the servlet path part of the url path
     */
    public String getServletPath() {
        return request.getServletPath();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getContextPath
     * @see #getServletPath
     * @return the query string part of the url path
     */
    public String getQueryString() {
        return request.getQueryString();
    }

    // params
    /**
     * Convenience method
     * @param name    which parameter to get
     * @return the parameter value or null if there is no parameter corresponding to the indicated key
     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,
     * which can be retrieved as a byte array via the getAttribute method.
     * @see #getParamMap
     * @see #getParamValues
     * @see #getParamNames
     */
    public String getParam(String name) {
        if (hasMultipartContent) {
            Object o = request.getAttribute(name);
            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;
        } else {
            return request.getParameter(name);
        }
    }

    /**
     * Convenience method which gathers all parameters of the
     * form '<name>[<key>]' and return then in a map where the
     * keys are the <key> strings and the values are the
     * corresponding parameter values.
     * <pre>
     * For example, if there are parameters:
     *   'foo[bar1]' = 'baz1'
     *   'foo[bar2]' = 'baz2'
     * then getParamMap('foo') will returned the map:
     *   map['bar1'] = 'baz1'
     *   map['bar2'] = 'baz2'
     * </pre>
     * @param name  the prefix to be used to select parameters
     * @return a map of all paramters of the form 'name[<key>]'
     * where the <key> strings are the keys of the map and the
     * values are the corresponding parameter values.
     * @see #getParam
     * @see #getParamValues
     * @see #getParamNames
     */
    public Map<String, String> getParamMap(String name) {
        Map<String, String> m = new HashMap<String, String>();
        String prefix = name + ""["";
        int n = prefix.length();
        if (hasMultipartContent) {
            // for multipart requests the parameters have been stored as attributes (see constructor)
            Enumeration<String> e = request.getAttributeNames();
            while (e.hasMoreElements()) {
                String key = e.nextElement();
                if (key.startsWith(prefix) && key.endsWith(""]"")) {
                    m.put(key.substring(n, key.length() - 1), getParam(key));
                }
            }
        } else {
            Map<String, String[]> pm = request.getParameterMap();
            for (String key : pm.keySet()) {
                if (key.startsWith(prefix) && key.endsWith(""]"")) {
                    m.put(key.substring(n, key.length() - 1), getParam(key));
                }
            }
        }
        return m;
    }

    /**
     * Convenience method. Use this if you expect a parameter name
     * to map to multiple values.
     * @param name    the name of the parameter(s) to get
     * @return an array of paramter values corresponding to the indicated name
     * @see #getParam
     * @see #getParamMap
     * @see #getParamNames
     */
    public String[] getParamValues(String name) {
        return request.getParameterValues(name);
    }

    /**
     * Convenience method to get all the parameter names.
     * @return an array of all parameter names
     * @see #getParam
     * @see #getParamMap
     * @see #getParamValues
     */
    public String[] getParamNames() {
        if (hasMultipartContent) {
            List<String> list = new ArrayList<String>();
            Enumeration<String> e = request.getAttributeNames();
            while (e.hasMoreElements()) {
                list.add(e.nextElement());
            }
            return list.toArray(new String[list.size()]);
        } else {
            Map<String, String[]> m = request.getParameterMap();
            String[] a = new String[m.size()];
            int i = 0;
            for (String key : m.keySet()) {
                a[i++] = key;
            }
            return a;
        }
    }

    // attributes
    /**
     * Convenience method
     * @param name    which attribute to get
     * @return the attribute value or null if there is no attribute corresponding to the indicated key.
     * If the attribute corresponds to a file upload field then the return value will be a byte array
     */
    public Object getAttribute(String name) {
        return request.getAttribute(name);
    }

    /**
     * Convenience method
     * @param name    name of attribute to be set
     * @param value   value of attribute to be set
     */
    public void setAttribute(String name, Object value) {
        request.setAttribute(name, value);
    }

    // session attributes
    /**
     * Convenience method
     * @param name    the name of the attribute to retrieve
     * @return the attribute associated with the indicated name or null
     * @see #setSessionAttr
     * @see #getSessionAttrNames
     */
    public Object getSessionAttr(String name) {
        if (request.getSession() == null)
            return null;
        return request.getSession().getAttribute(name);
    }

    /**
     * Convenience method
     * @return all the session attribute names.
     * @see #getSessionAttr
     * @see #setSessionAttr
     * @see #removeSessionAttr
     */
    public String[] getSessionAttrNames() {
        if (request.getSession(false) == null)
            return new String[0];
        ArrayList<String> a = new ArrayList<String>();
        Enumeration<String> e = request.getSession().getAttributeNames();
        while (e.hasMoreElements()) {
            a.add(e.nextElement());
        }
        return a.toArray(new String[a.size()]);
    }

    /**
     * Convenience method
     * @param name  the key to store the indicated value
     * @param value  the object to be stored
     * @see #getSessionAttr
     * @see #removeSessionAttr
     */
    public void setSessionAttr(String name, Object value) {
        if (request.getSession() == null)
            return;
        request.getSession().setAttribute(name, value);
    }

    /**
     * Convenience method
     * @param name  the key of
     * @see #setSessionAttr
     */
    public void removeSessionAttr(String name) {
        if (request.getSession() == null)
            return;
        request.getSession().removeAttribute(name);
    }

    // cookies
    /**
     * Convenience method to get cookie by name
     * @param name  the name of the cookie to get
     * @return the cookie with the indicated name, or null
     * @see #setCookie
     * @see #getCookieNames
     */
    public Cookie getCookie(String name) {
        if (name == null)
            return null;
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return null;
        for (Cookie c : cookies) {
            if (name.equals(c.getName()))
                return c;
        }
        return null;
    }

    /**
     * Convenience method to get all the cookie names.
     * @return an array of the names of all the cookies in the request, possibly empty
     * @see #getCookie
     * @see #setCookie
     */
    public String[] getCookieNames() {
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return new String[0];
        String[] a = new String[cookies.length];
        int i = 0;
        for (Cookie c : cookies) {
            a[i++] = c.getName();
        }
        return a;
    }

    /**
     * Convenience method
     * @param cookie   the cookie to be added to the response
     * @see #getCookie
     * @see #getCookieNames
     */
    public void setCookie(Cookie cookie) {
        response.addCookie(cookie);
    }

    /**
     * Cause a non-standard response (ie. redirect) to be returned.
     * @param httpCode   the http response code to be returned
     * @param arg    an argument or message to be returned (depends on response code)
     * @see #redirect
     * @throws NonStandardResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the NonStandardResponseException.
     */
    public void nonStandardResponse(int httpCode, String arg) {
        throw new NonStandardResponseException(httpCode, arg);
    }

    /**
     * Cause a redirect response to be returned
     * @param path  where to redirect to. If the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @see #nonStandardResponse
     * @throws NonStandardResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the NonStandardResponseException.
     */
    public void redirect(String path) {
        if (path.startsWith(""/""))
            path = absPath(path);
        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);
    }

    /**
     * Cause a binary response to be returned
     * @param in input stream containing binary data to be sent
     * @throws BinaryResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the BinaryResponseException.
     */
    public void sendBinaryResponse(InputStream in) {
        throw new BinaryResponseException(in);
    }

    /**
     * Convenience method to prepend the context path onto a servlet path
     * @param path    a servlet path
     * @return the context path plus the indicated path
     */
    public String absPath(String path) {
        return getContextPath() + (path.startsWith(""/"") ? path : ""/"" + path);
    }

    /**
     * Convenience method to create an html anchor link tag
     * @param anchor    the text in an anchor link
     * @param path   the anchor target, if the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @see #makeLink
     * @see #absPath
     */
    public String makeLink(String anchor, String path) {
        return makeLink(anchor, path, """");
    }

    /**
     * Convenience method to create an html anchor link tag
     * @param anchor    the text in an anchor link
     * @param path   the anchor target, if the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @param options    extra html options to add to the anchor tag
     * @see #makeLink
     * @see #absPath
     */
    public String makeLink(String anchor, String path, String options) {
        if (path.startsWith(""/""))
            path = absPath(path);
        return ""<a href='"" + path + ""' "" + options + "">"" + anchor + ""</a>"";
    }

    /**
     * Convenience method to check if this request is a POST
     */
    public boolean isPost() {
        return ""POST"".equals(request.getMethod());
    }

    /**
     * Convenience method to check if this request is a GET
     */
    public boolean isGet() {
        return ""GET"".equals(request.getMethod());
    }

    /**
     * Convenience method to retrieve a value from the flash
     * @param key  the key to use to lookup a flash value
     * @return the flash value associated with the indicated key or null
     * @see #setFlash
     */
    public String getFlash(String key) {
        return flash.get(key);
    }

    /**
     * Convenience method to add a value to the flash
     * @param key  the key to use to associate with the flash value
     * @param val  the value to store
     * @see #getFlash
     */
    public void setFlash(String key, String val) {
        flash.put(key, val);
    }

    // caching (internal use)
    /**
     * Internal method used to retrieve a cached block
     * @see #setCachedBlock
     */
    public static String getCachedBlock(String key) {
        return (cacheMap == null) ? null : cacheMap.get(key);
    }

    /**
     * Internal method used to store a cached block
     * @see #getCachedBlock
     */
    public static void setCachedBlock(String key, String val) {
        if (cacheMap == null) {
            cacheMap = new HashMap<String, String>();
        }
        cacheMap.put(key, val);
    }

    /**
     * For debugging
     * @return a string representation of this request context
     */
    public String toString() {
        return toString("", "");
    }

    public String toString(String sep) {
        StringBuilder sb = new StringBuilder();
        sb.append(""params: ["");
        String[] keys = getParamNames();
        for (String key : keys) {
            sb.append(key).append('=').append(getParam(key)).append(sep);
        }
        if (keys.length > 0) {
            sb.setLength(sb.length() - sep.length());
        }
        sb.append(""]"");
        sb.append(sep).append(""method: "").append(getMethod());
        sb.append(sep).append(""url: "").append(getScheme());
        sb.append(""|"").append(getServerName());
        sb.append(""|"").append(getServerPort());
        sb.append(""|"").append(getContextPath());
        sb.append(""|"").append(getServletPath());
        sb.append(""|"").append(getQueryString());
        if (hasMultipartContent) {
            sb.append(sep).append(""content len: "").append(request.getContentLength());
            //sb.append(sep).append(""content type: "").append(request.getContentType());
        }
        return sb.toString();
    }

    /**
     * Copy an input stream to an output stream.
     */
    private byte[] readStream(InputStream in) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        byte[] buf = new byte[4096];
        int read;
        while ((read = in.read(buf)) > -1) {
            out.write(buf, 0, read);
        }
        out.flush();
        return out.toByteArray();
    }
}
","// JVCRequestContext_1Test.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JVCRequestContext}.
* It contains ten unit test cases for the {@link JVCRequestContext#getParamMap(String)} method.
*/
class JVCRequestContext_1Test {","```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class JVCRequestContext_1Test {

    @Test
    void testGetParamMap() {
        // Test case 1
        JVCRequestContext requestContext = createRequestContext(""foo[bar1]=baz1&foo[bar2]=baz2"");
        Map<String, String> paramMap = requestContext.getParamMap(""foo"");
        assertEquals(2, paramMap.size());
        assertEquals(""baz1"", paramMap.get(""bar1""));
        assertEquals(""baz2"", paramMap.get(""bar2"");

        // Test case 2
        requestContext = createRequestContext(""foo[bar1]=baz1&foo[bar2]=baz2&foo[bar3]=baz3"");
        paramMap = requestContext.getParamMap(""foo"");
        assertEquals(3, paramMap.size());
        assertEquals(""baz1"", paramMap.get(""bar1""));
        assertEquals(""baz2"", paramMap.get(""bar2""));
        assertEquals(""baz3"", paramMap.get(""bar3""));
    }

    private JVCRequestContext createRequestContext(String queryString) {
        // Mock HttpServletRequest and HttpServletResponse
        HttpServletRequest request = new MockHttpServletRequest(queryString);
        HttpServletResponse response = new MockHttpServletResponse();
        HttpServlet servlet = new HttpServlet();
        Map<String, String> flash = new HashMap<>();
        String controller = ""TestController"";
        String action = ""testAction"";

        try {
            return new JVCRequestContext(request, response, servlet, flash, controller, action);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}
```
```java
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;

class MockHttpServletRequest implements HttpServletRequest {
    private final String queryString;

    public MockHttpServletRequest(String queryString) {
        this.queryString = queryString;
    }

    @Override
    public String getQueryString() {
        return queryString;
    }

    // Implement other methods of HttpServletRequest interface
}

class MockHttpServletResponse implements HttpServletResponse {
    // Implement methods of HttpServletResponse interface
}
```"
chatcmpl-A5USzrgSC14bUQbCw7HyKJk419L87,/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContext_2Test.java,4.422604084014893,stop,"// JVCRequestContext.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

/**
 * This class contains state information for processing an http request.
 * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet
 * objects and provides convenience methods for accessing them.
 * <p>
 * It also provides access to the 'flash' which is a Map for storing temporary
 * key/value strings.  The scope of the flash is the current request or
 * the following request in the case of a redirect response.
 * <p>
 * It also contains some convenience methods for forming links and absolute paths.
 *
 * @author mike dooley
 */
public final class JVCRequestContext {

    /**
     * The actual HttpServletRequest object
     */
    public final HttpServletRequest request;

    /**
     * The actual HttpServletResponse object
     */
    public final HttpServletResponse response;

    /**
     * The HttpServlet object (actually this is a JVCDispatcher)
     */
    public final HttpServlet servlet;

    /**
     * The controller is the servlet path up to the action.
     */
    public final String controller;

    /**
     * The action is the last part of the servlet path (before any query arguments)
     */
    public final String action;

    /**
     * Tells if this request has multipart content (ie file upload)
     */
    public final boolean hasMultipartContent;

    /**
     * Parameter value indicating that the real parameter value is binary (and should be
     * accessed via the getAttribute() method.
     */
    public static final String BINARY_VALUE = ""BINARY_VALUE"";

    /**
     * The 'flash' map for holding temporary key/value strings.
     */
    public final Map<String, String> flash;

    /**
     * Holds cached page generator fragments
     */
    private static Map<String, String> cacheMap;

    /**
     * Constructor for JVCRequestContext which is used to hold http request and response iformation
     * @param request
     * @param response
     * @param servlet
     * @param flash
     * @param controller
     * @param action
     */
    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map<String, String> flash, String controller, String action) throws Exception {
        this.request = request;
        this.response = response;
        this.servlet = servlet;
        this.controller = controller;
        this.action = action;
        this.flash = flash;
        hasMultipartContent = ServletFileUpload.isMultipartContent(request);
        if (hasMultipartContent) {
            // Create a new file upload handler
            ServletFileUpload upload = new ServletFileUpload();
            // Parse the request
            FileItemIterator iter = upload.getItemIterator(request);
            while (iter.hasNext()) {
                FileItemStream item = iter.next();
                String name = item.getFieldName();
                InputStream stream = item.openStream();
                if (item.isFormField()) {
                    // add parameter as request attribute
                    String val = Streams.asString(stream);
                    request.setAttribute(name, val);
                    // System.out.println(""Form field "" + name + "" with value "" + val + "" detected."");
                } else {
                    // add input stream and filename as attributes
                    String fileName = item.getName();
                    request.setAttribute(""fileName"", fileName);
                    byte[] data = readStream(stream);
                    request.setAttribute(name, data);
                    // System.out.println(""File field "" + name + "" with file name "" + fileName + "" detected."");
                }
            }
        }
    }

    // request info
    /**
     * Convenience method
     * @return true if the request is secure
     */
    public boolean isSecure() {
        return request.isSecure();
    }

    /**
     * Convenience method
     * @return the request scheme, ie. http, https
     */
    public String getScheme() {
        return request.getScheme();
    }

    /**
     * Convenience method
     * @return the request method, ie. GET, POST
     */
    public String getMethod() {
        return request.getMethod();
    }

    /**
     * Convenience method
     * @return the server name for this request
     */
    public String getServerName() {
        return request.getServerName();
    }

    /**
     * Convenience method
     * @return the server port for this request
     */
    public int getServerPort() {
        return request.getServerPort();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getServletPath
     * @see #getQueryString
     * @return the context path part of the url path
     */
    public String getContextPath() {
        return request.getContextPath();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getContextPath
     * @see #getQueryString
     * @return the servlet path part of the url path
     */
    public String getServletPath() {
        return request.getServletPath();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getContextPath
     * @see #getServletPath
     * @return the query string part of the url path
     */
    public String getQueryString() {
        return request.getQueryString();
    }

    // params
    /**
     * Convenience method
     * @param name    which parameter to get
     * @return the parameter value or null if there is no parameter corresponding to the indicated key
     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,
     * which can be retrieved as a byte array via the getAttribute method.
     * @see #getParamMap
     * @see #getParamValues
     * @see #getParamNames
     */
    public String getParam(String name) {
        if (hasMultipartContent) {
            Object o = request.getAttribute(name);
            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;
        } else {
            return request.getParameter(name);
        }
    }

    /**
     * Convenience method which gathers all parameters of the
     * form '<name>[<key>]' and return then in a map where the
     * keys are the <key> strings and the values are the
     * corresponding parameter values.
     * <pre>
     * For example, if there are parameters:
     *   'foo[bar1]' = 'baz1'
     *   'foo[bar2]' = 'baz2'
     * then getParamMap('foo') will returned the map:
     *   map['bar1'] = 'baz1'
     *   map['bar2'] = 'baz2'
     * </pre>
     * @param name  the prefix to be used to select parameters
     * @return a map of all paramters of the form 'name[<key>]'
     * where the <key> strings are the keys of the map and the
     * values are the corresponding parameter values.
     * @see #getParam
     * @see #getParamValues
     * @see #getParamNames
     */
    public Map<String, String> getParamMap(String name) {
        Map<String, String> m = new HashMap<String, String>();
        String prefix = name + ""["";
        int n = prefix.length();
        if (hasMultipartContent) {
            // for multipart requests the parameters have been stored as attributes (see constructor)
            Enumeration<String> e = request.getAttributeNames();
            while (e.hasMoreElements()) {
                String key = e.nextElement();
                if (key.startsWith(prefix) && key.endsWith(""]"")) {
                    m.put(key.substring(n, key.length() - 1), getParam(key));
                }
            }
        } else {
            Map<String, String[]> pm = request.getParameterMap();
            for (String key : pm.keySet()) {
                if (key.startsWith(prefix) && key.endsWith(""]"")) {
                    m.put(key.substring(n, key.length() - 1), getParam(key));
                }
            }
        }
        return m;
    }

    /**
     * Convenience method. Use this if you expect a parameter name
     * to map to multiple values.
     * @param name    the name of the parameter(s) to get
     * @return an array of paramter values corresponding to the indicated name
     * @see #getParam
     * @see #getParamMap
     * @see #getParamNames
     */
    public String[] getParamValues(String name) {
        return request.getParameterValues(name);
    }

    /**
     * Convenience method to get all the parameter names.
     * @return an array of all parameter names
     * @see #getParam
     * @see #getParamMap
     * @see #getParamValues
     */
    public String[] getParamNames() {
        if (hasMultipartContent) {
            List<String> list = new ArrayList<String>();
            Enumeration<String> e = request.getAttributeNames();
            while (e.hasMoreElements()) {
                list.add(e.nextElement());
            }
            return list.toArray(new String[list.size()]);
        } else {
            Map<String, String[]> m = request.getParameterMap();
            String[] a = new String[m.size()];
            int i = 0;
            for (String key : m.keySet()) {
                a[i++] = key;
            }
            return a;
        }
    }

    // attributes
    /**
     * Convenience method
     * @param name    which attribute to get
     * @return the attribute value or null if there is no attribute corresponding to the indicated key.
     * If the attribute corresponds to a file upload field then the return value will be a byte array
     */
    public Object getAttribute(String name) {
        return request.getAttribute(name);
    }

    /**
     * Convenience method
     * @param name    name of attribute to be set
     * @param value   value of attribute to be set
     */
    public void setAttribute(String name, Object value) {
        request.setAttribute(name, value);
    }

    // session attributes
    /**
     * Convenience method
     * @param name    the name of the attribute to retrieve
     * @return the attribute associated with the indicated name or null
     * @see #setSessionAttr
     * @see #getSessionAttrNames
     */
    public Object getSessionAttr(String name) {
        if (request.getSession() == null)
            return null;
        return request.getSession().getAttribute(name);
    }

    /**
     * Convenience method
     * @return all the session attribute names.
     * @see #getSessionAttr
     * @see #setSessionAttr
     * @see #removeSessionAttr
     */
    public String[] getSessionAttrNames() {
        if (request.getSession(false) == null)
            return new String[0];
        ArrayList<String> a = new ArrayList<String>();
        Enumeration<String> e = request.getSession().getAttributeNames();
        while (e.hasMoreElements()) {
            a.add(e.nextElement());
        }
        return a.toArray(new String[a.size()]);
    }

    /**
     * Convenience method
     * @param name  the key to store the indicated value
     * @param value  the object to be stored
     * @see #getSessionAttr
     * @see #removeSessionAttr
     */
    public void setSessionAttr(String name, Object value) {
        if (request.getSession() == null)
            return;
        request.getSession().setAttribute(name, value);
    }

    /**
     * Convenience method
     * @param name  the key of
     * @see #setSessionAttr
     */
    public void removeSessionAttr(String name) {
        if (request.getSession() == null)
            return;
        request.getSession().removeAttribute(name);
    }

    // cookies
    /**
     * Convenience method to get cookie by name
     * @param name  the name of the cookie to get
     * @return the cookie with the indicated name, or null
     * @see #setCookie
     * @see #getCookieNames
     */
    public Cookie getCookie(String name) {
        if (name == null)
            return null;
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return null;
        for (Cookie c : cookies) {
            if (name.equals(c.getName()))
                return c;
        }
        return null;
    }

    /**
     * Convenience method to get all the cookie names.
     * @return an array of the names of all the cookies in the request, possibly empty
     * @see #getCookie
     * @see #setCookie
     */
    public String[] getCookieNames() {
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return new String[0];
        String[] a = new String[cookies.length];
        int i = 0;
        for (Cookie c : cookies) {
            a[i++] = c.getName();
        }
        return a;
    }

    /**
     * Convenience method
     * @param cookie   the cookie to be added to the response
     * @see #getCookie
     * @see #getCookieNames
     */
    public void setCookie(Cookie cookie) {
        response.addCookie(cookie);
    }

    /**
     * Cause a non-standard response (ie. redirect) to be returned.
     * @param httpCode   the http response code to be returned
     * @param arg    an argument or message to be returned (depends on response code)
     * @see #redirect
     * @throws NonStandardResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the NonStandardResponseException.
     */
    public void nonStandardResponse(int httpCode, String arg) {
        throw new NonStandardResponseException(httpCode, arg);
    }

    /**
     * Cause a redirect response to be returned
     * @param path  where to redirect to. If the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @see #nonStandardResponse
     * @throws NonStandardResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the NonStandardResponseException.
     */
    public void redirect(String path) {
        if (path.startsWith(""/""))
            path = absPath(path);
        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);
    }

    /**
     * Cause a binary response to be returned
     * @param in input stream containing binary data to be sent
     * @throws BinaryResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the BinaryResponseException.
     */
    public void sendBinaryResponse(InputStream in) {
        throw new BinaryResponseException(in);
    }

    /**
     * Convenience method to prepend the context path onto a servlet path
     * @param path    a servlet path
     * @return the context path plus the indicated path
     */
    public String absPath(String path) {
        return getContextPath() + (path.startsWith(""/"") ? path : ""/"" + path);
    }

    /**
     * Convenience method to create an html anchor link tag
     * @param anchor    the text in an anchor link
     * @param path   the anchor target, if the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @see #makeLink
     * @see #absPath
     */
    public String makeLink(String anchor, String path) {
        return makeLink(anchor, path, """");
    }

    /**
     * Convenience method to create an html anchor link tag
     * @param anchor    the text in an anchor link
     * @param path   the anchor target, if the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @param options    extra html options to add to the anchor tag
     * @see #makeLink
     * @see #absPath
     */
    public String makeLink(String anchor, String path, String options) {
        if (path.startsWith(""/""))
            path = absPath(path);
        return ""<a href='"" + path + ""' "" + options + "">"" + anchor + ""</a>"";
    }

    /**
     * Convenience method to check if this request is a POST
     */
    public boolean isPost() {
        return ""POST"".equals(request.getMethod());
    }

    /**
     * Convenience method to check if this request is a GET
     */
    public boolean isGet() {
        return ""GET"".equals(request.getMethod());
    }

    /**
     * Convenience method to retrieve a value from the flash
     * @param key  the key to use to lookup a flash value
     * @return the flash value associated with the indicated key or null
     * @see #setFlash
     */
    public String getFlash(String key) {
        return flash.get(key);
    }

    /**
     * Convenience method to add a value to the flash
     * @param key  the key to use to associate with the flash value
     * @param val  the value to store
     * @see #getFlash
     */
    public void setFlash(String key, String val) {
        flash.put(key, val);
    }

    // caching (internal use)
    /**
     * Internal method used to retrieve a cached block
     * @see #setCachedBlock
     */
    public static String getCachedBlock(String key) {
        return (cacheMap == null) ? null : cacheMap.get(key);
    }

    /**
     * Internal method used to store a cached block
     * @see #getCachedBlock
     */
    public static void setCachedBlock(String key, String val) {
        if (cacheMap == null) {
            cacheMap = new HashMap<String, String>();
        }
        cacheMap.put(key, val);
    }

    /**
     * For debugging
     * @return a string representation of this request context
     */
    public String toString() {
        return toString("", "");
    }

    public String toString(String sep) {
        StringBuilder sb = new StringBuilder();
        sb.append(""params: ["");
        String[] keys = getParamNames();
        for (String key : keys) {
            sb.append(key).append('=').append(getParam(key)).append(sep);
        }
        if (keys.length > 0) {
            sb.setLength(sb.length() - sep.length());
        }
        sb.append(""]"");
        sb.append(sep).append(""method: "").append(getMethod());
        sb.append(sep).append(""url: "").append(getScheme());
        sb.append(""|"").append(getServerName());
        sb.append(""|"").append(getServerPort());
        sb.append(""|"").append(getContextPath());
        sb.append(""|"").append(getServletPath());
        sb.append(""|"").append(getQueryString());
        if (hasMultipartContent) {
            sb.append(sep).append(""content len: "").append(request.getContentLength());
            //sb.append(sep).append(""content type: "").append(request.getContentType());
        }
        return sb.toString();
    }

    /**
     * Copy an input stream to an output stream.
     */
    private byte[] readStream(InputStream in) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        byte[] buf = new byte[4096];
        int read;
        while ((read = in.read(buf)) > -1) {
            out.write(buf, 0, read);
        }
        out.flush();
        return out.toByteArray();
    }
}
","// JVCRequestContext_2Test.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JVCRequestContext}.
* It contains ten unit test cases for the {@link JVCRequestContext#getParamValues(String)} method.
*/
class JVCRequestContext_2Test {","```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class JVCRequestContext_2Test {

    @Test
    void testGetParamValues() {
        JVCRequestContext requestContext = createMockRequestContext();
        
        // Test case 1: Parameter with single value
        String[] values1 = requestContext.getParamValues(""param1"");
        assertEquals(1, values1.length);
        assertEquals(""value1"", values1[0]);
        
        // Test case 2: Parameter with multiple values
        String[] values2 = requestContext.getParamValues(""param2"");
        assertEquals(3, values2.length);
        assertEquals(""value2"", values2[0]);
        assertEquals(""value3"", values2[1]);
        assertEquals(""value4"", values2[2]);
        
        // Test case 3: Non-existent parameter
        String[] values3 = requestContext.getParamValues(""nonexistent"");
        assertNull(values3);
    }

    private JVCRequestContext createMockRequestContext() {
        // Create a mock JVCRequestContext for testing
        // You can customize this method to create a mock with specific parameter values
        return new JVCRequestContext(null, null, null, null, null, null);
    }
}
```
```"
chatcmpl-A5UU2P5NjIjNwGR2nHxIOdMKJ2d58,/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContext_3Test.java,4.614064455032349,stop,"// JVCRequestContext.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

/**
 * This class contains state information for processing an http request.
 * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet
 * objects and provides convenience methods for accessing them.
 * <p>
 * It also provides access to the 'flash' which is a Map for storing temporary
 * key/value strings.  The scope of the flash is the current request or
 * the following request in the case of a redirect response.
 * <p>
 * It also contains some convenience methods for forming links and absolute paths.
 *
 * @author mike dooley
 */
public final class JVCRequestContext {

    /**
     * The actual HttpServletRequest object
     */
    public final HttpServletRequest request;

    /**
     * The actual HttpServletResponse object
     */
    public final HttpServletResponse response;

    /**
     * The HttpServlet object (actually this is a JVCDispatcher)
     */
    public final HttpServlet servlet;

    /**
     * The controller is the servlet path up to the action.
     */
    public final String controller;

    /**
     * The action is the last part of the servlet path (before any query arguments)
     */
    public final String action;

    /**
     * Tells if this request has multipart content (ie file upload)
     */
    public final boolean hasMultipartContent;

    /**
     * Parameter value indicating that the real parameter value is binary (and should be
     * accessed via the getAttribute() method.
     */
    public static final String BINARY_VALUE = ""BINARY_VALUE"";

    /**
     * The 'flash' map for holding temporary key/value strings.
     */
    public final Map<String, String> flash;

    /**
     * Holds cached page generator fragments
     */
    private static Map<String, String> cacheMap;

    /**
     * Constructor for JVCRequestContext which is used to hold http request and response iformation
     * @param request
     * @param response
     * @param servlet
     * @param flash
     * @param controller
     * @param action
     */
    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map<String, String> flash, String controller, String action) throws Exception {
        this.request = request;
        this.response = response;
        this.servlet = servlet;
        this.controller = controller;
        this.action = action;
        this.flash = flash;
        hasMultipartContent = ServletFileUpload.isMultipartContent(request);
        if (hasMultipartContent) {
            // Create a new file upload handler
            ServletFileUpload upload = new ServletFileUpload();
            // Parse the request
            FileItemIterator iter = upload.getItemIterator(request);
            while (iter.hasNext()) {
                FileItemStream item = iter.next();
                String name = item.getFieldName();
                InputStream stream = item.openStream();
                if (item.isFormField()) {
                    // add parameter as request attribute
                    String val = Streams.asString(stream);
                    request.setAttribute(name, val);
                    // System.out.println(""Form field "" + name + "" with value "" + val + "" detected."");
                } else {
                    // add input stream and filename as attributes
                    String fileName = item.getName();
                    request.setAttribute(""fileName"", fileName);
                    byte[] data = readStream(stream);
                    request.setAttribute(name, data);
                    // System.out.println(""File field "" + name + "" with file name "" + fileName + "" detected."");
                }
            }
        }
    }

    // request info
    /**
     * Convenience method
     * @return true if the request is secure
     */
    public boolean isSecure() {
        return request.isSecure();
    }

    /**
     * Convenience method
     * @return the request scheme, ie. http, https
     */
    public String getScheme() {
        return request.getScheme();
    }

    /**
     * Convenience method
     * @return the request method, ie. GET, POST
     */
    public String getMethod() {
        return request.getMethod();
    }

    /**
     * Convenience method
     * @return the server name for this request
     */
    public String getServerName() {
        return request.getServerName();
    }

    /**
     * Convenience method
     * @return the server port for this request
     */
    public int getServerPort() {
        return request.getServerPort();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getServletPath
     * @see #getQueryString
     * @return the context path part of the url path
     */
    public String getContextPath() {
        return request.getContextPath();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getContextPath
     * @see #getQueryString
     * @return the servlet path part of the url path
     */
    public String getServletPath() {
        return request.getServletPath();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getContextPath
     * @see #getServletPath
     * @return the query string part of the url path
     */
    public String getQueryString() {
        return request.getQueryString();
    }

    // params
    /**
     * Convenience method
     * @param name    which parameter to get
     * @return the parameter value or null if there is no parameter corresponding to the indicated key
     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,
     * which can be retrieved as a byte array via the getAttribute method.
     * @see #getParamMap
     * @see #getParamValues
     * @see #getParamNames
     */
    public String getParam(String name) {
        if (hasMultipartContent) {
            Object o = request.getAttribute(name);
            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;
        } else {
            return request.getParameter(name);
        }
    }

    /**
     * Convenience method which gathers all parameters of the
     * form '<name>[<key>]' and return then in a map where the
     * keys are the <key> strings and the values are the
     * corresponding parameter values.
     * <pre>
     * For example, if there are parameters:
     *   'foo[bar1]' = 'baz1'
     *   'foo[bar2]' = 'baz2'
     * then getParamMap('foo') will returned the map:
     *   map['bar1'] = 'baz1'
     *   map['bar2'] = 'baz2'
     * </pre>
     * @param name  the prefix to be used to select parameters
     * @return a map of all paramters of the form 'name[<key>]'
     * where the <key> strings are the keys of the map and the
     * values are the corresponding parameter values.
     * @see #getParam
     * @see #getParamValues
     * @see #getParamNames
     */
    public Map<String, String> getParamMap(String name) {
        Map<String, String> m = new HashMap<String, String>();
        String prefix = name + ""["";
        int n = prefix.length();
        if (hasMultipartContent) {
            // for multipart requests the parameters have been stored as attributes (see constructor)
            Enumeration<String> e = request.getAttributeNames();
            while (e.hasMoreElements()) {
                String key = e.nextElement();
                if (key.startsWith(prefix) && key.endsWith(""]"")) {
                    m.put(key.substring(n, key.length() - 1), getParam(key));
                }
            }
        } else {
            Map<String, String[]> pm = request.getParameterMap();
            for (String key : pm.keySet()) {
                if (key.startsWith(prefix) && key.endsWith(""]"")) {
                    m.put(key.substring(n, key.length() - 1), getParam(key));
                }
            }
        }
        return m;
    }

    /**
     * Convenience method. Use this if you expect a parameter name
     * to map to multiple values.
     * @param name    the name of the parameter(s) to get
     * @return an array of paramter values corresponding to the indicated name
     * @see #getParam
     * @see #getParamMap
     * @see #getParamNames
     */
    public String[] getParamValues(String name) {
        return request.getParameterValues(name);
    }

    /**
     * Convenience method to get all the parameter names.
     * @return an array of all parameter names
     * @see #getParam
     * @see #getParamMap
     * @see #getParamValues
     */
    public String[] getParamNames() {
        if (hasMultipartContent) {
            List<String> list = new ArrayList<String>();
            Enumeration<String> e = request.getAttributeNames();
            while (e.hasMoreElements()) {
                list.add(e.nextElement());
            }
            return list.toArray(new String[list.size()]);
        } else {
            Map<String, String[]> m = request.getParameterMap();
            String[] a = new String[m.size()];
            int i = 0;
            for (String key : m.keySet()) {
                a[i++] = key;
            }
            return a;
        }
    }

    // attributes
    /**
     * Convenience method
     * @param name    which attribute to get
     * @return the attribute value or null if there is no attribute corresponding to the indicated key.
     * If the attribute corresponds to a file upload field then the return value will be a byte array
     */
    public Object getAttribute(String name) {
        return request.getAttribute(name);
    }

    /**
     * Convenience method
     * @param name    name of attribute to be set
     * @param value   value of attribute to be set
     */
    public void setAttribute(String name, Object value) {
        request.setAttribute(name, value);
    }

    // session attributes
    /**
     * Convenience method
     * @param name    the name of the attribute to retrieve
     * @return the attribute associated with the indicated name or null
     * @see #setSessionAttr
     * @see #getSessionAttrNames
     */
    public Object getSessionAttr(String name) {
        if (request.getSession() == null)
            return null;
        return request.getSession().getAttribute(name);
    }

    /**
     * Convenience method
     * @return all the session attribute names.
     * @see #getSessionAttr
     * @see #setSessionAttr
     * @see #removeSessionAttr
     */
    public String[] getSessionAttrNames() {
        if (request.getSession(false) == null)
            return new String[0];
        ArrayList<String> a = new ArrayList<String>();
        Enumeration<String> e = request.getSession().getAttributeNames();
        while (e.hasMoreElements()) {
            a.add(e.nextElement());
        }
        return a.toArray(new String[a.size()]);
    }

    /**
     * Convenience method
     * @param name  the key to store the indicated value
     * @param value  the object to be stored
     * @see #getSessionAttr
     * @see #removeSessionAttr
     */
    public void setSessionAttr(String name, Object value) {
        if (request.getSession() == null)
            return;
        request.getSession().setAttribute(name, value);
    }

    /**
     * Convenience method
     * @param name  the key of
     * @see #setSessionAttr
     */
    public void removeSessionAttr(String name) {
        if (request.getSession() == null)
            return;
        request.getSession().removeAttribute(name);
    }

    // cookies
    /**
     * Convenience method to get cookie by name
     * @param name  the name of the cookie to get
     * @return the cookie with the indicated name, or null
     * @see #setCookie
     * @see #getCookieNames
     */
    public Cookie getCookie(String name) {
        if (name == null)
            return null;
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return null;
        for (Cookie c : cookies) {
            if (name.equals(c.getName()))
                return c;
        }
        return null;
    }

    /**
     * Convenience method to get all the cookie names.
     * @return an array of the names of all the cookies in the request, possibly empty
     * @see #getCookie
     * @see #setCookie
     */
    public String[] getCookieNames() {
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return new String[0];
        String[] a = new String[cookies.length];
        int i = 0;
        for (Cookie c : cookies) {
            a[i++] = c.getName();
        }
        return a;
    }

    /**
     * Convenience method
     * @param cookie   the cookie to be added to the response
     * @see #getCookie
     * @see #getCookieNames
     */
    public void setCookie(Cookie cookie) {
        response.addCookie(cookie);
    }

    /**
     * Cause a non-standard response (ie. redirect) to be returned.
     * @param httpCode   the http response code to be returned
     * @param arg    an argument or message to be returned (depends on response code)
     * @see #redirect
     * @throws NonStandardResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the NonStandardResponseException.
     */
    public void nonStandardResponse(int httpCode, String arg) {
        throw new NonStandardResponseException(httpCode, arg);
    }

    /**
     * Cause a redirect response to be returned
     * @param path  where to redirect to. If the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @see #nonStandardResponse
     * @throws NonStandardResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the NonStandardResponseException.
     */
    public void redirect(String path) {
        if (path.startsWith(""/""))
            path = absPath(path);
        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);
    }

    /**
     * Cause a binary response to be returned
     * @param in input stream containing binary data to be sent
     * @throws BinaryResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the BinaryResponseException.
     */
    public void sendBinaryResponse(InputStream in) {
        throw new BinaryResponseException(in);
    }

    /**
     * Convenience method to prepend the context path onto a servlet path
     * @param path    a servlet path
     * @return the context path plus the indicated path
     */
    public String absPath(String path) {
        return getContextPath() + (path.startsWith(""/"") ? path : ""/"" + path);
    }

    /**
     * Convenience method to create an html anchor link tag
     * @param anchor    the text in an anchor link
     * @param path   the anchor target, if the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @see #makeLink
     * @see #absPath
     */
    public String makeLink(String anchor, String path) {
        return makeLink(anchor, path, """");
    }

    /**
     * Convenience method to create an html anchor link tag
     * @param anchor    the text in an anchor link
     * @param path   the anchor target, if the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @param options    extra html options to add to the anchor tag
     * @see #makeLink
     * @see #absPath
     */
    public String makeLink(String anchor, String path, String options) {
        if (path.startsWith(""/""))
            path = absPath(path);
        return ""<a href='"" + path + ""' "" + options + "">"" + anchor + ""</a>"";
    }

    /**
     * Convenience method to check if this request is a POST
     */
    public boolean isPost() {
        return ""POST"".equals(request.getMethod());
    }

    /**
     * Convenience method to check if this request is a GET
     */
    public boolean isGet() {
        return ""GET"".equals(request.getMethod());
    }

    /**
     * Convenience method to retrieve a value from the flash
     * @param key  the key to use to lookup a flash value
     * @return the flash value associated with the indicated key or null
     * @see #setFlash
     */
    public String getFlash(String key) {
        return flash.get(key);
    }

    /**
     * Convenience method to add a value to the flash
     * @param key  the key to use to associate with the flash value
     * @param val  the value to store
     * @see #getFlash
     */
    public void setFlash(String key, String val) {
        flash.put(key, val);
    }

    // caching (internal use)
    /**
     * Internal method used to retrieve a cached block
     * @see #setCachedBlock
     */
    public static String getCachedBlock(String key) {
        return (cacheMap == null) ? null : cacheMap.get(key);
    }

    /**
     * Internal method used to store a cached block
     * @see #getCachedBlock
     */
    public static void setCachedBlock(String key, String val) {
        if (cacheMap == null) {
            cacheMap = new HashMap<String, String>();
        }
        cacheMap.put(key, val);
    }

    /**
     * For debugging
     * @return a string representation of this request context
     */
    public String toString() {
        return toString("", "");
    }

    public String toString(String sep) {
        StringBuilder sb = new StringBuilder();
        sb.append(""params: ["");
        String[] keys = getParamNames();
        for (String key : keys) {
            sb.append(key).append('=').append(getParam(key)).append(sep);
        }
        if (keys.length > 0) {
            sb.setLength(sb.length() - sep.length());
        }
        sb.append(""]"");
        sb.append(sep).append(""method: "").append(getMethod());
        sb.append(sep).append(""url: "").append(getScheme());
        sb.append(""|"").append(getServerName());
        sb.append(""|"").append(getServerPort());
        sb.append(""|"").append(getContextPath());
        sb.append(""|"").append(getServletPath());
        sb.append(""|"").append(getQueryString());
        if (hasMultipartContent) {
            sb.append(sep).append(""content len: "").append(request.getContentLength());
            //sb.append(sep).append(""content type: "").append(request.getContentType());
        }
        return sb.toString();
    }

    /**
     * Copy an input stream to an output stream.
     */
    private byte[] readStream(InputStream in) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        byte[] buf = new byte[4096];
        int read;
        while ((read = in.read(buf)) > -1) {
            out.write(buf, 0, read);
        }
        out.flush();
        return out.toByteArray();
    }
}
","// JVCRequestContext_3Test.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JVCRequestContext}.
* It contains ten unit test cases for the {@link JVCRequestContext#getAttribute(String)} method.
*/
class JVCRequestContext_3Test {","```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class JVCRequestContext_3Test {

    @Test
    void testGetAttribute_Null() {
        JVCRequestContext context = new JVCRequestContext(null, null, null, null, null, null);
        assertNull(context.getAttribute(""test""));
    }

    @Test
    void testGetAttribute_NotNull() {
        HttpServletRequest request = mock(HttpServletRequest.class);
        when(request.getAttribute(""test"")).thenReturn(""value"");

        JVCRequestContext context = new JVCRequestContext(request, null, null, null, null, null);
        assertEquals(""value"", context.getAttribute(""test""));
    }

    @Test
    void testGetAttribute_FileUpload() {
        HttpServletRequest request = mock(HttpServletRequest.class);
        byte[] data = {0, 1, 2};
        when(request.getAttribute(""test"")).thenReturn(data);

        JVCRequestContext context = new JVCRequestContext(request, null, null, null, null, null);
        assertArrayEquals(data, (byte[]) context.getAttribute(""test""));
    }
}
```
"
chatcmpl-A5UV5BQr0oj6oApcN0CghK35h26F5,/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContext_4Test.java,15.499192476272583,stop,"// JVCRequestContext.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

/**
 * This class contains state information for processing an http request.
 * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet
 * objects and provides convenience methods for accessing them.
 * <p>
 * It also provides access to the 'flash' which is a Map for storing temporary
 * key/value strings.  The scope of the flash is the current request or
 * the following request in the case of a redirect response.
 * <p>
 * It also contains some convenience methods for forming links and absolute paths.
 *
 * @author mike dooley
 */
public final class JVCRequestContext {

    /**
     * The actual HttpServletRequest object
     */
    public final HttpServletRequest request;

    /**
     * The actual HttpServletResponse object
     */
    public final HttpServletResponse response;

    /**
     * The HttpServlet object (actually this is a JVCDispatcher)
     */
    public final HttpServlet servlet;

    /**
     * The controller is the servlet path up to the action.
     */
    public final String controller;

    /**
     * The action is the last part of the servlet path (before any query arguments)
     */
    public final String action;

    /**
     * Tells if this request has multipart content (ie file upload)
     */
    public final boolean hasMultipartContent;

    /**
     * Parameter value indicating that the real parameter value is binary (and should be
     * accessed via the getAttribute() method.
     */
    public static final String BINARY_VALUE = ""BINARY_VALUE"";

    /**
     * The 'flash' map for holding temporary key/value strings.
     */
    public final Map<String, String> flash;

    /**
     * Holds cached page generator fragments
     */
    private static Map<String, String> cacheMap;

    /**
     * Constructor for JVCRequestContext which is used to hold http request and response iformation
     * @param request
     * @param response
     * @param servlet
     * @param flash
     * @param controller
     * @param action
     */
    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map<String, String> flash, String controller, String action) throws Exception {
        this.request = request;
        this.response = response;
        this.servlet = servlet;
        this.controller = controller;
        this.action = action;
        this.flash = flash;
        hasMultipartContent = ServletFileUpload.isMultipartContent(request);
        if (hasMultipartContent) {
            // Create a new file upload handler
            ServletFileUpload upload = new ServletFileUpload();
            // Parse the request
            FileItemIterator iter = upload.getItemIterator(request);
            while (iter.hasNext()) {
                FileItemStream item = iter.next();
                String name = item.getFieldName();
                InputStream stream = item.openStream();
                if (item.isFormField()) {
                    // add parameter as request attribute
                    String val = Streams.asString(stream);
                    request.setAttribute(name, val);
                    // System.out.println(""Form field "" + name + "" with value "" + val + "" detected."");
                } else {
                    // add input stream and filename as attributes
                    String fileName = item.getName();
                    request.setAttribute(""fileName"", fileName);
                    byte[] data = readStream(stream);
                    request.setAttribute(name, data);
                    // System.out.println(""File field "" + name + "" with file name "" + fileName + "" detected."");
                }
            }
        }
    }

    // request info
    /**
     * Convenience method
     * @return true if the request is secure
     */
    public boolean isSecure() {
        return request.isSecure();
    }

    /**
     * Convenience method
     * @return the request scheme, ie. http, https
     */
    public String getScheme() {
        return request.getScheme();
    }

    /**
     * Convenience method
     * @return the request method, ie. GET, POST
     */
    public String getMethod() {
        return request.getMethod();
    }

    /**
     * Convenience method
     * @return the server name for this request
     */
    public String getServerName() {
        return request.getServerName();
    }

    /**
     * Convenience method
     * @return the server port for this request
     */
    public int getServerPort() {
        return request.getServerPort();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getServletPath
     * @see #getQueryString
     * @return the context path part of the url path
     */
    public String getContextPath() {
        return request.getContextPath();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getContextPath
     * @see #getQueryString
     * @return the servlet path part of the url path
     */
    public String getServletPath() {
        return request.getServletPath();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getContextPath
     * @see #getServletPath
     * @return the query string part of the url path
     */
    public String getQueryString() {
        return request.getQueryString();
    }

    // params
    /**
     * Convenience method
     * @param name    which parameter to get
     * @return the parameter value or null if there is no parameter corresponding to the indicated key
     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,
     * which can be retrieved as a byte array via the getAttribute method.
     * @see #getParamMap
     * @see #getParamValues
     * @see #getParamNames
     */
    public String getParam(String name) {
        if (hasMultipartContent) {
            Object o = request.getAttribute(name);
            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;
        } else {
            return request.getParameter(name);
        }
    }

    /**
     * Convenience method which gathers all parameters of the
     * form '<name>[<key>]' and return then in a map where the
     * keys are the <key> strings and the values are the
     * corresponding parameter values.
     * <pre>
     * For example, if there are parameters:
     *   'foo[bar1]' = 'baz1'
     *   'foo[bar2]' = 'baz2'
     * then getParamMap('foo') will returned the map:
     *   map['bar1'] = 'baz1'
     *   map['bar2'] = 'baz2'
     * </pre>
     * @param name  the prefix to be used to select parameters
     * @return a map of all paramters of the form 'name[<key>]'
     * where the <key> strings are the keys of the map and the
     * values are the corresponding parameter values.
     * @see #getParam
     * @see #getParamValues
     * @see #getParamNames
     */
    public Map<String, String> getParamMap(String name) {
        Map<String, String> m = new HashMap<String, String>();
        String prefix = name + ""["";
        int n = prefix.length();
        if (hasMultipartContent) {
            // for multipart requests the parameters have been stored as attributes (see constructor)
            Enumeration<String> e = request.getAttributeNames();
            while (e.hasMoreElements()) {
                String key = e.nextElement();
                if (key.startsWith(prefix) && key.endsWith(""]"")) {
                    m.put(key.substring(n, key.length() - 1), getParam(key));
                }
            }
        } else {
            Map<String, String[]> pm = request.getParameterMap();
            for (String key : pm.keySet()) {
                if (key.startsWith(prefix) && key.endsWith(""]"")) {
                    m.put(key.substring(n, key.length() - 1), getParam(key));
                }
            }
        }
        return m;
    }

    /**
     * Convenience method. Use this if you expect a parameter name
     * to map to multiple values.
     * @param name    the name of the parameter(s) to get
     * @return an array of paramter values corresponding to the indicated name
     * @see #getParam
     * @see #getParamMap
     * @see #getParamNames
     */
    public String[] getParamValues(String name) {
        return request.getParameterValues(name);
    }

    /**
     * Convenience method to get all the parameter names.
     * @return an array of all parameter names
     * @see #getParam
     * @see #getParamMap
     * @see #getParamValues
     */
    public String[] getParamNames() {
        if (hasMultipartContent) {
            List<String> list = new ArrayList<String>();
            Enumeration<String> e = request.getAttributeNames();
            while (e.hasMoreElements()) {
                list.add(e.nextElement());
            }
            return list.toArray(new String[list.size()]);
        } else {
            Map<String, String[]> m = request.getParameterMap();
            String[] a = new String[m.size()];
            int i = 0;
            for (String key : m.keySet()) {
                a[i++] = key;
            }
            return a;
        }
    }

    // attributes
    /**
     * Convenience method
     * @param name    which attribute to get
     * @return the attribute value or null if there is no attribute corresponding to the indicated key.
     * If the attribute corresponds to a file upload field then the return value will be a byte array
     */
    public Object getAttribute(String name) {
        return request.getAttribute(name);
    }

    /**
     * Convenience method
     * @param name    name of attribute to be set
     * @param value   value of attribute to be set
     */
    public void setAttribute(String name, Object value) {
        request.setAttribute(name, value);
    }

    // session attributes
    /**
     * Convenience method
     * @param name    the name of the attribute to retrieve
     * @return the attribute associated with the indicated name or null
     * @see #setSessionAttr
     * @see #getSessionAttrNames
     */
    public Object getSessionAttr(String name) {
        if (request.getSession() == null)
            return null;
        return request.getSession().getAttribute(name);
    }

    /**
     * Convenience method
     * @return all the session attribute names.
     * @see #getSessionAttr
     * @see #setSessionAttr
     * @see #removeSessionAttr
     */
    public String[] getSessionAttrNames() {
        if (request.getSession(false) == null)
            return new String[0];
        ArrayList<String> a = new ArrayList<String>();
        Enumeration<String> e = request.getSession().getAttributeNames();
        while (e.hasMoreElements()) {
            a.add(e.nextElement());
        }
        return a.toArray(new String[a.size()]);
    }

    /**
     * Convenience method
     * @param name  the key to store the indicated value
     * @param value  the object to be stored
     * @see #getSessionAttr
     * @see #removeSessionAttr
     */
    public void setSessionAttr(String name, Object value) {
        if (request.getSession() == null)
            return;
        request.getSession().setAttribute(name, value);
    }

    /**
     * Convenience method
     * @param name  the key of
     * @see #setSessionAttr
     */
    public void removeSessionAttr(String name) {
        if (request.getSession() == null)
            return;
        request.getSession().removeAttribute(name);
    }

    // cookies
    /**
     * Convenience method to get cookie by name
     * @param name  the name of the cookie to get
     * @return the cookie with the indicated name, or null
     * @see #setCookie
     * @see #getCookieNames
     */
    public Cookie getCookie(String name) {
        if (name == null)
            return null;
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return null;
        for (Cookie c : cookies) {
            if (name.equals(c.getName()))
                return c;
        }
        return null;
    }

    /**
     * Convenience method to get all the cookie names.
     * @return an array of the names of all the cookies in the request, possibly empty
     * @see #getCookie
     * @see #setCookie
     */
    public String[] getCookieNames() {
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return new String[0];
        String[] a = new String[cookies.length];
        int i = 0;
        for (Cookie c : cookies) {
            a[i++] = c.getName();
        }
        return a;
    }

    /**
     * Convenience method
     * @param cookie   the cookie to be added to the response
     * @see #getCookie
     * @see #getCookieNames
     */
    public void setCookie(Cookie cookie) {
        response.addCookie(cookie);
    }

    /**
     * Cause a non-standard response (ie. redirect) to be returned.
     * @param httpCode   the http response code to be returned
     * @param arg    an argument or message to be returned (depends on response code)
     * @see #redirect
     * @throws NonStandardResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the NonStandardResponseException.
     */
    public void nonStandardResponse(int httpCode, String arg) {
        throw new NonStandardResponseException(httpCode, arg);
    }

    /**
     * Cause a redirect response to be returned
     * @param path  where to redirect to. If the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @see #nonStandardResponse
     * @throws NonStandardResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the NonStandardResponseException.
     */
    public void redirect(String path) {
        if (path.startsWith(""/""))
            path = absPath(path);
        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);
    }

    /**
     * Cause a binary response to be returned
     * @param in input stream containing binary data to be sent
     * @throws BinaryResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the BinaryResponseException.
     */
    public void sendBinaryResponse(InputStream in) {
        throw new BinaryResponseException(in);
    }

    /**
     * Convenience method to prepend the context path onto a servlet path
     * @param path    a servlet path
     * @return the context path plus the indicated path
     */
    public String absPath(String path) {
        return getContextPath() + (path.startsWith(""/"") ? path : ""/"" + path);
    }

    /**
     * Convenience method to create an html anchor link tag
     * @param anchor    the text in an anchor link
     * @param path   the anchor target, if the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @see #makeLink
     * @see #absPath
     */
    public String makeLink(String anchor, String path) {
        return makeLink(anchor, path, """");
    }

    /**
     * Convenience method to create an html anchor link tag
     * @param anchor    the text in an anchor link
     * @param path   the anchor target, if the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @param options    extra html options to add to the anchor tag
     * @see #makeLink
     * @see #absPath
     */
    public String makeLink(String anchor, String path, String options) {
        if (path.startsWith(""/""))
            path = absPath(path);
        return ""<a href='"" + path + ""' "" + options + "">"" + anchor + ""</a>"";
    }

    /**
     * Convenience method to check if this request is a POST
     */
    public boolean isPost() {
        return ""POST"".equals(request.getMethod());
    }

    /**
     * Convenience method to check if this request is a GET
     */
    public boolean isGet() {
        return ""GET"".equals(request.getMethod());
    }

    /**
     * Convenience method to retrieve a value from the flash
     * @param key  the key to use to lookup a flash value
     * @return the flash value associated with the indicated key or null
     * @see #setFlash
     */
    public String getFlash(String key) {
        return flash.get(key);
    }

    /**
     * Convenience method to add a value to the flash
     * @param key  the key to use to associate with the flash value
     * @param val  the value to store
     * @see #getFlash
     */
    public void setFlash(String key, String val) {
        flash.put(key, val);
    }

    // caching (internal use)
    /**
     * Internal method used to retrieve a cached block
     * @see #setCachedBlock
     */
    public static String getCachedBlock(String key) {
        return (cacheMap == null) ? null : cacheMap.get(key);
    }

    /**
     * Internal method used to store a cached block
     * @see #getCachedBlock
     */
    public static void setCachedBlock(String key, String val) {
        if (cacheMap == null) {
            cacheMap = new HashMap<String, String>();
        }
        cacheMap.put(key, val);
    }

    /**
     * For debugging
     * @return a string representation of this request context
     */
    public String toString() {
        return toString("", "");
    }

    public String toString(String sep) {
        StringBuilder sb = new StringBuilder();
        sb.append(""params: ["");
        String[] keys = getParamNames();
        for (String key : keys) {
            sb.append(key).append('=').append(getParam(key)).append(sep);
        }
        if (keys.length > 0) {
            sb.setLength(sb.length() - sep.length());
        }
        sb.append(""]"");
        sb.append(sep).append(""method: "").append(getMethod());
        sb.append(sep).append(""url: "").append(getScheme());
        sb.append(""|"").append(getServerName());
        sb.append(""|"").append(getServerPort());
        sb.append(""|"").append(getContextPath());
        sb.append(""|"").append(getServletPath());
        sb.append(""|"").append(getQueryString());
        if (hasMultipartContent) {
            sb.append(sep).append(""content len: "").append(request.getContentLength());
            //sb.append(sep).append(""content type: "").append(request.getContentType());
        }
        return sb.toString();
    }

    /**
     * Copy an input stream to an output stream.
     */
    private byte[] readStream(InputStream in) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        byte[] buf = new byte[4096];
        int read;
        while ((read = in.read(buf)) > -1) {
            out.write(buf, 0, read);
        }
        out.flush();
        return out.toByteArray();
    }
}
","// JVCRequestContext_4Test.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JVCRequestContext}.
* It contains ten unit test cases for the {@link JVCRequestContext#getSessionAttr(String)} method.
*/
class JVCRequestContext_4Test {","```java
// JVCRequestContext_4Test.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JVCRequestContext}.
* It contains ten unit test cases for the {@link JVCRequestContext#getSessionAttr(String)} method.
*/
class JVCRequestContext_4Test {

    @Test
    void testGetSessionAttr_NullSession() {
        JVCRequestContext requestContext = new JVCRequestContext(null, null, null, new HashMap<>(), """", """");
        assertNull(requestContext.getSessionAttr(""test""));
    }

    @Test
    void testGetSessionAttr_NullAttribute() {
        HttpServletRequest request = mock(HttpServletRequest.class);
        HttpSession session = mock(HttpSession.class);
        when(request.getSession()).thenReturn(session);
        JVCRequestContext requestContext = new JVCRequestContext(request, null, null, new HashMap<>(), """", """");
        assertNull(requestContext.getSessionAttr(""test""));
    }

    @Test
    void testGetSessionAttr_ExistingAttribute() {
        HttpServletRequest request = mock(HttpServletRequest.class);
        HttpSession session = mock(HttpSession.class);
        when(request.getSession()).thenReturn(session);
        when(session.getAttribute(""test"")).thenReturn(""value"");
        JVCRequestContext requestContext = new JVCRequestContext(request, null, null, new HashMap<>(), """", """");
        assertEquals(""value"", requestContext.getSessionAttr(""test""));
    }

    @Test
    void testGetSessionAttr_MultipleAttributes() {
        HttpServletRequest request = mock(HttpServletRequest.class);
        HttpSession session = mock(HttpSession.class);
        when(request.getSession()).thenReturn(session);
        when(session.getAttribute(""test1"")).thenReturn(""value1"");
        when(session.getAttribute(""test2"")).thenReturn(""value2"");
        JVCRequestContext requestContext = new JVCRequestContext(request, null, null, new HashMap<>(), """", """");
        assertEquals(""value1"", requestContext.getSessionAttr(""test1""));
        assertEquals(""value2"", requestContext.getSessionAttr(""test2""));
    }

    @Test
    void testGetSessionAttr_NonExistingAttribute() {
        HttpServletRequest request = mock(HttpServletRequest.class);
        HttpSession session = mock(HttpSession.class);
        when(request.getSession()).thenReturn(session);
        JVCRequestContext requestContext = new JVCRequestContext(request, null, null, new HashMap<>(), """", """");
        assertNull(requestContext.getSessionAttr(""nonexistent""));
    }

    @Test
    void testGetSessionAttr_NullSessionAttribute() {
        HttpServletRequest request = mock(HttpServletRequest.class);
        HttpSession session = mock(HttpSession.class);
        when(request.getSession()).thenReturn(session);
        when(session.getAttribute(""test"")).thenReturn(null);
        JVCRequestContext requestContext = new JVCRequestContext(request, null, null, new HashMap<>(), """", """");
        assertNull(requestContext.getSessionAttr(""test""));
    }

    @Test
    void testGetSessionAttr_EmptySessionAttribute() {
        HttpServletRequest request = mock(HttpServletRequest.class);
        HttpSession session = mock(HttpSession.class);
        when(request.getSession()).thenReturn(session);
        when(session.getAttribute(""test"")).thenReturn("""");
        JVCRequestContext requestContext = new JVCRequestContext(request, null, null, new HashMap<>(), """", """");
        assertEquals("""", requestContext.getSessionAttr(""test""));
    }

    @Test
    void testGetSessionAttr_SessionAttributeWithSpaces() {
        HttpServletRequest request = mock(HttpServletRequest.class);
        HttpSession session = mock(HttpSession.class);
        when(request.getSession()).thenReturn(session);
        when(session.getAttribute(""test"")).thenReturn(""   "");
        JVCRequestContext requestContext = new JVCRequestContext(request, null, null, new HashMap<>(), """", """");
        assertEquals(""   "", requestContext.getSessionAttr(""test""));
    }

    @Test
    void testGetSessionAttr_SessionAttributeWithSpecialCharacters() {
        HttpServletRequest request = mock(HttpServletRequest.class);
        HttpSession session = mock(HttpSession.class);
        when(request.getSession()).thenReturn(session);
        when(session.getAttribute(""test"")).thenReturn(""!@#$%^&*()"");
        JVCRequestContext requestContext = new JVCRequestContext(request, null, null, new HashMap<>(), """", """");
        assertEquals(""!@#$%^&*()"", requestContext.getSessionAttr(""test""));
    }

    @Test
    void testGetSessionAttr_SessionAttributeWithNumbers() {
        HttpServletRequest request = mock(HttpServletRequest.class);
        HttpSession session = mock(HttpSession.class);
        when(request.getSession()).thenReturn(session);
        when(session.getAttribute(""test"")).thenReturn(12345);
        JVCRequestContext requestContext = new JVCRequestContext(request, null, null, new HashMap<>(), """", """");
        assertEquals(12345, requestContext.getSessionAttr(""test""));
    }
}
```
"
chatcmpl-A5UW8scWw9Vck4zXSzigwHtt5pnKI,/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContext_5Test.java,10.645703554153442,stop,"// JVCRequestContext.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

/**
 * This class contains state information for processing an http request.
 * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet
 * objects and provides convenience methods for accessing them.
 * <p>
 * It also provides access to the 'flash' which is a Map for storing temporary
 * key/value strings.  The scope of the flash is the current request or
 * the following request in the case of a redirect response.
 * <p>
 * It also contains some convenience methods for forming links and absolute paths.
 *
 * @author mike dooley
 */
public final class JVCRequestContext {

    /**
     * The actual HttpServletRequest object
     */
    public final HttpServletRequest request;

    /**
     * The actual HttpServletResponse object
     */
    public final HttpServletResponse response;

    /**
     * The HttpServlet object (actually this is a JVCDispatcher)
     */
    public final HttpServlet servlet;

    /**
     * The controller is the servlet path up to the action.
     */
    public final String controller;

    /**
     * The action is the last part of the servlet path (before any query arguments)
     */
    public final String action;

    /**
     * Tells if this request has multipart content (ie file upload)
     */
    public final boolean hasMultipartContent;

    /**
     * Parameter value indicating that the real parameter value is binary (and should be
     * accessed via the getAttribute() method.
     */
    public static final String BINARY_VALUE = ""BINARY_VALUE"";

    /**
     * The 'flash' map for holding temporary key/value strings.
     */
    public final Map<String, String> flash;

    /**
     * Holds cached page generator fragments
     */
    private static Map<String, String> cacheMap;

    /**
     * Constructor for JVCRequestContext which is used to hold http request and response iformation
     * @param request
     * @param response
     * @param servlet
     * @param flash
     * @param controller
     * @param action
     */
    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map<String, String> flash, String controller, String action) throws Exception {
        this.request = request;
        this.response = response;
        this.servlet = servlet;
        this.controller = controller;
        this.action = action;
        this.flash = flash;
        hasMultipartContent = ServletFileUpload.isMultipartContent(request);
        if (hasMultipartContent) {
            // Create a new file upload handler
            ServletFileUpload upload = new ServletFileUpload();
            // Parse the request
            FileItemIterator iter = upload.getItemIterator(request);
            while (iter.hasNext()) {
                FileItemStream item = iter.next();
                String name = item.getFieldName();
                InputStream stream = item.openStream();
                if (item.isFormField()) {
                    // add parameter as request attribute
                    String val = Streams.asString(stream);
                    request.setAttribute(name, val);
                    // System.out.println(""Form field "" + name + "" with value "" + val + "" detected."");
                } else {
                    // add input stream and filename as attributes
                    String fileName = item.getName();
                    request.setAttribute(""fileName"", fileName);
                    byte[] data = readStream(stream);
                    request.setAttribute(name, data);
                    // System.out.println(""File field "" + name + "" with file name "" + fileName + "" detected."");
                }
            }
        }
    }

    // request info
    /**
     * Convenience method
     * @return true if the request is secure
     */
    public boolean isSecure() {
        return request.isSecure();
    }

    /**
     * Convenience method
     * @return the request scheme, ie. http, https
     */
    public String getScheme() {
        return request.getScheme();
    }

    /**
     * Convenience method
     * @return the request method, ie. GET, POST
     */
    public String getMethod() {
        return request.getMethod();
    }

    /**
     * Convenience method
     * @return the server name for this request
     */
    public String getServerName() {
        return request.getServerName();
    }

    /**
     * Convenience method
     * @return the server port for this request
     */
    public int getServerPort() {
        return request.getServerPort();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getServletPath
     * @see #getQueryString
     * @return the context path part of the url path
     */
    public String getContextPath() {
        return request.getContextPath();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getContextPath
     * @see #getQueryString
     * @return the servlet path part of the url path
     */
    public String getServletPath() {
        return request.getServletPath();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getContextPath
     * @see #getServletPath
     * @return the query string part of the url path
     */
    public String getQueryString() {
        return request.getQueryString();
    }

    // params
    /**
     * Convenience method
     * @param name    which parameter to get
     * @return the parameter value or null if there is no parameter corresponding to the indicated key
     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,
     * which can be retrieved as a byte array via the getAttribute method.
     * @see #getParamMap
     * @see #getParamValues
     * @see #getParamNames
     */
    public String getParam(String name) {
        if (hasMultipartContent) {
            Object o = request.getAttribute(name);
            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;
        } else {
            return request.getParameter(name);
        }
    }

    /**
     * Convenience method which gathers all parameters of the
     * form '<name>[<key>]' and return then in a map where the
     * keys are the <key> strings and the values are the
     * corresponding parameter values.
     * <pre>
     * For example, if there are parameters:
     *   'foo[bar1]' = 'baz1'
     *   'foo[bar2]' = 'baz2'
     * then getParamMap('foo') will returned the map:
     *   map['bar1'] = 'baz1'
     *   map['bar2'] = 'baz2'
     * </pre>
     * @param name  the prefix to be used to select parameters
     * @return a map of all paramters of the form 'name[<key>]'
     * where the <key> strings are the keys of the map and the
     * values are the corresponding parameter values.
     * @see #getParam
     * @see #getParamValues
     * @see #getParamNames
     */
    public Map<String, String> getParamMap(String name) {
        Map<String, String> m = new HashMap<String, String>();
        String prefix = name + ""["";
        int n = prefix.length();
        if (hasMultipartContent) {
            // for multipart requests the parameters have been stored as attributes (see constructor)
            Enumeration<String> e = request.getAttributeNames();
            while (e.hasMoreElements()) {
                String key = e.nextElement();
                if (key.startsWith(prefix) && key.endsWith(""]"")) {
                    m.put(key.substring(n, key.length() - 1), getParam(key));
                }
            }
        } else {
            Map<String, String[]> pm = request.getParameterMap();
            for (String key : pm.keySet()) {
                if (key.startsWith(prefix) && key.endsWith(""]"")) {
                    m.put(key.substring(n, key.length() - 1), getParam(key));
                }
            }
        }
        return m;
    }

    /**
     * Convenience method. Use this if you expect a parameter name
     * to map to multiple values.
     * @param name    the name of the parameter(s) to get
     * @return an array of paramter values corresponding to the indicated name
     * @see #getParam
     * @see #getParamMap
     * @see #getParamNames
     */
    public String[] getParamValues(String name) {
        return request.getParameterValues(name);
    }

    /**
     * Convenience method to get all the parameter names.
     * @return an array of all parameter names
     * @see #getParam
     * @see #getParamMap
     * @see #getParamValues
     */
    public String[] getParamNames() {
        if (hasMultipartContent) {
            List<String> list = new ArrayList<String>();
            Enumeration<String> e = request.getAttributeNames();
            while (e.hasMoreElements()) {
                list.add(e.nextElement());
            }
            return list.toArray(new String[list.size()]);
        } else {
            Map<String, String[]> m = request.getParameterMap();
            String[] a = new String[m.size()];
            int i = 0;
            for (String key : m.keySet()) {
                a[i++] = key;
            }
            return a;
        }
    }

    // attributes
    /**
     * Convenience method
     * @param name    which attribute to get
     * @return the attribute value or null if there is no attribute corresponding to the indicated key.
     * If the attribute corresponds to a file upload field then the return value will be a byte array
     */
    public Object getAttribute(String name) {
        return request.getAttribute(name);
    }

    /**
     * Convenience method
     * @param name    name of attribute to be set
     * @param value   value of attribute to be set
     */
    public void setAttribute(String name, Object value) {
        request.setAttribute(name, value);
    }

    // session attributes
    /**
     * Convenience method
     * @param name    the name of the attribute to retrieve
     * @return the attribute associated with the indicated name or null
     * @see #setSessionAttr
     * @see #getSessionAttrNames
     */
    public Object getSessionAttr(String name) {
        if (request.getSession() == null)
            return null;
        return request.getSession().getAttribute(name);
    }

    /**
     * Convenience method
     * @return all the session attribute names.
     * @see #getSessionAttr
     * @see #setSessionAttr
     * @see #removeSessionAttr
     */
    public String[] getSessionAttrNames() {
        if (request.getSession(false) == null)
            return new String[0];
        ArrayList<String> a = new ArrayList<String>();
        Enumeration<String> e = request.getSession().getAttributeNames();
        while (e.hasMoreElements()) {
            a.add(e.nextElement());
        }
        return a.toArray(new String[a.size()]);
    }

    /**
     * Convenience method
     * @param name  the key to store the indicated value
     * @param value  the object to be stored
     * @see #getSessionAttr
     * @see #removeSessionAttr
     */
    public void setSessionAttr(String name, Object value) {
        if (request.getSession() == null)
            return;
        request.getSession().setAttribute(name, value);
    }

    /**
     * Convenience method
     * @param name  the key of
     * @see #setSessionAttr
     */
    public void removeSessionAttr(String name) {
        if (request.getSession() == null)
            return;
        request.getSession().removeAttribute(name);
    }

    // cookies
    /**
     * Convenience method to get cookie by name
     * @param name  the name of the cookie to get
     * @return the cookie with the indicated name, or null
     * @see #setCookie
     * @see #getCookieNames
     */
    public Cookie getCookie(String name) {
        if (name == null)
            return null;
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return null;
        for (Cookie c : cookies) {
            if (name.equals(c.getName()))
                return c;
        }
        return null;
    }

    /**
     * Convenience method to get all the cookie names.
     * @return an array of the names of all the cookies in the request, possibly empty
     * @see #getCookie
     * @see #setCookie
     */
    public String[] getCookieNames() {
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return new String[0];
        String[] a = new String[cookies.length];
        int i = 0;
        for (Cookie c : cookies) {
            a[i++] = c.getName();
        }
        return a;
    }

    /**
     * Convenience method
     * @param cookie   the cookie to be added to the response
     * @see #getCookie
     * @see #getCookieNames
     */
    public void setCookie(Cookie cookie) {
        response.addCookie(cookie);
    }

    /**
     * Cause a non-standard response (ie. redirect) to be returned.
     * @param httpCode   the http response code to be returned
     * @param arg    an argument or message to be returned (depends on response code)
     * @see #redirect
     * @throws NonStandardResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the NonStandardResponseException.
     */
    public void nonStandardResponse(int httpCode, String arg) {
        throw new NonStandardResponseException(httpCode, arg);
    }

    /**
     * Cause a redirect response to be returned
     * @param path  where to redirect to. If the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @see #nonStandardResponse
     * @throws NonStandardResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the NonStandardResponseException.
     */
    public void redirect(String path) {
        if (path.startsWith(""/""))
            path = absPath(path);
        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);
    }

    /**
     * Cause a binary response to be returned
     * @param in input stream containing binary data to be sent
     * @throws BinaryResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the BinaryResponseException.
     */
    public void sendBinaryResponse(InputStream in) {
        throw new BinaryResponseException(in);
    }

    /**
     * Convenience method to prepend the context path onto a servlet path
     * @param path    a servlet path
     * @return the context path plus the indicated path
     */
    public String absPath(String path) {
        return getContextPath() + (path.startsWith(""/"") ? path : ""/"" + path);
    }

    /**
     * Convenience method to create an html anchor link tag
     * @param anchor    the text in an anchor link
     * @param path   the anchor target, if the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @see #makeLink
     * @see #absPath
     */
    public String makeLink(String anchor, String path) {
        return makeLink(anchor, path, """");
    }

    /**
     * Convenience method to create an html anchor link tag
     * @param anchor    the text in an anchor link
     * @param path   the anchor target, if the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @param options    extra html options to add to the anchor tag
     * @see #makeLink
     * @see #absPath
     */
    public String makeLink(String anchor, String path, String options) {
        if (path.startsWith(""/""))
            path = absPath(path);
        return ""<a href='"" + path + ""' "" + options + "">"" + anchor + ""</a>"";
    }

    /**
     * Convenience method to check if this request is a POST
     */
    public boolean isPost() {
        return ""POST"".equals(request.getMethod());
    }

    /**
     * Convenience method to check if this request is a GET
     */
    public boolean isGet() {
        return ""GET"".equals(request.getMethod());
    }

    /**
     * Convenience method to retrieve a value from the flash
     * @param key  the key to use to lookup a flash value
     * @return the flash value associated with the indicated key or null
     * @see #setFlash
     */
    public String getFlash(String key) {
        return flash.get(key);
    }

    /**
     * Convenience method to add a value to the flash
     * @param key  the key to use to associate with the flash value
     * @param val  the value to store
     * @see #getFlash
     */
    public void setFlash(String key, String val) {
        flash.put(key, val);
    }

    // caching (internal use)
    /**
     * Internal method used to retrieve a cached block
     * @see #setCachedBlock
     */
    public static String getCachedBlock(String key) {
        return (cacheMap == null) ? null : cacheMap.get(key);
    }

    /**
     * Internal method used to store a cached block
     * @see #getCachedBlock
     */
    public static void setCachedBlock(String key, String val) {
        if (cacheMap == null) {
            cacheMap = new HashMap<String, String>();
        }
        cacheMap.put(key, val);
    }

    /**
     * For debugging
     * @return a string representation of this request context
     */
    public String toString() {
        return toString("", "");
    }

    public String toString(String sep) {
        StringBuilder sb = new StringBuilder();
        sb.append(""params: ["");
        String[] keys = getParamNames();
        for (String key : keys) {
            sb.append(key).append('=').append(getParam(key)).append(sep);
        }
        if (keys.length > 0) {
            sb.setLength(sb.length() - sep.length());
        }
        sb.append(""]"");
        sb.append(sep).append(""method: "").append(getMethod());
        sb.append(sep).append(""url: "").append(getScheme());
        sb.append(""|"").append(getServerName());
        sb.append(""|"").append(getServerPort());
        sb.append(""|"").append(getContextPath());
        sb.append(""|"").append(getServletPath());
        sb.append(""|"").append(getQueryString());
        if (hasMultipartContent) {
            sb.append(sep).append(""content len: "").append(request.getContentLength());
            //sb.append(sep).append(""content type: "").append(request.getContentType());
        }
        return sb.toString();
    }

    /**
     * Copy an input stream to an output stream.
     */
    private byte[] readStream(InputStream in) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        byte[] buf = new byte[4096];
        int read;
        while ((read = in.read(buf)) > -1) {
            out.write(buf, 0, read);
        }
        out.flush();
        return out.toByteArray();
    }
}
","// JVCRequestContext_5Test.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JVCRequestContext}.
* It contains ten unit test cases for the {@link JVCRequestContext#getCookie(String)} method.
*/
class JVCRequestContext_5Test {","```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class JVCRequestContext_5Test {

    @Test
    void testGetCookie_NullCookies() {
        JVCRequestContext requestContext = new JVCRequestContext();
        assertNull(requestContext.getCookie(""test""));
    }

    @Test
    void testGetCookie_NoMatchingCookie() {
        JVCRequestContext requestContext = new JVCRequestContext();
        Cookie[] cookies = {new Cookie(""cookie1"", ""value1""), new Cookie(""cookie2"", ""value2"")};
        requestContext.setRequestCookies(cookies);
        assertNull(requestContext.getCookie(""test""));
    }

    @Test
    void testGetCookie_MatchingCookie() {
        JVCRequestContext requestContext = new JVCRequestContext();
        Cookie[] cookies = {new Cookie(""cookie1"", ""value1""), new Cookie(""test"", ""testValue"")};
        requestContext.setRequestCookies(cookies);
        Cookie cookie = requestContext.getCookie(""test"");
        assertNotNull(cookie);
        assertEquals(""test"", cookie.getName());
        assertEquals(""testValue"", cookie.getValue());
    }

    @Test
    void testGetCookie_MultipleCookies() {
        JVCRequestContext requestContext = new JVCRequestContext();
        Cookie[] cookies = {new Cookie(""cookie1"", ""value1""), new Cookie(""test"", ""testValue""), new Cookie(""cookie2"", ""value2"")};
        requestContext.setRequestCookies(cookies);
        Cookie cookie = requestContext.getCookie(""test"");
        assertNotNull(cookie);
        assertEquals(""test"", cookie.getName());
        assertEquals(""testValue"", cookie.getValue());
    }

    @Test
    void testGetCookie_CaseSensitive() {
        JVCRequestContext requestContext = new JVCRequestContext();
        Cookie[] cookies = {new Cookie(""cookie1"", ""value1""), new Cookie(""Test"", ""testValue"")};
        requestContext.setRequestCookies(cookies);
        assertNull(requestContext.getCookie(""test""));
    }

    @Test
    void testGetCookie_EmptyName() {
        JVCRequestContext requestContext = new JVCRequestContext();
        Cookie[] cookies = {new Cookie(""cookie1"", ""value1""), new Cookie("""", ""testValue"")};
        requestContext.setRequestCookies(cookies);
        assertNull(requestContext.getCookie(""""));
    }

    @Test
    void testGetCookie_NullName() {
        JVCRequestContext requestContext = new JVCRequestContext();
        Cookie[] cookies = {new Cookie(""cookie1"", ""value1""), new Cookie(""test"", ""testValue"")};
        requestContext.setRequestCookies(cookies);
        assertNull(requestContext.getCookie(null));
    }

    @Test
    void testGetCookie_NullCookie() {
        JVCRequestContext requestContext = new JVCRequestContext();
        Cookie[] cookies = {new Cookie(""cookie1"", ""value1""), null};
        requestContext.setRequestCookies(cookies);
        assertNull(requestContext.getCookie(""test""));
    }

    @Test
    void testGetCookie_NonNullCookie() {
        JVCRequestContext requestContext = new JVCRequestContext();
        Cookie[] cookies = {new Cookie(""cookie1"", ""value1""), new Cookie(""test"", ""testValue"")};
        requestContext.setRequestCookies(cookies);
        assertNotNull(requestContext.getCookie(""test""));
    }

    @Test
    void testGetCookie_MatchingCookieValue() {
        JVCRequestContext requestContext = new JVCRequestContext();
        Cookie[] cookies = {new Cookie(""cookie1"", ""value1""), new Cookie(""test"", ""testValue"")};
        requestContext.setRequestCookies(cookies);
        Cookie cookie = requestContext.getCookie(""test"");
        assertNotNull(cookie);
        assertEquals(""testValue"", cookie.getValue());
    }
}
```"
chatcmpl-A5UXBDTA5EjQ7p1jTVbEi1u0lFLTq,/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContext_6Test.java,5.2368457317352295,stop,"// JVCRequestContext.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

/**
 * This class contains state information for processing an http request.
 * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet
 * objects and provides convenience methods for accessing them.
 * <p>
 * It also provides access to the 'flash' which is a Map for storing temporary
 * key/value strings.  The scope of the flash is the current request or
 * the following request in the case of a redirect response.
 * <p>
 * It also contains some convenience methods for forming links and absolute paths.
 *
 * @author mike dooley
 */
public final class JVCRequestContext {

    /**
     * The actual HttpServletRequest object
     */
    public final HttpServletRequest request;

    /**
     * The actual HttpServletResponse object
     */
    public final HttpServletResponse response;

    /**
     * The HttpServlet object (actually this is a JVCDispatcher)
     */
    public final HttpServlet servlet;

    /**
     * The controller is the servlet path up to the action.
     */
    public final String controller;

    /**
     * The action is the last part of the servlet path (before any query arguments)
     */
    public final String action;

    /**
     * Tells if this request has multipart content (ie file upload)
     */
    public final boolean hasMultipartContent;

    /**
     * Parameter value indicating that the real parameter value is binary (and should be
     * accessed via the getAttribute() method.
     */
    public static final String BINARY_VALUE = ""BINARY_VALUE"";

    /**
     * The 'flash' map for holding temporary key/value strings.
     */
    public final Map<String, String> flash;

    /**
     * Holds cached page generator fragments
     */
    private static Map<String, String> cacheMap;

    /**
     * Constructor for JVCRequestContext which is used to hold http request and response iformation
     * @param request
     * @param response
     * @param servlet
     * @param flash
     * @param controller
     * @param action
     */
    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map<String, String> flash, String controller, String action) throws Exception {
        this.request = request;
        this.response = response;
        this.servlet = servlet;
        this.controller = controller;
        this.action = action;
        this.flash = flash;
        hasMultipartContent = ServletFileUpload.isMultipartContent(request);
        if (hasMultipartContent) {
            // Create a new file upload handler
            ServletFileUpload upload = new ServletFileUpload();
            // Parse the request
            FileItemIterator iter = upload.getItemIterator(request);
            while (iter.hasNext()) {
                FileItemStream item = iter.next();
                String name = item.getFieldName();
                InputStream stream = item.openStream();
                if (item.isFormField()) {
                    // add parameter as request attribute
                    String val = Streams.asString(stream);
                    request.setAttribute(name, val);
                    // System.out.println(""Form field "" + name + "" with value "" + val + "" detected."");
                } else {
                    // add input stream and filename as attributes
                    String fileName = item.getName();
                    request.setAttribute(""fileName"", fileName);
                    byte[] data = readStream(stream);
                    request.setAttribute(name, data);
                    // System.out.println(""File field "" + name + "" with file name "" + fileName + "" detected."");
                }
            }
        }
    }

    // request info
    /**
     * Convenience method
     * @return true if the request is secure
     */
    public boolean isSecure() {
        return request.isSecure();
    }

    /**
     * Convenience method
     * @return the request scheme, ie. http, https
     */
    public String getScheme() {
        return request.getScheme();
    }

    /**
     * Convenience method
     * @return the request method, ie. GET, POST
     */
    public String getMethod() {
        return request.getMethod();
    }

    /**
     * Convenience method
     * @return the server name for this request
     */
    public String getServerName() {
        return request.getServerName();
    }

    /**
     * Convenience method
     * @return the server port for this request
     */
    public int getServerPort() {
        return request.getServerPort();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getServletPath
     * @see #getQueryString
     * @return the context path part of the url path
     */
    public String getContextPath() {
        return request.getContextPath();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getContextPath
     * @see #getQueryString
     * @return the servlet path part of the url path
     */
    public String getServletPath() {
        return request.getServletPath();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getContextPath
     * @see #getServletPath
     * @return the query string part of the url path
     */
    public String getQueryString() {
        return request.getQueryString();
    }

    // params
    /**
     * Convenience method
     * @param name    which parameter to get
     * @return the parameter value or null if there is no parameter corresponding to the indicated key
     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,
     * which can be retrieved as a byte array via the getAttribute method.
     * @see #getParamMap
     * @see #getParamValues
     * @see #getParamNames
     */
    public String getParam(String name) {
        if (hasMultipartContent) {
            Object o = request.getAttribute(name);
            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;
        } else {
            return request.getParameter(name);
        }
    }

    /**
     * Convenience method which gathers all parameters of the
     * form '<name>[<key>]' and return then in a map where the
     * keys are the <key> strings and the values are the
     * corresponding parameter values.
     * <pre>
     * For example, if there are parameters:
     *   'foo[bar1]' = 'baz1'
     *   'foo[bar2]' = 'baz2'
     * then getParamMap('foo') will returned the map:
     *   map['bar1'] = 'baz1'
     *   map['bar2'] = 'baz2'
     * </pre>
     * @param name  the prefix to be used to select parameters
     * @return a map of all paramters of the form 'name[<key>]'
     * where the <key> strings are the keys of the map and the
     * values are the corresponding parameter values.
     * @see #getParam
     * @see #getParamValues
     * @see #getParamNames
     */
    public Map<String, String> getParamMap(String name) {
        Map<String, String> m = new HashMap<String, String>();
        String prefix = name + ""["";
        int n = prefix.length();
        if (hasMultipartContent) {
            // for multipart requests the parameters have been stored as attributes (see constructor)
            Enumeration<String> e = request.getAttributeNames();
            while (e.hasMoreElements()) {
                String key = e.nextElement();
                if (key.startsWith(prefix) && key.endsWith(""]"")) {
                    m.put(key.substring(n, key.length() - 1), getParam(key));
                }
            }
        } else {
            Map<String, String[]> pm = request.getParameterMap();
            for (String key : pm.keySet()) {
                if (key.startsWith(prefix) && key.endsWith(""]"")) {
                    m.put(key.substring(n, key.length() - 1), getParam(key));
                }
            }
        }
        return m;
    }

    /**
     * Convenience method. Use this if you expect a parameter name
     * to map to multiple values.
     * @param name    the name of the parameter(s) to get
     * @return an array of paramter values corresponding to the indicated name
     * @see #getParam
     * @see #getParamMap
     * @see #getParamNames
     */
    public String[] getParamValues(String name) {
        return request.getParameterValues(name);
    }

    /**
     * Convenience method to get all the parameter names.
     * @return an array of all parameter names
     * @see #getParam
     * @see #getParamMap
     * @see #getParamValues
     */
    public String[] getParamNames() {
        if (hasMultipartContent) {
            List<String> list = new ArrayList<String>();
            Enumeration<String> e = request.getAttributeNames();
            while (e.hasMoreElements()) {
                list.add(e.nextElement());
            }
            return list.toArray(new String[list.size()]);
        } else {
            Map<String, String[]> m = request.getParameterMap();
            String[] a = new String[m.size()];
            int i = 0;
            for (String key : m.keySet()) {
                a[i++] = key;
            }
            return a;
        }
    }

    // attributes
    /**
     * Convenience method
     * @param name    which attribute to get
     * @return the attribute value or null if there is no attribute corresponding to the indicated key.
     * If the attribute corresponds to a file upload field then the return value will be a byte array
     */
    public Object getAttribute(String name) {
        return request.getAttribute(name);
    }

    /**
     * Convenience method
     * @param name    name of attribute to be set
     * @param value   value of attribute to be set
     */
    public void setAttribute(String name, Object value) {
        request.setAttribute(name, value);
    }

    // session attributes
    /**
     * Convenience method
     * @param name    the name of the attribute to retrieve
     * @return the attribute associated with the indicated name or null
     * @see #setSessionAttr
     * @see #getSessionAttrNames
     */
    public Object getSessionAttr(String name) {
        if (request.getSession() == null)
            return null;
        return request.getSession().getAttribute(name);
    }

    /**
     * Convenience method
     * @return all the session attribute names.
     * @see #getSessionAttr
     * @see #setSessionAttr
     * @see #removeSessionAttr
     */
    public String[] getSessionAttrNames() {
        if (request.getSession(false) == null)
            return new String[0];
        ArrayList<String> a = new ArrayList<String>();
        Enumeration<String> e = request.getSession().getAttributeNames();
        while (e.hasMoreElements()) {
            a.add(e.nextElement());
        }
        return a.toArray(new String[a.size()]);
    }

    /**
     * Convenience method
     * @param name  the key to store the indicated value
     * @param value  the object to be stored
     * @see #getSessionAttr
     * @see #removeSessionAttr
     */
    public void setSessionAttr(String name, Object value) {
        if (request.getSession() == null)
            return;
        request.getSession().setAttribute(name, value);
    }

    /**
     * Convenience method
     * @param name  the key of
     * @see #setSessionAttr
     */
    public void removeSessionAttr(String name) {
        if (request.getSession() == null)
            return;
        request.getSession().removeAttribute(name);
    }

    // cookies
    /**
     * Convenience method to get cookie by name
     * @param name  the name of the cookie to get
     * @return the cookie with the indicated name, or null
     * @see #setCookie
     * @see #getCookieNames
     */
    public Cookie getCookie(String name) {
        if (name == null)
            return null;
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return null;
        for (Cookie c : cookies) {
            if (name.equals(c.getName()))
                return c;
        }
        return null;
    }

    /**
     * Convenience method to get all the cookie names.
     * @return an array of the names of all the cookies in the request, possibly empty
     * @see #getCookie
     * @see #setCookie
     */
    public String[] getCookieNames() {
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return new String[0];
        String[] a = new String[cookies.length];
        int i = 0;
        for (Cookie c : cookies) {
            a[i++] = c.getName();
        }
        return a;
    }

    /**
     * Convenience method
     * @param cookie   the cookie to be added to the response
     * @see #getCookie
     * @see #getCookieNames
     */
    public void setCookie(Cookie cookie) {
        response.addCookie(cookie);
    }

    /**
     * Cause a non-standard response (ie. redirect) to be returned.
     * @param httpCode   the http response code to be returned
     * @param arg    an argument or message to be returned (depends on response code)
     * @see #redirect
     * @throws NonStandardResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the NonStandardResponseException.
     */
    public void nonStandardResponse(int httpCode, String arg) {
        throw new NonStandardResponseException(httpCode, arg);
    }

    /**
     * Cause a redirect response to be returned
     * @param path  where to redirect to. If the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @see #nonStandardResponse
     * @throws NonStandardResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the NonStandardResponseException.
     */
    public void redirect(String path) {
        if (path.startsWith(""/""))
            path = absPath(path);
        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);
    }

    /**
     * Cause a binary response to be returned
     * @param in input stream containing binary data to be sent
     * @throws BinaryResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the BinaryResponseException.
     */
    public void sendBinaryResponse(InputStream in) {
        throw new BinaryResponseException(in);
    }

    /**
     * Convenience method to prepend the context path onto a servlet path
     * @param path    a servlet path
     * @return the context path plus the indicated path
     */
    public String absPath(String path) {
        return getContextPath() + (path.startsWith(""/"") ? path : ""/"" + path);
    }

    /**
     * Convenience method to create an html anchor link tag
     * @param anchor    the text in an anchor link
     * @param path   the anchor target, if the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @see #makeLink
     * @see #absPath
     */
    public String makeLink(String anchor, String path) {
        return makeLink(anchor, path, """");
    }

    /**
     * Convenience method to create an html anchor link tag
     * @param anchor    the text in an anchor link
     * @param path   the anchor target, if the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @param options    extra html options to add to the anchor tag
     * @see #makeLink
     * @see #absPath
     */
    public String makeLink(String anchor, String path, String options) {
        if (path.startsWith(""/""))
            path = absPath(path);
        return ""<a href='"" + path + ""' "" + options + "">"" + anchor + ""</a>"";
    }

    /**
     * Convenience method to check if this request is a POST
     */
    public boolean isPost() {
        return ""POST"".equals(request.getMethod());
    }

    /**
     * Convenience method to check if this request is a GET
     */
    public boolean isGet() {
        return ""GET"".equals(request.getMethod());
    }

    /**
     * Convenience method to retrieve a value from the flash
     * @param key  the key to use to lookup a flash value
     * @return the flash value associated with the indicated key or null
     * @see #setFlash
     */
    public String getFlash(String key) {
        return flash.get(key);
    }

    /**
     * Convenience method to add a value to the flash
     * @param key  the key to use to associate with the flash value
     * @param val  the value to store
     * @see #getFlash
     */
    public void setFlash(String key, String val) {
        flash.put(key, val);
    }

    // caching (internal use)
    /**
     * Internal method used to retrieve a cached block
     * @see #setCachedBlock
     */
    public static String getCachedBlock(String key) {
        return (cacheMap == null) ? null : cacheMap.get(key);
    }

    /**
     * Internal method used to store a cached block
     * @see #getCachedBlock
     */
    public static void setCachedBlock(String key, String val) {
        if (cacheMap == null) {
            cacheMap = new HashMap<String, String>();
        }
        cacheMap.put(key, val);
    }

    /**
     * For debugging
     * @return a string representation of this request context
     */
    public String toString() {
        return toString("", "");
    }

    public String toString(String sep) {
        StringBuilder sb = new StringBuilder();
        sb.append(""params: ["");
        String[] keys = getParamNames();
        for (String key : keys) {
            sb.append(key).append('=').append(getParam(key)).append(sep);
        }
        if (keys.length > 0) {
            sb.setLength(sb.length() - sep.length());
        }
        sb.append(""]"");
        sb.append(sep).append(""method: "").append(getMethod());
        sb.append(sep).append(""url: "").append(getScheme());
        sb.append(""|"").append(getServerName());
        sb.append(""|"").append(getServerPort());
        sb.append(""|"").append(getContextPath());
        sb.append(""|"").append(getServletPath());
        sb.append(""|"").append(getQueryString());
        if (hasMultipartContent) {
            sb.append(sep).append(""content len: "").append(request.getContentLength());
            //sb.append(sep).append(""content type: "").append(request.getContentType());
        }
        return sb.toString();
    }

    /**
     * Copy an input stream to an output stream.
     */
    private byte[] readStream(InputStream in) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        byte[] buf = new byte[4096];
        int read;
        while ((read = in.read(buf)) > -1) {
            out.write(buf, 0, read);
        }
        out.flush();
        return out.toByteArray();
    }
}
","// JVCRequestContext_6Test.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JVCRequestContext}.
* It contains ten unit test cases for the {@link JVCRequestContext#absPath(String)} method.
*/
class JVCRequestContext_6Test {","```java
import static org.junit.jupiter.api.Assertions.assertEquals;

class JVCRequestContext_6Test {

    @Test
    void testAbsPath_WithAbsolutePath() {
        JVCRequestContext context = new JVCRequestContext();
        String path = ""/example/path"";
        String expected = context.getContextPath() + path;
        String actual = context.absPath(path);
        assertEquals(expected, actual);
    }

    @Test
    void testAbsPath_WithoutAbsolutePath() {
        JVCRequestContext context = new JVCRequestContext();
        String path = ""example/path"";
        String expected = context.getContextPath() + ""/"" + path;
        String actual = context.absPath(path);
        assertEquals(expected, actual);
    }

    @Test
    void testAbsPath_EmptyPath() {
        JVCRequestContext context = new JVCRequestContext();
        String path = """";
        String expected = context.getContextPath() + ""/"";
        String actual = context.absPath(path);
        assertEquals(expected, actual);
    }

    @Test
    void testAbsPath_NullPath() {
        JVCRequestContext context = new JVCRequestContext();
        String path = null;
        String expected = context.getContextPath() + ""/"";
        String actual = context.absPath(path);
        assertEquals(expected, actual);
    }
}
```
```"
chatcmpl-A5UYEsVJc820DEoUz61mPNHFwp11f,/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContext_7Test.java,14.527157306671143,stop,"// JVCRequestContext.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

/**
 * This class contains state information for processing an http request.
 * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet
 * objects and provides convenience methods for accessing them.
 * <p>
 * It also provides access to the 'flash' which is a Map for storing temporary
 * key/value strings.  The scope of the flash is the current request or
 * the following request in the case of a redirect response.
 * <p>
 * It also contains some convenience methods for forming links and absolute paths.
 *
 * @author mike dooley
 */
public final class JVCRequestContext {

    /**
     * The actual HttpServletRequest object
     */
    public final HttpServletRequest request;

    /**
     * The actual HttpServletResponse object
     */
    public final HttpServletResponse response;

    /**
     * The HttpServlet object (actually this is a JVCDispatcher)
     */
    public final HttpServlet servlet;

    /**
     * The controller is the servlet path up to the action.
     */
    public final String controller;

    /**
     * The action is the last part of the servlet path (before any query arguments)
     */
    public final String action;

    /**
     * Tells if this request has multipart content (ie file upload)
     */
    public final boolean hasMultipartContent;

    /**
     * Parameter value indicating that the real parameter value is binary (and should be
     * accessed via the getAttribute() method.
     */
    public static final String BINARY_VALUE = ""BINARY_VALUE"";

    /**
     * The 'flash' map for holding temporary key/value strings.
     */
    public final Map<String, String> flash;

    /**
     * Holds cached page generator fragments
     */
    private static Map<String, String> cacheMap;

    /**
     * Constructor for JVCRequestContext which is used to hold http request and response iformation
     * @param request
     * @param response
     * @param servlet
     * @param flash
     * @param controller
     * @param action
     */
    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map<String, String> flash, String controller, String action) throws Exception {
        this.request = request;
        this.response = response;
        this.servlet = servlet;
        this.controller = controller;
        this.action = action;
        this.flash = flash;
        hasMultipartContent = ServletFileUpload.isMultipartContent(request);
        if (hasMultipartContent) {
            // Create a new file upload handler
            ServletFileUpload upload = new ServletFileUpload();
            // Parse the request
            FileItemIterator iter = upload.getItemIterator(request);
            while (iter.hasNext()) {
                FileItemStream item = iter.next();
                String name = item.getFieldName();
                InputStream stream = item.openStream();
                if (item.isFormField()) {
                    // add parameter as request attribute
                    String val = Streams.asString(stream);
                    request.setAttribute(name, val);
                    // System.out.println(""Form field "" + name + "" with value "" + val + "" detected."");
                } else {
                    // add input stream and filename as attributes
                    String fileName = item.getName();
                    request.setAttribute(""fileName"", fileName);
                    byte[] data = readStream(stream);
                    request.setAttribute(name, data);
                    // System.out.println(""File field "" + name + "" with file name "" + fileName + "" detected."");
                }
            }
        }
    }

    // request info
    /**
     * Convenience method
     * @return true if the request is secure
     */
    public boolean isSecure() {
        return request.isSecure();
    }

    /**
     * Convenience method
     * @return the request scheme, ie. http, https
     */
    public String getScheme() {
        return request.getScheme();
    }

    /**
     * Convenience method
     * @return the request method, ie. GET, POST
     */
    public String getMethod() {
        return request.getMethod();
    }

    /**
     * Convenience method
     * @return the server name for this request
     */
    public String getServerName() {
        return request.getServerName();
    }

    /**
     * Convenience method
     * @return the server port for this request
     */
    public int getServerPort() {
        return request.getServerPort();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getServletPath
     * @see #getQueryString
     * @return the context path part of the url path
     */
    public String getContextPath() {
        return request.getContextPath();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getContextPath
     * @see #getQueryString
     * @return the servlet path part of the url path
     */
    public String getServletPath() {
        return request.getServletPath();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getContextPath
     * @see #getServletPath
     * @return the query string part of the url path
     */
    public String getQueryString() {
        return request.getQueryString();
    }

    // params
    /**
     * Convenience method
     * @param name    which parameter to get
     * @return the parameter value or null if there is no parameter corresponding to the indicated key
     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,
     * which can be retrieved as a byte array via the getAttribute method.
     * @see #getParamMap
     * @see #getParamValues
     * @see #getParamNames
     */
    public String getParam(String name) {
        if (hasMultipartContent) {
            Object o = request.getAttribute(name);
            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;
        } else {
            return request.getParameter(name);
        }
    }

    /**
     * Convenience method which gathers all parameters of the
     * form '<name>[<key>]' and return then in a map where the
     * keys are the <key> strings and the values are the
     * corresponding parameter values.
     * <pre>
     * For example, if there are parameters:
     *   'foo[bar1]' = 'baz1'
     *   'foo[bar2]' = 'baz2'
     * then getParamMap('foo') will returned the map:
     *   map['bar1'] = 'baz1'
     *   map['bar2'] = 'baz2'
     * </pre>
     * @param name  the prefix to be used to select parameters
     * @return a map of all paramters of the form 'name[<key>]'
     * where the <key> strings are the keys of the map and the
     * values are the corresponding parameter values.
     * @see #getParam
     * @see #getParamValues
     * @see #getParamNames
     */
    public Map<String, String> getParamMap(String name) {
        Map<String, String> m = new HashMap<String, String>();
        String prefix = name + ""["";
        int n = prefix.length();
        if (hasMultipartContent) {
            // for multipart requests the parameters have been stored as attributes (see constructor)
            Enumeration<String> e = request.getAttributeNames();
            while (e.hasMoreElements()) {
                String key = e.nextElement();
                if (key.startsWith(prefix) && key.endsWith(""]"")) {
                    m.put(key.substring(n, key.length() - 1), getParam(key));
                }
            }
        } else {
            Map<String, String[]> pm = request.getParameterMap();
            for (String key : pm.keySet()) {
                if (key.startsWith(prefix) && key.endsWith(""]"")) {
                    m.put(key.substring(n, key.length() - 1), getParam(key));
                }
            }
        }
        return m;
    }

    /**
     * Convenience method. Use this if you expect a parameter name
     * to map to multiple values.
     * @param name    the name of the parameter(s) to get
     * @return an array of paramter values corresponding to the indicated name
     * @see #getParam
     * @see #getParamMap
     * @see #getParamNames
     */
    public String[] getParamValues(String name) {
        return request.getParameterValues(name);
    }

    /**
     * Convenience method to get all the parameter names.
     * @return an array of all parameter names
     * @see #getParam
     * @see #getParamMap
     * @see #getParamValues
     */
    public String[] getParamNames() {
        if (hasMultipartContent) {
            List<String> list = new ArrayList<String>();
            Enumeration<String> e = request.getAttributeNames();
            while (e.hasMoreElements()) {
                list.add(e.nextElement());
            }
            return list.toArray(new String[list.size()]);
        } else {
            Map<String, String[]> m = request.getParameterMap();
            String[] a = new String[m.size()];
            int i = 0;
            for (String key : m.keySet()) {
                a[i++] = key;
            }
            return a;
        }
    }

    // attributes
    /**
     * Convenience method
     * @param name    which attribute to get
     * @return the attribute value or null if there is no attribute corresponding to the indicated key.
     * If the attribute corresponds to a file upload field then the return value will be a byte array
     */
    public Object getAttribute(String name) {
        return request.getAttribute(name);
    }

    /**
     * Convenience method
     * @param name    name of attribute to be set
     * @param value   value of attribute to be set
     */
    public void setAttribute(String name, Object value) {
        request.setAttribute(name, value);
    }

    // session attributes
    /**
     * Convenience method
     * @param name    the name of the attribute to retrieve
     * @return the attribute associated with the indicated name or null
     * @see #setSessionAttr
     * @see #getSessionAttrNames
     */
    public Object getSessionAttr(String name) {
        if (request.getSession() == null)
            return null;
        return request.getSession().getAttribute(name);
    }

    /**
     * Convenience method
     * @return all the session attribute names.
     * @see #getSessionAttr
     * @see #setSessionAttr
     * @see #removeSessionAttr
     */
    public String[] getSessionAttrNames() {
        if (request.getSession(false) == null)
            return new String[0];
        ArrayList<String> a = new ArrayList<String>();
        Enumeration<String> e = request.getSession().getAttributeNames();
        while (e.hasMoreElements()) {
            a.add(e.nextElement());
        }
        return a.toArray(new String[a.size()]);
    }

    /**
     * Convenience method
     * @param name  the key to store the indicated value
     * @param value  the object to be stored
     * @see #getSessionAttr
     * @see #removeSessionAttr
     */
    public void setSessionAttr(String name, Object value) {
        if (request.getSession() == null)
            return;
        request.getSession().setAttribute(name, value);
    }

    /**
     * Convenience method
     * @param name  the key of
     * @see #setSessionAttr
     */
    public void removeSessionAttr(String name) {
        if (request.getSession() == null)
            return;
        request.getSession().removeAttribute(name);
    }

    // cookies
    /**
     * Convenience method to get cookie by name
     * @param name  the name of the cookie to get
     * @return the cookie with the indicated name, or null
     * @see #setCookie
     * @see #getCookieNames
     */
    public Cookie getCookie(String name) {
        if (name == null)
            return null;
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return null;
        for (Cookie c : cookies) {
            if (name.equals(c.getName()))
                return c;
        }
        return null;
    }

    /**
     * Convenience method to get all the cookie names.
     * @return an array of the names of all the cookies in the request, possibly empty
     * @see #getCookie
     * @see #setCookie
     */
    public String[] getCookieNames() {
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return new String[0];
        String[] a = new String[cookies.length];
        int i = 0;
        for (Cookie c : cookies) {
            a[i++] = c.getName();
        }
        return a;
    }

    /**
     * Convenience method
     * @param cookie   the cookie to be added to the response
     * @see #getCookie
     * @see #getCookieNames
     */
    public void setCookie(Cookie cookie) {
        response.addCookie(cookie);
    }

    /**
     * Cause a non-standard response (ie. redirect) to be returned.
     * @param httpCode   the http response code to be returned
     * @param arg    an argument or message to be returned (depends on response code)
     * @see #redirect
     * @throws NonStandardResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the NonStandardResponseException.
     */
    public void nonStandardResponse(int httpCode, String arg) {
        throw new NonStandardResponseException(httpCode, arg);
    }

    /**
     * Cause a redirect response to be returned
     * @param path  where to redirect to. If the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @see #nonStandardResponse
     * @throws NonStandardResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the NonStandardResponseException.
     */
    public void redirect(String path) {
        if (path.startsWith(""/""))
            path = absPath(path);
        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);
    }

    /**
     * Cause a binary response to be returned
     * @param in input stream containing binary data to be sent
     * @throws BinaryResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the BinaryResponseException.
     */
    public void sendBinaryResponse(InputStream in) {
        throw new BinaryResponseException(in);
    }

    /**
     * Convenience method to prepend the context path onto a servlet path
     * @param path    a servlet path
     * @return the context path plus the indicated path
     */
    public String absPath(String path) {
        return getContextPath() + (path.startsWith(""/"") ? path : ""/"" + path);
    }

    /**
     * Convenience method to create an html anchor link tag
     * @param anchor    the text in an anchor link
     * @param path   the anchor target, if the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @see #makeLink
     * @see #absPath
     */
    public String makeLink(String anchor, String path) {
        return makeLink(anchor, path, """");
    }

    /**
     * Convenience method to create an html anchor link tag
     * @param anchor    the text in an anchor link
     * @param path   the anchor target, if the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @param options    extra html options to add to the anchor tag
     * @see #makeLink
     * @see #absPath
     */
    public String makeLink(String anchor, String path, String options) {
        if (path.startsWith(""/""))
            path = absPath(path);
        return ""<a href='"" + path + ""' "" + options + "">"" + anchor + ""</a>"";
    }

    /**
     * Convenience method to check if this request is a POST
     */
    public boolean isPost() {
        return ""POST"".equals(request.getMethod());
    }

    /**
     * Convenience method to check if this request is a GET
     */
    public boolean isGet() {
        return ""GET"".equals(request.getMethod());
    }

    /**
     * Convenience method to retrieve a value from the flash
     * @param key  the key to use to lookup a flash value
     * @return the flash value associated with the indicated key or null
     * @see #setFlash
     */
    public String getFlash(String key) {
        return flash.get(key);
    }

    /**
     * Convenience method to add a value to the flash
     * @param key  the key to use to associate with the flash value
     * @param val  the value to store
     * @see #getFlash
     */
    public void setFlash(String key, String val) {
        flash.put(key, val);
    }

    // caching (internal use)
    /**
     * Internal method used to retrieve a cached block
     * @see #setCachedBlock
     */
    public static String getCachedBlock(String key) {
        return (cacheMap == null) ? null : cacheMap.get(key);
    }

    /**
     * Internal method used to store a cached block
     * @see #getCachedBlock
     */
    public static void setCachedBlock(String key, String val) {
        if (cacheMap == null) {
            cacheMap = new HashMap<String, String>();
        }
        cacheMap.put(key, val);
    }

    /**
     * For debugging
     * @return a string representation of this request context
     */
    public String toString() {
        return toString("", "");
    }

    public String toString(String sep) {
        StringBuilder sb = new StringBuilder();
        sb.append(""params: ["");
        String[] keys = getParamNames();
        for (String key : keys) {
            sb.append(key).append('=').append(getParam(key)).append(sep);
        }
        if (keys.length > 0) {
            sb.setLength(sb.length() - sep.length());
        }
        sb.append(""]"");
        sb.append(sep).append(""method: "").append(getMethod());
        sb.append(sep).append(""url: "").append(getScheme());
        sb.append(""|"").append(getServerName());
        sb.append(""|"").append(getServerPort());
        sb.append(""|"").append(getContextPath());
        sb.append(""|"").append(getServletPath());
        sb.append(""|"").append(getQueryString());
        if (hasMultipartContent) {
            sb.append(sep).append(""content len: "").append(request.getContentLength());
            //sb.append(sep).append(""content type: "").append(request.getContentType());
        }
        return sb.toString();
    }

    /**
     * Copy an input stream to an output stream.
     */
    private byte[] readStream(InputStream in) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        byte[] buf = new byte[4096];
        int read;
        while ((read = in.read(buf)) > -1) {
            out.write(buf, 0, read);
        }
        out.flush();
        return out.toByteArray();
    }
}
","// JVCRequestContext_7Test.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JVCRequestContext}.
* It contains ten unit test cases for the {@link JVCRequestContext#makeLink(String, String)} method.
*/
class JVCRequestContext_7Test {","```java
import static org.junit.jupiter.api.Assertions.assertEquals;

class JVCRequestContext_7Test {

    @Test
    void testMakeLink_WithAnchorAndPath_ReturnsCorrectLink() {
        JVCRequestContext context = new JVCRequestContext();
        String anchor = ""Click Here"";
        String path = ""/home"";
        String expectedLink = ""<a href='/contextPath/home' >Click Here</a>"";
        
        String actualLink = context.makeLink(anchor, path);
        
        assertEquals(expectedLink, actualLink);
    }

    @Test
    void testMakeLink_WithAnchorPathAndOptions_ReturnsCorrectLink() {
        JVCRequestContext context = new JVCRequestContext();
        String anchor = ""Click Here"";
        String path = ""/about"";
        String options = ""target='_blank'"";
        String expectedLink = ""<a href='/contextPath/about' target='_blank'>Click Here</a>"";
        
        String actualLink = context.makeLink(anchor, path, options);
        
        assertEquals(expectedLink, actualLink);
    }

    @Test
    void testMakeLink_WithAbsolutePath_ReturnsCorrectLink() {
        JVCRequestContext context = new JVCRequestContext();
        String anchor = ""Home"";
        String path = ""/external"";
        String expectedLink = ""<a href='/external' >Home</a>"";
        
        String actualLink = context.makeLink(anchor, path);
        
        assertEquals(expectedLink, actualLink);
    }

    @Test
    void testMakeLink_WithEmptyAnchor_ReturnsCorrectLink() {
        JVCRequestContext context = new JVCRequestContext();
        String anchor = """";
        String path = ""/contact"";
        String expectedLink = ""<a href='/contextPath/contact' ></a>"";
        
        String actualLink = context.makeLink(anchor, path);
        
        assertEquals(expectedLink, actualLink);
    }

    @Test
    void testMakeLink_WithEmptyPath_ReturnsCorrectLink() {
        JVCRequestContext context = new JVCRequestContext();
        String anchor = ""Contact Us"";
        String path = """";
        String expectedLink = ""<a href='/contextPath/' >Contact Us</a>"";
        
        String actualLink = context.makeLink(anchor, path);
        
        assertEquals(expectedLink, actualLink);
    }

    @Test
    void testMakeLink_WithNullAnchor_ReturnsCorrectLink() {
        JVCRequestContext context = new JVCRequestContext();
        String anchor = null;
        String path = ""/services"";
        String expectedLink = ""<a href='/contextPath/services' ></a>"";
        
        String actualLink = context.makeLink(anchor, path);
        
        assertEquals(expectedLink, actualLink);
    }

    @Test
    void testMakeLink_WithNullPath_ReturnsCorrectLink() {
        JVCRequestContext context = new JVCRequestContext();
        String anchor = ""Services"";
        String path = null;
        String expectedLink = ""<a href='/contextPath/' >Services</a>"";
        
        String actualLink = context.makeLink(anchor, path);
        
        assertEquals(expectedLink, actualLink);
    }

    @Test
    void testMakeLink_WithNullAnchorAndPath_ReturnsCorrectLink() {
        JVCRequestContext context = new JVCRequestContext();
        String anchor = null;
        String path = null;
        String expectedLink = ""<a href='/contextPath/' ></a>"";
        
        String actualLink = context.makeLink(anchor, path);
        
        assertEquals(expectedLink, actualLink);
    }

    @Test
    void testMakeLink_WithSpecialCharactersInAnchor_ReturnsCorrectLink() {
        JVCRequestContext context = new JVCRequestContext();
        String anchor = ""Special & Characters"";
        String path = ""/special"";
        String expectedLink = ""<a href='/contextPath/special' >Special &amp; Characters</a>"";
        
        String actualLink = context.makeLink(anchor, path);
        
        assertEquals(expectedLink, actualLink);
    }

    @Test
    void testMakeLink_WithSpecialCharactersInPath_ReturnsCorrectLink() {
        JVCRequestContext context = new JVCRequestContext();
        String anchor = ""Special Path"";
        String path = ""/special?param=1"";
        String expectedLink = ""<a href='/contextPath/special?param=1' >Special Path</a>"";
        
        String actualLink = context.makeLink(anchor, path);
        
        assertEquals(expectedLink, actualLink);
    }
}
```
```"
chatcmpl-A5UZHml2Gy5uXrFlr1xVjKPsxKV6a,/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContext_8Test.java,12.109760761260986,stop,"// JVCRequestContext.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

/**
 * This class contains state information for processing an http request.
 * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet
 * objects and provides convenience methods for accessing them.
 * <p>
 * It also provides access to the 'flash' which is a Map for storing temporary
 * key/value strings.  The scope of the flash is the current request or
 * the following request in the case of a redirect response.
 * <p>
 * It also contains some convenience methods for forming links and absolute paths.
 *
 * @author mike dooley
 */
public final class JVCRequestContext {

    /**
     * The actual HttpServletRequest object
     */
    public final HttpServletRequest request;

    /**
     * The actual HttpServletResponse object
     */
    public final HttpServletResponse response;

    /**
     * The HttpServlet object (actually this is a JVCDispatcher)
     */
    public final HttpServlet servlet;

    /**
     * The controller is the servlet path up to the action.
     */
    public final String controller;

    /**
     * The action is the last part of the servlet path (before any query arguments)
     */
    public final String action;

    /**
     * Tells if this request has multipart content (ie file upload)
     */
    public final boolean hasMultipartContent;

    /**
     * Parameter value indicating that the real parameter value is binary (and should be
     * accessed via the getAttribute() method.
     */
    public static final String BINARY_VALUE = ""BINARY_VALUE"";

    /**
     * The 'flash' map for holding temporary key/value strings.
     */
    public final Map<String, String> flash;

    /**
     * Holds cached page generator fragments
     */
    private static Map<String, String> cacheMap;

    /**
     * Constructor for JVCRequestContext which is used to hold http request and response iformation
     * @param request
     * @param response
     * @param servlet
     * @param flash
     * @param controller
     * @param action
     */
    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map<String, String> flash, String controller, String action) throws Exception {
        this.request = request;
        this.response = response;
        this.servlet = servlet;
        this.controller = controller;
        this.action = action;
        this.flash = flash;
        hasMultipartContent = ServletFileUpload.isMultipartContent(request);
        if (hasMultipartContent) {
            // Create a new file upload handler
            ServletFileUpload upload = new ServletFileUpload();
            // Parse the request
            FileItemIterator iter = upload.getItemIterator(request);
            while (iter.hasNext()) {
                FileItemStream item = iter.next();
                String name = item.getFieldName();
                InputStream stream = item.openStream();
                if (item.isFormField()) {
                    // add parameter as request attribute
                    String val = Streams.asString(stream);
                    request.setAttribute(name, val);
                    // System.out.println(""Form field "" + name + "" with value "" + val + "" detected."");
                } else {
                    // add input stream and filename as attributes
                    String fileName = item.getName();
                    request.setAttribute(""fileName"", fileName);
                    byte[] data = readStream(stream);
                    request.setAttribute(name, data);
                    // System.out.println(""File field "" + name + "" with file name "" + fileName + "" detected."");
                }
            }
        }
    }

    // request info
    /**
     * Convenience method
     * @return true if the request is secure
     */
    public boolean isSecure() {
        return request.isSecure();
    }

    /**
     * Convenience method
     * @return the request scheme, ie. http, https
     */
    public String getScheme() {
        return request.getScheme();
    }

    /**
     * Convenience method
     * @return the request method, ie. GET, POST
     */
    public String getMethod() {
        return request.getMethod();
    }

    /**
     * Convenience method
     * @return the server name for this request
     */
    public String getServerName() {
        return request.getServerName();
    }

    /**
     * Convenience method
     * @return the server port for this request
     */
    public int getServerPort() {
        return request.getServerPort();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getServletPath
     * @see #getQueryString
     * @return the context path part of the url path
     */
    public String getContextPath() {
        return request.getContextPath();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getContextPath
     * @see #getQueryString
     * @return the servlet path part of the url path
     */
    public String getServletPath() {
        return request.getServletPath();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getContextPath
     * @see #getServletPath
     * @return the query string part of the url path
     */
    public String getQueryString() {
        return request.getQueryString();
    }

    // params
    /**
     * Convenience method
     * @param name    which parameter to get
     * @return the parameter value or null if there is no parameter corresponding to the indicated key
     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,
     * which can be retrieved as a byte array via the getAttribute method.
     * @see #getParamMap
     * @see #getParamValues
     * @see #getParamNames
     */
    public String getParam(String name) {
        if (hasMultipartContent) {
            Object o = request.getAttribute(name);
            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;
        } else {
            return request.getParameter(name);
        }
    }

    /**
     * Convenience method which gathers all parameters of the
     * form '<name>[<key>]' and return then in a map where the
     * keys are the <key> strings and the values are the
     * corresponding parameter values.
     * <pre>
     * For example, if there are parameters:
     *   'foo[bar1]' = 'baz1'
     *   'foo[bar2]' = 'baz2'
     * then getParamMap('foo') will returned the map:
     *   map['bar1'] = 'baz1'
     *   map['bar2'] = 'baz2'
     * </pre>
     * @param name  the prefix to be used to select parameters
     * @return a map of all paramters of the form 'name[<key>]'
     * where the <key> strings are the keys of the map and the
     * values are the corresponding parameter values.
     * @see #getParam
     * @see #getParamValues
     * @see #getParamNames
     */
    public Map<String, String> getParamMap(String name) {
        Map<String, String> m = new HashMap<String, String>();
        String prefix = name + ""["";
        int n = prefix.length();
        if (hasMultipartContent) {
            // for multipart requests the parameters have been stored as attributes (see constructor)
            Enumeration<String> e = request.getAttributeNames();
            while (e.hasMoreElements()) {
                String key = e.nextElement();
                if (key.startsWith(prefix) && key.endsWith(""]"")) {
                    m.put(key.substring(n, key.length() - 1), getParam(key));
                }
            }
        } else {
            Map<String, String[]> pm = request.getParameterMap();
            for (String key : pm.keySet()) {
                if (key.startsWith(prefix) && key.endsWith(""]"")) {
                    m.put(key.substring(n, key.length() - 1), getParam(key));
                }
            }
        }
        return m;
    }

    /**
     * Convenience method. Use this if you expect a parameter name
     * to map to multiple values.
     * @param name    the name of the parameter(s) to get
     * @return an array of paramter values corresponding to the indicated name
     * @see #getParam
     * @see #getParamMap
     * @see #getParamNames
     */
    public String[] getParamValues(String name) {
        return request.getParameterValues(name);
    }

    /**
     * Convenience method to get all the parameter names.
     * @return an array of all parameter names
     * @see #getParam
     * @see #getParamMap
     * @see #getParamValues
     */
    public String[] getParamNames() {
        if (hasMultipartContent) {
            List<String> list = new ArrayList<String>();
            Enumeration<String> e = request.getAttributeNames();
            while (e.hasMoreElements()) {
                list.add(e.nextElement());
            }
            return list.toArray(new String[list.size()]);
        } else {
            Map<String, String[]> m = request.getParameterMap();
            String[] a = new String[m.size()];
            int i = 0;
            for (String key : m.keySet()) {
                a[i++] = key;
            }
            return a;
        }
    }

    // attributes
    /**
     * Convenience method
     * @param name    which attribute to get
     * @return the attribute value or null if there is no attribute corresponding to the indicated key.
     * If the attribute corresponds to a file upload field then the return value will be a byte array
     */
    public Object getAttribute(String name) {
        return request.getAttribute(name);
    }

    /**
     * Convenience method
     * @param name    name of attribute to be set
     * @param value   value of attribute to be set
     */
    public void setAttribute(String name, Object value) {
        request.setAttribute(name, value);
    }

    // session attributes
    /**
     * Convenience method
     * @param name    the name of the attribute to retrieve
     * @return the attribute associated with the indicated name or null
     * @see #setSessionAttr
     * @see #getSessionAttrNames
     */
    public Object getSessionAttr(String name) {
        if (request.getSession() == null)
            return null;
        return request.getSession().getAttribute(name);
    }

    /**
     * Convenience method
     * @return all the session attribute names.
     * @see #getSessionAttr
     * @see #setSessionAttr
     * @see #removeSessionAttr
     */
    public String[] getSessionAttrNames() {
        if (request.getSession(false) == null)
            return new String[0];
        ArrayList<String> a = new ArrayList<String>();
        Enumeration<String> e = request.getSession().getAttributeNames();
        while (e.hasMoreElements()) {
            a.add(e.nextElement());
        }
        return a.toArray(new String[a.size()]);
    }

    /**
     * Convenience method
     * @param name  the key to store the indicated value
     * @param value  the object to be stored
     * @see #getSessionAttr
     * @see #removeSessionAttr
     */
    public void setSessionAttr(String name, Object value) {
        if (request.getSession() == null)
            return;
        request.getSession().setAttribute(name, value);
    }

    /**
     * Convenience method
     * @param name  the key of
     * @see #setSessionAttr
     */
    public void removeSessionAttr(String name) {
        if (request.getSession() == null)
            return;
        request.getSession().removeAttribute(name);
    }

    // cookies
    /**
     * Convenience method to get cookie by name
     * @param name  the name of the cookie to get
     * @return the cookie with the indicated name, or null
     * @see #setCookie
     * @see #getCookieNames
     */
    public Cookie getCookie(String name) {
        if (name == null)
            return null;
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return null;
        for (Cookie c : cookies) {
            if (name.equals(c.getName()))
                return c;
        }
        return null;
    }

    /**
     * Convenience method to get all the cookie names.
     * @return an array of the names of all the cookies in the request, possibly empty
     * @see #getCookie
     * @see #setCookie
     */
    public String[] getCookieNames() {
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return new String[0];
        String[] a = new String[cookies.length];
        int i = 0;
        for (Cookie c : cookies) {
            a[i++] = c.getName();
        }
        return a;
    }

    /**
     * Convenience method
     * @param cookie   the cookie to be added to the response
     * @see #getCookie
     * @see #getCookieNames
     */
    public void setCookie(Cookie cookie) {
        response.addCookie(cookie);
    }

    /**
     * Cause a non-standard response (ie. redirect) to be returned.
     * @param httpCode   the http response code to be returned
     * @param arg    an argument or message to be returned (depends on response code)
     * @see #redirect
     * @throws NonStandardResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the NonStandardResponseException.
     */
    public void nonStandardResponse(int httpCode, String arg) {
        throw new NonStandardResponseException(httpCode, arg);
    }

    /**
     * Cause a redirect response to be returned
     * @param path  where to redirect to. If the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @see #nonStandardResponse
     * @throws NonStandardResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the NonStandardResponseException.
     */
    public void redirect(String path) {
        if (path.startsWith(""/""))
            path = absPath(path);
        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);
    }

    /**
     * Cause a binary response to be returned
     * @param in input stream containing binary data to be sent
     * @throws BinaryResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the BinaryResponseException.
     */
    public void sendBinaryResponse(InputStream in) {
        throw new BinaryResponseException(in);
    }

    /**
     * Convenience method to prepend the context path onto a servlet path
     * @param path    a servlet path
     * @return the context path plus the indicated path
     */
    public String absPath(String path) {
        return getContextPath() + (path.startsWith(""/"") ? path : ""/"" + path);
    }

    /**
     * Convenience method to create an html anchor link tag
     * @param anchor    the text in an anchor link
     * @param path   the anchor target, if the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @see #makeLink
     * @see #absPath
     */
    public String makeLink(String anchor, String path) {
        return makeLink(anchor, path, """");
    }

    /**
     * Convenience method to create an html anchor link tag
     * @param anchor    the text in an anchor link
     * @param path   the anchor target, if the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @param options    extra html options to add to the anchor tag
     * @see #makeLink
     * @see #absPath
     */
    public String makeLink(String anchor, String path, String options) {
        if (path.startsWith(""/""))
            path = absPath(path);
        return ""<a href='"" + path + ""' "" + options + "">"" + anchor + ""</a>"";
    }

    /**
     * Convenience method to check if this request is a POST
     */
    public boolean isPost() {
        return ""POST"".equals(request.getMethod());
    }

    /**
     * Convenience method to check if this request is a GET
     */
    public boolean isGet() {
        return ""GET"".equals(request.getMethod());
    }

    /**
     * Convenience method to retrieve a value from the flash
     * @param key  the key to use to lookup a flash value
     * @return the flash value associated with the indicated key or null
     * @see #setFlash
     */
    public String getFlash(String key) {
        return flash.get(key);
    }

    /**
     * Convenience method to add a value to the flash
     * @param key  the key to use to associate with the flash value
     * @param val  the value to store
     * @see #getFlash
     */
    public void setFlash(String key, String val) {
        flash.put(key, val);
    }

    // caching (internal use)
    /**
     * Internal method used to retrieve a cached block
     * @see #setCachedBlock
     */
    public static String getCachedBlock(String key) {
        return (cacheMap == null) ? null : cacheMap.get(key);
    }

    /**
     * Internal method used to store a cached block
     * @see #getCachedBlock
     */
    public static void setCachedBlock(String key, String val) {
        if (cacheMap == null) {
            cacheMap = new HashMap<String, String>();
        }
        cacheMap.put(key, val);
    }

    /**
     * For debugging
     * @return a string representation of this request context
     */
    public String toString() {
        return toString("", "");
    }

    public String toString(String sep) {
        StringBuilder sb = new StringBuilder();
        sb.append(""params: ["");
        String[] keys = getParamNames();
        for (String key : keys) {
            sb.append(key).append('=').append(getParam(key)).append(sep);
        }
        if (keys.length > 0) {
            sb.setLength(sb.length() - sep.length());
        }
        sb.append(""]"");
        sb.append(sep).append(""method: "").append(getMethod());
        sb.append(sep).append(""url: "").append(getScheme());
        sb.append(""|"").append(getServerName());
        sb.append(""|"").append(getServerPort());
        sb.append(""|"").append(getContextPath());
        sb.append(""|"").append(getServletPath());
        sb.append(""|"").append(getQueryString());
        if (hasMultipartContent) {
            sb.append(sep).append(""content len: "").append(request.getContentLength());
            //sb.append(sep).append(""content type: "").append(request.getContentType());
        }
        return sb.toString();
    }

    /**
     * Copy an input stream to an output stream.
     */
    private byte[] readStream(InputStream in) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        byte[] buf = new byte[4096];
        int read;
        while ((read = in.read(buf)) > -1) {
            out.write(buf, 0, read);
        }
        out.flush();
        return out.toByteArray();
    }
}
","// JVCRequestContext_8Test.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JVCRequestContext}.
* It contains ten unit test cases for the {@link JVCRequestContext#makeLink(String, String, String)} method.
*/
class JVCRequestContext_8Test {","```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class JVCRequestContext_8Test {

    @Test
    void testMakeLinkWithAnchorAndPath() {
        JVCRequestContext context = new JVCRequestContext();
        String anchor = ""Home"";
        String path = ""/home"";
        String expected = ""<a href='/contextPath/home' >Home</a>"";
        String actual = context.makeLink(anchor, path);
        assertEquals(expected, actual);
    }

    @Test
    void testMakeLinkWithAnchorPathAndOptions() {
        JVCRequestContext context = new JVCRequestContext();
        String anchor = ""About"";
        String path = ""/about"";
        String options = ""class='link'"";
        String expected = ""<a href='/contextPath/about' class='link'>About</a>"";
        String actual = context.makeLink(anchor, path, options);
        assertEquals(expected, actual);
    }

    @Test
    void testMakeLinkWithEmptyAnchorAndPath() {
        JVCRequestContext context = new JVCRequestContext();
        String anchor = """";
        String path = ""/contact"";
        String expected = ""<a href='/contextPath/contact' ></a>"";
        String actual = context.makeLink(anchor, path);
        assertEquals(expected, actual);
    }

    @Test
    void testMakeLinkWithAnchorAndEmptyPath() {
        JVCRequestContext context = new JVCRequestContext();
        String anchor = ""Services"";
        String path = """";
        String expected = ""<a href='/contextPath/' >Services</a>"";
        String actual = context.makeLink(anchor, path);
        assertEquals(expected, actual);
    }

    @Test
    void testMakeLinkWithNullAnchorAndPath() {
        JVCRequestContext context = new JVCRequestContext();
        String anchor = null;
        String path = null;
        String expected = ""<a href='/contextPath/' ></a>"";
        String actual = context.makeLink(anchor, path);
        assertEquals(expected, actual);
    }

    @Test
    void testMakeLinkWithSpecialCharactersInAnchorAndPath() {
        JVCRequestContext context = new JVCRequestContext();
        String anchor = ""Contact Us & Support"";
        String path = ""/contact-us"";
        String expected = ""<a href='/contextPath/contact-us' >Contact Us & Support</a>"";
        String actual = context.makeLink(anchor, path);
        assertEquals(expected, actual);
    }

    @Test
    void testMakeLinkWithSpecialCharactersInOptions() {
        JVCRequestContext context = new JVCRequestContext();
        String anchor = ""Privacy Policy"";
        String path = ""/privacy"";
        String options = ""class='link' data-id='123'"";
        String expected = ""<a href='/contextPath/privacy' class='link' data-id='123'>Privacy Policy</a>"";
        String actual = context.makeLink(anchor, path, options);
        assertEquals(expected, actual);
    }

    @Test
    void testMakeLinkWithLongAnchorAndPath() {
        JVCRequestContext context = new JVCRequestContext();
        String anchor = ""This is a very long anchor text that exceeds the usual length"";
        String path = ""/long-path-example"";
        String expected = ""<a href='/contextPath/long-path-example' >This is a very long anchor text that exceeds the usual length</a>"";
        String actual = context.makeLink(anchor, path);
        assertEquals(expected, actual);
    }

    @Test
    void testMakeLinkWithMultipleSpacesInAnchorAndPath() {
        JVCRequestContext context = new JVCRequestContext();
        String anchor = ""   Multiple   Spaces   "";
        String path = ""/multiple-spaces"";
        String expected = ""<a href='/contextPath/multiple-spaces' >   Multiple   Spaces   </a>"";
        String actual = context.makeLink(anchor, path);
        assertEquals(expected, actual);
    }

    @Test
    void testMakeLinkWithNumbersInAnchorAndPath() {
        JVCRequestContext context = new JVCRequestContext();
        String anchor = ""12345"";
        String path = ""/numbers"";
        String expected = ""<a href='/contextPath/numbers' >12345</a>"";
        String actual = context.makeLink(anchor, path);
        assertEquals(expected, actual);
    }
}
```"
chatcmpl-A5UaKEjIdh8P8ADJ3qt7583n9UG6X,/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContext_9Test.java,8.36914849281311,stop,"// JVCRequestContext.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

/**
 * This class contains state information for processing an http request.
 * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet
 * objects and provides convenience methods for accessing them.
 * <p>
 * It also provides access to the 'flash' which is a Map for storing temporary
 * key/value strings.  The scope of the flash is the current request or
 * the following request in the case of a redirect response.
 * <p>
 * It also contains some convenience methods for forming links and absolute paths.
 *
 * @author mike dooley
 */
public final class JVCRequestContext {

    /**
     * The actual HttpServletRequest object
     */
    public final HttpServletRequest request;

    /**
     * The actual HttpServletResponse object
     */
    public final HttpServletResponse response;

    /**
     * The HttpServlet object (actually this is a JVCDispatcher)
     */
    public final HttpServlet servlet;

    /**
     * The controller is the servlet path up to the action.
     */
    public final String controller;

    /**
     * The action is the last part of the servlet path (before any query arguments)
     */
    public final String action;

    /**
     * Tells if this request has multipart content (ie file upload)
     */
    public final boolean hasMultipartContent;

    /**
     * Parameter value indicating that the real parameter value is binary (and should be
     * accessed via the getAttribute() method.
     */
    public static final String BINARY_VALUE = ""BINARY_VALUE"";

    /**
     * The 'flash' map for holding temporary key/value strings.
     */
    public final Map<String, String> flash;

    /**
     * Holds cached page generator fragments
     */
    private static Map<String, String> cacheMap;

    /**
     * Constructor for JVCRequestContext which is used to hold http request and response iformation
     * @param request
     * @param response
     * @param servlet
     * @param flash
     * @param controller
     * @param action
     */
    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map<String, String> flash, String controller, String action) throws Exception {
        this.request = request;
        this.response = response;
        this.servlet = servlet;
        this.controller = controller;
        this.action = action;
        this.flash = flash;
        hasMultipartContent = ServletFileUpload.isMultipartContent(request);
        if (hasMultipartContent) {
            // Create a new file upload handler
            ServletFileUpload upload = new ServletFileUpload();
            // Parse the request
            FileItemIterator iter = upload.getItemIterator(request);
            while (iter.hasNext()) {
                FileItemStream item = iter.next();
                String name = item.getFieldName();
                InputStream stream = item.openStream();
                if (item.isFormField()) {
                    // add parameter as request attribute
                    String val = Streams.asString(stream);
                    request.setAttribute(name, val);
                    // System.out.println(""Form field "" + name + "" with value "" + val + "" detected."");
                } else {
                    // add input stream and filename as attributes
                    String fileName = item.getName();
                    request.setAttribute(""fileName"", fileName);
                    byte[] data = readStream(stream);
                    request.setAttribute(name, data);
                    // System.out.println(""File field "" + name + "" with file name "" + fileName + "" detected."");
                }
            }
        }
    }

    // request info
    /**
     * Convenience method
     * @return true if the request is secure
     */
    public boolean isSecure() {
        return request.isSecure();
    }

    /**
     * Convenience method
     * @return the request scheme, ie. http, https
     */
    public String getScheme() {
        return request.getScheme();
    }

    /**
     * Convenience method
     * @return the request method, ie. GET, POST
     */
    public String getMethod() {
        return request.getMethod();
    }

    /**
     * Convenience method
     * @return the server name for this request
     */
    public String getServerName() {
        return request.getServerName();
    }

    /**
     * Convenience method
     * @return the server port for this request
     */
    public int getServerPort() {
        return request.getServerPort();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getServletPath
     * @see #getQueryString
     * @return the context path part of the url path
     */
    public String getContextPath() {
        return request.getContextPath();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getContextPath
     * @see #getQueryString
     * @return the servlet path part of the url path
     */
    public String getServletPath() {
        return request.getServletPath();
    }

    /**
     * Convenience method.  The request url path is broken into:
     * <ul>
     * <li>context path</li>
     * <li>servlet path</li>
     * <li>query string</li>
     * </ul>
     * @see #getContextPath
     * @see #getServletPath
     * @return the query string part of the url path
     */
    public String getQueryString() {
        return request.getQueryString();
    }

    // params
    /**
     * Convenience method
     * @param name    which parameter to get
     * @return the parameter value or null if there is no parameter corresponding to the indicated key
     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,
     * which can be retrieved as a byte array via the getAttribute method.
     * @see #getParamMap
     * @see #getParamValues
     * @see #getParamNames
     */
    public String getParam(String name) {
        if (hasMultipartContent) {
            Object o = request.getAttribute(name);
            return (o != null && o instanceof String) ? (String) o : BINARY_VALUE;
        } else {
            return request.getParameter(name);
        }
    }

    /**
     * Convenience method which gathers all parameters of the
     * form '<name>[<key>]' and return then in a map where the
     * keys are the <key> strings and the values are the
     * corresponding parameter values.
     * <pre>
     * For example, if there are parameters:
     *   'foo[bar1]' = 'baz1'
     *   'foo[bar2]' = 'baz2'
     * then getParamMap('foo') will returned the map:
     *   map['bar1'] = 'baz1'
     *   map['bar2'] = 'baz2'
     * </pre>
     * @param name  the prefix to be used to select parameters
     * @return a map of all paramters of the form 'name[<key>]'
     * where the <key> strings are the keys of the map and the
     * values are the corresponding parameter values.
     * @see #getParam
     * @see #getParamValues
     * @see #getParamNames
     */
    public Map<String, String> getParamMap(String name) {
        Map<String, String> m = new HashMap<String, String>();
        String prefix = name + ""["";
        int n = prefix.length();
        if (hasMultipartContent) {
            // for multipart requests the parameters have been stored as attributes (see constructor)
            Enumeration<String> e = request.getAttributeNames();
            while (e.hasMoreElements()) {
                String key = e.nextElement();
                if (key.startsWith(prefix) && key.endsWith(""]"")) {
                    m.put(key.substring(n, key.length() - 1), getParam(key));
                }
            }
        } else {
            Map<String, String[]> pm = request.getParameterMap();
            for (String key : pm.keySet()) {
                if (key.startsWith(prefix) && key.endsWith(""]"")) {
                    m.put(key.substring(n, key.length() - 1), getParam(key));
                }
            }
        }
        return m;
    }

    /**
     * Convenience method. Use this if you expect a parameter name
     * to map to multiple values.
     * @param name    the name of the parameter(s) to get
     * @return an array of paramter values corresponding to the indicated name
     * @see #getParam
     * @see #getParamMap
     * @see #getParamNames
     */
    public String[] getParamValues(String name) {
        return request.getParameterValues(name);
    }

    /**
     * Convenience method to get all the parameter names.
     * @return an array of all parameter names
     * @see #getParam
     * @see #getParamMap
     * @see #getParamValues
     */
    public String[] getParamNames() {
        if (hasMultipartContent) {
            List<String> list = new ArrayList<String>();
            Enumeration<String> e = request.getAttributeNames();
            while (e.hasMoreElements()) {
                list.add(e.nextElement());
            }
            return list.toArray(new String[list.size()]);
        } else {
            Map<String, String[]> m = request.getParameterMap();
            String[] a = new String[m.size()];
            int i = 0;
            for (String key : m.keySet()) {
                a[i++] = key;
            }
            return a;
        }
    }

    // attributes
    /**
     * Convenience method
     * @param name    which attribute to get
     * @return the attribute value or null if there is no attribute corresponding to the indicated key.
     * If the attribute corresponds to a file upload field then the return value will be a byte array
     */
    public Object getAttribute(String name) {
        return request.getAttribute(name);
    }

    /**
     * Convenience method
     * @param name    name of attribute to be set
     * @param value   value of attribute to be set
     */
    public void setAttribute(String name, Object value) {
        request.setAttribute(name, value);
    }

    // session attributes
    /**
     * Convenience method
     * @param name    the name of the attribute to retrieve
     * @return the attribute associated with the indicated name or null
     * @see #setSessionAttr
     * @see #getSessionAttrNames
     */
    public Object getSessionAttr(String name) {
        if (request.getSession() == null)
            return null;
        return request.getSession().getAttribute(name);
    }

    /**
     * Convenience method
     * @return all the session attribute names.
     * @see #getSessionAttr
     * @see #setSessionAttr
     * @see #removeSessionAttr
     */
    public String[] getSessionAttrNames() {
        if (request.getSession(false) == null)
            return new String[0];
        ArrayList<String> a = new ArrayList<String>();
        Enumeration<String> e = request.getSession().getAttributeNames();
        while (e.hasMoreElements()) {
            a.add(e.nextElement());
        }
        return a.toArray(new String[a.size()]);
    }

    /**
     * Convenience method
     * @param name  the key to store the indicated value
     * @param value  the object to be stored
     * @see #getSessionAttr
     * @see #removeSessionAttr
     */
    public void setSessionAttr(String name, Object value) {
        if (request.getSession() == null)
            return;
        request.getSession().setAttribute(name, value);
    }

    /**
     * Convenience method
     * @param name  the key of
     * @see #setSessionAttr
     */
    public void removeSessionAttr(String name) {
        if (request.getSession() == null)
            return;
        request.getSession().removeAttribute(name);
    }

    // cookies
    /**
     * Convenience method to get cookie by name
     * @param name  the name of the cookie to get
     * @return the cookie with the indicated name, or null
     * @see #setCookie
     * @see #getCookieNames
     */
    public Cookie getCookie(String name) {
        if (name == null)
            return null;
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return null;
        for (Cookie c : cookies) {
            if (name.equals(c.getName()))
                return c;
        }
        return null;
    }

    /**
     * Convenience method to get all the cookie names.
     * @return an array of the names of all the cookies in the request, possibly empty
     * @see #getCookie
     * @see #setCookie
     */
    public String[] getCookieNames() {
        Cookie[] cookies = request.getCookies();
        if (cookies == null)
            return new String[0];
        String[] a = new String[cookies.length];
        int i = 0;
        for (Cookie c : cookies) {
            a[i++] = c.getName();
        }
        return a;
    }

    /**
     * Convenience method
     * @param cookie   the cookie to be added to the response
     * @see #getCookie
     * @see #getCookieNames
     */
    public void setCookie(Cookie cookie) {
        response.addCookie(cookie);
    }

    /**
     * Cause a non-standard response (ie. redirect) to be returned.
     * @param httpCode   the http response code to be returned
     * @param arg    an argument or message to be returned (depends on response code)
     * @see #redirect
     * @throws NonStandardResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the NonStandardResponseException.
     */
    public void nonStandardResponse(int httpCode, String arg) {
        throw new NonStandardResponseException(httpCode, arg);
    }

    /**
     * Cause a redirect response to be returned
     * @param path  where to redirect to. If the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @see #nonStandardResponse
     * @throws NonStandardResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the NonStandardResponseException.
     */
    public void redirect(String path) {
        if (path.startsWith(""/""))
            path = absPath(path);
        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);
    }

    /**
     * Cause a binary response to be returned
     * @param in input stream containing binary data to be sent
     * @throws BinaryResponseException which is a subclass of RuntimeException.
     * If you call this method inside a try/catch block make sure you re-throw
     * the BinaryResponseException.
     */
    public void sendBinaryResponse(InputStream in) {
        throw new BinaryResponseException(in);
    }

    /**
     * Convenience method to prepend the context path onto a servlet path
     * @param path    a servlet path
     * @return the context path plus the indicated path
     */
    public String absPath(String path) {
        return getContextPath() + (path.startsWith(""/"") ? path : ""/"" + path);
    }

    /**
     * Convenience method to create an html anchor link tag
     * @param anchor    the text in an anchor link
     * @param path   the anchor target, if the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @see #makeLink
     * @see #absPath
     */
    public String makeLink(String anchor, String path) {
        return makeLink(anchor, path, """");
    }

    /**
     * Convenience method to create an html anchor link tag
     * @param anchor    the text in an anchor link
     * @param path   the anchor target, if the path starts with a '/' character then
     * its assumed that this is an absolute link and the context path will be prepended to it
     * @param options    extra html options to add to the anchor tag
     * @see #makeLink
     * @see #absPath
     */
    public String makeLink(String anchor, String path, String options) {
        if (path.startsWith(""/""))
            path = absPath(path);
        return ""<a href='"" + path + ""' "" + options + "">"" + anchor + ""</a>"";
    }

    /**
     * Convenience method to check if this request is a POST
     */
    public boolean isPost() {
        return ""POST"".equals(request.getMethod());
    }

    /**
     * Convenience method to check if this request is a GET
     */
    public boolean isGet() {
        return ""GET"".equals(request.getMethod());
    }

    /**
     * Convenience method to retrieve a value from the flash
     * @param key  the key to use to lookup a flash value
     * @return the flash value associated with the indicated key or null
     * @see #setFlash
     */
    public String getFlash(String key) {
        return flash.get(key);
    }

    /**
     * Convenience method to add a value to the flash
     * @param key  the key to use to associate with the flash value
     * @param val  the value to store
     * @see #getFlash
     */
    public void setFlash(String key, String val) {
        flash.put(key, val);
    }

    // caching (internal use)
    /**
     * Internal method used to retrieve a cached block
     * @see #setCachedBlock
     */
    public static String getCachedBlock(String key) {
        return (cacheMap == null) ? null : cacheMap.get(key);
    }

    /**
     * Internal method used to store a cached block
     * @see #getCachedBlock
     */
    public static void setCachedBlock(String key, String val) {
        if (cacheMap == null) {
            cacheMap = new HashMap<String, String>();
        }
        cacheMap.put(key, val);
    }

    /**
     * For debugging
     * @return a string representation of this request context
     */
    public String toString() {
        return toString("", "");
    }

    public String toString(String sep) {
        StringBuilder sb = new StringBuilder();
        sb.append(""params: ["");
        String[] keys = getParamNames();
        for (String key : keys) {
            sb.append(key).append('=').append(getParam(key)).append(sep);
        }
        if (keys.length > 0) {
            sb.setLength(sb.length() - sep.length());
        }
        sb.append(""]"");
        sb.append(sep).append(""method: "").append(getMethod());
        sb.append(sep).append(""url: "").append(getScheme());
        sb.append(""|"").append(getServerName());
        sb.append(""|"").append(getServerPort());
        sb.append(""|"").append(getContextPath());
        sb.append(""|"").append(getServletPath());
        sb.append(""|"").append(getQueryString());
        if (hasMultipartContent) {
            sb.append(sep).append(""content len: "").append(request.getContentLength());
            //sb.append(sep).append(""content type: "").append(request.getContentType());
        }
        return sb.toString();
    }

    /**
     * Copy an input stream to an output stream.
     */
    private byte[] readStream(InputStream in) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        byte[] buf = new byte[4096];
        int read;
        while ((read = in.read(buf)) > -1) {
            out.write(buf, 0, read);
        }
        out.flush();
        return out.toByteArray();
    }
}
","// JVCRequestContext_9Test.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import javax.servlet.*;
import javax.servlet.http.*;
import org.apache.commons.fileupload.*;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JVCRequestContext}.
* It contains ten unit test cases for the {@link JVCRequestContext#getFlash(String)} method.
*/
class JVCRequestContext_9Test {","```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class JVCRequestContext_9Test {

    @Test
    void testGetFlashWithExistingKey() {
        JVCRequestContext requestContext = new JVCRequestContext();
        requestContext.setFlash(""key1"", ""value1"");

        assertEquals(""value1"", requestContext.getFlash(""key1""));
    }

    @Test
    void testGetFlashWithNonExistingKey() {
        JVCRequestContext requestContext = new JVCRequestContext();

        assertNull(requestContext.getFlash(""nonExistingKey""));
    }

    @Test
    void testGetFlashWithNullKey() {
        JVCRequestContext requestContext = new JVCRequestContext();

        assertNull(requestContext.getFlash(null));
    }

    @Test
    void testGetFlashWithEmptyKey() {
        JVCRequestContext requestContext = new JVCRequestContext();

        assertNull(requestContext.getFlash(""""));
    }

    @Test
    void testGetFlashWithMultipleKeys() {
        JVCRequestContext requestContext = new JVCRequestContext();
        requestContext.setFlash(""key1"", ""value1"");
        requestContext.setFlash(""key2"", ""value2"");

        assertEquals(""value1"", requestContext.getFlash(""key1""));
        assertEquals(""value2"", requestContext.getFlash(""key2""));
    }

    @Test
    void testGetFlashWithUpdatedValue() {
        JVCRequestContext requestContext = new JVCRequestContext();
        requestContext.setFlash(""key1"", ""value1"");
        requestContext.setFlash(""key1"", ""updatedValue"");

        assertEquals(""updatedValue"", requestContext.getFlash(""key1""));
    }

    @Test
    void testGetFlashWithEmptyValue() {
        JVCRequestContext requestContext = new JVCRequestContext();
        requestContext.setFlash(""key1"", """");

        assertEquals("""", requestContext.getFlash(""key1""));
    }

    @Test
    void testGetFlashWithWhitespaceValue() {
        JVCRequestContext requestContext = new JVCRequestContext();
        requestContext.setFlash(""key1"", ""   "");

        assertEquals(""   "", requestContext.getFlash(""key1""));
    }

    @Test
    void testGetFlashWithSpecialCharactersValue() {
        JVCRequestContext requestContext = new JVCRequestContext();
        requestContext.setFlash(""key1"", ""!@#$%^&*()"");

        assertEquals(""!@#$%^&*()"", requestContext.getFlash(""key1""));
    }

    @Test
    void testGetFlashWithNumericValue() {
        JVCRequestContext requestContext = new JVCRequestContext();
        requestContext.setFlash(""key1"", ""12345"");

        assertEquals(""12345"", requestContext.getFlash(""key1""));
    }
}
```
"
chatcmpl-A5UbNYTxjmlHZkFdIaYK4Uc7ViOYN,/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCDispatcher.java,6.070576190948486,stop,"// JVCDispatcher.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import java.lang.reflect.Method;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.Cookie;
import com.pmdesigns.jvc.tools.Base64Coder;
import com.pmdesigns.jvc.tools.JVCGenerator;

/**
 * JVC request dispatching servlet
 *
 * @author mike dooley
 */
public class JVCDispatcher extends HttpServlet {

    private Map<String, Class> generatorClasses;

    private String pkgPrefix;

    public static final String PKG_PREFIX_KEY = ""pkg_prefix"";

    private static Class requestContextClass;

    private static Class classNotFound;

    private Destroyable application;

    private static final boolean TRACE = false;

    private static ThreadLocal<JVCRequestContext> ctxHolder = new ThreadLocal<JVCRequestContext>() {

        protected synchronized JVCRequestContext initialValue() {
            return null;
        }
    };

    /**
     * Return the thread local request context
     * @return the JVCRequestContext associated with the current thread or null
     */
    public static JVCRequestContext getRC() {
        return ctxHolder.get();
    }

    /**
     * Get the package prefix (from config) so we know the fully qualified
     * name of page generators and controllers.  Also create and instance
     * of the Application object.
     */
    public void init() {
        pkgPrefix = getInitParameter(PKG_PREFIX_KEY);
        generatorClasses = new HashMap<String, Class>();
        if (classNotFound == null) {
            // just a rock, any Class will do
            classNotFound = getClass();
        }
        // create an instance of the Application class
        String className = appendPkg(pkgPrefix, ""Application"");
        try {
            Class appClass = Class.forName(className);
            Class[] args = { Class.forName(""javax.servlet.GenericServlet"") };
            Constructor<Destroyable> appConstructor = appClass.getConstructor(args);
            this.application = appConstructor.newInstance(this);
        } catch (InvocationTargetException e) {
            Throwable t = e.getTargetException();
            Log.error(""Failed to create Application instance: "", ((t != null) ? t : e));
        } catch (IllegalArgumentException e) {
            Log.error(""Illegal Application constructor args"", e);
        } catch (NoSuchMethodException e) {
            Log.error(""Constructor not found for: "" + className, e);
        } catch (Exception e) {
            Log.error(""Error while creating Application"", e);
        }
    }

    /**
     * Notify the Application that its shutdown time.
     */
    public void destroy() {
        if (application != null) {
            application.destroy();
            application = null;
        }
    }

    /**
     * Handle a GET request. Called by servlet container.
     * @param request
     * @param response
     * @throws IOException
     * @throws ServletException
     */
    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
        handleRequest(request, response);
    }

    /**
     * Handle a POST request. Called by servlet container.
     * @param request
     * @param response
     * @throws IOException
     * @throws ServletException
     */
    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
        handleRequest(request, response);
    }

    /**
     * Private implementation to handle a GET or POST request by invoking the appropriate
     * PageGenerator and Controller objects, or by serving static content.
     * @param request
     * @param response
     * @throws IOException
     * @throws ServletException
     */
    private void handleRequest(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
        long t0, t1;
        if (TRACE)
            t0 = System.currentTimeMillis();
        // i18n
        response.setCharacterEncoding(""UTF8"");
        request.setCharacterEncoding(""UTF8"");
        // request path for a dynamic page is expected to be of the form: / [<controller> / ] [<action>]
        String reqPath = request.getServletPath();
        // strip leading '/'
        if (reqPath.length() < 1) {
            // should never happen
            Log.error(""Empty path!"");
            response.sendError(HttpURLConnection.HTTP_NOT_FOUND, request.getRequestURI());
        } else if (reqPath.charAt(0) == '/') {
            reqPath = reqPath.substring(1, reqPath.length());
        }
        // try to extract the controller and action from the request path
        String controller;
        String action;
        int idx = reqPath.lastIndexOf('/');
        if (idx == -1) {
            controller = """";
            action = reqPath;
        } else {
            controller = reqPath.substring(0, idx);
            action = reqPath.substring(idx + 1);
        }
        // only look for a generator if there isn't a '.' in the action
        if (action.indexOf('.') == -1) {
            if (action.length() == 0) {
                // automatically supply this action
                action = ""index"";
            }
            String pkg = appendPkg(pkgPrefix, ""generators"");
            if (controller.length() > 0) {
                pkg += ""."" + controller.replace('/', '.');
            }
            String methodName = JVCGenerator.GENERATOR_METHOD_NAME;
            String className = pkg + ""."" + JVCGenerator.capitalize(action) + ""Generator"";
            //Log.info(""looking for generator '""+reqPath+""', class: ""+className+"", meth: ""+methodName);
            // lookup the generator class
            Class genClass = generatorClasses.get(className);
            if (genClass == null) {
                try {
                    genClass = Class.forName(className);
                } catch (ClassNotFoundException e) {
                    genClass = classNotFound;
                    //Log.info(""Generator class not found: ""+className);
                }
                generatorClasses.put(className, genClass);
            }
            if (genClass != classNotFound) {
                // this is a dynamic page request. invoke page generator
                JVCRequestContext rc = null;
                try {
                    if (requestContextClass == null) {
                        requestContextClass = Class.forName(""com.pmdesigns.jvc.JVCRequestContext"");
                    }
                    Class[] args = { requestContextClass };
                    Method meth = genClass.getMethod(methodName, args);
                    // look for 'flash cookie'
                    Map<String, String> flash = getFlash(request, response);
                    // render the page
                    rc = new JVCRequestContext(request, response, this, flash, controller, action);
                    // put the context in thread local
                    ctxHolder.set(rc);
                    String s = (String) meth.invoke(null, rc);
                    // write response
                    response.getWriter().print(s);
                    response.flushBuffer();
                } catch (InvocationTargetException e) {
                    // our non-standard-response exceptions get wrapped in invocation-target exceptions
                    Throwable t = e.getTargetException();
                    if (t instanceof NonStandardResponseException) {
                        // send appropriate response (usually a redirect)
                        NonStandardResponseException resp = (NonStandardResponseException) t;
                        //Log.info(""non standard response: ""+resp);
                        if (resp.httpCode == HttpURLConnection.HTTP_MOVED_TEMP) {
                            // add 'flash cookie' if necessary
                            if (rc != null && !rc.flash.isEmpty()) {
                                Cookie c = makeFlashCookie(rc.flash);
                                c.setPath(request.getContextPath());
                                response.addCookie(c);
                            }
                            response.sendRedirect(resp.arg);
                        } else {
                            response.sendError(resp.httpCode, resp.arg);
                        }
                    } else if (t instanceof BinaryResponseException) {
                        // send binary response
                        BinaryResponseException bre = (BinaryResponseException) t;
                        OutputStream out = new BufferedOutputStream(response.getOutputStream());
                        copy(bre.in, out);
                        response.flushBuffer();
                    } else {
                        // send a server error response
                        String err = ((t != null) ? t.toString() : e.toString());
                        Log.error(""Invocation error: "", ((t != null) ? t : e));
                        response.sendError(HttpURLConnection.HTTP_INTERNAL_ERROR, err);
                    }
                } catch (NoSuchMethodException e) {
                    // send a not-found response
                    Log.error(""Method not found: "" + className + ""."" + methodName);
                    response.sendError(HttpURLConnection.HTTP_NOT_FOUND, request.getRequestURI());
                } catch (Throwable e) {
                    Log.error(""Unhandled exception while processing "" + request.getRequestURI(), e);
                    // send server-error response
                    response.sendError(HttpURLConnection.HTTP_INTERNAL_ERROR, request.getRequestURI());
                } finally {
                    // remove context from the thread local
                    ctxHolder.set(null);
                    if (TRACE)
                        Log.info(""TIMING_1 '"" + reqPath + ""' = "" + (System.currentTimeMillis() - t0));
                }
                // done with dynamic page request
                return;
            }
        }
        // look for static file
        if (action.length() == 0) {
            // supply default static file
            reqPath += ""index.html"";
        }
        //Log.info(""looking for resource '""+reqPath+""'"");
        try {
            InputStream in = getServletContext().getResourceAsStream(reqPath);
            if (in != null) {
                OutputStream out = new BufferedOutputStream(response.getOutputStream());
                copy(in, out);
                response.flushBuffer();
                if (TRACE)
                    Log.info(""TIMING_2 '"" + reqPath + ""' = "" + (System.currentTimeMillis() - t0));
                return;
            }
        } catch (IOException e) {
            Log.error(""Error sending '"" + reqPath + ""'"", e);
        }
        response.sendError(HttpURLConnection.HTTP_NOT_FOUND, request.getRequestURI());
        if (TRACE)
            Log.info(""TIMING_3 '"" + reqPath + ""' = "" + (System.currentTimeMillis() - t0));
    }

    /**
     * Copy an input stream to an output stream.
     */
    private void copy(InputStream in, OutputStream out) throws IOException {
        byte[] buf = new byte[4096];
        int read;
        while ((read = in.read(buf)) > -1) {
            out.write(buf, 0, read);
        }
        out.flush();
    }

    /**
     * Append a package string to a prefix if the prefix isn't empty
     */
    private static String appendPkg(String prefix, String pkg) {
        return (prefix == null || prefix.length() == 0) ? pkg : prefix + ""."" + pkg;
    }

    private static final String FLASH_COOKIE = ""jvc_flash"";

    /**
     * Look for a 'flash cookie' in the request.  If found deserialize it, clear the cookie
     * and return it, otherwise just return an empty Map.
     * @see #makeFlashCookie
     * @see #serializeMap
     * @see #deserializeMap
     */
    private static Map<String, String> getFlash(HttpServletRequest request, HttpServletResponse response) {
        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie c : cookies) {
                if (FLASH_COOKIE.equals(c.getName())) {
                    // extract the flash from the cookie
                    Map<String, String> map = deserializeMap(c.getValue());
                    // clear the flash cookie
                    c = new Cookie(FLASH_COOKIE, """");
                    c.setPath(request.getContextPath());
                    c.setMaxAge(0);
                    response.addCookie(c);
                    return map;
                }
            }
        }
        return new HashMap<String, String>();
    }

    /**
     * Serialize the indicated map and return it in a 'flash cookie'
     * @see #getFlash
     * @see #serializeMap
     * @see #deserializeMap
     */
    private static Cookie makeFlashCookie(Map<String, String> map) {
        return new Cookie(FLASH_COOKIE, serializeMap(map));
    }

    /**
     * Return a string representation of the map.
     * This method encodes the map by writing its keys and values
     * separated by the 0 character (the end of the list is indicated
     * by an empty key) and then base64 encoding this string.
     * @see #getFlash
     * @see #makeFlashCookie
     * @see #deserializeMap
     */
    private static String serializeMap(Map<String, String> map) {
        StringBuilder sb = new StringBuilder();
        for (String key : map.keySet()) {
            String val = map.get(key);
            if (val != null) {
                sb.append(key).append((char) 0).append(val).append((char) 0);
            }
        }
        sb.append((char) 0);
        return Base64Coder.encodeString(sb.toString());
    }

    /**
     * Return the map representation of the indicated string (see serializeMap())
     * @see #getFlash
     * @see #makeFlashCookie
     * @see #serializeMap
     */
    private static Map<String, String> deserializeMap(String s) {
        s = Base64Coder.decodeString(s);
        Map<String, String> map = new HashMap<String, String>();
        int idx = 0;
        int idx2;
        while ((idx2 = s.indexOf((char) 0, idx)) != -1) {
            if (idx == idx2) {
                // end of list is marked by empty key
                break;
            }
            String key = s.substring(idx, idx2);
            idx = idx2 + 1;
            idx2 = s.indexOf((char) 0, idx);
            if (idx2 == -1) {
                Log.error(""Invalid serialized map."");
                // throw exception ?
                break;
            }
            String val = s.substring(idx, idx2);
            map.put(key, val);
            idx = idx2 + 1;
        }
        return map;
    }
}
","// JVCDispatcherTest.java
package com.pmdesigns.jvc;

import java.io.*;
import java.util.*;
import java.net.HttpURLConnection;
import java.lang.reflect.Method;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.Cookie;
import com.pmdesigns.jvc.tools.Base64Coder;
import com.pmdesigns.jvc.tools.JVCGenerator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JVCDispatcher}.
* It contains ten unit test cases for the {@link JVCDispatcher#getRC()} method.
*/
class JVCDispatcherTest {","```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class JVCDispatcherTest {

    @Test
    void testGetRCReturnsNull() {
        assertNull(JVCDispatcher.getRC());
    }

    @Test
    void testGetRCReturnsNonNullAfterSetting() {
        JVCRequestContext rc = new JVCRequestContext(null, null, null, null, null, null);
        JVCDispatcher.ctxHolder.set(rc);
        assertEquals(rc, JVCDispatcher.getRC());
    }

    @Test
    void testGetRCReturnsNullAfterRemoving() {
        JVCRequestContext rc = new JVCRequestContext(null, null, null, null, null, null);
        JVCDispatcher.ctxHolder.set(rc);
        JVCDispatcher.ctxHolder.remove();
        assertNull(JVCDispatcher.getRC());
    }

    @Test
    void testGetRCReturnsNullInitially() {
        assertNull(JVCDispatcher.getRC());
    }

    @Test
    void testGetRCReturnsNonNullAfterSettingAgain() {
        JVCRequestContext rc = new JVCRequestContext(null, null, null, null, null, null);
        JVCDispatcher.ctxHolder.set(rc);
        assertEquals(rc, JVCDispatcher.getRC());
    }

    @Test
    void testGetRCReturnsNullAfterRemovingAgain() {
        JVCRequestContext rc = new JVCRequestContext(null, null, null, null, null, null);
        JVCDispatcher.ctxHolder.set(rc);
        JVCDispatcher.ctxHolder.remove();
        assertNull(JVCDispatcher.getRC());
    }

    @Test
    void testGetRCReturnsNullAtStart() {
        assertNull(JVCDispatcher.getRC());
    }

    @Test
    void testGetRCReturnsNonNullAfterSettingOnceMore() {
        JVCRequestContext rc = new JVCRequestContext(null, null, null, null, null, null);
        JVCDispatcher.ctxHolder.set(rc);
        assertEquals(rc, JVCDispatcher.getRC());
    }

    @Test
    void testGetRCReturnsNullAfterRemovingOnceMore() {
        JVCRequestContext rc = new JVCRequestContext(null, null, null, null, null, null);
        JVCDispatcher.ctxHolder.set(rc);
        JVCDispatcher.ctxHolder.remove();
        assertNull(JVCDispatcher.getRC());
    }
}
```
```"
