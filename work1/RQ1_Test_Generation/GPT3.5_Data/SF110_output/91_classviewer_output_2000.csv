ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
chatcmpl-A5VtX9RuF4bwNCXE6STtdL88ph9Pj,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_0Test.java,6.937825441360474,stop,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_0Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printFields()} method.
*/
class ClassInfo_0Test {","```java
    @Test
    void testPrintFields_NoFields() {
        ClassInfo classInfo = new ClassInfo();
        String[] fields = classInfo.printFields();
        assertNull(fields);
    }

    @Test
    void testPrintFields_WithFields() {
        ClassInfo classInfo = new ClassInfo(""javax.swing.WindowConstants"");
        String[] fields = classInfo.printFields();
        assertNotNull(fields);
        assertTrue(fields.length > 0);
    }

    @Test
    void testPrintFields_NullClass() {
        ClassInfo classInfo = new ClassInfo();
        String[] fields = classInfo.printFields();
        assertNull(fields);
    }

    @Test
    void testPrintFields_IllegalAccessException() {
        ClassInfo classInfo = new ClassInfo(""javax.swing.WindowConstants"");
        String[] fields = classInfo.printFields();
        assertNotNull(fields);
        for (String field : fields) {
            assertTrue(field.contains(""ILLEGAL ACCESS EXCEPTION""));
        }
    }

    @Test
    void testPrintFields_IllegalArgumentException() {
        ClassInfo classInfo = new ClassInfo(""javax.swing.WindowConstants"");
        String[] fields = classInfo.printFields();
        assertNotNull(fields);
        for (String field : fields) {
            assertTrue(field.contains(""ILLEGAL ARGUMENT EXCEPTION""));
        }
    }

    @Test
    void testPrintFields_DebugMode() {
        ClassInfo.debug = true;
        ClassInfo classInfo = new ClassInfo(""javax.swing.WindowConstants"");
        String[] fields = classInfo.printFields();
        assertNotNull(fields);
    }

    @Test
    void testPrintFields_NoFields_DebugMode() {
        ClassInfo.debug = true;
        ClassInfo classInfo = new ClassInfo();
        String[] fields = classInfo.printFields();
        assertNull(fields);
    }

    @Test
    void testPrintFields_NullClass_DebugMode() {
        ClassInfo.debug = true;
        ClassInfo classInfo = new ClassInfo();
        String[] fields = classInfo.printFields();
        assertNull(fields);
    }

    @Test
    void testPrintFields_WithFields_DebugMode() {
        ClassInfo.debug = true;
        ClassInfo classInfo = new ClassInfo(""javax.swing.WindowConstants"");
        String[] fields = classInfo.printFields();
        assertNotNull(fields);
        assertTrue(fields.length > 0);
    }
```
```"
chatcmpl-A5VuaszKBvLiIkQpZZUAx0gTTyMzd,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_1Test.java,5.885732650756836,stop,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_1Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printMethods()} method.
*/
class ClassInfo_1Test {","```java
    private ClassInfo classInfo;

    @BeforeEach
    void setUp() {
        classInfo = new ClassInfo(""javax.swing.JFrame"");
    }

    @Test
    void testPrintMethodsNotNull() {
        String[] methods = classInfo.printMethods();
        assertNotNull(methods);
    }

    @Test
    void testPrintMethodsNotEmpty() {
        String[] methods = classInfo.printMethods();
        assertTrue(methods.length > 0);
    }

    @Test
    void testPrintMethodsContainsMethod() {
        String[] methods = classInfo.printMethods();
        assertTrue(Arrays.asList(methods).contains(""public void javax.swing.JFrame.setVisible(boolean)""));
    }

    @Test
    void testPrintMethodsNoInheritedMethodsNotNull() {
        String[] methods = classInfo.printMethods(ClassInfo.NO_INHERITED_METHODS);
        assertNotNull(methods);
    }

    @Test
    void testPrintMethodsNoInheritedMethodsNotEmpty() {
        String[] methods = classInfo.printMethods(ClassInfo.NO_INHERITED_METHODS);
        assertTrue(methods.length > 0);
    }

    @Test
    void testPrintMethodsNoInheritedMethodsContainsMethod() {
        String[] methods = classInfo.printMethods(ClassInfo.NO_INHERITED_METHODS);
        assertFalse(Arrays.asList(methods).contains(""public void java.awt.Window.setVisible(boolean)""));
    }

    @Test
    void testPrintMethodsNoObjectMethodsNotNull() {
        String[] methods = classInfo.printMethods(ClassInfo.NO_OBJECT_METHODS);
        assertNotNull(methods);
    }

    @Test
    void testPrintMethodsNoObjectMethodsNotEmpty() {
        String[] methods = classInfo.printMethods(ClassInfo.NO_OBJECT_METHODS);
        assertTrue(methods.length > 0);
    }

    @Test
    void testPrintMethodsNoObjectMethodsContainsMethod() {
        String[] methods = classInfo.printMethods(ClassInfo.NO_OBJECT_METHODS);
        assertFalse(Arrays.asList(methods).contains(""public void java.lang.Object.wait() throws java.lang.InterruptedException""));
    }
```
"
chatcmpl-A5VvdUD3DOdt0xo8GCZLDujUq91th,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_2Test.java,6.915787696838379,stop,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_2Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printMethods(int)} method.
*/
class ClassInfo_2Test {","```java
    @Test
    void testPrintMethodsNoObjectMethods() {
        ClassInfo classInfo = new ClassInfo(""java.lang.String"");
        String[] methods = classInfo.printMethods(ClassInfo.NO_OBJECT_METHODS);
        assertNotNull(methods);
        assertEquals(0, methods.length);
    }

    @Test
    void testPrintMethodsNoInheritedMethods() {
        ClassInfo classInfo = new ClassInfo(""java.lang.String"");
        String[] methods = classInfo.printMethods(ClassInfo.NO_INHERITED_METHODS);
        assertNotNull(methods);
        assertTrue(methods.length > 0);
        for (String method : methods) {
            assertFalse(method.contains(""java.lang.String.""));
        }
    }

    @Test
    void testPrintMethodsInvalidParam() {
        ClassInfo classInfo = new ClassInfo(""java.lang.String"");
        String[] methods = classInfo.printMethods(3);
        assertNull(methods);
    }

    @Test
    void testPrintMethodsNoMethods() {
        ClassInfo classInfo = new ClassInfo(""java.awt.Point"");
        String[] methods = classInfo.printMethods(ClassInfo.NO_OBJECT_METHODS);
        assertNull(methods);
    }

    @Test
    void testPrintMethodsNoInheritedMethodsForInterface() {
        ClassInfo classInfo = new ClassInfo(""java.util.List"");
        String[] methods = classInfo.printMethods(ClassInfo.NO_INHERITED_METHODS);
        assertNull(methods);
    }

    @Test
    void testPrintMethodsNoObjectMethodsForInterface() {
        ClassInfo classInfo = new ClassInfo(""java.util.List"");
        String[] methods = classInfo.printMethods(ClassInfo.NO_OBJECT_METHODS);
        assertNull(methods);
    }

    @Test
    void testPrintMethodsNoMethodsForInterface() {
        ClassInfo classInfo = new ClassInfo(""java.util.List"");
        String[] methods = classInfo.printMethods();
        assertNull(methods);
    }

    @Test
    void testPrintMethodsNoInheritedMethodsForAbstractClass() {
        ClassInfo classInfo = new ClassInfo(""javax.swing.border.AbstractBorder"");
        String[] methods = classInfo.printMethods(ClassInfo.NO_INHERITED_METHODS);
        assertNull(methods);
    }

    @Test
    void testPrintMethodsNoObjectMethodsForAbstractClass() {
        ClassInfo classInfo = new ClassInfo(""javax.swing.border.AbstractBorder"");
        String[] methods = classInfo.printMethods(ClassInfo.NO_OBJECT_METHODS);
        assertNull(methods);
    }
```
"
chatcmpl-A5VwgYo1ysELSA2Lr0fEz7EAadSqq,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_3Test.java,6.725756883621216,stop,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_3Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printConstructors()} method.
*/
class ClassInfo_3Test {","```java
    private ClassInfo classInfo;

    @BeforeEach
    void setUp() {
        classInfo = new ClassInfo(""javax.swing.JFrame"");
    }

    @Test
    void testPrintConstructorsNotNull() {
        String[] constructors = classInfo.printConstructors();
        assertNotNull(constructors);
    }

    @Test
    void testPrintConstructorsNotEmpty() {
        String[] constructors = classInfo.printConstructors();
        assertTrue(constructors.length > 0);
    }

    @Test
    void testPrintConstructorsContainsExpectedConstructor() {
        String[] constructors = classInfo.printConstructors();
        assertTrue(Arrays.asList(constructors).contains(""public javax.swing.JFrame()""));
    }

    @Test
    void testPrintConstructorsDoesNotContainInvalidConstructor() {
        String[] constructors = classInfo.printConstructors();
        assertFalse(Arrays.asList(constructors).contains(""private javax.swing.JFrame()""));
    }

    @Test
    void testPrintConstructorsOutputFormat() {
        String[] constructors = classInfo.printConstructors();
        for (String constructor : constructors) {
            assertTrue(constructor.startsWith(""public"") || constructor.startsWith(""protected"") || constructor.startsWith(""package"") || constructor.startsWith(""private""));
        }
    }

    @Test
    void testPrintConstructorsNoIllegalAccessException() {
        String[] constructors = classInfo.printConstructors();
        for (String constructor : constructors) {
            assertFalse(constructor.contains(""ILLEGAL ACCESS EXCEPTION""));
        }
    }

    @Test
    void testPrintConstructorsNoIllegalArgumentException() {
        String[] constructors = classInfo.printConstructors();
        for (String constructor : constructors) {
            assertFalse(constructor.contains(""ILLEGAL ARGUMENT EXCEPTION""));
        }
    }

    @Test
    void testPrintConstructorsNoDebugOutput() {
        classInfo.debug = false;
        String[] constructors = classInfo.printConstructors();
        for (String constructor : constructors) {
            assertFalse(constructor.startsWith(""****************************************""));
        }
    }

    @Test
    void testPrintConstructorsWithDebugOutput() {
        classInfo.debug = true;
        String[] constructors = classInfo.printConstructors();
        for (String constructor : constructors) {
            assertTrue(constructor.startsWith(""****************************************""));
        }
    }
```
```"
chatcmpl-A5VxjyAdCF9gadyIU2G2eAgtL5NlB,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_4Test.java,7.567729234695435,stop,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_4Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printInterfaces()} method.
*/
class ClassInfo_4Test {","```java
    private ClassInfo classInfo;

    @BeforeEach
    void setUp() {
        classInfo = new ClassInfo();
    }

    @Test
    void testPrintInterfaces_NoInterfaces() {
        String[] interfaces = classInfo.printInterfaces();
        assertNull(interfaces);
    }

    @Test
    void testPrintInterfaces_OneInterface() {
        classInfo = new ClassInfo(""java.util.List"");
        String[] interfaces = classInfo.printInterfaces();
        assertNotNull(interfaces);
        assertEquals(1, interfaces.length);
        assertEquals(""java.util.Collection"", interfaces[0]);
    }

    @Test
    void testPrintInterfaces_MultipleInterfaces() {
        classInfo = new ClassInfo(""java.util.ArrayList"");
        String[] interfaces = classInfo.printInterfaces();
        assertNotNull(interfaces);
        assertEquals(2, interfaces.length);
        assertEquals(""java.util.List"", interfaces[0]);
        assertEquals(""java.util.RandomAccess"", interfaces[1]);
    }

    @Test
    void testPrintInterfaces_InterfaceInheritedFromSuperclass() {
        classInfo = new ClassInfo(""java.util.LinkedList"");
        String[] interfaces = classInfo.printInterfaces();
        assertNotNull(interfaces);
        assertEquals(3, interfaces.length);
        assertEquals(""java.util.List"", interfaces[0]);
        assertEquals(""java.util.Deque"", interfaces[1]);
        assertEquals(""java.util.Queue"", interfaces[2]);
    }

    @Test
    void testPrintInterfaces_AbstractClass() {
        classInfo = new ClassInfo(""java.awt.Window"");
        String[] interfaces = classInfo.printInterfaces();
        assertNotNull(interfaces);
        assertEquals(1, interfaces.length);
        assertEquals(""java.awt.image.ImageObserver"", interfaces[0]);
    }

    @Test
    void testPrintInterfaces_CustomClass() {
        classInfo = new ClassInfo(""com.jstevh.viewer.ClassInfo"");
        String[] interfaces = classInfo.printInterfaces();
        assertNotNull(interfaces);
        assertEquals(1, interfaces.length);
        assertEquals(""java.lang.Cloneable"", interfaces[0]);
    }

    @Test
    void testPrintInterfaces_NullClass() {
        assertThrows(ClassNotFoundException.class, () -> {
            new ClassInfo(""NonExistentClass"").printInterfaces();
        });
    }

    @Test
    void testPrintInterfaces_NullDirManager() {
        assertThrows(ClassNotFoundException.class, () -> {
            new ClassInfo(""java.util.List"", null).printInterfaces();
        });
    }

    @Test
    void testPrintInterfaces_EmptyClassName() {
        assertThrows(ClassNotFoundException.class, () -> {
            new ClassInfo("""").printInterfaces();
        });
    }
}
```"
chatcmpl-A5VymibS8oI1VM4txurvxEOMve7Qy,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_5Test.java,6.0419135093688965,stop,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_5Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getData(Member[])} method.
*/
class ClassInfo_5Test {","```java
    @Test
    void testGetDataWithEmptyArray() {
        Member[] members = new Member[0];
        String[] result = ClassInfo.getData(members);
        assertNull(result);
    }

    @Test
    void testGetDataWithSingleMember() {
        Member[] members = new Member[] {TestClass.class.getDeclaredFields()[0]};
        String[] result = ClassInfo.getData(members);
        assertNotNull(result);
        assertEquals(1, result.length);
    }

    @Test
    void testGetDataWithMultipleMembers() {
        Member[] members = TestClass.class.getDeclaredFields();
        String[] result = ClassInfo.getData(members);
        assertNotNull(result);
        assertEquals(members.length, result.length);
    }

    @Test
    void testGetDataWithNull() {
        String[] result = ClassInfo.getData(null);
        assertNull(result);
    }

    @Test
    void testGetDataWithMethods() {
        Member[] members = TestClass.class.getDeclaredMethods();
        String[] result = ClassInfo.getData(members);
        assertNotNull(result);
        assertEquals(members.length, result.length);
    }

    @Test
    void testGetDataWithConstructors() {
        Member[] members = TestClass.class.getDeclaredConstructors();
        String[] result = ClassInfo.getData(members);
        assertNotNull(result);
        assertEquals(members.length, result.length);
    }

    @Test
    void testGetDataWithMixedMembers() {
        Member[] members = new Member[] {TestClass.class.getDeclaredFields()[0], TestClass.class.getDeclaredMethods()[0]};
        String[] result = ClassInfo.getData(members);
        assertNotNull(result);
        assertEquals(2, result.length);
    }

    @Test
    void testGetDataWithInvalidMembers() {
        Member[] members = new Member[] {null, null};
        String[] result = ClassInfo.getData(members);
        assertNotNull(result);
        assertEquals(2, result.length);
    }

    static class TestClass {
        private int field1;
        public void method1() {}
    }
}
```"
chatcmpl-A5Vzp22iESPHwFfbHWkJpZI5EygTC,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_6Test.java,8.461116313934326,stop,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_6Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getData(Class[])} method.
*/
class ClassInfo_6Test {","```java
class ClassInfo_6Test {

    @Test
    void testGetData_withEmptyArray() {
        Class[] classes = new Class[0];
        String[] result = ClassInfo.getData(classes);
        assertNull(result);
    }

    @Test
    void testGetData_withSingleClass() {
        Class[] classes = {String.class};
        String[] result = ClassInfo.getData(classes);
        assertNotNull(result);
        assertEquals(1, result.length);
        assertEquals(""java.lang.String"", result[0]);
    }

    @Test
    void testGetData_withMultipleClasses() {
        Class[] classes = {String.class, Integer.class, Double.class};
        String[] result = ClassInfo.getData(classes);
        assertNotNull(result);
        assertEquals(3, result.length);
        assertEquals(""java.lang.String"", result[0]);
        assertEquals(""java.lang.Integer"", result[1]);
        assertEquals(""java.lang.Double"", result[2]);
    }

    @Test
    void testGetData_withNullClass() {
        Class[] classes = {String.class, null, Integer.class};
        String[] result = ClassInfo.getData(classes);
        assertNotNull(result);
        assertEquals(3, result.length);
        assertEquals(""java.lang.String"", result[0]);
        assertNull(result[1]);
        assertEquals(""java.lang.Integer"", result[2]);
    }

    @Test
    void testGetData_withPrimitiveClasses() {
        Class[] classes = {int.class, double.class, boolean.class};
        String[] result = ClassInfo.getData(classes);
        assertNotNull(result);
        assertEquals(3, result.length);
        assertEquals(""int"", result[0]);
        assertEquals(""double"", result[1]);
        assertEquals(""boolean"", result[2]);
    }

    @Test
    void testGetData_withArrayClass() {
        Class[] classes = {String[].class, int[].class};
        String[] result = ClassInfo.getData(classes);
        assertNotNull(result);
        assertEquals(2, result.length);
        assertEquals(""[Ljava.lang.String;"", result[0]);
        assertEquals(""[I"", result[1]);
    }

    @Test
    void testGetData_withInnerClass() {
        Class[] classes = {Map.Entry.class, ListIterator.class};
        String[] result = ClassInfo.getData(classes);
        assertNotNull(result);
        assertEquals(2, result.length);
        assertEquals(""java.util.Map.Entry"", result[0]);
        assertEquals(""java.util.ListIterator"", result[1]);
    }

    @Test
    void testGetData_withAnonymousClass() {
        Class[] classes = {new ActionListener() {}.getClass()};
        String[] result = ClassInfo.getData(classes);
        assertNotNull(result);
        assertEquals(1, result.length);
        assertEquals(""com.jstevh.viewer.ClassInfo_6Test$1"", result[0]);
    }

    @Test
    void testGetData_withLocalClass() {
        class LocalClass {}
        Class[] classes = {LocalClass.class};
        String[] result = ClassInfo.getData(classes);
        assertNotNull(result);
        assertEquals(1, result.length);
        assertEquals(""com.jstevh.viewer.ClassInfo_6Test$1LocalClass"", result[0]);
    }
}
```
```"
chatcmpl-A5W0saDgaNjLifbuoNTvjqv12PLpi,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_7Test.java,7.876080751419067,stop,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_7Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#srchMethods(String)} method.
*/
class ClassInfo_7Test {","```java
    @Test
    void testSrchMethods_NullInput() {
        ClassInfo classInfo = new ClassInfo();
        assertNull(classInfo.srchMethods(null));
    }

    @Test
    void testSrchMethods_EmptyInput() {
        ClassInfo classInfo = new ClassInfo();
        assertNull(classInfo.srchMethods(""""));
    }

    @Test
    void testSrchMethods_NoMatch() {
        ClassInfo classInfo = new ClassInfo();
        classInfo.printMethods();
        assertNull(classInfo.srchMethods(""nonexistent""));
    }

    @Test
    void testSrchMethods_SingleMatch() {
        ClassInfo classInfo = new ClassInfo();
        classInfo.printMethods();
        assertNotNull(classInfo.srchMethods(""printMethods""));
        assertEquals(1, classInfo.srchMethods(""printMethods"").length);
    }

    @Test
    void testSrchMethods_MultipleMatches() {
        ClassInfo classInfo = new ClassInfo();
        classInfo.printMethods();
        assertNotNull(classInfo.srchMethods(""print""));
        assertTrue(classInfo.srchMethods(""print"").length > 1);
    }

    @Test
    void testSrchMethods_CaseSensitive() {
        ClassInfo classInfo = new ClassInfo();
        classInfo.printMethods();
        assertNull(classInfo.srchMethods(""PrintMethods""));
    }

    @Test
    void testSrchMethods_WithNumbers() {
        ClassInfo classInfo = new ClassInfo();
        classInfo.printMethods();
        assertNotNull(classInfo.srchMethods(""2""));
    }

    @Test
    void testSrchMethods_WithSpecialCharacters() {
        ClassInfo classInfo = new ClassInfo();
        classInfo.printMethods();
        assertNotNull(classInfo.srchMethods(""()""));
    }

    @Test
    void testSrchMethods_WithSpaces() {
        ClassInfo classInfo = new ClassInfo();
        classInfo.printMethods();
        assertNotNull(classInfo.srchMethods(""print Methods""));
    }

    @Test
    void testSrchMethods_WithSymbols() {
        ClassInfo classInfo = new ClassInfo();
        classInfo.printMethods();
        assertNotNull(classInfo.srchMethods(""*""));
    }
```
```"
chatcmpl-A5W1vf98hLX9om9j1rKXvjKCcd7Rq,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_9Test.java,9.322413206100464,stop,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_9Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getFoundMethod(int)} method.
*/
class ClassInfo_9Test {","```java
    @Test
    void testGetFoundMethod_PositiveIndex() {
        ClassInfo classInfo = new ClassInfo();
        classInfo.debug = true;
        classInfo.srchMethods(""test"");
        MethodData methodData = classInfo.getFoundMethod(0);
        assertNotNull(methodData);
        assertEquals(""com.jstevh.viewer.ClassInfo"", methodData.getMethClass());
        assertEquals(""testGetFoundMethod_PositiveIndex"", methodData.getMethName());
    }

    @Test
    void testGetFoundMethod_NullIndex() {
        ClassInfo classInfo = new ClassInfo();
        classInfo.debug = true;
        classInfo.srchMethods(""test"");
        MethodData methodData = classInfo.getFoundMethod(1);
        assertNull(methodData);
    }

    @Test
    void testGetFoundMethod_NullFoundMethods() {
        ClassInfo classInfo = new ClassInfo();
        MethodData methodData = classInfo.getFoundMethod(0);
        assertNull(methodData);
    }

    @Test
    void testGetFoundMethod_OutOfRangeIndex() {
        ClassInfo classInfo = new ClassInfo();
        classInfo.debug = true;
        classInfo.srchMethods(""test"");
        MethodData methodData = classInfo.getFoundMethod(2);
        assertNull(methodData);
    }

    @Test
    void testGetFoundMethod_EmptyFoundMethods() {
        ClassInfo classInfo = new ClassInfo();
        classInfo.fndMethods = new String[0];
        MethodData methodData = classInfo.getFoundMethod(0);
        assertNull(methodData);
    }

    @Test
    void testGetFoundMethod_NegativeIndex() {
        ClassInfo classInfo = new ClassInfo();
        classInfo.debug = true;
        classInfo.srchMethods(""test"");
        MethodData methodData = classInfo.getFoundMethod(-1);
        assertNull(methodData);
    }

    @Test
    void testGetFoundMethod_DebugFalse() {
        ClassInfo classInfo = new ClassInfo();
        classInfo.debug = false;
        classInfo.srchMethods(""test"");
        MethodData methodData = classInfo.getFoundMethod(0);
        assertNull(methodData);
    }

    @Test
    void testGetFoundMethod_NullTempStr() {
        ClassInfo classInfo = new ClassInfo();
        classInfo.debug = true;
        classInfo.srchMethods(null);
        MethodData methodData = classInfo.getFoundMethod(0);
        assertNull(methodData);
    }

    @Test
    void testGetFoundMethod_NullFndMethods() {
        ClassInfo classInfo = new ClassInfo();
        classInfo.debug = true;
        MethodData methodData = classInfo.getFoundMethod(0);
        assertNull(methodData);
    }

    @Test
    void testGetFoundMethod_PositiveIndexWithMultipleMethods() {
        ClassInfo classInfo = new ClassInfo();
        classInfo.debug = true;
        classInfo.srchMethods(""test"");
        classInfo.srchMethods(""method"");
        MethodData methodData = classInfo.getFoundMethod(1);
        assertNotNull(methodData);
        assertEquals(""com.jstevh.viewer.ClassInfo"", methodData.getMethClass());
        assertEquals(""testGetFoundMethod_PositiveIndexWithMultipleMethods"", methodData.getMethName());
    }
```
```"
