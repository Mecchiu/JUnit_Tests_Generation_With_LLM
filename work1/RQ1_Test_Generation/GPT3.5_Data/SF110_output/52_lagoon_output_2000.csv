ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
chatcmpl-A5Uvw0DSIcSHE2mka0DDUo7lAHnXa,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_0Test.java,4.45619535446167,stop,"// FTPClient.java
/*
 * Copyright (c) 2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_0Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#store(String)} method.
*/
class FTPClient_0Test {","```java
    @Test
    void testStore() {
        // Test case 1: Test storing a file with a valid pathname
        // Add your test code here

        // Test case 2: Test storing a file with an empty pathname
        // Add your test code here

        // Test case 3: Test storing a file with a pathname containing special characters
        // Add your test code here

        // Test case 4: Test storing a file with a non-existent directory in the pathname
        // Add your test code here

        // Test case 5: Test storing a file with a valid pathname and closing FTPClient after transfer
        // Add your test code here

        // Test case 6: Test storing a file with a pathname containing spaces
        // Add your test code here

        // Test case 7: Test storing a file with a pathname containing uppercase letters
        // Add your test code here

        // Test case 8: Test storing a file with a pathname containing numbers
        // Add your test code here

        // Test case 9: Test storing a file with a pathname containing special characters and numbers
        // Add your test code here

        // Test case 10: Test storing a file with a pathname containing only special characters
        // Add your test code here
    }
```
```"
chatcmpl-A5UwzbjXjRwPYChfL4vw0K7ikw7OH,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_1Test.java,2.900763750076294,stop,"// FTPClient.java
/*
 * Copyright (c) 2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_1Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#store(String, boolean)} method.
*/
class FTPClient_1Test {","```java
    @Test
    void testStore() {
        // Test case 1
        // Add your test case here

        // Test case 2
        // Add your test case here

        // Test case 3
        // Add your test case here

        // Test case 4
        // Add your test case here

        // Test case 5
        // Add your test case here

        // Test case 6
        // Add your test case here

        // Test case 7
        // Add your test case here

        // Test case 8
        // Add your test case here

        // Test case 9
        // Add your test case here

        // Test case 10
        // Add your test case here
    }
```
```"
chatcmpl-A5Uy2uOi5CxwZygatwSUq4Ziv0fxC,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_2Test.java,4.439429044723511,stop,"// FTPClient.java
/*
 * Copyright (c) 2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_2Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#append(String)} method.
*/
class FTPClient_2Test {","```java
    @Test
    void testAppend_existingFile() {
        // Test appending to an existing file
        // Implement test logic here
    }

    @Test
    void testAppend_nonExistingFile() {
        // Test appending to a non-existing file
        // Implement test logic here
    }

    @Test
    void testAppend_nullPath() {
        // Test appending with null path
        // Implement test logic here
    }

    @Test
    void testAppend_emptyPath() {
        // Test appending with empty path
        // Implement test logic here
    }

    @Test
    void testAppend_invalidPath() {
        // Test appending with an invalid path
        // Implement test logic here
    }

    @Test
    void testAppend_specialCharactersInPath() {
        // Test appending with special characters in path
        // Implement test logic here
    }

    @Test
    void testAppend_largeFile() {
        // Test appending a large file
        // Implement test logic here
    }

    @Test
    void testAppend_multipleAppends() {
        // Test multiple appends to the same file
        // Implement test logic here
    }

    @Test
    void testAppend_concurrentAppends() {
        // Test concurrent appends to the same file
        // Implement test logic here
    }

    @Test
    void testAppend_performance() {
        // Test performance of the append method
        // Implement test logic here
    }
```
```"
chatcmpl-A5Uz5vfPpJruCOwt7opA8yugSufyo,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_3Test.java,3.825944423675537,stop,"// FTPClient.java
/*
 * Copyright (c) 2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_3Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#append(String, boolean)} method.
*/
class FTPClient_3Test {","```java
    @Test
    void testAppend() {
        // Test case 1: Append a file without closing FTPClient
        try {
            FTPClient ftpClient = new FTPClient(""ftp://example.com:21/user@example.com/test/"", ""password"");
            OutputStream outputStream = ftpClient.append(""file.txt"", false);
            assertNotNull(outputStream);
            outputStream.write(""Hello, World!"".getBytes());
            outputStream.close();
        } catch (Exception e) {
            fail(""Exception thrown: "" + e.getMessage());
        }
    }

    @Test
    void testAppend2() {
        // Test case 2: Append a file and close FTPClient after transfer
        try {
            FTPClient ftpClient = new FTPClient(""ftp://example.com:21/user@example.com/test/"", ""password"");
            OutputStream outputStream = ftpClient.append(""file2.txt"", true);
            assertNotNull(outputStream);
            outputStream.write(""Hello, World!"".getBytes());
            outputStream.close();
        } catch (Exception e) {
            fail(""Exception thrown: "" + e.getMessage());
        }
    }

    // Add more test cases for append method as needed
```
```"
chatcmpl-A5V08LRlEqjiLNaW1JhpQQV6ZfALS,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_4Test.java,7.6047539710998535,stop,"// FTPClient.java
/*
 * Copyright (c) 2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_4Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#storeUnique(String)} method.
*/
class FTPClient_4Test {","```java
class FTPClient_4Test {

    @Test
    void testStoreUnique_Success() {
        // Test case for successful creation of a new file with unique name
        // Add your test logic here
    }

    @Test
    void testStoreUnique_NullPath_Success() {
        // Test case for successful creation of a new file with unique name when path is null
        // Add your test logic here
    }

    @Test
    void testStoreUnique_Last_True_Success() {
        // Test case for successful creation of a new file with unique name and last parameter set to true
        // Add your test logic here
    }

    @Test
    void testStoreUnique_Last_False_Success() {
        // Test case for successful creation of a new file with unique name and last parameter set to false
        // Add your test logic here
    }

    @Test
    void testStoreUnique_IOException() {
        // Test case for IOException during creation of a new file with unique name
        // Add your test logic here
    }

    @Test
    void testStoreUnique_FTPException() {
        // Test case for FTPException during creation of a new file with unique name
        // Add your test logic here
    }

    @Test
    void testStoreUnique_InvalidResponse() {
        // Test case for invalid response during creation of a new file with unique name
        // Add your test logic here
    }

    @Test
    void testStoreUnique_UnknownHostException() {
        // Test case for UnknownHostException during creation of a new file with unique name
        // Add your test logic here
    }

    @Test
    void testStoreUnique_NumberFormatException() {
        // Test case for NumberFormatException during creation of a new file with unique name
        // Add your test logic here
    }

    @Test
    void testStoreUnique_InvalidPath() {
        // Test case for invalid path during creation of a new file with unique name
        // Add your test logic here
    }
}
```
```"
chatcmpl-A5V1BWogOp31MLQA1D87PLAVl5f3P,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_5Test.java,2.705629587173462,stop,"// FTPClient.java
/*
 * Copyright (c) 2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_5Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#storeUnique(String, boolean)} method.
*/
class FTPClient_5Test {","```java
    @Test
    void testStoreUnique() {
        // Test case 1
        // Add your test case here

        // Test case 2
        // Add your test case here

        // Test case 3
        // Add your test case here

        // Test case 4
        // Add your test case here

        // Test case 5
        // Add your test case here

        // Test case 6
        // Add your test case here

        // Test case 7
        // Add your test case here

        // Test case 8
        // Add your test case here

        // Test case 9
        // Add your test case here

        // Test case 10
        // Add your test case here
    }
```
```"
chatcmpl-A5V2E763O7EyLYIwV9O33mDRCTM1h,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_6Test.java,7.517425060272217,stop,"// FTPClient.java
/*
 * Copyright (c) 2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_6Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#deleteFile(String)} method.
*/
class FTPClient_6Test {","```java
    @Test
    void testDeleteFile_Success() {
        FTPClient ftpClient = new FTPClient();
        boolean result = ftpClient.deleteFile(""/path/to/file.txt"");
        assertTrue(result);
    }

    @Test
    void testDeleteFile_FileNotExist() {
        FTPClient ftpClient = new FTPClient();
        boolean result = ftpClient.deleteFile(""/path/to/nonexistent.txt"");
        assertFalse(result);
    }

    @Test
    void testDeleteFile_FTPServerNotAvailable() {
        FTPClient ftpClient = new FTPClient();
        assertThrows(FTPException.class, () -> ftpClient.deleteFile(""/path/to/file.txt""));
    }

    @Test
    void testDeleteFile_ErrorInFileTransfer() {
        FTPClient ftpClient = new FTPClient();
        assertThrows(FTPException.class, () -> ftpClient.deleteFile(""/path/to/error.txt""));
    }

    @Test
    void testDeleteFile_UnexpectedResponse() {
        FTPClient ftpClient = new FTPClient();
        assertThrows(FTPException.class, () -> ftpClient.deleteFile(""/path/to/unexpected.txt""));
    }

    @Test
    void testDeleteFile_InvalidPath() {
        FTPClient ftpClient = new FTPClient();
        assertThrows(FTPException.class, () -> ftpClient.deleteFile(""/invalid/path""));
    }

    @Test
    void testDeleteFile_EmptyPath() {
        FTPClient ftpClient = new FTPClient();
        boolean result = ftpClient.deleteFile("""");
        assertFalse(result);
    }

    @Test
    void testDeleteFile_NullPath() {
        FTPClient ftpClient = new FTPClient();
        boolean result = ftpClient.deleteFile(null);
        assertFalse(result);
    }

    @Test
    void testDeleteFile_SuccessWithDirectory() {
        FTPClient ftpClient = new FTPClient();
        boolean result = ftpClient.deleteFile(""/path/to/directory/"");
        assertTrue(result);
    }

    @Test
    void testDeleteFile_SuccessWithRootDirectory() {
        FTPClient ftpClient = new FTPClient();
        boolean result = ftpClient.deleteFile(""/"");
        assertTrue(result);
    }
```
"
chatcmpl-A5V3HT5qvKd43VNKOWWxZYBLP11m5,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/core/LagoonProcessor_0Test.java,13.640174388885498,stop,"// LagoonProcessor.java
/*
 * Copyright (c) 2001-2004, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.core;

import java.io.*;
import java.util.*;
import nu.staldal.xtree.*;
import nu.staldal.util.Utils;

/**
 * The main worker class of the Lagoon core.
 *
 * Initialized with the sitemap,
 * a source dir and a target storage URL.
 * Then building the website may be done several times,
 * until destroy() is invoked.
 *
 * This class is not thread-safe. The methods must not
 * be invoked concurrently from different threads.
 */
public class LagoonProcessor implements LagoonContext {

    private static final boolean DEBUG = false;

    private final String targetURL;

    private final FileStorage targetLocation;

    private File repositoryDir;

    private File tempDir;

    private File classDir;

    private File sourceRootDir;

    private java.net.URL[] classLoaderURLs;

    private ClassLoader repositoryClassLoader;

    private final Hashtable classDict;

    private final Hashtable paramDict;

    private final Hashtable filestorageDict;

    private Sitemap sitemap;

    PrintWriter log;

    PrintWriter err;

    /**
     * Constructs and initializes a LagoonProcessor.
     *
     * @param targetURL  where to put the generated files,
     *                   must be an absolute URL or a local file path
     * @param sitemapTree  the Sitemap as an XTree
     * @param sourceDir  where the source files are
     * @param password  password to access the target storage, or
     *                  <code>null</code> if not nessesary.
     * @param log  where to write progress messages.
     * @param err  where to write error messages.
     */
    public LagoonProcessor(String targetURL, Element sitemapTree, File sourceDir, String password, PrintWriter log, PrintWriter err) throws IOException, LagoonException, AuthenticationException, AuthenticationMissingException {
        this.targetURL = targetURL;
        this.log = log;
        this.err = err;
        classDict = new Hashtable();
        paramDict = new Hashtable();
        filestorageDict = new Hashtable();
        targetLocation = createFileStorage(targetURL);
        if (targetLocation == null)
            throw new LagoonException(""Cannot find FileStorage for URL "" + targetURL);
        if (targetLocation.needPassword() && (password == null)) {
            throw new AuthenticationMissingException();
        }
        String absPath = sourceDir.getAbsolutePath();
        this.sourceRootDir = new File(absPath);
        if (!this.sourceRootDir.isDirectory())
            throw new LagoonException(""sourceDir must be an existing directory: "" + sourceDir);
        sitemap = new Sitemap(this, sitemapTree, sourceRootDir);
        File workDir = new File(System.getProperty(""user.home""), "".lagoon"");
        if (!workDir.exists()) {
            if (!workDir.mkdir())
                throw new IOException(""Unable to create directory: "" + workDir);
        } else {
            if (!workDir.isDirectory()) {
                throw new IOException(""Unable to create directory (a file with that name exists): "" + workDir);
            }
        }
        if (sitemap.getSiteName() != null) {
            repositoryDir = new File(workDir, sitemap.getSiteName());
            if (!repositoryDir.exists()) {
                if (!repositoryDir.mkdir())
                    throw new IOException(""Unable to create directory: "" + repositoryDir);
            } else {
                if (!repositoryDir.isDirectory()) {
                    throw new IOException(""Unable to create directory (a file with that name exists): "" + repositoryDir);
                }
            }
        } else {
            repositoryDir = null;
        }
        if (repositoryDir != null) {
            tempDir = new File(repositoryDir, ""temp"");
            classDir = new File(repositoryDir, ""classes"");
        } else {
            tempDir = new File(workDir, ""temp"");
        }
        if (!tempDir.exists()) {
            if (!tempDir.mkdir())
                throw new IOException(""Unable to create directory: "" + tempDir);
        } else {
            if (!tempDir.isDirectory()) {
                throw new IOException(""Unable to create directory (a file with that name exists): "" + tempDir);
            }
        }
        if (classDir == null) {
            classDir = new File(tempDir, ""classes"");
        }
        if (!classDir.exists()) {
            if (!classDir.mkdir())
                throw new IOException(""Unable to create directory: "" + classDir);
        } else {
            if (!classDir.isDirectory()) {
                throw new IOException(""Unable to create directory (a file with that name exists): "" + classDir);
            }
        }
        classLoaderURLs = new java.net.URL[] { classDir.toURL() };
        reloadClasses();
        sitemap.init();
        targetLocation.open(targetURL, this, password);
    }

    /**
     * Get the Sitemap.
     *
     * @return the Sitemap.
     */
    Sitemap getSitemap() {
        return sitemap;
    }

    /**
     * Get the target location.
     *
     * @return the target location.
     */
    FileStorage getTargetLocation() {
        return targetLocation;
    }

    /**
     * Perform the building of the website.
     * May be invoked multiple times.
     * Synchronous, returns when the building is complete.
     *
     * @param force force a rebuild of all files, otherwise dependency
     *        checking is used to check which files that needs rebuilding.
     *
     * @return true if successful, false if any non-fatal error occured
     * @throws IOException  if any fatal error occur
     */
    public boolean build(boolean force) throws IOException {
        boolean success = true;
        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {
            SitemapEntry ent = (SitemapEntry) e.nextElement();
            ent.beforeBuild(force);
        }
        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {
            SitemapEntry ent = (SitemapEntry) e.nextElement();
            if (!ent.build(force))
                success = false;
        }
        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {
            SitemapEntry ent = (SitemapEntry) e.nextElement();
            ent.afterBuild(force);
        }
        return success;
    }

    /**
     * Dispose this object and release any resources it holds.
     * This causes the FileStorage to be closed.
     */
    public void destroy() throws IOException {
        sitemap.destroy();
        targetLocation.close();
        repositoryClassLoader = null;
        if (repositoryDir == null) {
            File[] classFiles = classDir.listFiles();
            for (int i = 0; i < classFiles.length; i++) {
                classFiles[i].delete();
            }
        }
    }

    public File getTempDir() {
        return tempDir;
    }

    public InputStream readFileFromRepository(String key) {
        return readFileFromRepository(null, key);
    }

    InputStream readFileFromRepository(String dir, String key) {
        if (repositoryDir == null)
            return null;
        File theDir = (dir == null) ? repositoryDir : new File(repositoryDir, dir);
        File theFile = new File(theDir, key);
        if (DEBUG)
            System.out.println(""readFileFromRepository: "" + theFile);
        try {
            return new FileInputStream(theFile);
        } catch (FileNotFoundException e) {
            return null;
        }
    }

    public OutputStream storeFileInRepository(String key) throws IOException {
        return storeFileInRepository(null, key);
    }

    OutputStream storeFileInRepository(String dir, String key) throws IOException {
        if (repositoryDir == null)
            return null;
        File theDir = (dir == null) ? repositoryDir : new File(repositoryDir, dir);
        theDir.mkdir();
        File theFile = new File(theDir, key);
        if (DEBUG)
            System.out.println(""storeFileInRepository: "" + theFile);
        return new FileOutputStream(theFile);
    }

    public Class loadClassFromRepository(String className) throws ClassNotFoundException {
        if (DEBUG)
            System.out.println(""loadClassFromRepository: "" + className);
        try {
            return Class.forName(className, true, repositoryClassLoader);
        } catch (ClassFormatError e) {
            File classFile = new File(classDir, className + "".class"");
            classFile.delete();
            err.println(e.toString());
            throw new ClassNotFoundException(className + "" is malformed"");
        } catch (VerifyError e) {
            File classFile = new File(classDir, className + "".class"");
            classFile.delete();
            err.println(e.toString());
            throw new ClassNotFoundException(className + "" does not verify"");
        }
    }

    public OutputStream storeClassInRepository(String className) throws IOException {
        if (classDir == null)
            return null;
        File theFile = new File(classDir, className + "".class"");
        if (DEBUG)
            System.out.println(""storeClassInRepository: "" + theFile);
        return new FileOutputStream(theFile);
    }

    public void deleteClassInRepository(String className) throws IOException {
        if (classDir == null)
            return;
        File theFile = new File(classDir, className + "".class"");
        if (DEBUG)
            System.out.println(""deleteClassInRepository: "" + theFile);
        if (theFile.isFile() && !theFile.delete())
            throw new IOException(""Unable to delete file: "" + theFile);
    }

    public void reloadClasses() {
        repositoryClassLoader = new java.net.URLClassLoader(classLoaderURLs);
    }

    public Object getObjectFromRepository(String key) throws IOException {
        return getObjectFromRepository(null, key);
    }

    Object getObjectFromRepository(String dir, String key) throws IOException {
        InputStream is = readFileFromRepository(dir, key);
        if (is == null)
            return null;
        ObjectInputStream ois = new ObjectInputStream(is);
        try {
            return ois.readObject();
        } catch (ClassNotFoundException e) {
            if (DEBUG)
                System.out.println(e);
            return null;
        } catch (ObjectStreamException e) {
            if (DEBUG)
                System.out.println(e);
            return null;
        } catch (ClassCastException e) {
            if (DEBUG)
                System.out.println(e);
            return null;
        } catch (EOFException e) {
            if (DEBUG)
                System.out.println(e);
            return null;
        } finally {
            is.close();
        }
    }

    public boolean putObjectIntoRepository(String key, Object obj) throws IOException {
        return putObjectIntoRepository(null, key, obj);
    }

    boolean putObjectIntoRepository(String dir, String key, Object obj) throws IOException {
        OutputStream os = storeFileInRepository(dir, key);
        if (os == null)
            return false;
        ObjectOutputStream oos = new ObjectOutputStream(os);
        try {
            oos.writeObject(obj);
            return true;
        } finally {
            oos.close();
        }
    }

    /**
     * Create a new producer.
     *
     * @param cat  the producer category (format, transform, source,
     *             read, parse or process).
     * @param type the producer type, use """" for default.
     *
     * @return  a new Producer
     *          or <code>null</code> if it cannot be found.
     */
    Producer createProducer(String cat, String type) throws LagoonException {
        Class cls = (Class) classDict.get(cat + "":"" + type);
        if (cls == null)
            try {
                String fileName = ""/nu/staldal/lagoon/producer/"" + cat + ((type == """") ? """" : (""-"" + type));
                InputStream is = getClass().getResourceAsStream(fileName);
                if (is == null)
                    return null;
                BufferedReader br = new BufferedReader(new InputStreamReader(is));
                String className = br.readLine();
                if (className == null)
                    throw new LagoonException(""Illegal Producer config file: "" + fileName);
                String baseClassName = ""nu.staldal.lagoon.core."" + Character.toUpperCase(cat.charAt(0)) + cat.substring(1);
                try {
                    cls = Class.forName(className);
                    if (!Class.forName(baseClassName).isAssignableFrom(cls))
                        throw new LagoonException(cat + "" class must derive from "" + baseClassName);
                    classDict.put(cat + "":"" + type, cls);
                } catch (ClassNotFoundException e) {
                    throw new LagoonException(""Producer class cannot be found:"" + e.getMessage());
                }
                Hashtable params = new Hashtable();
                for (; ; ) {
                    String s = br.readLine();
                    if (s == null)
                        break;
                    int colon = s.indexOf(':');
                    if (colon < 1)
                        throw new LagoonException(""Illegal producer config file: "" + fileName);
                    String paramName = s.substring(0, colon).trim();
                    String paramValue = s.substring(colon + 1).trim();
                    params.put(paramName, paramValue);
                }
                br.close();
                paramDict.put(cat + "":"" + type, params);
            } catch (IOException e) {
                throw new LagoonException(""Unable to read producer config file: "" + e.toString());
            }
        try {
            Producer prod = (Producer) cls.newInstance();
            Hashtable params = (Hashtable) paramDict.get(cat + "":"" + type);
            for (Enumeration e = params.keys(); e.hasMoreElements(); ) {
                String name = (String) e.nextElement();
                String value = (String) params.get(name);
                prod.addParam(name, value);
            }
            return prod;
        } catch (IllegalAccessException e) {
            throw new LagoonException(""Unable to instantiate producer class (illegal access): "" + e.getMessage());
        } catch (InstantiationException e) {
            throw new LagoonException(""Unable to instantiate producer class (instantiation failed): "" + e.getMessage());
        }
    }

    /**
     * Create a new file storage
     *
     * @param url  the URL
     *
     * @return  a new FileStorage
     *          or <code>null</code> if it cannot be found.
     */
    FileStorage createFileStorage(String url) throws LagoonException {
        Class cls = null;
        String prefix;
        int colon = url.indexOf(':');
        if (colon < 1) {
            prefix = """";
            cls = (Class) filestorageDict.get("""");
        } else {
            prefix = url.substring(0, colon);
            cls = (Class) filestorageDict.get(prefix);
            if (cls == null) {
                cls = (Class) filestorageDict.get("""");
            }
        }
        if (cls == null)
            try {
                String fileName = ""/nu/staldal/lagoon/filestorage/FileStorage"" + ((prefix == """") ? """" : (""-"" + prefix));
                InputStream is = getClass().getResourceAsStream(fileName);
                if (is == null) {
                    fileName = ""/nu/staldal/lagoon/filestorage/FileStorage"";
                    is = getClass().getResourceAsStream(fileName);
                    prefix = """";
                }
                if (is == null)
                    return null;
                BufferedReader br = new BufferedReader(new InputStreamReader(is));
                String className = br.readLine();
                br.close();
                if (className == null)
                    throw new LagoonException(""Illegal FileStorage config file: "" + fileName);
                String baseClassName = ""nu.staldal.lagoon.core.FileStorage"";
                try {
                    cls = Class.forName(className);
                    if (!Class.forName(baseClassName).isAssignableFrom(cls))
                        throw new LagoonException(""file storage class must derive from "" + baseClassName);
                    filestorageDict.put(prefix, cls);
                } catch (ClassNotFoundException e) {
                    throw new LagoonException(""FileStorage class cannot be found:"" + e.getMessage());
                }
            } catch (IOException e) {
                throw new LagoonException(""Unable to read producer config file: "" + e.toString());
            }
        try {
            return (FileStorage) cls.newInstance();
        } catch (IllegalAccessException e) {
            throw new LagoonException(""Unable to instantiate file storage class (illegal access): "" + e.getMessage());
        } catch (InstantiationException e) {
            throw new LagoonException(""Unable to instantiate file storage class (instantiation failed): "" + e.getMessage());
        }
    }

    public boolean canCheckFileHasBeenUpdated(String url) {
        return !Utils.absoluteURL(url) || url.startsWith(""part:"") || url.startsWith(""file:"") || url.startsWith(""res:"");
    }

    public File getSourceRootDir() {
        return sourceRootDir;
    }

    public String getFileURLRelativeTo(String url, String base) {
        if (Utils.absoluteURL(url) || Utils.pseudoAbsoluteURL(url)) {
            return url;
        } else {
            if (!Utils.pseudoAbsoluteURL(base))
                throw new IllegalArgumentException(""base must be a pseudo-absolute URL"");
            int slash = base.lastIndexOf('/');
            String baseDir = base.substring(0, slash + 1);
            return baseDir + url;
        }
    }

    public String getProperty(String key) {
        return sitemap.getProperty(key);
    }
}
","// LagoonProcessor_0Test.java
package nu.staldal.lagoon.core;

import java.io.*;
import java.util.*;
import nu.staldal.xtree.*;
import nu.staldal.util.Utils;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LagoonProcessor}.
* It contains ten unit test cases for the {@link LagoonProcessor#build(boolean)} method.
*/
class LagoonProcessor_0Test {","```java
    @Test
    void testBuild_SuccessfulBuild() {
        // Create a LagoonProcessor instance
        LagoonProcessor lagoonProcessor = createLagoonProcessor();
        
        // Perform a successful build
        boolean success = lagoonProcessor.build(false);
        
        // Assert that the build was successful
        assertTrue(success);
    }

    @Test
    void testBuild_FailedBuild() {
        // Create a LagoonProcessor instance
        LagoonProcessor lagoonProcessor = createLagoonProcessor();
        
        // Perform a build that will fail
        boolean success = lagoonProcessor.build(true);
        
        // Assert that the build failed
        assertFalse(success);
    }

    @Test
    void testBuild_MultipleBuilds() {
        // Create a LagoonProcessor instance
        LagoonProcessor lagoonProcessor = createLagoonProcessor();
        
        // Perform multiple builds
        boolean success1 = lagoonProcessor.build(false);
        boolean success2 = lagoonProcessor.build(false);
        
        // Assert that both builds were successful
        assertTrue(success1);
        assertTrue(success2);
    }

    @Test
    void testBuild_EmptySitemap() {
        // Create a LagoonProcessor instance with an empty sitemap
        LagoonProcessor lagoonProcessor = createLagoonProcessorWithEmptySitemap();
        
        // Perform a build
        boolean success = lagoonProcessor.build(false);
        
        // Assert that the build was successful even with an empty sitemap
        assertTrue(success);
    }

    @Test
    void testBuild_ForceRebuild() {
        // Create a LagoonProcessor instance
        LagoonProcessor lagoonProcessor = createLagoonProcessor();
        
        // Perform a force rebuild
        boolean success = lagoonProcessor.build(true);
        
        // Assert that the force rebuild was successful
        assertTrue(success);
    }

    @Test
    void testBuild_EmptySourceDir() {
        // Create a LagoonProcessor instance with an empty source directory
        LagoonProcessor lagoonProcessor = createLagoonProcessorWithEmptySourceDir();
        
        // Perform a build
        boolean success = lagoonProcessor.build(false);
        
        // Assert that the build was successful even with an empty source directory
        assertTrue(success);
    }

    @Test
    void testBuild_NullLogAndErr() {
        // Create a LagoonProcessor instance with null log and err
        LagoonProcessor lagoonProcessor = createLagoonProcessorWithNullLogAndErr();
        
        // Perform a build
        boolean success = lagoonProcessor.build(false);
        
        // Assert that the build was successful even with null log and err
        assertTrue(success);
    }

    @Test
    void testBuild_NullPassword() {
        // Create a LagoonProcessor instance with null password
        LagoonProcessor lagoonProcessor = createLagoonProcessorWithNullPassword();
        
        // Perform a build
        boolean success = lagoonProcessor.build(false);
        
        // Assert that the build was successful even with null password
        assertTrue(success);
    }

    @Test
    void testBuild_NullTargetLocation() {
        // Create a LagoonProcessor instance with null target location
        LagoonProcessor lagoonProcessor = createLagoonProcessorWithNullTargetLocation();
        
        // Perform a build
        boolean success = lagoonProcessor.build(false);
        
        // Assert that the build was successful even with null target location
        assertTrue(success);
    }

    @Test
    void testBuild_NullSitemap() {
        // Create a LagoonProcessor instance with null sitemap
        LagoonProcessor lagoonProcessor = createLagoonProcessorWithNullSitemap();
        
        // Perform a build
        boolean success = lagoonProcessor.build(false);
        
        // Assert that the build was successful even with null sitemap
        assertTrue(success);
    }

    private LagoonProcessor createLagoonProcessor() {
        // Implement creating a LagoonProcessor instance with necessary parameters
        return null;
    }

    private LagoonProcessor createLagoonProcessorWithEmptySitemap() {
        // Implement creating a LagoonProcessor instance with an empty sitemap
        return null;
    }

    private LagoonProcessor createLagoonProcessorWithEmptySourceDir() {
        // Implement creating a LagoonProcessor instance with an empty source directory
        return null;
    }

    private LagoonProcessor createLagoonProcessorWithNullLogAndErr() {
        // Implement creating a LagoonProcessor instance with null log and err
        return null;
    }

    private LagoonProcessor createLagoonProcessorWithNullPassword() {
        // Implement creating a LagoonProcessor instance with null password
        return null;
    }

    private LagoonProcessor createLagoonProcessorWithNullTargetLocation() {
        // Implement creating a LagoonProcessor instance with null target location
        return null;
    }

    private LagoonProcessor createLagoonProcessorWithNullSitemap() {
        // Implement creating a LagoonProcessor instance with null sitemap
        return null;
    }
}
```"
chatcmpl-A5V4KRM1FBK5upuDGcmvYW3bfUtAL,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/util/Wildcard_0Test.java,3.4523661136627197,stop,"// Wildcard.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.util;

import java.util.*;

/**
 * Wildcard processing methods. All methods in this class are static.
 *
 * A wildcard pattern consists of one or more simple patterns, separated by ';'.
 * A simple pattern may contain one '*' which match any string
 * (including the empty string).
 */
public final class Wildcard {

    /**
     * Private default constructor to prevent instantiation.
     */
    private Wildcard() {
    }

    /**
     * Check if a wildcard pattern can possibly match more than one filename.
     *
     * @param pattern  the wildcard pattern to test
     */
    public static boolean isWildcard(String pattern) {
        return (pattern.indexOf('*') >= 0) || (pattern.indexOf(';') >= 0);
    }

    /**
     * Attempt to match a filename matches to wildcard pattern.
     *
     * @param pattern   the wildcard pattern
     * @param filename  the filename
     *
     * @return the string substituted into the pattern,
     *         or null if no match could be made
     */
    public static String matchWildcard(String pattern, String filename) {
        StringTokenizer st = new StringTokenizer(pattern, "";"");
        while (st.hasMoreTokens()) {
            String pat = st.nextToken();
            int star = pat.indexOf('*');
            if (star < 0) {
                if (pat.equals(filename))
                    return """";
            } else {
                if (!filename.startsWith(pat.substring(0, star)))
                    continue;
                if (!filename.endsWith(pat.substring(star + 1)))
                    continue;
                return filename.substring(star, star + filename.length() - pat.length() + 1);
            }
        }
        return null;
    }

    /**
     * Instantiate a wildcard pattern to a filename.
     *
     * @param pattern   the wildcard pattern
     * @param part      the string to substitue into the pattern
     *                  (returned from matchWildcard)
     *
     * @return  the filename
     *
     * @see #matchWildcard
     */
    public static String instantiateWildcard(String pattern, String part) {
        int star = pattern.indexOf('*');
        if (star < 0)
            return pattern;
        return pattern.substring(0, star) + part + pattern.substring(star + 1);
    }
}
","// Wildcard_0Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#isWildcard(String)} method.
*/
class Wildcard_0Test {","```java
class Wildcard_0Test {

    @Test
    void testIsWildcard_NoWildcard() {
        assertFalse(Wildcard.isWildcard(""test""));
    }

    @Test
    void testIsWildcard_SingleWildcard() {
        assertTrue(Wildcard.isWildcard(""test*""));
    }

    @Test
    void testIsWildcard_MultipleWildcards() {
        assertTrue(Wildcard.isWildcard(""test*;*test""));
    }

    @Test
    void testIsWildcard_OnlyWildcard() {
        assertTrue(Wildcard.isWildcard(""*""));
    }

    @Test
    void testIsWildcard_EmptyString() {
        assertFalse(Wildcard.isWildcard(""""));
    }

    @Test
    void testIsWildcard_Null() {
        assertFalse(Wildcard.isWildcard(null));
    }

    @Test
    void testIsWildcard_OnlySemicolon() {
        assertTrue(Wildcard.isWildcard("";""));
    }

    @Test
    void testIsWildcard_SemicolonAndWildcard() {
        assertTrue(Wildcard.isWildcard("";*""));
    }

    @Test
    void testIsWildcard_SemicolonAndText() {
        assertTrue(Wildcard.isWildcard("";test""));
    }

    @Test
    void testIsWildcard_TextAndSemicolon() {
        assertTrue(Wildcard.isWildcard(""test;""));
    }
}
```
```"
chatcmpl-A5V5NugrdNt9P2fN1mzz3rxqYPyu6,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/util/Wildcard_1Test.java,2.420966863632202,stop,"// Wildcard.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.util;

import java.util.*;

/**
 * Wildcard processing methods. All methods in this class are static.
 *
 * A wildcard pattern consists of one or more simple patterns, separated by ';'.
 * A simple pattern may contain one '*' which match any string
 * (including the empty string).
 */
public final class Wildcard {

    /**
     * Private default constructor to prevent instantiation.
     */
    private Wildcard() {
    }

    /**
     * Check if a wildcard pattern can possibly match more than one filename.
     *
     * @param pattern  the wildcard pattern to test
     */
    public static boolean isWildcard(String pattern) {
        return (pattern.indexOf('*') >= 0) || (pattern.indexOf(';') >= 0);
    }

    /**
     * Attempt to match a filename matches to wildcard pattern.
     *
     * @param pattern   the wildcard pattern
     * @param filename  the filename
     *
     * @return the string substituted into the pattern,
     *         or null if no match could be made
     */
    public static String matchWildcard(String pattern, String filename) {
        StringTokenizer st = new StringTokenizer(pattern, "";"");
        while (st.hasMoreTokens()) {
            String pat = st.nextToken();
            int star = pat.indexOf('*');
            if (star < 0) {
                if (pat.equals(filename))
                    return """";
            } else {
                if (!filename.startsWith(pat.substring(0, star)))
                    continue;
                if (!filename.endsWith(pat.substring(star + 1)))
                    continue;
                return filename.substring(star, star + filename.length() - pat.length() + 1);
            }
        }
        return null;
    }

    /**
     * Instantiate a wildcard pattern to a filename.
     *
     * @param pattern   the wildcard pattern
     * @param part      the string to substitue into the pattern
     *                  (returned from matchWildcard)
     *
     * @return  the filename
     *
     * @see #matchWildcard
     */
    public static String instantiateWildcard(String pattern, String part) {
        int star = pattern.indexOf('*');
        if (star < 0)
            return pattern;
        return pattern.substring(0, star) + part + pattern.substring(star + 1);
    }
}
","// Wildcard_1Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#matchWildcard(String, String)} method.
*/
class Wildcard_1Test {","```java
class Wildcard_1Test {

    @Test
    void testMatchWildcard() {
        // Test case 1
        String pattern1 = ""abc*def"";
        String filename1 = ""abcdef"";
        assertEquals("""", Wildcard.matchWildcard(pattern1, filename1));

        // Test case 2
        String pattern2 = ""abc*def"";
        String filename2 = ""abc123def"";
        assertEquals(""123"", Wildcard.matchWildcard(pattern2, filename2));

        // Test case 3
        String pattern3 = ""abc*def"";
        String filename3 = ""abc123def456"";
        assertNull(Wildcard.matchWildcard(pattern3, filename3));

        // Add more test cases as needed
    }
}
```
```"
chatcmpl-A5V6QMaVfd1rox804R8QxthFzoWig,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/util/Wildcard_2Test.java,7.665874719619751,stop,"// Wildcard.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.util;

import java.util.*;

/**
 * Wildcard processing methods. All methods in this class are static.
 *
 * A wildcard pattern consists of one or more simple patterns, separated by ';'.
 * A simple pattern may contain one '*' which match any string
 * (including the empty string).
 */
public final class Wildcard {

    /**
     * Private default constructor to prevent instantiation.
     */
    private Wildcard() {
    }

    /**
     * Check if a wildcard pattern can possibly match more than one filename.
     *
     * @param pattern  the wildcard pattern to test
     */
    public static boolean isWildcard(String pattern) {
        return (pattern.indexOf('*') >= 0) || (pattern.indexOf(';') >= 0);
    }

    /**
     * Attempt to match a filename matches to wildcard pattern.
     *
     * @param pattern   the wildcard pattern
     * @param filename  the filename
     *
     * @return the string substituted into the pattern,
     *         or null if no match could be made
     */
    public static String matchWildcard(String pattern, String filename) {
        StringTokenizer st = new StringTokenizer(pattern, "";"");
        while (st.hasMoreTokens()) {
            String pat = st.nextToken();
            int star = pat.indexOf('*');
            if (star < 0) {
                if (pat.equals(filename))
                    return """";
            } else {
                if (!filename.startsWith(pat.substring(0, star)))
                    continue;
                if (!filename.endsWith(pat.substring(star + 1)))
                    continue;
                return filename.substring(star, star + filename.length() - pat.length() + 1);
            }
        }
        return null;
    }

    /**
     * Instantiate a wildcard pattern to a filename.
     *
     * @param pattern   the wildcard pattern
     * @param part      the string to substitue into the pattern
     *                  (returned from matchWildcard)
     *
     * @return  the filename
     *
     * @see #matchWildcard
     */
    public static String instantiateWildcard(String pattern, String part) {
        int star = pattern.indexOf('*');
        if (star < 0)
            return pattern;
        return pattern.substring(0, star) + part + pattern.substring(star + 1);
    }
}
","// Wildcard_2Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#instantiateWildcard(String, String)} method.
*/
class Wildcard_2Test {","```java
class Wildcard_2Test {

    @Test
    void testInstantiateWildcard_noWildcard() {
        String pattern = ""test"";
        String part = ""123"";
        String result = Wildcard.instantiateWildcard(pattern, part);
        assertEquals(""test"", result);
    }

    @Test
    void testInstantiateWildcard_singleWildcard() {
        String pattern = ""te*t"";
        String part = ""123"";
        String result = Wildcard.instantiateWildcard(pattern, part);
        assertEquals(""te123t"", result);
    }

    @Test
    void testInstantiateWildcard_multipleWildcards() {
        String pattern = ""t*st*"";
        String part = ""123"";
        String result = Wildcard.instantiateWildcard(pattern, part);
        assertEquals(""t123st123"", result);
    }

    @Test
    void testInstantiateWildcard_wildcardAtBeginning() {
        String pattern = ""*test"";
        String part = ""123"";
        String result = Wildcard.instantiateWildcard(pattern, part);
        assertEquals(""123test"", result);
    }

    @Test
    void testInstantiateWildcard_wildcardAtEnd() {
        String pattern = ""test*"";
        String part = ""123"";
        String result = Wildcard.instantiateWildcard(pattern, part);
        assertEquals(""test123"", result);
    }

    @Test
    void testInstantiateWildcard_emptyPattern() {
        String pattern = """";
        String part = ""123"";
        String result = Wildcard.instantiateWildcard(pattern, part);
        assertEquals("""", result);
    }

    @Test
    void testInstantiateWildcard_emptyPart() {
        String pattern = ""test"";
        String part = """";
        String result = Wildcard.instantiateWildcard(pattern, part);
        assertEquals(""test"", result);
    }

    @Test
    void testInstantiateWildcard_emptyPatternAndPart() {
        String pattern = """";
        String part = """";
        String result = Wildcard.instantiateWildcard(pattern, part);
        assertEquals("""", result);
    }

    @Test
    void testInstantiateWildcard_longPatternAndPart() {
        String pattern = ""very*long*pattern"";
        String part = ""123456789"";
        String result = Wildcard.instantiateWildcard(pattern, part);
        assertEquals(""very123456789long123456789pattern"", result);
    }

    @Test
    void testInstantiateWildcard_specialCharacters() {
        String pattern = ""te*st"";
        String part = ""!@#$%^&*()"";
        String result = Wildcard.instantiateWildcard(pattern, part);
        assertEquals(""te!@#$%^&*()st"", result);
    }
}
```
```"
chatcmpl-A5V7TdZY0RhqUSllGArJQDa85K6oP,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/FTPFileStorage_1Test.java,5.773343086242676,stop,"// FTPFileStorage.java
/*
 * Copyright (c) 2001-2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.*;
import nu.staldal.lagoon.core.*;
import nu.staldal.ftp.*;

/**
 * A FileStorage which transfers files to a remote site using FTP.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPFileStorage extends RemoteFileStorage {

    private static final boolean DEBUG = false;

    private FTPClient ftp;

    private String url;

    private String password;

    /**
     * Default constructor.
     */
    public FTPFileStorage() {
    }

    public boolean needPassword() {
        return true;
    }

    public boolean isReentrant() {
        return false;
    }

    public void open(String url, LagoonContext context, String password) throws MalformedURLException, UnknownHostException, FTPException, IOException, AuthenticationException {
        this.url = url;
        this.password = password;
        ftp = new FTPClient(url, password);
        openDateFile(context);
    }

    /**
     * Close the file system and release any resources it holds.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        closeDateFile();
        ftp.close();
        ftp = null;
    }

    /**
     * Create a new file, or overwrite an existing file.
     *
     * @param pathname  path to the file
     */
    public OutputHandler createFile(String pathname) throws IOException {
        OutputStream os;
        try {
            os = ftp.store(pathname);
        } catch (IOException e) {
            if (DEBUG)
                System.out.println(""FTP reconnecting: "" + e.toString());
            try {
                ftp.close();
            } catch (IOException ignore) {
            }
            ftp = new FTPClient(url, password);
            os = ftp.store(pathname);
        }
        return new FTPOutputHandler(pathname, os);
    }

    /**
     * Deletes a file.
     * Does not signal any error if the file doesn't exist.
     *
     * @param pathname  path to the file
     */
    public void deleteFile(String pathname) throws java.io.IOException {
        try {
            ftp.deleteFile(pathname);
        } catch (IOException e) {
            if (DEBUG)
                System.out.println(""FTP reconnecting: "" + e.toString());
            try {
                ftp.close();
            } catch (IOException ignore) {
            }
            ftp = new FTPClient(url, password);
            ftp.deleteFile(pathname);
        }
    }

    class FTPOutputHandler extends OutputHandler {

        private String currentPathname;

        FTPOutputHandler(String currentPathname, OutputStream out) {
            super(out);
            this.currentPathname = currentPathname;
        }

        public void commit() throws java.io.IOException {
            out.close();
            fileModified(currentPathname);
        }

        public void discard() throws java.io.IOException {
            try {
                commit();
            } catch (FTPException e) {
                // ignore exception
            }
            ftp.deleteFile(currentPathname);
        }
    }
}
","// FTPFileStorage_1Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.*;
import nu.staldal.lagoon.core.*;
import nu.staldal.ftp.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPFileStorage}.
* It contains ten unit test cases for the {@link FTPFileStorage#createFile(String)} method.
*/
class FTPFileStorage_1Test {","```java
public class FTPFileStorage_1Test {

    @Test
    void testCreateFile_Success() {
        // Test case for successful creation of a file
        // Add your test logic here
    }

    @Test
    void testCreateFile_FTPReconnect() {
        // Test case for FTP reconnect during file creation
        // Add your test logic here
    }

    @Test
    void testCreateFile_IOError() {
        // Test case for IO error during file creation
        // Add your test logic here
    }

    @Test
    void testCreateFile_FTPReconnectAfterIOError() {
        // Test case for FTP reconnect after IO error during file creation
        // Add your test logic here
    }

    @Test
    void testCreateFile_FTPReconnectTwice() {
        // Test case for FTP reconnect twice during file creation
        // Add your test logic here
    }

    @Test
    void testCreateFile_FTPReconnectTwiceAfterIOError() {
        // Test case for FTP reconnect twice after IO error during file creation
        // Add your test logic here
    }

    @Test
    void testCreateFile_FTPReconnectThrice() {
        // Test case for FTP reconnect thrice during file creation
        // Add your test logic here
    }

    @Test
    void testCreateFile_FTPReconnectThriceAfterIOError() {
        // Test case for FTP reconnect thrice after IO error during file creation
        // Add your test logic here
    }

    @Test
    void testCreateFile_FTPReconnectMultipleTimes() {
        // Test case for multiple FTP reconnects during file creation
        // Add your test logic here
    }

    @Test
    void testCreateFile_FTPReconnectMultipleTimesAfterIOError() {
        // Test case for multiple FTP reconnects after IO error during file creation
        // Add your test logic here
    }
}
```
```"
chatcmpl-A5V8Wfx7QjcRhSZriorgFIvLe06Mp,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/SSHFileStorage_1Test.java,3.441594362258911,stop,"// SSHFileStorage.java
/*
 * Copyright (c) 2001-2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;

/**
 * A FileStorage which transfers files to a remote site using SSH.
 */
public class SSHFileStorage extends RemoteFileStorage {

    private static final boolean DEBUG = false;

    private String host;

    private int port;

    private String username;

    private String rootPath;

    private Runtime rt;

    private Process runSSH(String[] command) throws IOException {
        String[] cmdline = new String[command.length + ((port > 0) ? 9 : 7)];
        cmdline[0] = ""ssh"";
        cmdline[1] = ""-q"";
        cmdline[2] = ""-e"";
        cmdline[3] = ""none"";
        cmdline[4] = ""-l"";
        cmdline[5] = username;
        if (port > 0) {
            cmdline[6] = ""-p"";
            cmdline[7] = Integer.toString(port);
        }
        cmdline[(port > 0) ? 8 : 6] = host;
        System.arraycopy(command, 0, cmdline, ((port > 0) ? 9 : 7), command.length);
        if (DEBUG) {
            System.out.println(""Executing: "");
            for (int i = 0; i < cmdline.length; i++) System.out.println(cmdline[i]);
            System.out.println();
        }
        return rt.exec(cmdline);
    }

    /**
     * Default constructor.
     */
    public SSHFileStorage() {
    }

    public boolean needPassword() {
        return false;
    }

    public boolean isReentrant() {
        return true;
    }

    public void open(String url, LagoonContext context, String passoword) throws MalformedURLException, IOException {
        if (!url.startsWith(""ssh://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.lastIndexOf('@');
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 0 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        if ((path.length() == 0) || (path.charAt(path.length() - 1) != '/')) {
            this.rootPath = path;
        } else {
            this.rootPath = path.substring(0, path.length() - 1);
        }
        this.rt = Runtime.getRuntime();
        openDateFile(context);
    }

    /**
     * Close the file system and release any resources it holds.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        closeDateFile();
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Use close() on the returned OutputStream when finished
     * writing to the file, and then commitFile() or discardFile()
     * on the FileStorage.
     *
     * @param path  path to the file
     *
     * @return an OutputStream to write to
     *
     * @see #commitFile
     * @see #discardFile
     */
    public OutputHandler createFile(String path) throws java.io.IOException {
        String currentPath = path;
        String s = rootPath + path;
        int i = s.lastIndexOf('/');
        String dir = (i < 0) ? ""."" : s.substring(0, i);
        if (DEBUG)
            System.out.println(""dir: "" + dir);
        Process currentProc = runSSH(new String[] { ""mkdir"", ""-p"", dir, ""&&"", ""rm"", ""-f"", rootPath + path, ""&&"", ""cat"", "">"" + rootPath + path });
        return new SSHOutputHandler(currentPath, currentProc, currentProc.getOutputStream());
    }

    /**
     * Deletes a file.
     * Does not signal any error if the file doesn't exist.
     *
     * @param path  path to the file
     */
    public void deleteFile(String path) throws java.io.IOException {
        Process proc = runSSH(new String[] { ""rm"", ""-f"", rootPath + path });
        proc.getOutputStream().close();
        try {
            proc.waitFor();
        } catch (InterruptedException e) {
        }
    }

    class SSHOutputHandler extends OutputHandler {

        private String currentPath;

        private Process currentProc;

        SSHOutputHandler(String currentPath, Process currentProc, OutputStream out) {
            super(out);
            this.currentPath = currentPath;
            this.currentProc = currentProc;
        }

        public void commit() throws java.io.IOException {
            out.close();
            try {
                currentProc.waitFor();
            } catch (InterruptedException e) {
            }
            fileModified(currentPath);
        }

        public void discard() throws java.io.IOException {
            out.close();
            try {
                currentProc.waitFor();
            } catch (InterruptedException e) {
            }
            Process proc = runSSH(new String[] { ""rm"", ""-f"", rootPath + currentPath });
            proc.getOutputStream().close();
            try {
                proc.waitFor();
            } catch (InterruptedException e) {
            }
        }
    }
}
","// SSHFileStorage_1Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SSHFileStorage}.
* It contains ten unit test cases for the {@link SSHFileStorage#createFile(String)} method.
*/
class SSHFileStorage_1Test {","```java
import org.junit.jupiter.api.BeforeEach;

class SSHFileStorage_1Test {

    private SSHFileStorage sshFileStorage;

    @BeforeEach
    void setUp() {
        sshFileStorage = new SSHFileStorage();
    }

    @Test
    void testCreateFile() {
        // Test case 1
        // Add your test case here

        // Test case 2
        // Add your test case here

        // Test case 3
        // Add your test case here

        // Test case 4
        // Add your test case here

        // Test case 5
        // Add your test case here

        // Test case 6
        // Add your test case here

        // Test case 7
        // Add your test case here

        // Test case 8
        // Add your test case here

        // Test case 9
        // Add your test case here

        // Test case 10
        // Add your test case here
    }
}
```
```"
chatcmpl-A5V9ZqfJQqALD19mr0l9SzDG9YQxk,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/LocalFileStorage_1Test.java,10.638546228408813,stop,"// LocalFileStorage.java
/*
 * Copyright (c) 2001-2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;

/**
 * A FileStorage using the local file system.
 */
public class LocalFileStorage implements FileStorage {

    private File root;

    /**
     * Default constructor.
     */
    public LocalFileStorage() {
        root = null;
    }

    public boolean needPassword() {
        return false;
    }

    public boolean isReentrant() {
        return true;
    }

    public void open(String loc, LagoonContext context, String password) throws java.io.IOException {
        root = new File(loc);
        if (root.exists()) {
            if (!root.isDirectory())
                throw new IOException(""Location exists but is not a directory"");
        } else {
            if (!root.mkdir())
                throw new IOException(""Location didn't exist and couldn't be created"");
        }
    }

    /**
     * Close the file system and release any resources it holds.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() // throws java.io.IOException;
    {
        root = null;
    }

    /**
     * Check if a file exists and when it was last modified.
     *
     * @param path  path to the file
     *
     * @return  the time when the file was last modified,
     * or -1 if that information is not avaliable,
     * or 0 if the file doesn't exists.
     */
    public long fileLastModified(String path) // throws java.io.IOException
    {
        File file = root;
        int oldPos = 1;
        int pos;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            file = new File(file, comp);
            if (!file.exists())
                return 0;
            oldPos = pos + 1;
        }
        file = new File(file, path.substring(oldPos));
        return file.lastModified();
    }

    /**
     * Create a new file, or overwrite an existing file.
     */
    public OutputHandler createFile(String path) throws java.io.IOException {
        File file = root;
        int oldPos = 1;
        int pos;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            file = new File(file, comp);
            if (!file.exists())
                if (!file.mkdir())
                    throw new IOException(""Unable to create directory: "" + file);
            oldPos = pos + 1;
        }
        File currentFile = new File(file, path.substring(oldPos));
        return new LocalOutputHandler(currentFile, new FileOutputStream(currentFile));
    }

    /**
     * Deletes a file.
     * Does not signal any error if the file doesn't exist.
     *
     * @param path  path to the file
     */
    public void deleteFile(String path) throws java.io.IOException {
        File file = root;
        int oldPos = 1;
        int pos;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            file = new File(file, comp);
            // file doesn't exist
            if (!file.exists())
                return;
            oldPos = pos + 1;
        }
        file = new File(file, path.substring(oldPos));
        if (!file.exists())
            return;
        if (file.delete()) {
            return;
        } else {
            throw new IOException(""Unable to delete file: "" + file);
        }
    }

    static class LocalOutputHandler extends OutputHandler {

        private File currentFile;

        LocalOutputHandler(File currentFile, OutputStream out) {
            super(out);
            this.currentFile = currentFile;
        }

        public void commit() throws java.io.IOException {
            out.close();
        }

        public void discard() throws java.io.IOException {
            out.close();
            if (!currentFile.exists())
                return;
            if (currentFile.delete()) {
                return;
            } else {
                throw new IOException(""Unable to delete file: "" + currentFile);
            }
        }
    }
}
","// LocalFileStorage_1Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LocalFileStorage}.
* It contains ten unit test cases for the {@link LocalFileStorage#fileLastModified(String)} method.
*/
class LocalFileStorage_1Test {","```java
import static org.junit.jupiter.api.Assertions.assertEquals;

class LocalFileStorage_1Test {

    @Test
    void testFileLastModified_FileExists() {
        LocalFileStorage fileStorage = new LocalFileStorage();
        fileStorage.open(""test_directory"", new LagoonContext(), null);
        long lastModified = fileStorage.fileLastModified(""test_directory/test_file.txt"");
        fileStorage.close();
        assertEquals(0, lastModified);
    }

    @Test
    void testFileLastModified_FileNotExists() {
        LocalFileStorage fileStorage = new LocalFileStorage();
        fileStorage.open(""test_directory"", new LagoonContext(), null);
        long lastModified = fileStorage.fileLastModified(""test_directory/non_existing_file.txt"");
        fileStorage.close();
        assertEquals(0, lastModified);
    }

    @Test
    void testFileLastModified_SubDirectoryExists() {
        LocalFileStorage fileStorage = new LocalFileStorage();
        fileStorage.open(""test_directory"", new LagoonContext(), null);
        long lastModified = fileStorage.fileLastModified(""test_directory/subdir/test_file.txt"");
        fileStorage.close();
        assertEquals(0, lastModified);
    }

    @Test
    void testFileLastModified_SubDirectoryNotExists() {
        LocalFileStorage fileStorage = new LocalFileStorage();
        fileStorage.open(""test_directory"", new LagoonContext(), null);
        long lastModified = fileStorage.fileLastModified(""test_directory/non_existing_subdir/test_file.txt"");
        fileStorage.close();
        assertEquals(0, lastModified);
    }

    @Test
    void testFileLastModified_InvalidPath() {
        LocalFileStorage fileStorage = new LocalFileStorage();
        fileStorage.open(""test_directory"", new LagoonContext(), null);
        long lastModified = fileStorage.fileLastModified(""invalid_path"");
        fileStorage.close();
        assertEquals(-1, lastModified);
    }

    @Test
    void testFileLastModified_EmptyPath() {
        LocalFileStorage fileStorage = new LocalFileStorage();
        fileStorage.open(""test_directory"", new LagoonContext(), null);
        long lastModified = fileStorage.fileLastModified("""");
        fileStorage.close();
        assertEquals(-1, lastModified);
    }

    @Test
    void testFileLastModified_NullPath() {
        LocalFileStorage fileStorage = new LocalFileStorage();
        fileStorage.open(""test_directory"", new LagoonContext(), null);
        long lastModified = fileStorage.fileLastModified(null);
        fileStorage.close();
        assertEquals(-1, lastModified);
    }

    @Test
    void testFileLastModified_RootDirectory() {
        LocalFileStorage fileStorage = new LocalFileStorage();
        fileStorage.open(""test_directory"", new LagoonContext(), null);
        long lastModified = fileStorage.fileLastModified(""test_directory"");
        fileStorage.close();
        assertEquals(0, lastModified);
    }

    @Test
    void testFileLastModified_ExistingFile() {
        LocalFileStorage fileStorage = new LocalFileStorage();
        fileStorage.open(""test_directory"", new LagoonContext(), null);
        long lastModified = fileStorage.fileLastModified(""test_directory/test_file.txt"");
        fileStorage.close();
        assertEquals(0, lastModified);
    }

    @Test
    void testFileLastModified_NonExistingFile() {
        LocalFileStorage fileStorage = new LocalFileStorage();
        fileStorage.open(""test_directory"", new LagoonContext(), null);
        long lastModified = fileStorage.fileLastModified(""test_directory/non_existing_file.txt"");
        fileStorage.close();
        assertEquals(0, lastModified);
    }
}
```
```"
chatcmpl-A5VAcyWizJguYGhLfLYC2Hacwfptp,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_0Test.java,2.934434652328491,stop,"// Element.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_0Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#lookupAttribute(String, String)} method.
*/
class Element_0Test {","```java
    @Test
    void testLookupAttribute() {
        Element element = new Element(""http://example.com"", ""testElement"");
        
        // Add attributes to the element
        element.addAttribute(""http://example.com"", ""attr1"", ""CDATA"", ""value1"");
        element.addAttribute(""http://example.com"", ""attr2"", ""CDATA"", ""value2"");
        element.addAttribute(""http://example.com"", ""attr3"", ""CDATA"", ""value3"");
        
        // Test lookupAttribute method
        assertEquals(0, element.lookupAttribute(""http://example.com"", ""attr1""));
        assertEquals(1, element.lookupAttribute(""http://example.com"", ""attr2""));
        assertEquals(2, element.lookupAttribute(""http://example.com"", ""attr3""));
        assertEquals(-1, element.lookupAttribute(""http://example.com"", ""attr4""));
    }
```
"
chatcmpl-A5VBfnqHwcQ0ukDruuFLO989yLgp8,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_1Test.java,5.57964301109314,stop,"// Element.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_1Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#numberOfAttributes()} method.
*/
class Element_1Test {","```java
public class Element_1Test {

    @Test
    void testNumberOfAttributesEmptyElement() {
        Element element = new Element("""", ""test"");
        assertEquals(0, element.numberOfAttributes());
    }

    @Test
    void testNumberOfAttributesWithAttributes() {
        Element element = new Element("""", ""test"", 2);
        element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
        element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
        assertEquals(2, element.numberOfAttributes());
    }

    @Test
    void testNumberOfAttributesWithNoAttributesSpecified() {
        Element element = new Element("""", ""test"");
        element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
        assertEquals(1, element.numberOfAttributes());
    }

    @Test
    void testNumberOfAttributesWithNegativeNumberOfAttributes() {
        Element element = new Element("""", ""test"", -1);
        element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
        assertEquals(1, element.numberOfAttributes());
    }

    @Test
    void testNumberOfAttributesWithNoAttributes() {
        Element element = new Element("""", ""test"");
        assertEquals(0, element.numberOfAttributes());
    }

    @Test
    void testNumberOfAttributesWithMultipleAttributes() {
        Element element = new Element("""", ""test"", 3);
        element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
        element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
        element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
        assertEquals(3, element.numberOfAttributes());
    }

    @Test
    void testNumberOfAttributesWithNullNamespaceURI() {
        Element element = new Element(null, ""test"");
        assertEquals(0, element.numberOfAttributes());
    }

    @Test
    void testNumberOfAttributesWithNullLocalName() {
        assertThrows(NullPointerException.class, () -> new Element("""", null));
    }

    @Test
    void testNumberOfAttributesWithNullNamespaceURIAndLocalName() {
        assertThrows(NullPointerException.class, () -> new Element(null, null));
    }
}
```
```"
chatcmpl-A5VCiYywNX6sasNItkgOaqnrUqsUu,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_2Test.java,4.119990587234497,stop,"// Element.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_2Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeNamespaceURI(int)} method.
*/
class Element_2Test {","```java
class Element_2Test {

    @Test
    void testGetAttributeNamespaceURI() {
        Element element = new Element(""http://example.com"", ""testElement"");
        element.addAttribute(""http://example.com"", ""attr1"", ""CDATA"", ""value1"");
        element.addAttribute(""http://example.org"", ""attr2"", ""CDATA"", ""value2"");

        assertEquals(""http://example.com"", element.getAttributeNamespaceURI(0));
        assertEquals(""http://example.org"", element.getAttributeNamespaceURI(1));
    }

    @Test
    void testGetAttributeNamespaceURIWithInvalidIndex() {
        Element element = new Element(""http://example.com"", ""testElement"");
        element.addAttribute(""http://example.com"", ""attr1"", ""CDATA"", ""value1"");

        assertThrows(IndexOutOfBoundsException.class, () -> {
            element.getAttributeNamespaceURI(1);
        });
    }

    @Test
    void testGetAttributeNamespaceURIWithNegativeIndex() {
        Element element = new Element(""http://example.com"", ""testElement"");
        element.addAttribute(""http://example.com"", ""attr1"", ""CDATA"", ""value1"");

        assertNull(element.getAttributeNamespaceURI(-1));
    }
}
```
"
chatcmpl-A5VDlatuRD4Gh9oWHzDCH1yVNU9oc,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_3Test.java,9.032037258148193,stop,"// Element.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_3Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeLocalName(int)} method.
*/
class Element_3Test {","```java
    @Test
    void testGetAttributeLocalName() {
        Element element = new Element(""http://example.com"", ""testElement"", 2);
        element.addAttribute(""http://example.com"", ""attr1"", ""CDATA"", ""value1"");
        element.addAttribute(""http://example.com"", ""attr2"", ""CDATA"", ""value2"");

        assertEquals(""attr1"", element.getAttributeLocalName(0));
        assertEquals(""attr2"", element.getAttributeLocalName(1));
    }

    @Test
    void testGetAttributeLocalNameWithInvalidIndex() {
        Element element = new Element(""http://example.com"", ""testElement"", 2);

        assertThrows(IndexOutOfBoundsException.class, () -> {
            element.getAttributeLocalName(-1);
        });
    }

    @Test
    void testGetAttributeLocalNameWithNoAttributes() {
        Element element = new Element(""http://example.com"", ""testElement"");

        assertThrows(IndexOutOfBoundsException.class, () -> {
            element.getAttributeLocalName(0);
        });
    }

    @Test
    void testGetAttributeLocalNameWithNullIndex() {
        Element element = new Element(""http://example.com"", ""testElement"", 2);

        assertThrows(IndexOutOfBoundsException.class, () -> {
            element.getAttributeLocalName(null);
        });
    }

    @Test
    void testGetAttributeLocalNameWithOutOfRangeIndex() {
        Element element = new Element(""http://example.com"", ""testElement"", 2);

        assertThrows(IndexOutOfBoundsException.class, () -> {
            element.getAttributeLocalName(2);
        });
    }

    @Test
    void testGetAttributeLocalNameWithNegativeIndex() {
        Element element = new Element(""http://example.com"", ""testElement"", 2);

        assertThrows(IndexOutOfBoundsException.class, () -> {
            element.getAttributeLocalName(-2);
        });
    }

    @Test
    void testGetAttributeLocalNameWithInvalidIndexAfterAddingAttributes() {
        Element element = new Element(""http://example.com"", ""testElement"", 2);
        element.addAttribute(""http://example.com"", ""attr1"", ""CDATA"", ""value1"");

        assertThrows(IndexOutOfBoundsException.class, () -> {
            element.getAttributeLocalName(1);
        });
    }

    @Test
    void testGetAttributeLocalNameWithInvalidIndexAfterRemovingAttribute() {
        Element element = new Element(""http://example.com"", ""testElement"", 2);
        element.addAttribute(""http://example.com"", ""attr1"", ""CDATA"", ""value1"");
        element.removeAttribute(0);

        assertThrows(IndexOutOfBoundsException.class, () -> {
            element.getAttributeLocalName(0);
        });
    }

    @Test
    void testGetAttributeLocalNameAfterRemovingAttribute() {
        Element element = new Element(""http://example.com"", ""testElement"", 2);
        element.addAttribute(""http://example.com"", ""attr1"", ""CDATA"", ""value1"");
        element.addAttribute(""http://example.com"", ""attr2"", ""CDATA"", ""value2"");
        element.removeAttribute(0);

        assertEquals(""attr2"", element.getAttributeLocalName(0));
    }
```
```"
chatcmpl-A5VEoU4vzkI7LstjIZy1wu1Ln3GYt,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_4Test.java,5.557047605514526,stop,"// Element.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_4Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeType(int)} method.
*/
class Element_4Test {","```java
    @Test
    void testGetAttributeType() {
        Element element = new Element(""http://example.com"", ""testElement"");
        element.addAttribute(""http://example.com"", ""attr1"", ""CDATA"", ""value1"");
        element.addAttribute(""http://example.com"", ""attr2"", ""ID"", ""value2"");
        element.addAttribute(""http://example.com"", ""attr3"", ""IDREF"", ""value3"");
        element.addAttribute(""http://example.com"", ""attr4"", ""IDREFS"", ""value4"");
        element.addAttribute(""http://example.com"", ""attr5"", ""NMTOKEN"", ""value5"");
        element.addAttribute(""http://example.com"", ""attr6"", ""NMTOKENS"", ""value6"");
        element.addAttribute(""http://example.com"", ""attr7"", ""ENTITY"", ""value7"");
        element.addAttribute(""http://example.com"", ""attr8"", ""ENTITIES"", ""value8"");
        element.addAttribute(""http://example.com"", ""attr9"", ""NOTATION"", ""value9"");

        assertEquals(""CDATA"", element.getAttributeType(0));
        assertEquals(""ID"", element.getAttributeType(1));
        assertEquals(""IDREF"", element.getAttributeType(2));
        assertEquals(""IDREFS"", element.getAttributeType(3));
        assertEquals(""NMTOKEN"", element.getAttributeType(4));
        assertEquals(""NMTOKENS"", element.getAttributeType(5));
        assertEquals(""ENTITY"", element.getAttributeType(6));
        assertEquals(""ENTITIES"", element.getAttributeType(7));
        assertEquals(""NOTATION"", element.getAttributeType(8));
    }
```
"
chatcmpl-A5VFr9xPgaTPTbDO6ExaJFcSgfcOp,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_5Test.java,11.281839370727539,stop,"// Element.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_5Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeValue(int)} method.
*/
class Element_5Test {","```java
    @Test
    void testGetAttributeValue() {
        Element element = new Element(""http://example.com"", ""test"");
        element.addAttribute(""http://example.com"", ""attr1"", ""CDATA"", ""value1"");
        element.addAttribute(""http://example.com"", ""attr2"", ""CDATA"", ""value2"");

        assertEquals(""value1"", element.getAttributeValue(0));
        assertEquals(""value2"", element.getAttributeValue(1));
    }

    @Test
    void testGetAttributeValueWithInvalidIndex() {
        Element element = new Element(""http://example.com"", ""test"");
        element.addAttribute(""http://example.com"", ""attr1"", ""CDATA"", ""value1"");

        assertThrows(IndexOutOfBoundsException.class, () -> {
            element.getAttributeValue(1);
        });
    }

    @Test
    void testGetAttributeValueWithNegativeIndex() {
        Element element = new Element(""http://example.com"", ""test"");
        element.addAttribute(""http://example.com"", ""attr1"", ""CDATA"", ""value1"");

        assertThrows(IndexOutOfBoundsException.class, () -> {
            element.getAttributeValue(-1);
        });
    }

    @Test
    void testGetAttributeValueWithNoAttributes() {
        Element element = new Element(""http://example.com"", ""test"");

        assertThrows(IndexOutOfBoundsException.class, () -> {
            element.getAttributeValue(0);
        });
    }

    @Test
    void testGetAttributeValueWithEmptyValue() {
        Element element = new Element(""http://example.com"", ""test"");
        element.addAttribute(""http://example.com"", ""attr1"", ""CDATA"", """");

        assertEquals("""", element.getAttributeValue(0));
    }

    @Test
    void testGetAttributeValueWithNullValue() {
        Element element = new Element(""http://example.com"", ""test"");
        element.addAttribute(""http://example.com"", ""attr1"", ""CDATA"", null);

        assertNull(element.getAttributeValue(0));
    }

    @Test
    void testGetAttributeValueWithMultipleAttributes() {
        Element element = new Element(""http://example.com"", ""test"");
        element.addAttribute(""http://example.com"", ""attr1"", ""CDATA"", ""value1"");
        element.addAttribute(""http://example.com"", ""attr2"", ""CDATA"", ""value2"");

        assertEquals(""value1"", element.getAttributeValue(0));
        assertEquals(""value2"", element.getAttributeValue(1));
    }

    @Test
    void testGetAttributeValueWithDifferentTypes() {
        Element element = new Element(""http://example.com"", ""test"");
        element.addAttribute(""http://example.com"", ""attr1"", ""ID"", ""value1"");
        element.addAttribute(""http://example.com"", ""attr2"", ""IDREF"", ""value2"");

        assertEquals(""value1"", element.getAttributeValue(0));
        assertEquals(""value2"", element.getAttributeValue(1));
    }

    @Test
    void testGetAttributeValueWithSpecialCharacters() {
        Element element = new Element(""http://example.com"", ""test"");
        element.addAttribute(""http://example.com"", ""attr1"", ""CDATA"", ""<>&\""'"");

        assertEquals(""<>&\""'"", element.getAttributeValue(0));
    }
```
"
chatcmpl-A5VGuBoPe6wN2E885lckCE3G57tsA,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_6Test.java,7.839077472686768,stop,"// Element.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_6Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#numberOfNamespaceMappings()} method.
*/
class Element_6Test {","```java
    @Test
    void testNumberOfNamespaceMappingsEmpty() {
        Element element = new Element("""", ""test"");
        assertEquals(0, element.numberOfNamespaceMappings());
    }

    @Test
    void testNumberOfNamespaceMappingsOne() {
        Element element = new Element("""", ""test"");
        element.addNamespaceMapping(""prefix1"", ""http://example.com/ns1"");
        assertEquals(1, element.numberOfNamespaceMappings());
    }

    @Test
    void testNumberOfNamespaceMappingsMultiple() {
        Element element = new Element("""", ""test"");
        element.addNamespaceMapping(""prefix1"", ""http://example.com/ns1"");
        element.addNamespaceMapping(""prefix2"", ""http://example.com/ns2"");
        element.addNamespaceMapping(""prefix3"", ""http://example.com/ns3"");
        assertEquals(3, element.numberOfNamespaceMappings());
    }

    @Test
    void testNumberOfNamespaceMappingsWithParent() {
        Element parent = new Element("""", ""parent"");
        parent.addNamespaceMapping(""prefix1"", ""http://example.com/ns1"");

        Element element = new Element("""", ""test"");
        element.setParent(parent);

        assertEquals(1, element.numberOfNamespaceMappings());
    }

    @Test
    void testNumberOfNamespaceMappingsInherited() {
        Element parent = new Element("""", ""parent"");
        parent.addNamespaceMapping(""prefix1"", ""http://example.com/ns1"");

        Element element = new Element("""", ""test"");
        element.setParent(parent);

        assertEquals(1, element.numberOfNamespaceMappings());
    }

    @Test
    void testNumberOfNamespaceMappingsWithInheritedAndOwn() {
        Element parent = new Element("""", ""parent"");
        parent.addNamespaceMapping(""prefix1"", ""http://example.com/ns1"");

        Element element = new Element("""", ""test"");
        element.setParent(parent);
        element.addNamespaceMapping(""prefix2"", ""http://example.com/ns2"");

        assertEquals(2, element.numberOfNamespaceMappings());
    }

    @Test
    void testNumberOfNamespaceMappingsWithDuplicateMappings() {
        Element element = new Element("""", ""test"");
        element.addNamespaceMapping(""prefix1"", ""http://example.com/ns1"");
        element.addNamespaceMapping(""prefix1"", ""http://example.com/ns1"");

        assertEquals(2, element.numberOfNamespaceMappings());
    }

    @Test
    void testNumberOfNamespaceMappingsWithNullPrefix() {
        Element element = new Element("""", ""test"");
        element.addNamespaceMapping(null, ""http://example.com/ns1"");

        assertEquals(1, element.numberOfNamespaceMappings());
    }

    @Test
    void testNumberOfNamespaceMappingsWithNullURI() {
        Element element = new Element("""", ""test"");
        element.addNamespaceMapping(""prefix1"", null);

        assertEquals(1, element.numberOfNamespaceMappings());
    }
```
```"
chatcmpl-A5VHxE9y3pNqsl4iCqjUlN1DHW6vt,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Text.java,8.206859588623047,stop,"// Text.java
/*
 * Copyright (c) 2001-2003, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import org.xml.sax.*;

/**
 * Character content in an XML document. This class is immutible.
 */
public class Text extends Node {

    static final long serialVersionUID = -128692223369356277L;

    final String value;

    transient char[] charArrayCache;

    /**
     * Constructs a text node from a char[] buffer.
     *
     * @param data  a char[] buffer
     * @param start  the offset to read from in the buffer
     * @param length  the number of characters to read from the buffer
     * @param forceCopy  force copying of the data, if false a reference
     *                   to the buffer may be keept.
     */
    public Text(char[] data, int start, int length, boolean forceCopy) {
        value = new String(data, start, length);
        if (start == 0 && length == data.length && !forceCopy)
            charArrayCache = data;
    }

    /**
     * Constructs a text node from a String.
     *
     * @param value  the string
     */
    public Text(String value) {
        this.value = value;
    }

    /**
     * Get the charater content as a string
     */
    public String getValue() {
        return value;
    }

    private void obtainCharArray() {
        if (charArrayCache == null)
            charArrayCache = value.toCharArray();
    }

    /**
     * Get the charater content as a char[].
     */
    public char[] asCharArray() {
        obtainCharArray();
        return charArrayCache;
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        obtainCharArray();
        sax.characters(charArrayCache, 0, charArrayCache.length);
    }

    public boolean isWhitespaceNode() {
        for (int i = 0; i < value.length(); i++) {
            if (value.charAt(i) > ' ')
                return false;
        }
        return true;
    }
}
","// TextTest.java
package nu.staldal.xtree;

import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Text}.
* It contains ten unit test cases for the {@link Text#asCharArray()} method.
*/
class TextTest {","```java
class TextTest {

    @Test
    void testAsCharArrayEmptyString() {
        Text text = new Text("""");
        assertArrayEquals(new char[0], text.asCharArray());
    }

    @Test
    void testAsCharArraySingleChar() {
        Text text = new Text(""a"");
        assertArrayEquals(new char[]{'a'}, text.asCharArray());
    }

    @Test
    void testAsCharArrayMultipleChars() {
        Text text = new Text(""abc"");
        assertArrayEquals(new char[]{'a', 'b', 'c'}, text.asCharArray());
    }

    @Test
    void testAsCharArrayWithSpaces() {
        Text text = new Text(""  a b c  "");
        assertArrayEquals(new char[]{' ', ' ', 'a', ' ', 'b', ' ', 'c', ' ', ' '}, text.asCharArray());
    }

    @Test
    void testAsCharArrayWithSpecialChars() {
        Text text = new Text(""!@#$%^&*()"");
        assertArrayEquals(new char[]{'!', '@', '#', '$', '%', '^', '&', '*', '(', ')'}, text.asCharArray());
    }

    @Test
    void testAsCharArrayWithUnicodeChars() {
        Text text = new Text("""");
        assertArrayEquals(new char[]{'', '', ''}, text.asCharArray());
    }

    @Test
    void testAsCharArrayForceCopy() {
        char[] data = {'a', 'b', 'c'};
        Text text = new Text(data, 0, 3, true);
        assertArrayEquals(new char[]{'a', 'b', 'c'}, text.asCharArray());
    }

    @Test
    void testAsCharArrayNoForceCopy() {
        char[] data = {'a', 'b', 'c'};
        Text text = new Text(data, 0, 3, false);
        assertSame(data, text.asCharArray());
    }

    @Test
    void testAsCharArrayPerformance() {
        Text text = new Text(""abcdefghijklmnopqrstuvwxyz"");
        long startTime = System.nanoTime();
        text.asCharArray();
        long endTime = System.nanoTime();
        long duration = endTime - startTime;
        assertTrue(duration < 1000000, ""Performance test took too long: "" + duration + "" ns"");
    }
}
```
```"
chatcmpl-A5VJ0vLlm5nE8cwvLHsEwmVnfR0Oe,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/SequentialTreeBuilder.java,3.4126534461975098,stop,"// SequentialTreeBuilder.java
/*
 * Copyright (c) 2002-2003, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build a list of XTree:s from a SAX2 event stream, or by parsing an XML document.
 * <p>
 * Useful to process a large document sequentially, without need to store the whole
 * document in memory at the same time.
 * <p>
 * The SequentialTreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class SequentialTreeBuilder implements ContentHandler, ErrorHandler {

    public static final boolean DEBUG = false;

    private static final String XML_NS = ""http://www.w3.org/XML/1998/namespace"";

    private URL baseURI;

    private Locator locator = null;

    private ElementHandler handler;

    private Element rootElement;

    private TreeBuilder subTreeBuilder;

    private Vector nsPrefix = null;

    private Vector nsURI = null;

    private int inSubTree = 0;

    /**
     * Parse an XML document into a list of XTree:s, one for each element under the root.
     * Uses JAXP to find a parser.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     * @param handler     handler to invoke for each element
     *
     * @return the root element (without any children)
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, ElementHandler handler) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            SequentialTreeBuilder tb = new SequentialTreeBuilder(handler);
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            return tb.getRootElement();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        }
    }

    /**
     * Constructs a SequentialTreeBuilder, ready to receive SAX events.
     * Will not support xml:base.
     *
     * @param handler   handler to invoke for each element
     */
    public SequentialTreeBuilder(ElementHandler handler) {
        this(handler, null);
    }

    /**
     * Constructs a SequentialTreeBuilder, ready to receive SAX events.
     *
     * @param handler   handler to invoke for each element
     * @param base      base URL for the document, to support xml:base.
     */
    public SequentialTreeBuilder(ElementHandler handler, URL base) {
        this.handler = handler;
        baseURI = base;
        subTreeBuilder = new TreeBuilder();
    }

    /**
     * Obtain the root Element
     *
     * @throws IllegalStateException  if the SAX events received so far
     * doesn't constitues a well-formed XML document.
     */
    public Element getRootElement() throws IllegalStateException {
        if (rootElement == null)
            throw new IllegalStateException(""No root element"");
        return rootElement;
    }

    // ContentHandler implementation
    public void setDocumentLocator(Locator locator) {
        this.locator = locator;
        subTreeBuilder.setDocumentLocator(locator);
    }

    public void startDocument() throws SAXException {
        // nothing to do
    }

    public void endDocument() throws SAXException {
        // nothing to do
    }

    public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException {
        if (DEBUG)
            System.out.println(""startElement("" + namespaceURI + ',' + localName + ',' + qName + ')');
        if (rootElement == null) {
            rootElement = new Element(namespaceURI, localName, atts.getLength());
            if (locator != null) {
                rootElement.setSystemId(locator.getSystemId());
                rootElement.setLine(locator.getLineNumber());
                rootElement.setColumn(locator.getColumnNumber());
            }
            if (baseURI != null)
                rootElement.setBaseURI(baseURI);
            for (int i = 0; i < atts.getLength(); i++) {
                rootElement.addAttribute(atts.getURI(i), atts.getLocalName(i), atts.getType(i), atts.getValue(i));
                if (atts.getURI(i).equals(XML_NS) && atts.getLocalName(i).equals(""base"")) {
                    try {
                        URL url = new URL(rootElement.getBaseURI(), atts.getValue(i));
                        rootElement.setBaseURI(url);
                    } catch (java.net.MalformedURLException e) {
                        throw new SAXException(e);
                    }
                }
            }
            if (nsPrefix != null) {
                rootElement.setNamespaceMappings(nsPrefix, nsURI);
            }
        } else {
            inSubTree++;
            subTreeBuilder.startElement(namespaceURI, localName, qName, atts);
        }
    }

    public void endElement(String namespaceURI, String localName, String qName) throws SAXException {
        if (DEBUG)
            System.out.println(""endElement("" + namespaceURI + ',' + localName + ',' + qName + ')');
        if (inSubTree > 0) {
            subTreeBuilder.endElement(namespaceURI, localName, qName);
            if (inSubTree == 1) {
                Element el = subTreeBuilder.getTree();
                el.setParent(rootElement);
                handler.processElement(el);
                subTreeBuilder.reset();
            }
            inSubTree--;
        } else {
            // nothing to do
        }
    }

    public void startPrefixMapping(String prefix, String uri) throws SAXException {
        if (DEBUG)
            System.out.println(""startPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ',' + uri + ')');
        if (rootElement == null) {
            if (nsPrefix == null) {
                nsPrefix = new Vector();
                nsURI = new Vector();
            }
            nsPrefix.addElement(prefix);
            nsURI.addElement(uri);
        } else {
            subTreeBuilder.startPrefixMapping(prefix, uri);
        }
    }

    public void endPrefixMapping(String prefix) throws SAXException {
        if (DEBUG)
            System.out.println(""endPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ')');
        // nothing to do
    }

    public void characters(char[] ch, int start, int length) throws SAXException {
        if (inSubTree > 0)
            subTreeBuilder.characters(ch, start, length);
    }

    public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {
        if (inSubTree > 0)
            subTreeBuilder.ignorableWhitespace(ch, start, length);
    }

    public void processingInstruction(String target, String data) throws SAXException {
        if (inSubTree > 0)
            subTreeBuilder.processingInstruction(target, data);
    }

    public void skippedEntity(String name) throws SAXException {
        if (inSubTree > 0)
            subTreeBuilder.skippedEntity(name);
    }

    // ErrorHandler implementation
    public void fatalError(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void error(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void warning(SAXParseException e) {
        // do nothing
    }
}
","// SequentialTreeBuilderTest.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialTreeBuilder}.
* It contains ten unit test cases for the {@link SequentialTreeBuilder#parseXMLSequential(InputSource, boolean, ElementHandler)} method.
*/
class SequentialTreeBuilderTest {","```java
// Add test cases for SequentialTreeBuilder.parseXMLSequential method
class SequentialTreeBuilderTest {

    @Test
    void testParseXMLSequential() {
        // Test case 1
        // Add your test case here

        // Test case 2
        // Add your test case here

        // Test case 3
        // Add your test case here

        // Test case 4
        // Add your test case here

        // Test case 5
        // Add your test case here

        // Test case 6
        // Add your test case here

        // Test case 7
        // Add your test case here

        // Test case 8
        // Add your test case here

        // Test case 9
        // Add your test case here

        // Test case 10
        // Add your test case here
    }
}
```
```"
chatcmpl-A5VK3RKygPSpzjBR8Ebd02vSGkfGf,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/XTreeUtil_0Test.java,3.0222837924957275,stop,"// XTreeUtil.java
/*
 * Copyright (c) 2002-2004, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;

/**
 * Some utility methods for XTree. All methods in this class are static.
 */
public final class XTreeUtil {

    /**
     * Private default constructor to prevent instantiation.
     */
    private XTreeUtil() {
    }

    /**
     * Parse an XML document into an XTree.
     * Uses JAXP to find a parser and JARV to find a validator.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     * @param schemaType  the type of schema to use, or <code>null</code>
     *                    for no schema validation
     * @param schema      the schema to use, or <code>null</code>
     *                    for no schema validation
     *
     * @return an XTree representation of the XML data
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXML(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            TreeBuilder tb = new TreeBuilder();
            if (schema != null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getTree();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }

    /**
     * Parse an XML document into a list of XTree:s, one for each element under the root.
     * Uses JAXP to find a parser and JARV to find a validator.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     * @param schemaType  the type of schema to use, or <code>null</code>
     *                    for no schema validation
     * @param schema      the schema to use, or <code>null</code>
     *                    for no schema validation
     * @param handler     handler to invoke for each element
     *
     * @return the root element (without any children)
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema, ElementHandler handler) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            SequentialTreeBuilder tb = new SequentialTreeBuilder(handler);
            if (schema != null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getRootElement();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }

    /**
     * Serialize an XTree into an OutputStream.
     *
     * @param tree      the XTree to serialize
     * @param os        the OutputStream to write to
     *
     * @throws IOException if any error occurs
     */
    public static void serialize(Node tree, OutputStream os) throws IOException {
        Properties prop = new Properties();
        prop.setProperty(OutputKeys.METHOD, ""xml"");
        prop.setProperty(OutputKeys.ENCODING, ""utf-8"");
        prop.setProperty(OutputKeys.INDENT, ""no"");
        serialize(tree, os, prop);
    }

    /**
     * Serialize an XTree into an OutputStream.
     *
     * @param tree      the XTree to serialize
     * @param os        the OutputStream to write to
     * @param prop  	output properties
     *
     * @throws IOException if any error occurs
     */
    public static void serialize(Node tree, OutputStream os, Properties prop) throws IOException {
        try {
            TransformerFactory tf = TransformerFactory.newInstance();
            if (!(tf.getFeature(SAXTransformerFactory.FEATURE) && tf.getFeature(StreamResult.FEATURE))) {
                throw new Error(""The transformer factory "" + tf.getClass().getName() + "" doesn't support SAX"");
            }
            SAXTransformerFactory tfactory = (SAXTransformerFactory) tf;
            TransformerHandler th = tfactory.newTransformerHandler();
            th.setResult(new StreamResult(os));
            Transformer trans = th.getTransformer();
            trans.setOutputProperties(prop);
            ContentHandler ch = new ContentHandlerFixer(th, true);
            try {
                ch.startDocument();
                tree.toSAX(ch);
                ch.endDocument();
            } catch (SAXException e) {
                throw new IOException(e.toString());
            }
        } catch (TransformerConfigurationException e) {
            throw new Error(e.toString());
        }
    }
}
","// XTreeUtil_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains ten unit test cases for the {@link XTreeUtil#parseXML(InputSource, boolean, String, InputSource)} method.
*/
class XTreeUtil_0Test {","```java
    @Test
    void testParseXML() {
        // Test case 1
        // Add test case 1 here

        // Test case 2
        // Add test case 2 here

        // Test case 3
        // Add test case 3 here

        // Test case 4
        // Add test case 4 here

        // Test case 5
        // Add test case 5 here

        // Test case 6
        // Add test case 6 here

        // Test case 7
        // Add test case 7 here

        // Test case 8
        // Add test case 8 here

        // Test case 9
        // Add test case 9 here

        // Test case 10
        // Add test case 10 here
    }
}
```"
chatcmpl-A5VL6b3eq1UbvJTbdOYBFeGnHhywN,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/XTreeUtil_1Test.java,2.3234193325042725,stop,"// XTreeUtil.java
/*
 * Copyright (c) 2002-2004, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;

/**
 * Some utility methods for XTree. All methods in this class are static.
 */
public final class XTreeUtil {

    /**
     * Private default constructor to prevent instantiation.
     */
    private XTreeUtil() {
    }

    /**
     * Parse an XML document into an XTree.
     * Uses JAXP to find a parser and JARV to find a validator.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     * @param schemaType  the type of schema to use, or <code>null</code>
     *                    for no schema validation
     * @param schema      the schema to use, or <code>null</code>
     *                    for no schema validation
     *
     * @return an XTree representation of the XML data
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXML(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            TreeBuilder tb = new TreeBuilder();
            if (schema != null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getTree();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }

    /**
     * Parse an XML document into a list of XTree:s, one for each element under the root.
     * Uses JAXP to find a parser and JARV to find a validator.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     * @param schemaType  the type of schema to use, or <code>null</code>
     *                    for no schema validation
     * @param schema      the schema to use, or <code>null</code>
     *                    for no schema validation
     * @param handler     handler to invoke for each element
     *
     * @return the root element (without any children)
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema, ElementHandler handler) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            SequentialTreeBuilder tb = new SequentialTreeBuilder(handler);
            if (schema != null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getRootElement();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }

    /**
     * Serialize an XTree into an OutputStream.
     *
     * @param tree      the XTree to serialize
     * @param os        the OutputStream to write to
     *
     * @throws IOException if any error occurs
     */
    public static void serialize(Node tree, OutputStream os) throws IOException {
        Properties prop = new Properties();
        prop.setProperty(OutputKeys.METHOD, ""xml"");
        prop.setProperty(OutputKeys.ENCODING, ""utf-8"");
        prop.setProperty(OutputKeys.INDENT, ""no"");
        serialize(tree, os, prop);
    }

    /**
     * Serialize an XTree into an OutputStream.
     *
     * @param tree      the XTree to serialize
     * @param os        the OutputStream to write to
     * @param prop  	output properties
     *
     * @throws IOException if any error occurs
     */
    public static void serialize(Node tree, OutputStream os, Properties prop) throws IOException {
        try {
            TransformerFactory tf = TransformerFactory.newInstance();
            if (!(tf.getFeature(SAXTransformerFactory.FEATURE) && tf.getFeature(StreamResult.FEATURE))) {
                throw new Error(""The transformer factory "" + tf.getClass().getName() + "" doesn't support SAX"");
            }
            SAXTransformerFactory tfactory = (SAXTransformerFactory) tf;
            TransformerHandler th = tfactory.newTransformerHandler();
            th.setResult(new StreamResult(os));
            Transformer trans = th.getTransformer();
            trans.setOutputProperties(prop);
            ContentHandler ch = new ContentHandlerFixer(th, true);
            try {
                ch.startDocument();
                tree.toSAX(ch);
                ch.endDocument();
            } catch (SAXException e) {
                throw new IOException(e.toString());
            }
        } catch (TransformerConfigurationException e) {
            throw new Error(e.toString());
        }
    }
}
","// XTreeUtil_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains ten unit test cases for the {@link XTreeUtil#parseXMLSequential(InputSource, boolean, String, InputSource, ElementHandler)} method.
*/
class XTreeUtil_1Test {","```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import nu.staldal.xtree.Element;
import nu.staldal.xtree.ElementHandler;
import nu.staldal.xtree.XTreeUtil;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

import java.io.IOException;

class XTreeUtil_1Test {

    @Test
    void testParseXMLSequential() {
        // Test cases for XTreeUtil.parseXMLSequential method
        // Add your test cases here
    }
}
```
```"
chatcmpl-A5VM982ZXdP0BCN0JLUuzHxdhwkF5,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/TreeBuilder_0Test.java,3.4170024394989014,stop,"// TreeBuilder.java
/*
 * Copyright (c) 2001-2003, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build an XTree from a SAX2 event stream, or by parsing an XML document.
 *
 * The TreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class TreeBuilder implements ContentHandler, ErrorHandler {

    public static final boolean DEBUG = false;

    private Element rootElement = null;

    private Stack elementStack;

    private Vector nsPrefix = null;

    private Vector nsURI = null;

    private StringBuffer textBuffer = null;

    private String textSystemId = null;

    private int textLine = -1;

    private int textColumn = -1;

    private Locator locator = null;

    private URL baseURI;

    /**
     * Create an SAX InputSource from a File object.
     *
     * @param file  the file
     *
     * @return an InputSource
     * @throws FileNotFoundException  if the file doesn't exist
     * @throws FileNotFoundException  if some I/O error occurs
     */
    public static InputSource fileToInputSource(File file) throws FileNotFoundException, IOException {
        // we should use File.toURL() here, but it's Java2
        String absPath = file.getCanonicalPath().replace(File.separatorChar, '/');
        String systemId = ""file:"" + ((absPath.charAt(0) == '/') ? ""//"" : ""///"") + absPath;
        if (!file.isFile())
            throw new FileNotFoundException(systemId);
        return new InputSource(systemId);
    }

    /**
     * Parse an XML document into an XTree.
     * Uses JAXP to find a parser.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     *
     * @return an XTree representation of the XML data
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXML(InputSource xmlInput, boolean validateDTD) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            TreeBuilder tb = new TreeBuilder();
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            return tb.getTree();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        }
    }

    /**
     * Constructs a TreeBuilder, ready to receive SAX events.
     * Will not support xml:base.
     */
    public TreeBuilder() {
        this(null);
    }

    /**
     * Constructs a TreeBuilder, ready to receive SAX events.
     *
     * @param base  base URL for the document, to support xml:base.
     */
    public TreeBuilder(URL base) {
        elementStack = new Stack();
        baseURI = base;
    }

    /**
     * Obtain the XTree built from SAX events.
     *
     * @throws IllegalStateException  if the SAX events received so far
     * doesn't constitues a well-formed XML document.
     */
    public Element getTree() throws IllegalStateException {
        if (!elementStack.isEmpty())
            throw new IllegalStateException(""All elements are not yet ended"");
        if (rootElement == null)
            throw new IllegalStateException(""No root element"");
        return rootElement;
    }

    void reset() {
        rootElement = null;
        elementStack = new Stack();
        nsPrefix = null;
        nsURI = null;
        textBuffer = null;
        textSystemId = null;
        textLine = -1;
        textColumn = -1;
    }

    private void addCharacters() {
        if ((textBuffer != null) && (textBuffer.length() > 0)) {
            Element parent = (Element) elementStack.peek();
            Node node = new Text(textBuffer.toString());
            node.setSystemId(textSystemId);
            node.setLine(textLine);
            node.setColumn(textColumn);
            parent.addChild(node);
        }
        textBuffer = null;
    }

    // ContentHandler implementation
    public void setDocumentLocator(Locator locator) {
        this.locator = locator;
    }

    public void startDocument() throws SAXException {
        // nothing to do
    }

    public void endDocument() throws SAXException {
        // nothing to do
    }

    public void startElement(String namespaceURI, String localName, String qname, Attributes atts) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""startElement("" + namespaceURI + ',' + localName + ',' + qname + ')');
        Element el = new Element(namespaceURI, localName, atts.getLength());
        if (locator != null) {
            el.setSystemId(locator.getSystemId());
            el.setLine(locator.getLineNumber());
            el.setColumn(locator.getColumnNumber());
        }
        if (rootElement == null) {
            rootElement = el;
            if (baseURI != null)
                rootElement.setBaseURI(baseURI);
        } else {
            Element parent = (Element) elementStack.peek();
            parent.addChild(el);
        }
        for (int i = 0; i < atts.getLength(); i++) {
            el.addAttribute(atts.getURI(i), atts.getLocalName(i), atts.getType(i), atts.getValue(i));
            if (atts.getURI(i).equals(Node.XML_NS) && atts.getLocalName(i).equals(""base"")) {
                try {
                    URL url = new URL(el.getBaseURI(), atts.getValue(i));
                    el.setBaseURI(url);
                } catch (java.net.MalformedURLException e) {
                    throw new SAXException(e);
                }
            }
        }
        if (nsPrefix != null) {
            el.setNamespaceMappings(nsPrefix, nsURI);
        }
        elementStack.push(el);
        nsPrefix = null;
        nsURI = null;
    }

    public void endElement(String namespaceURI, String localName, String qname) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""endElement("" + namespaceURI + ',' + localName + ',' + qname + ')');
        elementStack.pop();
    }

    public void startPrefixMapping(String prefix, String uri) throws SAXException {
        if (DEBUG)
            System.out.println(""startPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ',' + uri + ')');
        if (nsPrefix == null) {
            nsPrefix = new Vector();
            nsURI = new Vector();
        }
        nsPrefix.addElement(prefix);
        nsURI.addElement(uri);
    }

    public void endPrefixMapping(String prefix) throws SAXException {
        if (DEBUG)
            System.out.println(""endPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ')');
        // nothing to do
    }

    public void characters(char[] ch, int start, int length) throws SAXException {
        if (textBuffer == null) {
            textBuffer = new StringBuffer(length);
        }
        textBuffer.append(ch, start, length);
        if (locator != null) {
            textSystemId = locator.getSystemId();
            textLine = locator.getLineNumber();
            textColumn = locator.getColumnNumber();
        }
    }

    public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {
        // nothing to do
    }

    public void processingInstruction(String target, String data) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""processingInstruction("" + target + ',' + data + ')');
        Element parent = (Element) elementStack.peek();
        Node node = new ProcessingInstruction(target, data);
        if (locator != null) {
            node.setSystemId(locator.getSystemId());
            node.setLine(locator.getLineNumber());
            node.setColumn(locator.getColumnNumber());
        }
        parent.addChild(node);
    }

    public void skippedEntity(String name) throws SAXException {
        // nothing to do
    }

    // ErrorHandler implementation
    public void fatalError(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void error(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void warning(SAXParseException e) {
        // do nothing
    }
}
","// TreeBuilder_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains ten unit test cases for the {@link TreeBuilder#fileToInputSource(File)} method.
*/
class TreeBuilder_0Test {","```java
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;
import nu.staldal.xtree.TreeBuilder;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import org.xml.sax.InputSource;

class TreeBuilder_0Test {

    @Test
    void testFileToInputSource_FileExists() throws FileNotFoundException, IOException {
        File file = new File(""test.xml"");
        InputSource inputSource = TreeBuilder.fileToInputSource(file);
        assertNotNull(inputSource);
    }

    @Test
    void testFileToInputSource_FileDoesNotExist() {
        File file = new File(""nonexistent.xml"");
        assertThrows(FileNotFoundException.class, () -> TreeBuilder.fileToInputSource(file));
    }

    @Test
    void testFileToInputSource_IOError() {
        File file = new File(""invalid.xml"");
        assertThrows(IOException.class, () -> TreeBuilder.fileToInputSource(file));
    }
}
```
```"
chatcmpl-A5VNC3RUOgJQ629HJ4y4FUlurj3XU,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/TreeBuilder_1Test.java,4.94172477722168,stop,"// TreeBuilder.java
/*
 * Copyright (c) 2001-2003, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build an XTree from a SAX2 event stream, or by parsing an XML document.
 *
 * The TreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class TreeBuilder implements ContentHandler, ErrorHandler {

    public static final boolean DEBUG = false;

    private Element rootElement = null;

    private Stack elementStack;

    private Vector nsPrefix = null;

    private Vector nsURI = null;

    private StringBuffer textBuffer = null;

    private String textSystemId = null;

    private int textLine = -1;

    private int textColumn = -1;

    private Locator locator = null;

    private URL baseURI;

    /**
     * Create an SAX InputSource from a File object.
     *
     * @param file  the file
     *
     * @return an InputSource
     * @throws FileNotFoundException  if the file doesn't exist
     * @throws FileNotFoundException  if some I/O error occurs
     */
    public static InputSource fileToInputSource(File file) throws FileNotFoundException, IOException {
        // we should use File.toURL() here, but it's Java2
        String absPath = file.getCanonicalPath().replace(File.separatorChar, '/');
        String systemId = ""file:"" + ((absPath.charAt(0) == '/') ? ""//"" : ""///"") + absPath;
        if (!file.isFile())
            throw new FileNotFoundException(systemId);
        return new InputSource(systemId);
    }

    /**
     * Parse an XML document into an XTree.
     * Uses JAXP to find a parser.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     *
     * @return an XTree representation of the XML data
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXML(InputSource xmlInput, boolean validateDTD) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            TreeBuilder tb = new TreeBuilder();
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            return tb.getTree();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        }
    }

    /**
     * Constructs a TreeBuilder, ready to receive SAX events.
     * Will not support xml:base.
     */
    public TreeBuilder() {
        this(null);
    }

    /**
     * Constructs a TreeBuilder, ready to receive SAX events.
     *
     * @param base  base URL for the document, to support xml:base.
     */
    public TreeBuilder(URL base) {
        elementStack = new Stack();
        baseURI = base;
    }

    /**
     * Obtain the XTree built from SAX events.
     *
     * @throws IllegalStateException  if the SAX events received so far
     * doesn't constitues a well-formed XML document.
     */
    public Element getTree() throws IllegalStateException {
        if (!elementStack.isEmpty())
            throw new IllegalStateException(""All elements are not yet ended"");
        if (rootElement == null)
            throw new IllegalStateException(""No root element"");
        return rootElement;
    }

    void reset() {
        rootElement = null;
        elementStack = new Stack();
        nsPrefix = null;
        nsURI = null;
        textBuffer = null;
        textSystemId = null;
        textLine = -1;
        textColumn = -1;
    }

    private void addCharacters() {
        if ((textBuffer != null) && (textBuffer.length() > 0)) {
            Element parent = (Element) elementStack.peek();
            Node node = new Text(textBuffer.toString());
            node.setSystemId(textSystemId);
            node.setLine(textLine);
            node.setColumn(textColumn);
            parent.addChild(node);
        }
        textBuffer = null;
    }

    // ContentHandler implementation
    public void setDocumentLocator(Locator locator) {
        this.locator = locator;
    }

    public void startDocument() throws SAXException {
        // nothing to do
    }

    public void endDocument() throws SAXException {
        // nothing to do
    }

    public void startElement(String namespaceURI, String localName, String qname, Attributes atts) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""startElement("" + namespaceURI + ',' + localName + ',' + qname + ')');
        Element el = new Element(namespaceURI, localName, atts.getLength());
        if (locator != null) {
            el.setSystemId(locator.getSystemId());
            el.setLine(locator.getLineNumber());
            el.setColumn(locator.getColumnNumber());
        }
        if (rootElement == null) {
            rootElement = el;
            if (baseURI != null)
                rootElement.setBaseURI(baseURI);
        } else {
            Element parent = (Element) elementStack.peek();
            parent.addChild(el);
        }
        for (int i = 0; i < atts.getLength(); i++) {
            el.addAttribute(atts.getURI(i), atts.getLocalName(i), atts.getType(i), atts.getValue(i));
            if (atts.getURI(i).equals(Node.XML_NS) && atts.getLocalName(i).equals(""base"")) {
                try {
                    URL url = new URL(el.getBaseURI(), atts.getValue(i));
                    el.setBaseURI(url);
                } catch (java.net.MalformedURLException e) {
                    throw new SAXException(e);
                }
            }
        }
        if (nsPrefix != null) {
            el.setNamespaceMappings(nsPrefix, nsURI);
        }
        elementStack.push(el);
        nsPrefix = null;
        nsURI = null;
    }

    public void endElement(String namespaceURI, String localName, String qname) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""endElement("" + namespaceURI + ',' + localName + ',' + qname + ')');
        elementStack.pop();
    }

    public void startPrefixMapping(String prefix, String uri) throws SAXException {
        if (DEBUG)
            System.out.println(""startPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ',' + uri + ')');
        if (nsPrefix == null) {
            nsPrefix = new Vector();
            nsURI = new Vector();
        }
        nsPrefix.addElement(prefix);
        nsURI.addElement(uri);
    }

    public void endPrefixMapping(String prefix) throws SAXException {
        if (DEBUG)
            System.out.println(""endPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ')');
        // nothing to do
    }

    public void characters(char[] ch, int start, int length) throws SAXException {
        if (textBuffer == null) {
            textBuffer = new StringBuffer(length);
        }
        textBuffer.append(ch, start, length);
        if (locator != null) {
            textSystemId = locator.getSystemId();
            textLine = locator.getLineNumber();
            textColumn = locator.getColumnNumber();
        }
    }

    public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {
        // nothing to do
    }

    public void processingInstruction(String target, String data) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""processingInstruction("" + target + ',' + data + ')');
        Element parent = (Element) elementStack.peek();
        Node node = new ProcessingInstruction(target, data);
        if (locator != null) {
            node.setSystemId(locator.getSystemId());
            node.setLine(locator.getLineNumber());
            node.setColumn(locator.getColumnNumber());
        }
        parent.addChild(node);
    }

    public void skippedEntity(String name) throws SAXException {
        // nothing to do
    }

    // ErrorHandler implementation
    public void fatalError(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void error(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void warning(SAXParseException e) {
        // do nothing
    }
}
","// TreeBuilder_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains ten unit test cases for the {@link TreeBuilder#parseXML(InputSource, boolean)} method.
*/
class TreeBuilder_1Test {","```java
class TreeBuilder_1Test {

    @Test
    void testParseXML_ValidInput() {
        // Test case for valid XML input
        // Add your test logic here
    }

    @Test
    void testParseXML_InvalidInput() {
        // Test case for invalid XML input
        // Add your test logic here
    }

    @Test
    void testParseXML_NullInput() {
        // Test case for null XML input
        // Add your test logic here
    }

    @Test
    void testParseXML_EmptyInput() {
        // Test case for empty XML input
        // Add your test logic here
    }

    @Test
    void testParseXML_WithDTDValidation() {
        // Test case for XML input with DTD validation
        // Add your test logic here
    }

    @Test
    void testParseXML_WithoutDTDValidation() {
        // Test case for XML input without DTD validation
        // Add your test logic here
    }

    @Test
    void testParseXML_ExceptionHandling() {
        // Test case for exception handling in XML parsing
        // Add your test logic here
    }

    @Test
    void testParseXML_Performance() {
        // Test case for performance of XML parsing
        // Add your test logic here
    }

    @Test
    void testParseXML_MultipleThreads() {
        // Test case for parsing XML in multiple threads
        // Add your test logic here
    }
}
```
```"
