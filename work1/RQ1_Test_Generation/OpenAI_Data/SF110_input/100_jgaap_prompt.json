[
  {
    "numberTests": "ten",
    "original_code": "// EventSet.java\nimport java.util.Vector;\nimport java.util.List;\n\npublic class EventSet {\n\n    Vector\u003cEvent\u003e events \u003d new Vector\u003cEvent\u003e();\n\n    private String author;\n\n    public String getAuthor() {\n        return author;\n    }\n\n    /**\n     * Sets the author of the current event set.\n     *  There should be a better way to pass authors through the\n     *  processing stages...\n     */\n    public void setAuthor(String author) {\n        this.author \u003d author;\n    }\n\n    /**\n     * Creates a new, empty list of events*\n     */\n    public EventSet() {\n        this.events \u003d new Vector\u003cEvent\u003e();\n    }\n\n    /**\n     * Creates a new list of events given a previously created list of events*\n     */\n    public EventSet(List\u003cEvent\u003e evts) {\n        this.events \u003d new Vector\u003cEvent\u003e(evts);\n    }\n\n    /**\n     * Returns a subset of events given a starting index of an event and the\n     *  number of events wanted in the returned list.\n     *  TODO: Array bounds checking, if length is longer than the size of the list\n     */\n    public EventSet subset(int start, int length) {\n        return new EventSet(events.subList(start, length));\n    }\n\n    /**\n     * Returns the event at a given index*\n     */\n    public Event eventAt(int index) {\n        return events.get(index);\n    }\n\n    /**\n     * Returns the total number of events in the set*\n     */\n    public int size() {\n        return events.size();\n    }\n\n    /**\n     * Returns the string representation of this event set, which is just a\n     *  comma separated list of each individual event\n     */\n    public String toString() {\n        String t \u003d new String();\n        for (int i \u003d 0; i \u003c events.size(); i++) t +\u003d events.elementAt(i) + \", \";\n        return t;\n    }\n}\n",
    "package": "",
    "classname": "EventSet",
    "id": "/EvoSuiteBenchmark/original/100_jgaap/src/main/java/EventSet_2Test.java",
    "test_prompt": "// EventSet_2Test.java\n\n\nimport java.util.Vector;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EventSet}.\n* It contains ten unit test cases for the {@link EventSet#size()} method.\n*/\nclass EventSet_2Test {",
    "method_signature": "size()",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// DocumentSet.java\n/**\n *  DocumentSet.java\n *   Caleb Astey - 2007\n */\nimport java.util.Vector;\nimport java.util.Hashtable;\nimport java.util.StringTokenizer;\nimport java.util.*;\n\n/**\n * A Document Set is a group of documents written by the same author.\n *  This can be used to facilitate event sets that are larger than just\n *  a single document, which may be more indicative of an author\u0027s\n *  entire body of work.\n */\npublic class DocumentSet {\n\n    public Hashtable frequency;\n\n    Vector\u003cDocument\u003e documents;\n\n    DocumentSet() {\n        documents \u003d new Vector\u003cDocument\u003e();\n    }\n\n    DocumentSet(Document d) {\n        documents \u003d new Vector\u003cDocument\u003e();\n        documents.add(d);\n    }\n\n    /**\n     * Registers a new document to the list of documents by a given author.\n     *  The document is appended on to the end of the list.\n     */\n    public void register(Document d) {\n        documents.add(d);\n    }\n\n    /**\n     * Number of documents currently registered in this set of documents*\n     */\n    public int documentCount() {\n        return documents.size();\n    }\n\n    /**\n     * Returns an individual indexed documement.  The index is given by the\n     *  order in which the documents were registered with the DocumentSet\n     */\n    public Document getDocument(int index) {\n        return documents.elementAt(index);\n    }\n\n    /**\n     * Calculates the frequency of individual characters within the entire\n     *  set of documents.  Each character is a key in a hashtable with the value\n     *  being the frequency of occurrance. This is legacy code rewritten and was\n     *  included for completeness.\n     */\n    public void characterFrequency() {\n        frequency \u003d new Hashtable();\n        for (int i \u003d 0; i \u003c documents.size(); i++) {\n            Vector\u003cCharacter\u003e pt \u003d documents.elementAt(i).getProcessedText();\n            for (int j \u003d 0; j \u003c documents.elementAt(i).getSize(); j++) {\n                char letter \u003d pt.elementAt(j);\n                if (frequency.containsKey(letter)) {\n                    Integer t \u003d (Integer) frequency.get(letter);\n                    int ti \u003d t.intValue() + 1;\n                    frequency.put(letter, new Integer(ti));\n                } else\n                    frequency.put(letter, new Integer(1));\n            }\n        }\n    }\n\n    /**\n     * Calculates the frequency of full  words within the entire\n     *  set of documents.  Each word is a key in a hashtable with the value\n     *  being the frequency of occurrance. This is legacy code rewritten and was\n     *  included for completeness.\n     */\n    public void wordFrequency() {\n        frequency \u003d new Hashtable();\n        for (int i \u003d 0; i \u003c documents.size(); i++) {\n            String stDoc \u003d documents.elementAt(i).stringify();\n            StringTokenizer st \u003d new StringTokenizer(stDoc, \" .,;:?!\\\"\");\n            while (st.hasMoreTokens()) {\n                String word \u003d st.nextToken();\n                if (frequency.containsKey(word)) {\n                    Integer t \u003d (Integer) frequency.get(word);\n                    int ti \u003d t.intValue() + 1;\n                    frequency.put(word, new Integer(ti));\n                } else\n                    frequency.put(word, new Integer(1));\n            }\n        }\n    }\n\n    /**\n     * Returns the top most common words in the document with the rest\n     *  replaced with a placeholder.  This is also legacy code, rewritten,\n     *  generalized, and replaced from the old code.\n     *  Side Note:  This code should probably be moved to the EventSet class,\n     *  along with the frequency analysis classes.  This will allow character\n     *  and word frequencies to be generalized to event frequencies, by returning\n     *  the N most common events, replacing the rest with a generic event.\n     */\n    public void mostCommon(int n) {\n        Vector keys \u003d new Vector();\n        Vector values \u003d new Vector();\n        Vector\u003ckvp\u003e kvps \u003d new Vector\u003ckvp\u003e();\n        Enumeration ekeys \u003d frequency.keys();\n        while (ekeys.hasMoreElements()) {\n            Object temp \u003d ekeys.nextElement();\n            kvps.add(new kvp(temp, (Integer) frequency.get(temp)));\n        }\n        Collections.sort(kvps);\n        Collections.reverse(kvps);\n        for (int i \u003d 0; i \u003c n; i++) System.out.println(kvps.elementAt(i));\n    }\n}\n\n/**\n * kvp -\u003e key value pair.  This is a specific\n *  hashtable implementation for the frequency\n *  analysis portions of DocumentSet.mostCommon()\n */\nclass kvp implements Comparable {\n\n    Object key;\n\n    int value;\n\n    public kvp(Object key, Integer value) {\n        this.key \u003d key;\n        this.value \u003d value.intValue();\n    }\n\n    public int compareTo(Object ol) {\n        if (this.value \u003d\u003d ((kvp) ol).value)\n            return 0;\n        else if (this.value \u003c ((kvp) ol).value)\n            return -1;\n        else\n            return 1;\n    }\n\n    public String toString() {\n        String t \u003d new String();\n        t \u003d value + \":\\t\" + key;\n        return t;\n    }\n}\n",
    "package": "",
    "classname": "DocumentSet",
    "id": "/EvoSuiteBenchmark/original/100_jgaap/src/main/java/DocumentSet_0Test.java",
    "test_prompt": "// DocumentSet_0Test.java\n\n\n/**\n *  DocumentSet.java\n *   Caleb Astey - 2007\n */\nimport java.util.Vector;\nimport java.util.Hashtable;\nimport java.util.StringTokenizer;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DocumentSet}.\n* It contains ten unit test cases for the {@link DocumentSet#documentCount()} method.\n*/\nclass DocumentSet_0Test {",
    "method_signature": "documentCount()",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// Document.java\nimport java.io.*;\nimport java.util.Vector;\n\n/**\n *   Code for storing and processing individual documents of any type.\n */\npublic class Document {\n\n    private String author;\n\n    private String filename;\n\n    private char[] rawText;\n\n    private int size;\n\n    /**\n     * Contains current processed text*\n     */\n    public Vector\u003cCharacter\u003e procText;\n\n    /**\n     * Create and read in document with known text unknown author*\n     */\n    public Document(String filename) {\n        this.author \u003d null;\n        this.filename \u003d filename;\n        readText(filename);\n    }\n\n    /**\n     * Create and read in document with known text and known author*\n     */\n    public Document(String filename, String author) {\n        this.author \u003d author;\n        this.filename \u003d filename;\n        readText(filename);\n    }\n\n    /**\n     * Returns the full filename of the current document*\n     */\n    public String getFilename() {\n        return filename;\n    }\n\n    /**\n     * Sets the author of the current document*\n     */\n    public void setAuthor(String author) {\n        this.author \u003d author;\n    }\n\n    /**\n     * Retrieves the author of the current document*\n     */\n    public String getAuthor() {\n        return author;\n    }\n\n    /**\n     * Returns the size of the document.  Size is determined by the\n     *  number of characters plus whitespace\n     */\n    public int getSize() {\n        return size;\n    }\n\n    /**\n     * Returns text with preprocessing done.  Preprocessing can\n     *  include stripping whitespace or normalizin the case\n     */\n    public Vector\u003cCharacter\u003e getProcessedText() {\n        return procText;\n    }\n\n    /**\n     * Reads text from a local file.  Exceptions are not caught\n     *  by name.  Rather, all exceptions are handled through just\n     *  printing the error messgae to stdout.  This should\n     *  probably be changed for robustness.  The raw text of the\n     *  file is stored for quick access in an array.\n     */\n    public void readText(String filename) {\n        int c, ctr \u003d 0;\n        try {\n            File input \u003d new File(filename);\n            this.size \u003d (int) input.length();\n            this.rawText \u003d new char[size];\n            this.procText \u003d new Vector\u003cCharacter\u003e();\n            FileInputStream fis \u003d new FileInputStream(input);\n            while ((c \u003d fis.read()) !\u003d -1) {\n                rawText[ctr++] \u003d (char) c;\n                procText.add(new Character((char) c));\n            }\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n\n    public String toString() {\n        String t \u003d new String();\n        t \u003d \"Document: \" + filename + \"\\n\";\n        t +\u003d \"Author:   \" + author + \"\\n\";\n        return t;\n    }\n\n    public void print() {\n        for (Character c : procText) System.out.print(c);\n    }\n\n    /**\n     * Convert processed document into one really long string.\n     *  I\u0027m not quite sure yet why this ever would need to be done.\n     */\n    public String stringify() {\n        String t \u003d new String();\n        for (int i \u003d 0; i \u003c procText.size(); i++) t +\u003d (char) procText.elementAt(i);\n        return t;\n    }\n}\n",
    "package": "",
    "classname": "Document",
    "id": "/EvoSuiteBenchmark/original/100_jgaap/src/main/java/Document.java",
    "test_prompt": "// DocumentTest.java\n\n\nimport java.io.*;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Document}.\n* It contains ten unit test cases for the {@link Document#stringify()} method.\n*/\nclass DocumentTest {",
    "method_signature": "stringify()",
    "suffix": ""
  }
]