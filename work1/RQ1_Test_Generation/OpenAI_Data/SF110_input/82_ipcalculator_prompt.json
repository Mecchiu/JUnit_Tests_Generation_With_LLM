[
  {
    "numberTests": "ten",
    "original_code": "// BinaryCalculate.java\npackage ipac;\r\n\r\nimport java.text.*;\r\nimport java.util.*;\r\nimport java.math.*;\r\n\r\n/**\r\n *  Title: Binary Calculator\r\n *  \u003cbr\u003eDescription: Background binary calculator for the IPAC program\r\n *  \u003cbr\u003eCopyright (c) 2006-7 Jason Wang\r\n *\r\n *  \u003cp\u003eThis program is free software; you can redistribute it and/or\r\n *  \u003cbr\u003emodify it under the terms of the GNU General Public License\r\n *  \u003cbr\u003eas published by the Free Software Foundation; either version 2\r\n *  \u003cbr\u003eof the License, or (at your option) any later version.\r\n *\r\n *  \u003cbr\u003eThis program is distributed in the hope that it will be useful,\r\n *  \u003cbr\u003ebut WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  \u003cbr\u003eMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  \u003cbr\u003eGNU General Public License for more details.\r\n *\r\n *  \u003cbr\u003eYou should have received a copy of the GNU General Public License\r\n *  \u003cbr\u003ealong with this program; if not, write to the Free Software\r\n *  \u003cbr\u003eFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\r\n *                                                              02110-1301, USA.\r\n *\r\n *  @author      Jason Wang\r\n *  @version     v0.19\r\n */\r\npublic class BinaryCalculate {\r\n\r\n    boolean isIPv4 \u003d false;\r\n\r\n    boolean isIPv6 \u003d false;\r\n\r\n    String currentIP \u003d \"\";\r\n\r\n    String fullReassembler \u003d \"\";\r\n\r\n    String DELIMITER \u003d \"\";\r\n\r\n    int lengthOfToken \u003d 0;\r\n\r\n    String IPRangeAddress \u003d \"\";\r\n\r\n    String usableRange \u003d \"\";\r\n\r\n    int semiCol \u003d 0;\r\n\r\n    String prefix \u003d \"\";\r\n\r\n    BigInteger totalIPAddresses;\r\n\r\n    int MAXPREFIX \u003d 0;\r\n\r\n    /**\r\n     *  Calculates the sum of two binary numbers.\r\n     *\r\n     *  @param       num1    The starting binary number\r\n     *  @param       num2    The binary number to be added to the starting binary\r\n     *  @return      The sum of two binary numbers.\r\n     */\r\n    public String addBinary(String num1, String num2) {\r\n        boolean carry \u003d false;\r\n        int size1 \u003d num1.length() - 1;\r\n        int size2 \u003d num2.length() - 1;\r\n        String sum \u003d \"\";\r\n        if (size2 \u003e size1) {\r\n            String s \u003d num1;\r\n            num1 \u003d num2;\r\n            num2 \u003d s;\r\n            int n \u003d size1;\r\n            size1 \u003d size2;\r\n            size2 \u003d n;\r\n        }\r\n        for (; size2 \u003e\u003d 0; size1--, size2--) {\r\n            if (num1.charAt(size1) \u003d\u003d \u00270\u0027 \u0026\u0026 num2.charAt(size2) \u003d\u003d \u00270\u0027) {\r\n                if (!carry)\r\n                    sum \u003d \"0\" + sum;\r\n                else\r\n                    sum \u003d \"1\" + sum;\r\n                carry \u003d false;\r\n            } else if (num1.charAt(size1) \u003d\u003d \u00271\u0027 \u0026\u0026 num2.charAt(size2) \u003d\u003d \u00270\u0027) {\r\n                if (!carry)\r\n                    sum \u003d \"1\" + sum;\r\n                else {\r\n                    sum \u003d \"0\" + sum;\r\n                    carry \u003d true;\r\n                }\r\n            } else if (num1.charAt(size1) \u003d\u003d \u00270\u0027 \u0026\u0026 num2.charAt(size2) \u003d\u003d \u00271\u0027) {\r\n                if (!carry)\r\n                    sum \u003d \"1\" + sum;\r\n                else {\r\n                    sum \u003d \"0\" + sum;\r\n                    carry \u003d true;\r\n                }\r\n            } else if (num1.charAt(size1) \u003d\u003d \u00271\u0027 \u0026\u0026 num2.charAt(size2) \u003d\u003d \u00271\u0027) {\r\n                if (!carry)\r\n                    sum \u003d \"0\" + sum;\r\n                else\r\n                    sum \u003d \"1\" + sum;\r\n                carry \u003d true;\r\n            }\r\n        }\r\n        for (; size1 \u003e\u003d 0; size1--) {\r\n            if (num1.charAt(size1) \u003d\u003d \u00270\u0027) {\r\n                if (!carry)\r\n                    sum \u003d \"0\" + sum;\r\n                else\r\n                    sum \u003d \"1\" + sum;\r\n                carry \u003d false;\r\n            } else if (num1.charAt(size1) \u003d\u003d \u00271\u0027) {\r\n                if (!carry)\r\n                    sum \u003d \"1\" + sum;\r\n                else {\r\n                    sum \u003d \"0\" + sum;\r\n                    carry \u003d true;\r\n                }\r\n            }\r\n        }\r\n        if (carry)\r\n            sum \u003d \"1\" + sum;\r\n        return sum;\r\n    }\r\n\r\n    /**\r\n     *  Subtracts two binary numbers.\r\n     *\r\n     *  @param       num1    The starting binary number\r\n     *  @param       num2    The binary number to be subtracted from the\r\n     *                       starting binary\r\n     *  @return      The difference of two binary numbers.\r\n     */\r\n    public String subBinary(String num1, String num2) {\r\n        String diff \u003d \"\";\r\n        String twosComp \u003d \"\";\r\n        int size \u003d num1.length() - 1;\r\n        for (; size \u003e\u003d 0; size--) {\r\n            if (num1.charAt(size) \u003d\u003d \u00270\u0027)\r\n                twosComp \u003d \"1\" + twosComp;\r\n            else\r\n                twosComp \u003d \"0\" + twosComp;\r\n        }\r\n        twosComp \u003d \"0\" + twosComp;\r\n        twosComp \u003d addBinary(twosComp, \"1\");\r\n        diff \u003d addBinary(twosComp, num2);\r\n        return diff.substring(1);\r\n    }\r\n\r\n    /**\r\n     *  Calculates the IP Range from the provided IP address and number of IP\r\n     *  addresses. The results are stored into an \u003ccode\u003estring\u003c/code\u003e to be\r\n     *  returned to the method that called it.\r\n     *\r\n     *  @param      IP          The starting IP address (subnet) in binary\r\n     *  @param      IPPrefix    Number of IP addresses in binary\r\n     *  @return     Results string\r\n     */\r\n    public String IPCalculate(String IP, String IPPrefix) {\r\n        String outputText \u003d \"\";\r\n        checkIPType(IP.length() - 1);\r\n        String subnet \u003d convert(IP);\r\n        String netmask \u003d getNetmask(IPPrefix);\r\n        calculate(IP, IPPrefix);\r\n        outputText +\u003d \"Total Range: \" + IPRangeAddress + \"\\n\";\r\n        outputText +\u003d \"Usable Range: \" + usableRange + \"\\n\";\r\n        NumberFormat formatter \u003d new DecimalFormat(\"###,###,###,###,###,###,###,###,###,###,###,###,###\");\r\n        outputText +\u003d \"\\n\";\r\n        outputText +\u003d \"Total usable IP Addresses : \" + formatter.format(totalIPAddresses) + \"\\n\";\r\n        outputText +\u003d \"Subnet: \" + subnet + \"\\n\";\r\n        outputText +\u003d \"Binary Subnet: \" + getBinaryIP(IP) + \"\\n\";\r\n        outputText +\u003d \"Broadcast Address: \" + currentIP + \"\\n\";\r\n        outputText +\u003d \"Prefix: \" + prefix + \"\\n\";\r\n        checkIPType(netmask.length() - 1);\r\n        String outputNetmask \u003d convert(netmask);\r\n        outputText +\u003d \"Netmask: \" + outputNetmask + \"\\n\";\r\n        String binaryNetmask \u003d getBinaryIP(netmask);\r\n        outputText +\u003d \"Binary Netmask: \" + binaryNetmask;\r\n        return outputText;\r\n    }\r\n\r\n    /**\r\n     *  Adds delimiters back into a given IP address\r\n     *\r\n     *  @param      binaryIP     binary IP address with no delimiters\r\n     *  @return     binary IP address with delimiters\r\n     */\r\n    private String getBinaryIP(String binaryIP) {\r\n        String output \u003d \"\";\r\n        checkIPType(binaryIP.length() - 1);\r\n        for (int i \u003d 0; i \u003c MAXPREFIX; i++) {\r\n            output +\u003d binaryIP.charAt(i);\r\n            if (i \u003d\u003d semiCol) {\r\n                if (i !\u003d (binaryIP.length() - 1))\r\n                    output +\u003d DELIMITER;\r\n                semiCol +\u003d lengthOfToken;\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     *  Gets the netmask from a binary representation of number of IP addresses\r\n     *\r\n     *  @param      binaryIP     binary representation of number of IP addresses\r\n     *  @return     netmask of \u003ccode\u003ebinaryIP\u003c/code\u003e\r\n     */\r\n    private String getNetmask(String binaryIP) {\r\n        String invertedIPPrefix \u003d \"\";\r\n        for (int i \u003d 0; i \u003c MAXPREFIX; i++) {\r\n            if (binaryIP.charAt(i) \u003d\u003d \u00270\u0027)\r\n                invertedIPPrefix +\u003d \"1\";\r\n            else\r\n                invertedIPPrefix +\u003d \"0\";\r\n        }\r\n        return invertedIPPrefix;\r\n    }\r\n\r\n    /**\r\n     *  Calculates the IP Range from the provided IP address and number of IP\r\n     *  addresses. The results are stored as declared global variables for many\r\n     *  other methods to manipulate or use.\r\n     *  \u003cbr\u003eThis method also detects if the provided of number of IP addresses\r\n     *  to be calculate exceeds past these IP addresses: 255.255.255.255 and\r\n     *  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF, as further IP addresses exceeds\r\n     *  the IP addressing bounds.\r\n     *  \u003cbr\u003eThis method also calculates the prefix size needed to accomodate all\r\n     *  the IP Addresses to be listed and stores it as a global variable for use\r\n     *  in other methods.\r\n     *\r\n     *  @param       subnet              The starting IP address (subnet)\r\n     *  @param       noOfIPAddresses     Number of IP addresses\r\n     */\r\n    private void calculate(String subnet, String noOfIPAddresses) {\r\n        currentIP \u003d \"\";\r\n        String number1 \u003d subnet;\r\n        String usableIP \u003d \"\";\r\n        String IP \u003d addBinary(subnet, noOfIPAddresses);\r\n        checkIPType(subnet.length() - 1);\r\n        String addSubBinary \u003d \"\";\r\n        for (int i \u003d 0; i \u003c (MAXPREFIX - 1); i++) {\r\n            addSubBinary +\u003d \"0\";\r\n        }\r\n        addSubBinary +\u003d \"1\";\r\n        subnet \u003d addBinary(addSubBinary, subnet);\r\n        usableIP \u003d convert(subnet);\r\n        subnet \u003d subBinary(addSubBinary, subnet);\r\n        checkIPType(subnet.length() - 1);\r\n        currentIP \u003d convert(subnet);\r\n        fullReassembler \u003d \"\";\r\n        semiCol \u003d lengthOfToken - 1;\r\n        IPRangeAddress \u003d currentIP + \" -- \";\r\n        usableRange \u003d usableIP + \" -- \";\r\n        currentIP \u003d \"\";\r\n        String currentIPString \u003d \"\";\r\n        if (IP.length() \u003e 128) {\r\n            IPRangeAddress \u003d IPRangeAddress + \"FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF\";\r\n            currentIP \u003d \"FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF\";\r\n        } else if (IP.length() \u003e 32 \u0026\u0026 IP.length() \u003c 128) {\r\n            IPRangeAddress \u003d IPRangeAddress + \"255.255.255.255\";\r\n            currentIP \u003d \"255.255.255.255\";\r\n        } else {\r\n            String IPRangeEnd \u003d subBinary(addSubBinary, IP);\r\n            String endIP \u003d convert(IPRangeEnd);\r\n            usableRange \u003d usableRange + endIP;\r\n            checkIPType(subnet.length() - 1);\r\n            currentIP \u003d convert(IP);\r\n            IPRangeAddress \u003d IPRangeAddress + currentIP;\r\n        }\r\n        currentIPString \u003d subBinary(number1, convertToBinary(currentIP));\r\n        totalIPAddresses \u003d new BigInteger(currentIPString, 2);\r\n        totalIPAddresses \u003d totalIPAddresses.add(new BigInteger(\"1\"));\r\n        int prefixInt \u003d 0;\r\n        if (totalIPAddresses.doubleValue() \u003c 2)\r\n            prefixInt \u003d MAXPREFIX;\r\n        else if (totalIPAddresses.doubleValue() \u003d\u003d 2)\r\n            prefixInt \u003d MAXPREFIX - 2;\r\n        else {\r\n            if (isIPv6) {\r\n                String currentIPString1 \u003d currentIPString.substring(0, 64);\r\n                BigInteger totalIPAddresses1 \u003d new BigInteger(currentIPString1, 2);\r\n                double prefixInt1 \u003d 0;\r\n                if (totalIPAddresses1.doubleValue() \u003e 0)\r\n                    prefixInt1 \u003d Math.log(totalIPAddresses1.doubleValue()) / Math.log(2.0);\r\n                String currentIPString2 \u003d currentIPString.substring(64, 128);\r\n                BigInteger totalIPAddresses2 \u003d new BigInteger(currentIPString2, 2);\r\n                double prefixInt2 \u003d Math.log(totalIPAddresses2.doubleValue()) / Math.log(2.0);\r\n                prefixInt \u003d MAXPREFIX - (int) Math.ceil(prefixInt1) - (int) Math.round(prefixInt2);\r\n            } else if (isIPv4)\r\n                prefixInt \u003d MAXPREFIX - (int) Math.ceil(Math.log(totalIPAddresses.doubleValue()) / Math.log(2.0));\r\n        }\r\n        prefix \u003d \"/\" + prefixInt;\r\n        totalIPAddresses \u003d totalIPAddresses.subtract(new BigInteger(\"2\"));\r\n    }\r\n\r\n    /**\r\n     *  Calculates the IP Range from the provided IP address and number of IP\r\n     *  addresses from the smaller prefix. The results are stored into an array\r\n     *  to be printed using \u003ccode\u003e\u003cb\u003eOutput.java\u003c/b\u003e\u003c/code\u003e.\r\n     *\r\n     *  @param       IP          The starting IP address (subnet)\r\n     *  @param       IPPrefix    Number of IP addresses for smaller prefix\r\n     *  @param       noPrefix    Number of smaller prefixes within the total\r\n     *                           prefix\r\n     *  @param       endPrefix   Prefix of total number of IP Addresses\r\n     */\r\n    public void prefixInPrefixCalculate(String IP, String IPPrefix, int noPrefix, String endPrefix) {\r\n        try {\r\n            String[][] output \u003d new String[noPrefix + 8][2];\r\n            checkIPType(IP.length() - 1);\r\n            String subnet \u003d convert(IP);\r\n            String netmask \u003d getNetmask(IPPrefix);\r\n            calculate(IP, IPPrefix);\r\n            for (int i \u003d 0; i \u003c noPrefix; i++) {\r\n                calculate(IP, IPPrefix);\r\n                output[i][0] \u003d getStartIP() + \" \" + prefix;\r\n                output[i][1] \u003d IPRangeAddress;\r\n                IP \u003d addBinary(fullReassembler.substring(MAXPREFIX, fullReassembler.length()), Integer.toBinaryString(1));\r\n                fullReassembler \u003d \"\";\r\n            }\r\n            output[noPrefix + 1][0] \u003d \"Total usable IP Addresses :\";\r\n            NumberFormat formatter \u003d new DecimalFormat(\"###,###,###,###,###,###,###,###,###,###,###,###,###\");\r\n            output[noPrefix + 1][1] \u003d formatter.format(totalIPAddresses.multiply(new BigInteger(noPrefix + \"\"))) + \" \";\r\n            output[noPrefix + 2][0] \u003d \"Subnet:\";\r\n            output[noPrefix + 2][1] \u003d subnet;\r\n            StringTokenizer subnetTokens \u003d new StringTokenizer(convertToBinary(subnet), DELIMITER);\r\n            String paddedSubnet \u003d \"\";\r\n            while (subnetTokens.hasMoreTokens()) {\r\n                String unpaddedSubnet \u003d subnetTokens.nextToken();\r\n                while (unpaddedSubnet.length() \u003c lengthOfToken) unpaddedSubnet \u003d \"0\" + unpaddedSubnet;\r\n                paddedSubnet +\u003d unpaddedSubnet;\r\n            }\r\n            output[noPrefix + 3][0] \u003d \"Binary Subnet:\";\r\n            output[noPrefix + 3][1] \u003d getBinaryIP(paddedSubnet);\r\n            output[noPrefix + 4][0] \u003d \"Broadcast Address:\";\r\n            output[noPrefix + 4][1] \u003d currentIP;\r\n            output[noPrefix + 5][0] \u003d \"Prefix:\";\r\n            output[noPrefix + 5][1] \u003d endPrefix;\r\n            checkIPType(netmask.length() - 1);\r\n            output[noPrefix + 6][0] \u003d \"Netmask\";\r\n            output[noPrefix + 6][1] \u003d convert(netmask);\r\n            output[noPrefix + 7][0] \u003d \"Binary Netmask:\";\r\n            output[noPrefix + 7][1] \u003d getBinaryIP(netmask);\r\n            new Output(output);\r\n        } catch (OutOfMemoryError e) {\r\n            new IPv4().displayError(\"Your computer does not have sufficent \" + \"memory to process this query.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  Determines whether an IP Address provided in binary form is an IPv4 or\r\n     *  an IPv6 by the length of the binary string.\r\n     *\r\n     *  @param       size1    Length of binary string\r\n     */\r\n    private void checkIPType(int size1) {\r\n        if (size1 \u003d\u003d 31) {\r\n            isIPv4 \u003d true;\r\n            lengthOfToken \u003d 8;\r\n            DELIMITER \u003d \".\";\r\n            MAXPREFIX \u003d 32;\r\n        } else if (size1 \u003d\u003d 127) {\r\n            isIPv6 \u003d true;\r\n            lengthOfToken \u003d 16;\r\n            DELIMITER \u003d \":\";\r\n            MAXPREFIX \u003d 128;\r\n        }\r\n        semiCol \u003d lengthOfToken - 1;\r\n    }\r\n\r\n    /**\r\n     *  Reconstructs the dotted-decimal or hexidecimal IP address with\r\n     *  seperators from an given binary IP Address. The reconstructed IP address\r\n     *  is stored as a global declared variable, \u003ccode\u003ecurrentIP\u003c/code\u003e.\r\n     *\r\n     *  @param   IP  An binary IP Address to be converted back into\r\n     *               dotted-decimal or hexidecimal format\r\n     */\r\n    private String convert(String binaryIP) {\r\n        String outputIP \u003d \"\";\r\n        String reassembler \u003d \"\";\r\n        for (int i \u003d 0; i \u003c binaryIP.length(); i++) {\r\n            reassembler +\u003d binaryIP.charAt(i);\r\n            fullReassembler +\u003d binaryIP.charAt(i);\r\n            if (i \u003d\u003d semiCol) {\r\n                if (isIPv4) {\r\n                    outputIP +\u003d Integer.parseInt(reassembler, 2);\r\n                    reassembler \u003d \"\";\r\n                } else if (isIPv6) {\r\n                    outputIP +\u003d Integer.toHexString(Integer.parseInt(reassembler, 2));\r\n                    reassembler \u003d \"\";\r\n                }\r\n                if (i !\u003d (binaryIP.length() - 1))\r\n                    outputIP +\u003d DELIMITER;\r\n                semiCol \u003d semiCol + lengthOfToken;\r\n            }\r\n        }\r\n        return outputIP;\r\n    }\r\n\r\n    /**\r\n     *  Converts an given IPv4 or IPv6 address into binary format.\r\n     *\r\n     *  @param   IP  An IP Address to be converted back into binary format\r\n     *  @return  Binary representation of given IP Address.\r\n     */\r\n    private String convertToBinary(String IP) {\r\n        StringTokenizer octetToken \u003d new StringTokenizer(IP);\r\n        String output \u003d \"\";\r\n        int radix \u003d 0;\r\n        if (isIPv4)\r\n            radix \u003d 10;\r\n        else if (isIPv6)\r\n            radix \u003d 16;\r\n        while (octetToken.hasMoreTokens()) {\r\n            String out \u003d Integer.toBinaryString(Integer.parseInt(octetToken.nextToken(\".:\"), radix));\r\n            while (out.length() \u003c lengthOfToken) out \u003d \"0\" + out;\r\n            output +\u003d out;\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     *  Gets the starting IP of an IP range.\r\n     *\r\n     *  @return     Starting IP of IP range\r\n     */\r\n    private String getStartIP() {\r\n        StringTokenizer tokens \u003d new StringTokenizer(IPRangeAddress, \" -\");\r\n        return tokens.nextToken();\r\n    }\r\n}\r\n",
    "package": "ipac",
    "classname": "BinaryCalculate",
    "id": "/EvoSuiteBenchmark/original/82_ipcalculator/src/main/java/ipac/BinaryCalculate_0Test.java",
    "test_prompt": "// BinaryCalculate_0Test.java\npackage ipac;\n\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BinaryCalculate}.\n* It contains ten unit test cases for the {@link BinaryCalculate#addBinary(String, String)} method.\n*/\nclass BinaryCalculate_0Test {",
    "method_signature": "addBinary(String, String)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// BinaryCalculate.java\npackage ipac;\r\n\r\nimport java.text.*;\r\nimport java.util.*;\r\nimport java.math.*;\r\n\r\n/**\r\n *  Title: Binary Calculator\r\n *  \u003cbr\u003eDescription: Background binary calculator for the IPAC program\r\n *  \u003cbr\u003eCopyright (c) 2006-7 Jason Wang\r\n *\r\n *  \u003cp\u003eThis program is free software; you can redistribute it and/or\r\n *  \u003cbr\u003emodify it under the terms of the GNU General Public License\r\n *  \u003cbr\u003eas published by the Free Software Foundation; either version 2\r\n *  \u003cbr\u003eof the License, or (at your option) any later version.\r\n *\r\n *  \u003cbr\u003eThis program is distributed in the hope that it will be useful,\r\n *  \u003cbr\u003ebut WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  \u003cbr\u003eMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  \u003cbr\u003eGNU General Public License for more details.\r\n *\r\n *  \u003cbr\u003eYou should have received a copy of the GNU General Public License\r\n *  \u003cbr\u003ealong with this program; if not, write to the Free Software\r\n *  \u003cbr\u003eFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\r\n *                                                              02110-1301, USA.\r\n *\r\n *  @author      Jason Wang\r\n *  @version     v0.19\r\n */\r\npublic class BinaryCalculate {\r\n\r\n    boolean isIPv4 \u003d false;\r\n\r\n    boolean isIPv6 \u003d false;\r\n\r\n    String currentIP \u003d \"\";\r\n\r\n    String fullReassembler \u003d \"\";\r\n\r\n    String DELIMITER \u003d \"\";\r\n\r\n    int lengthOfToken \u003d 0;\r\n\r\n    String IPRangeAddress \u003d \"\";\r\n\r\n    String usableRange \u003d \"\";\r\n\r\n    int semiCol \u003d 0;\r\n\r\n    String prefix \u003d \"\";\r\n\r\n    BigInteger totalIPAddresses;\r\n\r\n    int MAXPREFIX \u003d 0;\r\n\r\n    /**\r\n     *  Calculates the sum of two binary numbers.\r\n     *\r\n     *  @param       num1    The starting binary number\r\n     *  @param       num2    The binary number to be added to the starting binary\r\n     *  @return      The sum of two binary numbers.\r\n     */\r\n    public String addBinary(String num1, String num2) {\r\n        boolean carry \u003d false;\r\n        int size1 \u003d num1.length() - 1;\r\n        int size2 \u003d num2.length() - 1;\r\n        String sum \u003d \"\";\r\n        if (size2 \u003e size1) {\r\n            String s \u003d num1;\r\n            num1 \u003d num2;\r\n            num2 \u003d s;\r\n            int n \u003d size1;\r\n            size1 \u003d size2;\r\n            size2 \u003d n;\r\n        }\r\n        for (; size2 \u003e\u003d 0; size1--, size2--) {\r\n            if (num1.charAt(size1) \u003d\u003d \u00270\u0027 \u0026\u0026 num2.charAt(size2) \u003d\u003d \u00270\u0027) {\r\n                if (!carry)\r\n                    sum \u003d \"0\" + sum;\r\n                else\r\n                    sum \u003d \"1\" + sum;\r\n                carry \u003d false;\r\n            } else if (num1.charAt(size1) \u003d\u003d \u00271\u0027 \u0026\u0026 num2.charAt(size2) \u003d\u003d \u00270\u0027) {\r\n                if (!carry)\r\n                    sum \u003d \"1\" + sum;\r\n                else {\r\n                    sum \u003d \"0\" + sum;\r\n                    carry \u003d true;\r\n                }\r\n            } else if (num1.charAt(size1) \u003d\u003d \u00270\u0027 \u0026\u0026 num2.charAt(size2) \u003d\u003d \u00271\u0027) {\r\n                if (!carry)\r\n                    sum \u003d \"1\" + sum;\r\n                else {\r\n                    sum \u003d \"0\" + sum;\r\n                    carry \u003d true;\r\n                }\r\n            } else if (num1.charAt(size1) \u003d\u003d \u00271\u0027 \u0026\u0026 num2.charAt(size2) \u003d\u003d \u00271\u0027) {\r\n                if (!carry)\r\n                    sum \u003d \"0\" + sum;\r\n                else\r\n                    sum \u003d \"1\" + sum;\r\n                carry \u003d true;\r\n            }\r\n        }\r\n        for (; size1 \u003e\u003d 0; size1--) {\r\n            if (num1.charAt(size1) \u003d\u003d \u00270\u0027) {\r\n                if (!carry)\r\n                    sum \u003d \"0\" + sum;\r\n                else\r\n                    sum \u003d \"1\" + sum;\r\n                carry \u003d false;\r\n            } else if (num1.charAt(size1) \u003d\u003d \u00271\u0027) {\r\n                if (!carry)\r\n                    sum \u003d \"1\" + sum;\r\n                else {\r\n                    sum \u003d \"0\" + sum;\r\n                    carry \u003d true;\r\n                }\r\n            }\r\n        }\r\n        if (carry)\r\n            sum \u003d \"1\" + sum;\r\n        return sum;\r\n    }\r\n\r\n    /**\r\n     *  Subtracts two binary numbers.\r\n     *\r\n     *  @param       num1    The starting binary number\r\n     *  @param       num2    The binary number to be subtracted from the\r\n     *                       starting binary\r\n     *  @return      The difference of two binary numbers.\r\n     */\r\n    public String subBinary(String num1, String num2) {\r\n        String diff \u003d \"\";\r\n        String twosComp \u003d \"\";\r\n        int size \u003d num1.length() - 1;\r\n        for (; size \u003e\u003d 0; size--) {\r\n            if (num1.charAt(size) \u003d\u003d \u00270\u0027)\r\n                twosComp \u003d \"1\" + twosComp;\r\n            else\r\n                twosComp \u003d \"0\" + twosComp;\r\n        }\r\n        twosComp \u003d \"0\" + twosComp;\r\n        twosComp \u003d addBinary(twosComp, \"1\");\r\n        diff \u003d addBinary(twosComp, num2);\r\n        return diff.substring(1);\r\n    }\r\n\r\n    /**\r\n     *  Calculates the IP Range from the provided IP address and number of IP\r\n     *  addresses. The results are stored into an \u003ccode\u003estring\u003c/code\u003e to be\r\n     *  returned to the method that called it.\r\n     *\r\n     *  @param      IP          The starting IP address (subnet) in binary\r\n     *  @param      IPPrefix    Number of IP addresses in binary\r\n     *  @return     Results string\r\n     */\r\n    public String IPCalculate(String IP, String IPPrefix) {\r\n        String outputText \u003d \"\";\r\n        checkIPType(IP.length() - 1);\r\n        String subnet \u003d convert(IP);\r\n        String netmask \u003d getNetmask(IPPrefix);\r\n        calculate(IP, IPPrefix);\r\n        outputText +\u003d \"Total Range: \" + IPRangeAddress + \"\\n\";\r\n        outputText +\u003d \"Usable Range: \" + usableRange + \"\\n\";\r\n        NumberFormat formatter \u003d new DecimalFormat(\"###,###,###,###,###,###,###,###,###,###,###,###,###\");\r\n        outputText +\u003d \"\\n\";\r\n        outputText +\u003d \"Total usable IP Addresses : \" + formatter.format(totalIPAddresses) + \"\\n\";\r\n        outputText +\u003d \"Subnet: \" + subnet + \"\\n\";\r\n        outputText +\u003d \"Binary Subnet: \" + getBinaryIP(IP) + \"\\n\";\r\n        outputText +\u003d \"Broadcast Address: \" + currentIP + \"\\n\";\r\n        outputText +\u003d \"Prefix: \" + prefix + \"\\n\";\r\n        checkIPType(netmask.length() - 1);\r\n        String outputNetmask \u003d convert(netmask);\r\n        outputText +\u003d \"Netmask: \" + outputNetmask + \"\\n\";\r\n        String binaryNetmask \u003d getBinaryIP(netmask);\r\n        outputText +\u003d \"Binary Netmask: \" + binaryNetmask;\r\n        return outputText;\r\n    }\r\n\r\n    /**\r\n     *  Adds delimiters back into a given IP address\r\n     *\r\n     *  @param      binaryIP     binary IP address with no delimiters\r\n     *  @return     binary IP address with delimiters\r\n     */\r\n    private String getBinaryIP(String binaryIP) {\r\n        String output \u003d \"\";\r\n        checkIPType(binaryIP.length() - 1);\r\n        for (int i \u003d 0; i \u003c MAXPREFIX; i++) {\r\n            output +\u003d binaryIP.charAt(i);\r\n            if (i \u003d\u003d semiCol) {\r\n                if (i !\u003d (binaryIP.length() - 1))\r\n                    output +\u003d DELIMITER;\r\n                semiCol +\u003d lengthOfToken;\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     *  Gets the netmask from a binary representation of number of IP addresses\r\n     *\r\n     *  @param      binaryIP     binary representation of number of IP addresses\r\n     *  @return     netmask of \u003ccode\u003ebinaryIP\u003c/code\u003e\r\n     */\r\n    private String getNetmask(String binaryIP) {\r\n        String invertedIPPrefix \u003d \"\";\r\n        for (int i \u003d 0; i \u003c MAXPREFIX; i++) {\r\n            if (binaryIP.charAt(i) \u003d\u003d \u00270\u0027)\r\n                invertedIPPrefix +\u003d \"1\";\r\n            else\r\n                invertedIPPrefix +\u003d \"0\";\r\n        }\r\n        return invertedIPPrefix;\r\n    }\r\n\r\n    /**\r\n     *  Calculates the IP Range from the provided IP address and number of IP\r\n     *  addresses. The results are stored as declared global variables for many\r\n     *  other methods to manipulate or use.\r\n     *  \u003cbr\u003eThis method also detects if the provided of number of IP addresses\r\n     *  to be calculate exceeds past these IP addresses: 255.255.255.255 and\r\n     *  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF, as further IP addresses exceeds\r\n     *  the IP addressing bounds.\r\n     *  \u003cbr\u003eThis method also calculates the prefix size needed to accomodate all\r\n     *  the IP Addresses to be listed and stores it as a global variable for use\r\n     *  in other methods.\r\n     *\r\n     *  @param       subnet              The starting IP address (subnet)\r\n     *  @param       noOfIPAddresses     Number of IP addresses\r\n     */\r\n    private void calculate(String subnet, String noOfIPAddresses) {\r\n        currentIP \u003d \"\";\r\n        String number1 \u003d subnet;\r\n        String usableIP \u003d \"\";\r\n        String IP \u003d addBinary(subnet, noOfIPAddresses);\r\n        checkIPType(subnet.length() - 1);\r\n        String addSubBinary \u003d \"\";\r\n        for (int i \u003d 0; i \u003c (MAXPREFIX - 1); i++) {\r\n            addSubBinary +\u003d \"0\";\r\n        }\r\n        addSubBinary +\u003d \"1\";\r\n        subnet \u003d addBinary(addSubBinary, subnet);\r\n        usableIP \u003d convert(subnet);\r\n        subnet \u003d subBinary(addSubBinary, subnet);\r\n        checkIPType(subnet.length() - 1);\r\n        currentIP \u003d convert(subnet);\r\n        fullReassembler \u003d \"\";\r\n        semiCol \u003d lengthOfToken - 1;\r\n        IPRangeAddress \u003d currentIP + \" -- \";\r\n        usableRange \u003d usableIP + \" -- \";\r\n        currentIP \u003d \"\";\r\n        String currentIPString \u003d \"\";\r\n        if (IP.length() \u003e 128) {\r\n            IPRangeAddress \u003d IPRangeAddress + \"FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF\";\r\n            currentIP \u003d \"FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF\";\r\n        } else if (IP.length() \u003e 32 \u0026\u0026 IP.length() \u003c 128) {\r\n            IPRangeAddress \u003d IPRangeAddress + \"255.255.255.255\";\r\n            currentIP \u003d \"255.255.255.255\";\r\n        } else {\r\n            String IPRangeEnd \u003d subBinary(addSubBinary, IP);\r\n            String endIP \u003d convert(IPRangeEnd);\r\n            usableRange \u003d usableRange + endIP;\r\n            checkIPType(subnet.length() - 1);\r\n            currentIP \u003d convert(IP);\r\n            IPRangeAddress \u003d IPRangeAddress + currentIP;\r\n        }\r\n        currentIPString \u003d subBinary(number1, convertToBinary(currentIP));\r\n        totalIPAddresses \u003d new BigInteger(currentIPString, 2);\r\n        totalIPAddresses \u003d totalIPAddresses.add(new BigInteger(\"1\"));\r\n        int prefixInt \u003d 0;\r\n        if (totalIPAddresses.doubleValue() \u003c 2)\r\n            prefixInt \u003d MAXPREFIX;\r\n        else if (totalIPAddresses.doubleValue() \u003d\u003d 2)\r\n            prefixInt \u003d MAXPREFIX - 2;\r\n        else {\r\n            if (isIPv6) {\r\n                String currentIPString1 \u003d currentIPString.substring(0, 64);\r\n                BigInteger totalIPAddresses1 \u003d new BigInteger(currentIPString1, 2);\r\n                double prefixInt1 \u003d 0;\r\n                if (totalIPAddresses1.doubleValue() \u003e 0)\r\n                    prefixInt1 \u003d Math.log(totalIPAddresses1.doubleValue()) / Math.log(2.0);\r\n                String currentIPString2 \u003d currentIPString.substring(64, 128);\r\n                BigInteger totalIPAddresses2 \u003d new BigInteger(currentIPString2, 2);\r\n                double prefixInt2 \u003d Math.log(totalIPAddresses2.doubleValue()) / Math.log(2.0);\r\n                prefixInt \u003d MAXPREFIX - (int) Math.ceil(prefixInt1) - (int) Math.round(prefixInt2);\r\n            } else if (isIPv4)\r\n                prefixInt \u003d MAXPREFIX - (int) Math.ceil(Math.log(totalIPAddresses.doubleValue()) / Math.log(2.0));\r\n        }\r\n        prefix \u003d \"/\" + prefixInt;\r\n        totalIPAddresses \u003d totalIPAddresses.subtract(new BigInteger(\"2\"));\r\n    }\r\n\r\n    /**\r\n     *  Calculates the IP Range from the provided IP address and number of IP\r\n     *  addresses from the smaller prefix. The results are stored into an array\r\n     *  to be printed using \u003ccode\u003e\u003cb\u003eOutput.java\u003c/b\u003e\u003c/code\u003e.\r\n     *\r\n     *  @param       IP          The starting IP address (subnet)\r\n     *  @param       IPPrefix    Number of IP addresses for smaller prefix\r\n     *  @param       noPrefix    Number of smaller prefixes within the total\r\n     *                           prefix\r\n     *  @param       endPrefix   Prefix of total number of IP Addresses\r\n     */\r\n    public void prefixInPrefixCalculate(String IP, String IPPrefix, int noPrefix, String endPrefix) {\r\n        try {\r\n            String[][] output \u003d new String[noPrefix + 8][2];\r\n            checkIPType(IP.length() - 1);\r\n            String subnet \u003d convert(IP);\r\n            String netmask \u003d getNetmask(IPPrefix);\r\n            calculate(IP, IPPrefix);\r\n            for (int i \u003d 0; i \u003c noPrefix; i++) {\r\n                calculate(IP, IPPrefix);\r\n                output[i][0] \u003d getStartIP() + \" \" + prefix;\r\n                output[i][1] \u003d IPRangeAddress;\r\n                IP \u003d addBinary(fullReassembler.substring(MAXPREFIX, fullReassembler.length()), Integer.toBinaryString(1));\r\n                fullReassembler \u003d \"\";\r\n            }\r\n            output[noPrefix + 1][0] \u003d \"Total usable IP Addresses :\";\r\n            NumberFormat formatter \u003d new DecimalFormat(\"###,###,###,###,###,###,###,###,###,###,###,###,###\");\r\n            output[noPrefix + 1][1] \u003d formatter.format(totalIPAddresses.multiply(new BigInteger(noPrefix + \"\"))) + \" \";\r\n            output[noPrefix + 2][0] \u003d \"Subnet:\";\r\n            output[noPrefix + 2][1] \u003d subnet;\r\n            StringTokenizer subnetTokens \u003d new StringTokenizer(convertToBinary(subnet), DELIMITER);\r\n            String paddedSubnet \u003d \"\";\r\n            while (subnetTokens.hasMoreTokens()) {\r\n                String unpaddedSubnet \u003d subnetTokens.nextToken();\r\n                while (unpaddedSubnet.length() \u003c lengthOfToken) unpaddedSubnet \u003d \"0\" + unpaddedSubnet;\r\n                paddedSubnet +\u003d unpaddedSubnet;\r\n            }\r\n            output[noPrefix + 3][0] \u003d \"Binary Subnet:\";\r\n            output[noPrefix + 3][1] \u003d getBinaryIP(paddedSubnet);\r\n            output[noPrefix + 4][0] \u003d \"Broadcast Address:\";\r\n            output[noPrefix + 4][1] \u003d currentIP;\r\n            output[noPrefix + 5][0] \u003d \"Prefix:\";\r\n            output[noPrefix + 5][1] \u003d endPrefix;\r\n            checkIPType(netmask.length() - 1);\r\n            output[noPrefix + 6][0] \u003d \"Netmask\";\r\n            output[noPrefix + 6][1] \u003d convert(netmask);\r\n            output[noPrefix + 7][0] \u003d \"Binary Netmask:\";\r\n            output[noPrefix + 7][1] \u003d getBinaryIP(netmask);\r\n            new Output(output);\r\n        } catch (OutOfMemoryError e) {\r\n            new IPv4().displayError(\"Your computer does not have sufficent \" + \"memory to process this query.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  Determines whether an IP Address provided in binary form is an IPv4 or\r\n     *  an IPv6 by the length of the binary string.\r\n     *\r\n     *  @param       size1    Length of binary string\r\n     */\r\n    private void checkIPType(int size1) {\r\n        if (size1 \u003d\u003d 31) {\r\n            isIPv4 \u003d true;\r\n            lengthOfToken \u003d 8;\r\n            DELIMITER \u003d \".\";\r\n            MAXPREFIX \u003d 32;\r\n        } else if (size1 \u003d\u003d 127) {\r\n            isIPv6 \u003d true;\r\n            lengthOfToken \u003d 16;\r\n            DELIMITER \u003d \":\";\r\n            MAXPREFIX \u003d 128;\r\n        }\r\n        semiCol \u003d lengthOfToken - 1;\r\n    }\r\n\r\n    /**\r\n     *  Reconstructs the dotted-decimal or hexidecimal IP address with\r\n     *  seperators from an given binary IP Address. The reconstructed IP address\r\n     *  is stored as a global declared variable, \u003ccode\u003ecurrentIP\u003c/code\u003e.\r\n     *\r\n     *  @param   IP  An binary IP Address to be converted back into\r\n     *               dotted-decimal or hexidecimal format\r\n     */\r\n    private String convert(String binaryIP) {\r\n        String outputIP \u003d \"\";\r\n        String reassembler \u003d \"\";\r\n        for (int i \u003d 0; i \u003c binaryIP.length(); i++) {\r\n            reassembler +\u003d binaryIP.charAt(i);\r\n            fullReassembler +\u003d binaryIP.charAt(i);\r\n            if (i \u003d\u003d semiCol) {\r\n                if (isIPv4) {\r\n                    outputIP +\u003d Integer.parseInt(reassembler, 2);\r\n                    reassembler \u003d \"\";\r\n                } else if (isIPv6) {\r\n                    outputIP +\u003d Integer.toHexString(Integer.parseInt(reassembler, 2));\r\n                    reassembler \u003d \"\";\r\n                }\r\n                if (i !\u003d (binaryIP.length() - 1))\r\n                    outputIP +\u003d DELIMITER;\r\n                semiCol \u003d semiCol + lengthOfToken;\r\n            }\r\n        }\r\n        return outputIP;\r\n    }\r\n\r\n    /**\r\n     *  Converts an given IPv4 or IPv6 address into binary format.\r\n     *\r\n     *  @param   IP  An IP Address to be converted back into binary format\r\n     *  @return  Binary representation of given IP Address.\r\n     */\r\n    private String convertToBinary(String IP) {\r\n        StringTokenizer octetToken \u003d new StringTokenizer(IP);\r\n        String output \u003d \"\";\r\n        int radix \u003d 0;\r\n        if (isIPv4)\r\n            radix \u003d 10;\r\n        else if (isIPv6)\r\n            radix \u003d 16;\r\n        while (octetToken.hasMoreTokens()) {\r\n            String out \u003d Integer.toBinaryString(Integer.parseInt(octetToken.nextToken(\".:\"), radix));\r\n            while (out.length() \u003c lengthOfToken) out \u003d \"0\" + out;\r\n            output +\u003d out;\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     *  Gets the starting IP of an IP range.\r\n     *\r\n     *  @return     Starting IP of IP range\r\n     */\r\n    private String getStartIP() {\r\n        StringTokenizer tokens \u003d new StringTokenizer(IPRangeAddress, \" -\");\r\n        return tokens.nextToken();\r\n    }\r\n}\r\n",
    "package": "ipac",
    "classname": "BinaryCalculate",
    "id": "/EvoSuiteBenchmark/original/82_ipcalculator/src/main/java/ipac/BinaryCalculate_1Test.java",
    "test_prompt": "// BinaryCalculate_1Test.java\npackage ipac;\n\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BinaryCalculate}.\n* It contains ten unit test cases for the {@link BinaryCalculate#subBinary(String, String)} method.\n*/\nclass BinaryCalculate_1Test {",
    "method_signature": "subBinary(String, String)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// BinaryCalculate.java\npackage ipac;\r\n\r\nimport java.text.*;\r\nimport java.util.*;\r\nimport java.math.*;\r\n\r\n/**\r\n *  Title: Binary Calculator\r\n *  \u003cbr\u003eDescription: Background binary calculator for the IPAC program\r\n *  \u003cbr\u003eCopyright (c) 2006-7 Jason Wang\r\n *\r\n *  \u003cp\u003eThis program is free software; you can redistribute it and/or\r\n *  \u003cbr\u003emodify it under the terms of the GNU General Public License\r\n *  \u003cbr\u003eas published by the Free Software Foundation; either version 2\r\n *  \u003cbr\u003eof the License, or (at your option) any later version.\r\n *\r\n *  \u003cbr\u003eThis program is distributed in the hope that it will be useful,\r\n *  \u003cbr\u003ebut WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  \u003cbr\u003eMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  \u003cbr\u003eGNU General Public License for more details.\r\n *\r\n *  \u003cbr\u003eYou should have received a copy of the GNU General Public License\r\n *  \u003cbr\u003ealong with this program; if not, write to the Free Software\r\n *  \u003cbr\u003eFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\r\n *                                                              02110-1301, USA.\r\n *\r\n *  @author      Jason Wang\r\n *  @version     v0.19\r\n */\r\npublic class BinaryCalculate {\r\n\r\n    boolean isIPv4 \u003d false;\r\n\r\n    boolean isIPv6 \u003d false;\r\n\r\n    String currentIP \u003d \"\";\r\n\r\n    String fullReassembler \u003d \"\";\r\n\r\n    String DELIMITER \u003d \"\";\r\n\r\n    int lengthOfToken \u003d 0;\r\n\r\n    String IPRangeAddress \u003d \"\";\r\n\r\n    String usableRange \u003d \"\";\r\n\r\n    int semiCol \u003d 0;\r\n\r\n    String prefix \u003d \"\";\r\n\r\n    BigInteger totalIPAddresses;\r\n\r\n    int MAXPREFIX \u003d 0;\r\n\r\n    /**\r\n     *  Calculates the sum of two binary numbers.\r\n     *\r\n     *  @param       num1    The starting binary number\r\n     *  @param       num2    The binary number to be added to the starting binary\r\n     *  @return      The sum of two binary numbers.\r\n     */\r\n    public String addBinary(String num1, String num2) {\r\n        boolean carry \u003d false;\r\n        int size1 \u003d num1.length() - 1;\r\n        int size2 \u003d num2.length() - 1;\r\n        String sum \u003d \"\";\r\n        if (size2 \u003e size1) {\r\n            String s \u003d num1;\r\n            num1 \u003d num2;\r\n            num2 \u003d s;\r\n            int n \u003d size1;\r\n            size1 \u003d size2;\r\n            size2 \u003d n;\r\n        }\r\n        for (; size2 \u003e\u003d 0; size1--, size2--) {\r\n            if (num1.charAt(size1) \u003d\u003d \u00270\u0027 \u0026\u0026 num2.charAt(size2) \u003d\u003d \u00270\u0027) {\r\n                if (!carry)\r\n                    sum \u003d \"0\" + sum;\r\n                else\r\n                    sum \u003d \"1\" + sum;\r\n                carry \u003d false;\r\n            } else if (num1.charAt(size1) \u003d\u003d \u00271\u0027 \u0026\u0026 num2.charAt(size2) \u003d\u003d \u00270\u0027) {\r\n                if (!carry)\r\n                    sum \u003d \"1\" + sum;\r\n                else {\r\n                    sum \u003d \"0\" + sum;\r\n                    carry \u003d true;\r\n                }\r\n            } else if (num1.charAt(size1) \u003d\u003d \u00270\u0027 \u0026\u0026 num2.charAt(size2) \u003d\u003d \u00271\u0027) {\r\n                if (!carry)\r\n                    sum \u003d \"1\" + sum;\r\n                else {\r\n                    sum \u003d \"0\" + sum;\r\n                    carry \u003d true;\r\n                }\r\n            } else if (num1.charAt(size1) \u003d\u003d \u00271\u0027 \u0026\u0026 num2.charAt(size2) \u003d\u003d \u00271\u0027) {\r\n                if (!carry)\r\n                    sum \u003d \"0\" + sum;\r\n                else\r\n                    sum \u003d \"1\" + sum;\r\n                carry \u003d true;\r\n            }\r\n        }\r\n        for (; size1 \u003e\u003d 0; size1--) {\r\n            if (num1.charAt(size1) \u003d\u003d \u00270\u0027) {\r\n                if (!carry)\r\n                    sum \u003d \"0\" + sum;\r\n                else\r\n                    sum \u003d \"1\" + sum;\r\n                carry \u003d false;\r\n            } else if (num1.charAt(size1) \u003d\u003d \u00271\u0027) {\r\n                if (!carry)\r\n                    sum \u003d \"1\" + sum;\r\n                else {\r\n                    sum \u003d \"0\" + sum;\r\n                    carry \u003d true;\r\n                }\r\n            }\r\n        }\r\n        if (carry)\r\n            sum \u003d \"1\" + sum;\r\n        return sum;\r\n    }\r\n\r\n    /**\r\n     *  Subtracts two binary numbers.\r\n     *\r\n     *  @param       num1    The starting binary number\r\n     *  @param       num2    The binary number to be subtracted from the\r\n     *                       starting binary\r\n     *  @return      The difference of two binary numbers.\r\n     */\r\n    public String subBinary(String num1, String num2) {\r\n        String diff \u003d \"\";\r\n        String twosComp \u003d \"\";\r\n        int size \u003d num1.length() - 1;\r\n        for (; size \u003e\u003d 0; size--) {\r\n            if (num1.charAt(size) \u003d\u003d \u00270\u0027)\r\n                twosComp \u003d \"1\" + twosComp;\r\n            else\r\n                twosComp \u003d \"0\" + twosComp;\r\n        }\r\n        twosComp \u003d \"0\" + twosComp;\r\n        twosComp \u003d addBinary(twosComp, \"1\");\r\n        diff \u003d addBinary(twosComp, num2);\r\n        return diff.substring(1);\r\n    }\r\n\r\n    /**\r\n     *  Calculates the IP Range from the provided IP address and number of IP\r\n     *  addresses. The results are stored into an \u003ccode\u003estring\u003c/code\u003e to be\r\n     *  returned to the method that called it.\r\n     *\r\n     *  @param      IP          The starting IP address (subnet) in binary\r\n     *  @param      IPPrefix    Number of IP addresses in binary\r\n     *  @return     Results string\r\n     */\r\n    public String IPCalculate(String IP, String IPPrefix) {\r\n        String outputText \u003d \"\";\r\n        checkIPType(IP.length() - 1);\r\n        String subnet \u003d convert(IP);\r\n        String netmask \u003d getNetmask(IPPrefix);\r\n        calculate(IP, IPPrefix);\r\n        outputText +\u003d \"Total Range: \" + IPRangeAddress + \"\\n\";\r\n        outputText +\u003d \"Usable Range: \" + usableRange + \"\\n\";\r\n        NumberFormat formatter \u003d new DecimalFormat(\"###,###,###,###,###,###,###,###,###,###,###,###,###\");\r\n        outputText +\u003d \"\\n\";\r\n        outputText +\u003d \"Total usable IP Addresses : \" + formatter.format(totalIPAddresses) + \"\\n\";\r\n        outputText +\u003d \"Subnet: \" + subnet + \"\\n\";\r\n        outputText +\u003d \"Binary Subnet: \" + getBinaryIP(IP) + \"\\n\";\r\n        outputText +\u003d \"Broadcast Address: \" + currentIP + \"\\n\";\r\n        outputText +\u003d \"Prefix: \" + prefix + \"\\n\";\r\n        checkIPType(netmask.length() - 1);\r\n        String outputNetmask \u003d convert(netmask);\r\n        outputText +\u003d \"Netmask: \" + outputNetmask + \"\\n\";\r\n        String binaryNetmask \u003d getBinaryIP(netmask);\r\n        outputText +\u003d \"Binary Netmask: \" + binaryNetmask;\r\n        return outputText;\r\n    }\r\n\r\n    /**\r\n     *  Adds delimiters back into a given IP address\r\n     *\r\n     *  @param      binaryIP     binary IP address with no delimiters\r\n     *  @return     binary IP address with delimiters\r\n     */\r\n    private String getBinaryIP(String binaryIP) {\r\n        String output \u003d \"\";\r\n        checkIPType(binaryIP.length() - 1);\r\n        for (int i \u003d 0; i \u003c MAXPREFIX; i++) {\r\n            output +\u003d binaryIP.charAt(i);\r\n            if (i \u003d\u003d semiCol) {\r\n                if (i !\u003d (binaryIP.length() - 1))\r\n                    output +\u003d DELIMITER;\r\n                semiCol +\u003d lengthOfToken;\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     *  Gets the netmask from a binary representation of number of IP addresses\r\n     *\r\n     *  @param      binaryIP     binary representation of number of IP addresses\r\n     *  @return     netmask of \u003ccode\u003ebinaryIP\u003c/code\u003e\r\n     */\r\n    private String getNetmask(String binaryIP) {\r\n        String invertedIPPrefix \u003d \"\";\r\n        for (int i \u003d 0; i \u003c MAXPREFIX; i++) {\r\n            if (binaryIP.charAt(i) \u003d\u003d \u00270\u0027)\r\n                invertedIPPrefix +\u003d \"1\";\r\n            else\r\n                invertedIPPrefix +\u003d \"0\";\r\n        }\r\n        return invertedIPPrefix;\r\n    }\r\n\r\n    /**\r\n     *  Calculates the IP Range from the provided IP address and number of IP\r\n     *  addresses. The results are stored as declared global variables for many\r\n     *  other methods to manipulate or use.\r\n     *  \u003cbr\u003eThis method also detects if the provided of number of IP addresses\r\n     *  to be calculate exceeds past these IP addresses: 255.255.255.255 and\r\n     *  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF, as further IP addresses exceeds\r\n     *  the IP addressing bounds.\r\n     *  \u003cbr\u003eThis method also calculates the prefix size needed to accomodate all\r\n     *  the IP Addresses to be listed and stores it as a global variable for use\r\n     *  in other methods.\r\n     *\r\n     *  @param       subnet              The starting IP address (subnet)\r\n     *  @param       noOfIPAddresses     Number of IP addresses\r\n     */\r\n    private void calculate(String subnet, String noOfIPAddresses) {\r\n        currentIP \u003d \"\";\r\n        String number1 \u003d subnet;\r\n        String usableIP \u003d \"\";\r\n        String IP \u003d addBinary(subnet, noOfIPAddresses);\r\n        checkIPType(subnet.length() - 1);\r\n        String addSubBinary \u003d \"\";\r\n        for (int i \u003d 0; i \u003c (MAXPREFIX - 1); i++) {\r\n            addSubBinary +\u003d \"0\";\r\n        }\r\n        addSubBinary +\u003d \"1\";\r\n        subnet \u003d addBinary(addSubBinary, subnet);\r\n        usableIP \u003d convert(subnet);\r\n        subnet \u003d subBinary(addSubBinary, subnet);\r\n        checkIPType(subnet.length() - 1);\r\n        currentIP \u003d convert(subnet);\r\n        fullReassembler \u003d \"\";\r\n        semiCol \u003d lengthOfToken - 1;\r\n        IPRangeAddress \u003d currentIP + \" -- \";\r\n        usableRange \u003d usableIP + \" -- \";\r\n        currentIP \u003d \"\";\r\n        String currentIPString \u003d \"\";\r\n        if (IP.length() \u003e 128) {\r\n            IPRangeAddress \u003d IPRangeAddress + \"FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF\";\r\n            currentIP \u003d \"FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF\";\r\n        } else if (IP.length() \u003e 32 \u0026\u0026 IP.length() \u003c 128) {\r\n            IPRangeAddress \u003d IPRangeAddress + \"255.255.255.255\";\r\n            currentIP \u003d \"255.255.255.255\";\r\n        } else {\r\n            String IPRangeEnd \u003d subBinary(addSubBinary, IP);\r\n            String endIP \u003d convert(IPRangeEnd);\r\n            usableRange \u003d usableRange + endIP;\r\n            checkIPType(subnet.length() - 1);\r\n            currentIP \u003d convert(IP);\r\n            IPRangeAddress \u003d IPRangeAddress + currentIP;\r\n        }\r\n        currentIPString \u003d subBinary(number1, convertToBinary(currentIP));\r\n        totalIPAddresses \u003d new BigInteger(currentIPString, 2);\r\n        totalIPAddresses \u003d totalIPAddresses.add(new BigInteger(\"1\"));\r\n        int prefixInt \u003d 0;\r\n        if (totalIPAddresses.doubleValue() \u003c 2)\r\n            prefixInt \u003d MAXPREFIX;\r\n        else if (totalIPAddresses.doubleValue() \u003d\u003d 2)\r\n            prefixInt \u003d MAXPREFIX - 2;\r\n        else {\r\n            if (isIPv6) {\r\n                String currentIPString1 \u003d currentIPString.substring(0, 64);\r\n                BigInteger totalIPAddresses1 \u003d new BigInteger(currentIPString1, 2);\r\n                double prefixInt1 \u003d 0;\r\n                if (totalIPAddresses1.doubleValue() \u003e 0)\r\n                    prefixInt1 \u003d Math.log(totalIPAddresses1.doubleValue()) / Math.log(2.0);\r\n                String currentIPString2 \u003d currentIPString.substring(64, 128);\r\n                BigInteger totalIPAddresses2 \u003d new BigInteger(currentIPString2, 2);\r\n                double prefixInt2 \u003d Math.log(totalIPAddresses2.doubleValue()) / Math.log(2.0);\r\n                prefixInt \u003d MAXPREFIX - (int) Math.ceil(prefixInt1) - (int) Math.round(prefixInt2);\r\n            } else if (isIPv4)\r\n                prefixInt \u003d MAXPREFIX - (int) Math.ceil(Math.log(totalIPAddresses.doubleValue()) / Math.log(2.0));\r\n        }\r\n        prefix \u003d \"/\" + prefixInt;\r\n        totalIPAddresses \u003d totalIPAddresses.subtract(new BigInteger(\"2\"));\r\n    }\r\n\r\n    /**\r\n     *  Calculates the IP Range from the provided IP address and number of IP\r\n     *  addresses from the smaller prefix. The results are stored into an array\r\n     *  to be printed using \u003ccode\u003e\u003cb\u003eOutput.java\u003c/b\u003e\u003c/code\u003e.\r\n     *\r\n     *  @param       IP          The starting IP address (subnet)\r\n     *  @param       IPPrefix    Number of IP addresses for smaller prefix\r\n     *  @param       noPrefix    Number of smaller prefixes within the total\r\n     *                           prefix\r\n     *  @param       endPrefix   Prefix of total number of IP Addresses\r\n     */\r\n    public void prefixInPrefixCalculate(String IP, String IPPrefix, int noPrefix, String endPrefix) {\r\n        try {\r\n            String[][] output \u003d new String[noPrefix + 8][2];\r\n            checkIPType(IP.length() - 1);\r\n            String subnet \u003d convert(IP);\r\n            String netmask \u003d getNetmask(IPPrefix);\r\n            calculate(IP, IPPrefix);\r\n            for (int i \u003d 0; i \u003c noPrefix; i++) {\r\n                calculate(IP, IPPrefix);\r\n                output[i][0] \u003d getStartIP() + \" \" + prefix;\r\n                output[i][1] \u003d IPRangeAddress;\r\n                IP \u003d addBinary(fullReassembler.substring(MAXPREFIX, fullReassembler.length()), Integer.toBinaryString(1));\r\n                fullReassembler \u003d \"\";\r\n            }\r\n            output[noPrefix + 1][0] \u003d \"Total usable IP Addresses :\";\r\n            NumberFormat formatter \u003d new DecimalFormat(\"###,###,###,###,###,###,###,###,###,###,###,###,###\");\r\n            output[noPrefix + 1][1] \u003d formatter.format(totalIPAddresses.multiply(new BigInteger(noPrefix + \"\"))) + \" \";\r\n            output[noPrefix + 2][0] \u003d \"Subnet:\";\r\n            output[noPrefix + 2][1] \u003d subnet;\r\n            StringTokenizer subnetTokens \u003d new StringTokenizer(convertToBinary(subnet), DELIMITER);\r\n            String paddedSubnet \u003d \"\";\r\n            while (subnetTokens.hasMoreTokens()) {\r\n                String unpaddedSubnet \u003d subnetTokens.nextToken();\r\n                while (unpaddedSubnet.length() \u003c lengthOfToken) unpaddedSubnet \u003d \"0\" + unpaddedSubnet;\r\n                paddedSubnet +\u003d unpaddedSubnet;\r\n            }\r\n            output[noPrefix + 3][0] \u003d \"Binary Subnet:\";\r\n            output[noPrefix + 3][1] \u003d getBinaryIP(paddedSubnet);\r\n            output[noPrefix + 4][0] \u003d \"Broadcast Address:\";\r\n            output[noPrefix + 4][1] \u003d currentIP;\r\n            output[noPrefix + 5][0] \u003d \"Prefix:\";\r\n            output[noPrefix + 5][1] \u003d endPrefix;\r\n            checkIPType(netmask.length() - 1);\r\n            output[noPrefix + 6][0] \u003d \"Netmask\";\r\n            output[noPrefix + 6][1] \u003d convert(netmask);\r\n            output[noPrefix + 7][0] \u003d \"Binary Netmask:\";\r\n            output[noPrefix + 7][1] \u003d getBinaryIP(netmask);\r\n            new Output(output);\r\n        } catch (OutOfMemoryError e) {\r\n            new IPv4().displayError(\"Your computer does not have sufficent \" + \"memory to process this query.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  Determines whether an IP Address provided in binary form is an IPv4 or\r\n     *  an IPv6 by the length of the binary string.\r\n     *\r\n     *  @param       size1    Length of binary string\r\n     */\r\n    private void checkIPType(int size1) {\r\n        if (size1 \u003d\u003d 31) {\r\n            isIPv4 \u003d true;\r\n            lengthOfToken \u003d 8;\r\n            DELIMITER \u003d \".\";\r\n            MAXPREFIX \u003d 32;\r\n        } else if (size1 \u003d\u003d 127) {\r\n            isIPv6 \u003d true;\r\n            lengthOfToken \u003d 16;\r\n            DELIMITER \u003d \":\";\r\n            MAXPREFIX \u003d 128;\r\n        }\r\n        semiCol \u003d lengthOfToken - 1;\r\n    }\r\n\r\n    /**\r\n     *  Reconstructs the dotted-decimal or hexidecimal IP address with\r\n     *  seperators from an given binary IP Address. The reconstructed IP address\r\n     *  is stored as a global declared variable, \u003ccode\u003ecurrentIP\u003c/code\u003e.\r\n     *\r\n     *  @param   IP  An binary IP Address to be converted back into\r\n     *               dotted-decimal or hexidecimal format\r\n     */\r\n    private String convert(String binaryIP) {\r\n        String outputIP \u003d \"\";\r\n        String reassembler \u003d \"\";\r\n        for (int i \u003d 0; i \u003c binaryIP.length(); i++) {\r\n            reassembler +\u003d binaryIP.charAt(i);\r\n            fullReassembler +\u003d binaryIP.charAt(i);\r\n            if (i \u003d\u003d semiCol) {\r\n                if (isIPv4) {\r\n                    outputIP +\u003d Integer.parseInt(reassembler, 2);\r\n                    reassembler \u003d \"\";\r\n                } else if (isIPv6) {\r\n                    outputIP +\u003d Integer.toHexString(Integer.parseInt(reassembler, 2));\r\n                    reassembler \u003d \"\";\r\n                }\r\n                if (i !\u003d (binaryIP.length() - 1))\r\n                    outputIP +\u003d DELIMITER;\r\n                semiCol \u003d semiCol + lengthOfToken;\r\n            }\r\n        }\r\n        return outputIP;\r\n    }\r\n\r\n    /**\r\n     *  Converts an given IPv4 or IPv6 address into binary format.\r\n     *\r\n     *  @param   IP  An IP Address to be converted back into binary format\r\n     *  @return  Binary representation of given IP Address.\r\n     */\r\n    private String convertToBinary(String IP) {\r\n        StringTokenizer octetToken \u003d new StringTokenizer(IP);\r\n        String output \u003d \"\";\r\n        int radix \u003d 0;\r\n        if (isIPv4)\r\n            radix \u003d 10;\r\n        else if (isIPv6)\r\n            radix \u003d 16;\r\n        while (octetToken.hasMoreTokens()) {\r\n            String out \u003d Integer.toBinaryString(Integer.parseInt(octetToken.nextToken(\".:\"), radix));\r\n            while (out.length() \u003c lengthOfToken) out \u003d \"0\" + out;\r\n            output +\u003d out;\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     *  Gets the starting IP of an IP range.\r\n     *\r\n     *  @return     Starting IP of IP range\r\n     */\r\n    private String getStartIP() {\r\n        StringTokenizer tokens \u003d new StringTokenizer(IPRangeAddress, \" -\");\r\n        return tokens.nextToken();\r\n    }\r\n}\r\n",
    "package": "ipac",
    "classname": "BinaryCalculate",
    "id": "/EvoSuiteBenchmark/original/82_ipcalculator/src/main/java/ipac/BinaryCalculate_2Test.java",
    "test_prompt": "// BinaryCalculate_2Test.java\npackage ipac;\n\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BinaryCalculate}.\n* It contains ten unit test cases for the {@link BinaryCalculate#IPCalculate(String, String)} method.\n*/\nclass BinaryCalculate_2Test {",
    "method_signature": "IPCalculate(String, String)",
    "suffix": "2"
  }
]