[
  {
    "numberTests": "ten",
    "original_code": "// Decompiler.java\n/* ***** BEGIN LICENSE BLOCK *****\n *\n * Version: MPL 1.1\n *\n * The contents of this file are subject to the Mozilla Public License\n * Version 1.1 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License\n * at http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * See the License for the specific language governing rights and\n * limitations under the License.\n *\n * The Original Code is org/mozilla/javascript/Decompiler.java,\n * a component of the Rhino Library ( http://www.mozilla.org/rhino/ )\n * This file is a modification of the Original Code developed\n * for YUI Compressor.\n *\n * The Initial Developer of the Original Code is Mozilla Foundation\n *\n * Copyright (c) 2009 Mozilla Foundation. All Rights Reserved.\n *\n * Contributor(s):  Yahoo! Inc. 2009\n *\n * ***** END LICENSE BLOCK ***** */\npackage org.mozilla.javascript;\n\n/**\n * The following class save decompilation information about the source.\n * Source information is returned from the parser as a String\n * associated with function nodes and with the toplevel script.  When\n * saved in the constant pool of a class, this string will be UTF-8\n * encoded, and token values will occupy a single byte.\n *\n * Source is saved (mostly) as token numbers.  The tokens saved pretty\n * much correspond to the token stream of a \u0027canonical\u0027 representation\n * of the input program, as directed by the parser.  (There were a few\n * cases where tokens could have been left out where decompiler could\n * easily reconstruct them, but I left them in for clarity).  (I also\n * looked adding source collection to TokenStream instead, where I\n * could have limited the changes to a few lines in getToken... but\n * this wouldn\u0027t have saved any space in the resulting source\n * representation, and would have meant that I\u0027d have to duplicate\n * parser logic in the decompiler to disambiguate situations where\n * newlines are important.)  The function decompile expands the\n * tokens back into their string representations, using simple\n * lookahead to correct spacing and indentation.\n *\n * Assignments are saved as two-token pairs (Token.ASSIGN, op). Number tokens\n * are stored inline, as a NUMBER token, a character representing the type, and\n * either 1 or 4 characters representing the bit-encoding of the number.  String\n * types NAME, STRING and OBJECT are currently stored as a token type,\n * followed by a character giving the length of the string (assumed to\n * be less than 2^16), followed by the characters of the string\n * inlined into the source string.  Changing this to some reference to\n * to the string in the compiled class\u0027 constant pool would probably\n * save a lot of space... but would require some method of deriving\n * the final constant pool entry from information available at parse\n * time.\n */\npublic class Decompiler {\n\n    /**\n     * Flag to indicate that the decompilation should omit the\n     * function header and trailing brace.\n     */\n    public static final int ONLY_BODY_FLAG \u003d 1 \u003c\u003c 0;\n\n    /**\n     * Flag to indicate that the decompilation generates toSource result.\n     */\n    public static final int TO_SOURCE_FLAG \u003d 1 \u003c\u003c 1;\n\n    /**\n     * Decompilation property to specify initial ident value.\n     */\n    public static final int INITIAL_INDENT_PROP \u003d 1;\n\n    /**\n     * Decompilation property to specify default identation offset.\n     */\n    public static final int INDENT_GAP_PROP \u003d 2;\n\n    /**\n     * Decompilation property to specify identation offset for case labels.\n     */\n    public static final int CASE_GAP_PROP \u003d 3;\n\n    // Marker to denote the last RC of function so it can be distinguished from\n    // the last RC of object literals in case of function expressions\n    private static final int FUNCTION_END \u003d Token.LAST_TOKEN + 1;\n\n    String getEncodedSource() {\n        return sourceToString(0);\n    }\n\n    int getCurrentOffset() {\n        return sourceTop;\n    }\n\n    int markFunctionStart(int functionType) {\n        int savedOffset \u003d getCurrentOffset();\n        addToken(Token.FUNCTION);\n        append((char) functionType);\n        return savedOffset;\n    }\n\n    int markFunctionEnd(int functionStart) {\n        int offset \u003d getCurrentOffset();\n        append((char) FUNCTION_END);\n        return offset;\n    }\n\n    void addToken(int token) {\n        if (!(0 \u003c\u003d token \u0026\u0026 token \u003c\u003d Token.LAST_TOKEN))\n            throw new IllegalArgumentException();\n        append((char) token);\n    }\n\n    void addEOL(int token) {\n        if (!(0 \u003c\u003d token \u0026\u0026 token \u003c\u003d Token.LAST_TOKEN))\n            throw new IllegalArgumentException();\n        append((char) token);\n        append((char) Token.EOL);\n    }\n\n    void addName(String str) {\n        addToken(Token.NAME);\n        appendString(str);\n    }\n\n    void addString(String str) {\n        addToken(Token.STRING);\n        appendString(str);\n    }\n\n    void addRegexp(String regexp, String flags) {\n        addToken(Token.REGEXP);\n        appendString(\u0027/\u0027 + regexp + \u0027/\u0027 + flags);\n    }\n\n    void addJScriptConditionalComment(String str) {\n        addToken(Token.CONDCOMMENT);\n        appendString(str);\n    }\n\n    void addPreservedComment(String str) {\n        addToken(Token.KEEPCOMMENT);\n        appendString(str);\n    }\n\n    void addNumber(double n) {\n        addToken(Token.NUMBER);\n        /* encode the number in the source stream.\n         * Save as NUMBER type (char | char char char char)\n         * where type is\n         * \u0027D\u0027 - double, \u0027S\u0027 - short, \u0027J\u0027 - long.\n\n         * We need to retain float vs. integer type info to keep the\n         * behavior of liveconnect type-guessing the same after\n         * decompilation.  (Liveconnect tries to present 1.0 to Java\n         * as a float/double)\n         * OPT: This is no longer true. We could compress the format.\n\n         * This may not be the most space-efficient encoding;\n         * the chars created below may take up to 3 bytes in\n         * constant pool UTF-8 encoding, so a Double could take\n         * up to 12 bytes.\n         */\n        long lbits \u003d (long) n;\n        if (lbits !\u003d n) {\n            // if it\u0027s floating point, save as a Double bit pattern.\n            // (12/15/97 our scanner only returns Double for f.p.)\n            lbits \u003d Double.doubleToLongBits(n);\n            append(\u0027D\u0027);\n            append((char) (lbits \u003e\u003e 48));\n            append((char) (lbits \u003e\u003e 32));\n            append((char) (lbits \u003e\u003e 16));\n            append((char) lbits);\n        } else {\n            // we can ignore negative values, bc they\u0027re already prefixed\n            // by NEG\n            if (lbits \u003c 0)\n                Kit.codeBug();\n            // will it fit in a char?\n            // this gives a short encoding for integer values up to 2^16.\n            if (lbits \u003c\u003d Character.MAX_VALUE) {\n                append(\u0027S\u0027);\n                append((char) lbits);\n            } else {\n                // Integral, but won\u0027t fit in a char. Store as a long.\n                append(\u0027J\u0027);\n                append((char) (lbits \u003e\u003e 48));\n                append((char) (lbits \u003e\u003e 32));\n                append((char) (lbits \u003e\u003e 16));\n                append((char) lbits);\n            }\n        }\n    }\n\n    private void appendString(String str) {\n        int L \u003d str.length();\n        int lengthEncodingSize \u003d 1;\n        if (L \u003e\u003d 0x8000) {\n            lengthEncodingSize \u003d 2;\n        }\n        int nextTop \u003d sourceTop + lengthEncodingSize + L;\n        if (nextTop \u003e sourceBuffer.length) {\n            increaseSourceCapacity(nextTop);\n        }\n        if (L \u003e\u003d 0x8000) {\n            // Use 2 chars to encode strings exceeding 32K, were the highest\n            // bit in the first char indicates presence of the next byte\n            sourceBuffer[sourceTop] \u003d (char) (0x8000 | (L \u003e\u003e\u003e 16));\n            ++sourceTop;\n        }\n        sourceBuffer[sourceTop] \u003d (char) L;\n        ++sourceTop;\n        str.getChars(0, L, sourceBuffer, sourceTop);\n        sourceTop \u003d nextTop;\n    }\n\n    private void append(char c) {\n        if (sourceTop \u003d\u003d sourceBuffer.length) {\n            increaseSourceCapacity(sourceTop + 1);\n        }\n        sourceBuffer[sourceTop] \u003d c;\n        ++sourceTop;\n    }\n\n    private void increaseSourceCapacity(int minimalCapacity) {\n        // Call this only when capacity increase is must\n        if (minimalCapacity \u003c\u003d sourceBuffer.length)\n            Kit.codeBug();\n        int newCapacity \u003d sourceBuffer.length * 2;\n        if (newCapacity \u003c minimalCapacity) {\n            newCapacity \u003d minimalCapacity;\n        }\n        char[] tmp \u003d new char[newCapacity];\n        System.arraycopy(sourceBuffer, 0, tmp, 0, sourceTop);\n        sourceBuffer \u003d tmp;\n    }\n\n    private String sourceToString(int offset) {\n        if (offset \u003c 0 || sourceTop \u003c offset)\n            Kit.codeBug();\n        return new String(sourceBuffer, offset, sourceTop - offset);\n    }\n\n    /**\n     * Decompile the source information associated with this js\n     * function/script back into a string.  For the most part, this\n     * just means translating tokens back to their string\n     * representations; there\u0027s a little bit of lookahead logic to\n     * decide the proper spacing/indentation.  Most of the work in\n     * mapping the original source to the prettyprinted decompiled\n     * version is done by the parser.\n     *\n     * @param source encoded source tree presentation\n     *\n     * @param flags flags to select output format\n     *\n     * @param properties indentation properties\n     */\n    public static String decompile(String source, int flags, UintMap properties) {\n        int length \u003d source.length();\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        int indent \u003d properties.getInt(INITIAL_INDENT_PROP, 0);\n        if (indent \u003c 0)\n            throw new IllegalArgumentException();\n        int indentGap \u003d properties.getInt(INDENT_GAP_PROP, 4);\n        if (indentGap \u003c 0)\n            throw new IllegalArgumentException();\n        int caseGap \u003d properties.getInt(CASE_GAP_PROP, 2);\n        if (caseGap \u003c 0)\n            throw new IllegalArgumentException();\n        StringBuffer result \u003d new StringBuffer();\n        boolean justFunctionBody \u003d (0 !\u003d (flags \u0026 Decompiler.ONLY_BODY_FLAG));\n        boolean toSource \u003d (0 !\u003d (flags \u0026 Decompiler.TO_SOURCE_FLAG));\n        // Spew tokens in source, for debugging.\n        // as TYPE number char\n        if (printSource) {\n            System.err.println(\"length:\" + length);\n            for (int i \u003d 0; i \u003c length; ++i) {\n                // Note that tokenToName will fail unless Context.printTrees\n                // is true.\n                String tokenname \u003d null;\n                if (Token.printNames) {\n                    tokenname \u003d Token.name(source.charAt(i));\n                }\n                if (tokenname \u003d\u003d null) {\n                    tokenname \u003d \"---\";\n                }\n                String pad \u003d tokenname.length() \u003e 7 ? \"\\t\" : \"\\t\\t\";\n                System.err.println(tokenname + pad + (int) source.charAt(i) + \"\\t\u0027\" + ScriptRuntime.escapeString(source.substring(i, i + 1)) + \"\u0027\");\n            }\n            System.err.println();\n        }\n        int braceNesting \u003d 0;\n        boolean afterFirstEOL \u003d false;\n        int i \u003d 0;\n        int topFunctionType;\n        if (source.charAt(i) \u003d\u003d Token.SCRIPT) {\n            ++i;\n            topFunctionType \u003d -1;\n        } else {\n            topFunctionType \u003d source.charAt(i + 1);\n        }\n        if (!toSource) {\n            // add an initial newline to exactly match js.\n            result.append(\u0027\\n\u0027);\n            for (int j \u003d 0; j \u003c indent; j++) result.append(\u0027 \u0027);\n        } else {\n            if (topFunctionType \u003d\u003d FunctionNode.FUNCTION_EXPRESSION) {\n                result.append(\u0027(\u0027);\n            }\n        }\n        while (i \u003c length) {\n            switch(source.charAt(i)) {\n                case Token.GET:\n                case Token.SET:\n                    result.append(source.charAt(i) \u003d\u003d Token.GET ? \"get \" : \"set \");\n                    ++i;\n                    i \u003d printSourceString(source, i + 1, false, result);\n                    // Now increment one more to get past the FUNCTION token\n                    ++i;\n                    break;\n                case Token.NAME:\n                case // re-wrapped in \u0027/\u0027s in parser...\n                Token.REGEXP:\n                    i \u003d printSourceString(source, i + 1, false, result);\n                    continue;\n                case Token.STRING:\n                    i \u003d printSourceString(source, i + 1, true, result);\n                    continue;\n                case Token.NUMBER:\n                    i \u003d printSourceNumber(source, i + 1, result);\n                    continue;\n                case Token.TRUE:\n                    result.append(\"true\");\n                    break;\n                case Token.FALSE:\n                    result.append(\"false\");\n                    break;\n                case Token.NULL:\n                    result.append(\"null\");\n                    break;\n                case Token.THIS:\n                    result.append(\"this\");\n                    break;\n                case Token.FUNCTION:\n                    // skip function type\n                    ++i;\n                    result.append(\"function \");\n                    break;\n                case FUNCTION_END:\n                    // Do nothing\n                    break;\n                case Token.COMMA:\n                    result.append(\", \");\n                    break;\n                case Token.LC:\n                    ++braceNesting;\n                    if (Token.EOL \u003d\u003d getNext(source, length, i))\n                        indent +\u003d indentGap;\n                    result.append(\u0027{\u0027);\n                    break;\n                case Token.RC:\n                    {\n                        --braceNesting;\n                        /* don\u0027t print the closing RC if it closes the\n                 * toplevel function and we\u0027re called from\n                 * decompileFunctionBody.\n                 */\n                        if (justFunctionBody \u0026\u0026 braceNesting \u003d\u003d 0)\n                            break;\n                        result.append(\u0027}\u0027);\n                        switch(getNext(source, length, i)) {\n                            case Token.EOL:\n                            case FUNCTION_END:\n                                indent -\u003d indentGap;\n                                break;\n                            case Token.WHILE:\n                            case Token.ELSE:\n                                indent -\u003d indentGap;\n                                result.append(\u0027 \u0027);\n                                break;\n                        }\n                        break;\n                    }\n                case Token.LP:\n                    result.append(\u0027(\u0027);\n                    break;\n                case Token.RP:\n                    result.append(\u0027)\u0027);\n                    if (Token.LC \u003d\u003d getNext(source, length, i))\n                        result.append(\u0027 \u0027);\n                    break;\n                case Token.LB:\n                    result.append(\u0027[\u0027);\n                    break;\n                case Token.RB:\n                    result.append(\u0027]\u0027);\n                    break;\n                case Token.EOL:\n                    {\n                        if (toSource)\n                            break;\n                        boolean newLine \u003d true;\n                        if (!afterFirstEOL) {\n                            afterFirstEOL \u003d true;\n                            if (justFunctionBody) {\n                                /* throw away just added \u0027function name(...) {\u0027\n                         * and restore the original indent\n                         */\n                                result.setLength(0);\n                                indent -\u003d indentGap;\n                                newLine \u003d false;\n                            }\n                        }\n                        if (newLine) {\n                            result.append(\u0027\\n\u0027);\n                        }\n                        /* add indent if any tokens remain,\n                 * less setback if next token is\n                 * a label, case or default.\n                 */\n                        if (i + 1 \u003c length) {\n                            int less \u003d 0;\n                            int nextToken \u003d source.charAt(i + 1);\n                            if (nextToken \u003d\u003d Token.CASE || nextToken \u003d\u003d Token.DEFAULT) {\n                                less \u003d indentGap - caseGap;\n                            } else if (nextToken \u003d\u003d Token.RC) {\n                                less \u003d indentGap;\n                            } else /* elaborate check against label... skip past a\n                     * following inlined NAME and look for a COLON.\n                     */\n                            if (nextToken \u003d\u003d Token.NAME) {\n                                int afterName \u003d getSourceStringEnd(source, i + 2);\n                                if (source.charAt(afterName) \u003d\u003d Token.COLON)\n                                    less \u003d indentGap;\n                            }\n                            for (; less \u003c indent; less++) result.append(\u0027 \u0027);\n                        }\n                        break;\n                    }\n                case Token.DOT:\n                    result.append(\u0027.\u0027);\n                    break;\n                case Token.NEW:\n                    result.append(\"new \");\n                    break;\n                case Token.DELPROP:\n                    result.append(\"delete \");\n                    break;\n                case Token.IF:\n                    result.append(\"if \");\n                    break;\n                case Token.ELSE:\n                    result.append(\"else \");\n                    break;\n                case Token.FOR:\n                    result.append(\"for \");\n                    break;\n                case Token.IN:\n                    result.append(\" in \");\n                    break;\n                case Token.WITH:\n                    result.append(\"with \");\n                    break;\n                case Token.WHILE:\n                    result.append(\"while \");\n                    break;\n                case Token.DO:\n                    result.append(\"do \");\n                    break;\n                case Token.TRY:\n                    result.append(\"try \");\n                    break;\n                case Token.CATCH:\n                    result.append(\"catch \");\n                    break;\n                case Token.FINALLY:\n                    result.append(\"finally \");\n                    break;\n                case Token.THROW:\n                    result.append(\"throw \");\n                    break;\n                case Token.SWITCH:\n                    result.append(\"switch \");\n                    break;\n                case Token.BREAK:\n                    result.append(\"break\");\n                    if (Token.NAME \u003d\u003d getNext(source, length, i))\n                        result.append(\u0027 \u0027);\n                    break;\n                case Token.CONTINUE:\n                    result.append(\"continue\");\n                    if (Token.NAME \u003d\u003d getNext(source, length, i))\n                        result.append(\u0027 \u0027);\n                    break;\n                case Token.CASE:\n                    result.append(\"case \");\n                    break;\n                case Token.DEFAULT:\n                    result.append(\"default\");\n                    break;\n                case Token.RETURN:\n                    result.append(\"return\");\n                    if (Token.SEMI !\u003d getNext(source, length, i))\n                        result.append(\u0027 \u0027);\n                    break;\n                case Token.VAR:\n                    result.append(\"var \");\n                    break;\n                case Token.LET:\n                    result.append(\"let \");\n                    break;\n                case Token.SEMI:\n                    result.append(\u0027;\u0027);\n                    if (Token.EOL !\u003d getNext(source, length, i)) {\n                        // separators in FOR\n                        result.append(\u0027 \u0027);\n                    }\n                    break;\n                case Token.ASSIGN:\n                    result.append(\" \u003d \");\n                    break;\n                case Token.ASSIGN_ADD:\n                    result.append(\" +\u003d \");\n                    break;\n                case Token.ASSIGN_SUB:\n                    result.append(\" -\u003d \");\n                    break;\n                case Token.ASSIGN_MUL:\n                    result.append(\" *\u003d \");\n                    break;\n                case Token.ASSIGN_DIV:\n                    result.append(\" /\u003d \");\n                    break;\n                case Token.ASSIGN_MOD:\n                    result.append(\" %\u003d \");\n                    break;\n                case Token.ASSIGN_BITOR:\n                    result.append(\" |\u003d \");\n                    break;\n                case Token.ASSIGN_BITXOR:\n                    result.append(\" ^\u003d \");\n                    break;\n                case Token.ASSIGN_BITAND:\n                    result.append(\" \u0026\u003d \");\n                    break;\n                case Token.ASSIGN_LSH:\n                    result.append(\" \u003c\u003c\u003d \");\n                    break;\n                case Token.ASSIGN_RSH:\n                    result.append(\" \u003e\u003e\u003d \");\n                    break;\n                case Token.ASSIGN_URSH:\n                    result.append(\" \u003e\u003e\u003e\u003d \");\n                    break;\n                case Token.HOOK:\n                    result.append(\" ? \");\n                    break;\n                case Token.OBJECTLIT:\n                    // pun OBJECTLIT to mean colon in objlit property\n                    // initialization.\n                    // This needs to be distinct from COLON in the general case\n                    // to distinguish from the colon in a ternary... which needs\n                    // different spacing.\n                    result.append(\u0027:\u0027);\n                    break;\n                case Token.COLON:\n                    if (Token.EOL \u003d\u003d getNext(source, length, i))\n                        // it\u0027s the end of a label\n                        result.append(\u0027:\u0027);\n                    else\n                        // it\u0027s the middle part of a ternary\n                        result.append(\" : \");\n                    break;\n                case Token.OR:\n                    result.append(\" || \");\n                    break;\n                case Token.AND:\n                    result.append(\" \u0026\u0026 \");\n                    break;\n                case Token.BITOR:\n                    result.append(\" | \");\n                    break;\n                case Token.BITXOR:\n                    result.append(\" ^ \");\n                    break;\n                case Token.BITAND:\n                    result.append(\" \u0026 \");\n                    break;\n                case Token.SHEQ:\n                    result.append(\" \u003d\u003d\u003d \");\n                    break;\n                case Token.SHNE:\n                    result.append(\" !\u003d\u003d \");\n                    break;\n                case Token.EQ:\n                    result.append(\" \u003d\u003d \");\n                    break;\n                case Token.NE:\n                    result.append(\" !\u003d \");\n                    break;\n                case Token.LE:\n                    result.append(\" \u003c\u003d \");\n                    break;\n                case Token.LT:\n                    result.append(\" \u003c \");\n                    break;\n                case Token.GE:\n                    result.append(\" \u003e\u003d \");\n                    break;\n                case Token.GT:\n                    result.append(\" \u003e \");\n                    break;\n                case Token.INSTANCEOF:\n                    result.append(\" instanceof \");\n                    break;\n                case Token.LSH:\n                    result.append(\" \u003c\u003c \");\n                    break;\n                case Token.RSH:\n                    result.append(\" \u003e\u003e \");\n                    break;\n                case Token.URSH:\n                    result.append(\" \u003e\u003e\u003e \");\n                    break;\n                case Token.TYPEOF:\n                    result.append(\"typeof \");\n                    break;\n                case Token.VOID:\n                    result.append(\"void \");\n                    break;\n                case Token.CONST:\n                    result.append(\"const \");\n                    break;\n                case Token.YIELD:\n                    result.append(\"yield \");\n                    break;\n                case Token.NOT:\n                    result.append(\u0027!\u0027);\n                    break;\n                case Token.BITNOT:\n                    result.append(\u0027~\u0027);\n                    break;\n                case Token.POS:\n                    result.append(\u0027+\u0027);\n                    break;\n                case Token.NEG:\n                    result.append(\u0027-\u0027);\n                    break;\n                case Token.INC:\n                    result.append(\"++\");\n                    break;\n                case Token.DEC:\n                    result.append(\"--\");\n                    break;\n                case Token.ADD:\n                    result.append(\" + \");\n                    break;\n                case Token.SUB:\n                    result.append(\" - \");\n                    break;\n                case Token.MUL:\n                    result.append(\" * \");\n                    break;\n                case Token.DIV:\n                    result.append(\" / \");\n                    break;\n                case Token.MOD:\n                    result.append(\" % \");\n                    break;\n                case Token.COLONCOLON:\n                    result.append(\"::\");\n                    break;\n                case Token.DOTDOT:\n                    result.append(\"..\");\n                    break;\n                case Token.DOTQUERY:\n                    result.append(\".(\");\n                    break;\n                case Token.XMLATTR:\n                    result.append(\u0027@\u0027);\n                    break;\n                default:\n                    // If we don\u0027t know how to decompile it, raise an exception.\n                    throw new RuntimeException(\"Token: \" + Token.name(source.charAt(i)));\n            }\n            ++i;\n        }\n        if (!toSource) {\n            // add that trailing newline if it\u0027s an outermost function.\n            if (!justFunctionBody)\n                result.append(\u0027\\n\u0027);\n        } else {\n            if (topFunctionType \u003d\u003d FunctionNode.FUNCTION_EXPRESSION) {\n                result.append(\u0027)\u0027);\n            }\n        }\n        return result.toString();\n    }\n\n    private static int getNext(String source, int length, int i) {\n        return (i + 1 \u003c length) ? source.charAt(i + 1) : Token.EOF;\n    }\n\n    private static int getSourceStringEnd(String source, int offset) {\n        return printSourceString(source, offset, false, null);\n    }\n\n    private static int printSourceString(String source, int offset, boolean asQuotedString, StringBuffer sb) {\n        int length \u003d source.charAt(offset);\n        ++offset;\n        if ((0x8000 \u0026 length) !\u003d 0) {\n            length \u003d ((0x7FFF \u0026 length) \u003c\u003c 16) | source.charAt(offset);\n            ++offset;\n        }\n        if (sb !\u003d null) {\n            String str \u003d source.substring(offset, offset + length);\n            if (!asQuotedString) {\n                sb.append(str);\n            } else {\n                sb.append(\u0027\"\u0027);\n                sb.append(ScriptRuntime.escapeString(str));\n                sb.append(\u0027\"\u0027);\n            }\n        }\n        return offset + length;\n    }\n\n    private static int printSourceNumber(String source, int offset, StringBuffer sb) {\n        double number \u003d 0.0;\n        char type \u003d source.charAt(offset);\n        ++offset;\n        if (type \u003d\u003d \u0027S\u0027) {\n            if (sb !\u003d null) {\n                int ival \u003d source.charAt(offset);\n                number \u003d ival;\n            }\n            ++offset;\n        } else if (type \u003d\u003d \u0027J\u0027 || type \u003d\u003d \u0027D\u0027) {\n            if (sb !\u003d null) {\n                long lbits;\n                lbits \u003d (long) source.charAt(offset) \u003c\u003c 48;\n                lbits |\u003d (long) source.charAt(offset + 1) \u003c\u003c 32;\n                lbits |\u003d (long) source.charAt(offset + 2) \u003c\u003c 16;\n                lbits |\u003d source.charAt(offset + 3);\n                if (type \u003d\u003d \u0027J\u0027) {\n                    number \u003d lbits;\n                } else {\n                    number \u003d Double.longBitsToDouble(lbits);\n                }\n            }\n            offset +\u003d 4;\n        } else {\n            // Bad source\n            throw new RuntimeException();\n        }\n        if (sb !\u003d null) {\n            sb.append(ScriptRuntime.numberToString(number, 10));\n        }\n        return offset;\n    }\n\n    private char[] sourceBuffer \u003d new char[128];\n\n    // Per script/function source buffer top: parent source does not include a\n    // nested functions source and uses function index as a reference instead.\n    private int sourceTop;\n\n    // whether to do a debug print of the source information, when decompiling.\n    private static final boolean printSource \u003d false;\n}\n",
    "package": "org.mozilla.javascript",
    "classname": "Decompiler",
    "id": "/EvoSuiteBenchmark/original/22_byuic/src/main/java/org/mozilla/javascript/Decompiler.java",
    "test_prompt": "// DecompilerTest.java\npackage org.mozilla.javascript;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Decompiler}.\n* It contains ten unit test cases for the {@link Decompiler#decompile(String, int, UintMap)} method.\n*/\nclass DecompilerTest {",
    "method_signature": "decompile(String, int, UintMap)",
    "suffix": ""
  }
]