[
  {
    "numberTests": "ten",
    "original_code": "// SimpleCharStream.java\n/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.1 */\n/* JavaCCOptions:STATIC\u003dfalse,SUPPORT_CLASS_VISIBILITY_PUBLIC\u003dtrue */\npackage com.pmdesigns.jvc.tools;\n\n/**\n * An implementation of interface CharStream, where the stream is assumed to\n * contain only ASCII characters (without unicode processing).\n */\npublic class SimpleCharStream {\n\n    /**\n     * Whether parser is static.\n     */\n    public static final boolean staticFlag \u003d false;\n\n    int bufsize;\n\n    int available;\n\n    int tokenBegin;\n\n    /**\n     * Position in buffer.\n     */\n    public int bufpos \u003d -1;\n\n    protected int[] bufline;\n\n    protected int[] bufcolumn;\n\n    protected int column \u003d 0;\n\n    protected int line \u003d 1;\n\n    protected boolean prevCharIsCR \u003d false;\n\n    protected boolean prevCharIsLF \u003d false;\n\n    protected java.io.Reader inputStream;\n\n    protected char[] buffer;\n\n    protected int maxNextCharInd \u003d 0;\n\n    protected int inBuf \u003d 0;\n\n    protected int tabSize \u003d 8;\n\n    protected void setTabSize(int i) {\n        tabSize \u003d i;\n    }\n\n    protected int getTabSize(int i) {\n        return tabSize;\n    }\n\n    protected void ExpandBuff(boolean wrapAround) {\n        char[] newbuffer \u003d new char[bufsize + 2048];\n        int[] newbufline \u003d new int[bufsize + 2048];\n        int[] newbufcolumn \u003d new int[bufsize + 2048];\n        try {\n            if (wrapAround) {\n                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n                System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);\n                buffer \u003d newbuffer;\n                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n                System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);\n                bufline \u003d newbufline;\n                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n                System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);\n                bufcolumn \u003d newbufcolumn;\n                maxNextCharInd \u003d (bufpos +\u003d (bufsize - tokenBegin));\n            } else {\n                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n                buffer \u003d newbuffer;\n                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n                bufline \u003d newbufline;\n                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n                bufcolumn \u003d newbufcolumn;\n                maxNextCharInd \u003d (bufpos -\u003d tokenBegin);\n            }\n        } catch (Throwable t) {\n            throw new Error(t.getMessage());\n        }\n        bufsize +\u003d 2048;\n        available \u003d bufsize;\n        tokenBegin \u003d 0;\n    }\n\n    protected void FillBuff() throws java.io.IOException {\n        if (maxNextCharInd \u003d\u003d available) {\n            if (available \u003d\u003d bufsize) {\n                if (tokenBegin \u003e 2048) {\n                    bufpos \u003d maxNextCharInd \u003d 0;\n                    available \u003d tokenBegin;\n                } else if (tokenBegin \u003c 0)\n                    bufpos \u003d maxNextCharInd \u003d 0;\n                else\n                    ExpandBuff(false);\n            } else if (available \u003e tokenBegin)\n                available \u003d bufsize;\n            else if ((tokenBegin - available) \u003c 2048)\n                ExpandBuff(true);\n            else\n                available \u003d tokenBegin;\n        }\n        int i;\n        try {\n            if ((i \u003d inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) \u003d\u003d -1) {\n                inputStream.close();\n                throw new java.io.IOException();\n            } else\n                maxNextCharInd +\u003d i;\n            return;\n        } catch (java.io.IOException e) {\n            --bufpos;\n            backup(0);\n            if (tokenBegin \u003d\u003d -1)\n                tokenBegin \u003d bufpos;\n            throw e;\n        }\n    }\n\n    /**\n     * Start.\n     */\n    public char BeginToken() throws java.io.IOException {\n        tokenBegin \u003d -1;\n        char c \u003d readChar();\n        tokenBegin \u003d bufpos;\n        return c;\n    }\n\n    protected void UpdateLineColumn(char c) {\n        column++;\n        if (prevCharIsLF) {\n            prevCharIsLF \u003d false;\n            line +\u003d (column \u003d 1);\n        } else if (prevCharIsCR) {\n            prevCharIsCR \u003d false;\n            if (c \u003d\u003d \u0027\\n\u0027) {\n                prevCharIsLF \u003d true;\n            } else\n                line +\u003d (column \u003d 1);\n        }\n        switch(c) {\n            case \u0027\\r\u0027:\n                prevCharIsCR \u003d true;\n                break;\n            case \u0027\\n\u0027:\n                prevCharIsLF \u003d true;\n                break;\n            case \u0027\\t\u0027:\n                column--;\n                column +\u003d (tabSize - (column % tabSize));\n                break;\n            default:\n                break;\n        }\n        bufline[bufpos] \u003d line;\n        bufcolumn[bufpos] \u003d column;\n    }\n\n    /**\n     * Read a character.\n     */\n    public char readChar() throws java.io.IOException {\n        if (inBuf \u003e 0) {\n            --inBuf;\n            if (++bufpos \u003d\u003d bufsize)\n                bufpos \u003d 0;\n            return buffer[bufpos];\n        }\n        if (++bufpos \u003e\u003d maxNextCharInd)\n            FillBuff();\n        char c \u003d buffer[bufpos];\n        UpdateLineColumn(c);\n        return c;\n    }\n\n    /**\n     * @deprecated\n     * @see #getEndColumn\n     */\n    public int getColumn() {\n        return bufcolumn[bufpos];\n    }\n\n    /**\n     * @deprecated\n     * @see #getEndLine\n     */\n    public int getLine() {\n        return bufline[bufpos];\n    }\n\n    /**\n     * Get token end column number.\n     */\n    public int getEndColumn() {\n        return bufcolumn[bufpos];\n    }\n\n    /**\n     * Get token end line number.\n     */\n    public int getEndLine() {\n        return bufline[bufpos];\n    }\n\n    /**\n     * Get token beginning column number.\n     */\n    public int getBeginColumn() {\n        return bufcolumn[tokenBegin];\n    }\n\n    /**\n     * Get token beginning line number.\n     */\n    public int getBeginLine() {\n        return bufline[tokenBegin];\n    }\n\n    /**\n     * Backup a number of characters.\n     */\n    public void backup(int amount) {\n        inBuf +\u003d amount;\n        if ((bufpos -\u003d amount) \u003c 0)\n            bufpos +\u003d bufsize;\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {\n        inputStream \u003d dstream;\n        line \u003d startline;\n        column \u003d startcolumn - 1;\n        available \u003d bufsize \u003d buffersize;\n        buffer \u003d new char[buffersize];\n        bufline \u003d new int[buffersize];\n        bufcolumn \u003d new int[buffersize];\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.Reader dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {\n        inputStream \u003d dstream;\n        line \u003d startline;\n        column \u003d startcolumn - 1;\n        if (buffer \u003d\u003d null || buffersize !\u003d buffer.length) {\n            available \u003d bufsize \u003d buffersize;\n            buffer \u003d new char[buffersize];\n            bufline \u003d new int[buffersize];\n            bufcolumn \u003d new int[buffersize];\n        }\n        prevCharIsLF \u003d prevCharIsCR \u003d false;\n        tokenBegin \u003d inBuf \u003d maxNextCharInd \u003d 0;\n        bufpos \u003d -1;\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.Reader dstream, int startline, int startcolumn) {\n        ReInit(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.Reader dstream) {\n        ReInit(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {\n        this(encoding \u003d\u003d null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {\n        this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {\n        this(dstream, encoding, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {\n        this(dstream, encoding, 1, 1, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {\n        ReInit(encoding \u003d\u003d null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {\n        ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {\n        ReInit(dstream, encoding, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream) {\n        ReInit(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {\n        ReInit(dstream, encoding, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn) {\n        ReInit(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Get token literal value.\n     */\n    public String GetImage() {\n        if (bufpos \u003e\u003d tokenBegin)\n            return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);\n        else\n            return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);\n    }\n\n    /**\n     * Get the suffix.\n     */\n    public char[] GetSuffix(int len) {\n        char[] ret \u003d new char[len];\n        if ((bufpos + 1) \u003e\u003d len)\n            System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);\n        else {\n            System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);\n            System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);\n        }\n        return ret;\n    }\n\n    /**\n     * Reset buffer when finished.\n     */\n    public void Done() {\n        buffer \u003d null;\n        bufline \u003d null;\n        bufcolumn \u003d null;\n    }\n\n    /**\n     * Method to adjust line and column numbers for the start of a token.\n     */\n    public void adjustBeginLineColumn(int newLine, int newCol) {\n        int start \u003d tokenBegin;\n        int len;\n        if (bufpos \u003e\u003d tokenBegin) {\n            len \u003d bufpos - tokenBegin + inBuf + 1;\n        } else {\n            len \u003d bufsize - tokenBegin + bufpos + 1 + inBuf;\n        }\n        int i \u003d 0, j \u003d 0, k \u003d 0;\n        int nextColDiff \u003d 0, columnDiff \u003d 0;\n        while (i \u003c len \u0026\u0026 bufline[j \u003d start % bufsize] \u003d\u003d bufline[k \u003d ++start % bufsize]) {\n            bufline[j] \u003d newLine;\n            nextColDiff \u003d columnDiff + bufcolumn[k] - bufcolumn[j];\n            bufcolumn[j] \u003d newCol + columnDiff;\n            columnDiff \u003d nextColDiff;\n            i++;\n        }\n        if (i \u003c len) {\n            bufline[j] \u003d newLine++;\n            bufcolumn[j] \u003d newCol + columnDiff;\n            while (i++ \u003c len) {\n                if (bufline[j \u003d start % bufsize] !\u003d bufline[++start % bufsize])\n                    bufline[j] \u003d newLine++;\n                else\n                    bufline[j] \u003d newLine;\n            }\n        }\n        line \u003d bufline[j];\n        column \u003d bufcolumn[j];\n    }\n}\n/* JavaCC - OriginalChecksum\u003dd9128cf5d82a12eb06ed3b6fa19acc59 (do not edit this line) */\n",
    "package": "com.pmdesigns.jvc.tools",
    "classname": "SimpleCharStream",
    "id": "/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/SimpleCharStream_0Test.java",
    "test_prompt": "// SimpleCharStream_0Test.java\n/* JavaCCOptions:STATIC\u003dfalse,SUPPORT_CLASS_VISIBILITY_PUBLIC\u003dtrue */\npackage com.pmdesigns.jvc.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCharStream}.\n* It contains ten unit test cases for the {@link SimpleCharStream#BeginToken()} method.\n*/\nclass SimpleCharStream_0Test {",
    "method_signature": "BeginToken()",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// SimpleCharStream.java\n/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.1 */\n/* JavaCCOptions:STATIC\u003dfalse,SUPPORT_CLASS_VISIBILITY_PUBLIC\u003dtrue */\npackage com.pmdesigns.jvc.tools;\n\n/**\n * An implementation of interface CharStream, where the stream is assumed to\n * contain only ASCII characters (without unicode processing).\n */\npublic class SimpleCharStream {\n\n    /**\n     * Whether parser is static.\n     */\n    public static final boolean staticFlag \u003d false;\n\n    int bufsize;\n\n    int available;\n\n    int tokenBegin;\n\n    /**\n     * Position in buffer.\n     */\n    public int bufpos \u003d -1;\n\n    protected int[] bufline;\n\n    protected int[] bufcolumn;\n\n    protected int column \u003d 0;\n\n    protected int line \u003d 1;\n\n    protected boolean prevCharIsCR \u003d false;\n\n    protected boolean prevCharIsLF \u003d false;\n\n    protected java.io.Reader inputStream;\n\n    protected char[] buffer;\n\n    protected int maxNextCharInd \u003d 0;\n\n    protected int inBuf \u003d 0;\n\n    protected int tabSize \u003d 8;\n\n    protected void setTabSize(int i) {\n        tabSize \u003d i;\n    }\n\n    protected int getTabSize(int i) {\n        return tabSize;\n    }\n\n    protected void ExpandBuff(boolean wrapAround) {\n        char[] newbuffer \u003d new char[bufsize + 2048];\n        int[] newbufline \u003d new int[bufsize + 2048];\n        int[] newbufcolumn \u003d new int[bufsize + 2048];\n        try {\n            if (wrapAround) {\n                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n                System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);\n                buffer \u003d newbuffer;\n                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n                System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);\n                bufline \u003d newbufline;\n                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n                System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);\n                bufcolumn \u003d newbufcolumn;\n                maxNextCharInd \u003d (bufpos +\u003d (bufsize - tokenBegin));\n            } else {\n                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n                buffer \u003d newbuffer;\n                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n                bufline \u003d newbufline;\n                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n                bufcolumn \u003d newbufcolumn;\n                maxNextCharInd \u003d (bufpos -\u003d tokenBegin);\n            }\n        } catch (Throwable t) {\n            throw new Error(t.getMessage());\n        }\n        bufsize +\u003d 2048;\n        available \u003d bufsize;\n        tokenBegin \u003d 0;\n    }\n\n    protected void FillBuff() throws java.io.IOException {\n        if (maxNextCharInd \u003d\u003d available) {\n            if (available \u003d\u003d bufsize) {\n                if (tokenBegin \u003e 2048) {\n                    bufpos \u003d maxNextCharInd \u003d 0;\n                    available \u003d tokenBegin;\n                } else if (tokenBegin \u003c 0)\n                    bufpos \u003d maxNextCharInd \u003d 0;\n                else\n                    ExpandBuff(false);\n            } else if (available \u003e tokenBegin)\n                available \u003d bufsize;\n            else if ((tokenBegin - available) \u003c 2048)\n                ExpandBuff(true);\n            else\n                available \u003d tokenBegin;\n        }\n        int i;\n        try {\n            if ((i \u003d inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) \u003d\u003d -1) {\n                inputStream.close();\n                throw new java.io.IOException();\n            } else\n                maxNextCharInd +\u003d i;\n            return;\n        } catch (java.io.IOException e) {\n            --bufpos;\n            backup(0);\n            if (tokenBegin \u003d\u003d -1)\n                tokenBegin \u003d bufpos;\n            throw e;\n        }\n    }\n\n    /**\n     * Start.\n     */\n    public char BeginToken() throws java.io.IOException {\n        tokenBegin \u003d -1;\n        char c \u003d readChar();\n        tokenBegin \u003d bufpos;\n        return c;\n    }\n\n    protected void UpdateLineColumn(char c) {\n        column++;\n        if (prevCharIsLF) {\n            prevCharIsLF \u003d false;\n            line +\u003d (column \u003d 1);\n        } else if (prevCharIsCR) {\n            prevCharIsCR \u003d false;\n            if (c \u003d\u003d \u0027\\n\u0027) {\n                prevCharIsLF \u003d true;\n            } else\n                line +\u003d (column \u003d 1);\n        }\n        switch(c) {\n            case \u0027\\r\u0027:\n                prevCharIsCR \u003d true;\n                break;\n            case \u0027\\n\u0027:\n                prevCharIsLF \u003d true;\n                break;\n            case \u0027\\t\u0027:\n                column--;\n                column +\u003d (tabSize - (column % tabSize));\n                break;\n            default:\n                break;\n        }\n        bufline[bufpos] \u003d line;\n        bufcolumn[bufpos] \u003d column;\n    }\n\n    /**\n     * Read a character.\n     */\n    public char readChar() throws java.io.IOException {\n        if (inBuf \u003e 0) {\n            --inBuf;\n            if (++bufpos \u003d\u003d bufsize)\n                bufpos \u003d 0;\n            return buffer[bufpos];\n        }\n        if (++bufpos \u003e\u003d maxNextCharInd)\n            FillBuff();\n        char c \u003d buffer[bufpos];\n        UpdateLineColumn(c);\n        return c;\n    }\n\n    /**\n     * @deprecated\n     * @see #getEndColumn\n     */\n    public int getColumn() {\n        return bufcolumn[bufpos];\n    }\n\n    /**\n     * @deprecated\n     * @see #getEndLine\n     */\n    public int getLine() {\n        return bufline[bufpos];\n    }\n\n    /**\n     * Get token end column number.\n     */\n    public int getEndColumn() {\n        return bufcolumn[bufpos];\n    }\n\n    /**\n     * Get token end line number.\n     */\n    public int getEndLine() {\n        return bufline[bufpos];\n    }\n\n    /**\n     * Get token beginning column number.\n     */\n    public int getBeginColumn() {\n        return bufcolumn[tokenBegin];\n    }\n\n    /**\n     * Get token beginning line number.\n     */\n    public int getBeginLine() {\n        return bufline[tokenBegin];\n    }\n\n    /**\n     * Backup a number of characters.\n     */\n    public void backup(int amount) {\n        inBuf +\u003d amount;\n        if ((bufpos -\u003d amount) \u003c 0)\n            bufpos +\u003d bufsize;\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {\n        inputStream \u003d dstream;\n        line \u003d startline;\n        column \u003d startcolumn - 1;\n        available \u003d bufsize \u003d buffersize;\n        buffer \u003d new char[buffersize];\n        bufline \u003d new int[buffersize];\n        bufcolumn \u003d new int[buffersize];\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.Reader dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {\n        inputStream \u003d dstream;\n        line \u003d startline;\n        column \u003d startcolumn - 1;\n        if (buffer \u003d\u003d null || buffersize !\u003d buffer.length) {\n            available \u003d bufsize \u003d buffersize;\n            buffer \u003d new char[buffersize];\n            bufline \u003d new int[buffersize];\n            bufcolumn \u003d new int[buffersize];\n        }\n        prevCharIsLF \u003d prevCharIsCR \u003d false;\n        tokenBegin \u003d inBuf \u003d maxNextCharInd \u003d 0;\n        bufpos \u003d -1;\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.Reader dstream, int startline, int startcolumn) {\n        ReInit(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.Reader dstream) {\n        ReInit(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {\n        this(encoding \u003d\u003d null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {\n        this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {\n        this(dstream, encoding, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {\n        this(dstream, encoding, 1, 1, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {\n        ReInit(encoding \u003d\u003d null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {\n        ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {\n        ReInit(dstream, encoding, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream) {\n        ReInit(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {\n        ReInit(dstream, encoding, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn) {\n        ReInit(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Get token literal value.\n     */\n    public String GetImage() {\n        if (bufpos \u003e\u003d tokenBegin)\n            return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);\n        else\n            return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);\n    }\n\n    /**\n     * Get the suffix.\n     */\n    public char[] GetSuffix(int len) {\n        char[] ret \u003d new char[len];\n        if ((bufpos + 1) \u003e\u003d len)\n            System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);\n        else {\n            System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);\n            System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);\n        }\n        return ret;\n    }\n\n    /**\n     * Reset buffer when finished.\n     */\n    public void Done() {\n        buffer \u003d null;\n        bufline \u003d null;\n        bufcolumn \u003d null;\n    }\n\n    /**\n     * Method to adjust line and column numbers for the start of a token.\n     */\n    public void adjustBeginLineColumn(int newLine, int newCol) {\n        int start \u003d tokenBegin;\n        int len;\n        if (bufpos \u003e\u003d tokenBegin) {\n            len \u003d bufpos - tokenBegin + inBuf + 1;\n        } else {\n            len \u003d bufsize - tokenBegin + bufpos + 1 + inBuf;\n        }\n        int i \u003d 0, j \u003d 0, k \u003d 0;\n        int nextColDiff \u003d 0, columnDiff \u003d 0;\n        while (i \u003c len \u0026\u0026 bufline[j \u003d start % bufsize] \u003d\u003d bufline[k \u003d ++start % bufsize]) {\n            bufline[j] \u003d newLine;\n            nextColDiff \u003d columnDiff + bufcolumn[k] - bufcolumn[j];\n            bufcolumn[j] \u003d newCol + columnDiff;\n            columnDiff \u003d nextColDiff;\n            i++;\n        }\n        if (i \u003c len) {\n            bufline[j] \u003d newLine++;\n            bufcolumn[j] \u003d newCol + columnDiff;\n            while (i++ \u003c len) {\n                if (bufline[j \u003d start % bufsize] !\u003d bufline[++start % bufsize])\n                    bufline[j] \u003d newLine++;\n                else\n                    bufline[j] \u003d newLine;\n            }\n        }\n        line \u003d bufline[j];\n        column \u003d bufcolumn[j];\n    }\n}\n/* JavaCC - OriginalChecksum\u003dd9128cf5d82a12eb06ed3b6fa19acc59 (do not edit this line) */\n",
    "package": "com.pmdesigns.jvc.tools",
    "classname": "SimpleCharStream",
    "id": "/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/SimpleCharStream_1Test.java",
    "test_prompt": "// SimpleCharStream_1Test.java\n/* JavaCCOptions:STATIC\u003dfalse,SUPPORT_CLASS_VISIBILITY_PUBLIC\u003dtrue */\npackage com.pmdesigns.jvc.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCharStream}.\n* It contains ten unit test cases for the {@link SimpleCharStream#readChar()} method.\n*/\nclass SimpleCharStream_1Test {",
    "method_signature": "readChar()",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// SimpleCharStream.java\n/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.1 */\n/* JavaCCOptions:STATIC\u003dfalse,SUPPORT_CLASS_VISIBILITY_PUBLIC\u003dtrue */\npackage com.pmdesigns.jvc.tools;\n\n/**\n * An implementation of interface CharStream, where the stream is assumed to\n * contain only ASCII characters (without unicode processing).\n */\npublic class SimpleCharStream {\n\n    /**\n     * Whether parser is static.\n     */\n    public static final boolean staticFlag \u003d false;\n\n    int bufsize;\n\n    int available;\n\n    int tokenBegin;\n\n    /**\n     * Position in buffer.\n     */\n    public int bufpos \u003d -1;\n\n    protected int[] bufline;\n\n    protected int[] bufcolumn;\n\n    protected int column \u003d 0;\n\n    protected int line \u003d 1;\n\n    protected boolean prevCharIsCR \u003d false;\n\n    protected boolean prevCharIsLF \u003d false;\n\n    protected java.io.Reader inputStream;\n\n    protected char[] buffer;\n\n    protected int maxNextCharInd \u003d 0;\n\n    protected int inBuf \u003d 0;\n\n    protected int tabSize \u003d 8;\n\n    protected void setTabSize(int i) {\n        tabSize \u003d i;\n    }\n\n    protected int getTabSize(int i) {\n        return tabSize;\n    }\n\n    protected void ExpandBuff(boolean wrapAround) {\n        char[] newbuffer \u003d new char[bufsize + 2048];\n        int[] newbufline \u003d new int[bufsize + 2048];\n        int[] newbufcolumn \u003d new int[bufsize + 2048];\n        try {\n            if (wrapAround) {\n                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n                System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);\n                buffer \u003d newbuffer;\n                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n                System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);\n                bufline \u003d newbufline;\n                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n                System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);\n                bufcolumn \u003d newbufcolumn;\n                maxNextCharInd \u003d (bufpos +\u003d (bufsize - tokenBegin));\n            } else {\n                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n                buffer \u003d newbuffer;\n                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n                bufline \u003d newbufline;\n                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n                bufcolumn \u003d newbufcolumn;\n                maxNextCharInd \u003d (bufpos -\u003d tokenBegin);\n            }\n        } catch (Throwable t) {\n            throw new Error(t.getMessage());\n        }\n        bufsize +\u003d 2048;\n        available \u003d bufsize;\n        tokenBegin \u003d 0;\n    }\n\n    protected void FillBuff() throws java.io.IOException {\n        if (maxNextCharInd \u003d\u003d available) {\n            if (available \u003d\u003d bufsize) {\n                if (tokenBegin \u003e 2048) {\n                    bufpos \u003d maxNextCharInd \u003d 0;\n                    available \u003d tokenBegin;\n                } else if (tokenBegin \u003c 0)\n                    bufpos \u003d maxNextCharInd \u003d 0;\n                else\n                    ExpandBuff(false);\n            } else if (available \u003e tokenBegin)\n                available \u003d bufsize;\n            else if ((tokenBegin - available) \u003c 2048)\n                ExpandBuff(true);\n            else\n                available \u003d tokenBegin;\n        }\n        int i;\n        try {\n            if ((i \u003d inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) \u003d\u003d -1) {\n                inputStream.close();\n                throw new java.io.IOException();\n            } else\n                maxNextCharInd +\u003d i;\n            return;\n        } catch (java.io.IOException e) {\n            --bufpos;\n            backup(0);\n            if (tokenBegin \u003d\u003d -1)\n                tokenBegin \u003d bufpos;\n            throw e;\n        }\n    }\n\n    /**\n     * Start.\n     */\n    public char BeginToken() throws java.io.IOException {\n        tokenBegin \u003d -1;\n        char c \u003d readChar();\n        tokenBegin \u003d bufpos;\n        return c;\n    }\n\n    protected void UpdateLineColumn(char c) {\n        column++;\n        if (prevCharIsLF) {\n            prevCharIsLF \u003d false;\n            line +\u003d (column \u003d 1);\n        } else if (prevCharIsCR) {\n            prevCharIsCR \u003d false;\n            if (c \u003d\u003d \u0027\\n\u0027) {\n                prevCharIsLF \u003d true;\n            } else\n                line +\u003d (column \u003d 1);\n        }\n        switch(c) {\n            case \u0027\\r\u0027:\n                prevCharIsCR \u003d true;\n                break;\n            case \u0027\\n\u0027:\n                prevCharIsLF \u003d true;\n                break;\n            case \u0027\\t\u0027:\n                column--;\n                column +\u003d (tabSize - (column % tabSize));\n                break;\n            default:\n                break;\n        }\n        bufline[bufpos] \u003d line;\n        bufcolumn[bufpos] \u003d column;\n    }\n\n    /**\n     * Read a character.\n     */\n    public char readChar() throws java.io.IOException {\n        if (inBuf \u003e 0) {\n            --inBuf;\n            if (++bufpos \u003d\u003d bufsize)\n                bufpos \u003d 0;\n            return buffer[bufpos];\n        }\n        if (++bufpos \u003e\u003d maxNextCharInd)\n            FillBuff();\n        char c \u003d buffer[bufpos];\n        UpdateLineColumn(c);\n        return c;\n    }\n\n    /**\n     * @deprecated\n     * @see #getEndColumn\n     */\n    public int getColumn() {\n        return bufcolumn[bufpos];\n    }\n\n    /**\n     * @deprecated\n     * @see #getEndLine\n     */\n    public int getLine() {\n        return bufline[bufpos];\n    }\n\n    /**\n     * Get token end column number.\n     */\n    public int getEndColumn() {\n        return bufcolumn[bufpos];\n    }\n\n    /**\n     * Get token end line number.\n     */\n    public int getEndLine() {\n        return bufline[bufpos];\n    }\n\n    /**\n     * Get token beginning column number.\n     */\n    public int getBeginColumn() {\n        return bufcolumn[tokenBegin];\n    }\n\n    /**\n     * Get token beginning line number.\n     */\n    public int getBeginLine() {\n        return bufline[tokenBegin];\n    }\n\n    /**\n     * Backup a number of characters.\n     */\n    public void backup(int amount) {\n        inBuf +\u003d amount;\n        if ((bufpos -\u003d amount) \u003c 0)\n            bufpos +\u003d bufsize;\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {\n        inputStream \u003d dstream;\n        line \u003d startline;\n        column \u003d startcolumn - 1;\n        available \u003d bufsize \u003d buffersize;\n        buffer \u003d new char[buffersize];\n        bufline \u003d new int[buffersize];\n        bufcolumn \u003d new int[buffersize];\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.Reader dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {\n        inputStream \u003d dstream;\n        line \u003d startline;\n        column \u003d startcolumn - 1;\n        if (buffer \u003d\u003d null || buffersize !\u003d buffer.length) {\n            available \u003d bufsize \u003d buffersize;\n            buffer \u003d new char[buffersize];\n            bufline \u003d new int[buffersize];\n            bufcolumn \u003d new int[buffersize];\n        }\n        prevCharIsLF \u003d prevCharIsCR \u003d false;\n        tokenBegin \u003d inBuf \u003d maxNextCharInd \u003d 0;\n        bufpos \u003d -1;\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.Reader dstream, int startline, int startcolumn) {\n        ReInit(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.Reader dstream) {\n        ReInit(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {\n        this(encoding \u003d\u003d null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {\n        this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {\n        this(dstream, encoding, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {\n        this(dstream, encoding, 1, 1, 4096);\n    }\n\n    /**\n     * Constructor.\n     */\n    public SimpleCharStream(java.io.InputStream dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {\n        ReInit(encoding \u003d\u003d null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {\n        ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {\n        ReInit(dstream, encoding, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream) {\n        ReInit(dstream, 1, 1, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {\n        ReInit(dstream, encoding, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Reinitialise.\n     */\n    public void ReInit(java.io.InputStream dstream, int startline, int startcolumn) {\n        ReInit(dstream, startline, startcolumn, 4096);\n    }\n\n    /**\n     * Get token literal value.\n     */\n    public String GetImage() {\n        if (bufpos \u003e\u003d tokenBegin)\n            return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);\n        else\n            return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);\n    }\n\n    /**\n     * Get the suffix.\n     */\n    public char[] GetSuffix(int len) {\n        char[] ret \u003d new char[len];\n        if ((bufpos + 1) \u003e\u003d len)\n            System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);\n        else {\n            System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);\n            System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);\n        }\n        return ret;\n    }\n\n    /**\n     * Reset buffer when finished.\n     */\n    public void Done() {\n        buffer \u003d null;\n        bufline \u003d null;\n        bufcolumn \u003d null;\n    }\n\n    /**\n     * Method to adjust line and column numbers for the start of a token.\n     */\n    public void adjustBeginLineColumn(int newLine, int newCol) {\n        int start \u003d tokenBegin;\n        int len;\n        if (bufpos \u003e\u003d tokenBegin) {\n            len \u003d bufpos - tokenBegin + inBuf + 1;\n        } else {\n            len \u003d bufsize - tokenBegin + bufpos + 1 + inBuf;\n        }\n        int i \u003d 0, j \u003d 0, k \u003d 0;\n        int nextColDiff \u003d 0, columnDiff \u003d 0;\n        while (i \u003c len \u0026\u0026 bufline[j \u003d start % bufsize] \u003d\u003d bufline[k \u003d ++start % bufsize]) {\n            bufline[j] \u003d newLine;\n            nextColDiff \u003d columnDiff + bufcolumn[k] - bufcolumn[j];\n            bufcolumn[j] \u003d newCol + columnDiff;\n            columnDiff \u003d nextColDiff;\n            i++;\n        }\n        if (i \u003c len) {\n            bufline[j] \u003d newLine++;\n            bufcolumn[j] \u003d newCol + columnDiff;\n            while (i++ \u003c len) {\n                if (bufline[j \u003d start % bufsize] !\u003d bufline[++start % bufsize])\n                    bufline[j] \u003d newLine++;\n                else\n                    bufline[j] \u003d newLine;\n            }\n        }\n        line \u003d bufline[j];\n        column \u003d bufcolumn[j];\n    }\n}\n/* JavaCC - OriginalChecksum\u003dd9128cf5d82a12eb06ed3b6fa19acc59 (do not edit this line) */\n",
    "package": "com.pmdesigns.jvc.tools",
    "classname": "SimpleCharStream",
    "id": "/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/SimpleCharStream_2Test.java",
    "test_prompt": "// SimpleCharStream_2Test.java\n/* JavaCCOptions:STATIC\u003dfalse,SUPPORT_CLASS_VISIBILITY_PUBLIC\u003dtrue */\npackage com.pmdesigns.jvc.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleCharStream}.\n* It contains ten unit test cases for the {@link SimpleCharStream#GetImage()} method.\n*/\nclass SimpleCharStream_2Test {",
    "method_signature": "GetImage()",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// Base64Coder.java\npackage com.pmdesigns.jvc.tools;\r\n\r\n/**\r\n * A Base64 Encoder/Decoder.\r\n *\r\n * \u003cp\u003e\r\n * This class is used to encode and decode data in Base64 format as described in RFC 1521.\r\n *\r\n * \u003cp\u003e\r\n * This is \"Open Source\" software and released under the \u003ca href\u003d\"http://www.gnu.org/licenses/lgpl.html\"\u003eGNU/LGPL\u003c/a\u003e license.\u003cbr\u003e\r\n * It is provided \"as is\" without warranty of any kind.\u003cbr\u003e\r\n * Copyright 2003: Christian d\u0027Heureuse, Inventec Informatik AG, Switzerland.\u003cbr\u003e\r\n * Home page: \u003ca href\u003d\"http://www.source-code.biz\"\u003ewww.source-code.biz\u003c/a\u003e\u003cbr\u003e\r\n *\r\n * \u003cp\u003e\r\n * Version history:\u003cbr\u003e\r\n * 2003-07-22 Christian d\u0027Heureuse (chdh): Module created.\u003cbr\u003e\r\n * 2005-08-11 chdh: Lincense changed from GPL to LGPL.\u003cbr\u003e\r\n * 2006-11-21 chdh:\u003cbr\u003e\r\n *  \u0026nbsp; Method encode(String) renamed to encodeString(String).\u003cbr\u003e\r\n *  \u0026nbsp; Method decode(String) renamed to decodeString(String).\u003cbr\u003e\r\n *  \u0026nbsp; New method encode(byte[],int) added.\u003cbr\u003e\r\n *  \u0026nbsp; New method decode(String) added.\u003cbr\u003e\r\n */\r\npublic class Base64Coder {\r\n\r\n    // Mapping table from 6-bit nibbles to Base64 characters.\r\n    private static char[] map1 \u003d new char[64];\r\n\r\n    static {\r\n        int i \u003d 0;\r\n        for (char c \u003d \u0027A\u0027; c \u003c\u003d \u0027Z\u0027; c++) map1[i++] \u003d c;\r\n        for (char c \u003d \u0027a\u0027; c \u003c\u003d \u0027z\u0027; c++) map1[i++] \u003d c;\r\n        for (char c \u003d \u00270\u0027; c \u003c\u003d \u00279\u0027; c++) map1[i++] \u003d c;\r\n        map1[i++] \u003d \u0027+\u0027;\r\n        map1[i++] \u003d \u0027/\u0027;\r\n    }\r\n\r\n    // Mapping table from Base64 characters to 6-bit nibbles.\r\n    private static byte[] map2 \u003d new byte[128];\r\n\r\n    static {\r\n        for (int i \u003d 0; i \u003c map2.length; i++) map2[i] \u003d -1;\r\n        for (int i \u003d 0; i \u003c 64; i++) map2[map1[i]] \u003d (byte) i;\r\n    }\r\n\r\n    /**\r\n     * Encodes a string into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param s  a String to be encoded.\r\n     * @return   A String with the Base64 encoded data.\r\n     */\r\n    public static String encodeString(String s) {\r\n        return new String(encode(s.getBytes()));\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in  an array containing the data bytes to be encoded.\r\n     * @return    A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in) {\r\n        return encode(in, in.length);\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in   an array containing the data bytes to be encoded.\r\n     * @param iLen number of bytes to process in \u003ccode\u003ein\u003c/code\u003e.\r\n     * @return     A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in, int iLen) {\r\n        // output length without padding\r\n        int oDataLen \u003d (iLen * 4 + 2) / 3;\r\n        // output length including padding\r\n        int oLen \u003d ((iLen + 2) / 3) * 4;\r\n        char[] out \u003d new char[oLen];\r\n        int ip \u003d 0;\r\n        int op \u003d 0;\r\n        while (ip \u003c iLen) {\r\n            int i0 \u003d in[ip++] \u0026 0xff;\r\n            int i1 \u003d ip \u003c iLen ? in[ip++] \u0026 0xff : 0;\r\n            int i2 \u003d ip \u003c iLen ? in[ip++] \u0026 0xff : 0;\r\n            int o0 \u003d i0 \u003e\u003e\u003e 2;\r\n            int o1 \u003d ((i0 \u0026 3) \u003c\u003c 4) | (i1 \u003e\u003e\u003e 4);\r\n            int o2 \u003d ((i1 \u0026 0xf) \u003c\u003c 2) | (i2 \u003e\u003e\u003e 6);\r\n            int o3 \u003d i2 \u0026 0x3F;\r\n            out[op++] \u003d map1[o0];\r\n            out[op++] \u003d map1[o1];\r\n            out[op] \u003d op \u003c oDataLen ? map1[o2] : \u0027\u003d\u0027;\r\n            op++;\r\n            out[op] \u003d op \u003c oDataLen ? map1[o3] : \u0027\u003d\u0027;\r\n            op++;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Decodes a string from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   A String containing the decoded data.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static String decodeString(String s) {\r\n        return new String(decode(s));\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   An array containing the decoded data bytes.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(String s) {\r\n        return decode(s.toCharArray());\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * No blanks or line breaks are allowed within the Base64 encoded data.\r\n     * @param in  a character array containing the Base64 encoded data.\r\n     * @return    An array containing the decoded data bytes.\r\n     * @throws    IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(char[] in) {\r\n        int iLen \u003d in.length;\r\n        if (iLen % 4 !\u003d 0)\r\n            throw new IllegalArgumentException(\"Length of Base64 encoded input string is not a multiple of 4.\");\r\n        while (iLen \u003e 0 \u0026\u0026 in[iLen - 1] \u003d\u003d \u0027\u003d\u0027) iLen--;\r\n        int oLen \u003d (iLen * 3) / 4;\r\n        byte[] out \u003d new byte[oLen];\r\n        int ip \u003d 0;\r\n        int op \u003d 0;\r\n        while (ip \u003c iLen) {\r\n            int i0 \u003d in[ip++];\r\n            int i1 \u003d in[ip++];\r\n            int i2 \u003d ip \u003c iLen ? in[ip++] : \u0027A\u0027;\r\n            int i3 \u003d ip \u003c iLen ? in[ip++] : \u0027A\u0027;\r\n            if (i0 \u003e 127 || i1 \u003e 127 || i2 \u003e 127 || i3 \u003e 127)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int b0 \u003d map2[i0];\r\n            int b1 \u003d map2[i1];\r\n            int b2 \u003d map2[i2];\r\n            int b3 \u003d map2[i3];\r\n            if (b0 \u003c 0 || b1 \u003c 0 || b2 \u003c 0 || b3 \u003c 0)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int o0 \u003d (b0 \u003c\u003c 2) | (b1 \u003e\u003e\u003e 4);\r\n            int o1 \u003d ((b1 \u0026 0xf) \u003c\u003c 4) | (b2 \u003e\u003e\u003e 2);\r\n            int o2 \u003d ((b2 \u0026 3) \u003c\u003c 6) | b3;\r\n            out[op++] \u003d (byte) o0;\r\n            if (op \u003c oLen)\r\n                out[op++] \u003d (byte) o1;\r\n            if (op \u003c oLen)\r\n                out[op++] \u003d (byte) o2;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    // Dummy constructor.\r\n    private Base64Coder() {\r\n    }\r\n}\r\n// end class Base64Coder\r\n",
    "package": "com.pmdesigns.jvc.tools",
    "classname": "Base64Coder",
    "id": "/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/Base64Coder_0Test.java",
    "test_prompt": "// Base64Coder_0Test.java\npackage com.pmdesigns.jvc.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64Coder}.\n* It contains ten unit test cases for the {@link Base64Coder#encodeString(String)} method.\n*/\nclass Base64Coder_0Test {",
    "method_signature": "encodeString(String)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// Base64Coder.java\npackage com.pmdesigns.jvc.tools;\r\n\r\n/**\r\n * A Base64 Encoder/Decoder.\r\n *\r\n * \u003cp\u003e\r\n * This class is used to encode and decode data in Base64 format as described in RFC 1521.\r\n *\r\n * \u003cp\u003e\r\n * This is \"Open Source\" software and released under the \u003ca href\u003d\"http://www.gnu.org/licenses/lgpl.html\"\u003eGNU/LGPL\u003c/a\u003e license.\u003cbr\u003e\r\n * It is provided \"as is\" without warranty of any kind.\u003cbr\u003e\r\n * Copyright 2003: Christian d\u0027Heureuse, Inventec Informatik AG, Switzerland.\u003cbr\u003e\r\n * Home page: \u003ca href\u003d\"http://www.source-code.biz\"\u003ewww.source-code.biz\u003c/a\u003e\u003cbr\u003e\r\n *\r\n * \u003cp\u003e\r\n * Version history:\u003cbr\u003e\r\n * 2003-07-22 Christian d\u0027Heureuse (chdh): Module created.\u003cbr\u003e\r\n * 2005-08-11 chdh: Lincense changed from GPL to LGPL.\u003cbr\u003e\r\n * 2006-11-21 chdh:\u003cbr\u003e\r\n *  \u0026nbsp; Method encode(String) renamed to encodeString(String).\u003cbr\u003e\r\n *  \u0026nbsp; Method decode(String) renamed to decodeString(String).\u003cbr\u003e\r\n *  \u0026nbsp; New method encode(byte[],int) added.\u003cbr\u003e\r\n *  \u0026nbsp; New method decode(String) added.\u003cbr\u003e\r\n */\r\npublic class Base64Coder {\r\n\r\n    // Mapping table from 6-bit nibbles to Base64 characters.\r\n    private static char[] map1 \u003d new char[64];\r\n\r\n    static {\r\n        int i \u003d 0;\r\n        for (char c \u003d \u0027A\u0027; c \u003c\u003d \u0027Z\u0027; c++) map1[i++] \u003d c;\r\n        for (char c \u003d \u0027a\u0027; c \u003c\u003d \u0027z\u0027; c++) map1[i++] \u003d c;\r\n        for (char c \u003d \u00270\u0027; c \u003c\u003d \u00279\u0027; c++) map1[i++] \u003d c;\r\n        map1[i++] \u003d \u0027+\u0027;\r\n        map1[i++] \u003d \u0027/\u0027;\r\n    }\r\n\r\n    // Mapping table from Base64 characters to 6-bit nibbles.\r\n    private static byte[] map2 \u003d new byte[128];\r\n\r\n    static {\r\n        for (int i \u003d 0; i \u003c map2.length; i++) map2[i] \u003d -1;\r\n        for (int i \u003d 0; i \u003c 64; i++) map2[map1[i]] \u003d (byte) i;\r\n    }\r\n\r\n    /**\r\n     * Encodes a string into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param s  a String to be encoded.\r\n     * @return   A String with the Base64 encoded data.\r\n     */\r\n    public static String encodeString(String s) {\r\n        return new String(encode(s.getBytes()));\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in  an array containing the data bytes to be encoded.\r\n     * @return    A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in) {\r\n        return encode(in, in.length);\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in   an array containing the data bytes to be encoded.\r\n     * @param iLen number of bytes to process in \u003ccode\u003ein\u003c/code\u003e.\r\n     * @return     A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in, int iLen) {\r\n        // output length without padding\r\n        int oDataLen \u003d (iLen * 4 + 2) / 3;\r\n        // output length including padding\r\n        int oLen \u003d ((iLen + 2) / 3) * 4;\r\n        char[] out \u003d new char[oLen];\r\n        int ip \u003d 0;\r\n        int op \u003d 0;\r\n        while (ip \u003c iLen) {\r\n            int i0 \u003d in[ip++] \u0026 0xff;\r\n            int i1 \u003d ip \u003c iLen ? in[ip++] \u0026 0xff : 0;\r\n            int i2 \u003d ip \u003c iLen ? in[ip++] \u0026 0xff : 0;\r\n            int o0 \u003d i0 \u003e\u003e\u003e 2;\r\n            int o1 \u003d ((i0 \u0026 3) \u003c\u003c 4) | (i1 \u003e\u003e\u003e 4);\r\n            int o2 \u003d ((i1 \u0026 0xf) \u003c\u003c 2) | (i2 \u003e\u003e\u003e 6);\r\n            int o3 \u003d i2 \u0026 0x3F;\r\n            out[op++] \u003d map1[o0];\r\n            out[op++] \u003d map1[o1];\r\n            out[op] \u003d op \u003c oDataLen ? map1[o2] : \u0027\u003d\u0027;\r\n            op++;\r\n            out[op] \u003d op \u003c oDataLen ? map1[o3] : \u0027\u003d\u0027;\r\n            op++;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Decodes a string from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   A String containing the decoded data.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static String decodeString(String s) {\r\n        return new String(decode(s));\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   An array containing the decoded data bytes.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(String s) {\r\n        return decode(s.toCharArray());\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * No blanks or line breaks are allowed within the Base64 encoded data.\r\n     * @param in  a character array containing the Base64 encoded data.\r\n     * @return    An array containing the decoded data bytes.\r\n     * @throws    IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(char[] in) {\r\n        int iLen \u003d in.length;\r\n        if (iLen % 4 !\u003d 0)\r\n            throw new IllegalArgumentException(\"Length of Base64 encoded input string is not a multiple of 4.\");\r\n        while (iLen \u003e 0 \u0026\u0026 in[iLen - 1] \u003d\u003d \u0027\u003d\u0027) iLen--;\r\n        int oLen \u003d (iLen * 3) / 4;\r\n        byte[] out \u003d new byte[oLen];\r\n        int ip \u003d 0;\r\n        int op \u003d 0;\r\n        while (ip \u003c iLen) {\r\n            int i0 \u003d in[ip++];\r\n            int i1 \u003d in[ip++];\r\n            int i2 \u003d ip \u003c iLen ? in[ip++] : \u0027A\u0027;\r\n            int i3 \u003d ip \u003c iLen ? in[ip++] : \u0027A\u0027;\r\n            if (i0 \u003e 127 || i1 \u003e 127 || i2 \u003e 127 || i3 \u003e 127)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int b0 \u003d map2[i0];\r\n            int b1 \u003d map2[i1];\r\n            int b2 \u003d map2[i2];\r\n            int b3 \u003d map2[i3];\r\n            if (b0 \u003c 0 || b1 \u003c 0 || b2 \u003c 0 || b3 \u003c 0)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int o0 \u003d (b0 \u003c\u003c 2) | (b1 \u003e\u003e\u003e 4);\r\n            int o1 \u003d ((b1 \u0026 0xf) \u003c\u003c 4) | (b2 \u003e\u003e\u003e 2);\r\n            int o2 \u003d ((b2 \u0026 3) \u003c\u003c 6) | b3;\r\n            out[op++] \u003d (byte) o0;\r\n            if (op \u003c oLen)\r\n                out[op++] \u003d (byte) o1;\r\n            if (op \u003c oLen)\r\n                out[op++] \u003d (byte) o2;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    // Dummy constructor.\r\n    private Base64Coder() {\r\n    }\r\n}\r\n// end class Base64Coder\r\n",
    "package": "com.pmdesigns.jvc.tools",
    "classname": "Base64Coder",
    "id": "/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/Base64Coder_1Test.java",
    "test_prompt": "// Base64Coder_1Test.java\npackage com.pmdesigns.jvc.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64Coder}.\n* It contains ten unit test cases for the {@link Base64Coder#encode(byte[])} method.\n*/\nclass Base64Coder_1Test {",
    "method_signature": "encode(byte[])",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// Base64Coder.java\npackage com.pmdesigns.jvc.tools;\r\n\r\n/**\r\n * A Base64 Encoder/Decoder.\r\n *\r\n * \u003cp\u003e\r\n * This class is used to encode and decode data in Base64 format as described in RFC 1521.\r\n *\r\n * \u003cp\u003e\r\n * This is \"Open Source\" software and released under the \u003ca href\u003d\"http://www.gnu.org/licenses/lgpl.html\"\u003eGNU/LGPL\u003c/a\u003e license.\u003cbr\u003e\r\n * It is provided \"as is\" without warranty of any kind.\u003cbr\u003e\r\n * Copyright 2003: Christian d\u0027Heureuse, Inventec Informatik AG, Switzerland.\u003cbr\u003e\r\n * Home page: \u003ca href\u003d\"http://www.source-code.biz\"\u003ewww.source-code.biz\u003c/a\u003e\u003cbr\u003e\r\n *\r\n * \u003cp\u003e\r\n * Version history:\u003cbr\u003e\r\n * 2003-07-22 Christian d\u0027Heureuse (chdh): Module created.\u003cbr\u003e\r\n * 2005-08-11 chdh: Lincense changed from GPL to LGPL.\u003cbr\u003e\r\n * 2006-11-21 chdh:\u003cbr\u003e\r\n *  \u0026nbsp; Method encode(String) renamed to encodeString(String).\u003cbr\u003e\r\n *  \u0026nbsp; Method decode(String) renamed to decodeString(String).\u003cbr\u003e\r\n *  \u0026nbsp; New method encode(byte[],int) added.\u003cbr\u003e\r\n *  \u0026nbsp; New method decode(String) added.\u003cbr\u003e\r\n */\r\npublic class Base64Coder {\r\n\r\n    // Mapping table from 6-bit nibbles to Base64 characters.\r\n    private static char[] map1 \u003d new char[64];\r\n\r\n    static {\r\n        int i \u003d 0;\r\n        for (char c \u003d \u0027A\u0027; c \u003c\u003d \u0027Z\u0027; c++) map1[i++] \u003d c;\r\n        for (char c \u003d \u0027a\u0027; c \u003c\u003d \u0027z\u0027; c++) map1[i++] \u003d c;\r\n        for (char c \u003d \u00270\u0027; c \u003c\u003d \u00279\u0027; c++) map1[i++] \u003d c;\r\n        map1[i++] \u003d \u0027+\u0027;\r\n        map1[i++] \u003d \u0027/\u0027;\r\n    }\r\n\r\n    // Mapping table from Base64 characters to 6-bit nibbles.\r\n    private static byte[] map2 \u003d new byte[128];\r\n\r\n    static {\r\n        for (int i \u003d 0; i \u003c map2.length; i++) map2[i] \u003d -1;\r\n        for (int i \u003d 0; i \u003c 64; i++) map2[map1[i]] \u003d (byte) i;\r\n    }\r\n\r\n    /**\r\n     * Encodes a string into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param s  a String to be encoded.\r\n     * @return   A String with the Base64 encoded data.\r\n     */\r\n    public static String encodeString(String s) {\r\n        return new String(encode(s.getBytes()));\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in  an array containing the data bytes to be encoded.\r\n     * @return    A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in) {\r\n        return encode(in, in.length);\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in   an array containing the data bytes to be encoded.\r\n     * @param iLen number of bytes to process in \u003ccode\u003ein\u003c/code\u003e.\r\n     * @return     A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in, int iLen) {\r\n        // output length without padding\r\n        int oDataLen \u003d (iLen * 4 + 2) / 3;\r\n        // output length including padding\r\n        int oLen \u003d ((iLen + 2) / 3) * 4;\r\n        char[] out \u003d new char[oLen];\r\n        int ip \u003d 0;\r\n        int op \u003d 0;\r\n        while (ip \u003c iLen) {\r\n            int i0 \u003d in[ip++] \u0026 0xff;\r\n            int i1 \u003d ip \u003c iLen ? in[ip++] \u0026 0xff : 0;\r\n            int i2 \u003d ip \u003c iLen ? in[ip++] \u0026 0xff : 0;\r\n            int o0 \u003d i0 \u003e\u003e\u003e 2;\r\n            int o1 \u003d ((i0 \u0026 3) \u003c\u003c 4) | (i1 \u003e\u003e\u003e 4);\r\n            int o2 \u003d ((i1 \u0026 0xf) \u003c\u003c 2) | (i2 \u003e\u003e\u003e 6);\r\n            int o3 \u003d i2 \u0026 0x3F;\r\n            out[op++] \u003d map1[o0];\r\n            out[op++] \u003d map1[o1];\r\n            out[op] \u003d op \u003c oDataLen ? map1[o2] : \u0027\u003d\u0027;\r\n            op++;\r\n            out[op] \u003d op \u003c oDataLen ? map1[o3] : \u0027\u003d\u0027;\r\n            op++;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Decodes a string from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   A String containing the decoded data.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static String decodeString(String s) {\r\n        return new String(decode(s));\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   An array containing the decoded data bytes.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(String s) {\r\n        return decode(s.toCharArray());\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * No blanks or line breaks are allowed within the Base64 encoded data.\r\n     * @param in  a character array containing the Base64 encoded data.\r\n     * @return    An array containing the decoded data bytes.\r\n     * @throws    IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(char[] in) {\r\n        int iLen \u003d in.length;\r\n        if (iLen % 4 !\u003d 0)\r\n            throw new IllegalArgumentException(\"Length of Base64 encoded input string is not a multiple of 4.\");\r\n        while (iLen \u003e 0 \u0026\u0026 in[iLen - 1] \u003d\u003d \u0027\u003d\u0027) iLen--;\r\n        int oLen \u003d (iLen * 3) / 4;\r\n        byte[] out \u003d new byte[oLen];\r\n        int ip \u003d 0;\r\n        int op \u003d 0;\r\n        while (ip \u003c iLen) {\r\n            int i0 \u003d in[ip++];\r\n            int i1 \u003d in[ip++];\r\n            int i2 \u003d ip \u003c iLen ? in[ip++] : \u0027A\u0027;\r\n            int i3 \u003d ip \u003c iLen ? in[ip++] : \u0027A\u0027;\r\n            if (i0 \u003e 127 || i1 \u003e 127 || i2 \u003e 127 || i3 \u003e 127)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int b0 \u003d map2[i0];\r\n            int b1 \u003d map2[i1];\r\n            int b2 \u003d map2[i2];\r\n            int b3 \u003d map2[i3];\r\n            if (b0 \u003c 0 || b1 \u003c 0 || b2 \u003c 0 || b3 \u003c 0)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int o0 \u003d (b0 \u003c\u003c 2) | (b1 \u003e\u003e\u003e 4);\r\n            int o1 \u003d ((b1 \u0026 0xf) \u003c\u003c 4) | (b2 \u003e\u003e\u003e 2);\r\n            int o2 \u003d ((b2 \u0026 3) \u003c\u003c 6) | b3;\r\n            out[op++] \u003d (byte) o0;\r\n            if (op \u003c oLen)\r\n                out[op++] \u003d (byte) o1;\r\n            if (op \u003c oLen)\r\n                out[op++] \u003d (byte) o2;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    // Dummy constructor.\r\n    private Base64Coder() {\r\n    }\r\n}\r\n// end class Base64Coder\r\n",
    "package": "com.pmdesigns.jvc.tools",
    "classname": "Base64Coder",
    "id": "/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/Base64Coder_2Test.java",
    "test_prompt": "// Base64Coder_2Test.java\npackage com.pmdesigns.jvc.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64Coder}.\n* It contains ten unit test cases for the {@link Base64Coder#encode(byte[], int)} method.\n*/\nclass Base64Coder_2Test {",
    "method_signature": "encode(byte[], int)",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// Base64Coder.java\npackage com.pmdesigns.jvc.tools;\r\n\r\n/**\r\n * A Base64 Encoder/Decoder.\r\n *\r\n * \u003cp\u003e\r\n * This class is used to encode and decode data in Base64 format as described in RFC 1521.\r\n *\r\n * \u003cp\u003e\r\n * This is \"Open Source\" software and released under the \u003ca href\u003d\"http://www.gnu.org/licenses/lgpl.html\"\u003eGNU/LGPL\u003c/a\u003e license.\u003cbr\u003e\r\n * It is provided \"as is\" without warranty of any kind.\u003cbr\u003e\r\n * Copyright 2003: Christian d\u0027Heureuse, Inventec Informatik AG, Switzerland.\u003cbr\u003e\r\n * Home page: \u003ca href\u003d\"http://www.source-code.biz\"\u003ewww.source-code.biz\u003c/a\u003e\u003cbr\u003e\r\n *\r\n * \u003cp\u003e\r\n * Version history:\u003cbr\u003e\r\n * 2003-07-22 Christian d\u0027Heureuse (chdh): Module created.\u003cbr\u003e\r\n * 2005-08-11 chdh: Lincense changed from GPL to LGPL.\u003cbr\u003e\r\n * 2006-11-21 chdh:\u003cbr\u003e\r\n *  \u0026nbsp; Method encode(String) renamed to encodeString(String).\u003cbr\u003e\r\n *  \u0026nbsp; Method decode(String) renamed to decodeString(String).\u003cbr\u003e\r\n *  \u0026nbsp; New method encode(byte[],int) added.\u003cbr\u003e\r\n *  \u0026nbsp; New method decode(String) added.\u003cbr\u003e\r\n */\r\npublic class Base64Coder {\r\n\r\n    // Mapping table from 6-bit nibbles to Base64 characters.\r\n    private static char[] map1 \u003d new char[64];\r\n\r\n    static {\r\n        int i \u003d 0;\r\n        for (char c \u003d \u0027A\u0027; c \u003c\u003d \u0027Z\u0027; c++) map1[i++] \u003d c;\r\n        for (char c \u003d \u0027a\u0027; c \u003c\u003d \u0027z\u0027; c++) map1[i++] \u003d c;\r\n        for (char c \u003d \u00270\u0027; c \u003c\u003d \u00279\u0027; c++) map1[i++] \u003d c;\r\n        map1[i++] \u003d \u0027+\u0027;\r\n        map1[i++] \u003d \u0027/\u0027;\r\n    }\r\n\r\n    // Mapping table from Base64 characters to 6-bit nibbles.\r\n    private static byte[] map2 \u003d new byte[128];\r\n\r\n    static {\r\n        for (int i \u003d 0; i \u003c map2.length; i++) map2[i] \u003d -1;\r\n        for (int i \u003d 0; i \u003c 64; i++) map2[map1[i]] \u003d (byte) i;\r\n    }\r\n\r\n    /**\r\n     * Encodes a string into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param s  a String to be encoded.\r\n     * @return   A String with the Base64 encoded data.\r\n     */\r\n    public static String encodeString(String s) {\r\n        return new String(encode(s.getBytes()));\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in  an array containing the data bytes to be encoded.\r\n     * @return    A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in) {\r\n        return encode(in, in.length);\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in   an array containing the data bytes to be encoded.\r\n     * @param iLen number of bytes to process in \u003ccode\u003ein\u003c/code\u003e.\r\n     * @return     A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in, int iLen) {\r\n        // output length without padding\r\n        int oDataLen \u003d (iLen * 4 + 2) / 3;\r\n        // output length including padding\r\n        int oLen \u003d ((iLen + 2) / 3) * 4;\r\n        char[] out \u003d new char[oLen];\r\n        int ip \u003d 0;\r\n        int op \u003d 0;\r\n        while (ip \u003c iLen) {\r\n            int i0 \u003d in[ip++] \u0026 0xff;\r\n            int i1 \u003d ip \u003c iLen ? in[ip++] \u0026 0xff : 0;\r\n            int i2 \u003d ip \u003c iLen ? in[ip++] \u0026 0xff : 0;\r\n            int o0 \u003d i0 \u003e\u003e\u003e 2;\r\n            int o1 \u003d ((i0 \u0026 3) \u003c\u003c 4) | (i1 \u003e\u003e\u003e 4);\r\n            int o2 \u003d ((i1 \u0026 0xf) \u003c\u003c 2) | (i2 \u003e\u003e\u003e 6);\r\n            int o3 \u003d i2 \u0026 0x3F;\r\n            out[op++] \u003d map1[o0];\r\n            out[op++] \u003d map1[o1];\r\n            out[op] \u003d op \u003c oDataLen ? map1[o2] : \u0027\u003d\u0027;\r\n            op++;\r\n            out[op] \u003d op \u003c oDataLen ? map1[o3] : \u0027\u003d\u0027;\r\n            op++;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Decodes a string from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   A String containing the decoded data.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static String decodeString(String s) {\r\n        return new String(decode(s));\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   An array containing the decoded data bytes.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(String s) {\r\n        return decode(s.toCharArray());\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * No blanks or line breaks are allowed within the Base64 encoded data.\r\n     * @param in  a character array containing the Base64 encoded data.\r\n     * @return    An array containing the decoded data bytes.\r\n     * @throws    IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(char[] in) {\r\n        int iLen \u003d in.length;\r\n        if (iLen % 4 !\u003d 0)\r\n            throw new IllegalArgumentException(\"Length of Base64 encoded input string is not a multiple of 4.\");\r\n        while (iLen \u003e 0 \u0026\u0026 in[iLen - 1] \u003d\u003d \u0027\u003d\u0027) iLen--;\r\n        int oLen \u003d (iLen * 3) / 4;\r\n        byte[] out \u003d new byte[oLen];\r\n        int ip \u003d 0;\r\n        int op \u003d 0;\r\n        while (ip \u003c iLen) {\r\n            int i0 \u003d in[ip++];\r\n            int i1 \u003d in[ip++];\r\n            int i2 \u003d ip \u003c iLen ? in[ip++] : \u0027A\u0027;\r\n            int i3 \u003d ip \u003c iLen ? in[ip++] : \u0027A\u0027;\r\n            if (i0 \u003e 127 || i1 \u003e 127 || i2 \u003e 127 || i3 \u003e 127)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int b0 \u003d map2[i0];\r\n            int b1 \u003d map2[i1];\r\n            int b2 \u003d map2[i2];\r\n            int b3 \u003d map2[i3];\r\n            if (b0 \u003c 0 || b1 \u003c 0 || b2 \u003c 0 || b3 \u003c 0)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int o0 \u003d (b0 \u003c\u003c 2) | (b1 \u003e\u003e\u003e 4);\r\n            int o1 \u003d ((b1 \u0026 0xf) \u003c\u003c 4) | (b2 \u003e\u003e\u003e 2);\r\n            int o2 \u003d ((b2 \u0026 3) \u003c\u003c 6) | b3;\r\n            out[op++] \u003d (byte) o0;\r\n            if (op \u003c oLen)\r\n                out[op++] \u003d (byte) o1;\r\n            if (op \u003c oLen)\r\n                out[op++] \u003d (byte) o2;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    // Dummy constructor.\r\n    private Base64Coder() {\r\n    }\r\n}\r\n// end class Base64Coder\r\n",
    "package": "com.pmdesigns.jvc.tools",
    "classname": "Base64Coder",
    "id": "/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/Base64Coder_3Test.java",
    "test_prompt": "// Base64Coder_3Test.java\npackage com.pmdesigns.jvc.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64Coder}.\n* It contains ten unit test cases for the {@link Base64Coder#decodeString(String)} method.\n*/\nclass Base64Coder_3Test {",
    "method_signature": "decodeString(String)",
    "suffix": "3"
  },
  {
    "numberTests": "ten",
    "original_code": "// Base64Coder.java\npackage com.pmdesigns.jvc.tools;\r\n\r\n/**\r\n * A Base64 Encoder/Decoder.\r\n *\r\n * \u003cp\u003e\r\n * This class is used to encode and decode data in Base64 format as described in RFC 1521.\r\n *\r\n * \u003cp\u003e\r\n * This is \"Open Source\" software and released under the \u003ca href\u003d\"http://www.gnu.org/licenses/lgpl.html\"\u003eGNU/LGPL\u003c/a\u003e license.\u003cbr\u003e\r\n * It is provided \"as is\" without warranty of any kind.\u003cbr\u003e\r\n * Copyright 2003: Christian d\u0027Heureuse, Inventec Informatik AG, Switzerland.\u003cbr\u003e\r\n * Home page: \u003ca href\u003d\"http://www.source-code.biz\"\u003ewww.source-code.biz\u003c/a\u003e\u003cbr\u003e\r\n *\r\n * \u003cp\u003e\r\n * Version history:\u003cbr\u003e\r\n * 2003-07-22 Christian d\u0027Heureuse (chdh): Module created.\u003cbr\u003e\r\n * 2005-08-11 chdh: Lincense changed from GPL to LGPL.\u003cbr\u003e\r\n * 2006-11-21 chdh:\u003cbr\u003e\r\n *  \u0026nbsp; Method encode(String) renamed to encodeString(String).\u003cbr\u003e\r\n *  \u0026nbsp; Method decode(String) renamed to decodeString(String).\u003cbr\u003e\r\n *  \u0026nbsp; New method encode(byte[],int) added.\u003cbr\u003e\r\n *  \u0026nbsp; New method decode(String) added.\u003cbr\u003e\r\n */\r\npublic class Base64Coder {\r\n\r\n    // Mapping table from 6-bit nibbles to Base64 characters.\r\n    private static char[] map1 \u003d new char[64];\r\n\r\n    static {\r\n        int i \u003d 0;\r\n        for (char c \u003d \u0027A\u0027; c \u003c\u003d \u0027Z\u0027; c++) map1[i++] \u003d c;\r\n        for (char c \u003d \u0027a\u0027; c \u003c\u003d \u0027z\u0027; c++) map1[i++] \u003d c;\r\n        for (char c \u003d \u00270\u0027; c \u003c\u003d \u00279\u0027; c++) map1[i++] \u003d c;\r\n        map1[i++] \u003d \u0027+\u0027;\r\n        map1[i++] \u003d \u0027/\u0027;\r\n    }\r\n\r\n    // Mapping table from Base64 characters to 6-bit nibbles.\r\n    private static byte[] map2 \u003d new byte[128];\r\n\r\n    static {\r\n        for (int i \u003d 0; i \u003c map2.length; i++) map2[i] \u003d -1;\r\n        for (int i \u003d 0; i \u003c 64; i++) map2[map1[i]] \u003d (byte) i;\r\n    }\r\n\r\n    /**\r\n     * Encodes a string into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param s  a String to be encoded.\r\n     * @return   A String with the Base64 encoded data.\r\n     */\r\n    public static String encodeString(String s) {\r\n        return new String(encode(s.getBytes()));\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in  an array containing the data bytes to be encoded.\r\n     * @return    A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in) {\r\n        return encode(in, in.length);\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in   an array containing the data bytes to be encoded.\r\n     * @param iLen number of bytes to process in \u003ccode\u003ein\u003c/code\u003e.\r\n     * @return     A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in, int iLen) {\r\n        // output length without padding\r\n        int oDataLen \u003d (iLen * 4 + 2) / 3;\r\n        // output length including padding\r\n        int oLen \u003d ((iLen + 2) / 3) * 4;\r\n        char[] out \u003d new char[oLen];\r\n        int ip \u003d 0;\r\n        int op \u003d 0;\r\n        while (ip \u003c iLen) {\r\n            int i0 \u003d in[ip++] \u0026 0xff;\r\n            int i1 \u003d ip \u003c iLen ? in[ip++] \u0026 0xff : 0;\r\n            int i2 \u003d ip \u003c iLen ? in[ip++] \u0026 0xff : 0;\r\n            int o0 \u003d i0 \u003e\u003e\u003e 2;\r\n            int o1 \u003d ((i0 \u0026 3) \u003c\u003c 4) | (i1 \u003e\u003e\u003e 4);\r\n            int o2 \u003d ((i1 \u0026 0xf) \u003c\u003c 2) | (i2 \u003e\u003e\u003e 6);\r\n            int o3 \u003d i2 \u0026 0x3F;\r\n            out[op++] \u003d map1[o0];\r\n            out[op++] \u003d map1[o1];\r\n            out[op] \u003d op \u003c oDataLen ? map1[o2] : \u0027\u003d\u0027;\r\n            op++;\r\n            out[op] \u003d op \u003c oDataLen ? map1[o3] : \u0027\u003d\u0027;\r\n            op++;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Decodes a string from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   A String containing the decoded data.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static String decodeString(String s) {\r\n        return new String(decode(s));\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   An array containing the decoded data bytes.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(String s) {\r\n        return decode(s.toCharArray());\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * No blanks or line breaks are allowed within the Base64 encoded data.\r\n     * @param in  a character array containing the Base64 encoded data.\r\n     * @return    An array containing the decoded data bytes.\r\n     * @throws    IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(char[] in) {\r\n        int iLen \u003d in.length;\r\n        if (iLen % 4 !\u003d 0)\r\n            throw new IllegalArgumentException(\"Length of Base64 encoded input string is not a multiple of 4.\");\r\n        while (iLen \u003e 0 \u0026\u0026 in[iLen - 1] \u003d\u003d \u0027\u003d\u0027) iLen--;\r\n        int oLen \u003d (iLen * 3) / 4;\r\n        byte[] out \u003d new byte[oLen];\r\n        int ip \u003d 0;\r\n        int op \u003d 0;\r\n        while (ip \u003c iLen) {\r\n            int i0 \u003d in[ip++];\r\n            int i1 \u003d in[ip++];\r\n            int i2 \u003d ip \u003c iLen ? in[ip++] : \u0027A\u0027;\r\n            int i3 \u003d ip \u003c iLen ? in[ip++] : \u0027A\u0027;\r\n            if (i0 \u003e 127 || i1 \u003e 127 || i2 \u003e 127 || i3 \u003e 127)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int b0 \u003d map2[i0];\r\n            int b1 \u003d map2[i1];\r\n            int b2 \u003d map2[i2];\r\n            int b3 \u003d map2[i3];\r\n            if (b0 \u003c 0 || b1 \u003c 0 || b2 \u003c 0 || b3 \u003c 0)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int o0 \u003d (b0 \u003c\u003c 2) | (b1 \u003e\u003e\u003e 4);\r\n            int o1 \u003d ((b1 \u0026 0xf) \u003c\u003c 4) | (b2 \u003e\u003e\u003e 2);\r\n            int o2 \u003d ((b2 \u0026 3) \u003c\u003c 6) | b3;\r\n            out[op++] \u003d (byte) o0;\r\n            if (op \u003c oLen)\r\n                out[op++] \u003d (byte) o1;\r\n            if (op \u003c oLen)\r\n                out[op++] \u003d (byte) o2;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    // Dummy constructor.\r\n    private Base64Coder() {\r\n    }\r\n}\r\n// end class Base64Coder\r\n",
    "package": "com.pmdesigns.jvc.tools",
    "classname": "Base64Coder",
    "id": "/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/Base64Coder_4Test.java",
    "test_prompt": "// Base64Coder_4Test.java\npackage com.pmdesigns.jvc.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64Coder}.\n* It contains ten unit test cases for the {@link Base64Coder#decode(String)} method.\n*/\nclass Base64Coder_4Test {",
    "method_signature": "decode(String)",
    "suffix": "4"
  },
  {
    "numberTests": "ten",
    "original_code": "// Base64Coder.java\npackage com.pmdesigns.jvc.tools;\r\n\r\n/**\r\n * A Base64 Encoder/Decoder.\r\n *\r\n * \u003cp\u003e\r\n * This class is used to encode and decode data in Base64 format as described in RFC 1521.\r\n *\r\n * \u003cp\u003e\r\n * This is \"Open Source\" software and released under the \u003ca href\u003d\"http://www.gnu.org/licenses/lgpl.html\"\u003eGNU/LGPL\u003c/a\u003e license.\u003cbr\u003e\r\n * It is provided \"as is\" without warranty of any kind.\u003cbr\u003e\r\n * Copyright 2003: Christian d\u0027Heureuse, Inventec Informatik AG, Switzerland.\u003cbr\u003e\r\n * Home page: \u003ca href\u003d\"http://www.source-code.biz\"\u003ewww.source-code.biz\u003c/a\u003e\u003cbr\u003e\r\n *\r\n * \u003cp\u003e\r\n * Version history:\u003cbr\u003e\r\n * 2003-07-22 Christian d\u0027Heureuse (chdh): Module created.\u003cbr\u003e\r\n * 2005-08-11 chdh: Lincense changed from GPL to LGPL.\u003cbr\u003e\r\n * 2006-11-21 chdh:\u003cbr\u003e\r\n *  \u0026nbsp; Method encode(String) renamed to encodeString(String).\u003cbr\u003e\r\n *  \u0026nbsp; Method decode(String) renamed to decodeString(String).\u003cbr\u003e\r\n *  \u0026nbsp; New method encode(byte[],int) added.\u003cbr\u003e\r\n *  \u0026nbsp; New method decode(String) added.\u003cbr\u003e\r\n */\r\npublic class Base64Coder {\r\n\r\n    // Mapping table from 6-bit nibbles to Base64 characters.\r\n    private static char[] map1 \u003d new char[64];\r\n\r\n    static {\r\n        int i \u003d 0;\r\n        for (char c \u003d \u0027A\u0027; c \u003c\u003d \u0027Z\u0027; c++) map1[i++] \u003d c;\r\n        for (char c \u003d \u0027a\u0027; c \u003c\u003d \u0027z\u0027; c++) map1[i++] \u003d c;\r\n        for (char c \u003d \u00270\u0027; c \u003c\u003d \u00279\u0027; c++) map1[i++] \u003d c;\r\n        map1[i++] \u003d \u0027+\u0027;\r\n        map1[i++] \u003d \u0027/\u0027;\r\n    }\r\n\r\n    // Mapping table from Base64 characters to 6-bit nibbles.\r\n    private static byte[] map2 \u003d new byte[128];\r\n\r\n    static {\r\n        for (int i \u003d 0; i \u003c map2.length; i++) map2[i] \u003d -1;\r\n        for (int i \u003d 0; i \u003c 64; i++) map2[map1[i]] \u003d (byte) i;\r\n    }\r\n\r\n    /**\r\n     * Encodes a string into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param s  a String to be encoded.\r\n     * @return   A String with the Base64 encoded data.\r\n     */\r\n    public static String encodeString(String s) {\r\n        return new String(encode(s.getBytes()));\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in  an array containing the data bytes to be encoded.\r\n     * @return    A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in) {\r\n        return encode(in, in.length);\r\n    }\r\n\r\n    /**\r\n     * Encodes a byte array into Base64 format.\r\n     * No blanks or line breaks are inserted.\r\n     * @param in   an array containing the data bytes to be encoded.\r\n     * @param iLen number of bytes to process in \u003ccode\u003ein\u003c/code\u003e.\r\n     * @return     A character array with the Base64 encoded data.\r\n     */\r\n    public static char[] encode(byte[] in, int iLen) {\r\n        // output length without padding\r\n        int oDataLen \u003d (iLen * 4 + 2) / 3;\r\n        // output length including padding\r\n        int oLen \u003d ((iLen + 2) / 3) * 4;\r\n        char[] out \u003d new char[oLen];\r\n        int ip \u003d 0;\r\n        int op \u003d 0;\r\n        while (ip \u003c iLen) {\r\n            int i0 \u003d in[ip++] \u0026 0xff;\r\n            int i1 \u003d ip \u003c iLen ? in[ip++] \u0026 0xff : 0;\r\n            int i2 \u003d ip \u003c iLen ? in[ip++] \u0026 0xff : 0;\r\n            int o0 \u003d i0 \u003e\u003e\u003e 2;\r\n            int o1 \u003d ((i0 \u0026 3) \u003c\u003c 4) | (i1 \u003e\u003e\u003e 4);\r\n            int o2 \u003d ((i1 \u0026 0xf) \u003c\u003c 2) | (i2 \u003e\u003e\u003e 6);\r\n            int o3 \u003d i2 \u0026 0x3F;\r\n            out[op++] \u003d map1[o0];\r\n            out[op++] \u003d map1[o1];\r\n            out[op] \u003d op \u003c oDataLen ? map1[o2] : \u0027\u003d\u0027;\r\n            op++;\r\n            out[op] \u003d op \u003c oDataLen ? map1[o3] : \u0027\u003d\u0027;\r\n            op++;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Decodes a string from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   A String containing the decoded data.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static String decodeString(String s) {\r\n        return new String(decode(s));\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * @param s  a Base64 String to be decoded.\r\n     * @return   An array containing the decoded data bytes.\r\n     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(String s) {\r\n        return decode(s.toCharArray());\r\n    }\r\n\r\n    /**\r\n     * Decodes a byte array from Base64 format.\r\n     * No blanks or line breaks are allowed within the Base64 encoded data.\r\n     * @param in  a character array containing the Base64 encoded data.\r\n     * @return    An array containing the decoded data bytes.\r\n     * @throws    IllegalArgumentException if the input is not valid Base64 encoded data.\r\n     */\r\n    public static byte[] decode(char[] in) {\r\n        int iLen \u003d in.length;\r\n        if (iLen % 4 !\u003d 0)\r\n            throw new IllegalArgumentException(\"Length of Base64 encoded input string is not a multiple of 4.\");\r\n        while (iLen \u003e 0 \u0026\u0026 in[iLen - 1] \u003d\u003d \u0027\u003d\u0027) iLen--;\r\n        int oLen \u003d (iLen * 3) / 4;\r\n        byte[] out \u003d new byte[oLen];\r\n        int ip \u003d 0;\r\n        int op \u003d 0;\r\n        while (ip \u003c iLen) {\r\n            int i0 \u003d in[ip++];\r\n            int i1 \u003d in[ip++];\r\n            int i2 \u003d ip \u003c iLen ? in[ip++] : \u0027A\u0027;\r\n            int i3 \u003d ip \u003c iLen ? in[ip++] : \u0027A\u0027;\r\n            if (i0 \u003e 127 || i1 \u003e 127 || i2 \u003e 127 || i3 \u003e 127)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int b0 \u003d map2[i0];\r\n            int b1 \u003d map2[i1];\r\n            int b2 \u003d map2[i2];\r\n            int b3 \u003d map2[i3];\r\n            if (b0 \u003c 0 || b1 \u003c 0 || b2 \u003c 0 || b3 \u003c 0)\r\n                throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n            int o0 \u003d (b0 \u003c\u003c 2) | (b1 \u003e\u003e\u003e 4);\r\n            int o1 \u003d ((b1 \u0026 0xf) \u003c\u003c 4) | (b2 \u003e\u003e\u003e 2);\r\n            int o2 \u003d ((b2 \u0026 3) \u003c\u003c 6) | b3;\r\n            out[op++] \u003d (byte) o0;\r\n            if (op \u003c oLen)\r\n                out[op++] \u003d (byte) o1;\r\n            if (op \u003c oLen)\r\n                out[op++] \u003d (byte) o2;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    // Dummy constructor.\r\n    private Base64Coder() {\r\n    }\r\n}\r\n// end class Base64Coder\r\n",
    "package": "com.pmdesigns.jvc.tools",
    "classname": "Base64Coder",
    "id": "/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/tools/Base64Coder_5Test.java",
    "test_prompt": "// Base64Coder_5Test.java\npackage com.pmdesigns.jvc.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64Coder}.\n* It contains ten unit test cases for the {@link Base64Coder#decode(char[])} method.\n*/\nclass Base64Coder_5Test {",
    "method_signature": "decode(char[])",
    "suffix": "5"
  },
  {
    "numberTests": "ten",
    "original_code": "// JVCRequestContext.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\n/**\n * This class contains state information for processing an http request.\n * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet\n * objects and provides convenience methods for accessing them.\n * \u003cp\u003e\n * It also provides access to the \u0027flash\u0027 which is a Map for storing temporary\n * key/value strings.  The scope of the flash is the current request or\n * the following request in the case of a redirect response.\n * \u003cp\u003e\n * It also contains some convenience methods for forming links and absolute paths.\n *\n * @author mike dooley\n */\npublic final class JVCRequestContext {\n\n    /**\n     * The actual HttpServletRequest object\n     */\n    public final HttpServletRequest request;\n\n    /**\n     * The actual HttpServletResponse object\n     */\n    public final HttpServletResponse response;\n\n    /**\n     * The HttpServlet object (actually this is a JVCDispatcher)\n     */\n    public final HttpServlet servlet;\n\n    /**\n     * The controller is the servlet path up to the action.\n     */\n    public final String controller;\n\n    /**\n     * The action is the last part of the servlet path (before any query arguments)\n     */\n    public final String action;\n\n    /**\n     * Tells if this request has multipart content (ie file upload)\n     */\n    public final boolean hasMultipartContent;\n\n    /**\n     * Parameter value indicating that the real parameter value is binary (and should be\n     * accessed via the getAttribute() method.\n     */\n    public static final String BINARY_VALUE \u003d \"BINARY_VALUE\";\n\n    /**\n     * The \u0027flash\u0027 map for holding temporary key/value strings.\n     */\n    public final Map\u003cString, String\u003e flash;\n\n    /**\n     * Holds cached page generator fragments\n     */\n    private static Map\u003cString, String\u003e cacheMap;\n\n    /**\n     * Constructor for JVCRequestContext which is used to hold http request and response iformation\n     * @param request\n     * @param response\n     * @param servlet\n     * @param flash\n     * @param controller\n     * @param action\n     */\n    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map\u003cString, String\u003e flash, String controller, String action) throws Exception {\n        this.request \u003d request;\n        this.response \u003d response;\n        this.servlet \u003d servlet;\n        this.controller \u003d controller;\n        this.action \u003d action;\n        this.flash \u003d flash;\n        hasMultipartContent \u003d ServletFileUpload.isMultipartContent(request);\n        if (hasMultipartContent) {\n            // Create a new file upload handler\n            ServletFileUpload upload \u003d new ServletFileUpload();\n            // Parse the request\n            FileItemIterator iter \u003d upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item \u003d iter.next();\n                String name \u003d item.getFieldName();\n                InputStream stream \u003d item.openStream();\n                if (item.isFormField()) {\n                    // add parameter as request attribute\n                    String val \u003d Streams.asString(stream);\n                    request.setAttribute(name, val);\n                    // System.out.println(\"Form field \" + name + \" with value \" + val + \" detected.\");\n                } else {\n                    // add input stream and filename as attributes\n                    String fileName \u003d item.getName();\n                    request.setAttribute(\"fileName\", fileName);\n                    byte[] data \u003d readStream(stream);\n                    request.setAttribute(name, data);\n                    // System.out.println(\"File field \" + name + \" with file name \" + fileName + \" detected.\");\n                }\n            }\n        }\n    }\n\n    // request info\n    /**\n     * Convenience method\n     * @return true if the request is secure\n     */\n    public boolean isSecure() {\n        return request.isSecure();\n    }\n\n    /**\n     * Convenience method\n     * @return the request scheme, ie. http, https\n     */\n    public String getScheme() {\n        return request.getScheme();\n    }\n\n    /**\n     * Convenience method\n     * @return the request method, ie. GET, POST\n     */\n    public String getMethod() {\n        return request.getMethod();\n    }\n\n    /**\n     * Convenience method\n     * @return the server name for this request\n     */\n    public String getServerName() {\n        return request.getServerName();\n    }\n\n    /**\n     * Convenience method\n     * @return the server port for this request\n     */\n    public int getServerPort() {\n        return request.getServerPort();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getServletPath\n     * @see #getQueryString\n     * @return the context path part of the url path\n     */\n    public String getContextPath() {\n        return request.getContextPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getContextPath\n     * @see #getQueryString\n     * @return the servlet path part of the url path\n     */\n    public String getServletPath() {\n        return request.getServletPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getContextPath\n     * @see #getServletPath\n     * @return the query string part of the url path\n     */\n    public String getQueryString() {\n        return request.getQueryString();\n    }\n\n    // params\n    /**\n     * Convenience method\n     * @param name    which parameter to get\n     * @return the parameter value or null if there is no parameter corresponding to the indicated key\n     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,\n     * which can be retrieved as a byte array via the getAttribute method.\n     * @see #getParamMap\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public String getParam(String name) {\n        if (hasMultipartContent) {\n            Object o \u003d request.getAttribute(name);\n            return (o !\u003d null \u0026\u0026 o instanceof String) ? (String) o : BINARY_VALUE;\n        } else {\n            return request.getParameter(name);\n        }\n    }\n\n    /**\n     * Convenience method which gathers all parameters of the\n     * form \u0027\u003cname\u003e[\u003ckey\u003e]\u0027 and return then in a map where the\n     * keys are the \u003ckey\u003e strings and the values are the\n     * corresponding parameter values.\n     * \u003cpre\u003e\n     * For example, if there are parameters:\n     *   \u0027foo[bar1]\u0027 \u003d \u0027baz1\u0027\n     *   \u0027foo[bar2]\u0027 \u003d \u0027baz2\u0027\n     * then getParamMap(\u0027foo\u0027) will returned the map:\n     *   map[\u0027bar1\u0027] \u003d \u0027baz1\u0027\n     *   map[\u0027bar2\u0027] \u003d \u0027baz2\u0027\n     * \u003c/pre\u003e\n     * @param name  the prefix to be used to select parameters\n     * @return a map of all paramters of the form \u0027name[\u003ckey\u003e]\u0027\n     * where the \u003ckey\u003e strings are the keys of the map and the\n     * values are the corresponding parameter values.\n     * @see #getParam\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public Map\u003cString, String\u003e getParamMap(String name) {\n        Map\u003cString, String\u003e m \u003d new HashMap\u003cString, String\u003e();\n        String prefix \u003d name + \"[\";\n        int n \u003d prefix.length();\n        if (hasMultipartContent) {\n            // for multipart requests the parameters have been stored as attributes (see constructor)\n            Enumeration\u003cString\u003e e \u003d request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                String key \u003d e.nextElement();\n                if (key.startsWith(prefix) \u0026\u0026 key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        } else {\n            Map\u003cString, String[]\u003e pm \u003d request.getParameterMap();\n            for (String key : pm.keySet()) {\n                if (key.startsWith(prefix) \u0026\u0026 key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        }\n        return m;\n    }\n\n    /**\n     * Convenience method. Use this if you expect a parameter name\n     * to map to multiple values.\n     * @param name    the name of the parameter(s) to get\n     * @return an array of paramter values corresponding to the indicated name\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamNames\n     */\n    public String[] getParamValues(String name) {\n        return request.getParameterValues(name);\n    }\n\n    /**\n     * Convenience method to get all the parameter names.\n     * @return an array of all parameter names\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamValues\n     */\n    public String[] getParamNames() {\n        if (hasMultipartContent) {\n            List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n            Enumeration\u003cString\u003e e \u003d request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                list.add(e.nextElement());\n            }\n            return list.toArray(new String[list.size()]);\n        } else {\n            Map\u003cString, String[]\u003e m \u003d request.getParameterMap();\n            String[] a \u003d new String[m.size()];\n            int i \u003d 0;\n            for (String key : m.keySet()) {\n                a[i++] \u003d key;\n            }\n            return a;\n        }\n    }\n\n    // attributes\n    /**\n     * Convenience method\n     * @param name    which attribute to get\n     * @return the attribute value or null if there is no attribute corresponding to the indicated key.\n     * If the attribute corresponds to a file upload field then the return value will be a byte array\n     */\n    public Object getAttribute(String name) {\n        return request.getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @param name    name of attribute to be set\n     * @param value   value of attribute to be set\n     */\n    public void setAttribute(String name, Object value) {\n        request.setAttribute(name, value);\n    }\n\n    // session attributes\n    /**\n     * Convenience method\n     * @param name    the name of the attribute to retrieve\n     * @return the attribute associated with the indicated name or null\n     * @see #setSessionAttr\n     * @see #getSessionAttrNames\n     */\n    public Object getSessionAttr(String name) {\n        if (request.getSession() \u003d\u003d null)\n            return null;\n        return request.getSession().getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @return all the session attribute names.\n     * @see #getSessionAttr\n     * @see #setSessionAttr\n     * @see #removeSessionAttr\n     */\n    public String[] getSessionAttrNames() {\n        if (request.getSession(false) \u003d\u003d null)\n            return new String[0];\n        ArrayList\u003cString\u003e a \u003d new ArrayList\u003cString\u003e();\n        Enumeration\u003cString\u003e e \u003d request.getSession().getAttributeNames();\n        while (e.hasMoreElements()) {\n            a.add(e.nextElement());\n        }\n        return a.toArray(new String[a.size()]);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key to store the indicated value\n     * @param value  the object to be stored\n     * @see #getSessionAttr\n     * @see #removeSessionAttr\n     */\n    public void setSessionAttr(String name, Object value) {\n        if (request.getSession() \u003d\u003d null)\n            return;\n        request.getSession().setAttribute(name, value);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key of\n     * @see #setSessionAttr\n     */\n    public void removeSessionAttr(String name) {\n        if (request.getSession() \u003d\u003d null)\n            return;\n        request.getSession().removeAttribute(name);\n    }\n\n    // cookies\n    /**\n     * Convenience method to get cookie by name\n     * @param name  the name of the cookie to get\n     * @return the cookie with the indicated name, or null\n     * @see #setCookie\n     * @see #getCookieNames\n     */\n    public Cookie getCookie(String name) {\n        if (name \u003d\u003d null)\n            return null;\n        Cookie[] cookies \u003d request.getCookies();\n        if (cookies \u003d\u003d null)\n            return null;\n        for (Cookie c : cookies) {\n            if (name.equals(c.getName()))\n                return c;\n        }\n        return null;\n    }\n\n    /**\n     * Convenience method to get all the cookie names.\n     * @return an array of the names of all the cookies in the request, possibly empty\n     * @see #getCookie\n     * @see #setCookie\n     */\n    public String[] getCookieNames() {\n        Cookie[] cookies \u003d request.getCookies();\n        if (cookies \u003d\u003d null)\n            return new String[0];\n        String[] a \u003d new String[cookies.length];\n        int i \u003d 0;\n        for (Cookie c : cookies) {\n            a[i++] \u003d c.getName();\n        }\n        return a;\n    }\n\n    /**\n     * Convenience method\n     * @param cookie   the cookie to be added to the response\n     * @see #getCookie\n     * @see #getCookieNames\n     */\n    public void setCookie(Cookie cookie) {\n        response.addCookie(cookie);\n    }\n\n    /**\n     * Cause a non-standard response (ie. redirect) to be returned.\n     * @param httpCode   the http response code to be returned\n     * @param arg    an argument or message to be returned (depends on response code)\n     * @see #redirect\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void nonStandardResponse(int httpCode, String arg) {\n        throw new NonStandardResponseException(httpCode, arg);\n    }\n\n    /**\n     * Cause a redirect response to be returned\n     * @param path  where to redirect to. If the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #nonStandardResponse\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void redirect(String path) {\n        if (path.startsWith(\"/\"))\n            path \u003d absPath(path);\n        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);\n    }\n\n    /**\n     * Cause a binary response to be returned\n     * @param in input stream containing binary data to be sent\n     * @throws BinaryResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the BinaryResponseException.\n     */\n    public void sendBinaryResponse(InputStream in) {\n        throw new BinaryResponseException(in);\n    }\n\n    /**\n     * Convenience method to prepend the context path onto a servlet path\n     * @param path    a servlet path\n     * @return the context path plus the indicated path\n     */\n    public String absPath(String path) {\n        return getContextPath() + (path.startsWith(\"/\") ? path : \"/\" + path);\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path) {\n        return makeLink(anchor, path, \"\");\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @param options    extra html options to add to the anchor tag\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path, String options) {\n        if (path.startsWith(\"/\"))\n            path \u003d absPath(path);\n        return \"\u003ca href\u003d\u0027\" + path + \"\u0027 \" + options + \"\u003e\" + anchor + \"\u003c/a\u003e\";\n    }\n\n    /**\n     * Convenience method to check if this request is a POST\n     */\n    public boolean isPost() {\n        return \"POST\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to check if this request is a GET\n     */\n    public boolean isGet() {\n        return \"GET\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to retrieve a value from the flash\n     * @param key  the key to use to lookup a flash value\n     * @return the flash value associated with the indicated key or null\n     * @see #setFlash\n     */\n    public String getFlash(String key) {\n        return flash.get(key);\n    }\n\n    /**\n     * Convenience method to add a value to the flash\n     * @param key  the key to use to associate with the flash value\n     * @param val  the value to store\n     * @see #getFlash\n     */\n    public void setFlash(String key, String val) {\n        flash.put(key, val);\n    }\n\n    // caching (internal use)\n    /**\n     * Internal method used to retrieve a cached block\n     * @see #setCachedBlock\n     */\n    public static String getCachedBlock(String key) {\n        return (cacheMap \u003d\u003d null) ? null : cacheMap.get(key);\n    }\n\n    /**\n     * Internal method used to store a cached block\n     * @see #getCachedBlock\n     */\n    public static void setCachedBlock(String key, String val) {\n        if (cacheMap \u003d\u003d null) {\n            cacheMap \u003d new HashMap\u003cString, String\u003e();\n        }\n        cacheMap.put(key, val);\n    }\n\n    /**\n     * For debugging\n     * @return a string representation of this request context\n     */\n    public String toString() {\n        return toString(\", \");\n    }\n\n    public String toString(String sep) {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"params: [\");\n        String[] keys \u003d getParamNames();\n        for (String key : keys) {\n            sb.append(key).append(\u0027\u003d\u0027).append(getParam(key)).append(sep);\n        }\n        if (keys.length \u003e 0) {\n            sb.setLength(sb.length() - sep.length());\n        }\n        sb.append(\"]\");\n        sb.append(sep).append(\"method: \").append(getMethod());\n        sb.append(sep).append(\"url: \").append(getScheme());\n        sb.append(\"|\").append(getServerName());\n        sb.append(\"|\").append(getServerPort());\n        sb.append(\"|\").append(getContextPath());\n        sb.append(\"|\").append(getServletPath());\n        sb.append(\"|\").append(getQueryString());\n        if (hasMultipartContent) {\n            sb.append(sep).append(\"content len: \").append(request.getContentLength());\n            //sb.append(sep).append(\"content type: \").append(request.getContentType());\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Copy an input stream to an output stream.\n     */\n    private byte[] readStream(InputStream in) throws IOException {\n        ByteArrayOutputStream out \u003d new ByteArrayOutputStream();\n        byte[] buf \u003d new byte[4096];\n        int read;\n        while ((read \u003d in.read(buf)) \u003e -1) {\n            out.write(buf, 0, read);\n        }\n        out.flush();\n        return out.toByteArray();\n    }\n}\n",
    "package": "com.pmdesigns.jvc",
    "classname": "JVCRequestContext",
    "id": "/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContext_0Test.java",
    "test_prompt": "// JVCRequestContext_0Test.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JVCRequestContext}.\n* It contains ten unit test cases for the {@link JVCRequestContext#getParam(String)} method.\n*/\nclass JVCRequestContext_0Test {",
    "method_signature": "getParam(String)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// JVCRequestContext.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\n/**\n * This class contains state information for processing an http request.\n * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet\n * objects and provides convenience methods for accessing them.\n * \u003cp\u003e\n * It also provides access to the \u0027flash\u0027 which is a Map for storing temporary\n * key/value strings.  The scope of the flash is the current request or\n * the following request in the case of a redirect response.\n * \u003cp\u003e\n * It also contains some convenience methods for forming links and absolute paths.\n *\n * @author mike dooley\n */\npublic final class JVCRequestContext {\n\n    /**\n     * The actual HttpServletRequest object\n     */\n    public final HttpServletRequest request;\n\n    /**\n     * The actual HttpServletResponse object\n     */\n    public final HttpServletResponse response;\n\n    /**\n     * The HttpServlet object (actually this is a JVCDispatcher)\n     */\n    public final HttpServlet servlet;\n\n    /**\n     * The controller is the servlet path up to the action.\n     */\n    public final String controller;\n\n    /**\n     * The action is the last part of the servlet path (before any query arguments)\n     */\n    public final String action;\n\n    /**\n     * Tells if this request has multipart content (ie file upload)\n     */\n    public final boolean hasMultipartContent;\n\n    /**\n     * Parameter value indicating that the real parameter value is binary (and should be\n     * accessed via the getAttribute() method.\n     */\n    public static final String BINARY_VALUE \u003d \"BINARY_VALUE\";\n\n    /**\n     * The \u0027flash\u0027 map for holding temporary key/value strings.\n     */\n    public final Map\u003cString, String\u003e flash;\n\n    /**\n     * Holds cached page generator fragments\n     */\n    private static Map\u003cString, String\u003e cacheMap;\n\n    /**\n     * Constructor for JVCRequestContext which is used to hold http request and response iformation\n     * @param request\n     * @param response\n     * @param servlet\n     * @param flash\n     * @param controller\n     * @param action\n     */\n    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map\u003cString, String\u003e flash, String controller, String action) throws Exception {\n        this.request \u003d request;\n        this.response \u003d response;\n        this.servlet \u003d servlet;\n        this.controller \u003d controller;\n        this.action \u003d action;\n        this.flash \u003d flash;\n        hasMultipartContent \u003d ServletFileUpload.isMultipartContent(request);\n        if (hasMultipartContent) {\n            // Create a new file upload handler\n            ServletFileUpload upload \u003d new ServletFileUpload();\n            // Parse the request\n            FileItemIterator iter \u003d upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item \u003d iter.next();\n                String name \u003d item.getFieldName();\n                InputStream stream \u003d item.openStream();\n                if (item.isFormField()) {\n                    // add parameter as request attribute\n                    String val \u003d Streams.asString(stream);\n                    request.setAttribute(name, val);\n                    // System.out.println(\"Form field \" + name + \" with value \" + val + \" detected.\");\n                } else {\n                    // add input stream and filename as attributes\n                    String fileName \u003d item.getName();\n                    request.setAttribute(\"fileName\", fileName);\n                    byte[] data \u003d readStream(stream);\n                    request.setAttribute(name, data);\n                    // System.out.println(\"File field \" + name + \" with file name \" + fileName + \" detected.\");\n                }\n            }\n        }\n    }\n\n    // request info\n    /**\n     * Convenience method\n     * @return true if the request is secure\n     */\n    public boolean isSecure() {\n        return request.isSecure();\n    }\n\n    /**\n     * Convenience method\n     * @return the request scheme, ie. http, https\n     */\n    public String getScheme() {\n        return request.getScheme();\n    }\n\n    /**\n     * Convenience method\n     * @return the request method, ie. GET, POST\n     */\n    public String getMethod() {\n        return request.getMethod();\n    }\n\n    /**\n     * Convenience method\n     * @return the server name for this request\n     */\n    public String getServerName() {\n        return request.getServerName();\n    }\n\n    /**\n     * Convenience method\n     * @return the server port for this request\n     */\n    public int getServerPort() {\n        return request.getServerPort();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getServletPath\n     * @see #getQueryString\n     * @return the context path part of the url path\n     */\n    public String getContextPath() {\n        return request.getContextPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getContextPath\n     * @see #getQueryString\n     * @return the servlet path part of the url path\n     */\n    public String getServletPath() {\n        return request.getServletPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getContextPath\n     * @see #getServletPath\n     * @return the query string part of the url path\n     */\n    public String getQueryString() {\n        return request.getQueryString();\n    }\n\n    // params\n    /**\n     * Convenience method\n     * @param name    which parameter to get\n     * @return the parameter value or null if there is no parameter corresponding to the indicated key\n     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,\n     * which can be retrieved as a byte array via the getAttribute method.\n     * @see #getParamMap\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public String getParam(String name) {\n        if (hasMultipartContent) {\n            Object o \u003d request.getAttribute(name);\n            return (o !\u003d null \u0026\u0026 o instanceof String) ? (String) o : BINARY_VALUE;\n        } else {\n            return request.getParameter(name);\n        }\n    }\n\n    /**\n     * Convenience method which gathers all parameters of the\n     * form \u0027\u003cname\u003e[\u003ckey\u003e]\u0027 and return then in a map where the\n     * keys are the \u003ckey\u003e strings and the values are the\n     * corresponding parameter values.\n     * \u003cpre\u003e\n     * For example, if there are parameters:\n     *   \u0027foo[bar1]\u0027 \u003d \u0027baz1\u0027\n     *   \u0027foo[bar2]\u0027 \u003d \u0027baz2\u0027\n     * then getParamMap(\u0027foo\u0027) will returned the map:\n     *   map[\u0027bar1\u0027] \u003d \u0027baz1\u0027\n     *   map[\u0027bar2\u0027] \u003d \u0027baz2\u0027\n     * \u003c/pre\u003e\n     * @param name  the prefix to be used to select parameters\n     * @return a map of all paramters of the form \u0027name[\u003ckey\u003e]\u0027\n     * where the \u003ckey\u003e strings are the keys of the map and the\n     * values are the corresponding parameter values.\n     * @see #getParam\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public Map\u003cString, String\u003e getParamMap(String name) {\n        Map\u003cString, String\u003e m \u003d new HashMap\u003cString, String\u003e();\n        String prefix \u003d name + \"[\";\n        int n \u003d prefix.length();\n        if (hasMultipartContent) {\n            // for multipart requests the parameters have been stored as attributes (see constructor)\n            Enumeration\u003cString\u003e e \u003d request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                String key \u003d e.nextElement();\n                if (key.startsWith(prefix) \u0026\u0026 key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        } else {\n            Map\u003cString, String[]\u003e pm \u003d request.getParameterMap();\n            for (String key : pm.keySet()) {\n                if (key.startsWith(prefix) \u0026\u0026 key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        }\n        return m;\n    }\n\n    /**\n     * Convenience method. Use this if you expect a parameter name\n     * to map to multiple values.\n     * @param name    the name of the parameter(s) to get\n     * @return an array of paramter values corresponding to the indicated name\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamNames\n     */\n    public String[] getParamValues(String name) {\n        return request.getParameterValues(name);\n    }\n\n    /**\n     * Convenience method to get all the parameter names.\n     * @return an array of all parameter names\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamValues\n     */\n    public String[] getParamNames() {\n        if (hasMultipartContent) {\n            List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n            Enumeration\u003cString\u003e e \u003d request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                list.add(e.nextElement());\n            }\n            return list.toArray(new String[list.size()]);\n        } else {\n            Map\u003cString, String[]\u003e m \u003d request.getParameterMap();\n            String[] a \u003d new String[m.size()];\n            int i \u003d 0;\n            for (String key : m.keySet()) {\n                a[i++] \u003d key;\n            }\n            return a;\n        }\n    }\n\n    // attributes\n    /**\n     * Convenience method\n     * @param name    which attribute to get\n     * @return the attribute value or null if there is no attribute corresponding to the indicated key.\n     * If the attribute corresponds to a file upload field then the return value will be a byte array\n     */\n    public Object getAttribute(String name) {\n        return request.getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @param name    name of attribute to be set\n     * @param value   value of attribute to be set\n     */\n    public void setAttribute(String name, Object value) {\n        request.setAttribute(name, value);\n    }\n\n    // session attributes\n    /**\n     * Convenience method\n     * @param name    the name of the attribute to retrieve\n     * @return the attribute associated with the indicated name or null\n     * @see #setSessionAttr\n     * @see #getSessionAttrNames\n     */\n    public Object getSessionAttr(String name) {\n        if (request.getSession() \u003d\u003d null)\n            return null;\n        return request.getSession().getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @return all the session attribute names.\n     * @see #getSessionAttr\n     * @see #setSessionAttr\n     * @see #removeSessionAttr\n     */\n    public String[] getSessionAttrNames() {\n        if (request.getSession(false) \u003d\u003d null)\n            return new String[0];\n        ArrayList\u003cString\u003e a \u003d new ArrayList\u003cString\u003e();\n        Enumeration\u003cString\u003e e \u003d request.getSession().getAttributeNames();\n        while (e.hasMoreElements()) {\n            a.add(e.nextElement());\n        }\n        return a.toArray(new String[a.size()]);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key to store the indicated value\n     * @param value  the object to be stored\n     * @see #getSessionAttr\n     * @see #removeSessionAttr\n     */\n    public void setSessionAttr(String name, Object value) {\n        if (request.getSession() \u003d\u003d null)\n            return;\n        request.getSession().setAttribute(name, value);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key of\n     * @see #setSessionAttr\n     */\n    public void removeSessionAttr(String name) {\n        if (request.getSession() \u003d\u003d null)\n            return;\n        request.getSession().removeAttribute(name);\n    }\n\n    // cookies\n    /**\n     * Convenience method to get cookie by name\n     * @param name  the name of the cookie to get\n     * @return the cookie with the indicated name, or null\n     * @see #setCookie\n     * @see #getCookieNames\n     */\n    public Cookie getCookie(String name) {\n        if (name \u003d\u003d null)\n            return null;\n        Cookie[] cookies \u003d request.getCookies();\n        if (cookies \u003d\u003d null)\n            return null;\n        for (Cookie c : cookies) {\n            if (name.equals(c.getName()))\n                return c;\n        }\n        return null;\n    }\n\n    /**\n     * Convenience method to get all the cookie names.\n     * @return an array of the names of all the cookies in the request, possibly empty\n     * @see #getCookie\n     * @see #setCookie\n     */\n    public String[] getCookieNames() {\n        Cookie[] cookies \u003d request.getCookies();\n        if (cookies \u003d\u003d null)\n            return new String[0];\n        String[] a \u003d new String[cookies.length];\n        int i \u003d 0;\n        for (Cookie c : cookies) {\n            a[i++] \u003d c.getName();\n        }\n        return a;\n    }\n\n    /**\n     * Convenience method\n     * @param cookie   the cookie to be added to the response\n     * @see #getCookie\n     * @see #getCookieNames\n     */\n    public void setCookie(Cookie cookie) {\n        response.addCookie(cookie);\n    }\n\n    /**\n     * Cause a non-standard response (ie. redirect) to be returned.\n     * @param httpCode   the http response code to be returned\n     * @param arg    an argument or message to be returned (depends on response code)\n     * @see #redirect\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void nonStandardResponse(int httpCode, String arg) {\n        throw new NonStandardResponseException(httpCode, arg);\n    }\n\n    /**\n     * Cause a redirect response to be returned\n     * @param path  where to redirect to. If the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #nonStandardResponse\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void redirect(String path) {\n        if (path.startsWith(\"/\"))\n            path \u003d absPath(path);\n        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);\n    }\n\n    /**\n     * Cause a binary response to be returned\n     * @param in input stream containing binary data to be sent\n     * @throws BinaryResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the BinaryResponseException.\n     */\n    public void sendBinaryResponse(InputStream in) {\n        throw new BinaryResponseException(in);\n    }\n\n    /**\n     * Convenience method to prepend the context path onto a servlet path\n     * @param path    a servlet path\n     * @return the context path plus the indicated path\n     */\n    public String absPath(String path) {\n        return getContextPath() + (path.startsWith(\"/\") ? path : \"/\" + path);\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path) {\n        return makeLink(anchor, path, \"\");\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @param options    extra html options to add to the anchor tag\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path, String options) {\n        if (path.startsWith(\"/\"))\n            path \u003d absPath(path);\n        return \"\u003ca href\u003d\u0027\" + path + \"\u0027 \" + options + \"\u003e\" + anchor + \"\u003c/a\u003e\";\n    }\n\n    /**\n     * Convenience method to check if this request is a POST\n     */\n    public boolean isPost() {\n        return \"POST\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to check if this request is a GET\n     */\n    public boolean isGet() {\n        return \"GET\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to retrieve a value from the flash\n     * @param key  the key to use to lookup a flash value\n     * @return the flash value associated with the indicated key or null\n     * @see #setFlash\n     */\n    public String getFlash(String key) {\n        return flash.get(key);\n    }\n\n    /**\n     * Convenience method to add a value to the flash\n     * @param key  the key to use to associate with the flash value\n     * @param val  the value to store\n     * @see #getFlash\n     */\n    public void setFlash(String key, String val) {\n        flash.put(key, val);\n    }\n\n    // caching (internal use)\n    /**\n     * Internal method used to retrieve a cached block\n     * @see #setCachedBlock\n     */\n    public static String getCachedBlock(String key) {\n        return (cacheMap \u003d\u003d null) ? null : cacheMap.get(key);\n    }\n\n    /**\n     * Internal method used to store a cached block\n     * @see #getCachedBlock\n     */\n    public static void setCachedBlock(String key, String val) {\n        if (cacheMap \u003d\u003d null) {\n            cacheMap \u003d new HashMap\u003cString, String\u003e();\n        }\n        cacheMap.put(key, val);\n    }\n\n    /**\n     * For debugging\n     * @return a string representation of this request context\n     */\n    public String toString() {\n        return toString(\", \");\n    }\n\n    public String toString(String sep) {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"params: [\");\n        String[] keys \u003d getParamNames();\n        for (String key : keys) {\n            sb.append(key).append(\u0027\u003d\u0027).append(getParam(key)).append(sep);\n        }\n        if (keys.length \u003e 0) {\n            sb.setLength(sb.length() - sep.length());\n        }\n        sb.append(\"]\");\n        sb.append(sep).append(\"method: \").append(getMethod());\n        sb.append(sep).append(\"url: \").append(getScheme());\n        sb.append(\"|\").append(getServerName());\n        sb.append(\"|\").append(getServerPort());\n        sb.append(\"|\").append(getContextPath());\n        sb.append(\"|\").append(getServletPath());\n        sb.append(\"|\").append(getQueryString());\n        if (hasMultipartContent) {\n            sb.append(sep).append(\"content len: \").append(request.getContentLength());\n            //sb.append(sep).append(\"content type: \").append(request.getContentType());\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Copy an input stream to an output stream.\n     */\n    private byte[] readStream(InputStream in) throws IOException {\n        ByteArrayOutputStream out \u003d new ByteArrayOutputStream();\n        byte[] buf \u003d new byte[4096];\n        int read;\n        while ((read \u003d in.read(buf)) \u003e -1) {\n            out.write(buf, 0, read);\n        }\n        out.flush();\n        return out.toByteArray();\n    }\n}\n",
    "package": "com.pmdesigns.jvc",
    "classname": "JVCRequestContext",
    "id": "/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContext_1Test.java",
    "test_prompt": "// JVCRequestContext_1Test.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JVCRequestContext}.\n* It contains ten unit test cases for the {@link JVCRequestContext#getParamMap(String)} method.\n*/\nclass JVCRequestContext_1Test {",
    "method_signature": "getParamMap(String)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// JVCRequestContext.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\n/**\n * This class contains state information for processing an http request.\n * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet\n * objects and provides convenience methods for accessing them.\n * \u003cp\u003e\n * It also provides access to the \u0027flash\u0027 which is a Map for storing temporary\n * key/value strings.  The scope of the flash is the current request or\n * the following request in the case of a redirect response.\n * \u003cp\u003e\n * It also contains some convenience methods for forming links and absolute paths.\n *\n * @author mike dooley\n */\npublic final class JVCRequestContext {\n\n    /**\n     * The actual HttpServletRequest object\n     */\n    public final HttpServletRequest request;\n\n    /**\n     * The actual HttpServletResponse object\n     */\n    public final HttpServletResponse response;\n\n    /**\n     * The HttpServlet object (actually this is a JVCDispatcher)\n     */\n    public final HttpServlet servlet;\n\n    /**\n     * The controller is the servlet path up to the action.\n     */\n    public final String controller;\n\n    /**\n     * The action is the last part of the servlet path (before any query arguments)\n     */\n    public final String action;\n\n    /**\n     * Tells if this request has multipart content (ie file upload)\n     */\n    public final boolean hasMultipartContent;\n\n    /**\n     * Parameter value indicating that the real parameter value is binary (and should be\n     * accessed via the getAttribute() method.\n     */\n    public static final String BINARY_VALUE \u003d \"BINARY_VALUE\";\n\n    /**\n     * The \u0027flash\u0027 map for holding temporary key/value strings.\n     */\n    public final Map\u003cString, String\u003e flash;\n\n    /**\n     * Holds cached page generator fragments\n     */\n    private static Map\u003cString, String\u003e cacheMap;\n\n    /**\n     * Constructor for JVCRequestContext which is used to hold http request and response iformation\n     * @param request\n     * @param response\n     * @param servlet\n     * @param flash\n     * @param controller\n     * @param action\n     */\n    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map\u003cString, String\u003e flash, String controller, String action) throws Exception {\n        this.request \u003d request;\n        this.response \u003d response;\n        this.servlet \u003d servlet;\n        this.controller \u003d controller;\n        this.action \u003d action;\n        this.flash \u003d flash;\n        hasMultipartContent \u003d ServletFileUpload.isMultipartContent(request);\n        if (hasMultipartContent) {\n            // Create a new file upload handler\n            ServletFileUpload upload \u003d new ServletFileUpload();\n            // Parse the request\n            FileItemIterator iter \u003d upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item \u003d iter.next();\n                String name \u003d item.getFieldName();\n                InputStream stream \u003d item.openStream();\n                if (item.isFormField()) {\n                    // add parameter as request attribute\n                    String val \u003d Streams.asString(stream);\n                    request.setAttribute(name, val);\n                    // System.out.println(\"Form field \" + name + \" with value \" + val + \" detected.\");\n                } else {\n                    // add input stream and filename as attributes\n                    String fileName \u003d item.getName();\n                    request.setAttribute(\"fileName\", fileName);\n                    byte[] data \u003d readStream(stream);\n                    request.setAttribute(name, data);\n                    // System.out.println(\"File field \" + name + \" with file name \" + fileName + \" detected.\");\n                }\n            }\n        }\n    }\n\n    // request info\n    /**\n     * Convenience method\n     * @return true if the request is secure\n     */\n    public boolean isSecure() {\n        return request.isSecure();\n    }\n\n    /**\n     * Convenience method\n     * @return the request scheme, ie. http, https\n     */\n    public String getScheme() {\n        return request.getScheme();\n    }\n\n    /**\n     * Convenience method\n     * @return the request method, ie. GET, POST\n     */\n    public String getMethod() {\n        return request.getMethod();\n    }\n\n    /**\n     * Convenience method\n     * @return the server name for this request\n     */\n    public String getServerName() {\n        return request.getServerName();\n    }\n\n    /**\n     * Convenience method\n     * @return the server port for this request\n     */\n    public int getServerPort() {\n        return request.getServerPort();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getServletPath\n     * @see #getQueryString\n     * @return the context path part of the url path\n     */\n    public String getContextPath() {\n        return request.getContextPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getContextPath\n     * @see #getQueryString\n     * @return the servlet path part of the url path\n     */\n    public String getServletPath() {\n        return request.getServletPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getContextPath\n     * @see #getServletPath\n     * @return the query string part of the url path\n     */\n    public String getQueryString() {\n        return request.getQueryString();\n    }\n\n    // params\n    /**\n     * Convenience method\n     * @param name    which parameter to get\n     * @return the parameter value or null if there is no parameter corresponding to the indicated key\n     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,\n     * which can be retrieved as a byte array via the getAttribute method.\n     * @see #getParamMap\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public String getParam(String name) {\n        if (hasMultipartContent) {\n            Object o \u003d request.getAttribute(name);\n            return (o !\u003d null \u0026\u0026 o instanceof String) ? (String) o : BINARY_VALUE;\n        } else {\n            return request.getParameter(name);\n        }\n    }\n\n    /**\n     * Convenience method which gathers all parameters of the\n     * form \u0027\u003cname\u003e[\u003ckey\u003e]\u0027 and return then in a map where the\n     * keys are the \u003ckey\u003e strings and the values are the\n     * corresponding parameter values.\n     * \u003cpre\u003e\n     * For example, if there are parameters:\n     *   \u0027foo[bar1]\u0027 \u003d \u0027baz1\u0027\n     *   \u0027foo[bar2]\u0027 \u003d \u0027baz2\u0027\n     * then getParamMap(\u0027foo\u0027) will returned the map:\n     *   map[\u0027bar1\u0027] \u003d \u0027baz1\u0027\n     *   map[\u0027bar2\u0027] \u003d \u0027baz2\u0027\n     * \u003c/pre\u003e\n     * @param name  the prefix to be used to select parameters\n     * @return a map of all paramters of the form \u0027name[\u003ckey\u003e]\u0027\n     * where the \u003ckey\u003e strings are the keys of the map and the\n     * values are the corresponding parameter values.\n     * @see #getParam\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public Map\u003cString, String\u003e getParamMap(String name) {\n        Map\u003cString, String\u003e m \u003d new HashMap\u003cString, String\u003e();\n        String prefix \u003d name + \"[\";\n        int n \u003d prefix.length();\n        if (hasMultipartContent) {\n            // for multipart requests the parameters have been stored as attributes (see constructor)\n            Enumeration\u003cString\u003e e \u003d request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                String key \u003d e.nextElement();\n                if (key.startsWith(prefix) \u0026\u0026 key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        } else {\n            Map\u003cString, String[]\u003e pm \u003d request.getParameterMap();\n            for (String key : pm.keySet()) {\n                if (key.startsWith(prefix) \u0026\u0026 key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        }\n        return m;\n    }\n\n    /**\n     * Convenience method. Use this if you expect a parameter name\n     * to map to multiple values.\n     * @param name    the name of the parameter(s) to get\n     * @return an array of paramter values corresponding to the indicated name\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamNames\n     */\n    public String[] getParamValues(String name) {\n        return request.getParameterValues(name);\n    }\n\n    /**\n     * Convenience method to get all the parameter names.\n     * @return an array of all parameter names\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamValues\n     */\n    public String[] getParamNames() {\n        if (hasMultipartContent) {\n            List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n            Enumeration\u003cString\u003e e \u003d request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                list.add(e.nextElement());\n            }\n            return list.toArray(new String[list.size()]);\n        } else {\n            Map\u003cString, String[]\u003e m \u003d request.getParameterMap();\n            String[] a \u003d new String[m.size()];\n            int i \u003d 0;\n            for (String key : m.keySet()) {\n                a[i++] \u003d key;\n            }\n            return a;\n        }\n    }\n\n    // attributes\n    /**\n     * Convenience method\n     * @param name    which attribute to get\n     * @return the attribute value or null if there is no attribute corresponding to the indicated key.\n     * If the attribute corresponds to a file upload field then the return value will be a byte array\n     */\n    public Object getAttribute(String name) {\n        return request.getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @param name    name of attribute to be set\n     * @param value   value of attribute to be set\n     */\n    public void setAttribute(String name, Object value) {\n        request.setAttribute(name, value);\n    }\n\n    // session attributes\n    /**\n     * Convenience method\n     * @param name    the name of the attribute to retrieve\n     * @return the attribute associated with the indicated name or null\n     * @see #setSessionAttr\n     * @see #getSessionAttrNames\n     */\n    public Object getSessionAttr(String name) {\n        if (request.getSession() \u003d\u003d null)\n            return null;\n        return request.getSession().getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @return all the session attribute names.\n     * @see #getSessionAttr\n     * @see #setSessionAttr\n     * @see #removeSessionAttr\n     */\n    public String[] getSessionAttrNames() {\n        if (request.getSession(false) \u003d\u003d null)\n            return new String[0];\n        ArrayList\u003cString\u003e a \u003d new ArrayList\u003cString\u003e();\n        Enumeration\u003cString\u003e e \u003d request.getSession().getAttributeNames();\n        while (e.hasMoreElements()) {\n            a.add(e.nextElement());\n        }\n        return a.toArray(new String[a.size()]);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key to store the indicated value\n     * @param value  the object to be stored\n     * @see #getSessionAttr\n     * @see #removeSessionAttr\n     */\n    public void setSessionAttr(String name, Object value) {\n        if (request.getSession() \u003d\u003d null)\n            return;\n        request.getSession().setAttribute(name, value);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key of\n     * @see #setSessionAttr\n     */\n    public void removeSessionAttr(String name) {\n        if (request.getSession() \u003d\u003d null)\n            return;\n        request.getSession().removeAttribute(name);\n    }\n\n    // cookies\n    /**\n     * Convenience method to get cookie by name\n     * @param name  the name of the cookie to get\n     * @return the cookie with the indicated name, or null\n     * @see #setCookie\n     * @see #getCookieNames\n     */\n    public Cookie getCookie(String name) {\n        if (name \u003d\u003d null)\n            return null;\n        Cookie[] cookies \u003d request.getCookies();\n        if (cookies \u003d\u003d null)\n            return null;\n        for (Cookie c : cookies) {\n            if (name.equals(c.getName()))\n                return c;\n        }\n        return null;\n    }\n\n    /**\n     * Convenience method to get all the cookie names.\n     * @return an array of the names of all the cookies in the request, possibly empty\n     * @see #getCookie\n     * @see #setCookie\n     */\n    public String[] getCookieNames() {\n        Cookie[] cookies \u003d request.getCookies();\n        if (cookies \u003d\u003d null)\n            return new String[0];\n        String[] a \u003d new String[cookies.length];\n        int i \u003d 0;\n        for (Cookie c : cookies) {\n            a[i++] \u003d c.getName();\n        }\n        return a;\n    }\n\n    /**\n     * Convenience method\n     * @param cookie   the cookie to be added to the response\n     * @see #getCookie\n     * @see #getCookieNames\n     */\n    public void setCookie(Cookie cookie) {\n        response.addCookie(cookie);\n    }\n\n    /**\n     * Cause a non-standard response (ie. redirect) to be returned.\n     * @param httpCode   the http response code to be returned\n     * @param arg    an argument or message to be returned (depends on response code)\n     * @see #redirect\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void nonStandardResponse(int httpCode, String arg) {\n        throw new NonStandardResponseException(httpCode, arg);\n    }\n\n    /**\n     * Cause a redirect response to be returned\n     * @param path  where to redirect to. If the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #nonStandardResponse\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void redirect(String path) {\n        if (path.startsWith(\"/\"))\n            path \u003d absPath(path);\n        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);\n    }\n\n    /**\n     * Cause a binary response to be returned\n     * @param in input stream containing binary data to be sent\n     * @throws BinaryResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the BinaryResponseException.\n     */\n    public void sendBinaryResponse(InputStream in) {\n        throw new BinaryResponseException(in);\n    }\n\n    /**\n     * Convenience method to prepend the context path onto a servlet path\n     * @param path    a servlet path\n     * @return the context path plus the indicated path\n     */\n    public String absPath(String path) {\n        return getContextPath() + (path.startsWith(\"/\") ? path : \"/\" + path);\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path) {\n        return makeLink(anchor, path, \"\");\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @param options    extra html options to add to the anchor tag\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path, String options) {\n        if (path.startsWith(\"/\"))\n            path \u003d absPath(path);\n        return \"\u003ca href\u003d\u0027\" + path + \"\u0027 \" + options + \"\u003e\" + anchor + \"\u003c/a\u003e\";\n    }\n\n    /**\n     * Convenience method to check if this request is a POST\n     */\n    public boolean isPost() {\n        return \"POST\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to check if this request is a GET\n     */\n    public boolean isGet() {\n        return \"GET\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to retrieve a value from the flash\n     * @param key  the key to use to lookup a flash value\n     * @return the flash value associated with the indicated key or null\n     * @see #setFlash\n     */\n    public String getFlash(String key) {\n        return flash.get(key);\n    }\n\n    /**\n     * Convenience method to add a value to the flash\n     * @param key  the key to use to associate with the flash value\n     * @param val  the value to store\n     * @see #getFlash\n     */\n    public void setFlash(String key, String val) {\n        flash.put(key, val);\n    }\n\n    // caching (internal use)\n    /**\n     * Internal method used to retrieve a cached block\n     * @see #setCachedBlock\n     */\n    public static String getCachedBlock(String key) {\n        return (cacheMap \u003d\u003d null) ? null : cacheMap.get(key);\n    }\n\n    /**\n     * Internal method used to store a cached block\n     * @see #getCachedBlock\n     */\n    public static void setCachedBlock(String key, String val) {\n        if (cacheMap \u003d\u003d null) {\n            cacheMap \u003d new HashMap\u003cString, String\u003e();\n        }\n        cacheMap.put(key, val);\n    }\n\n    /**\n     * For debugging\n     * @return a string representation of this request context\n     */\n    public String toString() {\n        return toString(\", \");\n    }\n\n    public String toString(String sep) {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"params: [\");\n        String[] keys \u003d getParamNames();\n        for (String key : keys) {\n            sb.append(key).append(\u0027\u003d\u0027).append(getParam(key)).append(sep);\n        }\n        if (keys.length \u003e 0) {\n            sb.setLength(sb.length() - sep.length());\n        }\n        sb.append(\"]\");\n        sb.append(sep).append(\"method: \").append(getMethod());\n        sb.append(sep).append(\"url: \").append(getScheme());\n        sb.append(\"|\").append(getServerName());\n        sb.append(\"|\").append(getServerPort());\n        sb.append(\"|\").append(getContextPath());\n        sb.append(\"|\").append(getServletPath());\n        sb.append(\"|\").append(getQueryString());\n        if (hasMultipartContent) {\n            sb.append(sep).append(\"content len: \").append(request.getContentLength());\n            //sb.append(sep).append(\"content type: \").append(request.getContentType());\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Copy an input stream to an output stream.\n     */\n    private byte[] readStream(InputStream in) throws IOException {\n        ByteArrayOutputStream out \u003d new ByteArrayOutputStream();\n        byte[] buf \u003d new byte[4096];\n        int read;\n        while ((read \u003d in.read(buf)) \u003e -1) {\n            out.write(buf, 0, read);\n        }\n        out.flush();\n        return out.toByteArray();\n    }\n}\n",
    "package": "com.pmdesigns.jvc",
    "classname": "JVCRequestContext",
    "id": "/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContext_2Test.java",
    "test_prompt": "// JVCRequestContext_2Test.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JVCRequestContext}.\n* It contains ten unit test cases for the {@link JVCRequestContext#getParamValues(String)} method.\n*/\nclass JVCRequestContext_2Test {",
    "method_signature": "getParamValues(String)",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// JVCRequestContext.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\n/**\n * This class contains state information for processing an http request.\n * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet\n * objects and provides convenience methods for accessing them.\n * \u003cp\u003e\n * It also provides access to the \u0027flash\u0027 which is a Map for storing temporary\n * key/value strings.  The scope of the flash is the current request or\n * the following request in the case of a redirect response.\n * \u003cp\u003e\n * It also contains some convenience methods for forming links and absolute paths.\n *\n * @author mike dooley\n */\npublic final class JVCRequestContext {\n\n    /**\n     * The actual HttpServletRequest object\n     */\n    public final HttpServletRequest request;\n\n    /**\n     * The actual HttpServletResponse object\n     */\n    public final HttpServletResponse response;\n\n    /**\n     * The HttpServlet object (actually this is a JVCDispatcher)\n     */\n    public final HttpServlet servlet;\n\n    /**\n     * The controller is the servlet path up to the action.\n     */\n    public final String controller;\n\n    /**\n     * The action is the last part of the servlet path (before any query arguments)\n     */\n    public final String action;\n\n    /**\n     * Tells if this request has multipart content (ie file upload)\n     */\n    public final boolean hasMultipartContent;\n\n    /**\n     * Parameter value indicating that the real parameter value is binary (and should be\n     * accessed via the getAttribute() method.\n     */\n    public static final String BINARY_VALUE \u003d \"BINARY_VALUE\";\n\n    /**\n     * The \u0027flash\u0027 map for holding temporary key/value strings.\n     */\n    public final Map\u003cString, String\u003e flash;\n\n    /**\n     * Holds cached page generator fragments\n     */\n    private static Map\u003cString, String\u003e cacheMap;\n\n    /**\n     * Constructor for JVCRequestContext which is used to hold http request and response iformation\n     * @param request\n     * @param response\n     * @param servlet\n     * @param flash\n     * @param controller\n     * @param action\n     */\n    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map\u003cString, String\u003e flash, String controller, String action) throws Exception {\n        this.request \u003d request;\n        this.response \u003d response;\n        this.servlet \u003d servlet;\n        this.controller \u003d controller;\n        this.action \u003d action;\n        this.flash \u003d flash;\n        hasMultipartContent \u003d ServletFileUpload.isMultipartContent(request);\n        if (hasMultipartContent) {\n            // Create a new file upload handler\n            ServletFileUpload upload \u003d new ServletFileUpload();\n            // Parse the request\n            FileItemIterator iter \u003d upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item \u003d iter.next();\n                String name \u003d item.getFieldName();\n                InputStream stream \u003d item.openStream();\n                if (item.isFormField()) {\n                    // add parameter as request attribute\n                    String val \u003d Streams.asString(stream);\n                    request.setAttribute(name, val);\n                    // System.out.println(\"Form field \" + name + \" with value \" + val + \" detected.\");\n                } else {\n                    // add input stream and filename as attributes\n                    String fileName \u003d item.getName();\n                    request.setAttribute(\"fileName\", fileName);\n                    byte[] data \u003d readStream(stream);\n                    request.setAttribute(name, data);\n                    // System.out.println(\"File field \" + name + \" with file name \" + fileName + \" detected.\");\n                }\n            }\n        }\n    }\n\n    // request info\n    /**\n     * Convenience method\n     * @return true if the request is secure\n     */\n    public boolean isSecure() {\n        return request.isSecure();\n    }\n\n    /**\n     * Convenience method\n     * @return the request scheme, ie. http, https\n     */\n    public String getScheme() {\n        return request.getScheme();\n    }\n\n    /**\n     * Convenience method\n     * @return the request method, ie. GET, POST\n     */\n    public String getMethod() {\n        return request.getMethod();\n    }\n\n    /**\n     * Convenience method\n     * @return the server name for this request\n     */\n    public String getServerName() {\n        return request.getServerName();\n    }\n\n    /**\n     * Convenience method\n     * @return the server port for this request\n     */\n    public int getServerPort() {\n        return request.getServerPort();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getServletPath\n     * @see #getQueryString\n     * @return the context path part of the url path\n     */\n    public String getContextPath() {\n        return request.getContextPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getContextPath\n     * @see #getQueryString\n     * @return the servlet path part of the url path\n     */\n    public String getServletPath() {\n        return request.getServletPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getContextPath\n     * @see #getServletPath\n     * @return the query string part of the url path\n     */\n    public String getQueryString() {\n        return request.getQueryString();\n    }\n\n    // params\n    /**\n     * Convenience method\n     * @param name    which parameter to get\n     * @return the parameter value or null if there is no parameter corresponding to the indicated key\n     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,\n     * which can be retrieved as a byte array via the getAttribute method.\n     * @see #getParamMap\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public String getParam(String name) {\n        if (hasMultipartContent) {\n            Object o \u003d request.getAttribute(name);\n            return (o !\u003d null \u0026\u0026 o instanceof String) ? (String) o : BINARY_VALUE;\n        } else {\n            return request.getParameter(name);\n        }\n    }\n\n    /**\n     * Convenience method which gathers all parameters of the\n     * form \u0027\u003cname\u003e[\u003ckey\u003e]\u0027 and return then in a map where the\n     * keys are the \u003ckey\u003e strings and the values are the\n     * corresponding parameter values.\n     * \u003cpre\u003e\n     * For example, if there are parameters:\n     *   \u0027foo[bar1]\u0027 \u003d \u0027baz1\u0027\n     *   \u0027foo[bar2]\u0027 \u003d \u0027baz2\u0027\n     * then getParamMap(\u0027foo\u0027) will returned the map:\n     *   map[\u0027bar1\u0027] \u003d \u0027baz1\u0027\n     *   map[\u0027bar2\u0027] \u003d \u0027baz2\u0027\n     * \u003c/pre\u003e\n     * @param name  the prefix to be used to select parameters\n     * @return a map of all paramters of the form \u0027name[\u003ckey\u003e]\u0027\n     * where the \u003ckey\u003e strings are the keys of the map and the\n     * values are the corresponding parameter values.\n     * @see #getParam\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public Map\u003cString, String\u003e getParamMap(String name) {\n        Map\u003cString, String\u003e m \u003d new HashMap\u003cString, String\u003e();\n        String prefix \u003d name + \"[\";\n        int n \u003d prefix.length();\n        if (hasMultipartContent) {\n            // for multipart requests the parameters have been stored as attributes (see constructor)\n            Enumeration\u003cString\u003e e \u003d request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                String key \u003d e.nextElement();\n                if (key.startsWith(prefix) \u0026\u0026 key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        } else {\n            Map\u003cString, String[]\u003e pm \u003d request.getParameterMap();\n            for (String key : pm.keySet()) {\n                if (key.startsWith(prefix) \u0026\u0026 key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        }\n        return m;\n    }\n\n    /**\n     * Convenience method. Use this if you expect a parameter name\n     * to map to multiple values.\n     * @param name    the name of the parameter(s) to get\n     * @return an array of paramter values corresponding to the indicated name\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamNames\n     */\n    public String[] getParamValues(String name) {\n        return request.getParameterValues(name);\n    }\n\n    /**\n     * Convenience method to get all the parameter names.\n     * @return an array of all parameter names\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamValues\n     */\n    public String[] getParamNames() {\n        if (hasMultipartContent) {\n            List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n            Enumeration\u003cString\u003e e \u003d request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                list.add(e.nextElement());\n            }\n            return list.toArray(new String[list.size()]);\n        } else {\n            Map\u003cString, String[]\u003e m \u003d request.getParameterMap();\n            String[] a \u003d new String[m.size()];\n            int i \u003d 0;\n            for (String key : m.keySet()) {\n                a[i++] \u003d key;\n            }\n            return a;\n        }\n    }\n\n    // attributes\n    /**\n     * Convenience method\n     * @param name    which attribute to get\n     * @return the attribute value or null if there is no attribute corresponding to the indicated key.\n     * If the attribute corresponds to a file upload field then the return value will be a byte array\n     */\n    public Object getAttribute(String name) {\n        return request.getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @param name    name of attribute to be set\n     * @param value   value of attribute to be set\n     */\n    public void setAttribute(String name, Object value) {\n        request.setAttribute(name, value);\n    }\n\n    // session attributes\n    /**\n     * Convenience method\n     * @param name    the name of the attribute to retrieve\n     * @return the attribute associated with the indicated name or null\n     * @see #setSessionAttr\n     * @see #getSessionAttrNames\n     */\n    public Object getSessionAttr(String name) {\n        if (request.getSession() \u003d\u003d null)\n            return null;\n        return request.getSession().getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @return all the session attribute names.\n     * @see #getSessionAttr\n     * @see #setSessionAttr\n     * @see #removeSessionAttr\n     */\n    public String[] getSessionAttrNames() {\n        if (request.getSession(false) \u003d\u003d null)\n            return new String[0];\n        ArrayList\u003cString\u003e a \u003d new ArrayList\u003cString\u003e();\n        Enumeration\u003cString\u003e e \u003d request.getSession().getAttributeNames();\n        while (e.hasMoreElements()) {\n            a.add(e.nextElement());\n        }\n        return a.toArray(new String[a.size()]);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key to store the indicated value\n     * @param value  the object to be stored\n     * @see #getSessionAttr\n     * @see #removeSessionAttr\n     */\n    public void setSessionAttr(String name, Object value) {\n        if (request.getSession() \u003d\u003d null)\n            return;\n        request.getSession().setAttribute(name, value);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key of\n     * @see #setSessionAttr\n     */\n    public void removeSessionAttr(String name) {\n        if (request.getSession() \u003d\u003d null)\n            return;\n        request.getSession().removeAttribute(name);\n    }\n\n    // cookies\n    /**\n     * Convenience method to get cookie by name\n     * @param name  the name of the cookie to get\n     * @return the cookie with the indicated name, or null\n     * @see #setCookie\n     * @see #getCookieNames\n     */\n    public Cookie getCookie(String name) {\n        if (name \u003d\u003d null)\n            return null;\n        Cookie[] cookies \u003d request.getCookies();\n        if (cookies \u003d\u003d null)\n            return null;\n        for (Cookie c : cookies) {\n            if (name.equals(c.getName()))\n                return c;\n        }\n        return null;\n    }\n\n    /**\n     * Convenience method to get all the cookie names.\n     * @return an array of the names of all the cookies in the request, possibly empty\n     * @see #getCookie\n     * @see #setCookie\n     */\n    public String[] getCookieNames() {\n        Cookie[] cookies \u003d request.getCookies();\n        if (cookies \u003d\u003d null)\n            return new String[0];\n        String[] a \u003d new String[cookies.length];\n        int i \u003d 0;\n        for (Cookie c : cookies) {\n            a[i++] \u003d c.getName();\n        }\n        return a;\n    }\n\n    /**\n     * Convenience method\n     * @param cookie   the cookie to be added to the response\n     * @see #getCookie\n     * @see #getCookieNames\n     */\n    public void setCookie(Cookie cookie) {\n        response.addCookie(cookie);\n    }\n\n    /**\n     * Cause a non-standard response (ie. redirect) to be returned.\n     * @param httpCode   the http response code to be returned\n     * @param arg    an argument or message to be returned (depends on response code)\n     * @see #redirect\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void nonStandardResponse(int httpCode, String arg) {\n        throw new NonStandardResponseException(httpCode, arg);\n    }\n\n    /**\n     * Cause a redirect response to be returned\n     * @param path  where to redirect to. If the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #nonStandardResponse\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void redirect(String path) {\n        if (path.startsWith(\"/\"))\n            path \u003d absPath(path);\n        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);\n    }\n\n    /**\n     * Cause a binary response to be returned\n     * @param in input stream containing binary data to be sent\n     * @throws BinaryResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the BinaryResponseException.\n     */\n    public void sendBinaryResponse(InputStream in) {\n        throw new BinaryResponseException(in);\n    }\n\n    /**\n     * Convenience method to prepend the context path onto a servlet path\n     * @param path    a servlet path\n     * @return the context path plus the indicated path\n     */\n    public String absPath(String path) {\n        return getContextPath() + (path.startsWith(\"/\") ? path : \"/\" + path);\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path) {\n        return makeLink(anchor, path, \"\");\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @param options    extra html options to add to the anchor tag\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path, String options) {\n        if (path.startsWith(\"/\"))\n            path \u003d absPath(path);\n        return \"\u003ca href\u003d\u0027\" + path + \"\u0027 \" + options + \"\u003e\" + anchor + \"\u003c/a\u003e\";\n    }\n\n    /**\n     * Convenience method to check if this request is a POST\n     */\n    public boolean isPost() {\n        return \"POST\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to check if this request is a GET\n     */\n    public boolean isGet() {\n        return \"GET\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to retrieve a value from the flash\n     * @param key  the key to use to lookup a flash value\n     * @return the flash value associated with the indicated key or null\n     * @see #setFlash\n     */\n    public String getFlash(String key) {\n        return flash.get(key);\n    }\n\n    /**\n     * Convenience method to add a value to the flash\n     * @param key  the key to use to associate with the flash value\n     * @param val  the value to store\n     * @see #getFlash\n     */\n    public void setFlash(String key, String val) {\n        flash.put(key, val);\n    }\n\n    // caching (internal use)\n    /**\n     * Internal method used to retrieve a cached block\n     * @see #setCachedBlock\n     */\n    public static String getCachedBlock(String key) {\n        return (cacheMap \u003d\u003d null) ? null : cacheMap.get(key);\n    }\n\n    /**\n     * Internal method used to store a cached block\n     * @see #getCachedBlock\n     */\n    public static void setCachedBlock(String key, String val) {\n        if (cacheMap \u003d\u003d null) {\n            cacheMap \u003d new HashMap\u003cString, String\u003e();\n        }\n        cacheMap.put(key, val);\n    }\n\n    /**\n     * For debugging\n     * @return a string representation of this request context\n     */\n    public String toString() {\n        return toString(\", \");\n    }\n\n    public String toString(String sep) {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"params: [\");\n        String[] keys \u003d getParamNames();\n        for (String key : keys) {\n            sb.append(key).append(\u0027\u003d\u0027).append(getParam(key)).append(sep);\n        }\n        if (keys.length \u003e 0) {\n            sb.setLength(sb.length() - sep.length());\n        }\n        sb.append(\"]\");\n        sb.append(sep).append(\"method: \").append(getMethod());\n        sb.append(sep).append(\"url: \").append(getScheme());\n        sb.append(\"|\").append(getServerName());\n        sb.append(\"|\").append(getServerPort());\n        sb.append(\"|\").append(getContextPath());\n        sb.append(\"|\").append(getServletPath());\n        sb.append(\"|\").append(getQueryString());\n        if (hasMultipartContent) {\n            sb.append(sep).append(\"content len: \").append(request.getContentLength());\n            //sb.append(sep).append(\"content type: \").append(request.getContentType());\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Copy an input stream to an output stream.\n     */\n    private byte[] readStream(InputStream in) throws IOException {\n        ByteArrayOutputStream out \u003d new ByteArrayOutputStream();\n        byte[] buf \u003d new byte[4096];\n        int read;\n        while ((read \u003d in.read(buf)) \u003e -1) {\n            out.write(buf, 0, read);\n        }\n        out.flush();\n        return out.toByteArray();\n    }\n}\n",
    "package": "com.pmdesigns.jvc",
    "classname": "JVCRequestContext",
    "id": "/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContext_3Test.java",
    "test_prompt": "// JVCRequestContext_3Test.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JVCRequestContext}.\n* It contains ten unit test cases for the {@link JVCRequestContext#getAttribute(String)} method.\n*/\nclass JVCRequestContext_3Test {",
    "method_signature": "getAttribute(String)",
    "suffix": "3"
  },
  {
    "numberTests": "ten",
    "original_code": "// JVCRequestContext.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\n/**\n * This class contains state information for processing an http request.\n * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet\n * objects and provides convenience methods for accessing them.\n * \u003cp\u003e\n * It also provides access to the \u0027flash\u0027 which is a Map for storing temporary\n * key/value strings.  The scope of the flash is the current request or\n * the following request in the case of a redirect response.\n * \u003cp\u003e\n * It also contains some convenience methods for forming links and absolute paths.\n *\n * @author mike dooley\n */\npublic final class JVCRequestContext {\n\n    /**\n     * The actual HttpServletRequest object\n     */\n    public final HttpServletRequest request;\n\n    /**\n     * The actual HttpServletResponse object\n     */\n    public final HttpServletResponse response;\n\n    /**\n     * The HttpServlet object (actually this is a JVCDispatcher)\n     */\n    public final HttpServlet servlet;\n\n    /**\n     * The controller is the servlet path up to the action.\n     */\n    public final String controller;\n\n    /**\n     * The action is the last part of the servlet path (before any query arguments)\n     */\n    public final String action;\n\n    /**\n     * Tells if this request has multipart content (ie file upload)\n     */\n    public final boolean hasMultipartContent;\n\n    /**\n     * Parameter value indicating that the real parameter value is binary (and should be\n     * accessed via the getAttribute() method.\n     */\n    public static final String BINARY_VALUE \u003d \"BINARY_VALUE\";\n\n    /**\n     * The \u0027flash\u0027 map for holding temporary key/value strings.\n     */\n    public final Map\u003cString, String\u003e flash;\n\n    /**\n     * Holds cached page generator fragments\n     */\n    private static Map\u003cString, String\u003e cacheMap;\n\n    /**\n     * Constructor for JVCRequestContext which is used to hold http request and response iformation\n     * @param request\n     * @param response\n     * @param servlet\n     * @param flash\n     * @param controller\n     * @param action\n     */\n    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map\u003cString, String\u003e flash, String controller, String action) throws Exception {\n        this.request \u003d request;\n        this.response \u003d response;\n        this.servlet \u003d servlet;\n        this.controller \u003d controller;\n        this.action \u003d action;\n        this.flash \u003d flash;\n        hasMultipartContent \u003d ServletFileUpload.isMultipartContent(request);\n        if (hasMultipartContent) {\n            // Create a new file upload handler\n            ServletFileUpload upload \u003d new ServletFileUpload();\n            // Parse the request\n            FileItemIterator iter \u003d upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item \u003d iter.next();\n                String name \u003d item.getFieldName();\n                InputStream stream \u003d item.openStream();\n                if (item.isFormField()) {\n                    // add parameter as request attribute\n                    String val \u003d Streams.asString(stream);\n                    request.setAttribute(name, val);\n                    // System.out.println(\"Form field \" + name + \" with value \" + val + \" detected.\");\n                } else {\n                    // add input stream and filename as attributes\n                    String fileName \u003d item.getName();\n                    request.setAttribute(\"fileName\", fileName);\n                    byte[] data \u003d readStream(stream);\n                    request.setAttribute(name, data);\n                    // System.out.println(\"File field \" + name + \" with file name \" + fileName + \" detected.\");\n                }\n            }\n        }\n    }\n\n    // request info\n    /**\n     * Convenience method\n     * @return true if the request is secure\n     */\n    public boolean isSecure() {\n        return request.isSecure();\n    }\n\n    /**\n     * Convenience method\n     * @return the request scheme, ie. http, https\n     */\n    public String getScheme() {\n        return request.getScheme();\n    }\n\n    /**\n     * Convenience method\n     * @return the request method, ie. GET, POST\n     */\n    public String getMethod() {\n        return request.getMethod();\n    }\n\n    /**\n     * Convenience method\n     * @return the server name for this request\n     */\n    public String getServerName() {\n        return request.getServerName();\n    }\n\n    /**\n     * Convenience method\n     * @return the server port for this request\n     */\n    public int getServerPort() {\n        return request.getServerPort();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getServletPath\n     * @see #getQueryString\n     * @return the context path part of the url path\n     */\n    public String getContextPath() {\n        return request.getContextPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getContextPath\n     * @see #getQueryString\n     * @return the servlet path part of the url path\n     */\n    public String getServletPath() {\n        return request.getServletPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getContextPath\n     * @see #getServletPath\n     * @return the query string part of the url path\n     */\n    public String getQueryString() {\n        return request.getQueryString();\n    }\n\n    // params\n    /**\n     * Convenience method\n     * @param name    which parameter to get\n     * @return the parameter value or null if there is no parameter corresponding to the indicated key\n     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,\n     * which can be retrieved as a byte array via the getAttribute method.\n     * @see #getParamMap\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public String getParam(String name) {\n        if (hasMultipartContent) {\n            Object o \u003d request.getAttribute(name);\n            return (o !\u003d null \u0026\u0026 o instanceof String) ? (String) o : BINARY_VALUE;\n        } else {\n            return request.getParameter(name);\n        }\n    }\n\n    /**\n     * Convenience method which gathers all parameters of the\n     * form \u0027\u003cname\u003e[\u003ckey\u003e]\u0027 and return then in a map where the\n     * keys are the \u003ckey\u003e strings and the values are the\n     * corresponding parameter values.\n     * \u003cpre\u003e\n     * For example, if there are parameters:\n     *   \u0027foo[bar1]\u0027 \u003d \u0027baz1\u0027\n     *   \u0027foo[bar2]\u0027 \u003d \u0027baz2\u0027\n     * then getParamMap(\u0027foo\u0027) will returned the map:\n     *   map[\u0027bar1\u0027] \u003d \u0027baz1\u0027\n     *   map[\u0027bar2\u0027] \u003d \u0027baz2\u0027\n     * \u003c/pre\u003e\n     * @param name  the prefix to be used to select parameters\n     * @return a map of all paramters of the form \u0027name[\u003ckey\u003e]\u0027\n     * where the \u003ckey\u003e strings are the keys of the map and the\n     * values are the corresponding parameter values.\n     * @see #getParam\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public Map\u003cString, String\u003e getParamMap(String name) {\n        Map\u003cString, String\u003e m \u003d new HashMap\u003cString, String\u003e();\n        String prefix \u003d name + \"[\";\n        int n \u003d prefix.length();\n        if (hasMultipartContent) {\n            // for multipart requests the parameters have been stored as attributes (see constructor)\n            Enumeration\u003cString\u003e e \u003d request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                String key \u003d e.nextElement();\n                if (key.startsWith(prefix) \u0026\u0026 key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        } else {\n            Map\u003cString, String[]\u003e pm \u003d request.getParameterMap();\n            for (String key : pm.keySet()) {\n                if (key.startsWith(prefix) \u0026\u0026 key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        }\n        return m;\n    }\n\n    /**\n     * Convenience method. Use this if you expect a parameter name\n     * to map to multiple values.\n     * @param name    the name of the parameter(s) to get\n     * @return an array of paramter values corresponding to the indicated name\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamNames\n     */\n    public String[] getParamValues(String name) {\n        return request.getParameterValues(name);\n    }\n\n    /**\n     * Convenience method to get all the parameter names.\n     * @return an array of all parameter names\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamValues\n     */\n    public String[] getParamNames() {\n        if (hasMultipartContent) {\n            List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n            Enumeration\u003cString\u003e e \u003d request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                list.add(e.nextElement());\n            }\n            return list.toArray(new String[list.size()]);\n        } else {\n            Map\u003cString, String[]\u003e m \u003d request.getParameterMap();\n            String[] a \u003d new String[m.size()];\n            int i \u003d 0;\n            for (String key : m.keySet()) {\n                a[i++] \u003d key;\n            }\n            return a;\n        }\n    }\n\n    // attributes\n    /**\n     * Convenience method\n     * @param name    which attribute to get\n     * @return the attribute value or null if there is no attribute corresponding to the indicated key.\n     * If the attribute corresponds to a file upload field then the return value will be a byte array\n     */\n    public Object getAttribute(String name) {\n        return request.getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @param name    name of attribute to be set\n     * @param value   value of attribute to be set\n     */\n    public void setAttribute(String name, Object value) {\n        request.setAttribute(name, value);\n    }\n\n    // session attributes\n    /**\n     * Convenience method\n     * @param name    the name of the attribute to retrieve\n     * @return the attribute associated with the indicated name or null\n     * @see #setSessionAttr\n     * @see #getSessionAttrNames\n     */\n    public Object getSessionAttr(String name) {\n        if (request.getSession() \u003d\u003d null)\n            return null;\n        return request.getSession().getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @return all the session attribute names.\n     * @see #getSessionAttr\n     * @see #setSessionAttr\n     * @see #removeSessionAttr\n     */\n    public String[] getSessionAttrNames() {\n        if (request.getSession(false) \u003d\u003d null)\n            return new String[0];\n        ArrayList\u003cString\u003e a \u003d new ArrayList\u003cString\u003e();\n        Enumeration\u003cString\u003e e \u003d request.getSession().getAttributeNames();\n        while (e.hasMoreElements()) {\n            a.add(e.nextElement());\n        }\n        return a.toArray(new String[a.size()]);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key to store the indicated value\n     * @param value  the object to be stored\n     * @see #getSessionAttr\n     * @see #removeSessionAttr\n     */\n    public void setSessionAttr(String name, Object value) {\n        if (request.getSession() \u003d\u003d null)\n            return;\n        request.getSession().setAttribute(name, value);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key of\n     * @see #setSessionAttr\n     */\n    public void removeSessionAttr(String name) {\n        if (request.getSession() \u003d\u003d null)\n            return;\n        request.getSession().removeAttribute(name);\n    }\n\n    // cookies\n    /**\n     * Convenience method to get cookie by name\n     * @param name  the name of the cookie to get\n     * @return the cookie with the indicated name, or null\n     * @see #setCookie\n     * @see #getCookieNames\n     */\n    public Cookie getCookie(String name) {\n        if (name \u003d\u003d null)\n            return null;\n        Cookie[] cookies \u003d request.getCookies();\n        if (cookies \u003d\u003d null)\n            return null;\n        for (Cookie c : cookies) {\n            if (name.equals(c.getName()))\n                return c;\n        }\n        return null;\n    }\n\n    /**\n     * Convenience method to get all the cookie names.\n     * @return an array of the names of all the cookies in the request, possibly empty\n     * @see #getCookie\n     * @see #setCookie\n     */\n    public String[] getCookieNames() {\n        Cookie[] cookies \u003d request.getCookies();\n        if (cookies \u003d\u003d null)\n            return new String[0];\n        String[] a \u003d new String[cookies.length];\n        int i \u003d 0;\n        for (Cookie c : cookies) {\n            a[i++] \u003d c.getName();\n        }\n        return a;\n    }\n\n    /**\n     * Convenience method\n     * @param cookie   the cookie to be added to the response\n     * @see #getCookie\n     * @see #getCookieNames\n     */\n    public void setCookie(Cookie cookie) {\n        response.addCookie(cookie);\n    }\n\n    /**\n     * Cause a non-standard response (ie. redirect) to be returned.\n     * @param httpCode   the http response code to be returned\n     * @param arg    an argument or message to be returned (depends on response code)\n     * @see #redirect\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void nonStandardResponse(int httpCode, String arg) {\n        throw new NonStandardResponseException(httpCode, arg);\n    }\n\n    /**\n     * Cause a redirect response to be returned\n     * @param path  where to redirect to. If the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #nonStandardResponse\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void redirect(String path) {\n        if (path.startsWith(\"/\"))\n            path \u003d absPath(path);\n        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);\n    }\n\n    /**\n     * Cause a binary response to be returned\n     * @param in input stream containing binary data to be sent\n     * @throws BinaryResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the BinaryResponseException.\n     */\n    public void sendBinaryResponse(InputStream in) {\n        throw new BinaryResponseException(in);\n    }\n\n    /**\n     * Convenience method to prepend the context path onto a servlet path\n     * @param path    a servlet path\n     * @return the context path plus the indicated path\n     */\n    public String absPath(String path) {\n        return getContextPath() + (path.startsWith(\"/\") ? path : \"/\" + path);\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path) {\n        return makeLink(anchor, path, \"\");\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @param options    extra html options to add to the anchor tag\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path, String options) {\n        if (path.startsWith(\"/\"))\n            path \u003d absPath(path);\n        return \"\u003ca href\u003d\u0027\" + path + \"\u0027 \" + options + \"\u003e\" + anchor + \"\u003c/a\u003e\";\n    }\n\n    /**\n     * Convenience method to check if this request is a POST\n     */\n    public boolean isPost() {\n        return \"POST\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to check if this request is a GET\n     */\n    public boolean isGet() {\n        return \"GET\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to retrieve a value from the flash\n     * @param key  the key to use to lookup a flash value\n     * @return the flash value associated with the indicated key or null\n     * @see #setFlash\n     */\n    public String getFlash(String key) {\n        return flash.get(key);\n    }\n\n    /**\n     * Convenience method to add a value to the flash\n     * @param key  the key to use to associate with the flash value\n     * @param val  the value to store\n     * @see #getFlash\n     */\n    public void setFlash(String key, String val) {\n        flash.put(key, val);\n    }\n\n    // caching (internal use)\n    /**\n     * Internal method used to retrieve a cached block\n     * @see #setCachedBlock\n     */\n    public static String getCachedBlock(String key) {\n        return (cacheMap \u003d\u003d null) ? null : cacheMap.get(key);\n    }\n\n    /**\n     * Internal method used to store a cached block\n     * @see #getCachedBlock\n     */\n    public static void setCachedBlock(String key, String val) {\n        if (cacheMap \u003d\u003d null) {\n            cacheMap \u003d new HashMap\u003cString, String\u003e();\n        }\n        cacheMap.put(key, val);\n    }\n\n    /**\n     * For debugging\n     * @return a string representation of this request context\n     */\n    public String toString() {\n        return toString(\", \");\n    }\n\n    public String toString(String sep) {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"params: [\");\n        String[] keys \u003d getParamNames();\n        for (String key : keys) {\n            sb.append(key).append(\u0027\u003d\u0027).append(getParam(key)).append(sep);\n        }\n        if (keys.length \u003e 0) {\n            sb.setLength(sb.length() - sep.length());\n        }\n        sb.append(\"]\");\n        sb.append(sep).append(\"method: \").append(getMethod());\n        sb.append(sep).append(\"url: \").append(getScheme());\n        sb.append(\"|\").append(getServerName());\n        sb.append(\"|\").append(getServerPort());\n        sb.append(\"|\").append(getContextPath());\n        sb.append(\"|\").append(getServletPath());\n        sb.append(\"|\").append(getQueryString());\n        if (hasMultipartContent) {\n            sb.append(sep).append(\"content len: \").append(request.getContentLength());\n            //sb.append(sep).append(\"content type: \").append(request.getContentType());\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Copy an input stream to an output stream.\n     */\n    private byte[] readStream(InputStream in) throws IOException {\n        ByteArrayOutputStream out \u003d new ByteArrayOutputStream();\n        byte[] buf \u003d new byte[4096];\n        int read;\n        while ((read \u003d in.read(buf)) \u003e -1) {\n            out.write(buf, 0, read);\n        }\n        out.flush();\n        return out.toByteArray();\n    }\n}\n",
    "package": "com.pmdesigns.jvc",
    "classname": "JVCRequestContext",
    "id": "/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContext_4Test.java",
    "test_prompt": "// JVCRequestContext_4Test.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JVCRequestContext}.\n* It contains ten unit test cases for the {@link JVCRequestContext#getSessionAttr(String)} method.\n*/\nclass JVCRequestContext_4Test {",
    "method_signature": "getSessionAttr(String)",
    "suffix": "4"
  },
  {
    "numberTests": "ten",
    "original_code": "// JVCRequestContext.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\n/**\n * This class contains state information for processing an http request.\n * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet\n * objects and provides convenience methods for accessing them.\n * \u003cp\u003e\n * It also provides access to the \u0027flash\u0027 which is a Map for storing temporary\n * key/value strings.  The scope of the flash is the current request or\n * the following request in the case of a redirect response.\n * \u003cp\u003e\n * It also contains some convenience methods for forming links and absolute paths.\n *\n * @author mike dooley\n */\npublic final class JVCRequestContext {\n\n    /**\n     * The actual HttpServletRequest object\n     */\n    public final HttpServletRequest request;\n\n    /**\n     * The actual HttpServletResponse object\n     */\n    public final HttpServletResponse response;\n\n    /**\n     * The HttpServlet object (actually this is a JVCDispatcher)\n     */\n    public final HttpServlet servlet;\n\n    /**\n     * The controller is the servlet path up to the action.\n     */\n    public final String controller;\n\n    /**\n     * The action is the last part of the servlet path (before any query arguments)\n     */\n    public final String action;\n\n    /**\n     * Tells if this request has multipart content (ie file upload)\n     */\n    public final boolean hasMultipartContent;\n\n    /**\n     * Parameter value indicating that the real parameter value is binary (and should be\n     * accessed via the getAttribute() method.\n     */\n    public static final String BINARY_VALUE \u003d \"BINARY_VALUE\";\n\n    /**\n     * The \u0027flash\u0027 map for holding temporary key/value strings.\n     */\n    public final Map\u003cString, String\u003e flash;\n\n    /**\n     * Holds cached page generator fragments\n     */\n    private static Map\u003cString, String\u003e cacheMap;\n\n    /**\n     * Constructor for JVCRequestContext which is used to hold http request and response iformation\n     * @param request\n     * @param response\n     * @param servlet\n     * @param flash\n     * @param controller\n     * @param action\n     */\n    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map\u003cString, String\u003e flash, String controller, String action) throws Exception {\n        this.request \u003d request;\n        this.response \u003d response;\n        this.servlet \u003d servlet;\n        this.controller \u003d controller;\n        this.action \u003d action;\n        this.flash \u003d flash;\n        hasMultipartContent \u003d ServletFileUpload.isMultipartContent(request);\n        if (hasMultipartContent) {\n            // Create a new file upload handler\n            ServletFileUpload upload \u003d new ServletFileUpload();\n            // Parse the request\n            FileItemIterator iter \u003d upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item \u003d iter.next();\n                String name \u003d item.getFieldName();\n                InputStream stream \u003d item.openStream();\n                if (item.isFormField()) {\n                    // add parameter as request attribute\n                    String val \u003d Streams.asString(stream);\n                    request.setAttribute(name, val);\n                    // System.out.println(\"Form field \" + name + \" with value \" + val + \" detected.\");\n                } else {\n                    // add input stream and filename as attributes\n                    String fileName \u003d item.getName();\n                    request.setAttribute(\"fileName\", fileName);\n                    byte[] data \u003d readStream(stream);\n                    request.setAttribute(name, data);\n                    // System.out.println(\"File field \" + name + \" with file name \" + fileName + \" detected.\");\n                }\n            }\n        }\n    }\n\n    // request info\n    /**\n     * Convenience method\n     * @return true if the request is secure\n     */\n    public boolean isSecure() {\n        return request.isSecure();\n    }\n\n    /**\n     * Convenience method\n     * @return the request scheme, ie. http, https\n     */\n    public String getScheme() {\n        return request.getScheme();\n    }\n\n    /**\n     * Convenience method\n     * @return the request method, ie. GET, POST\n     */\n    public String getMethod() {\n        return request.getMethod();\n    }\n\n    /**\n     * Convenience method\n     * @return the server name for this request\n     */\n    public String getServerName() {\n        return request.getServerName();\n    }\n\n    /**\n     * Convenience method\n     * @return the server port for this request\n     */\n    public int getServerPort() {\n        return request.getServerPort();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getServletPath\n     * @see #getQueryString\n     * @return the context path part of the url path\n     */\n    public String getContextPath() {\n        return request.getContextPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getContextPath\n     * @see #getQueryString\n     * @return the servlet path part of the url path\n     */\n    public String getServletPath() {\n        return request.getServletPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getContextPath\n     * @see #getServletPath\n     * @return the query string part of the url path\n     */\n    public String getQueryString() {\n        return request.getQueryString();\n    }\n\n    // params\n    /**\n     * Convenience method\n     * @param name    which parameter to get\n     * @return the parameter value or null if there is no parameter corresponding to the indicated key\n     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,\n     * which can be retrieved as a byte array via the getAttribute method.\n     * @see #getParamMap\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public String getParam(String name) {\n        if (hasMultipartContent) {\n            Object o \u003d request.getAttribute(name);\n            return (o !\u003d null \u0026\u0026 o instanceof String) ? (String) o : BINARY_VALUE;\n        } else {\n            return request.getParameter(name);\n        }\n    }\n\n    /**\n     * Convenience method which gathers all parameters of the\n     * form \u0027\u003cname\u003e[\u003ckey\u003e]\u0027 and return then in a map where the\n     * keys are the \u003ckey\u003e strings and the values are the\n     * corresponding parameter values.\n     * \u003cpre\u003e\n     * For example, if there are parameters:\n     *   \u0027foo[bar1]\u0027 \u003d \u0027baz1\u0027\n     *   \u0027foo[bar2]\u0027 \u003d \u0027baz2\u0027\n     * then getParamMap(\u0027foo\u0027) will returned the map:\n     *   map[\u0027bar1\u0027] \u003d \u0027baz1\u0027\n     *   map[\u0027bar2\u0027] \u003d \u0027baz2\u0027\n     * \u003c/pre\u003e\n     * @param name  the prefix to be used to select parameters\n     * @return a map of all paramters of the form \u0027name[\u003ckey\u003e]\u0027\n     * where the \u003ckey\u003e strings are the keys of the map and the\n     * values are the corresponding parameter values.\n     * @see #getParam\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public Map\u003cString, String\u003e getParamMap(String name) {\n        Map\u003cString, String\u003e m \u003d new HashMap\u003cString, String\u003e();\n        String prefix \u003d name + \"[\";\n        int n \u003d prefix.length();\n        if (hasMultipartContent) {\n            // for multipart requests the parameters have been stored as attributes (see constructor)\n            Enumeration\u003cString\u003e e \u003d request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                String key \u003d e.nextElement();\n                if (key.startsWith(prefix) \u0026\u0026 key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        } else {\n            Map\u003cString, String[]\u003e pm \u003d request.getParameterMap();\n            for (String key : pm.keySet()) {\n                if (key.startsWith(prefix) \u0026\u0026 key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        }\n        return m;\n    }\n\n    /**\n     * Convenience method. Use this if you expect a parameter name\n     * to map to multiple values.\n     * @param name    the name of the parameter(s) to get\n     * @return an array of paramter values corresponding to the indicated name\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamNames\n     */\n    public String[] getParamValues(String name) {\n        return request.getParameterValues(name);\n    }\n\n    /**\n     * Convenience method to get all the parameter names.\n     * @return an array of all parameter names\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamValues\n     */\n    public String[] getParamNames() {\n        if (hasMultipartContent) {\n            List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n            Enumeration\u003cString\u003e e \u003d request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                list.add(e.nextElement());\n            }\n            return list.toArray(new String[list.size()]);\n        } else {\n            Map\u003cString, String[]\u003e m \u003d request.getParameterMap();\n            String[] a \u003d new String[m.size()];\n            int i \u003d 0;\n            for (String key : m.keySet()) {\n                a[i++] \u003d key;\n            }\n            return a;\n        }\n    }\n\n    // attributes\n    /**\n     * Convenience method\n     * @param name    which attribute to get\n     * @return the attribute value or null if there is no attribute corresponding to the indicated key.\n     * If the attribute corresponds to a file upload field then the return value will be a byte array\n     */\n    public Object getAttribute(String name) {\n        return request.getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @param name    name of attribute to be set\n     * @param value   value of attribute to be set\n     */\n    public void setAttribute(String name, Object value) {\n        request.setAttribute(name, value);\n    }\n\n    // session attributes\n    /**\n     * Convenience method\n     * @param name    the name of the attribute to retrieve\n     * @return the attribute associated with the indicated name or null\n     * @see #setSessionAttr\n     * @see #getSessionAttrNames\n     */\n    public Object getSessionAttr(String name) {\n        if (request.getSession() \u003d\u003d null)\n            return null;\n        return request.getSession().getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @return all the session attribute names.\n     * @see #getSessionAttr\n     * @see #setSessionAttr\n     * @see #removeSessionAttr\n     */\n    public String[] getSessionAttrNames() {\n        if (request.getSession(false) \u003d\u003d null)\n            return new String[0];\n        ArrayList\u003cString\u003e a \u003d new ArrayList\u003cString\u003e();\n        Enumeration\u003cString\u003e e \u003d request.getSession().getAttributeNames();\n        while (e.hasMoreElements()) {\n            a.add(e.nextElement());\n        }\n        return a.toArray(new String[a.size()]);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key to store the indicated value\n     * @param value  the object to be stored\n     * @see #getSessionAttr\n     * @see #removeSessionAttr\n     */\n    public void setSessionAttr(String name, Object value) {\n        if (request.getSession() \u003d\u003d null)\n            return;\n        request.getSession().setAttribute(name, value);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key of\n     * @see #setSessionAttr\n     */\n    public void removeSessionAttr(String name) {\n        if (request.getSession() \u003d\u003d null)\n            return;\n        request.getSession().removeAttribute(name);\n    }\n\n    // cookies\n    /**\n     * Convenience method to get cookie by name\n     * @param name  the name of the cookie to get\n     * @return the cookie with the indicated name, or null\n     * @see #setCookie\n     * @see #getCookieNames\n     */\n    public Cookie getCookie(String name) {\n        if (name \u003d\u003d null)\n            return null;\n        Cookie[] cookies \u003d request.getCookies();\n        if (cookies \u003d\u003d null)\n            return null;\n        for (Cookie c : cookies) {\n            if (name.equals(c.getName()))\n                return c;\n        }\n        return null;\n    }\n\n    /**\n     * Convenience method to get all the cookie names.\n     * @return an array of the names of all the cookies in the request, possibly empty\n     * @see #getCookie\n     * @see #setCookie\n     */\n    public String[] getCookieNames() {\n        Cookie[] cookies \u003d request.getCookies();\n        if (cookies \u003d\u003d null)\n            return new String[0];\n        String[] a \u003d new String[cookies.length];\n        int i \u003d 0;\n        for (Cookie c : cookies) {\n            a[i++] \u003d c.getName();\n        }\n        return a;\n    }\n\n    /**\n     * Convenience method\n     * @param cookie   the cookie to be added to the response\n     * @see #getCookie\n     * @see #getCookieNames\n     */\n    public void setCookie(Cookie cookie) {\n        response.addCookie(cookie);\n    }\n\n    /**\n     * Cause a non-standard response (ie. redirect) to be returned.\n     * @param httpCode   the http response code to be returned\n     * @param arg    an argument or message to be returned (depends on response code)\n     * @see #redirect\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void nonStandardResponse(int httpCode, String arg) {\n        throw new NonStandardResponseException(httpCode, arg);\n    }\n\n    /**\n     * Cause a redirect response to be returned\n     * @param path  where to redirect to. If the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #nonStandardResponse\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void redirect(String path) {\n        if (path.startsWith(\"/\"))\n            path \u003d absPath(path);\n        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);\n    }\n\n    /**\n     * Cause a binary response to be returned\n     * @param in input stream containing binary data to be sent\n     * @throws BinaryResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the BinaryResponseException.\n     */\n    public void sendBinaryResponse(InputStream in) {\n        throw new BinaryResponseException(in);\n    }\n\n    /**\n     * Convenience method to prepend the context path onto a servlet path\n     * @param path    a servlet path\n     * @return the context path plus the indicated path\n     */\n    public String absPath(String path) {\n        return getContextPath() + (path.startsWith(\"/\") ? path : \"/\" + path);\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path) {\n        return makeLink(anchor, path, \"\");\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @param options    extra html options to add to the anchor tag\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path, String options) {\n        if (path.startsWith(\"/\"))\n            path \u003d absPath(path);\n        return \"\u003ca href\u003d\u0027\" + path + \"\u0027 \" + options + \"\u003e\" + anchor + \"\u003c/a\u003e\";\n    }\n\n    /**\n     * Convenience method to check if this request is a POST\n     */\n    public boolean isPost() {\n        return \"POST\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to check if this request is a GET\n     */\n    public boolean isGet() {\n        return \"GET\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to retrieve a value from the flash\n     * @param key  the key to use to lookup a flash value\n     * @return the flash value associated with the indicated key or null\n     * @see #setFlash\n     */\n    public String getFlash(String key) {\n        return flash.get(key);\n    }\n\n    /**\n     * Convenience method to add a value to the flash\n     * @param key  the key to use to associate with the flash value\n     * @param val  the value to store\n     * @see #getFlash\n     */\n    public void setFlash(String key, String val) {\n        flash.put(key, val);\n    }\n\n    // caching (internal use)\n    /**\n     * Internal method used to retrieve a cached block\n     * @see #setCachedBlock\n     */\n    public static String getCachedBlock(String key) {\n        return (cacheMap \u003d\u003d null) ? null : cacheMap.get(key);\n    }\n\n    /**\n     * Internal method used to store a cached block\n     * @see #getCachedBlock\n     */\n    public static void setCachedBlock(String key, String val) {\n        if (cacheMap \u003d\u003d null) {\n            cacheMap \u003d new HashMap\u003cString, String\u003e();\n        }\n        cacheMap.put(key, val);\n    }\n\n    /**\n     * For debugging\n     * @return a string representation of this request context\n     */\n    public String toString() {\n        return toString(\", \");\n    }\n\n    public String toString(String sep) {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"params: [\");\n        String[] keys \u003d getParamNames();\n        for (String key : keys) {\n            sb.append(key).append(\u0027\u003d\u0027).append(getParam(key)).append(sep);\n        }\n        if (keys.length \u003e 0) {\n            sb.setLength(sb.length() - sep.length());\n        }\n        sb.append(\"]\");\n        sb.append(sep).append(\"method: \").append(getMethod());\n        sb.append(sep).append(\"url: \").append(getScheme());\n        sb.append(\"|\").append(getServerName());\n        sb.append(\"|\").append(getServerPort());\n        sb.append(\"|\").append(getContextPath());\n        sb.append(\"|\").append(getServletPath());\n        sb.append(\"|\").append(getQueryString());\n        if (hasMultipartContent) {\n            sb.append(sep).append(\"content len: \").append(request.getContentLength());\n            //sb.append(sep).append(\"content type: \").append(request.getContentType());\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Copy an input stream to an output stream.\n     */\n    private byte[] readStream(InputStream in) throws IOException {\n        ByteArrayOutputStream out \u003d new ByteArrayOutputStream();\n        byte[] buf \u003d new byte[4096];\n        int read;\n        while ((read \u003d in.read(buf)) \u003e -1) {\n            out.write(buf, 0, read);\n        }\n        out.flush();\n        return out.toByteArray();\n    }\n}\n",
    "package": "com.pmdesigns.jvc",
    "classname": "JVCRequestContext",
    "id": "/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContext_5Test.java",
    "test_prompt": "// JVCRequestContext_5Test.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JVCRequestContext}.\n* It contains ten unit test cases for the {@link JVCRequestContext#getCookie(String)} method.\n*/\nclass JVCRequestContext_5Test {",
    "method_signature": "getCookie(String)",
    "suffix": "5"
  },
  {
    "numberTests": "ten",
    "original_code": "// JVCRequestContext.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\n/**\n * This class contains state information for processing an http request.\n * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet\n * objects and provides convenience methods for accessing them.\n * \u003cp\u003e\n * It also provides access to the \u0027flash\u0027 which is a Map for storing temporary\n * key/value strings.  The scope of the flash is the current request or\n * the following request in the case of a redirect response.\n * \u003cp\u003e\n * It also contains some convenience methods for forming links and absolute paths.\n *\n * @author mike dooley\n */\npublic final class JVCRequestContext {\n\n    /**\n     * The actual HttpServletRequest object\n     */\n    public final HttpServletRequest request;\n\n    /**\n     * The actual HttpServletResponse object\n     */\n    public final HttpServletResponse response;\n\n    /**\n     * The HttpServlet object (actually this is a JVCDispatcher)\n     */\n    public final HttpServlet servlet;\n\n    /**\n     * The controller is the servlet path up to the action.\n     */\n    public final String controller;\n\n    /**\n     * The action is the last part of the servlet path (before any query arguments)\n     */\n    public final String action;\n\n    /**\n     * Tells if this request has multipart content (ie file upload)\n     */\n    public final boolean hasMultipartContent;\n\n    /**\n     * Parameter value indicating that the real parameter value is binary (and should be\n     * accessed via the getAttribute() method.\n     */\n    public static final String BINARY_VALUE \u003d \"BINARY_VALUE\";\n\n    /**\n     * The \u0027flash\u0027 map for holding temporary key/value strings.\n     */\n    public final Map\u003cString, String\u003e flash;\n\n    /**\n     * Holds cached page generator fragments\n     */\n    private static Map\u003cString, String\u003e cacheMap;\n\n    /**\n     * Constructor for JVCRequestContext which is used to hold http request and response iformation\n     * @param request\n     * @param response\n     * @param servlet\n     * @param flash\n     * @param controller\n     * @param action\n     */\n    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map\u003cString, String\u003e flash, String controller, String action) throws Exception {\n        this.request \u003d request;\n        this.response \u003d response;\n        this.servlet \u003d servlet;\n        this.controller \u003d controller;\n        this.action \u003d action;\n        this.flash \u003d flash;\n        hasMultipartContent \u003d ServletFileUpload.isMultipartContent(request);\n        if (hasMultipartContent) {\n            // Create a new file upload handler\n            ServletFileUpload upload \u003d new ServletFileUpload();\n            // Parse the request\n            FileItemIterator iter \u003d upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item \u003d iter.next();\n                String name \u003d item.getFieldName();\n                InputStream stream \u003d item.openStream();\n                if (item.isFormField()) {\n                    // add parameter as request attribute\n                    String val \u003d Streams.asString(stream);\n                    request.setAttribute(name, val);\n                    // System.out.println(\"Form field \" + name + \" with value \" + val + \" detected.\");\n                } else {\n                    // add input stream and filename as attributes\n                    String fileName \u003d item.getName();\n                    request.setAttribute(\"fileName\", fileName);\n                    byte[] data \u003d readStream(stream);\n                    request.setAttribute(name, data);\n                    // System.out.println(\"File field \" + name + \" with file name \" + fileName + \" detected.\");\n                }\n            }\n        }\n    }\n\n    // request info\n    /**\n     * Convenience method\n     * @return true if the request is secure\n     */\n    public boolean isSecure() {\n        return request.isSecure();\n    }\n\n    /**\n     * Convenience method\n     * @return the request scheme, ie. http, https\n     */\n    public String getScheme() {\n        return request.getScheme();\n    }\n\n    /**\n     * Convenience method\n     * @return the request method, ie. GET, POST\n     */\n    public String getMethod() {\n        return request.getMethod();\n    }\n\n    /**\n     * Convenience method\n     * @return the server name for this request\n     */\n    public String getServerName() {\n        return request.getServerName();\n    }\n\n    /**\n     * Convenience method\n     * @return the server port for this request\n     */\n    public int getServerPort() {\n        return request.getServerPort();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getServletPath\n     * @see #getQueryString\n     * @return the context path part of the url path\n     */\n    public String getContextPath() {\n        return request.getContextPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getContextPath\n     * @see #getQueryString\n     * @return the servlet path part of the url path\n     */\n    public String getServletPath() {\n        return request.getServletPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getContextPath\n     * @see #getServletPath\n     * @return the query string part of the url path\n     */\n    public String getQueryString() {\n        return request.getQueryString();\n    }\n\n    // params\n    /**\n     * Convenience method\n     * @param name    which parameter to get\n     * @return the parameter value or null if there is no parameter corresponding to the indicated key\n     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,\n     * which can be retrieved as a byte array via the getAttribute method.\n     * @see #getParamMap\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public String getParam(String name) {\n        if (hasMultipartContent) {\n            Object o \u003d request.getAttribute(name);\n            return (o !\u003d null \u0026\u0026 o instanceof String) ? (String) o : BINARY_VALUE;\n        } else {\n            return request.getParameter(name);\n        }\n    }\n\n    /**\n     * Convenience method which gathers all parameters of the\n     * form \u0027\u003cname\u003e[\u003ckey\u003e]\u0027 and return then in a map where the\n     * keys are the \u003ckey\u003e strings and the values are the\n     * corresponding parameter values.\n     * \u003cpre\u003e\n     * For example, if there are parameters:\n     *   \u0027foo[bar1]\u0027 \u003d \u0027baz1\u0027\n     *   \u0027foo[bar2]\u0027 \u003d \u0027baz2\u0027\n     * then getParamMap(\u0027foo\u0027) will returned the map:\n     *   map[\u0027bar1\u0027] \u003d \u0027baz1\u0027\n     *   map[\u0027bar2\u0027] \u003d \u0027baz2\u0027\n     * \u003c/pre\u003e\n     * @param name  the prefix to be used to select parameters\n     * @return a map of all paramters of the form \u0027name[\u003ckey\u003e]\u0027\n     * where the \u003ckey\u003e strings are the keys of the map and the\n     * values are the corresponding parameter values.\n     * @see #getParam\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public Map\u003cString, String\u003e getParamMap(String name) {\n        Map\u003cString, String\u003e m \u003d new HashMap\u003cString, String\u003e();\n        String prefix \u003d name + \"[\";\n        int n \u003d prefix.length();\n        if (hasMultipartContent) {\n            // for multipart requests the parameters have been stored as attributes (see constructor)\n            Enumeration\u003cString\u003e e \u003d request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                String key \u003d e.nextElement();\n                if (key.startsWith(prefix) \u0026\u0026 key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        } else {\n            Map\u003cString, String[]\u003e pm \u003d request.getParameterMap();\n            for (String key : pm.keySet()) {\n                if (key.startsWith(prefix) \u0026\u0026 key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        }\n        return m;\n    }\n\n    /**\n     * Convenience method. Use this if you expect a parameter name\n     * to map to multiple values.\n     * @param name    the name of the parameter(s) to get\n     * @return an array of paramter values corresponding to the indicated name\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamNames\n     */\n    public String[] getParamValues(String name) {\n        return request.getParameterValues(name);\n    }\n\n    /**\n     * Convenience method to get all the parameter names.\n     * @return an array of all parameter names\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamValues\n     */\n    public String[] getParamNames() {\n        if (hasMultipartContent) {\n            List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n            Enumeration\u003cString\u003e e \u003d request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                list.add(e.nextElement());\n            }\n            return list.toArray(new String[list.size()]);\n        } else {\n            Map\u003cString, String[]\u003e m \u003d request.getParameterMap();\n            String[] a \u003d new String[m.size()];\n            int i \u003d 0;\n            for (String key : m.keySet()) {\n                a[i++] \u003d key;\n            }\n            return a;\n        }\n    }\n\n    // attributes\n    /**\n     * Convenience method\n     * @param name    which attribute to get\n     * @return the attribute value or null if there is no attribute corresponding to the indicated key.\n     * If the attribute corresponds to a file upload field then the return value will be a byte array\n     */\n    public Object getAttribute(String name) {\n        return request.getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @param name    name of attribute to be set\n     * @param value   value of attribute to be set\n     */\n    public void setAttribute(String name, Object value) {\n        request.setAttribute(name, value);\n    }\n\n    // session attributes\n    /**\n     * Convenience method\n     * @param name    the name of the attribute to retrieve\n     * @return the attribute associated with the indicated name or null\n     * @see #setSessionAttr\n     * @see #getSessionAttrNames\n     */\n    public Object getSessionAttr(String name) {\n        if (request.getSession() \u003d\u003d null)\n            return null;\n        return request.getSession().getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @return all the session attribute names.\n     * @see #getSessionAttr\n     * @see #setSessionAttr\n     * @see #removeSessionAttr\n     */\n    public String[] getSessionAttrNames() {\n        if (request.getSession(false) \u003d\u003d null)\n            return new String[0];\n        ArrayList\u003cString\u003e a \u003d new ArrayList\u003cString\u003e();\n        Enumeration\u003cString\u003e e \u003d request.getSession().getAttributeNames();\n        while (e.hasMoreElements()) {\n            a.add(e.nextElement());\n        }\n        return a.toArray(new String[a.size()]);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key to store the indicated value\n     * @param value  the object to be stored\n     * @see #getSessionAttr\n     * @see #removeSessionAttr\n     */\n    public void setSessionAttr(String name, Object value) {\n        if (request.getSession() \u003d\u003d null)\n            return;\n        request.getSession().setAttribute(name, value);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key of\n     * @see #setSessionAttr\n     */\n    public void removeSessionAttr(String name) {\n        if (request.getSession() \u003d\u003d null)\n            return;\n        request.getSession().removeAttribute(name);\n    }\n\n    // cookies\n    /**\n     * Convenience method to get cookie by name\n     * @param name  the name of the cookie to get\n     * @return the cookie with the indicated name, or null\n     * @see #setCookie\n     * @see #getCookieNames\n     */\n    public Cookie getCookie(String name) {\n        if (name \u003d\u003d null)\n            return null;\n        Cookie[] cookies \u003d request.getCookies();\n        if (cookies \u003d\u003d null)\n            return null;\n        for (Cookie c : cookies) {\n            if (name.equals(c.getName()))\n                return c;\n        }\n        return null;\n    }\n\n    /**\n     * Convenience method to get all the cookie names.\n     * @return an array of the names of all the cookies in the request, possibly empty\n     * @see #getCookie\n     * @see #setCookie\n     */\n    public String[] getCookieNames() {\n        Cookie[] cookies \u003d request.getCookies();\n        if (cookies \u003d\u003d null)\n            return new String[0];\n        String[] a \u003d new String[cookies.length];\n        int i \u003d 0;\n        for (Cookie c : cookies) {\n            a[i++] \u003d c.getName();\n        }\n        return a;\n    }\n\n    /**\n     * Convenience method\n     * @param cookie   the cookie to be added to the response\n     * @see #getCookie\n     * @see #getCookieNames\n     */\n    public void setCookie(Cookie cookie) {\n        response.addCookie(cookie);\n    }\n\n    /**\n     * Cause a non-standard response (ie. redirect) to be returned.\n     * @param httpCode   the http response code to be returned\n     * @param arg    an argument or message to be returned (depends on response code)\n     * @see #redirect\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void nonStandardResponse(int httpCode, String arg) {\n        throw new NonStandardResponseException(httpCode, arg);\n    }\n\n    /**\n     * Cause a redirect response to be returned\n     * @param path  where to redirect to. If the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #nonStandardResponse\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void redirect(String path) {\n        if (path.startsWith(\"/\"))\n            path \u003d absPath(path);\n        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);\n    }\n\n    /**\n     * Cause a binary response to be returned\n     * @param in input stream containing binary data to be sent\n     * @throws BinaryResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the BinaryResponseException.\n     */\n    public void sendBinaryResponse(InputStream in) {\n        throw new BinaryResponseException(in);\n    }\n\n    /**\n     * Convenience method to prepend the context path onto a servlet path\n     * @param path    a servlet path\n     * @return the context path plus the indicated path\n     */\n    public String absPath(String path) {\n        return getContextPath() + (path.startsWith(\"/\") ? path : \"/\" + path);\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path) {\n        return makeLink(anchor, path, \"\");\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @param options    extra html options to add to the anchor tag\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path, String options) {\n        if (path.startsWith(\"/\"))\n            path \u003d absPath(path);\n        return \"\u003ca href\u003d\u0027\" + path + \"\u0027 \" + options + \"\u003e\" + anchor + \"\u003c/a\u003e\";\n    }\n\n    /**\n     * Convenience method to check if this request is a POST\n     */\n    public boolean isPost() {\n        return \"POST\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to check if this request is a GET\n     */\n    public boolean isGet() {\n        return \"GET\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to retrieve a value from the flash\n     * @param key  the key to use to lookup a flash value\n     * @return the flash value associated with the indicated key or null\n     * @see #setFlash\n     */\n    public String getFlash(String key) {\n        return flash.get(key);\n    }\n\n    /**\n     * Convenience method to add a value to the flash\n     * @param key  the key to use to associate with the flash value\n     * @param val  the value to store\n     * @see #getFlash\n     */\n    public void setFlash(String key, String val) {\n        flash.put(key, val);\n    }\n\n    // caching (internal use)\n    /**\n     * Internal method used to retrieve a cached block\n     * @see #setCachedBlock\n     */\n    public static String getCachedBlock(String key) {\n        return (cacheMap \u003d\u003d null) ? null : cacheMap.get(key);\n    }\n\n    /**\n     * Internal method used to store a cached block\n     * @see #getCachedBlock\n     */\n    public static void setCachedBlock(String key, String val) {\n        if (cacheMap \u003d\u003d null) {\n            cacheMap \u003d new HashMap\u003cString, String\u003e();\n        }\n        cacheMap.put(key, val);\n    }\n\n    /**\n     * For debugging\n     * @return a string representation of this request context\n     */\n    public String toString() {\n        return toString(\", \");\n    }\n\n    public String toString(String sep) {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"params: [\");\n        String[] keys \u003d getParamNames();\n        for (String key : keys) {\n            sb.append(key).append(\u0027\u003d\u0027).append(getParam(key)).append(sep);\n        }\n        if (keys.length \u003e 0) {\n            sb.setLength(sb.length() - sep.length());\n        }\n        sb.append(\"]\");\n        sb.append(sep).append(\"method: \").append(getMethod());\n        sb.append(sep).append(\"url: \").append(getScheme());\n        sb.append(\"|\").append(getServerName());\n        sb.append(\"|\").append(getServerPort());\n        sb.append(\"|\").append(getContextPath());\n        sb.append(\"|\").append(getServletPath());\n        sb.append(\"|\").append(getQueryString());\n        if (hasMultipartContent) {\n            sb.append(sep).append(\"content len: \").append(request.getContentLength());\n            //sb.append(sep).append(\"content type: \").append(request.getContentType());\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Copy an input stream to an output stream.\n     */\n    private byte[] readStream(InputStream in) throws IOException {\n        ByteArrayOutputStream out \u003d new ByteArrayOutputStream();\n        byte[] buf \u003d new byte[4096];\n        int read;\n        while ((read \u003d in.read(buf)) \u003e -1) {\n            out.write(buf, 0, read);\n        }\n        out.flush();\n        return out.toByteArray();\n    }\n}\n",
    "package": "com.pmdesigns.jvc",
    "classname": "JVCRequestContext",
    "id": "/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContext_6Test.java",
    "test_prompt": "// JVCRequestContext_6Test.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JVCRequestContext}.\n* It contains ten unit test cases for the {@link JVCRequestContext#absPath(String)} method.\n*/\nclass JVCRequestContext_6Test {",
    "method_signature": "absPath(String)",
    "suffix": "6"
  },
  {
    "numberTests": "ten",
    "original_code": "// JVCRequestContext.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\n/**\n * This class contains state information for processing an http request.\n * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet\n * objects and provides convenience methods for accessing them.\n * \u003cp\u003e\n * It also provides access to the \u0027flash\u0027 which is a Map for storing temporary\n * key/value strings.  The scope of the flash is the current request or\n * the following request in the case of a redirect response.\n * \u003cp\u003e\n * It also contains some convenience methods for forming links and absolute paths.\n *\n * @author mike dooley\n */\npublic final class JVCRequestContext {\n\n    /**\n     * The actual HttpServletRequest object\n     */\n    public final HttpServletRequest request;\n\n    /**\n     * The actual HttpServletResponse object\n     */\n    public final HttpServletResponse response;\n\n    /**\n     * The HttpServlet object (actually this is a JVCDispatcher)\n     */\n    public final HttpServlet servlet;\n\n    /**\n     * The controller is the servlet path up to the action.\n     */\n    public final String controller;\n\n    /**\n     * The action is the last part of the servlet path (before any query arguments)\n     */\n    public final String action;\n\n    /**\n     * Tells if this request has multipart content (ie file upload)\n     */\n    public final boolean hasMultipartContent;\n\n    /**\n     * Parameter value indicating that the real parameter value is binary (and should be\n     * accessed via the getAttribute() method.\n     */\n    public static final String BINARY_VALUE \u003d \"BINARY_VALUE\";\n\n    /**\n     * The \u0027flash\u0027 map for holding temporary key/value strings.\n     */\n    public final Map\u003cString, String\u003e flash;\n\n    /**\n     * Holds cached page generator fragments\n     */\n    private static Map\u003cString, String\u003e cacheMap;\n\n    /**\n     * Constructor for JVCRequestContext which is used to hold http request and response iformation\n     * @param request\n     * @param response\n     * @param servlet\n     * @param flash\n     * @param controller\n     * @param action\n     */\n    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map\u003cString, String\u003e flash, String controller, String action) throws Exception {\n        this.request \u003d request;\n        this.response \u003d response;\n        this.servlet \u003d servlet;\n        this.controller \u003d controller;\n        this.action \u003d action;\n        this.flash \u003d flash;\n        hasMultipartContent \u003d ServletFileUpload.isMultipartContent(request);\n        if (hasMultipartContent) {\n            // Create a new file upload handler\n            ServletFileUpload upload \u003d new ServletFileUpload();\n            // Parse the request\n            FileItemIterator iter \u003d upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item \u003d iter.next();\n                String name \u003d item.getFieldName();\n                InputStream stream \u003d item.openStream();\n                if (item.isFormField()) {\n                    // add parameter as request attribute\n                    String val \u003d Streams.asString(stream);\n                    request.setAttribute(name, val);\n                    // System.out.println(\"Form field \" + name + \" with value \" + val + \" detected.\");\n                } else {\n                    // add input stream and filename as attributes\n                    String fileName \u003d item.getName();\n                    request.setAttribute(\"fileName\", fileName);\n                    byte[] data \u003d readStream(stream);\n                    request.setAttribute(name, data);\n                    // System.out.println(\"File field \" + name + \" with file name \" + fileName + \" detected.\");\n                }\n            }\n        }\n    }\n\n    // request info\n    /**\n     * Convenience method\n     * @return true if the request is secure\n     */\n    public boolean isSecure() {\n        return request.isSecure();\n    }\n\n    /**\n     * Convenience method\n     * @return the request scheme, ie. http, https\n     */\n    public String getScheme() {\n        return request.getScheme();\n    }\n\n    /**\n     * Convenience method\n     * @return the request method, ie. GET, POST\n     */\n    public String getMethod() {\n        return request.getMethod();\n    }\n\n    /**\n     * Convenience method\n     * @return the server name for this request\n     */\n    public String getServerName() {\n        return request.getServerName();\n    }\n\n    /**\n     * Convenience method\n     * @return the server port for this request\n     */\n    public int getServerPort() {\n        return request.getServerPort();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getServletPath\n     * @see #getQueryString\n     * @return the context path part of the url path\n     */\n    public String getContextPath() {\n        return request.getContextPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getContextPath\n     * @see #getQueryString\n     * @return the servlet path part of the url path\n     */\n    public String getServletPath() {\n        return request.getServletPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getContextPath\n     * @see #getServletPath\n     * @return the query string part of the url path\n     */\n    public String getQueryString() {\n        return request.getQueryString();\n    }\n\n    // params\n    /**\n     * Convenience method\n     * @param name    which parameter to get\n     * @return the parameter value or null if there is no parameter corresponding to the indicated key\n     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,\n     * which can be retrieved as a byte array via the getAttribute method.\n     * @see #getParamMap\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public String getParam(String name) {\n        if (hasMultipartContent) {\n            Object o \u003d request.getAttribute(name);\n            return (o !\u003d null \u0026\u0026 o instanceof String) ? (String) o : BINARY_VALUE;\n        } else {\n            return request.getParameter(name);\n        }\n    }\n\n    /**\n     * Convenience method which gathers all parameters of the\n     * form \u0027\u003cname\u003e[\u003ckey\u003e]\u0027 and return then in a map where the\n     * keys are the \u003ckey\u003e strings and the values are the\n     * corresponding parameter values.\n     * \u003cpre\u003e\n     * For example, if there are parameters:\n     *   \u0027foo[bar1]\u0027 \u003d \u0027baz1\u0027\n     *   \u0027foo[bar2]\u0027 \u003d \u0027baz2\u0027\n     * then getParamMap(\u0027foo\u0027) will returned the map:\n     *   map[\u0027bar1\u0027] \u003d \u0027baz1\u0027\n     *   map[\u0027bar2\u0027] \u003d \u0027baz2\u0027\n     * \u003c/pre\u003e\n     * @param name  the prefix to be used to select parameters\n     * @return a map of all paramters of the form \u0027name[\u003ckey\u003e]\u0027\n     * where the \u003ckey\u003e strings are the keys of the map and the\n     * values are the corresponding parameter values.\n     * @see #getParam\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public Map\u003cString, String\u003e getParamMap(String name) {\n        Map\u003cString, String\u003e m \u003d new HashMap\u003cString, String\u003e();\n        String prefix \u003d name + \"[\";\n        int n \u003d prefix.length();\n        if (hasMultipartContent) {\n            // for multipart requests the parameters have been stored as attributes (see constructor)\n            Enumeration\u003cString\u003e e \u003d request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                String key \u003d e.nextElement();\n                if (key.startsWith(prefix) \u0026\u0026 key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        } else {\n            Map\u003cString, String[]\u003e pm \u003d request.getParameterMap();\n            for (String key : pm.keySet()) {\n                if (key.startsWith(prefix) \u0026\u0026 key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        }\n        return m;\n    }\n\n    /**\n     * Convenience method. Use this if you expect a parameter name\n     * to map to multiple values.\n     * @param name    the name of the parameter(s) to get\n     * @return an array of paramter values corresponding to the indicated name\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamNames\n     */\n    public String[] getParamValues(String name) {\n        return request.getParameterValues(name);\n    }\n\n    /**\n     * Convenience method to get all the parameter names.\n     * @return an array of all parameter names\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamValues\n     */\n    public String[] getParamNames() {\n        if (hasMultipartContent) {\n            List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n            Enumeration\u003cString\u003e e \u003d request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                list.add(e.nextElement());\n            }\n            return list.toArray(new String[list.size()]);\n        } else {\n            Map\u003cString, String[]\u003e m \u003d request.getParameterMap();\n            String[] a \u003d new String[m.size()];\n            int i \u003d 0;\n            for (String key : m.keySet()) {\n                a[i++] \u003d key;\n            }\n            return a;\n        }\n    }\n\n    // attributes\n    /**\n     * Convenience method\n     * @param name    which attribute to get\n     * @return the attribute value or null if there is no attribute corresponding to the indicated key.\n     * If the attribute corresponds to a file upload field then the return value will be a byte array\n     */\n    public Object getAttribute(String name) {\n        return request.getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @param name    name of attribute to be set\n     * @param value   value of attribute to be set\n     */\n    public void setAttribute(String name, Object value) {\n        request.setAttribute(name, value);\n    }\n\n    // session attributes\n    /**\n     * Convenience method\n     * @param name    the name of the attribute to retrieve\n     * @return the attribute associated with the indicated name or null\n     * @see #setSessionAttr\n     * @see #getSessionAttrNames\n     */\n    public Object getSessionAttr(String name) {\n        if (request.getSession() \u003d\u003d null)\n            return null;\n        return request.getSession().getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @return all the session attribute names.\n     * @see #getSessionAttr\n     * @see #setSessionAttr\n     * @see #removeSessionAttr\n     */\n    public String[] getSessionAttrNames() {\n        if (request.getSession(false) \u003d\u003d null)\n            return new String[0];\n        ArrayList\u003cString\u003e a \u003d new ArrayList\u003cString\u003e();\n        Enumeration\u003cString\u003e e \u003d request.getSession().getAttributeNames();\n        while (e.hasMoreElements()) {\n            a.add(e.nextElement());\n        }\n        return a.toArray(new String[a.size()]);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key to store the indicated value\n     * @param value  the object to be stored\n     * @see #getSessionAttr\n     * @see #removeSessionAttr\n     */\n    public void setSessionAttr(String name, Object value) {\n        if (request.getSession() \u003d\u003d null)\n            return;\n        request.getSession().setAttribute(name, value);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key of\n     * @see #setSessionAttr\n     */\n    public void removeSessionAttr(String name) {\n        if (request.getSession() \u003d\u003d null)\n            return;\n        request.getSession().removeAttribute(name);\n    }\n\n    // cookies\n    /**\n     * Convenience method to get cookie by name\n     * @param name  the name of the cookie to get\n     * @return the cookie with the indicated name, or null\n     * @see #setCookie\n     * @see #getCookieNames\n     */\n    public Cookie getCookie(String name) {\n        if (name \u003d\u003d null)\n            return null;\n        Cookie[] cookies \u003d request.getCookies();\n        if (cookies \u003d\u003d null)\n            return null;\n        for (Cookie c : cookies) {\n            if (name.equals(c.getName()))\n                return c;\n        }\n        return null;\n    }\n\n    /**\n     * Convenience method to get all the cookie names.\n     * @return an array of the names of all the cookies in the request, possibly empty\n     * @see #getCookie\n     * @see #setCookie\n     */\n    public String[] getCookieNames() {\n        Cookie[] cookies \u003d request.getCookies();\n        if (cookies \u003d\u003d null)\n            return new String[0];\n        String[] a \u003d new String[cookies.length];\n        int i \u003d 0;\n        for (Cookie c : cookies) {\n            a[i++] \u003d c.getName();\n        }\n        return a;\n    }\n\n    /**\n     * Convenience method\n     * @param cookie   the cookie to be added to the response\n     * @see #getCookie\n     * @see #getCookieNames\n     */\n    public void setCookie(Cookie cookie) {\n        response.addCookie(cookie);\n    }\n\n    /**\n     * Cause a non-standard response (ie. redirect) to be returned.\n     * @param httpCode   the http response code to be returned\n     * @param arg    an argument or message to be returned (depends on response code)\n     * @see #redirect\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void nonStandardResponse(int httpCode, String arg) {\n        throw new NonStandardResponseException(httpCode, arg);\n    }\n\n    /**\n     * Cause a redirect response to be returned\n     * @param path  where to redirect to. If the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #nonStandardResponse\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void redirect(String path) {\n        if (path.startsWith(\"/\"))\n            path \u003d absPath(path);\n        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);\n    }\n\n    /**\n     * Cause a binary response to be returned\n     * @param in input stream containing binary data to be sent\n     * @throws BinaryResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the BinaryResponseException.\n     */\n    public void sendBinaryResponse(InputStream in) {\n        throw new BinaryResponseException(in);\n    }\n\n    /**\n     * Convenience method to prepend the context path onto a servlet path\n     * @param path    a servlet path\n     * @return the context path plus the indicated path\n     */\n    public String absPath(String path) {\n        return getContextPath() + (path.startsWith(\"/\") ? path : \"/\" + path);\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path) {\n        return makeLink(anchor, path, \"\");\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @param options    extra html options to add to the anchor tag\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path, String options) {\n        if (path.startsWith(\"/\"))\n            path \u003d absPath(path);\n        return \"\u003ca href\u003d\u0027\" + path + \"\u0027 \" + options + \"\u003e\" + anchor + \"\u003c/a\u003e\";\n    }\n\n    /**\n     * Convenience method to check if this request is a POST\n     */\n    public boolean isPost() {\n        return \"POST\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to check if this request is a GET\n     */\n    public boolean isGet() {\n        return \"GET\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to retrieve a value from the flash\n     * @param key  the key to use to lookup a flash value\n     * @return the flash value associated with the indicated key or null\n     * @see #setFlash\n     */\n    public String getFlash(String key) {\n        return flash.get(key);\n    }\n\n    /**\n     * Convenience method to add a value to the flash\n     * @param key  the key to use to associate with the flash value\n     * @param val  the value to store\n     * @see #getFlash\n     */\n    public void setFlash(String key, String val) {\n        flash.put(key, val);\n    }\n\n    // caching (internal use)\n    /**\n     * Internal method used to retrieve a cached block\n     * @see #setCachedBlock\n     */\n    public static String getCachedBlock(String key) {\n        return (cacheMap \u003d\u003d null) ? null : cacheMap.get(key);\n    }\n\n    /**\n     * Internal method used to store a cached block\n     * @see #getCachedBlock\n     */\n    public static void setCachedBlock(String key, String val) {\n        if (cacheMap \u003d\u003d null) {\n            cacheMap \u003d new HashMap\u003cString, String\u003e();\n        }\n        cacheMap.put(key, val);\n    }\n\n    /**\n     * For debugging\n     * @return a string representation of this request context\n     */\n    public String toString() {\n        return toString(\", \");\n    }\n\n    public String toString(String sep) {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"params: [\");\n        String[] keys \u003d getParamNames();\n        for (String key : keys) {\n            sb.append(key).append(\u0027\u003d\u0027).append(getParam(key)).append(sep);\n        }\n        if (keys.length \u003e 0) {\n            sb.setLength(sb.length() - sep.length());\n        }\n        sb.append(\"]\");\n        sb.append(sep).append(\"method: \").append(getMethod());\n        sb.append(sep).append(\"url: \").append(getScheme());\n        sb.append(\"|\").append(getServerName());\n        sb.append(\"|\").append(getServerPort());\n        sb.append(\"|\").append(getContextPath());\n        sb.append(\"|\").append(getServletPath());\n        sb.append(\"|\").append(getQueryString());\n        if (hasMultipartContent) {\n            sb.append(sep).append(\"content len: \").append(request.getContentLength());\n            //sb.append(sep).append(\"content type: \").append(request.getContentType());\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Copy an input stream to an output stream.\n     */\n    private byte[] readStream(InputStream in) throws IOException {\n        ByteArrayOutputStream out \u003d new ByteArrayOutputStream();\n        byte[] buf \u003d new byte[4096];\n        int read;\n        while ((read \u003d in.read(buf)) \u003e -1) {\n            out.write(buf, 0, read);\n        }\n        out.flush();\n        return out.toByteArray();\n    }\n}\n",
    "package": "com.pmdesigns.jvc",
    "classname": "JVCRequestContext",
    "id": "/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContext_7Test.java",
    "test_prompt": "// JVCRequestContext_7Test.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JVCRequestContext}.\n* It contains ten unit test cases for the {@link JVCRequestContext#makeLink(String, String)} method.\n*/\nclass JVCRequestContext_7Test {",
    "method_signature": "makeLink(String, String)",
    "suffix": "7"
  },
  {
    "numberTests": "ten",
    "original_code": "// JVCRequestContext.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\n/**\n * This class contains state information for processing an http request.\n * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet\n * objects and provides convenience methods for accessing them.\n * \u003cp\u003e\n * It also provides access to the \u0027flash\u0027 which is a Map for storing temporary\n * key/value strings.  The scope of the flash is the current request or\n * the following request in the case of a redirect response.\n * \u003cp\u003e\n * It also contains some convenience methods for forming links and absolute paths.\n *\n * @author mike dooley\n */\npublic final class JVCRequestContext {\n\n    /**\n     * The actual HttpServletRequest object\n     */\n    public final HttpServletRequest request;\n\n    /**\n     * The actual HttpServletResponse object\n     */\n    public final HttpServletResponse response;\n\n    /**\n     * The HttpServlet object (actually this is a JVCDispatcher)\n     */\n    public final HttpServlet servlet;\n\n    /**\n     * The controller is the servlet path up to the action.\n     */\n    public final String controller;\n\n    /**\n     * The action is the last part of the servlet path (before any query arguments)\n     */\n    public final String action;\n\n    /**\n     * Tells if this request has multipart content (ie file upload)\n     */\n    public final boolean hasMultipartContent;\n\n    /**\n     * Parameter value indicating that the real parameter value is binary (and should be\n     * accessed via the getAttribute() method.\n     */\n    public static final String BINARY_VALUE \u003d \"BINARY_VALUE\";\n\n    /**\n     * The \u0027flash\u0027 map for holding temporary key/value strings.\n     */\n    public final Map\u003cString, String\u003e flash;\n\n    /**\n     * Holds cached page generator fragments\n     */\n    private static Map\u003cString, String\u003e cacheMap;\n\n    /**\n     * Constructor for JVCRequestContext which is used to hold http request and response iformation\n     * @param request\n     * @param response\n     * @param servlet\n     * @param flash\n     * @param controller\n     * @param action\n     */\n    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map\u003cString, String\u003e flash, String controller, String action) throws Exception {\n        this.request \u003d request;\n        this.response \u003d response;\n        this.servlet \u003d servlet;\n        this.controller \u003d controller;\n        this.action \u003d action;\n        this.flash \u003d flash;\n        hasMultipartContent \u003d ServletFileUpload.isMultipartContent(request);\n        if (hasMultipartContent) {\n            // Create a new file upload handler\n            ServletFileUpload upload \u003d new ServletFileUpload();\n            // Parse the request\n            FileItemIterator iter \u003d upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item \u003d iter.next();\n                String name \u003d item.getFieldName();\n                InputStream stream \u003d item.openStream();\n                if (item.isFormField()) {\n                    // add parameter as request attribute\n                    String val \u003d Streams.asString(stream);\n                    request.setAttribute(name, val);\n                    // System.out.println(\"Form field \" + name + \" with value \" + val + \" detected.\");\n                } else {\n                    // add input stream and filename as attributes\n                    String fileName \u003d item.getName();\n                    request.setAttribute(\"fileName\", fileName);\n                    byte[] data \u003d readStream(stream);\n                    request.setAttribute(name, data);\n                    // System.out.println(\"File field \" + name + \" with file name \" + fileName + \" detected.\");\n                }\n            }\n        }\n    }\n\n    // request info\n    /**\n     * Convenience method\n     * @return true if the request is secure\n     */\n    public boolean isSecure() {\n        return request.isSecure();\n    }\n\n    /**\n     * Convenience method\n     * @return the request scheme, ie. http, https\n     */\n    public String getScheme() {\n        return request.getScheme();\n    }\n\n    /**\n     * Convenience method\n     * @return the request method, ie. GET, POST\n     */\n    public String getMethod() {\n        return request.getMethod();\n    }\n\n    /**\n     * Convenience method\n     * @return the server name for this request\n     */\n    public String getServerName() {\n        return request.getServerName();\n    }\n\n    /**\n     * Convenience method\n     * @return the server port for this request\n     */\n    public int getServerPort() {\n        return request.getServerPort();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getServletPath\n     * @see #getQueryString\n     * @return the context path part of the url path\n     */\n    public String getContextPath() {\n        return request.getContextPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getContextPath\n     * @see #getQueryString\n     * @return the servlet path part of the url path\n     */\n    public String getServletPath() {\n        return request.getServletPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getContextPath\n     * @see #getServletPath\n     * @return the query string part of the url path\n     */\n    public String getQueryString() {\n        return request.getQueryString();\n    }\n\n    // params\n    /**\n     * Convenience method\n     * @param name    which parameter to get\n     * @return the parameter value or null if there is no parameter corresponding to the indicated key\n     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,\n     * which can be retrieved as a byte array via the getAttribute method.\n     * @see #getParamMap\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public String getParam(String name) {\n        if (hasMultipartContent) {\n            Object o \u003d request.getAttribute(name);\n            return (o !\u003d null \u0026\u0026 o instanceof String) ? (String) o : BINARY_VALUE;\n        } else {\n            return request.getParameter(name);\n        }\n    }\n\n    /**\n     * Convenience method which gathers all parameters of the\n     * form \u0027\u003cname\u003e[\u003ckey\u003e]\u0027 and return then in a map where the\n     * keys are the \u003ckey\u003e strings and the values are the\n     * corresponding parameter values.\n     * \u003cpre\u003e\n     * For example, if there are parameters:\n     *   \u0027foo[bar1]\u0027 \u003d \u0027baz1\u0027\n     *   \u0027foo[bar2]\u0027 \u003d \u0027baz2\u0027\n     * then getParamMap(\u0027foo\u0027) will returned the map:\n     *   map[\u0027bar1\u0027] \u003d \u0027baz1\u0027\n     *   map[\u0027bar2\u0027] \u003d \u0027baz2\u0027\n     * \u003c/pre\u003e\n     * @param name  the prefix to be used to select parameters\n     * @return a map of all paramters of the form \u0027name[\u003ckey\u003e]\u0027\n     * where the \u003ckey\u003e strings are the keys of the map and the\n     * values are the corresponding parameter values.\n     * @see #getParam\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public Map\u003cString, String\u003e getParamMap(String name) {\n        Map\u003cString, String\u003e m \u003d new HashMap\u003cString, String\u003e();\n        String prefix \u003d name + \"[\";\n        int n \u003d prefix.length();\n        if (hasMultipartContent) {\n            // for multipart requests the parameters have been stored as attributes (see constructor)\n            Enumeration\u003cString\u003e e \u003d request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                String key \u003d e.nextElement();\n                if (key.startsWith(prefix) \u0026\u0026 key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        } else {\n            Map\u003cString, String[]\u003e pm \u003d request.getParameterMap();\n            for (String key : pm.keySet()) {\n                if (key.startsWith(prefix) \u0026\u0026 key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        }\n        return m;\n    }\n\n    /**\n     * Convenience method. Use this if you expect a parameter name\n     * to map to multiple values.\n     * @param name    the name of the parameter(s) to get\n     * @return an array of paramter values corresponding to the indicated name\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamNames\n     */\n    public String[] getParamValues(String name) {\n        return request.getParameterValues(name);\n    }\n\n    /**\n     * Convenience method to get all the parameter names.\n     * @return an array of all parameter names\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamValues\n     */\n    public String[] getParamNames() {\n        if (hasMultipartContent) {\n            List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n            Enumeration\u003cString\u003e e \u003d request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                list.add(e.nextElement());\n            }\n            return list.toArray(new String[list.size()]);\n        } else {\n            Map\u003cString, String[]\u003e m \u003d request.getParameterMap();\n            String[] a \u003d new String[m.size()];\n            int i \u003d 0;\n            for (String key : m.keySet()) {\n                a[i++] \u003d key;\n            }\n            return a;\n        }\n    }\n\n    // attributes\n    /**\n     * Convenience method\n     * @param name    which attribute to get\n     * @return the attribute value or null if there is no attribute corresponding to the indicated key.\n     * If the attribute corresponds to a file upload field then the return value will be a byte array\n     */\n    public Object getAttribute(String name) {\n        return request.getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @param name    name of attribute to be set\n     * @param value   value of attribute to be set\n     */\n    public void setAttribute(String name, Object value) {\n        request.setAttribute(name, value);\n    }\n\n    // session attributes\n    /**\n     * Convenience method\n     * @param name    the name of the attribute to retrieve\n     * @return the attribute associated with the indicated name or null\n     * @see #setSessionAttr\n     * @see #getSessionAttrNames\n     */\n    public Object getSessionAttr(String name) {\n        if (request.getSession() \u003d\u003d null)\n            return null;\n        return request.getSession().getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @return all the session attribute names.\n     * @see #getSessionAttr\n     * @see #setSessionAttr\n     * @see #removeSessionAttr\n     */\n    public String[] getSessionAttrNames() {\n        if (request.getSession(false) \u003d\u003d null)\n            return new String[0];\n        ArrayList\u003cString\u003e a \u003d new ArrayList\u003cString\u003e();\n        Enumeration\u003cString\u003e e \u003d request.getSession().getAttributeNames();\n        while (e.hasMoreElements()) {\n            a.add(e.nextElement());\n        }\n        return a.toArray(new String[a.size()]);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key to store the indicated value\n     * @param value  the object to be stored\n     * @see #getSessionAttr\n     * @see #removeSessionAttr\n     */\n    public void setSessionAttr(String name, Object value) {\n        if (request.getSession() \u003d\u003d null)\n            return;\n        request.getSession().setAttribute(name, value);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key of\n     * @see #setSessionAttr\n     */\n    public void removeSessionAttr(String name) {\n        if (request.getSession() \u003d\u003d null)\n            return;\n        request.getSession().removeAttribute(name);\n    }\n\n    // cookies\n    /**\n     * Convenience method to get cookie by name\n     * @param name  the name of the cookie to get\n     * @return the cookie with the indicated name, or null\n     * @see #setCookie\n     * @see #getCookieNames\n     */\n    public Cookie getCookie(String name) {\n        if (name \u003d\u003d null)\n            return null;\n        Cookie[] cookies \u003d request.getCookies();\n        if (cookies \u003d\u003d null)\n            return null;\n        for (Cookie c : cookies) {\n            if (name.equals(c.getName()))\n                return c;\n        }\n        return null;\n    }\n\n    /**\n     * Convenience method to get all the cookie names.\n     * @return an array of the names of all the cookies in the request, possibly empty\n     * @see #getCookie\n     * @see #setCookie\n     */\n    public String[] getCookieNames() {\n        Cookie[] cookies \u003d request.getCookies();\n        if (cookies \u003d\u003d null)\n            return new String[0];\n        String[] a \u003d new String[cookies.length];\n        int i \u003d 0;\n        for (Cookie c : cookies) {\n            a[i++] \u003d c.getName();\n        }\n        return a;\n    }\n\n    /**\n     * Convenience method\n     * @param cookie   the cookie to be added to the response\n     * @see #getCookie\n     * @see #getCookieNames\n     */\n    public void setCookie(Cookie cookie) {\n        response.addCookie(cookie);\n    }\n\n    /**\n     * Cause a non-standard response (ie. redirect) to be returned.\n     * @param httpCode   the http response code to be returned\n     * @param arg    an argument or message to be returned (depends on response code)\n     * @see #redirect\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void nonStandardResponse(int httpCode, String arg) {\n        throw new NonStandardResponseException(httpCode, arg);\n    }\n\n    /**\n     * Cause a redirect response to be returned\n     * @param path  where to redirect to. If the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #nonStandardResponse\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void redirect(String path) {\n        if (path.startsWith(\"/\"))\n            path \u003d absPath(path);\n        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);\n    }\n\n    /**\n     * Cause a binary response to be returned\n     * @param in input stream containing binary data to be sent\n     * @throws BinaryResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the BinaryResponseException.\n     */\n    public void sendBinaryResponse(InputStream in) {\n        throw new BinaryResponseException(in);\n    }\n\n    /**\n     * Convenience method to prepend the context path onto a servlet path\n     * @param path    a servlet path\n     * @return the context path plus the indicated path\n     */\n    public String absPath(String path) {\n        return getContextPath() + (path.startsWith(\"/\") ? path : \"/\" + path);\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path) {\n        return makeLink(anchor, path, \"\");\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @param options    extra html options to add to the anchor tag\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path, String options) {\n        if (path.startsWith(\"/\"))\n            path \u003d absPath(path);\n        return \"\u003ca href\u003d\u0027\" + path + \"\u0027 \" + options + \"\u003e\" + anchor + \"\u003c/a\u003e\";\n    }\n\n    /**\n     * Convenience method to check if this request is a POST\n     */\n    public boolean isPost() {\n        return \"POST\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to check if this request is a GET\n     */\n    public boolean isGet() {\n        return \"GET\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to retrieve a value from the flash\n     * @param key  the key to use to lookup a flash value\n     * @return the flash value associated with the indicated key or null\n     * @see #setFlash\n     */\n    public String getFlash(String key) {\n        return flash.get(key);\n    }\n\n    /**\n     * Convenience method to add a value to the flash\n     * @param key  the key to use to associate with the flash value\n     * @param val  the value to store\n     * @see #getFlash\n     */\n    public void setFlash(String key, String val) {\n        flash.put(key, val);\n    }\n\n    // caching (internal use)\n    /**\n     * Internal method used to retrieve a cached block\n     * @see #setCachedBlock\n     */\n    public static String getCachedBlock(String key) {\n        return (cacheMap \u003d\u003d null) ? null : cacheMap.get(key);\n    }\n\n    /**\n     * Internal method used to store a cached block\n     * @see #getCachedBlock\n     */\n    public static void setCachedBlock(String key, String val) {\n        if (cacheMap \u003d\u003d null) {\n            cacheMap \u003d new HashMap\u003cString, String\u003e();\n        }\n        cacheMap.put(key, val);\n    }\n\n    /**\n     * For debugging\n     * @return a string representation of this request context\n     */\n    public String toString() {\n        return toString(\", \");\n    }\n\n    public String toString(String sep) {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"params: [\");\n        String[] keys \u003d getParamNames();\n        for (String key : keys) {\n            sb.append(key).append(\u0027\u003d\u0027).append(getParam(key)).append(sep);\n        }\n        if (keys.length \u003e 0) {\n            sb.setLength(sb.length() - sep.length());\n        }\n        sb.append(\"]\");\n        sb.append(sep).append(\"method: \").append(getMethod());\n        sb.append(sep).append(\"url: \").append(getScheme());\n        sb.append(\"|\").append(getServerName());\n        sb.append(\"|\").append(getServerPort());\n        sb.append(\"|\").append(getContextPath());\n        sb.append(\"|\").append(getServletPath());\n        sb.append(\"|\").append(getQueryString());\n        if (hasMultipartContent) {\n            sb.append(sep).append(\"content len: \").append(request.getContentLength());\n            //sb.append(sep).append(\"content type: \").append(request.getContentType());\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Copy an input stream to an output stream.\n     */\n    private byte[] readStream(InputStream in) throws IOException {\n        ByteArrayOutputStream out \u003d new ByteArrayOutputStream();\n        byte[] buf \u003d new byte[4096];\n        int read;\n        while ((read \u003d in.read(buf)) \u003e -1) {\n            out.write(buf, 0, read);\n        }\n        out.flush();\n        return out.toByteArray();\n    }\n}\n",
    "package": "com.pmdesigns.jvc",
    "classname": "JVCRequestContext",
    "id": "/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContext_8Test.java",
    "test_prompt": "// JVCRequestContext_8Test.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JVCRequestContext}.\n* It contains ten unit test cases for the {@link JVCRequestContext#makeLink(String, String, String)} method.\n*/\nclass JVCRequestContext_8Test {",
    "method_signature": "makeLink(String, String, String)",
    "suffix": "8"
  },
  {
    "numberTests": "ten",
    "original_code": "// JVCRequestContext.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\n\n/**\n * This class contains state information for processing an http request.\n * It wraps the standard HttpServletRequest, HttpServletResponse and HttpServlet\n * objects and provides convenience methods for accessing them.\n * \u003cp\u003e\n * It also provides access to the \u0027flash\u0027 which is a Map for storing temporary\n * key/value strings.  The scope of the flash is the current request or\n * the following request in the case of a redirect response.\n * \u003cp\u003e\n * It also contains some convenience methods for forming links and absolute paths.\n *\n * @author mike dooley\n */\npublic final class JVCRequestContext {\n\n    /**\n     * The actual HttpServletRequest object\n     */\n    public final HttpServletRequest request;\n\n    /**\n     * The actual HttpServletResponse object\n     */\n    public final HttpServletResponse response;\n\n    /**\n     * The HttpServlet object (actually this is a JVCDispatcher)\n     */\n    public final HttpServlet servlet;\n\n    /**\n     * The controller is the servlet path up to the action.\n     */\n    public final String controller;\n\n    /**\n     * The action is the last part of the servlet path (before any query arguments)\n     */\n    public final String action;\n\n    /**\n     * Tells if this request has multipart content (ie file upload)\n     */\n    public final boolean hasMultipartContent;\n\n    /**\n     * Parameter value indicating that the real parameter value is binary (and should be\n     * accessed via the getAttribute() method.\n     */\n    public static final String BINARY_VALUE \u003d \"BINARY_VALUE\";\n\n    /**\n     * The \u0027flash\u0027 map for holding temporary key/value strings.\n     */\n    public final Map\u003cString, String\u003e flash;\n\n    /**\n     * Holds cached page generator fragments\n     */\n    private static Map\u003cString, String\u003e cacheMap;\n\n    /**\n     * Constructor for JVCRequestContext which is used to hold http request and response iformation\n     * @param request\n     * @param response\n     * @param servlet\n     * @param flash\n     * @param controller\n     * @param action\n     */\n    JVCRequestContext(HttpServletRequest request, HttpServletResponse response, HttpServlet servlet, Map\u003cString, String\u003e flash, String controller, String action) throws Exception {\n        this.request \u003d request;\n        this.response \u003d response;\n        this.servlet \u003d servlet;\n        this.controller \u003d controller;\n        this.action \u003d action;\n        this.flash \u003d flash;\n        hasMultipartContent \u003d ServletFileUpload.isMultipartContent(request);\n        if (hasMultipartContent) {\n            // Create a new file upload handler\n            ServletFileUpload upload \u003d new ServletFileUpload();\n            // Parse the request\n            FileItemIterator iter \u003d upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item \u003d iter.next();\n                String name \u003d item.getFieldName();\n                InputStream stream \u003d item.openStream();\n                if (item.isFormField()) {\n                    // add parameter as request attribute\n                    String val \u003d Streams.asString(stream);\n                    request.setAttribute(name, val);\n                    // System.out.println(\"Form field \" + name + \" with value \" + val + \" detected.\");\n                } else {\n                    // add input stream and filename as attributes\n                    String fileName \u003d item.getName();\n                    request.setAttribute(\"fileName\", fileName);\n                    byte[] data \u003d readStream(stream);\n                    request.setAttribute(name, data);\n                    // System.out.println(\"File field \" + name + \" with file name \" + fileName + \" detected.\");\n                }\n            }\n        }\n    }\n\n    // request info\n    /**\n     * Convenience method\n     * @return true if the request is secure\n     */\n    public boolean isSecure() {\n        return request.isSecure();\n    }\n\n    /**\n     * Convenience method\n     * @return the request scheme, ie. http, https\n     */\n    public String getScheme() {\n        return request.getScheme();\n    }\n\n    /**\n     * Convenience method\n     * @return the request method, ie. GET, POST\n     */\n    public String getMethod() {\n        return request.getMethod();\n    }\n\n    /**\n     * Convenience method\n     * @return the server name for this request\n     */\n    public String getServerName() {\n        return request.getServerName();\n    }\n\n    /**\n     * Convenience method\n     * @return the server port for this request\n     */\n    public int getServerPort() {\n        return request.getServerPort();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getServletPath\n     * @see #getQueryString\n     * @return the context path part of the url path\n     */\n    public String getContextPath() {\n        return request.getContextPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getContextPath\n     * @see #getQueryString\n     * @return the servlet path part of the url path\n     */\n    public String getServletPath() {\n        return request.getServletPath();\n    }\n\n    /**\n     * Convenience method.  The request url path is broken into:\n     * \u003cul\u003e\n     * \u003cli\u003econtext path\u003c/li\u003e\n     * \u003cli\u003eservlet path\u003c/li\u003e\n     * \u003cli\u003equery string\u003c/li\u003e\n     * \u003c/ul\u003e\n     * @see #getContextPath\n     * @see #getServletPath\n     * @return the query string part of the url path\n     */\n    public String getQueryString() {\n        return request.getQueryString();\n    }\n\n    // params\n    /**\n     * Convenience method\n     * @param name    which parameter to get\n     * @return the parameter value or null if there is no parameter corresponding to the indicated key\n     * or BINARY_VALUE if this is a multipart request and there is binary data for the indicate key,\n     * which can be retrieved as a byte array via the getAttribute method.\n     * @see #getParamMap\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public String getParam(String name) {\n        if (hasMultipartContent) {\n            Object o \u003d request.getAttribute(name);\n            return (o !\u003d null \u0026\u0026 o instanceof String) ? (String) o : BINARY_VALUE;\n        } else {\n            return request.getParameter(name);\n        }\n    }\n\n    /**\n     * Convenience method which gathers all parameters of the\n     * form \u0027\u003cname\u003e[\u003ckey\u003e]\u0027 and return then in a map where the\n     * keys are the \u003ckey\u003e strings and the values are the\n     * corresponding parameter values.\n     * \u003cpre\u003e\n     * For example, if there are parameters:\n     *   \u0027foo[bar1]\u0027 \u003d \u0027baz1\u0027\n     *   \u0027foo[bar2]\u0027 \u003d \u0027baz2\u0027\n     * then getParamMap(\u0027foo\u0027) will returned the map:\n     *   map[\u0027bar1\u0027] \u003d \u0027baz1\u0027\n     *   map[\u0027bar2\u0027] \u003d \u0027baz2\u0027\n     * \u003c/pre\u003e\n     * @param name  the prefix to be used to select parameters\n     * @return a map of all paramters of the form \u0027name[\u003ckey\u003e]\u0027\n     * where the \u003ckey\u003e strings are the keys of the map and the\n     * values are the corresponding parameter values.\n     * @see #getParam\n     * @see #getParamValues\n     * @see #getParamNames\n     */\n    public Map\u003cString, String\u003e getParamMap(String name) {\n        Map\u003cString, String\u003e m \u003d new HashMap\u003cString, String\u003e();\n        String prefix \u003d name + \"[\";\n        int n \u003d prefix.length();\n        if (hasMultipartContent) {\n            // for multipart requests the parameters have been stored as attributes (see constructor)\n            Enumeration\u003cString\u003e e \u003d request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                String key \u003d e.nextElement();\n                if (key.startsWith(prefix) \u0026\u0026 key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        } else {\n            Map\u003cString, String[]\u003e pm \u003d request.getParameterMap();\n            for (String key : pm.keySet()) {\n                if (key.startsWith(prefix) \u0026\u0026 key.endsWith(\"]\")) {\n                    m.put(key.substring(n, key.length() - 1), getParam(key));\n                }\n            }\n        }\n        return m;\n    }\n\n    /**\n     * Convenience method. Use this if you expect a parameter name\n     * to map to multiple values.\n     * @param name    the name of the parameter(s) to get\n     * @return an array of paramter values corresponding to the indicated name\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamNames\n     */\n    public String[] getParamValues(String name) {\n        return request.getParameterValues(name);\n    }\n\n    /**\n     * Convenience method to get all the parameter names.\n     * @return an array of all parameter names\n     * @see #getParam\n     * @see #getParamMap\n     * @see #getParamValues\n     */\n    public String[] getParamNames() {\n        if (hasMultipartContent) {\n            List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n            Enumeration\u003cString\u003e e \u003d request.getAttributeNames();\n            while (e.hasMoreElements()) {\n                list.add(e.nextElement());\n            }\n            return list.toArray(new String[list.size()]);\n        } else {\n            Map\u003cString, String[]\u003e m \u003d request.getParameterMap();\n            String[] a \u003d new String[m.size()];\n            int i \u003d 0;\n            for (String key : m.keySet()) {\n                a[i++] \u003d key;\n            }\n            return a;\n        }\n    }\n\n    // attributes\n    /**\n     * Convenience method\n     * @param name    which attribute to get\n     * @return the attribute value or null if there is no attribute corresponding to the indicated key.\n     * If the attribute corresponds to a file upload field then the return value will be a byte array\n     */\n    public Object getAttribute(String name) {\n        return request.getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @param name    name of attribute to be set\n     * @param value   value of attribute to be set\n     */\n    public void setAttribute(String name, Object value) {\n        request.setAttribute(name, value);\n    }\n\n    // session attributes\n    /**\n     * Convenience method\n     * @param name    the name of the attribute to retrieve\n     * @return the attribute associated with the indicated name or null\n     * @see #setSessionAttr\n     * @see #getSessionAttrNames\n     */\n    public Object getSessionAttr(String name) {\n        if (request.getSession() \u003d\u003d null)\n            return null;\n        return request.getSession().getAttribute(name);\n    }\n\n    /**\n     * Convenience method\n     * @return all the session attribute names.\n     * @see #getSessionAttr\n     * @see #setSessionAttr\n     * @see #removeSessionAttr\n     */\n    public String[] getSessionAttrNames() {\n        if (request.getSession(false) \u003d\u003d null)\n            return new String[0];\n        ArrayList\u003cString\u003e a \u003d new ArrayList\u003cString\u003e();\n        Enumeration\u003cString\u003e e \u003d request.getSession().getAttributeNames();\n        while (e.hasMoreElements()) {\n            a.add(e.nextElement());\n        }\n        return a.toArray(new String[a.size()]);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key to store the indicated value\n     * @param value  the object to be stored\n     * @see #getSessionAttr\n     * @see #removeSessionAttr\n     */\n    public void setSessionAttr(String name, Object value) {\n        if (request.getSession() \u003d\u003d null)\n            return;\n        request.getSession().setAttribute(name, value);\n    }\n\n    /**\n     * Convenience method\n     * @param name  the key of\n     * @see #setSessionAttr\n     */\n    public void removeSessionAttr(String name) {\n        if (request.getSession() \u003d\u003d null)\n            return;\n        request.getSession().removeAttribute(name);\n    }\n\n    // cookies\n    /**\n     * Convenience method to get cookie by name\n     * @param name  the name of the cookie to get\n     * @return the cookie with the indicated name, or null\n     * @see #setCookie\n     * @see #getCookieNames\n     */\n    public Cookie getCookie(String name) {\n        if (name \u003d\u003d null)\n            return null;\n        Cookie[] cookies \u003d request.getCookies();\n        if (cookies \u003d\u003d null)\n            return null;\n        for (Cookie c : cookies) {\n            if (name.equals(c.getName()))\n                return c;\n        }\n        return null;\n    }\n\n    /**\n     * Convenience method to get all the cookie names.\n     * @return an array of the names of all the cookies in the request, possibly empty\n     * @see #getCookie\n     * @see #setCookie\n     */\n    public String[] getCookieNames() {\n        Cookie[] cookies \u003d request.getCookies();\n        if (cookies \u003d\u003d null)\n            return new String[0];\n        String[] a \u003d new String[cookies.length];\n        int i \u003d 0;\n        for (Cookie c : cookies) {\n            a[i++] \u003d c.getName();\n        }\n        return a;\n    }\n\n    /**\n     * Convenience method\n     * @param cookie   the cookie to be added to the response\n     * @see #getCookie\n     * @see #getCookieNames\n     */\n    public void setCookie(Cookie cookie) {\n        response.addCookie(cookie);\n    }\n\n    /**\n     * Cause a non-standard response (ie. redirect) to be returned.\n     * @param httpCode   the http response code to be returned\n     * @param arg    an argument or message to be returned (depends on response code)\n     * @see #redirect\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void nonStandardResponse(int httpCode, String arg) {\n        throw new NonStandardResponseException(httpCode, arg);\n    }\n\n    /**\n     * Cause a redirect response to be returned\n     * @param path  where to redirect to. If the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #nonStandardResponse\n     * @throws NonStandardResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the NonStandardResponseException.\n     */\n    public void redirect(String path) {\n        if (path.startsWith(\"/\"))\n            path \u003d absPath(path);\n        nonStandardResponse(HttpURLConnection.HTTP_MOVED_TEMP, path);\n    }\n\n    /**\n     * Cause a binary response to be returned\n     * @param in input stream containing binary data to be sent\n     * @throws BinaryResponseException which is a subclass of RuntimeException.\n     * If you call this method inside a try/catch block make sure you re-throw\n     * the BinaryResponseException.\n     */\n    public void sendBinaryResponse(InputStream in) {\n        throw new BinaryResponseException(in);\n    }\n\n    /**\n     * Convenience method to prepend the context path onto a servlet path\n     * @param path    a servlet path\n     * @return the context path plus the indicated path\n     */\n    public String absPath(String path) {\n        return getContextPath() + (path.startsWith(\"/\") ? path : \"/\" + path);\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path) {\n        return makeLink(anchor, path, \"\");\n    }\n\n    /**\n     * Convenience method to create an html anchor link tag\n     * @param anchor    the text in an anchor link\n     * @param path   the anchor target, if the path starts with a \u0027/\u0027 character then\n     * its assumed that this is an absolute link and the context path will be prepended to it\n     * @param options    extra html options to add to the anchor tag\n     * @see #makeLink\n     * @see #absPath\n     */\n    public String makeLink(String anchor, String path, String options) {\n        if (path.startsWith(\"/\"))\n            path \u003d absPath(path);\n        return \"\u003ca href\u003d\u0027\" + path + \"\u0027 \" + options + \"\u003e\" + anchor + \"\u003c/a\u003e\";\n    }\n\n    /**\n     * Convenience method to check if this request is a POST\n     */\n    public boolean isPost() {\n        return \"POST\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to check if this request is a GET\n     */\n    public boolean isGet() {\n        return \"GET\".equals(request.getMethod());\n    }\n\n    /**\n     * Convenience method to retrieve a value from the flash\n     * @param key  the key to use to lookup a flash value\n     * @return the flash value associated with the indicated key or null\n     * @see #setFlash\n     */\n    public String getFlash(String key) {\n        return flash.get(key);\n    }\n\n    /**\n     * Convenience method to add a value to the flash\n     * @param key  the key to use to associate with the flash value\n     * @param val  the value to store\n     * @see #getFlash\n     */\n    public void setFlash(String key, String val) {\n        flash.put(key, val);\n    }\n\n    // caching (internal use)\n    /**\n     * Internal method used to retrieve a cached block\n     * @see #setCachedBlock\n     */\n    public static String getCachedBlock(String key) {\n        return (cacheMap \u003d\u003d null) ? null : cacheMap.get(key);\n    }\n\n    /**\n     * Internal method used to store a cached block\n     * @see #getCachedBlock\n     */\n    public static void setCachedBlock(String key, String val) {\n        if (cacheMap \u003d\u003d null) {\n            cacheMap \u003d new HashMap\u003cString, String\u003e();\n        }\n        cacheMap.put(key, val);\n    }\n\n    /**\n     * For debugging\n     * @return a string representation of this request context\n     */\n    public String toString() {\n        return toString(\", \");\n    }\n\n    public String toString(String sep) {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"params: [\");\n        String[] keys \u003d getParamNames();\n        for (String key : keys) {\n            sb.append(key).append(\u0027\u003d\u0027).append(getParam(key)).append(sep);\n        }\n        if (keys.length \u003e 0) {\n            sb.setLength(sb.length() - sep.length());\n        }\n        sb.append(\"]\");\n        sb.append(sep).append(\"method: \").append(getMethod());\n        sb.append(sep).append(\"url: \").append(getScheme());\n        sb.append(\"|\").append(getServerName());\n        sb.append(\"|\").append(getServerPort());\n        sb.append(\"|\").append(getContextPath());\n        sb.append(\"|\").append(getServletPath());\n        sb.append(\"|\").append(getQueryString());\n        if (hasMultipartContent) {\n            sb.append(sep).append(\"content len: \").append(request.getContentLength());\n            //sb.append(sep).append(\"content type: \").append(request.getContentType());\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Copy an input stream to an output stream.\n     */\n    private byte[] readStream(InputStream in) throws IOException {\n        ByteArrayOutputStream out \u003d new ByteArrayOutputStream();\n        byte[] buf \u003d new byte[4096];\n        int read;\n        while ((read \u003d in.read(buf)) \u003e -1) {\n            out.write(buf, 0, read);\n        }\n        out.flush();\n        return out.toByteArray();\n    }\n}\n",
    "package": "com.pmdesigns.jvc",
    "classname": "JVCRequestContext",
    "id": "/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCRequestContext_9Test.java",
    "test_prompt": "// JVCRequestContext_9Test.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport org.apache.commons.fileupload.*;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JVCRequestContext}.\n* It contains ten unit test cases for the {@link JVCRequestContext#getFlash(String)} method.\n*/\nclass JVCRequestContext_9Test {",
    "method_signature": "getFlash(String)",
    "suffix": "9"
  },
  {
    "numberTests": "ten",
    "original_code": "// JVCDispatcher.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.Cookie;\nimport com.pmdesigns.jvc.tools.Base64Coder;\nimport com.pmdesigns.jvc.tools.JVCGenerator;\n\n/**\n * JVC request dispatching servlet\n *\n * @author mike dooley\n */\npublic class JVCDispatcher extends HttpServlet {\n\n    private Map\u003cString, Class\u003e generatorClasses;\n\n    private String pkgPrefix;\n\n    public static final String PKG_PREFIX_KEY \u003d \"pkg_prefix\";\n\n    private static Class requestContextClass;\n\n    private static Class classNotFound;\n\n    private Destroyable application;\n\n    private static final boolean TRACE \u003d false;\n\n    private static ThreadLocal\u003cJVCRequestContext\u003e ctxHolder \u003d new ThreadLocal\u003cJVCRequestContext\u003e() {\n\n        protected synchronized JVCRequestContext initialValue() {\n            return null;\n        }\n    };\n\n    /**\n     * Return the thread local request context\n     * @return the JVCRequestContext associated with the current thread or null\n     */\n    public static JVCRequestContext getRC() {\n        return ctxHolder.get();\n    }\n\n    /**\n     * Get the package prefix (from config) so we know the fully qualified\n     * name of page generators and controllers.  Also create and instance\n     * of the Application object.\n     */\n    public void init() {\n        pkgPrefix \u003d getInitParameter(PKG_PREFIX_KEY);\n        generatorClasses \u003d new HashMap\u003cString, Class\u003e();\n        if (classNotFound \u003d\u003d null) {\n            // just a rock, any Class will do\n            classNotFound \u003d getClass();\n        }\n        // create an instance of the Application class\n        String className \u003d appendPkg(pkgPrefix, \"Application\");\n        try {\n            Class appClass \u003d Class.forName(className);\n            Class[] args \u003d { Class.forName(\"javax.servlet.GenericServlet\") };\n            Constructor\u003cDestroyable\u003e appConstructor \u003d appClass.getConstructor(args);\n            this.application \u003d appConstructor.newInstance(this);\n        } catch (InvocationTargetException e) {\n            Throwable t \u003d e.getTargetException();\n            Log.error(\"Failed to create Application instance: \", ((t !\u003d null) ? t : e));\n        } catch (IllegalArgumentException e) {\n            Log.error(\"Illegal Application constructor args\", e);\n        } catch (NoSuchMethodException e) {\n            Log.error(\"Constructor not found for: \" + className, e);\n        } catch (Exception e) {\n            Log.error(\"Error while creating Application\", e);\n        }\n    }\n\n    /**\n     * Notify the Application that its shutdown time.\n     */\n    public void destroy() {\n        if (application !\u003d null) {\n            application.destroy();\n            application \u003d null;\n        }\n    }\n\n    /**\n     * Handle a GET request. Called by servlet container.\n     * @param request\n     * @param response\n     * @throws IOException\n     * @throws ServletException\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        handleRequest(request, response);\n    }\n\n    /**\n     * Handle a POST request. Called by servlet container.\n     * @param request\n     * @param response\n     * @throws IOException\n     * @throws ServletException\n     */\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        handleRequest(request, response);\n    }\n\n    /**\n     * Private implementation to handle a GET or POST request by invoking the appropriate\n     * PageGenerator and Controller objects, or by serving static content.\n     * @param request\n     * @param response\n     * @throws IOException\n     * @throws ServletException\n     */\n    private void handleRequest(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        long t0, t1;\n        if (TRACE)\n            t0 \u003d System.currentTimeMillis();\n        // i18n\n        response.setCharacterEncoding(\"UTF8\");\n        request.setCharacterEncoding(\"UTF8\");\n        // request path for a dynamic page is expected to be of the form: / [\u003ccontroller\u003e / ] [\u003caction\u003e]\n        String reqPath \u003d request.getServletPath();\n        // strip leading \u0027/\u0027\n        if (reqPath.length() \u003c 1) {\n            // should never happen\n            Log.error(\"Empty path!\");\n            response.sendError(HttpURLConnection.HTTP_NOT_FOUND, request.getRequestURI());\n        } else if (reqPath.charAt(0) \u003d\u003d \u0027/\u0027) {\n            reqPath \u003d reqPath.substring(1, reqPath.length());\n        }\n        // try to extract the controller and action from the request path\n        String controller;\n        String action;\n        int idx \u003d reqPath.lastIndexOf(\u0027/\u0027);\n        if (idx \u003d\u003d -1) {\n            controller \u003d \"\";\n            action \u003d reqPath;\n        } else {\n            controller \u003d reqPath.substring(0, idx);\n            action \u003d reqPath.substring(idx + 1);\n        }\n        // only look for a generator if there isn\u0027t a \u0027.\u0027 in the action\n        if (action.indexOf(\u0027.\u0027) \u003d\u003d -1) {\n            if (action.length() \u003d\u003d 0) {\n                // automatically supply this action\n                action \u003d \"index\";\n            }\n            String pkg \u003d appendPkg(pkgPrefix, \"generators\");\n            if (controller.length() \u003e 0) {\n                pkg +\u003d \".\" + controller.replace(\u0027/\u0027, \u0027.\u0027);\n            }\n            String methodName \u003d JVCGenerator.GENERATOR_METHOD_NAME;\n            String className \u003d pkg + \".\" + JVCGenerator.capitalize(action) + \"Generator\";\n            //Log.info(\"looking for generator \u0027\"+reqPath+\"\u0027, class: \"+className+\", meth: \"+methodName);\n            // lookup the generator class\n            Class genClass \u003d generatorClasses.get(className);\n            if (genClass \u003d\u003d null) {\n                try {\n                    genClass \u003d Class.forName(className);\n                } catch (ClassNotFoundException e) {\n                    genClass \u003d classNotFound;\n                    //Log.info(\"Generator class not found: \"+className);\n                }\n                generatorClasses.put(className, genClass);\n            }\n            if (genClass !\u003d classNotFound) {\n                // this is a dynamic page request. invoke page generator\n                JVCRequestContext rc \u003d null;\n                try {\n                    if (requestContextClass \u003d\u003d null) {\n                        requestContextClass \u003d Class.forName(\"com.pmdesigns.jvc.JVCRequestContext\");\n                    }\n                    Class[] args \u003d { requestContextClass };\n                    Method meth \u003d genClass.getMethod(methodName, args);\n                    // look for \u0027flash cookie\u0027\n                    Map\u003cString, String\u003e flash \u003d getFlash(request, response);\n                    // render the page\n                    rc \u003d new JVCRequestContext(request, response, this, flash, controller, action);\n                    // put the context in thread local\n                    ctxHolder.set(rc);\n                    String s \u003d (String) meth.invoke(null, rc);\n                    // write response\n                    response.getWriter().print(s);\n                    response.flushBuffer();\n                } catch (InvocationTargetException e) {\n                    // our non-standard-response exceptions get wrapped in invocation-target exceptions\n                    Throwable t \u003d e.getTargetException();\n                    if (t instanceof NonStandardResponseException) {\n                        // send appropriate response (usually a redirect)\n                        NonStandardResponseException resp \u003d (NonStandardResponseException) t;\n                        //Log.info(\"non standard response: \"+resp);\n                        if (resp.httpCode \u003d\u003d HttpURLConnection.HTTP_MOVED_TEMP) {\n                            // add \u0027flash cookie\u0027 if necessary\n                            if (rc !\u003d null \u0026\u0026 !rc.flash.isEmpty()) {\n                                Cookie c \u003d makeFlashCookie(rc.flash);\n                                c.setPath(request.getContextPath());\n                                response.addCookie(c);\n                            }\n                            response.sendRedirect(resp.arg);\n                        } else {\n                            response.sendError(resp.httpCode, resp.arg);\n                        }\n                    } else if (t instanceof BinaryResponseException) {\n                        // send binary response\n                        BinaryResponseException bre \u003d (BinaryResponseException) t;\n                        OutputStream out \u003d new BufferedOutputStream(response.getOutputStream());\n                        copy(bre.in, out);\n                        response.flushBuffer();\n                    } else {\n                        // send a server error response\n                        String err \u003d ((t !\u003d null) ? t.toString() : e.toString());\n                        Log.error(\"Invocation error: \", ((t !\u003d null) ? t : e));\n                        response.sendError(HttpURLConnection.HTTP_INTERNAL_ERROR, err);\n                    }\n                } catch (NoSuchMethodException e) {\n                    // send a not-found response\n                    Log.error(\"Method not found: \" + className + \".\" + methodName);\n                    response.sendError(HttpURLConnection.HTTP_NOT_FOUND, request.getRequestURI());\n                } catch (Throwable e) {\n                    Log.error(\"Unhandled exception while processing \" + request.getRequestURI(), e);\n                    // send server-error response\n                    response.sendError(HttpURLConnection.HTTP_INTERNAL_ERROR, request.getRequestURI());\n                } finally {\n                    // remove context from the thread local\n                    ctxHolder.set(null);\n                    if (TRACE)\n                        Log.info(\"TIMING_1 \u0027\" + reqPath + \"\u0027 \u003d \" + (System.currentTimeMillis() - t0));\n                }\n                // done with dynamic page request\n                return;\n            }\n        }\n        // look for static file\n        if (action.length() \u003d\u003d 0) {\n            // supply default static file\n            reqPath +\u003d \"index.html\";\n        }\n        //Log.info(\"looking for resource \u0027\"+reqPath+\"\u0027\");\n        try {\n            InputStream in \u003d getServletContext().getResourceAsStream(reqPath);\n            if (in !\u003d null) {\n                OutputStream out \u003d new BufferedOutputStream(response.getOutputStream());\n                copy(in, out);\n                response.flushBuffer();\n                if (TRACE)\n                    Log.info(\"TIMING_2 \u0027\" + reqPath + \"\u0027 \u003d \" + (System.currentTimeMillis() - t0));\n                return;\n            }\n        } catch (IOException e) {\n            Log.error(\"Error sending \u0027\" + reqPath + \"\u0027\", e);\n        }\n        response.sendError(HttpURLConnection.HTTP_NOT_FOUND, request.getRequestURI());\n        if (TRACE)\n            Log.info(\"TIMING_3 \u0027\" + reqPath + \"\u0027 \u003d \" + (System.currentTimeMillis() - t0));\n    }\n\n    /**\n     * Copy an input stream to an output stream.\n     */\n    private void copy(InputStream in, OutputStream out) throws IOException {\n        byte[] buf \u003d new byte[4096];\n        int read;\n        while ((read \u003d in.read(buf)) \u003e -1) {\n            out.write(buf, 0, read);\n        }\n        out.flush();\n    }\n\n    /**\n     * Append a package string to a prefix if the prefix isn\u0027t empty\n     */\n    private static String appendPkg(String prefix, String pkg) {\n        return (prefix \u003d\u003d null || prefix.length() \u003d\u003d 0) ? pkg : prefix + \".\" + pkg;\n    }\n\n    private static final String FLASH_COOKIE \u003d \"jvc_flash\";\n\n    /**\n     * Look for a \u0027flash cookie\u0027 in the request.  If found deserialize it, clear the cookie\n     * and return it, otherwise just return an empty Map.\n     * @see #makeFlashCookie\n     * @see #serializeMap\n     * @see #deserializeMap\n     */\n    private static Map\u003cString, String\u003e getFlash(HttpServletRequest request, HttpServletResponse response) {\n        Cookie[] cookies \u003d request.getCookies();\n        if (cookies !\u003d null) {\n            for (Cookie c : cookies) {\n                if (FLASH_COOKIE.equals(c.getName())) {\n                    // extract the flash from the cookie\n                    Map\u003cString, String\u003e map \u003d deserializeMap(c.getValue());\n                    // clear the flash cookie\n                    c \u003d new Cookie(FLASH_COOKIE, \"\");\n                    c.setPath(request.getContextPath());\n                    c.setMaxAge(0);\n                    response.addCookie(c);\n                    return map;\n                }\n            }\n        }\n        return new HashMap\u003cString, String\u003e();\n    }\n\n    /**\n     * Serialize the indicated map and return it in a \u0027flash cookie\u0027\n     * @see #getFlash\n     * @see #serializeMap\n     * @see #deserializeMap\n     */\n    private static Cookie makeFlashCookie(Map\u003cString, String\u003e map) {\n        return new Cookie(FLASH_COOKIE, serializeMap(map));\n    }\n\n    /**\n     * Return a string representation of the map.\n     * This method encodes the map by writing its keys and values\n     * separated by the 0 character (the end of the list is indicated\n     * by an empty key) and then base64 encoding this string.\n     * @see #getFlash\n     * @see #makeFlashCookie\n     * @see #deserializeMap\n     */\n    private static String serializeMap(Map\u003cString, String\u003e map) {\n        StringBuilder sb \u003d new StringBuilder();\n        for (String key : map.keySet()) {\n            String val \u003d map.get(key);\n            if (val !\u003d null) {\n                sb.append(key).append((char) 0).append(val).append((char) 0);\n            }\n        }\n        sb.append((char) 0);\n        return Base64Coder.encodeString(sb.toString());\n    }\n\n    /**\n     * Return the map representation of the indicated string (see serializeMap())\n     * @see #getFlash\n     * @see #makeFlashCookie\n     * @see #serializeMap\n     */\n    private static Map\u003cString, String\u003e deserializeMap(String s) {\n        s \u003d Base64Coder.decodeString(s);\n        Map\u003cString, String\u003e map \u003d new HashMap\u003cString, String\u003e();\n        int idx \u003d 0;\n        int idx2;\n        while ((idx2 \u003d s.indexOf((char) 0, idx)) !\u003d -1) {\n            if (idx \u003d\u003d idx2) {\n                // end of list is marked by empty key\n                break;\n            }\n            String key \u003d s.substring(idx, idx2);\n            idx \u003d idx2 + 1;\n            idx2 \u003d s.indexOf((char) 0, idx);\n            if (idx2 \u003d\u003d -1) {\n                Log.error(\"Invalid serialized map.\");\n                // throw exception ?\n                break;\n            }\n            String val \u003d s.substring(idx, idx2);\n            map.put(key, val);\n            idx \u003d idx2 + 1;\n        }\n        return map;\n    }\n}\n",
    "package": "com.pmdesigns.jvc",
    "classname": "JVCDispatcher",
    "id": "/EvoSuiteBenchmark/original/33_javaviewcontrol/src/main/java/com/pmdesigns/jvc/JVCDispatcher.java",
    "test_prompt": "// JVCDispatcherTest.java\npackage com.pmdesigns.jvc;\n\nimport java.io.*;\nimport java.util.*;\nimport java.net.HttpURLConnection;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.Cookie;\nimport com.pmdesigns.jvc.tools.Base64Coder;\nimport com.pmdesigns.jvc.tools.JVCGenerator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JVCDispatcher}.\n* It contains ten unit test cases for the {@link JVCDispatcher#getRC()} method.\n*/\nclass JVCDispatcherTest {",
    "method_signature": "getRC()",
    "suffix": ""
  }
]