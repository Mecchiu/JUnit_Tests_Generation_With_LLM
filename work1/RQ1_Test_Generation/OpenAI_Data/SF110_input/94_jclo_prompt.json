[
  {
    "numberTests": "ten",
    "original_code": "// JCLO.java\npackage edu.mscd.cs.jclo;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Modifier;\n\n/**\n * This class is used to parse command-line arguments based on a the\n * variables with an object.  Each variable in the class specifies a\n * command-line argument that can be accepted; the name of the variable\n * becomes the name of the command-line argument.  As Java does not allow\n * dashes \u0027-\u0027 in variables, use two underscores \u0027__\u0027 if you want a dash in\n * an argument.  Also, if you want to have a numeric argument (e.g.: \u0027-1\u0027),\n * start the variable name with a single underscore.  JCLO uses reflection\n * to determine the type of each variable in the passed object and sets the\n * values in the object passed to it via parsing the command line.  If you\n * include a String array named \"additional\", all non-dashed arguments will\n * be placed in it.\n *\n * @author\t\tSteve Beaty (beatys@mscd.edu) @version\t$Id:\n * JCLO.java,v 1.5 2007/11/01 16:43:12 beaty Exp beaty $\n */\npublic class JCLO {\n\n    private Field[] fields;\n\n    private Object object;\n\n    private boolean doubleDashes;\n\n    private boolean hasEquals;\n\n    private String prefix \u003d \"\";\n\n    private String[][] aliases;\n\n    /**\n     * \tA constructor that takes the Object that contains the variables\n     * \tacceptable on a command line.  Call parse (String) to do the actual\n     * \tparsing.\n     *\n     * \t@param\tobject\twhere the variables/arguments are\n     */\n    public JCLO(Object object) {\n        this((String) null, object, null);\n    }\n\n    public JCLO(Object object, String[][] aliases) {\n        this((String) null, object, aliases);\n    }\n\n    public JCLO(String prefix, Object object) {\n        this(prefix, object, null);\n    }\n\n    /**\n     * \tA constructor that takes an Object, a prefix, and a boolean that\n     * \tspecifies whether to accept single or double dashes; call parse\n     * \t(String) to do the actual parsing.\n     *\n     * \t@param\tobject\twhere the variables/arguments are\n     * \t@param\tprefix\tthe String CLO\u0027s start with, if any\n     */\n    public JCLO(String prefix, Object object, String[][] aliases) {\n        this.object \u003d object;\n        this.prefix \u003d prefix;\n        this.aliases \u003d aliases;\n        fields \u003d object.getClass().getDeclaredFields();\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            fields[i].setAccessible(true);\n        }\n    }\n\n    /**\n     * \tJust a simple method to put the try/catch in one place.\n     *\n     * \t@param\tf\tthe Field to get the value of\n     * \t@return\t\tthe Object with the value\n     */\n    private Object getObject(Field f) {\n        try {\n            return (f.get(object));\n        } catch (java.lang.IllegalAccessException iae) {\n            iae.printStackTrace();\n            System.exit(1);\n        }\n        return (null);\n    }\n\n    private Field getField(String key) {\n        Field f \u003d null;\n        if (prefix !\u003d null)\n            key \u003d prefix + key;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            String name \u003d fields[i].getName();\n            if (name.equals(key))\n                return (fields[i]);\n        }\n        return (null);\n    }\n\n    /**\n     * \tGet the current value of the variable in the object\n     *\n     * \t@param\tkey\tthe variable name\n     * \t@return\t\tan Object with the value\n     */\n    public Object getValue(String key) {\n        Field f \u003d getField(key);\n        if (f \u003d\u003d null) {\n            System.out.println(\"Field not found: \" + key);\n            return (null);\n        }\n        return (getObject(f));\n    }\n\n    /**\n     * \tJust a simple method to put the try/catch in one place.\n     *\n     * \t@param\tf\tthe Field to set the value of\n     * \t@param\to\tthe Object with the value\n     */\n    private void setObject(Field f, Object o) {\n        try {\n            f.set(object, o);\n        } catch (java.lang.IllegalAccessException iae) {\n            iae.printStackTrace();\n        }\n    }\n\n    private String getArrayType(Class type) {\n        return (type.getComponentType().toString().replaceFirst(\"class.*\\\\.\", \"\"));\n    }\n\n    /**\n     * \tAn external representation of the object\n     *\n     * \t@return\t\ta formatted version of this object\n     */\n    public String toString() {\n        String r \u003d \"\";\n        boolean first \u003d true;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            Field field \u003d fields[i];\n            String key \u003d field.getName();\n            Class type \u003d field.getType();\n            Object object \u003d getObject(field);\n            if (!first)\n                r +\u003d \"\\n\";\n            first \u003d false;\n            if (type.isArray()) {\n                r +\u003d getArrayType(type) + \"[]\" + \": \" + key + \" \u003d \";\n                r +\u003d java.util.Arrays.toString((Object[]) object);\n            } else {\n                r +\u003d type.toString().replaceFirst(\"class java.lang.\", \"\") + \": \" + key + \" \u003d \" + object;\n            }\n        }\n        return (r);\n    }\n\n    private String getUsageType(Class type) {\n        if (type.getName().equals(\"boolean\")) {\n            return (doubleDashes ? \"[\u003dboolean]\" : \"\");\n        } else if (type.isArray()) {\n            return ((doubleDashes ? \"\u003d\" : \" \") + getArrayType(type) + \"...\");\n        } else {\n            return ((doubleDashes ? \"\u003d\" : \" \") + type.getName().replaceFirst(\"java.lang.\", \"\"));\n        }\n    }\n\n    /**\n     *  Create and usage message for the acceptable command line variables.\n     *\n     * \t@return\t\ta String that specifies acceptable options\n     */\n    public String usage() {\n        boolean additional \u003d false;\n        String[] a \u003d new String[fields.length];\n        int count \u003d 0;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            Field field \u003d fields[i];\n            String key \u003d field.getName();\n            Class type \u003d field.getType();\n            if (key.equals(\"additional\"))\n                continue;\n            if (prefix !\u003d null) {\n                if (!key.startsWith(prefix))\n                    continue;\n                else\n                    key \u003d key.replaceFirst(\"^\" + prefix, \"\");\n            }\n            if (Modifier.isFinal(field.getModifiers()))\n                continue;\n            key \u003d key.replaceFirst(\"^_([0-9])\", \"$1\");\n            key \u003d key.replaceAll(\"__\", \"-\");\n            key \u003d key.replaceAll(\"_\\\\$\", \".\");\n            a[count++] \u003d (doubleDashes ? \"--\" : \"-\") + key + getUsageType(type) + \"\\n\";\n        }\n        String r \u003d \"\";\n        java.util.Arrays.sort(a, 0, count);\n        for (int i \u003d 0; i \u003c a.length; i++) if (a[i] !\u003d null)\n            r +\u003d a[i];\n        return (r);\n    }\n\n    private void parseAdditional(String[] args, int i) {\n        int number \u003d args.length - i;\n        String[] add \u003d new String[number];\n        for (int j \u003d 0; j \u003c number; j++, i++) {\n            add[j] \u003d args[i];\n        }\n        Field f \u003d getField(\"additional\");\n        if (f !\u003d null) {\n            setObject(f, add);\n        } else {\n            System.err.println(\"No varible \u0027additional\u0027 found\");\n        }\n    }\n\n    /**\n     * \tAdd to object o to the end of the array contained in field and\n     * \treturn the resulting array.\n     *\n     * \t@param\tfield\tthe field in the object\n     * \t@param\to\tthe new object to be placed at the end\n     * \t@return\t\ta formatted version of this object\n     */\n    private Object addToArray(Field field, Object o) {\n        Object ret;\n        Object orig \u003d getObject(field);\n        Class componentType \u003d field.getType().getComponentType();\n        if (// the array is empty\n        orig \u003d\u003d null) {\n            ret \u003d Array.newInstance(componentType, 1);\n            Array.set(ret, 0, o);\n        } else {\n            int length \u003d Array.getLength(orig);\n            ret \u003d Array.newInstance(componentType, length + 1);\n            int j;\n            for (j \u003d 0; j \u003c length; j++) {\n                Array.set(ret, j, Array.get(orig, j));\n            }\n            Array.set(ret, j, o);\n        }\n        return (ret);\n    }\n\n    private String getKey(String arg) {\n        if (hasEquals)\n            arg \u003d arg.replaceFirst(\"\u003d.*\", \"\");\n        if (doubleDashes)\n            arg \u003d arg.substring(2);\n        else\n            arg \u003d arg.substring(1);\n        // variables can\u0027t start with a number and can\u0027t have a dash\n        arg \u003d arg.replaceAll(\"^([0-9])\", \"_$1\");\n        arg \u003d arg.replaceAll(\"-\", \"__\");\n        arg \u003d arg.replaceAll(\"\\\\.\", \"_\\\\$\");\n        if (aliases !\u003d null) {\n            for (int i \u003d 0; i \u003c aliases.length; i++) {\n                if (aliases[i][0].equals(arg))\n                    arg \u003d aliases[i][1];\n            }\n        }\n        return (arg);\n    }\n\n    private String getBooleanValue(String arg) {\n        if (hasEquals) {\n            arg \u003d arg.replaceFirst(\"[^\u003d]*\u003d\", \"\");\n            if (arg.equalsIgnoreCase(\"true\") || arg.equalsIgnoreCase(\"yes\"))\n                return (\"true\");\n            else\n                return (\"false\");\n        } else {\n            return (\"true\");\n        }\n    }\n\n    /**\n     * \tMake an Object of the correct type for the field, using a String\n     * \tversion of the value to create it.\n     *\n     * \t@param\ttype\ta String representing the base (or String) type\n     * \t@param\tval\tthe value\n     * \t@return\t\tan Object of the correct type and value\n     */\n    private Object makeObject(String type, String val) {\n        if (type.equals(\"boolean\")) {\n            return (new Boolean(val));\n        }\n        if (type.equals(\"byte\")) {\n            return (new Byte(val));\n        }\n        if (type.equals(\"short\")) {\n            return (new Short(val));\n        }\n        if (type.equals(\"int\")) {\n            return (new Integer(val));\n        }\n        if (type.equals(\"float\")) {\n            return (new Float(val));\n        }\n        if (type.equals(\"double\")) {\n            return (new Double(val));\n        }\n        if (type.equals(\"long\")) {\n            return (new Long(val));\n        }\n        if (type.equals(\"java.lang.String\")) {\n            return (val);\n        }\n        if (type.equals(\"char\")) {\n            return (new Character(val.charAt(0)));\n        }\n        return (null);\n    }\n\n    private String getEqualsValue(String arg) {\n        if (arg.indexOf(\"\u003d\") \u003d\u003d -1) {\n            throw (new IllegalArgumentException(\"\u0027\" + arg + \"\u0027 requires \u0027\u003dVALUE\u0027\"));\n        } else {\n            return (arg.replaceFirst(\"[^\u003d]*\u003d\", \"\"));\n        }\n    }\n\n    /**\n     * \tParse a command line.\n     *\n     * \t@param\targs\tthe arguments to be parsed\n     */\n    public void parse(String[] args) {\n        for (int i \u003d 0; i \u003c args.length; i++) {\n            if (!args[i].startsWith(\"-\")) {\n                parseAdditional(args, i);\n                return;\n            }\n            doubleDashes \u003d args[i].startsWith(\"--\");\n            hasEquals \u003d args[i].indexOf(\"\u003d\") !\u003d -1;\n            String key \u003d getKey(args[i]);\n            Field field \u003d getField(key);\n            if (field \u003d\u003d null) {\n                throw (new IllegalArgumentException(\"No such option: \\\"\" + key + \"\\\"\"));\n            }\n            Class type \u003d field.getType();\n            String name \u003d type.getName();\n            if (type.isArray())\n                name \u003d type.getComponentType().getName();\n            String value \u003d null;\n            if (name.equals(\"boolean\"))\n                value \u003d getBooleanValue(args[i]);\n            else if (doubleDashes || hasEquals)\n                value \u003d getEqualsValue(args[i]);\n            else\n                value \u003d args[++i];\n            Object o \u003d makeObject(name, value);\n            if (o \u003d\u003d null)\n                continue;\n            if (type.isArray())\n                o \u003d addToArray(field, o);\n            setObject(field, o);\n        }\n    }\n\n    /**\n     * Get a boolean value from the object after parsing.\n     */\n    public boolean getBoolean(String key) {\n        return (((Boolean) getValue(key)).booleanValue());\n    }\n\n    /**\n     * Get a byte value from the object after parsing.\n     */\n    public byte getByte(String key) {\n        return (((Byte) getValue(key)).byteValue());\n    }\n\n    /**\n     * Get a character value from the object after parsing.\n     */\n    public char getChar(String key) {\n        return (((Character) getValue(key)).charValue());\n    }\n\n    /**\n     * Get a short value from the object after parsing.\n     */\n    public short getShort(String key) {\n        return (((Short) getValue(key)).shortValue());\n    }\n\n    /**\n     * Get an integer value from the object after parsing.\n     */\n    public int getInt(String key) {\n        return (((Integer) getValue(key)).intValue());\n    }\n\n    /**\n     * Get a float value from the object after parsing.\n     */\n    public float getFloat(String key) {\n        return (((Float) getValue(key)).floatValue());\n    }\n\n    /**\n     * Get a double value from the object after parsing.\n     */\n    public double getDouble(String key) {\n        return (((Double) getValue(key)).doubleValue());\n    }\n\n    /**\n     * Get a long value from the object after parsing.\n     */\n    public long getLong(String key) {\n        return (((Long) getValue(key)).longValue());\n    }\n\n    /**\n     * Get a String from the object after parsing.\n     */\n    public String getString(String key) {\n        return ((String) getValue(key));\n    }\n\n    /**\n     * Get an array of bytes from the object after parsing.\n     */\n    public byte[] getBytes(String key) {\n        return ((byte[]) getValue(key));\n    }\n\n    /**\n     * Get an array of characaters from the object after parsing.\n     */\n    public char[] getChars(String key) {\n        return ((char[]) getValue(key));\n    }\n\n    /**\n     * Get an array of shorts from the object after parsing.\n     */\n    public short[] getShorts(String key) {\n        return ((short[]) getValue(key));\n    }\n\n    /**\n     * Get an array of integers from the object after parsing.\n     */\n    public int[] getInts(String key) {\n        return ((int[]) getValue(key));\n    }\n\n    /**\n     * Get an array of floats from the object after parsing.\n     */\n    public float[] getFloats(String key) {\n        return ((float[]) getValue(key));\n    }\n\n    /**\n     * Get an array of doubles from the object after parsing.\n     */\n    public double[] getDoubles(String key) {\n        return ((double[]) getValue(key));\n    }\n\n    /**\n     * Get an array of longs from the object after parsing.\n     */\n    public long[] getLongs(String key) {\n        return ((long[]) getValue(key));\n    }\n\n    /**\n     * Get an array of Strings from the object after parsing.\n     */\n    public String[] getStrings(String key) {\n        return ((String[]) getValue(key));\n    }\n\n    public static void main(String[] args) {\n        // cheesy, i know...\n        if (args.length \u003d\u003d 1 \u0026\u0026 args[0].equalsIgnoreCase(\"--version\")) {\n            System.out.println(\"1.3.4\");\n        }\n    }\n}\n",
    "package": "edu.mscd.cs.jclo",
    "classname": "JCLO",
    "id": "/EvoSuiteBenchmark/original/94_jclo/src/main/java/edu/mscd/cs/jclo/JCLO_0Test.java",
    "test_prompt": "// JCLO_0Test.java\npackage edu.mscd.cs.jclo;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Modifier;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JCLO}.\n* It contains ten unit test cases for the {@link JCLO#getValue(String)} method.\n*/\nclass JCLO_0Test {",
    "method_signature": "getValue(String)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// JCLO.java\npackage edu.mscd.cs.jclo;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Modifier;\n\n/**\n * This class is used to parse command-line arguments based on a the\n * variables with an object.  Each variable in the class specifies a\n * command-line argument that can be accepted; the name of the variable\n * becomes the name of the command-line argument.  As Java does not allow\n * dashes \u0027-\u0027 in variables, use two underscores \u0027__\u0027 if you want a dash in\n * an argument.  Also, if you want to have a numeric argument (e.g.: \u0027-1\u0027),\n * start the variable name with a single underscore.  JCLO uses reflection\n * to determine the type of each variable in the passed object and sets the\n * values in the object passed to it via parsing the command line.  If you\n * include a String array named \"additional\", all non-dashed arguments will\n * be placed in it.\n *\n * @author\t\tSteve Beaty (beatys@mscd.edu) @version\t$Id:\n * JCLO.java,v 1.5 2007/11/01 16:43:12 beaty Exp beaty $\n */\npublic class JCLO {\n\n    private Field[] fields;\n\n    private Object object;\n\n    private boolean doubleDashes;\n\n    private boolean hasEquals;\n\n    private String prefix \u003d \"\";\n\n    private String[][] aliases;\n\n    /**\n     * \tA constructor that takes the Object that contains the variables\n     * \tacceptable on a command line.  Call parse (String) to do the actual\n     * \tparsing.\n     *\n     * \t@param\tobject\twhere the variables/arguments are\n     */\n    public JCLO(Object object) {\n        this((String) null, object, null);\n    }\n\n    public JCLO(Object object, String[][] aliases) {\n        this((String) null, object, aliases);\n    }\n\n    public JCLO(String prefix, Object object) {\n        this(prefix, object, null);\n    }\n\n    /**\n     * \tA constructor that takes an Object, a prefix, and a boolean that\n     * \tspecifies whether to accept single or double dashes; call parse\n     * \t(String) to do the actual parsing.\n     *\n     * \t@param\tobject\twhere the variables/arguments are\n     * \t@param\tprefix\tthe String CLO\u0027s start with, if any\n     */\n    public JCLO(String prefix, Object object, String[][] aliases) {\n        this.object \u003d object;\n        this.prefix \u003d prefix;\n        this.aliases \u003d aliases;\n        fields \u003d object.getClass().getDeclaredFields();\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            fields[i].setAccessible(true);\n        }\n    }\n\n    /**\n     * \tJust a simple method to put the try/catch in one place.\n     *\n     * \t@param\tf\tthe Field to get the value of\n     * \t@return\t\tthe Object with the value\n     */\n    private Object getObject(Field f) {\n        try {\n            return (f.get(object));\n        } catch (java.lang.IllegalAccessException iae) {\n            iae.printStackTrace();\n            System.exit(1);\n        }\n        return (null);\n    }\n\n    private Field getField(String key) {\n        Field f \u003d null;\n        if (prefix !\u003d null)\n            key \u003d prefix + key;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            String name \u003d fields[i].getName();\n            if (name.equals(key))\n                return (fields[i]);\n        }\n        return (null);\n    }\n\n    /**\n     * \tGet the current value of the variable in the object\n     *\n     * \t@param\tkey\tthe variable name\n     * \t@return\t\tan Object with the value\n     */\n    public Object getValue(String key) {\n        Field f \u003d getField(key);\n        if (f \u003d\u003d null) {\n            System.out.println(\"Field not found: \" + key);\n            return (null);\n        }\n        return (getObject(f));\n    }\n\n    /**\n     * \tJust a simple method to put the try/catch in one place.\n     *\n     * \t@param\tf\tthe Field to set the value of\n     * \t@param\to\tthe Object with the value\n     */\n    private void setObject(Field f, Object o) {\n        try {\n            f.set(object, o);\n        } catch (java.lang.IllegalAccessException iae) {\n            iae.printStackTrace();\n        }\n    }\n\n    private String getArrayType(Class type) {\n        return (type.getComponentType().toString().replaceFirst(\"class.*\\\\.\", \"\"));\n    }\n\n    /**\n     * \tAn external representation of the object\n     *\n     * \t@return\t\ta formatted version of this object\n     */\n    public String toString() {\n        String r \u003d \"\";\n        boolean first \u003d true;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            Field field \u003d fields[i];\n            String key \u003d field.getName();\n            Class type \u003d field.getType();\n            Object object \u003d getObject(field);\n            if (!first)\n                r +\u003d \"\\n\";\n            first \u003d false;\n            if (type.isArray()) {\n                r +\u003d getArrayType(type) + \"[]\" + \": \" + key + \" \u003d \";\n                r +\u003d java.util.Arrays.toString((Object[]) object);\n            } else {\n                r +\u003d type.toString().replaceFirst(\"class java.lang.\", \"\") + \": \" + key + \" \u003d \" + object;\n            }\n        }\n        return (r);\n    }\n\n    private String getUsageType(Class type) {\n        if (type.getName().equals(\"boolean\")) {\n            return (doubleDashes ? \"[\u003dboolean]\" : \"\");\n        } else if (type.isArray()) {\n            return ((doubleDashes ? \"\u003d\" : \" \") + getArrayType(type) + \"...\");\n        } else {\n            return ((doubleDashes ? \"\u003d\" : \" \") + type.getName().replaceFirst(\"java.lang.\", \"\"));\n        }\n    }\n\n    /**\n     *  Create and usage message for the acceptable command line variables.\n     *\n     * \t@return\t\ta String that specifies acceptable options\n     */\n    public String usage() {\n        boolean additional \u003d false;\n        String[] a \u003d new String[fields.length];\n        int count \u003d 0;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            Field field \u003d fields[i];\n            String key \u003d field.getName();\n            Class type \u003d field.getType();\n            if (key.equals(\"additional\"))\n                continue;\n            if (prefix !\u003d null) {\n                if (!key.startsWith(prefix))\n                    continue;\n                else\n                    key \u003d key.replaceFirst(\"^\" + prefix, \"\");\n            }\n            if (Modifier.isFinal(field.getModifiers()))\n                continue;\n            key \u003d key.replaceFirst(\"^_([0-9])\", \"$1\");\n            key \u003d key.replaceAll(\"__\", \"-\");\n            key \u003d key.replaceAll(\"_\\\\$\", \".\");\n            a[count++] \u003d (doubleDashes ? \"--\" : \"-\") + key + getUsageType(type) + \"\\n\";\n        }\n        String r \u003d \"\";\n        java.util.Arrays.sort(a, 0, count);\n        for (int i \u003d 0; i \u003c a.length; i++) if (a[i] !\u003d null)\n            r +\u003d a[i];\n        return (r);\n    }\n\n    private void parseAdditional(String[] args, int i) {\n        int number \u003d args.length - i;\n        String[] add \u003d new String[number];\n        for (int j \u003d 0; j \u003c number; j++, i++) {\n            add[j] \u003d args[i];\n        }\n        Field f \u003d getField(\"additional\");\n        if (f !\u003d null) {\n            setObject(f, add);\n        } else {\n            System.err.println(\"No varible \u0027additional\u0027 found\");\n        }\n    }\n\n    /**\n     * \tAdd to object o to the end of the array contained in field and\n     * \treturn the resulting array.\n     *\n     * \t@param\tfield\tthe field in the object\n     * \t@param\to\tthe new object to be placed at the end\n     * \t@return\t\ta formatted version of this object\n     */\n    private Object addToArray(Field field, Object o) {\n        Object ret;\n        Object orig \u003d getObject(field);\n        Class componentType \u003d field.getType().getComponentType();\n        if (// the array is empty\n        orig \u003d\u003d null) {\n            ret \u003d Array.newInstance(componentType, 1);\n            Array.set(ret, 0, o);\n        } else {\n            int length \u003d Array.getLength(orig);\n            ret \u003d Array.newInstance(componentType, length + 1);\n            int j;\n            for (j \u003d 0; j \u003c length; j++) {\n                Array.set(ret, j, Array.get(orig, j));\n            }\n            Array.set(ret, j, o);\n        }\n        return (ret);\n    }\n\n    private String getKey(String arg) {\n        if (hasEquals)\n            arg \u003d arg.replaceFirst(\"\u003d.*\", \"\");\n        if (doubleDashes)\n            arg \u003d arg.substring(2);\n        else\n            arg \u003d arg.substring(1);\n        // variables can\u0027t start with a number and can\u0027t have a dash\n        arg \u003d arg.replaceAll(\"^([0-9])\", \"_$1\");\n        arg \u003d arg.replaceAll(\"-\", \"__\");\n        arg \u003d arg.replaceAll(\"\\\\.\", \"_\\\\$\");\n        if (aliases !\u003d null) {\n            for (int i \u003d 0; i \u003c aliases.length; i++) {\n                if (aliases[i][0].equals(arg))\n                    arg \u003d aliases[i][1];\n            }\n        }\n        return (arg);\n    }\n\n    private String getBooleanValue(String arg) {\n        if (hasEquals) {\n            arg \u003d arg.replaceFirst(\"[^\u003d]*\u003d\", \"\");\n            if (arg.equalsIgnoreCase(\"true\") || arg.equalsIgnoreCase(\"yes\"))\n                return (\"true\");\n            else\n                return (\"false\");\n        } else {\n            return (\"true\");\n        }\n    }\n\n    /**\n     * \tMake an Object of the correct type for the field, using a String\n     * \tversion of the value to create it.\n     *\n     * \t@param\ttype\ta String representing the base (or String) type\n     * \t@param\tval\tthe value\n     * \t@return\t\tan Object of the correct type and value\n     */\n    private Object makeObject(String type, String val) {\n        if (type.equals(\"boolean\")) {\n            return (new Boolean(val));\n        }\n        if (type.equals(\"byte\")) {\n            return (new Byte(val));\n        }\n        if (type.equals(\"short\")) {\n            return (new Short(val));\n        }\n        if (type.equals(\"int\")) {\n            return (new Integer(val));\n        }\n        if (type.equals(\"float\")) {\n            return (new Float(val));\n        }\n        if (type.equals(\"double\")) {\n            return (new Double(val));\n        }\n        if (type.equals(\"long\")) {\n            return (new Long(val));\n        }\n        if (type.equals(\"java.lang.String\")) {\n            return (val);\n        }\n        if (type.equals(\"char\")) {\n            return (new Character(val.charAt(0)));\n        }\n        return (null);\n    }\n\n    private String getEqualsValue(String arg) {\n        if (arg.indexOf(\"\u003d\") \u003d\u003d -1) {\n            throw (new IllegalArgumentException(\"\u0027\" + arg + \"\u0027 requires \u0027\u003dVALUE\u0027\"));\n        } else {\n            return (arg.replaceFirst(\"[^\u003d]*\u003d\", \"\"));\n        }\n    }\n\n    /**\n     * \tParse a command line.\n     *\n     * \t@param\targs\tthe arguments to be parsed\n     */\n    public void parse(String[] args) {\n        for (int i \u003d 0; i \u003c args.length; i++) {\n            if (!args[i].startsWith(\"-\")) {\n                parseAdditional(args, i);\n                return;\n            }\n            doubleDashes \u003d args[i].startsWith(\"--\");\n            hasEquals \u003d args[i].indexOf(\"\u003d\") !\u003d -1;\n            String key \u003d getKey(args[i]);\n            Field field \u003d getField(key);\n            if (field \u003d\u003d null) {\n                throw (new IllegalArgumentException(\"No such option: \\\"\" + key + \"\\\"\"));\n            }\n            Class type \u003d field.getType();\n            String name \u003d type.getName();\n            if (type.isArray())\n                name \u003d type.getComponentType().getName();\n            String value \u003d null;\n            if (name.equals(\"boolean\"))\n                value \u003d getBooleanValue(args[i]);\n            else if (doubleDashes || hasEquals)\n                value \u003d getEqualsValue(args[i]);\n            else\n                value \u003d args[++i];\n            Object o \u003d makeObject(name, value);\n            if (o \u003d\u003d null)\n                continue;\n            if (type.isArray())\n                o \u003d addToArray(field, o);\n            setObject(field, o);\n        }\n    }\n\n    /**\n     * Get a boolean value from the object after parsing.\n     */\n    public boolean getBoolean(String key) {\n        return (((Boolean) getValue(key)).booleanValue());\n    }\n\n    /**\n     * Get a byte value from the object after parsing.\n     */\n    public byte getByte(String key) {\n        return (((Byte) getValue(key)).byteValue());\n    }\n\n    /**\n     * Get a character value from the object after parsing.\n     */\n    public char getChar(String key) {\n        return (((Character) getValue(key)).charValue());\n    }\n\n    /**\n     * Get a short value from the object after parsing.\n     */\n    public short getShort(String key) {\n        return (((Short) getValue(key)).shortValue());\n    }\n\n    /**\n     * Get an integer value from the object after parsing.\n     */\n    public int getInt(String key) {\n        return (((Integer) getValue(key)).intValue());\n    }\n\n    /**\n     * Get a float value from the object after parsing.\n     */\n    public float getFloat(String key) {\n        return (((Float) getValue(key)).floatValue());\n    }\n\n    /**\n     * Get a double value from the object after parsing.\n     */\n    public double getDouble(String key) {\n        return (((Double) getValue(key)).doubleValue());\n    }\n\n    /**\n     * Get a long value from the object after parsing.\n     */\n    public long getLong(String key) {\n        return (((Long) getValue(key)).longValue());\n    }\n\n    /**\n     * Get a String from the object after parsing.\n     */\n    public String getString(String key) {\n        return ((String) getValue(key));\n    }\n\n    /**\n     * Get an array of bytes from the object after parsing.\n     */\n    public byte[] getBytes(String key) {\n        return ((byte[]) getValue(key));\n    }\n\n    /**\n     * Get an array of characaters from the object after parsing.\n     */\n    public char[] getChars(String key) {\n        return ((char[]) getValue(key));\n    }\n\n    /**\n     * Get an array of shorts from the object after parsing.\n     */\n    public short[] getShorts(String key) {\n        return ((short[]) getValue(key));\n    }\n\n    /**\n     * Get an array of integers from the object after parsing.\n     */\n    public int[] getInts(String key) {\n        return ((int[]) getValue(key));\n    }\n\n    /**\n     * Get an array of floats from the object after parsing.\n     */\n    public float[] getFloats(String key) {\n        return ((float[]) getValue(key));\n    }\n\n    /**\n     * Get an array of doubles from the object after parsing.\n     */\n    public double[] getDoubles(String key) {\n        return ((double[]) getValue(key));\n    }\n\n    /**\n     * Get an array of longs from the object after parsing.\n     */\n    public long[] getLongs(String key) {\n        return ((long[]) getValue(key));\n    }\n\n    /**\n     * Get an array of Strings from the object after parsing.\n     */\n    public String[] getStrings(String key) {\n        return ((String[]) getValue(key));\n    }\n\n    public static void main(String[] args) {\n        // cheesy, i know...\n        if (args.length \u003d\u003d 1 \u0026\u0026 args[0].equalsIgnoreCase(\"--version\")) {\n            System.out.println(\"1.3.4\");\n        }\n    }\n}\n",
    "package": "edu.mscd.cs.jclo",
    "classname": "JCLO",
    "id": "/EvoSuiteBenchmark/original/94_jclo/src/main/java/edu/mscd/cs/jclo/JCLO_1Test.java",
    "test_prompt": "// JCLO_1Test.java\npackage edu.mscd.cs.jclo;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Modifier;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JCLO}.\n* It contains ten unit test cases for the {@link JCLO#usage()} method.\n*/\nclass JCLO_1Test {",
    "method_signature": "usage()",
    "suffix": "1"
  }
]