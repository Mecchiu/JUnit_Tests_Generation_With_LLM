ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6wosm53EUyKVtywahYlNQryeNccbJ,/EvoSuiteBenchmark/original/19_jmca/src/main/java/com/soops/CEN4010/JMCA/ASTNode_0Test.java,133.65792083740234,length,"// ASTNode.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;

/**
 * <p>Title: Group 2 Project </p>
 *
 * <p>Class: CEN4010 Fall 2005</p>
 *
 * <p>Description: Data Structure for ASTree Node</p>
 *
 * <p>Instructor Dr. Stoeklin</p>
 *
 * @author Group 2
 */
public class ASTNode implements Comparable, java.io.Serializable {

    /**
     * data of the node
     */
    String type = null;

    String identity = null;

    /**
     * implements Comparable
     * @param node Object
     * @return int values 0 for same and 1 for different
     */
    public int compareTo(Object node) {
        if (!type.equals(((ASTNode) node).getType()) || !identity.equals(((ASTNode) node).getIdentity())) {
            return 1;
        }
        for (int i = 0; i < list.size(); ++i) {
            try {
                if (list.get(i).compareTo(((ASTNode) node).list.get(i)) == 1) {
                    return 1;
                }
            } catch (IndexOutOfBoundsException ne) {
                return 1;
            } catch (NullPointerException np) {
                return 1;
            }
        }
        return 0;
    }

    /**
     * children of the node
     */
    //IC - Added the <Object> tags to get rid of warnings...
    //http://java.sun.com/developer/JDCTechTips/2005/tt0315.html
    // SS - changed <Object> to <ASTNode> and removed the casts
    java.util.ArrayList<ASTNode> list = new java.util.ArrayList<ASTNode>();

    /**
     * parent of the node
     */
    ASTNode parent = null;

    /**
     * add child to node
     * @param node ASTNode
     */
    public void addChild(ASTNode node) {
        list.add(node);
    }

    /**
     * default constructor
     */
    public ASTNode() {
    }

    /**
     * construct a  node and set its parent
     * @param p ASTNode
     */
    public ASTNode(ASTNode p) {
        parent = p;
    }

    /**
     * construct a node and set data types and parent
     * @param type String
     * @param identity String
     * @param p ASTNode
     */
    public ASTNode(String type, String identity, ASTNode p) {
        parent = p;
        setType(type);
        setIdentity(identity);
    }

    /**
     * get the parent node
     * @return ASTNode
     */
    public ASTNode getParent() {
        return parent;
    }

    /**
     * set the data element type
     * @param t String
     */
    public void setType(String t) {
        type = t;
    }

    /**
     * set the data type identity
     * @param id String
     */
    public void setIdentity(String id) {
        identity = id;
    }

    /**
     * get the data element type
     * @return String
     */
    public String getType() {
        return type;
    }

    /**
     * get the data element identity
     * @return String
     */
    public String getIdentity() {
        return identity;
    }

    /**
     * concat type and identity
     * @return String
     */
    public String toString() {
        String returnString = type + "" :: "" + identity;
        return returnString;
    }

    /**
     * display this node and all its children recursively
     * @param wtr Writer
     */
    public void display(Writer wtr) {
        try {
            wtr.write(toString());
        } catch (IOException ie) {
            System.err.println(ie.getMessage());
        }
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            try {
                wtr.write(""\n"");
            } catch (IOException ie) {
                System.err.println(ie.getMessage());
            }
            list.get(i).display(wtr);
        }
    }

    /**
     *  reads the node in from a file
     * @param filename String
     * @return ASTNode
     */
    public static ASTNode getTree(String filename) {
        ObjectInputStream rdr = null;
        ASTNode rootNode = null;
        try {
            FileInputStream flstrm = new FileInputStream(new File(filename));
            rdr = new ObjectInputStream(flstrm);
            rootNode = (ASTNode) rdr.readObject();
            rdr.close();
        } catch (java.io.IOException ie) {
        } finally {
            return rootNode;
        }
    }

    /**
     * save the node and its children to disk
     * @param filename String
     */
    public void dump(String filename) {
        ObjectOutputStream wtr = null;
        try {
            FileOutputStream flstrm = new FileOutputStream(new File(filename));
            wtr = new ObjectOutputStream(flstrm);
            wtr.writeObject(this);
            wtr.close();
        } catch (java.io.IOException ie) {
        }
    }

    /**
     * add this node and recursively all its children to a swing tree structure <br>
     * used to construct a JTree with the ASTree
     * @return DefaultMutableTreeNode
     */
    public DefaultMutableTreeNode createTree() {
        javax.swing.tree.DefaultMutableTreeNode node = new DefaultMutableTreeNode(toString());
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            node.add(list.get(i).createTree());
        }
        return node;
    }
}
","// ASTNode_0Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains ten unit test cases for the {@link ASTNode#compareTo(Object)} method.
*/
class ASTNode_0Test {","// ASTNode_0Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains ten unit test cases for the {@link ASTNode#compareTo(Object)} method.
*/
class ASTNode_0Test {

	/**
	* Test case 1 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type and identity.
	*/
	@Test
	void testCompareTo_1() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity"");
		assertEquals(0, node1.compareTo(node2));
	}
	
	/**
	* Test case 2 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type but different identity.
	*/
	@Test
	void testCompareTo_2() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity2"");
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 3 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same identity but different type.
	*/
	@Test
	void testCompareTo_3() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type2"");
		node2.setIdentity(""identity"");
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 4 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have different type and identity.
	*/
	@Test
	void testCompareTo_4() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type2"");
		node2.setIdentity(""identity2"");
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 5 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type and identity, but the first node has a child.
	*/
	@Test
	void testCompareTo_5() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		ASTNode node3 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity"");
		node3.setType(""type"");
		node3.setIdentity(""identity"");
		node1.addChild(node3);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 6 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type and identity, but the second node has a child.
	*/
	@Test
	void testCompareTo_6() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		ASTNode node3 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity"");
		node3.setType(""type"");
		node3.setIdentity(""identity"");
		node2.addChild(node3);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 7 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type and identity, but the first node has a child with different type and identity.
	*/
	@Test
	void testCompareTo_7() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		ASTNode node3 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity"");
		node3.setType(""type2"");
		node3.setIdentity(""identity2"");
		node1.addChild(node3);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 8 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type and identity, but the second node has a child with different type and identity.
	*/
	@Test
	void testCompareTo_8() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		ASTNode node3 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity"");
		node3.setType(""type2"");
		node3.setIdentity(""identity2"");
		node2.addChild(node3);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 9 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type and identity, but the first node has a child with different type and the second node has a child with different identity.
	*/
	@Test
	void testCompareTo_9() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		ASTNode node3 = new ASTNode();
		ASTNode node4 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity"");
		node3.setType(""type2"");
		node3.setIdentity(""identity"");
		node4.setType(""type"");
		node4.setIdentity(""identity2"");
		node1.addChild(node3);
		node2.addChild(node4);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 10 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type and identity, but the second node has a child with different type and the first node has a child with different identity.
	*/
	@Test
	void testCompareTo_10() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		ASTNode node3 = new ASTNode();
		ASTNode node4 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity"");
		node3.setType(""type2"");
		node3.setIdentity(""identity"");
		node4.setType(""type"");
		node4.setIdentity(""identity2"");
		node1.addChild(node4);
		node2.addChild(node3);
		assertEquals(1, node1.compareTo(node2));
	}
}

// ASTNode_1Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains ten unit test cases for the {@link ASTNode#compareTo(Object)} method.
*/
class ASTNode_1Test {
		
	/**
	* Test case 1 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type and identity.
	*/
	@Test
	void testCompareTo_1() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity"");
		assertEquals(0, node1.compareTo(node2));
	}
	
	/**
	* Test case 2 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type but different identity.
	*/
	@Test
	void testCompareTo_2() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity2"");
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 3 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same identity but different type.
	*/
	@Test
	void testCompareTo_3() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type2"");
		node2.setIdentity(""identity"");
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 4 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have different type and identity.
	*/
	@Test
	void testCompareTo_4() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type2"");
		node2.setIdentity(""identity2"");
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 5 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type and identity, but the first node has a child.
	*/
	@Test
	void testCompareTo_5() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		ASTNode node3 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity"");
		node3.setType(""type"");
		node3.setIdentity(""identity"");
		node1.addChild(node3);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 6 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type and identity, but the second node has a child.
	*/
	@Test
	void testCompareTo_6() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		ASTNode node3 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity"");
		node3.setType(""type"");
		node3.setIdentity(""identity"");
		node2.addChild(node3);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 7 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type and identity, but the first node has a child with different type and identity.
	*/
	@Test
	void testCompareTo_7() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		ASTNode node3 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity"");
		node3.setType(""type2"");
		node3.setIdentity(""identity2"");
		node1.addChild(node3);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 8 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type and identity, but the second node has a child with different type and identity.
	*/
	@Test
	void testCompareTo_8() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		ASTNode node3 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity"");
		node3.setType(""type2"");
		node3.setIdentity(""identity2"");
		node2.addChild(node3);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 9 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type and identity, but the first node has a child with different type and the second node has a child with different identity.
	*/
	@Test
	void testCompareTo_9() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		ASTNode node3 = new ASTNode();
		ASTNode node4 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity"");
		node3.setType(""type2"");
		node3.setIdentity(""identity"");
		node4.setType(""type"");
		node4.setIdentity(""identity2"");
		node1.addChild(node3);
		node2.addChild(node4);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 10 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type and identity, but the second node has a child with different type and the first node has a child with different identity.
	*/
	@Test
	void testCompareTo_10() {
		ASTNode node1 = new ASTNode"
cmpl-6wouvTTXDDE8tnMW98L0tDZYIijDJ,/EvoSuiteBenchmark/original/19_jmca/src/main/java/com/soops/CEN4010/JMCA/ASTNode_1Test.java,90.14105415344238,length,"// ASTNode.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;

/**
 * <p>Title: Group 2 Project </p>
 *
 * <p>Class: CEN4010 Fall 2005</p>
 *
 * <p>Description: Data Structure for ASTree Node</p>
 *
 * <p>Instructor Dr. Stoeklin</p>
 *
 * @author Group 2
 */
public class ASTNode implements Comparable, java.io.Serializable {

    /**
     * data of the node
     */
    String type = null;

    String identity = null;

    /**
     * implements Comparable
     * @param node Object
     * @return int values 0 for same and 1 for different
     */
    public int compareTo(Object node) {
        if (!type.equals(((ASTNode) node).getType()) || !identity.equals(((ASTNode) node).getIdentity())) {
            return 1;
        }
        for (int i = 0; i < list.size(); ++i) {
            try {
                if (list.get(i).compareTo(((ASTNode) node).list.get(i)) == 1) {
                    return 1;
                }
            } catch (IndexOutOfBoundsException ne) {
                return 1;
            } catch (NullPointerException np) {
                return 1;
            }
        }
        return 0;
    }

    /**
     * children of the node
     */
    //IC - Added the <Object> tags to get rid of warnings...
    //http://java.sun.com/developer/JDCTechTips/2005/tt0315.html
    // SS - changed <Object> to <ASTNode> and removed the casts
    java.util.ArrayList<ASTNode> list = new java.util.ArrayList<ASTNode>();

    /**
     * parent of the node
     */
    ASTNode parent = null;

    /**
     * add child to node
     * @param node ASTNode
     */
    public void addChild(ASTNode node) {
        list.add(node);
    }

    /**
     * default constructor
     */
    public ASTNode() {
    }

    /**
     * construct a  node and set its parent
     * @param p ASTNode
     */
    public ASTNode(ASTNode p) {
        parent = p;
    }

    /**
     * construct a node and set data types and parent
     * @param type String
     * @param identity String
     * @param p ASTNode
     */
    public ASTNode(String type, String identity, ASTNode p) {
        parent = p;
        setType(type);
        setIdentity(identity);
    }

    /**
     * get the parent node
     * @return ASTNode
     */
    public ASTNode getParent() {
        return parent;
    }

    /**
     * set the data element type
     * @param t String
     */
    public void setType(String t) {
        type = t;
    }

    /**
     * set the data type identity
     * @param id String
     */
    public void setIdentity(String id) {
        identity = id;
    }

    /**
     * get the data element type
     * @return String
     */
    public String getType() {
        return type;
    }

    /**
     * get the data element identity
     * @return String
     */
    public String getIdentity() {
        return identity;
    }

    /**
     * concat type and identity
     * @return String
     */
    public String toString() {
        String returnString = type + "" :: "" + identity;
        return returnString;
    }

    /**
     * display this node and all its children recursively
     * @param wtr Writer
     */
    public void display(Writer wtr) {
        try {
            wtr.write(toString());
        } catch (IOException ie) {
            System.err.println(ie.getMessage());
        }
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            try {
                wtr.write(""\n"");
            } catch (IOException ie) {
                System.err.println(ie.getMessage());
            }
            list.get(i).display(wtr);
        }
    }

    /**
     *  reads the node in from a file
     * @param filename String
     * @return ASTNode
     */
    public static ASTNode getTree(String filename) {
        ObjectInputStream rdr = null;
        ASTNode rootNode = null;
        try {
            FileInputStream flstrm = new FileInputStream(new File(filename));
            rdr = new ObjectInputStream(flstrm);
            rootNode = (ASTNode) rdr.readObject();
            rdr.close();
        } catch (java.io.IOException ie) {
        } finally {
            return rootNode;
        }
    }

    /**
     * save the node and its children to disk
     * @param filename String
     */
    public void dump(String filename) {
        ObjectOutputStream wtr = null;
        try {
            FileOutputStream flstrm = new FileOutputStream(new File(filename));
            wtr = new ObjectOutputStream(flstrm);
            wtr.writeObject(this);
            wtr.close();
        } catch (java.io.IOException ie) {
        }
    }

    /**
     * add this node and recursively all its children to a swing tree structure <br>
     * used to construct a JTree with the ASTree
     * @return DefaultMutableTreeNode
     */
    public DefaultMutableTreeNode createTree() {
        javax.swing.tree.DefaultMutableTreeNode node = new DefaultMutableTreeNode(toString());
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            node.add(list.get(i).createTree());
        }
        return node;
    }
}
","// ASTNode_1Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains ten unit test cases for the {@link ASTNode#getTree(String)} method.
*/
class ASTNode_1Test {","// ASTNode_1Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains ten unit test cases for the {@link ASTNode#getTree(String)} method.
*/
class ASTNode_1Test {

	/**
	* Test case 1 for {@link ASTNode#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_1() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		assertNotNull(rootNode);
	}
	
	/**
	* Test case 2 for {@link ASTNode#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_2() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		assertNotNull(rootNode);
	}
	
	/**
	* Test case 3 for {@link ASTNode#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_3() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		assertNotNull(rootNode);
	}
	
	/**
	* Test case 4 for {@link ASTNode#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_4() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		assertNotNull(rootNode);
	}
	
	/**
	* Test case 5 for {@link ASTNode#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_5() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		assertNotNull(rootNode);
	}
	
	/**
	* Test case 6 for {@link ASTNode#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_6() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		assertNotNull(rootNode);
	}
	
	/**
	* Test case 7 for {@link ASTNode#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_7() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		assertNotNull(rootNode);
	}
	
	/**
	* Test case 8 for {@link ASTNode#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_8() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		assertNotNull(rootNode);
	}
	
	/**
	* Test case 9 for {@link ASTNode#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_9() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		assertNotNull(rootNode);
	}
	
	/**
	* Test case 10 for {@link ASTNode#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_10() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		assertNotNull(rootNode);
	}
}

// ASTNode_2Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains ten unit test cases for the {@link ASTNode#dump(String)} method.
*/
class ASTNode_2Test {
		
	/**
	* Test case 1 for {@link ASTNode#dump(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testDump_1() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		rootNode.dump(""test.txt"");
	}
	
	/**
	* Test case 2 for {@link ASTNode#dump(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testDump_2() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		rootNode.dump(""test.txt"");
	}
	
	/**
	* Test case 3 for {@link ASTNode#dump(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testDump_3() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		rootNode.dump(""test.txt"");
	}
	
	/**
	* Test case 4 for {@link ASTNode#dump(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testDump_4() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		rootNode.dump(""test.txt"");
	}
	
	/**
	* Test case 5 for {@link ASTNode#dump(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testDump_5() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		rootNode.dump(""test.txt"");
	}
	
	/**
	* Test case 6 for {@link ASTNode#dump(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testDump_6() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		rootNode.dump(""test.txt"");
	}
	
	/**
	* Test case 7 for {@link ASTNode#dump(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testDump_7() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		rootNode.dump(""test.txt"");
	}
	
	/**
	* Test case 8 for {@link ASTNode#dump(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testDump_8() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		rootNode.dump(""test.txt"");
	}
	
	/**
	* Test case 9 for {@link ASTNode#dump(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testDump_9() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		rootNode.dump(""test.txt"");
	}
	
	/**
	* Test case 10 for {@link ASTNode#dump(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testDump_10() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		rootNode.dump(""test.txt"");
	}
}

// ASTNode_3Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains ten unit test cases for the {@link ASTNode#createTree()} method.
*/
class ASTNode_3Test {
		
	/**
	* Test case 1 for {@link ASTNode#createTree()}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testCreateTree_1() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		DefaultMutableTreeNode tree = rootNode.createTree();
		assertNotNull(tree);
	}
	
	/**
	* Test case 2 for {@link ASTNode#createTree()}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testCreateTree_2() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		DefaultMutableTreeNode tree = rootNode.createTree();
		assertNotNull(tree);
	}
	
	/**
	* Test case 3 for {@link ASTNode#createTree()}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testCreateTree_3() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		DefaultMutableTreeNode tree = rootNode.createTree();
		assertNotNull(tree);
	}
	
	/**
	* Test case 4 for {@link ASTNode#createTree()}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testCreateTree_4() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		DefaultMutableTreeNode tree = rootNode.createTree();
		assertNotNull(tree);
	}
	
	/**
	* Test case 5 for {@link ASTNode#createTree()}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testCreateTree_5() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		DefaultMutableTreeNode tree = rootNode.createTree();
		assertNotNull(tree);
	}
	
	/**
	* Test case 6 for {@link ASTNode#createTree()}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testCreateTree_6() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		DefaultMutableTreeNode tree = rootNode.createTree();
		assertNotNull(tree);
	}
	
	/**
	* Test case 7 for {@link ASTNode#createTree()}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testCreateTree_7() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		DefaultMutableTreeNode tree = rootNode.createTree();
		assertNotNull(tree);
	}
	
	/**
	* Test case 8 for {@link ASTNode#createTree()}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testCreateTree_8() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		DefaultMutableTreeNode tree = rootNode.createTree();
		assertNotNull(tree);
	}
	
	/**
	* Test case 9 for {@link ASTNode#createTree()}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testCreateTree_9() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		DefaultMutableTreeNode tree = rootNode.createTree();
		assertNotNull(tree);
	}
	
	/**
	* Test case 10 for {@link ASTNode#createTree()}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testCreateTree_10() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		DefaultMutableTreeNode tree = rootNode.createTree();
		assertNotNull(tree);
	}
}

// ASTree.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;

/**
 * <p>Title: Group 2 Project </p>
 *
 * <p>Class: CEN4010 Fall 2005</p>
 *
 * <p>Description: Data Structure for ASTree</p>
 *
 * <p>Instructor Dr. Stoeklin</p>
 *
 * @author Group 2
 */
public class ASTree {

    /**
     * root node of the tree
     */
    ASTNode root = null;

    /**
     * default constructor
     */
    public ASTree() {
    }

    /**
     * construct a tree with a root node
     * @param root ASTNode
     */
    public ASTree(ASTNode root) {
        this.root = root;
    }

    /**
     * get the root node
     * @return ASTNode
     */
    public ASTNode getRoot() {
        return root;
    }

    /**
     * set the root node
     * @param root ASTNode
     */
    public void setRoot(ASTNode root) {
        this.root = root;
    }

    /**
     * display the tree
     * @param wtr Writer
     */
    public void display(Writer wtr) {
        root.display(wtr);
    }

    /**
     * save the tree to disk
     * @param filename String
     */
    public void dump(String filename) {
        root.dump(filename);
    }

    /**
     * read the tree from disk
     * @param filename String
     * @return ASTree
     */
    public static ASTree getTree(String filename) {
        ASTNode rootNode = ASTNode.getTree(filename);
        return new ASTree(rootNode);
    }

    /**
     * create a swing tree structure from the ASTree
     * @return DefaultMutableTreeNode
     */
    public DefaultMutableTreeNode createTree() {
        return root.createTree();
    }
}

// ASTree_1Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTree}.
* It contains ten unit test cases for the {@link ASTree#getTree(String)} method.
*/
class ASTree_1Test {
		
	/**
	* Test case 1 for {@link ASTree#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_1() {
		ASTree tree = ASTree.getTree(""test.txt"");
		assertNotNull(tree);
	}
	
	/**
	* Test case 2 for {@link ASTree#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_2() {
		ASTree tree = ASTree.getTree(""test.txt"");
		assertNotNull(tree);
	}
	
	/**
	* Test case 3 for {@link ASTree#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_3() {
		ASTree tree = ASTree.getTree(""test.txt"");
		assertNotNull(tree);
	}
	
	/**
	* Test case 4 for {@link ASTree#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_4() {
		ASTree tree = ASTree.getTree(""test.txt"");
		assertNotNull(tree);
	}
	
	/**
	* Test case 5 for {@link ASTree#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	"
cmpl-6wowNNFulWOI7E1ykzVHNuZji3Ixb,/EvoSuiteBenchmark/original/19_jmca/src/main/java/com/soops/CEN4010/JMCA/ASTNode_2Test.java,137.81757926940918,length,"// ASTNode.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;

/**
 * <p>Title: Group 2 Project </p>
 *
 * <p>Class: CEN4010 Fall 2005</p>
 *
 * <p>Description: Data Structure for ASTree Node</p>
 *
 * <p>Instructor Dr. Stoeklin</p>
 *
 * @author Group 2
 */
public class ASTNode implements Comparable, java.io.Serializable {

    /**
     * data of the node
     */
    String type = null;

    String identity = null;

    /**
     * implements Comparable
     * @param node Object
     * @return int values 0 for same and 1 for different
     */
    public int compareTo(Object node) {
        if (!type.equals(((ASTNode) node).getType()) || !identity.equals(((ASTNode) node).getIdentity())) {
            return 1;
        }
        for (int i = 0; i < list.size(); ++i) {
            try {
                if (list.get(i).compareTo(((ASTNode) node).list.get(i)) == 1) {
                    return 1;
                }
            } catch (IndexOutOfBoundsException ne) {
                return 1;
            } catch (NullPointerException np) {
                return 1;
            }
        }
        return 0;
    }

    /**
     * children of the node
     */
    //IC - Added the <Object> tags to get rid of warnings...
    //http://java.sun.com/developer/JDCTechTips/2005/tt0315.html
    // SS - changed <Object> to <ASTNode> and removed the casts
    java.util.ArrayList<ASTNode> list = new java.util.ArrayList<ASTNode>();

    /**
     * parent of the node
     */
    ASTNode parent = null;

    /**
     * add child to node
     * @param node ASTNode
     */
    public void addChild(ASTNode node) {
        list.add(node);
    }

    /**
     * default constructor
     */
    public ASTNode() {
    }

    /**
     * construct a  node and set its parent
     * @param p ASTNode
     */
    public ASTNode(ASTNode p) {
        parent = p;
    }

    /**
     * construct a node and set data types and parent
     * @param type String
     * @param identity String
     * @param p ASTNode
     */
    public ASTNode(String type, String identity, ASTNode p) {
        parent = p;
        setType(type);
        setIdentity(identity);
    }

    /**
     * get the parent node
     * @return ASTNode
     */
    public ASTNode getParent() {
        return parent;
    }

    /**
     * set the data element type
     * @param t String
     */
    public void setType(String t) {
        type = t;
    }

    /**
     * set the data type identity
     * @param id String
     */
    public void setIdentity(String id) {
        identity = id;
    }

    /**
     * get the data element type
     * @return String
     */
    public String getType() {
        return type;
    }

    /**
     * get the data element identity
     * @return String
     */
    public String getIdentity() {
        return identity;
    }

    /**
     * concat type and identity
     * @return String
     */
    public String toString() {
        String returnString = type + "" :: "" + identity;
        return returnString;
    }

    /**
     * display this node and all its children recursively
     * @param wtr Writer
     */
    public void display(Writer wtr) {
        try {
            wtr.write(toString());
        } catch (IOException ie) {
            System.err.println(ie.getMessage());
        }
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            try {
                wtr.write(""\n"");
            } catch (IOException ie) {
                System.err.println(ie.getMessage());
            }
            list.get(i).display(wtr);
        }
    }

    /**
     *  reads the node in from a file
     * @param filename String
     * @return ASTNode
     */
    public static ASTNode getTree(String filename) {
        ObjectInputStream rdr = null;
        ASTNode rootNode = null;
        try {
            FileInputStream flstrm = new FileInputStream(new File(filename));
            rdr = new ObjectInputStream(flstrm);
            rootNode = (ASTNode) rdr.readObject();
            rdr.close();
        } catch (java.io.IOException ie) {
        } finally {
            return rootNode;
        }
    }

    /**
     * save the node and its children to disk
     * @param filename String
     */
    public void dump(String filename) {
        ObjectOutputStream wtr = null;
        try {
            FileOutputStream flstrm = new FileOutputStream(new File(filename));
            wtr = new ObjectOutputStream(flstrm);
            wtr.writeObject(this);
            wtr.close();
        } catch (java.io.IOException ie) {
        }
    }

    /**
     * add this node and recursively all its children to a swing tree structure <br>
     * used to construct a JTree with the ASTree
     * @return DefaultMutableTreeNode
     */
    public DefaultMutableTreeNode createTree() {
        javax.swing.tree.DefaultMutableTreeNode node = new DefaultMutableTreeNode(toString());
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            node.add(list.get(i).createTree());
        }
        return node;
    }
}
","// ASTNode_2Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains ten unit test cases for the {@link ASTNode#createTree()} method.
*/
class ASTNode_2Test {","// ASTNode_2Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains ten unit test cases for the {@link ASTNode#createTree()} method.
*/
class ASTNode_2Test {

	/**
	* Test case 1 for {@link ASTNode#createTree()}.
	* It tests the method with a null ASTNode.
	*/
	@Test
	void testCreateTree1() {
		ASTNode node = null;
		DefaultMutableTreeNode tree = node.createTree();
		assertNull(tree);
	}
	
	/**
	* Test case 2 for {@link ASTNode#createTree()}.
	* It tests the method with an ASTNode with no children.
	*/
	@Test
	void testCreateTree2() {
		ASTNode node = new ASTNode();
		node.setType(""type"");
		node.setIdentity(""identity"");
		DefaultMutableTreeNode tree = node.createTree();
		assertEquals(""type :: identity"", tree.toString());
	}
	
	/**
	* Test case 3 for {@link ASTNode#createTree()}.
	* It tests the method with an ASTNode with one child.
	*/
	@Test
	void testCreateTree3() {
		ASTNode node = new ASTNode();
		node.setType(""type"");
		node.setIdentity(""identity"");
		ASTNode child = new ASTNode();
		child.setType(""type"");
		child.setIdentity(""identity"");
		node.addChild(child);
		DefaultMutableTreeNode tree = node.createTree();
		assertEquals(""type :: identity"", tree.toString());
		assertEquals(""type :: identity"", tree.getChildAt(0).toString());
	}
	
	/**
	* Test case 4 for {@link ASTNode#createTree()}.
	* It tests the method with an ASTNode with two children.
	*/
	@Test
	void testCreateTree4() {
		ASTNode node = new ASTNode();
		node.setType(""type"");
		node.setIdentity(""identity"");
		ASTNode child1 = new ASTNode();
		child1.setType(""type"");
		child1.setIdentity(""identity"");
		ASTNode child2 = new ASTNode();
		child2.setType(""type"");
		child2.setIdentity(""identity"");
		node.addChild(child1);
		node.addChild(child2);
		DefaultMutableTreeNode tree = node.createTree();
		assertEquals(""type :: identity"", tree.toString());
		assertEquals(""type :: identity"", tree.getChildAt(0).toString());
		assertEquals(""type :: identity"", tree.getChildAt(1).toString());
	}
	
	/**
	* Test case 5 for {@link ASTNode#createTree()}.
	* It tests the method with an ASTNode with three children.
	*/
	@Test
	void testCreateTree5() {
		ASTNode node = new ASTNode();
		node.setType(""type"");
		node.setIdentity(""identity"");
		ASTNode child1 = new ASTNode();
		child1.setType(""type"");
		child1.setIdentity(""identity"");
		ASTNode child2 = new ASTNode();
		child2.setType(""type"");
		child2.setIdentity(""identity"");
		ASTNode child3 = new ASTNode();
		child3.setType(""type"");
		child3.setIdentity(""identity"");
		node.addChild(child1);
		node.addChild(child2);
		node.addChild(child3);
		DefaultMutableTreeNode tree = node.createTree();
		assertEquals(""type :: identity"", tree.toString());
		assertEquals(""type :: identity"", tree.getChildAt(0).toString());
		assertEquals(""type :: identity"", tree.getChildAt(1).toString());
		assertEquals(""type :: identity"", tree.getChildAt(2).toString());
	}
	
	/**
	* Test case 6 for {@link ASTNode#createTree()}.
	* It tests the method with an ASTNode with four children.
	*/
	@Test
	void testCreateTree6() {
		ASTNode node = new ASTNode();
		node.setType(""type"");
		node.setIdentity(""identity"");
		ASTNode child1 = new ASTNode();
		child1.setType(""type"");
		child1.setIdentity(""identity"");
		ASTNode child2 = new ASTNode();
		child2.setType(""type"");
		child2.setIdentity(""identity"");
		ASTNode child3 = new ASTNode();
		child3.setType(""type"");
		child3.setIdentity(""identity"");
		ASTNode child4 = new ASTNode();
		child4.setType(""type"");
		child4.setIdentity(""identity"");
		node.addChild(child1);
		node.addChild(child2);
		node.addChild(child3);
		node.addChild(child4);
		DefaultMutableTreeNode tree = node.createTree();
		assertEquals(""type :: identity"", tree.toString());
		assertEquals(""type :: identity"", tree.getChildAt(0).toString());
		assertEquals(""type :: identity"", tree.getChildAt(1).toString());
		assertEquals(""type :: identity"", tree.getChildAt(2).toString());
		assertEquals(""type :: identity"", tree.getChildAt(3).toString());
	}
	
	/**
	* Test case 7 for {@link ASTNode#createTree()}.
	* It tests the method with an ASTNode with five children.
	*/
	@Test
	void testCreateTree7() {
		ASTNode node = new ASTNode();
		node.setType(""type"");
		node.setIdentity(""identity"");
		ASTNode child1 = new ASTNode();
		child1.setType(""type"");
		child1.setIdentity(""identity"");
		ASTNode child2 = new ASTNode();
		child2.setType(""type"");
		child2.setIdentity(""identity"");
		ASTNode child3 = new ASTNode();
		child3.setType(""type"");
		child3.setIdentity(""identity"");
		ASTNode child4 = new ASTNode();
		child4.setType(""type"");
		child4.setIdentity(""identity"");
		ASTNode child5 = new ASTNode();
		child5.setType(""type"");
		child5.setIdentity(""identity"");
		node.addChild(child1);
		node.addChild(child2);
		node.addChild(child3);
		node.addChild(child4);
		node.addChild(child5);
		DefaultMutableTreeNode tree = node.createTree();
		assertEquals(""type :: identity"", tree.toString());
		assertEquals(""type :: identity"", tree.getChildAt(0).toString());
		assertEquals(""type :: identity"", tree.getChildAt(1).toString());
		assertEquals(""type :: identity"", tree.getChildAt(2).toString());
		assertEquals(""type :: identity"", tree.getChildAt(3).toString());
		assertEquals(""type :: identity"", tree.getChildAt(4).toString());
	}
	
	/**
	* Test case 8 for {@link ASTNode#createTree()}.
	* It tests the method with an ASTNode with six children.
	*/
	@Test
	void testCreateTree8() {
		ASTNode node = new ASTNode();
		node.setType(""type"");
		node.setIdentity(""identity"");
		ASTNode child1 = new ASTNode();
		child1.setType(""type"");
		child1.setIdentity(""identity"");
		ASTNode child2 = new ASTNode();
		child2.setType(""type"");
		child2.setIdentity(""identity"");
		ASTNode child3 = new ASTNode();
		child3.setType(""type"");
		child3.setIdentity(""identity"");
		ASTNode child4 = new ASTNode();
		child4.setType(""type"");
		child4.setIdentity(""identity"");
		ASTNode child5 = new ASTNode();
		child5.setType(""type"");
		child5.setIdentity(""identity"");
		ASTNode child6 = new ASTNode();
		child6.setType(""type"");
		child6.setIdentity(""identity"");
		node.addChild(child1);
		node.addChild(child2);
		node.addChild(child3);
		node.addChild(child4);
		node.addChild(child5);
		node.addChild(child6);
		DefaultMutableTreeNode tree = node.createTree();
		assertEquals(""type :: identity"", tree.toString());
		assertEquals(""type :: identity"", tree.getChildAt(0).toString());
		assertEquals(""type :: identity"", tree.getChildAt(1).toString());
		assertEquals(""type :: identity"", tree.getChildAt(2).toString());
		assertEquals(""type :: identity"", tree.getChildAt(3).toString());
		assertEquals(""type :: identity"", tree.getChildAt(4).toString());
		assertEquals(""type :: identity"", tree.getChildAt(5).toString());
	}
	
	/**
	* Test case 9 for {@link ASTNode#createTree()}.
	* It tests the method with an ASTNode with seven children.
	*/
	@Test
	void testCreateTree9() {
		ASTNode node = new ASTNode();
		node.setType(""type"");
		node.setIdentity(""identity"");
		ASTNode child1 = new ASTNode();
		child1.setType(""type"");
		child1.setIdentity(""identity"");
		ASTNode child2 = new ASTNode();
		child2.setType(""type"");
		child2.setIdentity(""identity"");
		ASTNode child3 = new ASTNode();
		child3.setType(""type"");
		child3.setIdentity(""identity"");
		ASTNode child4 = new ASTNode();
		child4.setType(""type"");
		child4.setIdentity(""identity"");
		ASTNode child5 = new ASTNode();
		child5.setType(""type"");
		child5.setIdentity(""identity"");
		ASTNode child6 = new ASTNode();
		child6.setType(""type"");
		child6.setIdentity(""identity"");
		ASTNode child7 = new ASTNode();
		child7.setType(""type"");
		child7.setIdentity(""identity"");
		node.addChild(child1);
		node.addChild(child2);
		node.addChild(child3);
		node.addChild(child4);
		node.addChild(child5);
		node.addChild(child6);
		node.addChild(child7);
		DefaultMutableTreeNode tree = node.createTree();
		assertEquals(""type :: identity"", tree.toString());
		assertEquals(""type :: identity"", tree.getChildAt(0).toString());
		assertEquals(""type :: identity"", tree.getChildAt(1).toString());
		assertEquals(""type :: identity"", tree.getChildAt(2).toString());
		assertEquals(""type :: identity"", tree.getChildAt(3).toString());
		assertEquals(""type :: identity"", tree.getChildAt(4).toString());
		assertEquals(""type :: identity"", tree.getChildAt(5).toString());
		assertEquals(""type :: identity"", tree.getChildAt(6).toString());
	}
	
	/**
	* Test case 10 for {@link ASTNode#createTree()}.
	* It tests the method with an ASTNode with eight children.
	*/
	@Test
	void testCreateTree10() {
		ASTNode node = new ASTNode();
		node.setType(""type"");
		node.setIdentity(""identity"");
		ASTNode child1 = new ASTNode();
		child1.setType(""type"");
		child1.setIdentity(""identity"");
		ASTNode child2 = new ASTNode();
		child2.setType(""type"");
		child2.setIdentity(""identity"");
		ASTNode child3 = new ASTNode();
		child3.setType(""type"");
		child3.setIdentity(""identity"");
		ASTNode child4 = new ASTNode();
		child4.setType(""type"");
		child4.setIdentity(""identity"");
		ASTNode child5 = new ASTNode();
		child5.setType(""type"");
		child5.setIdentity(""identity"");
		ASTNode child6 = new ASTNode();
		child6.setType(""type"");
		child6.setIdentity(""identity"");
		ASTNode child7 = new ASTNode();
		child7.setType(""type"");
		child7.setIdentity(""identity"");
		ASTNode child8 = new ASTNode();
		child8.setType(""type"");
		child8.setIdentity(""identity"");
		node.addChild(child1);
		node.addChild(child2);
		node.addChild(child3);
		node.addChild(child4);
		node.addChild(child5);
		node.addChild(child6);
		node.addChild(child7);
		node.addChild(child8);
		DefaultMutableTreeNode tree = node.createTree();
		assertEquals(""type :: identity"", tree.toString());
		assertEquals(""type :: identity"", tree.getChildAt(0).toString());
		assertEquals(""type :: identity"", tree.getChildAt(1).toString());
		assertEquals(""type :: identity"", tree.getChildAt(2).toString());
		assertEquals(""type :: identity"", tree.getChildAt(3).toString());
		assertEquals(""type :: identity"", tree.getChildAt(4).toString());
		assertEquals(""type :: identity"", tree.getChildAt(5).toString());
		assertEquals(""type :: identity"", tree.getChildAt(6).toString());
		assertEquals(""type :: identity"", tree.getChildAt(7).toString());
	}
}

// ASTree.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;

/**
 * <p>Title: Group 2 Project </p>
 *
 * <p>Class: CEN4010 Fall 2005</p>
 *
 * <p>Description: Abstract Syntax Tree</p>
 *
 * <p>Instructor Dr. Stoeklin</p>
 *
 * @author Group 2
 */
public class ASTree {

    /**
     * root node of the tree
     */
    ASTNode root = null;

    /**
     * default constructor
     */
    public ASTree() {
    }

    /**
     * construct a tree with a root node
     * @param r ASTNode
     */
    public ASTree(ASTNode r) {
        root = r;
    }

    /**
     * get the root node
     * @return ASTNode
     */
    public ASTNode getRoot() {
        return root;
    }

    /**
     * set the root node
     * @param r ASTNode
     */
    public void setRoot(ASTNode r) {
        root = r;
    }

    /**
     * display the tree
     * @param wtr Writer
     */
    public void display(Writer wtr) {
        root.display(wtr);
    }

    /**
     * read"
dbe69982-f666-4476-8312-d083e0387b0f,/EvoSuiteBenchmark/original/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JMCAAnalyzer.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 10197 tokens (6197 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// JMCAAnalyzer.java
package com.soops.CEN4010.JMCA;

import java.util.*;

/**
 * <p>Title: JMCAAnalyzer </p>
 *
 * <p>Description: implements Analyzer</p>
 *
 * Group2 for CEN4010 at FSU - Fall 2005
 */
public class JMCAAnalyzer implements Analyzer {

    private String fileName = """";

    private StringBuilder output = new StringBuilder();

    private java.util.HashSet<String> classList = null;

    private static final boolean DEVELOPMENT = false;

    /**
     * Analyze the ASTree and return a formatted string
     * @param root ASTNode
     * @return String
     */
    public String analyze(ASTNode root) {
        if (root == null) {
            output.append(""File did not parse correctly"");
            return output.toString();
        }
        setHeader();
        //  for each class
        for (ASTNode node : root.list) {
            analyzeClass(node);
        }
        return output.toString();
    }

    /**
     * top level analyzer for each class <br>
     * calls analyzeMethod for each method
     * @param node ASTNode
     */
    private void analyzeClass(ASTNode node) {
        // list of class variables
        classList = new HashSet<String>();
        java.util.ArrayList<ASTNode> methodList = new ArrayList<ASTNode>();
        // print class header
        output.append(""\nClass: "" + node.getIdentity() + ""\n\n"");
        output.append(""Method Name                             Cohesion Level\n"");
        output.append(""--------------------------------------------------------------\n"");
        // save each class variable in classList
        for (ASTNode childNode : node.list) {
            if (childNode.getType().equals(""ClassVariableDeclaration"")) {
                classList.add(childNode.getIdentity());
            }
        }
        //  do for each method
        for (ASTNode childNode : node.list) {
            if (childNode.getType().equals(""MethodDeclaration"")) {
                analyzeMethod(childNode);
            }
        }
    }

    // end method analyzeClass
    /**
     * called for each method
     * @param node ASTNode
     */
    private void analyzeMethod(ASTNode node) {
        output.append(node.getIdentity());
        /**
         * list of all statements
         */
        ArrayList<StatementDS> statementList = new ArrayList<StatementDS>();
        /**
         * analyze all statements and add them to the statementList
         */
        statements(node, statementList, false, false);
        /**
         * HashMap of all modified variables
         */
        HashMap<String, StatementElement> modifiedVariables = new HashMap<String, StatementElement>();
        // build semantics for each statement
        for (StatementDS tmpDS : statementList) {
            if (classList.contains(tmpDS.getLVal().getElementName())) {
                tmpDS.getLVal().setType(StatementElement.variableType.ClassVariable);
            }
            if (tmpDS.getType() != null) {
                if (tmpDS.getType().equals(StatementDS.statementType.Assignment) || tmpDS.getType().equals(StatementDS.statementType.PostInc) || tmpDS.getType().equals(StatementDS.statementType.PreInc)) {
                    tmpDS.getLVal().setModified(true);
                    modifiedVariables.put(tmpDS.getLVal().getElementName(), tmpDS.getLVal());
                }
            }
            // set for selection
            tmpDS.getLVal().setInSelection(tmpDS.isInSelection());
            // set for iteration
            tmpDS.getLVal().setInIteration(tmpDS.isInIteration());
            // add modified variables to the chain of variables affecting this element
            ArrayList<StatementElement> rVals = tmpDS.getRVals();
            for (StatementElement rval : rVals) {
                StatementElement tmpEl = modifiedVariables.get(rval.getElementName());
                if (tmpEl != null && !tmpEl.getElementName().equals(tmpDS.getLVal().getElementName())) {
                    tmpDS.getLVal().addModifier(tmpEl);
                } else if (!rval.getElementName().equals(tmpDS.getLVal().getElementName())) {
                    tmpDS.getLVal().addModifier(rval);
                }
                if (rval.hasBeenModified()) {
                    tmpDS.getLVal().addModifier(rval);
                    modifiedVariables.put(rval.getElementName(), rval);
                }
            }
        }
        int modifiedClassVariables = 0;
        int classVariableWithModifiers = 0;
        int modifiedLocVariables = 0;
        boolean iterative = false;
        boolean selective = false;
        String cohesionLevel = """";
        boolean firstModifiedClassVariableWithModifers = true;
        ArrayList<String> classVarModifiers = new ArrayList<String>();
        // do for every Statement
        for (StatementElement el : modifiedVariables.values()) {
            if (el.hasBeenModified()) {
                // class variables
                if (el.getType() != null && el.getType().equals(StatementElement.variableType.ClassVariable)) {
                    // selection
                    if (el.isInSelection()) {
                        selective = true;
                    }
                    // iteration
                    if (el.isInIteration()) {
                        iterative = true;
                    }
                    if (el.getModifiers().size() > 0) {
                        ++classVariableWithModifiers;
                        if (firstModifiedClassVariableWithModifers) {
                            createArrayListOfModifiers(el, classVarModifiers);
                            firstModifiedClassVariableWithModifers = false;
                        } else {
                            ArrayList<String> tmpList = new ArrayList<String>();
                            createArrayListOfModifiers(el, tmpList);
                            ArrayList<String> unionSet = new ArrayList<String>();
                            // get the union of modifed variables
                            for (String var : classVarModifiers) {
                                for (String tmpEl : tmpList) {
                                    if (var.equals(tmpEl)) {
                                        unionSet.add(var);
                                    }
                                }
                            }
                            classVarModifiers = unionSet;
                        }
                    }
                    ++modifiedClassVariables;
                } else {
                    // end modified class variables
                    ++modifiedLocVariables;
                }
            }
        }
        String cohesionType = ""Coincidental"";
        if (modifiedClassVariables == 1 && modifiedLocVariables == 0) {
            cohesionType = ""Functional"";
        } else if (modifiedClassVariables == 1 && classVarModifiers.size() > 0) {
            cohesionType = ""Sequential"";
        } else if (modifiedClassVariables > 1 && classVarModifiers.size() > 0) {
            cohesionType = ""Communicational"";
        } else if (modifiedClassVariables == 0) {
            cohesionType = ""No Class Level Assignments"";
            //  cohesionType = ""Coincidental"";
        }
        if (iterative) {
            cohesionType = ""Iterative"";
        }
        if (selective) {
            cohesionType = ""Conditional"";
        }
        for (int i = 0; i < 60 - node.getIdentity().length() - cohesionType.length(); ++i) {
            output.append("" "");
        }
        output.append(cohesionType + ""\n"");
        // print out a toString dump for development analysis
        if (DEVELOPMENT) {
            for (StatementDS tmpDS : statementList) {
                output.append(""     "" + tmpDS.toString() + ""\n"");
            }
        }
    }

    // end method analyzeMethod
    /**
     * recursive method to create a chain of modifiers to a variable <b>
     * using this method then :   a = b + c;  d = a;  e = d; <br>
     *   e would contain both d and a as modifiers it is dependent on
     * @param stE StatementElement
     * @param list ArrayList
     */
    private void createArrayListOfModifiers(StatementElement stE, ArrayList<String> list) {
        for (StatementElement tmpEl : stE.getModifiers()) {
            list.add(tmpEl.getElementName());
            if (tmpEl.getModifiers().size() > 0) {
                createArrayListOfModifiers(tmpEl, list);
            }
        }
    }

    /**
     * recusive method to analyze statements
     * @param parentNode ASTNode
     * @param statementList ArrayList
     * @param isInSelection boolean
     * @param isInIteration boolean
     */
    private void statements(ASTNode parentNode, ArrayList<StatementDS> statementList, boolean isInSelection, boolean isInIteration) {
        for (ASTNode childNode : parentNode.list) {
            if (childNode.getType().equals(""Selection"")) {
                statements(childNode, statementList, true, isInIteration);
            } else if (childNode.getType().equals(""Iteration"")) {
                statements(childNode, statementList, isInSelection, true);
            } else if (childNode.getIdentity().equals(""StatementExpression"")) {
                StatementDS tmpDS = analyzeStatement(childNode);
                tmpDS.setInIteration(isInIteration);
                tmpDS.setInSelection(isInSelection);
                statementList.add(tmpDS);
            }
        }
    }

    /**
     * called for each statement
     * @param node ASTNode
     * @return StatementDS
     */
    private StatementDS analyzeStatement(ASTNode node) {
        StatementDS localDS = new StatementDS();
        int nodeCount = node.list.size();
        int currCtr = 0;
        int nxtCtr = nodeCount > 0 ? 1 : 0;
        // check for preDec ++ or --
        String firstVal = node.list.get(0).getIdentity();
        if (firstVal.equals(""++"") || firstVal.equals(""--"")) {
            localDS.setType(StatementDS.statementType.PreInc);
            currCtr++;
        }
        currCtr = getLVal(currCtr, node.list);
        localDS.setLVal(node.list.get(currCtr).getIdentity());
        if (currCtr + 1 == nodeCount) {
            return localDS;
        }
        // have the LVAL and there is a next
        currCtr++;
        if (node.list.get(currCtr).getIdentity().equals(""["")) {
            while (!node.list.get(currCtr).getIdentity().equals(""]"")) {
                currCtr++;
            }
            currCtr++;
        }
        if (currCtr + 1 == nodeCount) {
            return localDS;
        }
        // have the LVAL and there is a next
        String tmpVl = node.list.get(currCtr).getIdentity();
        if (tmpVl.equals(""("")) {
            localDS.setType(StatementDS.statementType.MethodCall);
            return localDS;
        }
        if (tmpVl.equals(""++"") || tmpVl.equals(""--"")) {
            localDS.setType(StatementDS.statementType.PostInc);
            return localDS;
        }
        if (tmpVl.equals(""+="") || tmpVl.equals(""="") || tmpVl.equals(""-="") || tmpVl.equals(""\\="") || tmpVl.equals(""*="")) {
            localDS.setType(StatementDS.statementType.Assignment);
            currCtr++;
        }
        getRVals(localDS, currCtr, node.list);
        return localDS;
    }

    /**
     * called from analyzeStatement - gets a list of RVals in assignment statements
     * @param locDS StatementDS
     * @param ctr int
     * @param list ArrayList
     */
    private void getRVals(StatementDS locDS, int ctr, ArrayList<ASTNode> list) {
        // reset to true for each new rval element
        boolean isFirstToken = true;
        String currVariable = null;
        int nodeCount = list.size();
        String currID = null, nextID = null;
        StatementElement currEl = null;
        while (ctr < nodeCount) {
            currID = list.get(ctr).getIdentity();
            if (ctr + 1 < nodeCount) {
                nextID = list.get(ctr + 1).getIdentity();
            } else {
                nextID = null;
            }
            if (isFirstToken) {
                currEl = new StatementElement();
                isFirstToken = false;
                if (currID.equals(""++"") || currID.equals(""--"")) {
                    currEl.setModified(true);
                }
                if (currID.equals(""("")) {
                    ctr++;
                    continue;
                }
            }
            if (nextID != null && (nextID.equals(""++"") || nextID.equals(""--""))) {
                currEl.setModified(true);
                if (currEl.getElementName() == null) {
                    currEl.setElementName(currID);
                }
            }
            if (nextID != null && (nextID.equals("")""))) {
                if (currEl.getElementName() == null) {
                    currEl.setElementName(currID);
                }
                ctr++;
                continue;
            }
            if (nextID != null && nextID.equals(""."")) {
                ctr += 2;
                continue;
            }
            if (nextID == null || isOperator(nextID)) {
                if (currEl.getElementName() == null) {
                    currEl.setElementName(currID);
                }
                locDS.addRVal(currEl);
                // set for the next element
                isFirstToken = true;
                ctr++;
                continue;
            }
            if (currID.equals(""new"")) {
                currEl.setType(StatementElement.variableType.ClassInitiator);
            }
            if (nextID != null && nextID.equals(""("")) {
                if (currEl.getType() == null) {
                    currEl.setType(StatementElement.variableType.MethodCall);
                }
                if (currEl.getElementName() == null) {
                    currEl.setElementName(currID);
                }
            }
            // ignore the array subscripts
            if (nextID != null && nextID.equals(""["")) {
                if (currEl.getElementName() == null) {
                    currEl.setElementName(currID);
                }
                String tmpVal = list.get(ctr).getIdentity();
                while (!tmpVal.equals(""]"")) {
                    ctr++;
                    tmpVal = list.get(ctr).getIdentity();
                }
                if (ctr == nodeCount - 1) {
                    locDS.addRVal(currEl);
                }
            }
            ctr++;
        }
        // end while loop
    }

    /**
     * helper function - checks for delimiters in a equation where delimiters <br>
     * are defined as arithmetic operands such as '+' and '-'
     * @param id String
     * @return boolean
     */
    private boolean isOperator(String id) {
        if (id == null) {
            return false;
        }
        if (id.equals(""+"") || id.equals(""-"") || id.equals(""\\"") || id.equals(""*"") || id.equals(""<<"") || id.equals("">>"") || id.equals(""%"")) {
            return true;
        }
        return false;
    }

    /**
     * gets the variable name for the lVal of an expression
     * @param ctr int
     * @param list ArrayList
     * @return int
     */
    private int getLVal(int ctr, ArrayList<ASTNode> list) {
        // do until the LVal is found
        // lval is an identity that does not have a '.' as the next identity
        // ie.   java.util.Type   in this instance Type is the LVal
        int nodeCount = list.size();
        String currID = null, nextID = null;
        while (ctr < nodeCount) {
            currID = list.get(ctr).getIdentity();
            if (ctr + 1 < nodeCount) {
                nextID = list.get(ctr + 1).getIdentity();
            } else {
                return ctr;
            }
            if (!nextID.equals(""."")) {
                return ctr;
            }
            ctr += 2;
        }
        return ctr;
    }

    /**
     * write the report header to output
     */
    private void setHeader() {
        output.append(""\nFile:  "");
        output.append(fileName);
        output.append(""\n"");
    }

    /**
     * Store the file name parsed for formatted display purposes
     * @param fileName String
     */
    public void setFileName(String fileName) {
        this.fileName = fileName;
    }
}

/**
 *  represents a variable in an expression
 */
class StatementElement {

    /**
     * marked true if this variable is modifed in the method
     */
    private boolean hasBeenModified = false;

    /**
     * represents the variable name
     */
    private String elementName = null;

    /**
     * set true if variable is within a if statement
     */
    private boolean isInSelection = false;

    /**
     * set true if variable is within an interation block
     */
    private boolean isInIteration = false;

    /**
     * list of elements that have modified this element <br>
     * a recursive descent of elements will get a chain of modifiers
     */
    private ArrayList<StatementElement> modifiers = new ArrayList<StatementElement>();

    /**
     * add a variable to the modifier list
     * @param rval StatementElement
     */
    public void addModifier(StatementElement rval) {
        modifiers.add(rval);
    }

    /**
     * return a reference to the modifier list
     * @return ArrayList
     */
    public ArrayList<StatementElement> getModifiers() {
        return modifiers;
    }

    /**
     *  enumeration of types
     */
    public static enum variableType {

        ClassVariable, LocalVariable, MethodCall, ClassInitiator
    }

    /**
     * local variableType represent the type of variable this is
     */
    variableType type = null;

    /**
     * default constructor
     */
    StatementElement() {
    }

    /**
     *  setter for the variable name
     * @param name String
     */
    StatementElement(String name) {
        setElementName(name);
    }

    /**
     * getter for the type : see enum variableType
     * @return variableType
     */
    variableType getType() {
        return type;
    }

    /**
     * setter for the variable type
     * @param t variableType
     */
    void setType(variableType t) {
        type = t;
    }

    /**
     * setter for the name
     * @param name String
     */
    void setElementName(String name) {
        elementName = name;
    }

    /**
     * getter for the boolean flag hasBeenModified
     * @return boolean
     */
    boolean hasBeenModified() {
        return hasBeenModified;
    }

    /**
     * getter for the variable name
     * @return String
     */
    String getElementName() {
        return elementName;
    }

    /**
     * setter for the boolean flag has been modified
     * @param val boolean
     */
    void setModified(boolean val) {
        hasBeenModified = val;
    }

    /**
     * override of toString provides information for debugging/development
     * @return String
     */
    public String toString() {
        String tmp = elementName;
        if (hasBeenModified) {
            tmp += "" (modified) "";
        }
        if (type != null) {
            tmp += "" ("" + type.toString() + "") "";
        }
        for (StatementElement element : modifiers) {
            tmp += element.toString();
        }
        return tmp;
    }

    /**
     * getter for the boolean flag isInSelection
     * @return boolean
     */
    boolean isInSelection() {
        return isInSelection;
    }

    /**
     * getter for the boolean flag isInIteration
     * @return boolean
     */
    boolean isInIteration() {
        return isInIteration;
    }

    /**
     * setter for isInSelection
     * @param val boolean
     */
    void setInSelection(boolean val) {
        isInSelection = val;
    }

    /**
     * setter for isInIteration
     * @param val boolean
     */
    void setInIteration(boolean val) {
        isInIteration = val;
    }
}

// end class
/**
 *   represents an expression statement <br>
 *   has Statment Elements  : one lVal and 0 . . . n rVals
 */
class StatementDS {

    private StatementElement lVal = null;

    private ArrayList<StatementElement> rValList = new ArrayList<StatementElement>();

    public static enum statementType {

        PreInc, PostInc, Assignment, MethodCall
    }

    private statementType type = null;

    private boolean isInSelection = false;

    private boolean isInIteration = false;

    statementType getType() {
        return type;
    }

    /**
     * add a rVal to the list
     * @param rv StatementElement
     */
    void addRVal(StatementElement rv) {
        rValList.add(rv);
    }

    /**
     * set statement type: see  enum statementType
     * @param t statementType
     */
    void setType(statementType t) {
        type = t;
    }

    /**
     * get a reference to the list of rVals
     * @return ArrayList
     */
    ArrayList<StatementElement> getRVals() {
        return rValList;
    }

    /**
     * override of toString contains information for debugging
     * @return String
     */
    public String toString() {
        String tmp = lVal.toString();
        tmp += "" : "" + type.toString();
        if (this.isInIteration()) {
            tmp += "" (Iteration) "";
        }
        if (this.isInSelection()) {
            tmp += "" (Selection) "";
        }
        for (StatementElement rVal : rValList) {
            tmp += "" := "" + rVal.toString();
        }
        return tmp;
    }

    /**
     * setter for the LVal
     * @param rv StatementElement
     */
    void setLVal(StatementElement rv) {
        lVal = rv;
    }

    /**
     * setter for the LVal
     * @param id String
     */
    void setLVal(String id) {
        lVal = new StatementElement(id);
    }

    /**
     * getter for the LVal
     * @return StatementElement
     */
    StatementElement getLVal() {
        return lVal;
    }

    /**
     * getter for the boolean flag isInSelection
     * @return boolean
     */
    boolean isInSelection() {
        return isInSelection;
    }

    /**
     * getter for the boolean flag isInIteration
     * @return boolean
     */
    boolean isInIteration() {
        return isInIteration;
    }

    /**
     * setter for isInSelection
     * @param val boolean
     */
    void setInSelection(boolean val) {
        isInSelection = val;
    }

    /**
     * setter for isInIteration
     * @param val boolean
     */
    void setInIteration(boolean val) {
        isInIteration = val;
    }
}
","// JMCAAnalyzerTest.java
package com.soops.CEN4010.JMCA;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JMCAAnalyzer}.
* It contains ten unit test cases for the {@link JMCAAnalyzer#analyze(ASTNode)} method.
*/
class JMCAAnalyzerTest {","// JMCAAnalyzerTest.java
package com.soops.CEN4010.JMCA;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JMCAAnalyzer}.
* It contains ten unit test cases for the {@link JMCAAnalyzer#analyze(ASTNode)} method.
*/
class JMCAAnalyzerTest {
"
cmpl-6wozZ8gAFKgUSJMre1tZzRfY9Wj74,/EvoSuiteBenchmark/original/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JMCAParser.java,108.41341781616211,length,"// JMCAParser.java
package com.soops.CEN4010.JMCA;

import java.io.Reader;
import com.soops.CEN4010.JMCA.JParser.JavaParser;
import java.io.IOException;
import java.io.FileWriter;
import java.io.Writer;
import java.io.FileInputStream;
import java.io.File;
import com.soops.CEN4010.JMCA.JParser.xmlParser.SaxProcessor;
import com.soops.CEN4010.JMCA.JParser.ParseException;

public class JMCAParser implements Parser {

    String intermediateFile = ""default.xml"";

    /**
     * parse implements parse for Parser
     * precondition is the intermediatFile is set
     * @param rdr Reader
     * @return ASTNode
     */
    public ASTNode parse(Reader rdr) {
        JavaParser parser = new JavaParser(rdr);
        Writer wtr = null;
        try {
            parser.CompilationUnit();
            wtr = new FileWriter(new File(intermediateFile));
            parser.dump(wtr);
            System.out.println(""Java Parser Version 1.1:  Java program parsed successfully."");
            wtr.close();
            SaxProcessor saxP = new SaxProcessor(new FileInputStream(new File(intermediateFile)));
            saxP.showFile();
            return saxP.getRootNode();
        } catch (ParseException e) {
            System.out.println(e.getMessage());
            System.out.println(""Java Parser Version 1.1:  Encountered errors during parse."");
            return null;
        } catch (IOException ie) {
            System.out.println(""IO Error from parse : "" + ie.getMessage());
            return null;
        } catch (Error ex) {
            return null;
        } finally {
            try {
                if (wtr != null)
                    wtr.close();
            } catch (IOException ie) {
                System.err.println(""Error while closing intermediate file "" + intermediateFile);
                System.err.println(ie.getMessage());
            }
        }
        //           return null;
    }
}
","// JMCAParserTest.java
package com.soops.CEN4010.JMCA;

import java.io.Reader;
import com.soops.CEN4010.JMCA.JParser.JavaParser;
import java.io.IOException;
import java.io.FileWriter;
import java.io.Writer;
import java.io.FileInputStream;
import java.io.File;
import com.soops.CEN4010.JMCA.JParser.xmlParser.SaxProcessor;
import com.soops.CEN4010.JMCA.JParser.ParseException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JMCAParser}.
* It contains ten unit test cases for the {@link JMCAParser#parse(Reader)} method.
*/
class JMCAParserTest {","// JMCAParserTest.java
package com.soops.CEN4010.JMCA;

import java.io.Reader;
import com.soops.CEN4010.JMCA.JParser.JavaParser;
import java.io.IOException;
import java.io.FileWriter;
import java.io.Writer;
import java.io.FileInputStream;
import java.io.File;
import com.soops.CEN4010.JMCA.JParser.xmlParser.SaxProcessor;
import com.soops.CEN4010.JMCA.JParser.ParseException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JMCAParser}.
* It contains ten unit test cases for the {@link JMCAParser#parse(Reader)} method.
*/
class JMCAParserTest {

	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a valid Java program.
	*/
	@Test
	void testParseValidJavaProgram() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/valid_java_program.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/valid_java_program.java""));
		assertNotNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError2() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error2.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error2.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError3() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error3.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error3.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError4() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error4.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error4.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError5() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error5.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error5.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError6() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error6.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error6.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError7() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error7.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error7.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError8() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error8.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error8.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError9() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error9.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error9.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError10() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error10.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error10.java""));
		assertNull(root);
	}
}

// JMCATest.java
package com.soops.CEN4010.JMCA;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JMCAParser}.
* It contains ten unit test cases for the {@link JMCAParser#parse(Reader)} method.
*/
class JMCATest {
		
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a valid Java program.
	*/
	@Test
	void testParseValidJavaProgram() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/valid_java_program.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/valid_java_program.java""));
		assertNotNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError2() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error2.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error2.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError3() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error3.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error3.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError4() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error4.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error4.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError5() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error5.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error5.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError6() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error6.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error6.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError7() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error7.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error7.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError8() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error8.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error8.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError9() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error9.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error9.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError10() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_sy"
cmpl-6wp1KOSX49bUaPWsgsNJs5l0ch46R,/EvoSuiteBenchmark/original/19_jmca/src/main/java/com/soops/CEN4010/JMCA/UILayoutDisplayAnalyzer.java,144.68192887306213,length,"// UILayoutDisplayAnalyzer.java
package com.soops.CEN4010.JMCA;

/**
 * <p>Title: Group 2 Project </p>
 *
 * <p>Class: CEN4010 Fall 2005</p>
 *
 * <p>Description: Description: UILayoutDisplayAnalyzer implements a dummy Analyzer
 *    use for UI layout  </p>
 *
 * <p>Instructor Dr. Stoeklin</p>
 *
 * @author Group 2
 */
public class UILayoutDisplayAnalyzer implements Analyzer {

    String filename = null;

    /**
     * store the file name for formatted display purposes
     * @param file String
     */
    public void setFileName(String file) {
        filename = file;
    }

    /**
     * no operational implementation of Analyzer
     * @param dummy ASTNode not used for dummy output
     * @return display string
     */
    public String analyze(ASTNode dummy) {
        StringBuffer output = new StringBuffer();
        //FAKE OUTPUT FOR PROTOTYPE
        output = new StringBuffer(""\nFile:  "");
        output.append(filename);
        output.append(""\n"");
        output.append(""Class: CohesionTest\n\n"");
        output.append(""Method Name                             Cohesion Level\n"");
        output.append(""--------------------------------------------------------------\n"");
        output.append(""deposit                                 Functional\n"");
        output.append(""withdraw                                Sequential\n"");
        output.append(""addCD                                   Communicational\n"");
        output.append(""formDet                                 Iterative\n"");
        output.append(""checkBookIn                             Conditional\n"");
        output.append(""readInput                               Coincidental\n"");
        return output.toString();
    }
}
","// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {","// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {

	/**
	* Test case for {@link UILayoutDisplayAnalyzer#analyze(ASTNode)}.
	*/
	@Test
	void testAnalyze() {
		UILayoutDisplayAnalyzer analyzer = new UILayoutDisplayAnalyzer();
		analyzer.setFileName(""test.java"");
		assertEquals(""\nFile:  test.java\nClass: CohesionTest\n\nMethod Name                             Cohesion Level\n--------------------------------------------------------------\ndeposit                                 Functional\nwithdraw                                Sequential\naddCD                                   Communicational\nformDet                                 Iterative\ncheckBookIn                             Conditional\nreadInput                               Coincidental\n"", analyzer.analyze(null));
	}
}

// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {
		
	/**
	* Test case for {@link UILayoutDisplayAnalyzer#analyze(ASTNode)}.
	*/
	@Test
	void testAnalyze() {
		UILayoutDisplayAnalyzer analyzer = new UILayoutDisplayAnalyzer();
		analyzer.setFileName(""test.java"");
		assertEquals(""\nFile:  test.java\nClass: CohesionTest\n\nMethod Name                             Cohesion Level\n--------------------------------------------------------------\ndeposit                                 Functional\nwithdraw                                Sequential\naddCD                                   Communicational\nformDet                                 Iterative\ncheckBookIn                             Conditional\nreadInput                               Coincidental\n"", analyzer.analyze(null));
	}
}

// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {
		
	/**
	* Test case for {@link UILayoutDisplayAnalyzer#analyze(ASTNode)}.
	*/
	@Test
	void testAnalyze() {
		UILayoutDisplayAnalyzer analyzer = new UILayoutDisplayAnalyzer();
		analyzer.setFileName(""test.java"");
		assertEquals(""\nFile:  test.java\nClass: CohesionTest\n\nMethod Name                             Cohesion Level\n--------------------------------------------------------------\ndeposit                                 Functional\nwithdraw                                Sequential\naddCD                                   Communicational\nformDet                                 Iterative\ncheckBookIn                             Conditional\nreadInput                               Coincidental\n"", analyzer.analyze(null));
	}
}

// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {
		
	/**
	* Test case for {@link UILayoutDisplayAnalyzer#analyze(ASTNode)}.
	*/
	@Test
	void testAnalyze() {
		UILayoutDisplayAnalyzer analyzer = new UILayoutDisplayAnalyzer();
		analyzer.setFileName(""test.java"");
		assertEquals(""\nFile:  test.java\nClass: CohesionTest\n\nMethod Name                             Cohesion Level\n--------------------------------------------------------------\ndeposit                                 Functional\nwithdraw                                Sequential\naddCD                                   Communicational\nformDet                                 Iterative\ncheckBookIn                             Conditional\nreadInput                               Coincidental\n"", analyzer.analyze(null));
	}
}

// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {
		
	/**
	* Test case for {@link UILayoutDisplayAnalyzer#analyze(ASTNode)}.
	*/
	@Test
	void testAnalyze() {
		UILayoutDisplayAnalyzer analyzer = new UILayoutDisplayAnalyzer();
		analyzer.setFileName(""test.java"");
		assertEquals(""\nFile:  test.java\nClass: CohesionTest\n\nMethod Name                             Cohesion Level\n--------------------------------------------------------------\ndeposit                                 Functional\nwithdraw                                Sequential\naddCD                                   Communicational\nformDet                                 Iterative\ncheckBookIn                             Conditional\nreadInput                               Coincidental\n"", analyzer.analyze(null));
	}
}

// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {
		
	/**
	* Test case for {@link UILayoutDisplayAnalyzer#analyze(ASTNode)}.
	*/
	@Test
	void testAnalyze() {
		UILayoutDisplayAnalyzer analyzer = new UILayoutDisplayAnalyzer();
		analyzer.setFileName(""test.java"");
		assertEquals(""\nFile:  test.java\nClass: CohesionTest\n\nMethod Name                             Cohesion Level\n--------------------------------------------------------------\ndeposit                                 Functional\nwithdraw                                Sequential\naddCD                                   Communicational\nformDet                                 Iterative\ncheckBookIn                             Conditional\nreadInput                               Coincidental\n"", analyzer.analyze(null));
	}
}

// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {
		
	/**
	* Test case for {@link UILayoutDisplayAnalyzer#analyze(ASTNode)}.
	*/
	@Test
	void testAnalyze() {
		UILayoutDisplayAnalyzer analyzer = new UILayoutDisplayAnalyzer();
		analyzer.setFileName(""test.java"");
		assertEquals(""\nFile:  test.java\nClass: CohesionTest\n\nMethod Name                             Cohesion Level\n--------------------------------------------------------------\ndeposit                                 Functional\nwithdraw                                Sequential\naddCD                                   Communicational\nformDet                                 Iterative\ncheckBookIn                             Conditional\nreadInput                               Coincidental\n"", analyzer.analyze(null));
	}
}

// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {
		
	/**
	* Test case for {@link UILayoutDisplayAnalyzer#analyze(ASTNode)}.
	*/
	@Test
	void testAnalyze() {
		UILayoutDisplayAnalyzer analyzer = new UILayoutDisplayAnalyzer();
		analyzer.setFileName(""test.java"");
		assertEquals(""\nFile:  test.java\nClass: CohesionTest\n\nMethod Name                             Cohesion Level\n--------------------------------------------------------------\ndeposit                                 Functional\nwithdraw                                Sequential\naddCD                                   Communicational\nformDet                                 Iterative\ncheckBookIn                             Conditional\nreadInput                               Coincidental\n"", analyzer.analyze(null));
	}
}

// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {
		
	/**
	* Test case for {@link UILayoutDisplayAnalyzer#analyze(ASTNode)}.
	*/
	@Test
	void testAnalyze() {
		UILayoutDisplayAnalyzer analyzer = new UILayoutDisplayAnalyzer();
		analyzer.setFileName(""test.java"");
		assertEquals(""\nFile:  test.java\nClass: CohesionTest\n\nMethod Name                             Cohesion Level\n--------------------------------------------------------------\ndeposit                                 Functional\nwithdraw                                Sequential\naddCD                                   Communicational\nformDet                                 Iterative\ncheckBookIn                             Conditional\nreadInput                               Coincidental\n"", analyzer.analyze(null));
	}
}

// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {
		
	/**
	* Test case for {@link UILayoutDisplayAnalyzer#analyze(ASTNode)}.
	*/
	@Test
	void testAnalyze() {
		UILayoutDisplayAnalyzer analyzer = new UILayoutDisplayAnalyzer();
		analyzer.setFileName(""test.java"");
		assertEquals(""\nFile:  test.java\nClass: CohesionTest\n\nMethod Name                             Cohesion Level\n--------------------------------------------------------------\ndeposit                                 Functional\nwithdraw                                Sequential\naddCD                                   Communicational\nformDet                                 Iterative\ncheckBookIn                             Conditional\nreadInput                               Coincidental\n"", analyzer.analyze(null));
	}
}

// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {
		
	/**
	* Test case for {@link UILayoutDisplayAnalyzer#analyze(ASTNode)}.
	*/
	@Test
	void testAnalyze() {
		UILayoutDisplayAnalyzer analyzer = new UILayoutDisplayAnalyzer();
		analyzer.setFileName(""test.java"");
		assertEquals(""\nFile:  test.java\nClass: CohesionTest\n\nMethod Name                             Cohesion Level\n--------------------------------------------------------------\ndeposit                                 Functional\nwithdraw                                Sequential\naddCD                                   Communicational\nformDet                                 Iterative\ncheckBookIn                             Conditional\nreadInput                               Coincidental\n"", analyzer.analyze(null));
	}
}

// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {
		
	/**
	* Test case for {@link UILayoutDisplayAnalyzer#analyze(ASTNode)}.
	*/
	@Test
	void testAnalyze() {
		UILayoutDisplayAnalyzer analyzer = new UILayoutDisplayAnalyzer();
		analyzer.setFileName(""test.java"");
		assertEquals(""\nFile:  test.java\nClass: CohesionTest\n\nMethod Name                             Cohesion Level\n--------------------------------------------------------------\ndeposit                                 Functional\nwithdraw                                Sequential\naddCD                                   Communicational\nformDet                                 Iterative\ncheckBookIn                             Conditional\nreadInput                               Coincidental\n"", analyzer.analyze(null));
	}
}

// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {
		
	/**
	* Test case for {@link UILayoutDisplayAnalyzer#analyze(ASTNode)}.
	*/
	@Test
	void testAnalyze() {
		UILayoutDisplayAnalyzer analyzer = new UILayoutDisplayAnalyzer();
		analyzer.setFileName(""test.java"");
		assertEquals(""\nFile:  test.java\nClass: CohesionTest\n\nMethod Name                             Cohesion Level\n--------------------------------------------------------------\ndeposit                                 Functional\nwithdraw                                Sequential\naddCD                                   Communicational\nformDet                                 Iterative\ncheckBookIn                             Conditional\nreadInput                               Coincidental\n"", analyzer.analyze(null));
	}
}

// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {
		
	/**
	* Test case for {@link UILayoutDisplayAnalyzer#analyze"
