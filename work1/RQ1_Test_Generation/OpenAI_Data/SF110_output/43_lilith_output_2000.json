[
{
    "id": "cmpl-6wSGela6C6NvmGZ4MKGQ5gTAdg80m",
    "object": "text_completion",
    "created": 1679389704,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\t@Test\n\t\tpublic void testFormat_0() {\n\t\t\t\tString messagePattern = \"\";\n\t\t\t\tString[] arguments = new String[] {};\n\t\t\t\tString result = MessageFormatter.format(messagePattern, arguments);\n\t\t\t\tassertEquals(\"\", result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testFormat_1() {\n\t\t\t\tString messagePattern = \"\";\n\t\t\t\tString[] arguments = new String[] {\"a\"};\n\t\t\t\tString result = MessageFormatter.format(messagePattern, arguments);\n\t\t\t\tassertEquals(\"\", result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testFormat_2() {\n\t\t\t\tString messagePattern = \"\";\n\t\t\t\tString[] arguments = new String[] {\"a\", \"b\"};\n\t\t\t\tString result = MessageFormatter.format(messagePattern, arguments);\n\t\t\t\tassertEquals(\"\", result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testFormat_3() {\n\t\t\t\tString messagePattern = \"\";\n\t\t\t\tString[] arguments = new String[] {\"a\", \"b\", \"c\"};\n\t\t\t\tString result = MessageFormatter.format(messagePattern, arguments);\n\t\t\t\tassertEquals(\"\", result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testFormat_4() {\n\t\t\t\tString messagePattern = \"\";\n\t\t\t\tString[] arguments = new String[] {\"a\", \"b\", \"c\", \"d\"};\n\t\t\t\tString result = MessageFormatter.format(messagePattern, arguments);\n\t\t\t\tassertEquals(\"\", result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testFormat_5() {\n\t\t\t\tString messagePattern = \"\";\n\t\t\t\tString[] arguments = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\t\t\t\tString result = MessageFormatter.format(messagePattern, arguments);\n\t\t\t\tassertEquals(\"\", result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testFormat_6() {\n\t\t\t\tString messagePattern = \"\";\n\t\t\t\tString[] arguments = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\n\t\t\t\tString result = MessageFormatter.format(messagePattern, arguments);\n\t\t\t\tassertEquals(\"\", result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testFormat_7() {\n\t\t\t\tString messagePattern = \"\";\n\t\t\t\tString[] arguments = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"};\n\t\t\t\tString result = MessageFormatter.format(messagePattern, arguments);\n\t\t\t\tassertEquals(\"\", result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testFormat_8() {\n\t\t\t\tString messagePattern = \"\";\n\t\t\t\tString[] arguments = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"};\n\t\t\t\tString result = MessageFormatter.format(messagePattern, arguments);\n\t\t\t\tassertEquals(\"\", result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testFormat_9() {\n\t\t\t\tString messagePattern = \"\";\n\t\t\t\tString[] arguments = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"};\n\t\t\t\tString result = MessageFormatter.format(messagePattern, arguments);\n\t\t\t\tassertEquals(\"\", result);\n\t\t}\n\t\t\n}\n\n// MessageFormatter_1Test.java\npackage de.huxhorn.lilith.data.logging;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MessageFormatter}.\n* It contains ten unit test cases for the {@link MessageFormatter#format(String, String[])} method.\n*/\nclass MessageFormatter_1Test {\n\t\t\n\t\t@Test\n\t\tpublic void testFormat_0() {\n\t\t\t\tString messagePattern = \"a\";\n\t\t\t\tString[] arguments = new String[] {};\n\t\t\t\tString result = MessageFormatter.format(messagePattern, arguments);\n\t\t\t\tassertEquals(\"a\", result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testFormat_1() {\n\t\t\t\tString messagePattern = \"a\";\n\t\t\t\tString[] arguments = new String[] {\"b\"};\n\t\t\t\tString result = MessageFormatter.format(messagePattern, arguments);\n\t\t\t\tassertEquals(\"a\", result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testFormat_2() {\n\t\t\t\tString messagePattern = \"a\";\n\t\t\t\tString[] arguments = new String[] {\"b\", \"c\"};\n\t\t\t\tString result = MessageFormatter.format(messagePattern, arguments);\n\t\t\t\tassertEquals(\"a\", result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testFormat_3() {\n\t\t\t\tString messagePattern = \"a\";\n\t\t\t\tString[] arguments = new String[] {\"b\", \"c\", \"d\"};\n\t\t\t\tString result = MessageFormatter.format(messagePattern, arguments);\n\t\t\t\tassertEquals(\"a\", result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testFormat_4() {\n\t\t\t\tString messagePattern = \"a\";\n\t\t\t\tString[] arguments = new String[] {\"b\", \"c\", \"d\", \"e\"};\n\t\t\t\tString result = MessageFormatter.format(messagePattern, arguments);\n\t\t\t\tassertEquals(\"a\", result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testFormat_5() {\n\t\t\t\tString messagePattern = \"a\";\n\t\t\t\tString[] arguments = new String[] {\"b\", \"c\", \"d\", \"e\", \"f\"};\n\t\t\t\tString result = MessageFormatter.format(messagePattern, arguments);\n\t\t\t\tassertEquals(\"a\", result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testFormat_6() {\n\t\t\t\tString messagePattern = \"a\";\n\t\t\t\tString[] arguments = new String[] {\"b\", \"c\", \"d\", \"e\", \"f\", \"g\"};\n\t\t\t\tString result = MessageFormatter.format(messagePattern, arguments);\n\t\t\t\tassertEquals(\"a\", result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testFormat_7() {\n\t\t\t\tString messagePattern = \"a\";\n\t\t\t\tString[] arguments = new String[] {\"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"};\n\t\t\t\tString result = MessageFormatter.format(messagePattern, arguments);\n\t\t\t\tassertEquals(\"a\", result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testFormat_8() {\n\t\t\t\tString messagePattern = \"a\";\n\t\t\t\tString[] arguments = new String[] {\"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"};\n\t\t\t\tString result = MessageFormatter.format(messagePattern, arguments);\n\t\t\t\tassertEquals(\"a\", result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testFormat_9() {\n\t\t\t\tString messagePattern = \"a\";\n\t\t\t\tString[] arguments = new String[] {\"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"};\n\t\t\t\tString result = MessageFormatter.format(messagePattern",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 5265,
        "completion_tokens": 2000,
        "total_tokens": 7265
    },
    "time_taken": 63.150105476379395,
    "prompt_id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_0Test.java",
    "original_code": "// MessageFormatter.java\n/*\r\n * Lilith - a log event viewer.\r\n * Copyright (C) 2007-2009 Joern Huxhorn\r\n * \r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.huxhorn.lilith.data.logging;\r\n\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Arrays;\r\nimport java.util.Collection;\r\nimport java.util.Date;\r\nimport java.util.HashSet;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n/**\r\n * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>\r\n * <p>\r\n * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message\r\n * is split into three parts:\r\n * </p>\r\n * <ol>\r\n * <li>Counting of placeholders in the message pattern (cheap)</li>\r\n * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as\r\n * an optional Throwable if available (relatively cheap)</li>\r\n * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>\r\n * </ol>\r\n * <p>\r\n * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the\r\n * actual construction of the message, is only done on demand.\r\n * </p>\r\n */\r\npublic class MessageFormatter {\r\n\r\n    private static final char DELIM_START = '{';\r\n\r\n    private static final char DELIM_STOP = '}';\r\n\r\n    private static final char ESCAPE_CHAR = '\\\\';\r\n\r\n    public static final String RECURSION_PREFIX = \"[...\";\r\n\r\n    public static final String RECURSION_SUFFIX = \"...]\";\r\n\r\n    public static final String ERROR_PREFIX = \"[!!!\";\r\n\r\n    public static final String ERROR_SEPARATOR = \"=>\";\r\n\r\n    public static final String ERROR_MSG_SEPARATOR = \":\";\r\n\r\n    public static final String ERROR_SUFFIX = \"!!!]\";\r\n\r\n    /**\r\n     * Replace placeholders in the given messagePattern with arguments.\r\n     *\r\n     * @param messagePattern the message pattern containing placeholders.\r\n     * @param arguments      the arguments to be used to replace placeholders.\r\n     * @return the formatted message.\r\n     */\r\n    public static String format(String messagePattern, String[] arguments) {\r\n        if (messagePattern == null || arguments == null || arguments.length == 0) {\r\n            return messagePattern;\r\n        }\r\n        StringBuilder result = new StringBuilder();\r\n        int escapeCounter = 0;\r\n        int currentArgument = 0;\r\n        for (int i = 0; i < messagePattern.length(); i++) {\r\n            char curChar = messagePattern.charAt(i);\r\n            if (curChar == ESCAPE_CHAR) {\r\n                escapeCounter++;\r\n            } else {\r\n                if (curChar == DELIM_START) {\r\n                    if (i < messagePattern.length() - 1) {\r\n                        if (messagePattern.charAt(i + 1) == DELIM_STOP) {\r\n                            // write escaped escape chars\r\n                            int escapedEscapes = escapeCounter / 2;\r\n                            for (int j = 0; j < escapedEscapes; j++) {\r\n                                result.append(ESCAPE_CHAR);\r\n                            }\r\n                            if (escapeCounter % 2 == 1) {\r\n                                // i.e. escaped\r\n                                // write escaped escape chars\r\n                                result.append(DELIM_START);\r\n                                result.append(DELIM_STOP);\r\n                            } else {\r\n                                // unescaped\r\n                                if (currentArgument < arguments.length) {\r\n                                    result.append(arguments[currentArgument]);\r\n                                } else {\r\n                                    result.append(DELIM_START).append(DELIM_STOP);\r\n                                }\r\n                                currentArgument++;\r\n                            }\r\n                            i++;\r\n                            escapeCounter = 0;\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n                // any other char beside ESCAPE or DELIM_START/STOP-combo\r\n                // write unescaped escape chars\r\n                if (escapeCounter > 0) {\r\n                    for (int j = 0; j < escapeCounter; j++) {\r\n                        result.append(ESCAPE_CHAR);\r\n                    }\r\n                    escapeCounter = 0;\r\n                }\r\n                result.append(curChar);\r\n            }\r\n        }\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Counts the number of unescaped placeholders in the given messagePattern.\r\n     *\r\n     * @param messagePattern the message pattern to be analyzed.\r\n     * @return the number of unescaped placeholders.\r\n     */\r\n    public static int countArgumentPlaceholders(String messagePattern) {\r\n        if (messagePattern == null) {\r\n            return 0;\r\n        }\r\n        int delim = messagePattern.indexOf(DELIM_START);\r\n        if (delim == -1) {\r\n            // special case, no placeholders at all.\r\n            return 0;\r\n        }\r\n        int result = 0;\r\n        boolean isEscaped = false;\r\n        for (int i = 0; i < messagePattern.length(); i++) {\r\n            char curChar = messagePattern.charAt(i);\r\n            if (curChar == ESCAPE_CHAR) {\r\n                isEscaped = !isEscaped;\r\n            } else if (curChar == DELIM_START) {\r\n                if (!isEscaped) {\r\n                    if (i < messagePattern.length() - 1) {\r\n                        if (messagePattern.charAt(i + 1) == DELIM_STOP) {\r\n                            result++;\r\n                            i++;\r\n                        }\r\n                    }\r\n                }\r\n                isEscaped = false;\r\n            } else {\r\n                isEscaped = false;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * <p>This method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String\r\n     * as well as an optional Throwable.</p>\r\n     * <p/>\r\n     * <p>If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned\r\n     * in MessageFormatter.ArgumentResult.getThrowable() and won't be contained in the created String[].<br/>\r\n     * If it is used up getThrowable will return null even if the last argument was a Throwable!</p>\r\n     *\r\n     * @param messagePattern the message pattern that to be checked for placeholders.\r\n     * @param arguments      the argument array to be converted.\r\n     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.\r\n     */\r\n    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments) {\r\n        if (arguments == null) {\r\n            return null;\r\n        }\r\n        int argsCount = countArgumentPlaceholders(messagePattern);\r\n        int resultArgCount = arguments.length;\r\n        Throwable throwable = null;\r\n        if (argsCount < arguments.length) {\r\n            if (arguments[arguments.length - 1] instanceof Throwable) {\r\n                throwable = (Throwable) arguments[arguments.length - 1];\r\n                resultArgCount--;\r\n            }\r\n        }\r\n        String[] stringArgs;\r\n        if (argsCount == 1 && throwable == null && arguments.length > 1) {\r\n            // special case\r\n            stringArgs = new String[1];\r\n            stringArgs[0] = deepToString(arguments);\r\n        } else {\r\n            stringArgs = new String[resultArgCount];\r\n            for (int i = 0; i < stringArgs.length; i++) {\r\n                stringArgs[i] = deepToString(arguments[i]);\r\n            }\r\n        }\r\n        return new ArgumentResult(stringArgs, throwable);\r\n    }\r\n\r\n    public static String deepToString(Object o) {\r\n        if (o == null) {\r\n            return null;\r\n        }\r\n        if (o instanceof String) {\r\n            return (String) o;\r\n        }\r\n        StringBuilder str = new StringBuilder();\r\n        // that's actually a neat name ;)\r\n        Set<String> dejaVu = new HashSet<String>();\r\n        recursiveDeepToString(o, str, dejaVu);\r\n        return str.toString();\r\n    }\r\n\r\n    /**\r\n     * This method performs a deep toString of the given Object.\r\n     * Primitive arrays are converted using their respective Arrays.toString methods while\r\n     * special handling is implemented for \"container types\", i.e. Object[], Map and Collection because those could\r\n     * contain themselves.\r\n     * <p/>\r\n     * dejaVu is used in case of those container types to prevent an endless recursion.\r\n     * <p/>\r\n     * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior.\r\n     * They only check if the container is directly contained in itself, but not if a contained container contains the\r\n     * original one. Because of that, Arrays.toString(Object[]) isn't safe either.\r\n     * Confusing? Just read the last paragraph again and check the respective toString() implementation.\r\n     * <p/>\r\n     * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)\r\n     * would produce a relatively hard-to-debug StackOverflowError.\r\n     *\r\n     * @param o      the Object to convert into a String\r\n     * @param str    the StringBuilder that o will be appended to\r\n     * @param dejaVu a list of container identities that were already used.\r\n     */\r\n    private static void recursiveDeepToString(Object o, StringBuilder str, Set<String> dejaVu) {\r\n        if (o == null) {\r\n            str.append(\"null\");\r\n            return;\r\n        }\r\n        if (o instanceof String) {\r\n            str.append(o);\r\n            return;\r\n        }\r\n        Class oClass = o.getClass();\r\n        if (oClass.isArray()) {\r\n            if (oClass == byte[].class) {\r\n                str.append(Arrays.toString((byte[]) o));\r\n            } else if (oClass == short[].class) {\r\n                str.append(Arrays.toString((short[]) o));\r\n            } else if (oClass == int[].class) {\r\n                str.append(Arrays.toString((int[]) o));\r\n            } else if (oClass == long[].class) {\r\n                str.append(Arrays.toString((long[]) o));\r\n            } else if (oClass == float[].class) {\r\n                str.append(Arrays.toString((float[]) o));\r\n            } else if (oClass == double[].class) {\r\n                str.append(Arrays.toString((double[]) o));\r\n            } else if (oClass == boolean[].class) {\r\n                str.append(Arrays.toString((boolean[]) o));\r\n            } else if (oClass == char[].class) {\r\n                str.append(Arrays.toString((char[]) o));\r\n            } else {\r\n                // special handling of container Object[]\r\n                String id = identityToString(o);\r\n                if (dejaVu.contains(id)) {\r\n                    str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n                } else {\r\n                    dejaVu.add(id);\r\n                    Object[] oArray = (Object[]) o;\r\n                    str.append(\"[\");\r\n                    boolean first = true;\r\n                    for (Object current : oArray) {\r\n                        if (first) {\r\n                            first = false;\r\n                        } else {\r\n                            str.append(\", \");\r\n                        }\r\n                        recursiveDeepToString(current, str, new HashSet<String>(dejaVu));\r\n                    }\r\n                    str.append(\"]\");\r\n                }\r\n                //str.append(Arrays.deepToString((Object[]) o));\r\n            }\r\n        } else if (o instanceof Map) {\r\n            // special handling of container Map\r\n            String id = identityToString(o);\r\n            if (dejaVu.contains(id)) {\r\n                str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n            } else {\r\n                dejaVu.add(id);\r\n                Map<?, ?> oMap = (Map<?, ?>) o;\r\n                str.append(\"{\");\r\n                boolean isFirst = true;\r\n                for (Map.Entry<?, ?> current : oMap.entrySet()) {\r\n                    if (isFirst) {\r\n                        isFirst = false;\r\n                    } else {\r\n                        str.append(\", \");\r\n                    }\r\n                    Object key = current.getKey();\r\n                    Object value = current.getValue();\r\n                    recursiveDeepToString(key, str, new HashSet<String>(dejaVu));\r\n                    str.append(\"=\");\r\n                    recursiveDeepToString(value, str, new HashSet<String>(dejaVu));\r\n                }\r\n                str.append(\"}\");\r\n            }\r\n        } else if (o instanceof Collection) {\r\n            // special handling of container Collection\r\n            String id = identityToString(o);\r\n            if (dejaVu.contains(id)) {\r\n                str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n            } else {\r\n                dejaVu.add(id);\r\n                Collection<?> oCol = (Collection<?>) o;\r\n                str.append(\"[\");\r\n                boolean isFirst = true;\r\n                for (Object current : oCol) {\r\n                    if (isFirst) {\r\n                        isFirst = false;\r\n                    } else {\r\n                        str.append(\", \");\r\n                    }\r\n                    recursiveDeepToString(current, str, new HashSet<String>(dejaVu));\r\n                }\r\n                str.append(\"]\");\r\n            }\r\n        } else if (o instanceof Date) {\r\n            Date date = (Date) o;\r\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\");\r\n            // I'll leave it like this for the moment... this could probably be optimized using ThreadLocal...\r\n            str.append(format.format(date));\r\n        } else {\r\n            // it's just some other Object, we can only use toString().\r\n            try {\r\n                str.append(o.toString());\r\n            } catch (Throwable t) {\r\n                str.append(ERROR_PREFIX);\r\n                str.append(identityToString(o));\r\n                str.append(ERROR_SEPARATOR);\r\n                String msg = t.getMessage();\r\n                String className = t.getClass().getName();\r\n                str.append(className);\r\n                if (!className.equals(msg)) {\r\n                    str.append(ERROR_MSG_SEPARATOR);\r\n                    str.append(msg);\r\n                }\r\n                str.append(ERROR_SUFFIX);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method returns the same as if Object.toString() would not have been\r\n     * overridden in obj.\r\n     * <p/>\r\n     * Note that this isn't 100% secure as collisions can always happen with hash codes.\r\n     * <p/>\r\n     * Copied from Object.hashCode():\r\n     * As much as is reasonably practical, the hashCode method defined by\r\n     * class <tt>Object</tt> does return distinct integers for distinct\r\n     * objects. (This is typically implemented by converting the internal\r\n     * address of the object into an integer, but this implementation\r\n     * technique is not required by the\r\n     * Java<font size=\"-2\"><sup>TM</sup></font> programming language.)\r\n     *\r\n     * @param obj the Object that is to be converted into an identity string.\r\n     * @return the identity string as also defined in Object.toString()\r\n     */\r\n    public static String identityToString(Object obj) {\r\n        if (obj == null) {\r\n            return null;\r\n        }\r\n        return obj.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(obj));\r\n    }\r\n\r\n    /**\r\n     * <p>This is just a simple class containing the result of an evaluateArgument call. It's necessary because we need to\r\n     * return two results, i.e. the resulting String[] and the optional Throwable.</p>\r\n     * <p/>\r\n     * <p>This class is not Serializable because serializing a Throwable is generally a bad idea if the data is supposed\r\n     * to leave the current VM since it may result in ClassNotFoundExceptions if the given Throwable is not\r\n     * available/different in the deserializing VM.</p>\r\n     */\r\n    public static class ArgumentResult {\r\n\r\n        private Throwable throwable;\r\n\r\n        private String[] arguments;\r\n\r\n        public ArgumentResult(String[] arguments, Throwable throwable) {\r\n            this.throwable = throwable;\r\n            this.arguments = arguments;\r\n        }\r\n\r\n        public Throwable getThrowable() {\r\n            return throwable;\r\n        }\r\n\r\n        public String[] getArguments() {\r\n            return arguments;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            StringBuilder result = new StringBuilder();\r\n            result.append(\"ArgumentResult[throwable=\").append(throwable);\r\n            result.append(\", arguments=\");\r\n            if (arguments != null) {\r\n                result.append(\"[\");\r\n                boolean isFirst = true;\r\n                for (String current : arguments) {\r\n                    if (!isFirst) {\r\n                        result.append(\", \");\r\n                    } else {\r\n                        isFirst = false;\r\n                    }\r\n                    if (current != null) {\r\n                        result.append(\"'\").append(current).append(\"'\");\r\n                    } else {\r\n                        result.append(\"null\");\r\n                    }\r\n                }\r\n                result.append(\"]\");\r\n            }\r\n            return result.toString();\r\n        }\r\n\r\n        public boolean equals(Object o) {\r\n            if (this == o)\r\n                return true;\r\n            if (o == null || getClass() != o.getClass())\r\n                return false;\r\n            ArgumentResult result = (ArgumentResult) o;\r\n            if (!Arrays.equals(arguments, result.arguments))\r\n                return false;\r\n            if (throwable != null ? !throwable.equals(result.throwable) : result.throwable != null)\r\n                return false;\r\n            return true;\r\n        }\r\n\r\n        public int hashCode() {\r\n            int result;\r\n            result = (throwable != null ? throwable.hashCode() : 0);\r\n            result = 31 * result + (arguments != null ? Arrays.hashCode(arguments) : 0);\r\n            return result;\r\n        }\r\n    }\r\n}\r\n",
    "test_prompt": "// MessageFormatter_0Test.java\npackage de.huxhorn.lilith.data.logging;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MessageFormatter}.\n* It contains ten unit test cases for the {@link MessageFormatter#format(String, String[])} method.\n*/\nclass MessageFormatter_0Test {"
},
{
    "id": "cmpl-6wSHfhOa9SZtpUJnaGvHqE4xjaUyU",
    "object": "text_completion",
    "created": 1679389767,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_null() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(null);\n\t\t\t\tassertEquals(0, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_empty() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"\");\n\t\t\t\tassertEquals(0, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_noPlaceholders() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello World!\");\n\t\t\t\tassertEquals(0, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_onePlaceholder() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello {}!\");\n\t\t\t\tassertEquals(1, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_twoPlaceholders() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello {}! {}\");\n\t\t\t\tassertEquals(2, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\{}!\");\n\t\t\t\tassertEquals(0, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder2() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\{}!\");\n\t\t\t\tassertEquals(1, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder3() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\\\\\{}!\");\n\t\t\t\tassertEquals(0, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder4() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\\\\\\\\\{}!\");\n\t\t\t\tassertEquals(1, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder5() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\\\\\\\\\{}!\");\n\t\t\t\tassertEquals(1, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder6() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\\\\\\\\\{}!\");\n\t\t\t\tassertEquals(1, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder7() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\\\\\\\\\{}!\");\n\t\t\t\tassertEquals(1, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder8() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\\\\\\\\\{}!\");\n\t\t\t\tassertEquals(1, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder9() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\\\\\\\\\{}!\");\n\t\t\t\tassertEquals(1, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder10() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\\\\\\\\\{}!\");\n\t\t\t\tassertEquals(1, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder11() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\\\\\\\\\{}!\");\n\t\t\t\tassertEquals(1, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder12() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\\\\\\\\\{}!\");\n\t\t\t\tassertEquals(1, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder13() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\\\\\\\\\{}!\");\n\t\t\t\tassertEquals(1, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder14() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\\\\\\\\\{}!\");\n\t\t\t\tassertEquals(1, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder15() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\\\\\\\\\{}!\");\n\t\t\t\tassertEquals(1, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder16() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\\\\\\\\\{}!\");\n\t\t\t\tassertEquals(1, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder17() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\\\\\\\\\{}!\");\n\t\t\t\tassertEquals(1, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder18() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\\\\\\\\\{}!\");\n\t\t\t\tassertEquals(1, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder19() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\\\\\\\\\{}!\");\n\t\t\t\tassertEquals(1, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder20() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\\\\\\\\\{}!\");\n\t\t\t\tassertEquals(1, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder21() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\\\\\\\\\{}!\");\n\t\t\t\tassertEquals(1, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder22() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\\\\\\\\\{}!\");\n\t\t\t\tassertEquals(1, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder23() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\\\\\\\\\{}!\");\n\t\t\t\tassertEquals(1, result);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testCountArgumentPlaceholders_escapedPlaceholder24() {\n\t\t\t\tint result = MessageFormatter.countArgumentPlaceholders(\"Hello \\\\\\\\\\\\\\\\{}!\");\n\t\t\t\tassertEquals(1",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 5265,
        "completion_tokens": 2000,
        "total_tokens": 7265
    },
    "time_taken": 62.453726053237915,
    "prompt_id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_1Test.java",
    "original_code": "// MessageFormatter.java\n/*\r\n * Lilith - a log event viewer.\r\n * Copyright (C) 2007-2009 Joern Huxhorn\r\n * \r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.huxhorn.lilith.data.logging;\r\n\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Arrays;\r\nimport java.util.Collection;\r\nimport java.util.Date;\r\nimport java.util.HashSet;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n/**\r\n * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>\r\n * <p>\r\n * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message\r\n * is split into three parts:\r\n * </p>\r\n * <ol>\r\n * <li>Counting of placeholders in the message pattern (cheap)</li>\r\n * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as\r\n * an optional Throwable if available (relatively cheap)</li>\r\n * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>\r\n * </ol>\r\n * <p>\r\n * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the\r\n * actual construction of the message, is only done on demand.\r\n * </p>\r\n */\r\npublic class MessageFormatter {\r\n\r\n    private static final char DELIM_START = '{';\r\n\r\n    private static final char DELIM_STOP = '}';\r\n\r\n    private static final char ESCAPE_CHAR = '\\\\';\r\n\r\n    public static final String RECURSION_PREFIX = \"[...\";\r\n\r\n    public static final String RECURSION_SUFFIX = \"...]\";\r\n\r\n    public static final String ERROR_PREFIX = \"[!!!\";\r\n\r\n    public static final String ERROR_SEPARATOR = \"=>\";\r\n\r\n    public static final String ERROR_MSG_SEPARATOR = \":\";\r\n\r\n    public static final String ERROR_SUFFIX = \"!!!]\";\r\n\r\n    /**\r\n     * Replace placeholders in the given messagePattern with arguments.\r\n     *\r\n     * @param messagePattern the message pattern containing placeholders.\r\n     * @param arguments      the arguments to be used to replace placeholders.\r\n     * @return the formatted message.\r\n     */\r\n    public static String format(String messagePattern, String[] arguments) {\r\n        if (messagePattern == null || arguments == null || arguments.length == 0) {\r\n            return messagePattern;\r\n        }\r\n        StringBuilder result = new StringBuilder();\r\n        int escapeCounter = 0;\r\n        int currentArgument = 0;\r\n        for (int i = 0; i < messagePattern.length(); i++) {\r\n            char curChar = messagePattern.charAt(i);\r\n            if (curChar == ESCAPE_CHAR) {\r\n                escapeCounter++;\r\n            } else {\r\n                if (curChar == DELIM_START) {\r\n                    if (i < messagePattern.length() - 1) {\r\n                        if (messagePattern.charAt(i + 1) == DELIM_STOP) {\r\n                            // write escaped escape chars\r\n                            int escapedEscapes = escapeCounter / 2;\r\n                            for (int j = 0; j < escapedEscapes; j++) {\r\n                                result.append(ESCAPE_CHAR);\r\n                            }\r\n                            if (escapeCounter % 2 == 1) {\r\n                                // i.e. escaped\r\n                                // write escaped escape chars\r\n                                result.append(DELIM_START);\r\n                                result.append(DELIM_STOP);\r\n                            } else {\r\n                                // unescaped\r\n                                if (currentArgument < arguments.length) {\r\n                                    result.append(arguments[currentArgument]);\r\n                                } else {\r\n                                    result.append(DELIM_START).append(DELIM_STOP);\r\n                                }\r\n                                currentArgument++;\r\n                            }\r\n                            i++;\r\n                            escapeCounter = 0;\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n                // any other char beside ESCAPE or DELIM_START/STOP-combo\r\n                // write unescaped escape chars\r\n                if (escapeCounter > 0) {\r\n                    for (int j = 0; j < escapeCounter; j++) {\r\n                        result.append(ESCAPE_CHAR);\r\n                    }\r\n                    escapeCounter = 0;\r\n                }\r\n                result.append(curChar);\r\n            }\r\n        }\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Counts the number of unescaped placeholders in the given messagePattern.\r\n     *\r\n     * @param messagePattern the message pattern to be analyzed.\r\n     * @return the number of unescaped placeholders.\r\n     */\r\n    public static int countArgumentPlaceholders(String messagePattern) {\r\n        if (messagePattern == null) {\r\n            return 0;\r\n        }\r\n        int delim = messagePattern.indexOf(DELIM_START);\r\n        if (delim == -1) {\r\n            // special case, no placeholders at all.\r\n            return 0;\r\n        }\r\n        int result = 0;\r\n        boolean isEscaped = false;\r\n        for (int i = 0; i < messagePattern.length(); i++) {\r\n            char curChar = messagePattern.charAt(i);\r\n            if (curChar == ESCAPE_CHAR) {\r\n                isEscaped = !isEscaped;\r\n            } else if (curChar == DELIM_START) {\r\n                if (!isEscaped) {\r\n                    if (i < messagePattern.length() - 1) {\r\n                        if (messagePattern.charAt(i + 1) == DELIM_STOP) {\r\n                            result++;\r\n                            i++;\r\n                        }\r\n                    }\r\n                }\r\n                isEscaped = false;\r\n            } else {\r\n                isEscaped = false;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * <p>This method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String\r\n     * as well as an optional Throwable.</p>\r\n     * <p/>\r\n     * <p>If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned\r\n     * in MessageFormatter.ArgumentResult.getThrowable() and won't be contained in the created String[].<br/>\r\n     * If it is used up getThrowable will return null even if the last argument was a Throwable!</p>\r\n     *\r\n     * @param messagePattern the message pattern that to be checked for placeholders.\r\n     * @param arguments      the argument array to be converted.\r\n     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.\r\n     */\r\n    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments) {\r\n        if (arguments == null) {\r\n            return null;\r\n        }\r\n        int argsCount = countArgumentPlaceholders(messagePattern);\r\n        int resultArgCount = arguments.length;\r\n        Throwable throwable = null;\r\n        if (argsCount < arguments.length) {\r\n            if (arguments[arguments.length - 1] instanceof Throwable) {\r\n                throwable = (Throwable) arguments[arguments.length - 1];\r\n                resultArgCount--;\r\n            }\r\n        }\r\n        String[] stringArgs;\r\n        if (argsCount == 1 && throwable == null && arguments.length > 1) {\r\n            // special case\r\n            stringArgs = new String[1];\r\n            stringArgs[0] = deepToString(arguments);\r\n        } else {\r\n            stringArgs = new String[resultArgCount];\r\n            for (int i = 0; i < stringArgs.length; i++) {\r\n                stringArgs[i] = deepToString(arguments[i]);\r\n            }\r\n        }\r\n        return new ArgumentResult(stringArgs, throwable);\r\n    }\r\n\r\n    public static String deepToString(Object o) {\r\n        if (o == null) {\r\n            return null;\r\n        }\r\n        if (o instanceof String) {\r\n            return (String) o;\r\n        }\r\n        StringBuilder str = new StringBuilder();\r\n        // that's actually a neat name ;)\r\n        Set<String> dejaVu = new HashSet<String>();\r\n        recursiveDeepToString(o, str, dejaVu);\r\n        return str.toString();\r\n    }\r\n\r\n    /**\r\n     * This method performs a deep toString of the given Object.\r\n     * Primitive arrays are converted using their respective Arrays.toString methods while\r\n     * special handling is implemented for \"container types\", i.e. Object[], Map and Collection because those could\r\n     * contain themselves.\r\n     * <p/>\r\n     * dejaVu is used in case of those container types to prevent an endless recursion.\r\n     * <p/>\r\n     * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior.\r\n     * They only check if the container is directly contained in itself, but not if a contained container contains the\r\n     * original one. Because of that, Arrays.toString(Object[]) isn't safe either.\r\n     * Confusing? Just read the last paragraph again and check the respective toString() implementation.\r\n     * <p/>\r\n     * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)\r\n     * would produce a relatively hard-to-debug StackOverflowError.\r\n     *\r\n     * @param o      the Object to convert into a String\r\n     * @param str    the StringBuilder that o will be appended to\r\n     * @param dejaVu a list of container identities that were already used.\r\n     */\r\n    private static void recursiveDeepToString(Object o, StringBuilder str, Set<String> dejaVu) {\r\n        if (o == null) {\r\n            str.append(\"null\");\r\n            return;\r\n        }\r\n        if (o instanceof String) {\r\n            str.append(o);\r\n            return;\r\n        }\r\n        Class oClass = o.getClass();\r\n        if (oClass.isArray()) {\r\n            if (oClass == byte[].class) {\r\n                str.append(Arrays.toString((byte[]) o));\r\n            } else if (oClass == short[].class) {\r\n                str.append(Arrays.toString((short[]) o));\r\n            } else if (oClass == int[].class) {\r\n                str.append(Arrays.toString((int[]) o));\r\n            } else if (oClass == long[].class) {\r\n                str.append(Arrays.toString((long[]) o));\r\n            } else if (oClass == float[].class) {\r\n                str.append(Arrays.toString((float[]) o));\r\n            } else if (oClass == double[].class) {\r\n                str.append(Arrays.toString((double[]) o));\r\n            } else if (oClass == boolean[].class) {\r\n                str.append(Arrays.toString((boolean[]) o));\r\n            } else if (oClass == char[].class) {\r\n                str.append(Arrays.toString((char[]) o));\r\n            } else {\r\n                // special handling of container Object[]\r\n                String id = identityToString(o);\r\n                if (dejaVu.contains(id)) {\r\n                    str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n                } else {\r\n                    dejaVu.add(id);\r\n                    Object[] oArray = (Object[]) o;\r\n                    str.append(\"[\");\r\n                    boolean first = true;\r\n                    for (Object current : oArray) {\r\n                        if (first) {\r\n                            first = false;\r\n                        } else {\r\n                            str.append(\", \");\r\n                        }\r\n                        recursiveDeepToString(current, str, new HashSet<String>(dejaVu));\r\n                    }\r\n                    str.append(\"]\");\r\n                }\r\n                //str.append(Arrays.deepToString((Object[]) o));\r\n            }\r\n        } else if (o instanceof Map) {\r\n            // special handling of container Map\r\n            String id = identityToString(o);\r\n            if (dejaVu.contains(id)) {\r\n                str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n            } else {\r\n                dejaVu.add(id);\r\n                Map<?, ?> oMap = (Map<?, ?>) o;\r\n                str.append(\"{\");\r\n                boolean isFirst = true;\r\n                for (Map.Entry<?, ?> current : oMap.entrySet()) {\r\n                    if (isFirst) {\r\n                        isFirst = false;\r\n                    } else {\r\n                        str.append(\", \");\r\n                    }\r\n                    Object key = current.getKey();\r\n                    Object value = current.getValue();\r\n                    recursiveDeepToString(key, str, new HashSet<String>(dejaVu));\r\n                    str.append(\"=\");\r\n                    recursiveDeepToString(value, str, new HashSet<String>(dejaVu));\r\n                }\r\n                str.append(\"}\");\r\n            }\r\n        } else if (o instanceof Collection) {\r\n            // special handling of container Collection\r\n            String id = identityToString(o);\r\n            if (dejaVu.contains(id)) {\r\n                str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n            } else {\r\n                dejaVu.add(id);\r\n                Collection<?> oCol = (Collection<?>) o;\r\n                str.append(\"[\");\r\n                boolean isFirst = true;\r\n                for (Object current : oCol) {\r\n                    if (isFirst) {\r\n                        isFirst = false;\r\n                    } else {\r\n                        str.append(\", \");\r\n                    }\r\n                    recursiveDeepToString(current, str, new HashSet<String>(dejaVu));\r\n                }\r\n                str.append(\"]\");\r\n            }\r\n        } else if (o instanceof Date) {\r\n            Date date = (Date) o;\r\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\");\r\n            // I'll leave it like this for the moment... this could probably be optimized using ThreadLocal...\r\n            str.append(format.format(date));\r\n        } else {\r\n            // it's just some other Object, we can only use toString().\r\n            try {\r\n                str.append(o.toString());\r\n            } catch (Throwable t) {\r\n                str.append(ERROR_PREFIX);\r\n                str.append(identityToString(o));\r\n                str.append(ERROR_SEPARATOR);\r\n                String msg = t.getMessage();\r\n                String className = t.getClass().getName();\r\n                str.append(className);\r\n                if (!className.equals(msg)) {\r\n                    str.append(ERROR_MSG_SEPARATOR);\r\n                    str.append(msg);\r\n                }\r\n                str.append(ERROR_SUFFIX);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method returns the same as if Object.toString() would not have been\r\n     * overridden in obj.\r\n     * <p/>\r\n     * Note that this isn't 100% secure as collisions can always happen with hash codes.\r\n     * <p/>\r\n     * Copied from Object.hashCode():\r\n     * As much as is reasonably practical, the hashCode method defined by\r\n     * class <tt>Object</tt> does return distinct integers for distinct\r\n     * objects. (This is typically implemented by converting the internal\r\n     * address of the object into an integer, but this implementation\r\n     * technique is not required by the\r\n     * Java<font size=\"-2\"><sup>TM</sup></font> programming language.)\r\n     *\r\n     * @param obj the Object that is to be converted into an identity string.\r\n     * @return the identity string as also defined in Object.toString()\r\n     */\r\n    public static String identityToString(Object obj) {\r\n        if (obj == null) {\r\n            return null;\r\n        }\r\n        return obj.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(obj));\r\n    }\r\n\r\n    /**\r\n     * <p>This is just a simple class containing the result of an evaluateArgument call. It's necessary because we need to\r\n     * return two results, i.e. the resulting String[] and the optional Throwable.</p>\r\n     * <p/>\r\n     * <p>This class is not Serializable because serializing a Throwable is generally a bad idea if the data is supposed\r\n     * to leave the current VM since it may result in ClassNotFoundExceptions if the given Throwable is not\r\n     * available/different in the deserializing VM.</p>\r\n     */\r\n    public static class ArgumentResult {\r\n\r\n        private Throwable throwable;\r\n\r\n        private String[] arguments;\r\n\r\n        public ArgumentResult(String[] arguments, Throwable throwable) {\r\n            this.throwable = throwable;\r\n            this.arguments = arguments;\r\n        }\r\n\r\n        public Throwable getThrowable() {\r\n            return throwable;\r\n        }\r\n\r\n        public String[] getArguments() {\r\n            return arguments;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            StringBuilder result = new StringBuilder();\r\n            result.append(\"ArgumentResult[throwable=\").append(throwable);\r\n            result.append(\", arguments=\");\r\n            if (arguments != null) {\r\n                result.append(\"[\");\r\n                boolean isFirst = true;\r\n                for (String current : arguments) {\r\n                    if (!isFirst) {\r\n                        result.append(\", \");\r\n                    } else {\r\n                        isFirst = false;\r\n                    }\r\n                    if (current != null) {\r\n                        result.append(\"'\").append(current).append(\"'\");\r\n                    } else {\r\n                        result.append(\"null\");\r\n                    }\r\n                }\r\n                result.append(\"]\");\r\n            }\r\n            return result.toString();\r\n        }\r\n\r\n        public boolean equals(Object o) {\r\n            if (this == o)\r\n                return true;\r\n            if (o == null || getClass() != o.getClass())\r\n                return false;\r\n            ArgumentResult result = (ArgumentResult) o;\r\n            if (!Arrays.equals(arguments, result.arguments))\r\n                return false;\r\n            if (throwable != null ? !throwable.equals(result.throwable) : result.throwable != null)\r\n                return false;\r\n            return true;\r\n        }\r\n\r\n        public int hashCode() {\r\n            int result;\r\n            result = (throwable != null ? throwable.hashCode() : 0);\r\n            result = 31 * result + (arguments != null ? Arrays.hashCode(arguments) : 0);\r\n            return result;\r\n        }\r\n    }\r\n}\r\n",
    "test_prompt": "// MessageFormatter_1Test.java\npackage de.huxhorn.lilith.data.logging;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MessageFormatter}.\n* It contains ten unit test cases for the {@link MessageFormatter#countArgumentPlaceholders(String)} method.\n*/\nclass MessageFormatter_1Test {"
},
{
    "id": "cmpl-6wSIgGKS3SkxEJGqVJscBJrTqQDIx",
    "object": "text_completion",
    "created": 1679389830,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\t@Test\n\t\tpublic void testEvaluateArguments() {\n\t\t\t\tString messagePattern = \"This is a test.\";\n\t\t\t\tObject[] arguments = new Object[] { \"foo\", \"bar\" };\n\t\t\t\tMessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);\n\t\t\t\tassertNotNull(result);\n\t\t\t\tassertNull(result.getThrowable());\n\t\t\t\tassertNotNull(result.getArguments());\n\t\t\t\tassertEquals(2, result.getArguments().length);\n\t\t\t\tassertEquals(\"foo\", result.getArguments()[0]);\n\t\t\t\tassertEquals(\"bar\", result.getArguments()[1]);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testEvaluateArguments_2() {\n\t\t\t\tString messagePattern = \"This is a test.\";\n\t\t\t\tObject[] arguments = new Object[] { \"foo\", \"bar\", new Throwable(\"Test\") };\n\t\t\t\tMessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);\n\t\t\t\tassertNotNull(result);\n\t\t\t\tassertNotNull(result.getThrowable());\n\t\t\t\tassertEquals(\"Test\", result.getThrowable().getMessage());\n\t\t\t\tassertNotNull(result.getArguments());\n\t\t\t\tassertEquals(2, result.getArguments().length);\n\t\t\t\tassertEquals(\"foo\", result.getArguments()[0]);\n\t\t\t\tassertEquals(\"bar\", result.getArguments()[1]);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testEvaluateArguments_3() {\n\t\t\t\tString messagePattern = \"This is a test.\";\n\t\t\t\tObject[] arguments = new Object[] { \"foo\", \"bar\", new Throwable(\"Test\"), \"baz\" };\n\t\t\t\tMessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);\n\t\t\t\tassertNotNull(result);\n\t\t\t\tassertNull(result.getThrowable());\n\t\t\t\tassertNotNull(result.getArguments());\n\t\t\t\tassertEquals(3, result.getArguments().length);\n\t\t\t\tassertEquals(\"foo\", result.getArguments()[0]);\n\t\t\t\tassertEquals(\"bar\", result.getArguments()[1]);\n\t\t\t\tassertEquals(\"baz\", result.getArguments()[2]);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testEvaluateArguments_4() {\n\t\t\t\tString messagePattern = \"This is a test.\";\n\t\t\t\tObject[] arguments = new Object[] { \"foo\", \"bar\", new Throwable(\"Test\"), \"baz\", \"bam\" };\n\t\t\t\tMessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);\n\t\t\t\tassertNotNull(result);\n\t\t\t\tassertNotNull(result.getThrowable());\n\t\t\t\tassertEquals(\"Test\", result.getThrowable().getMessage());\n\t\t\t\tassertNotNull(result.getArguments());\n\t\t\t\tassertEquals(3, result.getArguments().length);\n\t\t\t\tassertEquals(\"foo\", result.getArguments()[0]);\n\t\t\t\tassertEquals(\"bar\", result.getArguments()[1]);\n\t\t\t\tassertEquals(\"baz\", result.getArguments()[2]);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testEvaluateArguments_5() {\n\t\t\t\tString messagePattern = \"This is a test.\";\n\t\t\t\tObject[] arguments = new Object[] { \"foo\", \"bar\", new Throwable(\"Test\"), \"baz\", \"bam\", \"bim\" };\n\t\t\t\tMessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);\n\t\t\t\tassertNotNull(result);\n\t\t\t\tassertNotNull(result.getThrowable());\n\t\t\t\tassertEquals(\"Test\", result.getThrowable().getMessage());\n\t\t\t\tassertNotNull(result.getArguments());\n\t\t\t\tassertEquals(3, result.getArguments().length);\n\t\t\t\tassertEquals(\"foo\", result.getArguments()[0]);\n\t\t\t\tassertEquals(\"bar\", result.getArguments()[1]);\n\t\t\t\tassertEquals(\"baz\", result.getArguments()[2]);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testEvaluateArguments_6() {\n\t\t\t\tString messagePattern = \"This is a test.\";\n\t\t\t\tObject[] arguments = new Object[] { \"foo\", \"bar\", new Throwable(\"Test\"), \"baz\", \"bam\", \"bim\", \"bop\" };\n\t\t\t\tMessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);\n\t\t\t\tassertNotNull(result);\n\t\t\t\tassertNotNull(result.getThrowable());\n\t\t\t\tassertEquals(\"Test\", result.getThrowable().getMessage());\n\t\t\t\tassertNotNull(result.getArguments());\n\t\t\t\tassertEquals(3, result.getArguments().length);\n\t\t\t\tassertEquals(\"foo\", result.getArguments()[0]);\n\t\t\t\tassertEquals(\"bar\", result.getArguments()[1]);\n\t\t\t\tassertEquals(\"baz\", result.getArguments()[2]);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testEvaluateArguments_7() {\n\t\t\t\tString messagePattern = \"This is a test.\";\n\t\t\t\tObject[] arguments = new Object[] { \"foo\", \"bar\", new Throwable(\"Test\"), \"baz\", \"bam\", \"bim\", \"bop\", \"bap\" };\n\t\t\t\tMessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);\n\t\t\t\tassertNotNull(result);\n\t\t\t\tassertNotNull(result.getThrowable());\n\t\t\t\tassertEquals(\"Test\", result.getThrowable().getMessage());\n\t\t\t\tassertNotNull(result.getArguments());\n\t\t\t\tassertEquals(3, result.getArguments().length);\n\t\t\t\tassertEquals(\"foo\", result.getArguments()[0]);\n\t\t\t\tassertEquals(\"bar\", result.getArguments()[1]);\n\t\t\t\tassertEquals(\"baz\", result.getArguments()[2]);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testEvaluateArguments_8() {\n\t\t\t\tString messagePattern = \"This is a test.\";\n\t\t\t\tObject[] arguments = new Object[] { \"foo\", \"bar\", new Throwable(\"Test\"), \"baz\", \"bam\", \"bim\", \"bop\", \"bap\", \"bup\" };\n\t\t\t\tMessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(messagePattern, arguments);\n\t\t\t\tassertNotNull(result);\n\t\t\t\tassertNotNull(result.getThrowable());\n\t\t\t\tassertEquals(\"Test\", result.getThrowable().getMessage());\n\t\t\t\tassertNotNull(result.getArguments());\n\t\t\t\tassertEquals(3, result.getArguments().length);\n\t\t\t\tassertEquals(\"foo\", result.getArguments()[0]);\n\t\t\t\tassertEquals(\"bar\", result.getArguments()[1]);\n\t\t\t\tassertEquals(\"baz\", result.getArguments()[2]);\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testEvaluateArguments_9() {\n\t\t\t\tString messagePattern = \"This is a test.\";\n\t\t\t\tObject[] arguments = new Object[] { \"foo\", \"bar\", new Throwable(\"Test\"), \"baz\", \"bam\", \"bim\", \"bop\", \"bap\", \"bup\", \"bip\" };\n\t\t\t\tMessageFormatter.ArgumentResult result = MessageFormatter.evaluateArguments(",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 5267,
        "completion_tokens": 2000,
        "total_tokens": 7267
    },
    "time_taken": 76.83181548118591,
    "prompt_id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_2Test.java",
    "original_code": "// MessageFormatter.java\n/*\r\n * Lilith - a log event viewer.\r\n * Copyright (C) 2007-2009 Joern Huxhorn\r\n * \r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.huxhorn.lilith.data.logging;\r\n\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Arrays;\r\nimport java.util.Collection;\r\nimport java.util.Date;\r\nimport java.util.HashSet;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n/**\r\n * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>\r\n * <p>\r\n * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message\r\n * is split into three parts:\r\n * </p>\r\n * <ol>\r\n * <li>Counting of placeholders in the message pattern (cheap)</li>\r\n * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as\r\n * an optional Throwable if available (relatively cheap)</li>\r\n * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>\r\n * </ol>\r\n * <p>\r\n * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the\r\n * actual construction of the message, is only done on demand.\r\n * </p>\r\n */\r\npublic class MessageFormatter {\r\n\r\n    private static final char DELIM_START = '{';\r\n\r\n    private static final char DELIM_STOP = '}';\r\n\r\n    private static final char ESCAPE_CHAR = '\\\\';\r\n\r\n    public static final String RECURSION_PREFIX = \"[...\";\r\n\r\n    public static final String RECURSION_SUFFIX = \"...]\";\r\n\r\n    public static final String ERROR_PREFIX = \"[!!!\";\r\n\r\n    public static final String ERROR_SEPARATOR = \"=>\";\r\n\r\n    public static final String ERROR_MSG_SEPARATOR = \":\";\r\n\r\n    public static final String ERROR_SUFFIX = \"!!!]\";\r\n\r\n    /**\r\n     * Replace placeholders in the given messagePattern with arguments.\r\n     *\r\n     * @param messagePattern the message pattern containing placeholders.\r\n     * @param arguments      the arguments to be used to replace placeholders.\r\n     * @return the formatted message.\r\n     */\r\n    public static String format(String messagePattern, String[] arguments) {\r\n        if (messagePattern == null || arguments == null || arguments.length == 0) {\r\n            return messagePattern;\r\n        }\r\n        StringBuilder result = new StringBuilder();\r\n        int escapeCounter = 0;\r\n        int currentArgument = 0;\r\n        for (int i = 0; i < messagePattern.length(); i++) {\r\n            char curChar = messagePattern.charAt(i);\r\n            if (curChar == ESCAPE_CHAR) {\r\n                escapeCounter++;\r\n            } else {\r\n                if (curChar == DELIM_START) {\r\n                    if (i < messagePattern.length() - 1) {\r\n                        if (messagePattern.charAt(i + 1) == DELIM_STOP) {\r\n                            // write escaped escape chars\r\n                            int escapedEscapes = escapeCounter / 2;\r\n                            for (int j = 0; j < escapedEscapes; j++) {\r\n                                result.append(ESCAPE_CHAR);\r\n                            }\r\n                            if (escapeCounter % 2 == 1) {\r\n                                // i.e. escaped\r\n                                // write escaped escape chars\r\n                                result.append(DELIM_START);\r\n                                result.append(DELIM_STOP);\r\n                            } else {\r\n                                // unescaped\r\n                                if (currentArgument < arguments.length) {\r\n                                    result.append(arguments[currentArgument]);\r\n                                } else {\r\n                                    result.append(DELIM_START).append(DELIM_STOP);\r\n                                }\r\n                                currentArgument++;\r\n                            }\r\n                            i++;\r\n                            escapeCounter = 0;\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n                // any other char beside ESCAPE or DELIM_START/STOP-combo\r\n                // write unescaped escape chars\r\n                if (escapeCounter > 0) {\r\n                    for (int j = 0; j < escapeCounter; j++) {\r\n                        result.append(ESCAPE_CHAR);\r\n                    }\r\n                    escapeCounter = 0;\r\n                }\r\n                result.append(curChar);\r\n            }\r\n        }\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Counts the number of unescaped placeholders in the given messagePattern.\r\n     *\r\n     * @param messagePattern the message pattern to be analyzed.\r\n     * @return the number of unescaped placeholders.\r\n     */\r\n    public static int countArgumentPlaceholders(String messagePattern) {\r\n        if (messagePattern == null) {\r\n            return 0;\r\n        }\r\n        int delim = messagePattern.indexOf(DELIM_START);\r\n        if (delim == -1) {\r\n            // special case, no placeholders at all.\r\n            return 0;\r\n        }\r\n        int result = 0;\r\n        boolean isEscaped = false;\r\n        for (int i = 0; i < messagePattern.length(); i++) {\r\n            char curChar = messagePattern.charAt(i);\r\n            if (curChar == ESCAPE_CHAR) {\r\n                isEscaped = !isEscaped;\r\n            } else if (curChar == DELIM_START) {\r\n                if (!isEscaped) {\r\n                    if (i < messagePattern.length() - 1) {\r\n                        if (messagePattern.charAt(i + 1) == DELIM_STOP) {\r\n                            result++;\r\n                            i++;\r\n                        }\r\n                    }\r\n                }\r\n                isEscaped = false;\r\n            } else {\r\n                isEscaped = false;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * <p>This method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String\r\n     * as well as an optional Throwable.</p>\r\n     * <p/>\r\n     * <p>If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned\r\n     * in MessageFormatter.ArgumentResult.getThrowable() and won't be contained in the created String[].<br/>\r\n     * If it is used up getThrowable will return null even if the last argument was a Throwable!</p>\r\n     *\r\n     * @param messagePattern the message pattern that to be checked for placeholders.\r\n     * @param arguments      the argument array to be converted.\r\n     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.\r\n     */\r\n    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments) {\r\n        if (arguments == null) {\r\n            return null;\r\n        }\r\n        int argsCount = countArgumentPlaceholders(messagePattern);\r\n        int resultArgCount = arguments.length;\r\n        Throwable throwable = null;\r\n        if (argsCount < arguments.length) {\r\n            if (arguments[arguments.length - 1] instanceof Throwable) {\r\n                throwable = (Throwable) arguments[arguments.length - 1];\r\n                resultArgCount--;\r\n            }\r\n        }\r\n        String[] stringArgs;\r\n        if (argsCount == 1 && throwable == null && arguments.length > 1) {\r\n            // special case\r\n            stringArgs = new String[1];\r\n            stringArgs[0] = deepToString(arguments);\r\n        } else {\r\n            stringArgs = new String[resultArgCount];\r\n            for (int i = 0; i < stringArgs.length; i++) {\r\n                stringArgs[i] = deepToString(arguments[i]);\r\n            }\r\n        }\r\n        return new ArgumentResult(stringArgs, throwable);\r\n    }\r\n\r\n    public static String deepToString(Object o) {\r\n        if (o == null) {\r\n            return null;\r\n        }\r\n        if (o instanceof String) {\r\n            return (String) o;\r\n        }\r\n        StringBuilder str = new StringBuilder();\r\n        // that's actually a neat name ;)\r\n        Set<String> dejaVu = new HashSet<String>();\r\n        recursiveDeepToString(o, str, dejaVu);\r\n        return str.toString();\r\n    }\r\n\r\n    /**\r\n     * This method performs a deep toString of the given Object.\r\n     * Primitive arrays are converted using their respective Arrays.toString methods while\r\n     * special handling is implemented for \"container types\", i.e. Object[], Map and Collection because those could\r\n     * contain themselves.\r\n     * <p/>\r\n     * dejaVu is used in case of those container types to prevent an endless recursion.\r\n     * <p/>\r\n     * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior.\r\n     * They only check if the container is directly contained in itself, but not if a contained container contains the\r\n     * original one. Because of that, Arrays.toString(Object[]) isn't safe either.\r\n     * Confusing? Just read the last paragraph again and check the respective toString() implementation.\r\n     * <p/>\r\n     * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)\r\n     * would produce a relatively hard-to-debug StackOverflowError.\r\n     *\r\n     * @param o      the Object to convert into a String\r\n     * @param str    the StringBuilder that o will be appended to\r\n     * @param dejaVu a list of container identities that were already used.\r\n     */\r\n    private static void recursiveDeepToString(Object o, StringBuilder str, Set<String> dejaVu) {\r\n        if (o == null) {\r\n            str.append(\"null\");\r\n            return;\r\n        }\r\n        if (o instanceof String) {\r\n            str.append(o);\r\n            return;\r\n        }\r\n        Class oClass = o.getClass();\r\n        if (oClass.isArray()) {\r\n            if (oClass == byte[].class) {\r\n                str.append(Arrays.toString((byte[]) o));\r\n            } else if (oClass == short[].class) {\r\n                str.append(Arrays.toString((short[]) o));\r\n            } else if (oClass == int[].class) {\r\n                str.append(Arrays.toString((int[]) o));\r\n            } else if (oClass == long[].class) {\r\n                str.append(Arrays.toString((long[]) o));\r\n            } else if (oClass == float[].class) {\r\n                str.append(Arrays.toString((float[]) o));\r\n            } else if (oClass == double[].class) {\r\n                str.append(Arrays.toString((double[]) o));\r\n            } else if (oClass == boolean[].class) {\r\n                str.append(Arrays.toString((boolean[]) o));\r\n            } else if (oClass == char[].class) {\r\n                str.append(Arrays.toString((char[]) o));\r\n            } else {\r\n                // special handling of container Object[]\r\n                String id = identityToString(o);\r\n                if (dejaVu.contains(id)) {\r\n                    str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n                } else {\r\n                    dejaVu.add(id);\r\n                    Object[] oArray = (Object[]) o;\r\n                    str.append(\"[\");\r\n                    boolean first = true;\r\n                    for (Object current : oArray) {\r\n                        if (first) {\r\n                            first = false;\r\n                        } else {\r\n                            str.append(\", \");\r\n                        }\r\n                        recursiveDeepToString(current, str, new HashSet<String>(dejaVu));\r\n                    }\r\n                    str.append(\"]\");\r\n                }\r\n                //str.append(Arrays.deepToString((Object[]) o));\r\n            }\r\n        } else if (o instanceof Map) {\r\n            // special handling of container Map\r\n            String id = identityToString(o);\r\n            if (dejaVu.contains(id)) {\r\n                str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n            } else {\r\n                dejaVu.add(id);\r\n                Map<?, ?> oMap = (Map<?, ?>) o;\r\n                str.append(\"{\");\r\n                boolean isFirst = true;\r\n                for (Map.Entry<?, ?> current : oMap.entrySet()) {\r\n                    if (isFirst) {\r\n                        isFirst = false;\r\n                    } else {\r\n                        str.append(\", \");\r\n                    }\r\n                    Object key = current.getKey();\r\n                    Object value = current.getValue();\r\n                    recursiveDeepToString(key, str, new HashSet<String>(dejaVu));\r\n                    str.append(\"=\");\r\n                    recursiveDeepToString(value, str, new HashSet<String>(dejaVu));\r\n                }\r\n                str.append(\"}\");\r\n            }\r\n        } else if (o instanceof Collection) {\r\n            // special handling of container Collection\r\n            String id = identityToString(o);\r\n            if (dejaVu.contains(id)) {\r\n                str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n            } else {\r\n                dejaVu.add(id);\r\n                Collection<?> oCol = (Collection<?>) o;\r\n                str.append(\"[\");\r\n                boolean isFirst = true;\r\n                for (Object current : oCol) {\r\n                    if (isFirst) {\r\n                        isFirst = false;\r\n                    } else {\r\n                        str.append(\", \");\r\n                    }\r\n                    recursiveDeepToString(current, str, new HashSet<String>(dejaVu));\r\n                }\r\n                str.append(\"]\");\r\n            }\r\n        } else if (o instanceof Date) {\r\n            Date date = (Date) o;\r\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\");\r\n            // I'll leave it like this for the moment... this could probably be optimized using ThreadLocal...\r\n            str.append(format.format(date));\r\n        } else {\r\n            // it's just some other Object, we can only use toString().\r\n            try {\r\n                str.append(o.toString());\r\n            } catch (Throwable t) {\r\n                str.append(ERROR_PREFIX);\r\n                str.append(identityToString(o));\r\n                str.append(ERROR_SEPARATOR);\r\n                String msg = t.getMessage();\r\n                String className = t.getClass().getName();\r\n                str.append(className);\r\n                if (!className.equals(msg)) {\r\n                    str.append(ERROR_MSG_SEPARATOR);\r\n                    str.append(msg);\r\n                }\r\n                str.append(ERROR_SUFFIX);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method returns the same as if Object.toString() would not have been\r\n     * overridden in obj.\r\n     * <p/>\r\n     * Note that this isn't 100% secure as collisions can always happen with hash codes.\r\n     * <p/>\r\n     * Copied from Object.hashCode():\r\n     * As much as is reasonably practical, the hashCode method defined by\r\n     * class <tt>Object</tt> does return distinct integers for distinct\r\n     * objects. (This is typically implemented by converting the internal\r\n     * address of the object into an integer, but this implementation\r\n     * technique is not required by the\r\n     * Java<font size=\"-2\"><sup>TM</sup></font> programming language.)\r\n     *\r\n     * @param obj the Object that is to be converted into an identity string.\r\n     * @return the identity string as also defined in Object.toString()\r\n     */\r\n    public static String identityToString(Object obj) {\r\n        if (obj == null) {\r\n            return null;\r\n        }\r\n        return obj.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(obj));\r\n    }\r\n\r\n    /**\r\n     * <p>This is just a simple class containing the result of an evaluateArgument call. It's necessary because we need to\r\n     * return two results, i.e. the resulting String[] and the optional Throwable.</p>\r\n     * <p/>\r\n     * <p>This class is not Serializable because serializing a Throwable is generally a bad idea if the data is supposed\r\n     * to leave the current VM since it may result in ClassNotFoundExceptions if the given Throwable is not\r\n     * available/different in the deserializing VM.</p>\r\n     */\r\n    public static class ArgumentResult {\r\n\r\n        private Throwable throwable;\r\n\r\n        private String[] arguments;\r\n\r\n        public ArgumentResult(String[] arguments, Throwable throwable) {\r\n            this.throwable = throwable;\r\n            this.arguments = arguments;\r\n        }\r\n\r\n        public Throwable getThrowable() {\r\n            return throwable;\r\n        }\r\n\r\n        public String[] getArguments() {\r\n            return arguments;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            StringBuilder result = new StringBuilder();\r\n            result.append(\"ArgumentResult[throwable=\").append(throwable);\r\n            result.append(\", arguments=\");\r\n            if (arguments != null) {\r\n                result.append(\"[\");\r\n                boolean isFirst = true;\r\n                for (String current : arguments) {\r\n                    if (!isFirst) {\r\n                        result.append(\", \");\r\n                    } else {\r\n                        isFirst = false;\r\n                    }\r\n                    if (current != null) {\r\n                        result.append(\"'\").append(current).append(\"'\");\r\n                    } else {\r\n                        result.append(\"null\");\r\n                    }\r\n                }\r\n                result.append(\"]\");\r\n            }\r\n            return result.toString();\r\n        }\r\n\r\n        public boolean equals(Object o) {\r\n            if (this == o)\r\n                return true;\r\n            if (o == null || getClass() != o.getClass())\r\n                return false;\r\n            ArgumentResult result = (ArgumentResult) o;\r\n            if (!Arrays.equals(arguments, result.arguments))\r\n                return false;\r\n            if (throwable != null ? !throwable.equals(result.throwable) : result.throwable != null)\r\n                return false;\r\n            return true;\r\n        }\r\n\r\n        public int hashCode() {\r\n            int result;\r\n            result = (throwable != null ? throwable.hashCode() : 0);\r\n            result = 31 * result + (arguments != null ? Arrays.hashCode(arguments) : 0);\r\n            return result;\r\n        }\r\n    }\r\n}\r\n",
    "test_prompt": "// MessageFormatter_2Test.java\npackage de.huxhorn.lilith.data.logging;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MessageFormatter}.\n* It contains ten unit test cases for the {@link MessageFormatter#evaluateArguments(String, Object[])} method.\n*/\nclass MessageFormatter_2Test {"
},
{
    "id": "cmpl-6wSJv2Wa0XKFlsEbbTM33nxOQxt0I",
    "object": "text_completion",
    "created": 1679389907,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\t@Test\n\t\tpublic void testIdentityToString() {\n\t\t\t\tassertNull(MessageFormatter.identityToString(null));\n\t\t\t\tassertEquals(\"java.lang.String@\" + Integer.toHexString(System.identityHashCode(\"\")), MessageFormatter.identityToString(\"\"));\n\t\t\t\tassertEquals(\"java.lang.String@\" + Integer.toHexString(System.identityHashCode(\"test\")), MessageFormatter.identityToString(\"test\"));\n\t\t\t\tassertEquals(\"java.lang.Integer@\" + Integer.toHexString(System.identityHashCode(Integer.valueOf(0))), MessageFormatter.identityToString(Integer.valueOf(0)));\n\t\t\t\tassertEquals(\"java.lang.Integer@\" + Integer.toHexString(System.identityHashCode(Integer.valueOf(1))), MessageFormatter.identityToString(Integer.valueOf(1)));\n\t\t\t\tassertEquals(\"java.lang.Integer@\" + Integer.toHexString(System.identityHashCode(Integer.valueOf(-1))), MessageFormatter.identityToString(Integer.valueOf(-1)));\n\t\t\t\tassertEquals(\"java.lang.Integer@\" + Integer.toHexString(System.identityHashCode(Integer.valueOf(Integer.MAX_VALUE))), MessageFormatter.identityToString(Integer.valueOf(Integer.MAX_VALUE)));\n\t\t\t\tassertEquals(\"java.lang.Integer@\" + Integer.toHexString(System.identityHashCode(Integer.valueOf(Integer.MIN_VALUE))), MessageFormatter.identityToString(Integer.valueOf(Integer.MIN_VALUE)));\n\t\t\t\tassertEquals(\"java.lang.Long@\" + Integer.toHexString(System.identityHashCode(Long.valueOf(0))), MessageFormatter.identityToString(Long.valueOf(0)));\n\t\t\t\tassertEquals(\"java.lang.Long@\" + Integer.toHexString(System.identityHashCode(Long.valueOf(1))), MessageFormatter.identityToString(Long.valueOf(1)));\n\t\t\t\tassertEquals(\"java.lang.Long@\" + Integer.toHexString(System.identityHashCode(Long.valueOf(-1))), MessageFormatter.identityToString(Long.valueOf(-1)));\n\t\t\t\tassertEquals(\"java.lang.Long@\" + Integer.toHexString(System.identityHashCode(Long.valueOf(Long.MAX_VALUE))), MessageFormatter.identityToString(Long.valueOf(Long.MAX_VALUE)));\n\t\t\t\tassertEquals(\"java.lang.Long@\" + Integer.toHexString(System.identityHashCode(Long.valueOf(Long.MIN_VALUE))), MessageFormatter.identityToString(Long.valueOf(Long.MIN_VALUE)));\n\t\t\t\tassertEquals(\"java.lang.Boolean@\" + Integer.toHexString(System.identityHashCode(Boolean.TRUE)), MessageFormatter.identityToString(Boolean.TRUE));\n\t\t\t\tassertEquals(\"java.lang.Boolean@\" + Integer.toHexString(System.identityHashCode(Boolean.FALSE)), MessageFormatter.identityToString(Boolean.FALSE));\n\t\t\t\tassertEquals(\"java.lang.Character@\" + Integer.toHexString(System.identityHashCode(Character.valueOf('a'))), MessageFormatter.identityToString(Character.valueOf('a')));\n\t\t\t\tassertEquals(\"java.lang.Character@\" + Integer.toHexString(System.identityHashCode(Character.valueOf('\\u0000'))), MessageFormatter.identityToString(Character.valueOf('\\u0000')));\n\t\t\t\tassertEquals(\"java.lang.Character@\" + Integer.toHexString(System.identityHashCode(Character.valueOf('\\u0001'))), MessageFormatter.identityToString(Character.valueOf('\\u0001')));\n\t\t\t\tassertEquals(\"java.lang.Character@\" + Integer.toHexString(System.identityHashCode(Character.valueOf('\\u007F'))), MessageFormatter.identityToString(Character.valueOf('\\u007F')));\n\t\t\t\tassertEquals(\"java.lang.Character@\" + Integer.toHexString(System.identityHashCode(Character.valueOf('\\u0080'))), MessageFormatter.identityToString(Character.valueOf('\\u0080')));\n\t\t\t\tassertEquals(\"java.lang.Character@\" + Integer.toHexString(System.identityHashCode(Character.valueOf('\\u00FF'))), MessageFormatter.identityToString(Character.valueOf('\\u00FF')));\n\t\t\t\tassertEquals(\"java.lang.Character@\" + Integer.toHexString(System.identityHashCode(Character.valueOf('\\u0100'))), MessageFormatter.identityToString(Character.valueOf('\\u0100')));\n\t\t\t\tassertEquals(\"java.lang.Character@\" + Integer.toHexString(System.identityHashCode(Character.valueOf('\\u07FF'))), MessageFormatter.identityToString(Character.valueOf('\\u07FF')));\n\t\t\t\tassertEquals(\"java.lang.Character@\" + Integer.toHexString(System.identityHashCode(Character.valueOf('\\u0800'))), MessageFormatter.identityToString(Character.valueOf('\\u0800')));\n\t\t\t\tassertEquals(\"java.lang.Character@\" + Integer.toHexString(System.identityHashCode(Character.valueOf('\\uFFFF'))), MessageFormatter.identityToString(Character.valueOf('\\uFFFF')));\n\t\t\t\tassertEquals(\"java.lang.Character@\" + Integer.toHexString(System.identityHashCode(Character.valueOf('\\uD800'))), MessageFormatter.identityToString(Character.valueOf('\\uD800')));\n\t\t\t\tassertEquals(\"java.lang.Character@\" + Integer.toHexString(System.identityHashCode(Character.valueOf('\\uDFFF'))), MessageFormatter.identityToString(Character.valueOf('\\uDFFF')));\n\t\t\t\tassertEquals(\"java.lang.Character@\" + Integer.toHexString(System.identityHashCode(Character.valueOf('\\uE000'))), MessageFormatter.identityToString(Character.valueOf('\\uE000')));\n\t\t\t\tassertEquals(\"java.lang.Character@\" + Integer.toHexString(System.identityHashCode(Character.valueOf('\\uFFFD'))), MessageFormatter.identityToString(Character.valueOf('\\uFFFD')));\n\t\t\t\tassertEquals(\"java.lang.Character@\" + Integer.toHexString(System.identityHashCode(Character.valueOf('\\uFFFE'))), MessageFormatter.identityToString(Character.valueOf('\\uFFFE')));\n\t\t\t\tassertEquals(\"java.lang.Character@\" + Integer.toHexString(System.identityHashCode(Character.valueOf('\\uFFFF'))), MessageFormatter.identityToString(Character.valueOf('\\uFFFF')));\n\t\t\t\tassertEquals(\"java.lang.Character@\" + Integer.toHexString(System.identityHashCode(Character.valueOf('\\uD800'))), MessageFormatter.identityToString(Character.valueOf('\\uD800')));\n\t\t\t\tassertEquals(\"java.lang.Character@\" + Integer.toHexString(System.identityHashCode(Character.valueOf('\\uDBFF'))), MessageFormatter.identityToString(Character.valueOf('\\uDBFF')));\n\t\t\t\tassertEquals(\"java.lang.Character@\" + Integer.toHexString(System.identityHashCode(Character.valueOf('\\u",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 5264,
        "completion_tokens": 2000,
        "total_tokens": 7264
    },
    "time_taken": 73.9807481765747,
    "prompt_id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/data/logging/MessageFormatter_4Test.java",
    "original_code": "// MessageFormatter.java\n/*\r\n * Lilith - a log event viewer.\r\n * Copyright (C) 2007-2009 Joern Huxhorn\r\n * \r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.huxhorn.lilith.data.logging;\r\n\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Arrays;\r\nimport java.util.Collection;\r\nimport java.util.Date;\r\nimport java.util.HashSet;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n/**\r\n * <p>Replacement for org.slf4j.helpers.MessageFormatter.</p>\r\n * <p>\r\n * In contrast to the mentioned class, the formatting of message pattern and arguments into the actual message\r\n * is split into three parts:\r\n * </p>\r\n * <ol>\r\n * <li>Counting of placeholders in the message pattern (cheap)</li>\r\n * <li>Conversion of argument array into an ArgumentResult, containing the arguments converted to String as well as\r\n * an optional Throwable if available (relatively cheap)</li>\r\n * <li>Replacement of placeholders in a message pattern with arguments given as String[]. (most expensive)</li>\r\n * </ol>\r\n * <p>\r\n * That way only the first two steps have to be done during event creation while the most expensive part, i.e. the\r\n * actual construction of the message, is only done on demand.\r\n * </p>\r\n */\r\npublic class MessageFormatter {\r\n\r\n    private static final char DELIM_START = '{';\r\n\r\n    private static final char DELIM_STOP = '}';\r\n\r\n    private static final char ESCAPE_CHAR = '\\\\';\r\n\r\n    public static final String RECURSION_PREFIX = \"[...\";\r\n\r\n    public static final String RECURSION_SUFFIX = \"...]\";\r\n\r\n    public static final String ERROR_PREFIX = \"[!!!\";\r\n\r\n    public static final String ERROR_SEPARATOR = \"=>\";\r\n\r\n    public static final String ERROR_MSG_SEPARATOR = \":\";\r\n\r\n    public static final String ERROR_SUFFIX = \"!!!]\";\r\n\r\n    /**\r\n     * Replace placeholders in the given messagePattern with arguments.\r\n     *\r\n     * @param messagePattern the message pattern containing placeholders.\r\n     * @param arguments      the arguments to be used to replace placeholders.\r\n     * @return the formatted message.\r\n     */\r\n    public static String format(String messagePattern, String[] arguments) {\r\n        if (messagePattern == null || arguments == null || arguments.length == 0) {\r\n            return messagePattern;\r\n        }\r\n        StringBuilder result = new StringBuilder();\r\n        int escapeCounter = 0;\r\n        int currentArgument = 0;\r\n        for (int i = 0; i < messagePattern.length(); i++) {\r\n            char curChar = messagePattern.charAt(i);\r\n            if (curChar == ESCAPE_CHAR) {\r\n                escapeCounter++;\r\n            } else {\r\n                if (curChar == DELIM_START) {\r\n                    if (i < messagePattern.length() - 1) {\r\n                        if (messagePattern.charAt(i + 1) == DELIM_STOP) {\r\n                            // write escaped escape chars\r\n                            int escapedEscapes = escapeCounter / 2;\r\n                            for (int j = 0; j < escapedEscapes; j++) {\r\n                                result.append(ESCAPE_CHAR);\r\n                            }\r\n                            if (escapeCounter % 2 == 1) {\r\n                                // i.e. escaped\r\n                                // write escaped escape chars\r\n                                result.append(DELIM_START);\r\n                                result.append(DELIM_STOP);\r\n                            } else {\r\n                                // unescaped\r\n                                if (currentArgument < arguments.length) {\r\n                                    result.append(arguments[currentArgument]);\r\n                                } else {\r\n                                    result.append(DELIM_START).append(DELIM_STOP);\r\n                                }\r\n                                currentArgument++;\r\n                            }\r\n                            i++;\r\n                            escapeCounter = 0;\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n                // any other char beside ESCAPE or DELIM_START/STOP-combo\r\n                // write unescaped escape chars\r\n                if (escapeCounter > 0) {\r\n                    for (int j = 0; j < escapeCounter; j++) {\r\n                        result.append(ESCAPE_CHAR);\r\n                    }\r\n                    escapeCounter = 0;\r\n                }\r\n                result.append(curChar);\r\n            }\r\n        }\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Counts the number of unescaped placeholders in the given messagePattern.\r\n     *\r\n     * @param messagePattern the message pattern to be analyzed.\r\n     * @return the number of unescaped placeholders.\r\n     */\r\n    public static int countArgumentPlaceholders(String messagePattern) {\r\n        if (messagePattern == null) {\r\n            return 0;\r\n        }\r\n        int delim = messagePattern.indexOf(DELIM_START);\r\n        if (delim == -1) {\r\n            // special case, no placeholders at all.\r\n            return 0;\r\n        }\r\n        int result = 0;\r\n        boolean isEscaped = false;\r\n        for (int i = 0; i < messagePattern.length(); i++) {\r\n            char curChar = messagePattern.charAt(i);\r\n            if (curChar == ESCAPE_CHAR) {\r\n                isEscaped = !isEscaped;\r\n            } else if (curChar == DELIM_START) {\r\n                if (!isEscaped) {\r\n                    if (i < messagePattern.length() - 1) {\r\n                        if (messagePattern.charAt(i + 1) == DELIM_STOP) {\r\n                            result++;\r\n                            i++;\r\n                        }\r\n                    }\r\n                }\r\n                isEscaped = false;\r\n            } else {\r\n                isEscaped = false;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * <p>This method returns a MessageFormatter.ArgumentResult which contains the arguments converted to String\r\n     * as well as an optional Throwable.</p>\r\n     * <p/>\r\n     * <p>If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned\r\n     * in MessageFormatter.ArgumentResult.getThrowable() and won't be contained in the created String[].<br/>\r\n     * If it is used up getThrowable will return null even if the last argument was a Throwable!</p>\r\n     *\r\n     * @param messagePattern the message pattern that to be checked for placeholders.\r\n     * @param arguments      the argument array to be converted.\r\n     * @return a MessageFormatter.ArgumentResult containing the converted arformatted message and optionally a Throwable.\r\n     */\r\n    public static ArgumentResult evaluateArguments(String messagePattern, Object[] arguments) {\r\n        if (arguments == null) {\r\n            return null;\r\n        }\r\n        int argsCount = countArgumentPlaceholders(messagePattern);\r\n        int resultArgCount = arguments.length;\r\n        Throwable throwable = null;\r\n        if (argsCount < arguments.length) {\r\n            if (arguments[arguments.length - 1] instanceof Throwable) {\r\n                throwable = (Throwable) arguments[arguments.length - 1];\r\n                resultArgCount--;\r\n            }\r\n        }\r\n        String[] stringArgs;\r\n        if (argsCount == 1 && throwable == null && arguments.length > 1) {\r\n            // special case\r\n            stringArgs = new String[1];\r\n            stringArgs[0] = deepToString(arguments);\r\n        } else {\r\n            stringArgs = new String[resultArgCount];\r\n            for (int i = 0; i < stringArgs.length; i++) {\r\n                stringArgs[i] = deepToString(arguments[i]);\r\n            }\r\n        }\r\n        return new ArgumentResult(stringArgs, throwable);\r\n    }\r\n\r\n    public static String deepToString(Object o) {\r\n        if (o == null) {\r\n            return null;\r\n        }\r\n        if (o instanceof String) {\r\n            return (String) o;\r\n        }\r\n        StringBuilder str = new StringBuilder();\r\n        // that's actually a neat name ;)\r\n        Set<String> dejaVu = new HashSet<String>();\r\n        recursiveDeepToString(o, str, dejaVu);\r\n        return str.toString();\r\n    }\r\n\r\n    /**\r\n     * This method performs a deep toString of the given Object.\r\n     * Primitive arrays are converted using their respective Arrays.toString methods while\r\n     * special handling is implemented for \"container types\", i.e. Object[], Map and Collection because those could\r\n     * contain themselves.\r\n     * <p/>\r\n     * dejaVu is used in case of those container types to prevent an endless recursion.\r\n     * <p/>\r\n     * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a behavior.\r\n     * They only check if the container is directly contained in itself, but not if a contained container contains the\r\n     * original one. Because of that, Arrays.toString(Object[]) isn't safe either.\r\n     * Confusing? Just read the last paragraph again and check the respective toString() implementation.\r\n     * <p/>\r\n     * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)\r\n     * would produce a relatively hard-to-debug StackOverflowError.\r\n     *\r\n     * @param o      the Object to convert into a String\r\n     * @param str    the StringBuilder that o will be appended to\r\n     * @param dejaVu a list of container identities that were already used.\r\n     */\r\n    private static void recursiveDeepToString(Object o, StringBuilder str, Set<String> dejaVu) {\r\n        if (o == null) {\r\n            str.append(\"null\");\r\n            return;\r\n        }\r\n        if (o instanceof String) {\r\n            str.append(o);\r\n            return;\r\n        }\r\n        Class oClass = o.getClass();\r\n        if (oClass.isArray()) {\r\n            if (oClass == byte[].class) {\r\n                str.append(Arrays.toString((byte[]) o));\r\n            } else if (oClass == short[].class) {\r\n                str.append(Arrays.toString((short[]) o));\r\n            } else if (oClass == int[].class) {\r\n                str.append(Arrays.toString((int[]) o));\r\n            } else if (oClass == long[].class) {\r\n                str.append(Arrays.toString((long[]) o));\r\n            } else if (oClass == float[].class) {\r\n                str.append(Arrays.toString((float[]) o));\r\n            } else if (oClass == double[].class) {\r\n                str.append(Arrays.toString((double[]) o));\r\n            } else if (oClass == boolean[].class) {\r\n                str.append(Arrays.toString((boolean[]) o));\r\n            } else if (oClass == char[].class) {\r\n                str.append(Arrays.toString((char[]) o));\r\n            } else {\r\n                // special handling of container Object[]\r\n                String id = identityToString(o);\r\n                if (dejaVu.contains(id)) {\r\n                    str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n                } else {\r\n                    dejaVu.add(id);\r\n                    Object[] oArray = (Object[]) o;\r\n                    str.append(\"[\");\r\n                    boolean first = true;\r\n                    for (Object current : oArray) {\r\n                        if (first) {\r\n                            first = false;\r\n                        } else {\r\n                            str.append(\", \");\r\n                        }\r\n                        recursiveDeepToString(current, str, new HashSet<String>(dejaVu));\r\n                    }\r\n                    str.append(\"]\");\r\n                }\r\n                //str.append(Arrays.deepToString((Object[]) o));\r\n            }\r\n        } else if (o instanceof Map) {\r\n            // special handling of container Map\r\n            String id = identityToString(o);\r\n            if (dejaVu.contains(id)) {\r\n                str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n            } else {\r\n                dejaVu.add(id);\r\n                Map<?, ?> oMap = (Map<?, ?>) o;\r\n                str.append(\"{\");\r\n                boolean isFirst = true;\r\n                for (Map.Entry<?, ?> current : oMap.entrySet()) {\r\n                    if (isFirst) {\r\n                        isFirst = false;\r\n                    } else {\r\n                        str.append(\", \");\r\n                    }\r\n                    Object key = current.getKey();\r\n                    Object value = current.getValue();\r\n                    recursiveDeepToString(key, str, new HashSet<String>(dejaVu));\r\n                    str.append(\"=\");\r\n                    recursiveDeepToString(value, str, new HashSet<String>(dejaVu));\r\n                }\r\n                str.append(\"}\");\r\n            }\r\n        } else if (o instanceof Collection) {\r\n            // special handling of container Collection\r\n            String id = identityToString(o);\r\n            if (dejaVu.contains(id)) {\r\n                str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);\r\n            } else {\r\n                dejaVu.add(id);\r\n                Collection<?> oCol = (Collection<?>) o;\r\n                str.append(\"[\");\r\n                boolean isFirst = true;\r\n                for (Object current : oCol) {\r\n                    if (isFirst) {\r\n                        isFirst = false;\r\n                    } else {\r\n                        str.append(\", \");\r\n                    }\r\n                    recursiveDeepToString(current, str, new HashSet<String>(dejaVu));\r\n                }\r\n                str.append(\"]\");\r\n            }\r\n        } else if (o instanceof Date) {\r\n            Date date = (Date) o;\r\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\");\r\n            // I'll leave it like this for the moment... this could probably be optimized using ThreadLocal...\r\n            str.append(format.format(date));\r\n        } else {\r\n            // it's just some other Object, we can only use toString().\r\n            try {\r\n                str.append(o.toString());\r\n            } catch (Throwable t) {\r\n                str.append(ERROR_PREFIX);\r\n                str.append(identityToString(o));\r\n                str.append(ERROR_SEPARATOR);\r\n                String msg = t.getMessage();\r\n                String className = t.getClass().getName();\r\n                str.append(className);\r\n                if (!className.equals(msg)) {\r\n                    str.append(ERROR_MSG_SEPARATOR);\r\n                    str.append(msg);\r\n                }\r\n                str.append(ERROR_SUFFIX);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method returns the same as if Object.toString() would not have been\r\n     * overridden in obj.\r\n     * <p/>\r\n     * Note that this isn't 100% secure as collisions can always happen with hash codes.\r\n     * <p/>\r\n     * Copied from Object.hashCode():\r\n     * As much as is reasonably practical, the hashCode method defined by\r\n     * class <tt>Object</tt> does return distinct integers for distinct\r\n     * objects. (This is typically implemented by converting the internal\r\n     * address of the object into an integer, but this implementation\r\n     * technique is not required by the\r\n     * Java<font size=\"-2\"><sup>TM</sup></font> programming language.)\r\n     *\r\n     * @param obj the Object that is to be converted into an identity string.\r\n     * @return the identity string as also defined in Object.toString()\r\n     */\r\n    public static String identityToString(Object obj) {\r\n        if (obj == null) {\r\n            return null;\r\n        }\r\n        return obj.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(obj));\r\n    }\r\n\r\n    /**\r\n     * <p>This is just a simple class containing the result of an evaluateArgument call. It's necessary because we need to\r\n     * return two results, i.e. the resulting String[] and the optional Throwable.</p>\r\n     * <p/>\r\n     * <p>This class is not Serializable because serializing a Throwable is generally a bad idea if the data is supposed\r\n     * to leave the current VM since it may result in ClassNotFoundExceptions if the given Throwable is not\r\n     * available/different in the deserializing VM.</p>\r\n     */\r\n    public static class ArgumentResult {\r\n\r\n        private Throwable throwable;\r\n\r\n        private String[] arguments;\r\n\r\n        public ArgumentResult(String[] arguments, Throwable throwable) {\r\n            this.throwable = throwable;\r\n            this.arguments = arguments;\r\n        }\r\n\r\n        public Throwable getThrowable() {\r\n            return throwable;\r\n        }\r\n\r\n        public String[] getArguments() {\r\n            return arguments;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            StringBuilder result = new StringBuilder();\r\n            result.append(\"ArgumentResult[throwable=\").append(throwable);\r\n            result.append(\", arguments=\");\r\n            if (arguments != null) {\r\n                result.append(\"[\");\r\n                boolean isFirst = true;\r\n                for (String current : arguments) {\r\n                    if (!isFirst) {\r\n                        result.append(\", \");\r\n                    } else {\r\n                        isFirst = false;\r\n                    }\r\n                    if (current != null) {\r\n                        result.append(\"'\").append(current).append(\"'\");\r\n                    } else {\r\n                        result.append(\"null\");\r\n                    }\r\n                }\r\n                result.append(\"]\");\r\n            }\r\n            return result.toString();\r\n        }\r\n\r\n        public boolean equals(Object o) {\r\n            if (this == o)\r\n                return true;\r\n            if (o == null || getClass() != o.getClass())\r\n                return false;\r\n            ArgumentResult result = (ArgumentResult) o;\r\n            if (!Arrays.equals(arguments, result.arguments))\r\n                return false;\r\n            if (throwable != null ? !throwable.equals(result.throwable) : result.throwable != null)\r\n                return false;\r\n            return true;\r\n        }\r\n\r\n        public int hashCode() {\r\n            int result;\r\n            result = (throwable != null ? throwable.hashCode() : 0);\r\n            result = 31 * result + (arguments != null ? Arrays.hashCode(arguments) : 0);\r\n            return result;\r\n        }\r\n    }\r\n}\r\n",
    "test_prompt": "// MessageFormatter_4Test.java\npackage de.huxhorn.lilith.data.logging;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MessageFormatter}.\n* It contains ten unit test cases for the {@link MessageFormatter#identityToString(Object)} method.\n*/\nclass MessageFormatter_4Test {"
},
{
    "id": "cmpl-6wSL6imYDTCFrRIB9yBRO4r0oc6t4",
    "object": "text_completion",
    "created": 1679389980,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t/**\n\t* Test case for {@link NDC#getContextStack()} method.\n\t* The test case tests the method with an empty stack.\n\t*/\n\t@Test\n\tvoid testGetContextStack_empty() {\n\t\tNDC.clear();\n\t\tMessage[] contextStack = NDC.getContextStack();\n\t\tassertNotNull(contextStack);\n\t\tassertEquals(0, contextStack.length);\n\t}\n\t\n\t/**\n\t* Test case for {@link NDC#getContextStack()} method.\n\t* The test case tests the method with a stack containing one element.\n\t*/\n\t@Test\n\tvoid testGetContextStack_one() {\n\t\tNDC.clear();\n\t\tNDC.push(\"Test\");\n\t\tMessage[] contextStack = NDC.getContextStack();\n\t\tassertNotNull(contextStack);\n\t\tassertEquals(1, contextStack.length);\n\t\tassertEquals(\"Test\", contextStack[0].getMessage());\n\t}\n\t\n\t/**\n\t* Test case for {@link NDC#getContextStack()} method.\n\t* The test case tests the method with a stack containing two elements.\n\t*/\n\t@Test\n\tvoid testGetContextStack_two() {\n\t\tNDC.clear();\n\t\tNDC.push(\"Test\");\n\t\tNDC.push(\"Test2\");\n\t\tMessage[] contextStack = NDC.getContextStack();\n\t\tassertNotNull(contextStack);\n\t\tassertEquals(2, contextStack.length);\n\t\tassertEquals(\"Test\", contextStack[0].getMessage());\n\t\tassertEquals(\"Test2\", contextStack[1].getMessage());\n\t}\n\t\n\t/**\n\t* Test case for {@link NDC#getContextStack()} method.\n\t* The test case tests the method with a stack containing three elements.\n\t*/\n\t@Test\n\tvoid testGetContextStack_three() {\n\t\tNDC.clear();\n\t\tNDC.push(\"Test\");\n\t\tNDC.push(\"Test2\");\n\t\tNDC.push(\"Test3\");\n\t\tMessage[] contextStack = NDC.getContextStack();\n\t\tassertNotNull(contextStack);\n\t\tassertEquals(3, contextStack.length);\n\t\tassertEquals(\"Test\", contextStack[0].getMessage());\n\t\tassertEquals(\"Test2\", contextStack[1].getMessage());\n\t\tassertEquals(\"Test3\", contextStack[2].getMessage());\n\t}\n\t\n\t/**\n\t* Test case for {@link NDC#getContextStack()} method.\n\t* The test case tests the method with a stack containing four elements.\n\t*/\n\t@Test\n\tvoid testGetContextStack_four() {\n\t\tNDC.clear();\n\t\tNDC.push(\"Test\");\n\t\tNDC.push(\"Test2\");\n\t\tNDC.push(\"Test3\");\n\t\tNDC.push(\"Test4\");\n\t\tMessage[] contextStack = NDC.getContextStack();\n\t\tassertNotNull(contextStack);\n\t\tassertEquals(4, contextStack.length);\n\t\tassertEquals(\"Test\", contextStack[0].getMessage());\n\t\tassertEquals(\"Test2\", contextStack[1].getMessage());\n\t\tassertEquals(\"Test3\", contextStack[2].getMessage());\n\t\tassertEquals(\"Test4\", contextStack[3].getMessage());\n\t}\n\t\n\t/**\n\t* Test case for {@link NDC#getContextStack()} method.\n\t* The test case tests the method with a stack containing five elements.\n\t*/\n\t@Test\n\tvoid testGetContextStack_five() {\n\t\tNDC.clear();\n\t\tNDC.push(\"Test\");\n\t\tNDC.push(\"Test2\");\n\t\tNDC.push(\"Test3\");\n\t\tNDC.push(\"Test4\");\n\t\tNDC.push(\"Test5\");\n\t\tMessage[] contextStack = NDC.getContextStack();\n\t\tassertNotNull(contextStack);\n\t\tassertEquals(5, contextStack.length);\n\t\tassertEquals(\"Test\", contextStack[0].getMessage());\n\t\tassertEquals(\"Test2\", contextStack[1].getMessage());\n\t\tassertEquals(\"Test3\", contextStack[2].getMessage());\n\t\tassertEquals(\"Test4\", contextStack[3].getMessage());\n\t\tassertEquals(\"Test5\", contextStack[4].getMessage());\n\t}\n\t\n\t/**\n\t* Test case for {@link NDC#getContextStack()} method.\n\t* The test case tests the method with a stack containing six elements.\n\t*/\n\t@Test\n\tvoid testGetContextStack_six() {\n\t\tNDC.clear();\n\t\tNDC.push(\"Test\");\n\t\tNDC.push(\"Test2\");\n\t\tNDC.push(\"Test3\");\n\t\tNDC.push(\"Test4\");\n\t\tNDC.push(\"Test5\");\n\t\tNDC.push(\"Test6\");\n\t\tMessage[] contextStack = NDC.getContextStack();\n\t\tassertNotNull(contextStack);\n\t\tassertEquals(6, contextStack.length);\n\t\tassertEquals(\"Test\", contextStack[0].getMessage());\n\t\tassertEquals(\"Test2\", contextStack[1].getMessage());\n\t\tassertEquals(\"Test3\", contextStack[2].getMessage());\n\t\tassertEquals(\"Test4\", contextStack[3].getMessage());\n\t\tassertEquals(\"Test5\", contextStack[4].getMessage());\n\t\tassertEquals(\"Test6\", contextStack[5].getMessage());\n\t}\n\t\n\t/**\n\t* Test case for {@link NDC#getContextStack()} method.\n\t* The test case tests the method with a stack containing seven elements.\n\t*/\n\t@Test\n\tvoid testGetContextStack_seven() {\n\t\tNDC.clear();\n\t\tNDC.push(\"Test\");\n\t\tNDC.push(\"Test2\");\n\t\tNDC.push(\"Test3\");\n\t\tNDC.push(\"Test4\");\n\t\tNDC.push(\"Test5\");\n\t\tNDC.push(\"Test6\");\n\t\tNDC.push(\"Test7\");\n\t\tMessage[] contextStack = NDC.getContextStack();\n\t\tassertNotNull(contextStack);\n\t\tassertEquals(7, contextStack.length);\n\t\tassertEquals(\"Test\", contextStack[0].getMessage());\n\t\tassertEquals(\"Test2\", contextStack[1].getMessage());\n\t\tassertEquals(\"Test3\", contextStack[2].getMessage());\n\t\tassertEquals(\"Test4\", contextStack[3].getMessage());\n\t\tassertEquals(\"Test5\", contextStack[4].getMessage());\n\t\tassertEquals(\"Test6\", contextStack[5].getMessage());\n\t\tassertEquals(\"Test7\", contextStack[6].getMessage());\n\t}\n\t\n\t/**\n\t* Test case for {@link NDC#getContextStack()} method.\n\t* The test case tests the method with a stack containing eight elements.\n\t*/\n\t@Test\n\tvoid testGetContextStack_eight() {\n\t\tNDC.clear();\n\t\tNDC.push(\"Test\");\n\t\tNDC.push(\"Test2\");\n\t\tNDC.push(\"Test3\");\n\t\tNDC.push(\"Test4\");\n\t\tNDC.push(\"Test5\");\n\t\tNDC.push(\"Test6\");\n\t\tNDC.push(\"Test7\");\n\t\tNDC.push(\"Test8\");\n\t\tMessage[] contextStack = NDC.getContextStack();\n\t\tassertNotNull(contextStack);\n\t\tassertEquals(8, contextStack.length);\n\t\tassertEquals(\"Test\", contextStack[0].getMessage());\n\t\tassertEquals(\"Test2\", contextStack[1].getMessage());\n\t\tassertEquals(\"Test3\", contextStack[2].getMessage());\n\t\tassertEquals(\"Test4\", contextStack[3].getMessage());\n\t\tassertEquals(\"Test5\", contextStack[4].getMessage());\n\t\tassertEquals(\"Test6\", contextStack[5].getMessage());\n\t\tassertEquals(\"Test7\", contextStack[6].getMessage());\n\t\tassertEquals(\"Test8\", contextStack[7].getMessage());\n\t}\n\t\n\t",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 809,
        "completion_tokens": 2000,
        "total_tokens": 2809
    },
    "time_taken": 59.95193696022034,
    "prompt_id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/logback/classic/NDC_2Test.java",
    "original_code": "// NDC.java\n/*\r\n * Lilith - a log event viewer.\r\n * Copyright (C) 2007-2009 Joern Huxhorn\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.huxhorn.lilith.logback.classic;\r\n\r\nimport de.huxhorn.lilith.data.logging.Message;\r\n\r\npublic class NDC {\r\n\r\n    private static final NDCAdapter ndcAdapter;\r\n\r\n    static {\r\n        // TODO: configuration\r\n        ndcAdapter = new SimpleNDCAdapter();\r\n    }\r\n\r\n    private NDC() {\r\n    }\r\n\r\n    public static void push(String message) {\r\n        ndcAdapter.push(message);\r\n    }\r\n\r\n    public static void push(String messagePattern, Object[] arguments) {\r\n        ndcAdapter.push(messagePattern, arguments);\r\n    }\r\n\r\n    /**\r\n     * Pops the last message from the stack.\r\n     * <p/>\r\n     * This method does not return the popped message to discourage it's usage in application logic.\r\n     */\r\n    public static void pop() {\r\n        ndcAdapter.pop();\r\n    }\r\n\r\n    public static int getDepth() {\r\n        return ndcAdapter.getDepth();\r\n    }\r\n\r\n    public static void setMaximumDepth(int maximumDepth) {\r\n        ndcAdapter.setMaximumDepth(maximumDepth);\r\n    }\r\n\r\n    public static boolean isEmpty() {\r\n        return ndcAdapter.isEmpty();\r\n    }\r\n\r\n    public static void clear() {\r\n        ndcAdapter.clear();\r\n    }\r\n\r\n    /**\r\n     * Returns an array containing all messages of the stack.\r\n     * <p/>\r\n     * The messages from the NDC stack should not be used in application logic.\r\n     *\r\n     * @return an array containing all messages of the stack.\r\n     */\r\n    public static Message[] getContextStack() {\r\n        return ndcAdapter.getContextStack();\r\n    }\r\n}\r\n",
    "test_prompt": "// NDC_2Test.java\npackage de.huxhorn.lilith.logback.classic;\n\nimport de.huxhorn.lilith.data.logging.Message;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NDC}.\n* It contains ten unit test cases for the {@link NDC#getContextStack()} method.\n*/\nclass NDC_2Test {"
},
{
    "choices": [
        {
            "finish_reason": "ERROR - This model's maximum context length is 8001 tokens, however you requested 19178 tokens (17178 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.",
            "text": ""
        }
    ],
    "id": "71167456-0f27-4134-93bb-c3a358a2c0fe",
    "prompt_id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/AboutPanel_0Test.java",
    "original_code": "// AboutPanel.java\n/*\r\n * Lilith - a log event viewer.\r\n * Copyright (C) 2007-2009 Joern Huxhorn\r\n * \r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.huxhorn.lilith.swing;\r\n\r\nimport de.huxhorn.sulky.swing.GraphicsUtilities;\r\nimport de.huxhorn.sulky.swing.filters.ColorTintFilter;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport java.awt.*;\r\nimport java.awt.event.ActionEvent;\r\nimport java.awt.event.ActionListener;\r\nimport java.awt.event.ComponentAdapter;\r\nimport java.awt.event.ComponentEvent;\r\nimport java.awt.event.MouseEvent;\r\nimport java.awt.image.BufferedImage;\r\nimport java.awt.image.BufferedImageOp;\r\nimport java.awt.image.ConvolveOp;\r\nimport java.awt.image.Kernel;\r\nimport java.beans.PropertyChangeEvent;\r\nimport java.beans.PropertyChangeListener;\r\nimport java.io.IOException;\r\nimport java.net.URL;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.StringTokenizer;\r\nimport javax.swing.*;\r\nimport javax.swing.event.MouseInputAdapter;\r\n\r\n// TODO: get/setMouseHandling/MouseInputMode\r\n// TODO: setVersionHeight(versionHeight);\r\n// TODO: setVersionString(versionString);\r\n// TODO: correct versionHeight if string would be outside background.\r\n// TODO: VersionString centered to bg/scroll.\r\n// TODO: relative ScrollAreas (values given as % of backgroundImage)\r\n// TODO: Handle errors in Image-Loading\r\n// TODO: offscreenImage h\ufffdchstens so gro\ufffd wie die size / nicht gesamten bg malen\r\n// TODO: paint background-color for rest of component (not only behind bg-image)\r\n// TODO: scroll-area defined by object-array containing icons and strings...\r\n// TODO: transient attributes\r\n// TODO: serialVersion\r\n// TODO: use ResourceSupport\r\n/**\r\n * <code>AboutPanel</code> is a component which has a background-image and a\r\n * rectangle in which a given text is scrolling (the scroll-area). You may also\r\n * specify an Image (e.g. a png-file with alpha-channel) that is drawn before\r\n * the scroll-text itself. An optional version-string may be given that will be\r\n * painted centered relative to the scroll-area.\r\n *\r\n * @author Joern Huxhorn\r\n */\r\npublic class AboutPanel extends JComponent {\r\n\r\n    private final Logger logger = LoggerFactory.getLogger(AboutPanel.class);\r\n\r\n    public static final String BACKGROUND_IMAGE_RESOURCE = \"background.png\";\r\n\r\n    public static final String ABOUT_IMAGE_RESOURCE = \"about.png\";\r\n\r\n    public static final String TEXT_RESOURCE_PREFIX = \"about.\";\r\n\r\n    public static final String SCROLL_TEXT_RESOURCE = TEXT_RESOURCE_PREFIX + \"scroll.text\";\r\n\r\n    public static final String VERSION_TEXT_RESOURCE = TEXT_RESOURCE_PREFIX + \"version.text\";\r\n\r\n    public static final String VERSION_HEIGHT_RESOURCE = TEXT_RESOURCE_PREFIX + \"version.height\";\r\n\r\n    public static final String SCROLL_AREA_RESOURCE_BASE = TEXT_RESOURCE_PREFIX + \"scroll.area.\";\r\n\r\n    public static final String SCROLL_AREA_X_RESOURCE = SCROLL_AREA_RESOURCE_BASE + \"x\";\r\n\r\n    public static final String SCROLL_AREA_Y_RESOURCE = SCROLL_AREA_RESOURCE_BASE + \"y\";\r\n\r\n    public static final String SCROLL_AREA_WIDTH_RESOURCE = SCROLL_AREA_RESOURCE_BASE + \"width\";\r\n\r\n    public static final String SCROLL_AREA_HEIGHT_RESOURCE = SCROLL_AREA_RESOURCE_BASE + \"height\";\r\n\r\n    public static final String SCROLL_AREA_TOOLTIP_TEXT_RESOURCE = SCROLL_AREA_RESOURCE_BASE + \"tooltip.text\";\r\n\r\n    public static final String TEXT_RESOURCE_BUNDLE_RESOURCE = \"TextResources\";\r\n\r\n    public static final int MOUSE_DISABLED = 0;\r\n\r\n    public static final int MOUSE_COMPONENT = 1;\r\n\r\n    public static final int MOUSE_SCROLLAREA = 2;\r\n\r\n    public static final int MOUSE_BACKGROUND = 3;\r\n\r\n    //private static final int SCROLL_SLEEP_TIME = 50;\r\n    private static final int SCROLL_PIXELS = 1;\r\n\r\n    //private static final int SCROLL_THREAD_PRIORITY = Thread.NORM_PRIORITY+1;\r\n    //private final ResourceSupport resourceSupport;\r\n    private BufferedImage backgroundImage;\r\n\r\n    private BufferedImage aboutImage;\r\n\r\n    //private ImageIcon backgroundImageIcon;\r\n    //private ImageIcon aboutImageIcon;\r\n    private FontMetrics fontMetrics;\r\n\r\n    private Insets insets;\r\n\r\n    private Dimension size;\r\n\r\n    private Dimension preferredSize;\r\n\r\n    private Point offscreenOffset;\r\n\r\n    private String[] scrollLines;\r\n\r\n    private String versionText;\r\n\r\n    private String scrollAreaToolTipText;\r\n\r\n    private int versionHeight;\r\n\r\n    private int scrollPosition;\r\n\r\n    private int maxScrollPosition;\r\n\r\n    private int minScrollPosition;\r\n\r\n    private Rectangle maxScrollArea;\r\n\r\n    private Rectangle backgroundImageArea;\r\n\r\n    private Rectangle translatedBackgroundImageArea;\r\n\r\n    private Rectangle translatedScrollArea;\r\n\r\n    private Rectangle scrollArea;\r\n\r\n    private Rectangle paintArea;\r\n\r\n    private BufferedImage offscreenImage;\r\n\r\n    private BufferedImage scrollImage;\r\n\r\n    private boolean scrolling;\r\n\r\n    //private boolean offscreenInitialized = false;\r\n    //private boolean scrollInitialized = false;\r\n    //private boolean painted;\r\n    private int mouseEventHandling = MOUSE_BACKGROUND;\r\n\r\n    //private transient Thread scrollThread;\r\n    private boolean debug;\r\n\r\n    private Timer timer;\r\n\r\n    //private String scrollText;\r\n    //private Map textBundleMap;\r\n    //private int mouseEventHandling=MOUSE_DISABLED;\r\n    /**\r\n     * Creates a new <code>AboutPanel</code> initialized with the given parameters.\r\n     *\r\n     * @param backgroundImageUrl The URL to the Background-Image of the\r\n     *                           AboutPanel. This parameter is mandatory.\r\n     * @param scrollArea         The Rectangle inside the background-image where\r\n     *                           scrolling should take place. This parameter is optional. If it's null\r\n     *                           then the scroll-area is set to (0, 0, background.width,\r\n     *                           background.height).\r\n     */\r\n    public AboutPanel(URL backgroundImageUrl, Rectangle scrollArea, String scrollText) throws IOException {\r\n        this(backgroundImageUrl, scrollArea, scrollText, null, null, -1);\r\n    }\r\n\r\n    public boolean isDebug() {\r\n        return debug;\r\n    }\r\n\r\n    public void setDebug(boolean debug) {\r\n        this.debug = debug;\r\n    }\r\n\r\n    /**\r\n     * Creates a new <code>AboutPanel</code> initialized with the given parameters.\r\n     *\r\n     * @param backgroundImageUrl The URL to the Background-Image of the\r\n     *                           AboutPanel. This parameter is mandatory.\r\n     * @param scrollArea         The Rectangle inside the background-image where\r\n     *                           scrolling should take place. This parameter is optional. If it's null\r\n     *                           then the scroll-area is set to (0, 0, background.width,\r\n     *                           background.height).\r\n     * @param versionText        The String describing the version of the program.\r\n     *                           It is painted centered to the scroll-rectangle at the specified height.\r\n     *                           This parameter is optional.\r\n     * @param versionHeight      The height at which the version-string is\r\n     *                           supposed to be painted. This parameter is optional but should be given\r\n     *                           a correct value if versionText!=null..\r\n     */\r\n    public AboutPanel(URL backgroundImageUrl, Rectangle scrollArea, String scrollText, String versionText, int versionHeight) throws IOException {\r\n        this(backgroundImageUrl, scrollArea, scrollText, null, versionText, versionHeight);\r\n    }\r\n\r\n    /**\r\n     * Creates a new <code>AboutPanel</code> initialized with the given parameters.\r\n     *\r\n     * @param backgroundImageUrl The URL to the Background-Image of the\r\n     *                           AboutPanel. This parameter is mandatory.\r\n     * @param scrollArea         The Rectangle inside the background-image where\r\n     *                           scrolling should take place. This parameter is optional. If it's null\r\n     *                           then the scroll-area is set to (0, 0, background.width,\r\n     *                           background.height).\r\n     * @param imageUrl           The URL to the Image that will be painted at the\r\n     *                           start of the scroll-area. This parameter is optional.\r\n     * @param versionText        The String describing the version of the program.\r\n     *                           It is painted centered to the scroll-rectangle at the specified height.\r\n     *                           This parameter is optional.\r\n     * @param versionHeight      The height at which the version-string is\r\n     *                           supposed to be painted. This parameter is optional but should be given\r\n     *                           a correct value if versionText!=null..\r\n     */\r\n    public AboutPanel(URL backgroundImageUrl, Rectangle scrollArea, String scrollText, URL imageUrl, String versionText, int versionHeight) throws IOException {\r\n        this();\r\n        if (backgroundImageUrl == null) {\r\n            throw new NullPointerException(\"backgroundImageUrl must not be null!\");\r\n        }\r\n        if (scrollText == null) {\r\n            throw new NullPointerException(\"scrollText must not be null!\");\r\n        }\r\n        init(backgroundImageUrl, scrollArea, scrollText, imageUrl, versionText, versionHeight);\r\n    }\r\n\r\n    public AboutPanel() {\r\n        ActionListener timerListener = new TimerActionListener();\r\n        timer = new Timer(10, timerListener);\r\n        //this.resourceSupport=new ResourceSupport(this);\r\n        initAttributes();\r\n        addPropertyChangeListener(new AboutPropertyChangeListener());\r\n        addComponentListener(new AboutComponentListener());\r\n        // initializes to Label.font\r\n        setFont(null);\r\n        AboutMouseInputListener mouseInputListener = new AboutMouseInputListener();\r\n        addMouseListener(mouseInputListener);\r\n        addMouseMotionListener(mouseInputListener);\r\n        //this.scrollThread=null;\r\n        setScrolling(false);\r\n        //\t\tinitResources();\r\n    }\r\n\r\n    //\tprotected void initResources()\r\n    //\t{\r\n    //\t\tinitTextBundleMap();\r\n    //\r\n    //\t\t//URL backgroundImageUrl=resourceSupport.getResource(BACKGROUND_IMAGE_RESOURCE);\r\n    //\t\t//URL imageUrl=resourceSupport.getResource(ABOUT_IMAGE_RESOURCE);\r\n    //\t\t//scrollText=getTextResource(SCROLL_TEXT_RESOURCE, null);\r\n    //\t\tversionText=getTextResource(VERSION_TEXT_RESOURCE, null);\r\n    //\t\tint versionHeight=-1;\r\n    //\t\ttry\r\n    //\t\t{\r\n    //\t\t\tversionHeight=Integer.parseInt(getTextResource(VERSION_HEIGHT_RESOURCE, \"-1\"));\r\n    //\t\t}\r\n    //\t\tcatch(NumberFormatException ex)\r\n    //\t\t{\r\n    //\t\t\tif(logger.isWarnEnabled()) logger.warn(\"Illegal integer value!\", ex);\r\n    //\t\t}\r\n    //\r\n    //\t\tRectangle scrollArea=new Rectangle(-1, -1, -1, -1);\r\n    //\t\ttry\r\n    //\t\t{\r\n    //\t\t\tscrollArea.x=Integer.parseInt(getTextResource(SCROLL_AREA_X_RESOURCE, \"-1\"));\r\n    //\t\t}\r\n    //\t\tcatch(NumberFormatException ex)\r\n    //\t\t{\r\n    //\t\t\tif(logger.isWarnEnabled()) logger.warn(\"Illegal integer value!\", ex);\r\n    //\t\t}\r\n    //\t\ttry\r\n    //\t\t{\r\n    //\t\t\tscrollArea.y=Integer.parseInt(getTextResource(SCROLL_AREA_Y_RESOURCE, \"-1\"));\r\n    //\t\t}\r\n    //\t\tcatch(NumberFormatException ex)\r\n    //\t\t{\r\n    //\t\t\tif(logger.isWarnEnabled()) logger.warn(\"Illegal integer value!\", ex);\r\n    //\t\t}\r\n    //\t\ttry\r\n    //\t\t{\r\n    //\t\t\tscrollArea.width=Integer.parseInt(getTextResource(SCROLL_AREA_WIDTH_RESOURCE, \"-1\"));\r\n    //\t\t}\r\n    //\t\tcatch(NumberFormatException ex)\r\n    //\t\t{\r\n    //\t\t\tif(logger.isWarnEnabled()) logger.warn(\"Illegal integer value!\", ex);\r\n    //\t\t}\r\n    //\t\ttry\r\n    //\t\t{\r\n    //\t\t\tscrollArea.height=Integer.parseInt(getTextResource(SCROLL_AREA_HEIGHT_RESOURCE, \"-1\"));\r\n    //\t\t}\r\n    //\t\tcatch(NumberFormatException ex)\r\n    //\t\t{\r\n    //\t\t\tif(logger.isWarnEnabled()) logger.warn(\"Illegal integer value!\", ex);\r\n    //\t\t}\r\n    //\t\tif(\tscrollArea.x == -1 ||\r\n    //\t\t\tscrollArea.y == -1 ||\r\n    //\t\t\tscrollArea.width == -1 ||\r\n    //\t\t\tscrollArea.height == -1 )\r\n    //\t\t{\r\n    //\t\t\t// ignore if scroll-area isn't fully specified\r\n    //\t\t\tscrollArea = null;\r\n    //\t\t}\r\n    //\t\tinit(backgroundImageUrl, scrollArea, scrollText, imageUrl, versionText, versionHeight );\r\n    //\t\t//setScrollAreaToolTipText(getTextResource(SCROLL_AREA_TOOLTIP_TEXT_RESOURCE, null));\r\n    //\t}\r\n    //\tprotected void initTextBundleMap()\r\n    //\t{\r\n    //\t\ttextBundleMap=resourceSupport.getResourceMap(TEXT_RESOURCE_BUNDLE_RESOURCE, getLocale());\r\n    //\t\tif(logger.isDebugEnabled() && textBundleMap!=null)\r\n    //\t\t{\r\n    //\t\t\tStringBuffer buffer=new StringBuffer();\r\n    //\r\n    //\t\t\tIterator iter=textBundleMap.keySet().iterator();\r\n    //\t\t\twhile(iter.hasNext())\r\n    //\t\t\t{\r\n    //\t\t\t\tObject key=iter.next();\r\n    //\t\t\t\tObject value=textBundleMap.get(key);\r\n    //\t\t\t\tbuffer.append(\"Key: \");\r\n    //\t\t\t\tbuffer.append(key);\r\n    //\t\t\t\tbuffer.append(\"    Value: \");\r\n    //\t\t\t\tbuffer.append(value);\r\n    //\t\t\t\tbuffer.append(\"\\n\");\r\n    //\r\n    //\t\t\t}\r\n    //\t\t\tlogger.debug(\"BundleMap \\\"\"+TEXT_RESOURCE_BUNDLE_RESOURCE+\"\\\" of class \"+getClass().getName()+\":\\n\"+buffer.toString());\r\n    //\t\t}\r\n    //\t\tif(logger.isInfoEnabled() && textBundleMap==null)\r\n    //\t\t{\r\n    //\t\t\tlogger.info(\"Couldn't find BundleMap \\\"\"+TEXT_RESOURCE_BUNDLE_RESOURCE+\"\\\" of class \"+getClass().getName()+\".\");\r\n    //\t\t}\r\n    //\t}\r\n    //\tprotected String getTextResource(final String resourceName, final String defaultValue)\r\n    //\t{\r\n    //\t\tString result=null;\r\n    //\t\tif(textBundleMap!=null)\r\n    //\t\t{\r\n    //\t\t\tresult=(String)textBundleMap.get(resourceName);\r\n    //\t\t}\r\n    //\t\tif(result==null)\r\n    //\t\t{\r\n    //\t\t\tresult=defaultValue;\r\n    //\t\t\tif(logger.isDebugEnabled()) logger.debug(\"Using default-value '\"+defaultValue+\"' for text-resource '\"+resourceName+\"'.\");\r\n    //\t\t}\r\n    //\r\n    //\t\treturn result;\r\n    //\t}\r\n    private void init(URL backgroundImageUrl, Rectangle scrollArea, String scrollText, URL imageUrl, String versionText, int versionHeight) throws IOException {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"init called with following arguments: backgroundImageUrl=\" + backgroundImageUrl + \", \" + \"scrollArea=\" + scrollArea + \", scrollText=\" + scrollText + \", imageUrl=\" + imageUrl + \", versionText=\" + versionText + \", versionHeight=\" + versionHeight);\r\n        }\r\n        setBackgroundImage(backgroundImageUrl);\r\n        setScrollArea(scrollArea);\r\n        setAboutImage(imageUrl);\r\n        this.versionText = versionText;\r\n        this.versionHeight = versionHeight;\r\n        setScrollText(scrollText);\r\n    }\r\n\r\n    /*\r\n\tprotected synchronized boolean isPainted()\r\n\t{\r\n\t\treturn painted;\r\n\t}\r\n\r\n\tprotected synchronized void setPainted(boolean painted)\r\n\t{\r\n\t\tif(this.painted!=painted)\r\n\t\t{\r\n\t\t\tthis.painted=painted;\r\n\t\t\tnotifyAll();\r\n\t\t}\r\n\t}\r\n    */\r\n    private void initAttributes() {\r\n        //setPainted(true);\r\n        preferredSize = new Dimension();\r\n        offscreenOffset = new Point();\r\n        backgroundImageArea = new Rectangle();\r\n        translatedScrollArea = new Rectangle();\r\n        translatedBackgroundImageArea = new Rectangle();\r\n        scrollArea = new Rectangle();\r\n        paintArea = new Rectangle();\r\n        insets = getInsets();\r\n    }\r\n\r\n    public void setScrollText(String ScrollText) {\r\n        StringTokenizer st = new StringTokenizer(ScrollText, \"\\n\", true);\r\n        List<String> lines = new ArrayList<String>(st.countTokens() / 2);\r\n        String prevToken = null;\r\n        while (st.hasMoreTokens()) {\r\n            String token = st.nextToken();\r\n            if (token.equals(\"\\n\")) {\r\n                if (prevToken != null && !prevToken.equals(\"\\n\")) {\r\n                    lines.add(prevToken);\r\n                } else {\r\n                    lines.add(\"\");\r\n                }\r\n            }\r\n            prevToken = token;\r\n        }\r\n        if (prevToken != null && !prevToken.equals(\"\\n\")) {\r\n            lines.add(prevToken);\r\n        }\r\n        String[] loScrollLines = new String[lines.size()];\r\n        loScrollLines = lines.toArray(loScrollLines);\r\n        setScrollLines(loScrollLines);\r\n    }\r\n\r\n    protected void setScrollLines(String[] scrollLines) {\r\n        if (scrollLines == null) {\r\n            NullPointerException ex = new NullPointerException(\"scrollLines must not be null!\");\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"Parameter 'scrollLines' of method 'setScrollLines' must not be null!\", ex);\r\n            }\r\n            throw ex;\r\n        }\r\n        this.scrollLines = scrollLines.clone();\r\n        flushScrollImage();\r\n    }\r\n\r\n    /**\r\n     * Sets the backgroundImage attribute of the <code>AboutPanel</code> object\r\n     */\r\n    public void setBackgroundImage(URL imageUrl) throws IOException {\r\n        setBackgroundImage(GraphicsUtilities.loadCompatibleImage(imageUrl));\r\n    }\r\n\r\n    /**\r\n     * Sets the backgroundImage attribute of the <code>AboutPanel</code> object\r\n     *\r\n     * @param BackgroundImage The new backgroundImage value\r\n     */\r\n    public void setBackgroundImage(BufferedImage BackgroundImage) {\r\n        if (backgroundImage != null) {\r\n            backgroundImage.flush();\r\n            backgroundImage = null;\r\n        }\r\n        backgroundImage = BackgroundImage;\r\n        updateBackgroundAttributes();\r\n    }\r\n\r\n    public void setAboutImage(URL imageUrl) throws IOException {\r\n        setAboutImage(GraphicsUtilities.loadCompatibleImage(imageUrl));\r\n    }\r\n\r\n    public void setAboutImage(BufferedImage AboutImage) {\r\n        if (aboutImage != null) {\r\n            aboutImage.flush();\r\n            aboutImage = null;\r\n        }\r\n        aboutImage = AboutImage;\r\n        flushScrollImage();\r\n    }\r\n\r\n    /**\r\n     * Sets the scrollArea attribute of the <code>AboutPanel</code> object\r\n     *\r\n     * @param ScrollArea The new scrollArea value\r\n     */\r\n    public void setScrollArea(Rectangle ScrollArea) {\r\n        if (ScrollArea != null) {\r\n            maxScrollArea = backgroundImageArea.intersection(ScrollArea);\r\n        } else {\r\n            maxScrollArea = (Rectangle) backgroundImageArea.clone();\r\n        }\r\n        minScrollPosition = -maxScrollArea.height;\r\n        calculateAttributes();\r\n        flushScrollImage();\r\n    }\r\n\r\n    /**\r\n     * Description of the Method\r\n     */\r\n    private void flushScrollImage() {\r\n        if (scrollImage != null) {\r\n            if (logger.isInfoEnabled())\r\n                logger.info(\"Flushing ScrollImage\");\r\n            scrollImage.flush();\r\n            scrollImage = null;\r\n        }\r\n        setScrollPosition(minScrollPosition);\r\n    }\r\n\r\n    /**\r\n     * Description of the Method\r\n     */\r\n    private void flushOffscreenImage() {\r\n        if (offscreenImage != null) {\r\n            if (logger.isInfoEnabled())\r\n                logger.info(\"Flushing OffscreenImage\");\r\n            offscreenImage.flush();\r\n            offscreenImage = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Description of the Method\r\n     */\r\n    private void updateBackgroundAttributes() {\r\n        backgroundImageArea.x = 0;\r\n        backgroundImageArea.y = 0;\r\n        backgroundImageArea.width = backgroundImage.getWidth();\r\n        backgroundImageArea.height = backgroundImage.getHeight();\r\n        calculatePreferredSize();\r\n        if (maxScrollArea != null) {\r\n            maxScrollArea = maxScrollArea.intersection(backgroundImageArea);\r\n        } else {\r\n            maxScrollArea = (Rectangle) backgroundImageArea.clone();\r\n        }\r\n        flushOffscreenImage();\r\n        flushScrollImage();\r\n        repaint();\r\n    }\r\n\r\n    /**\r\n     * Sets the ToolTipText that will appear if the user moves the mouse over the\r\n     * scroll-area of this component.\r\n     *\r\n     * @param toolTipText The new ScrollAreaToolTipText value\r\n     */\r\n    public void setScrollAreaToolTipText(String toolTipText) {\r\n        scrollAreaToolTipText = toolTipText;\r\n    }\r\n\r\n    /**\r\n     * Gets the ScrollAreaToolTipText attribute of the <code>AboutPanel</code>\r\n     * object\r\n     *\r\n     * @return The ScrollAreaToolTipText value\r\n     */\r\n    public String getScrollAreaToolTipText() {\r\n        return scrollAreaToolTipText;\r\n    }\r\n\r\n    /**\r\n     * This method returns ScrollAreaToolTipText if the point of the <code>MouseEvent</code>\r\n     * is inside the scroll-area and <code>null</code> otherwise.<p />\r\n     * <p/>\r\n     * It's needed by the <code>ToolTipManager</code> .\r\n     *\r\n     * @param evt a <code>MouseEvent</code>.\r\n     * @return The toolTipText value for the <code>ToolTipManager</code>.\r\n     */\r\n    public String getToolTipText(MouseEvent evt) {\r\n        if (handleMouseEvent(evt)) {\r\n            return scrollAreaToolTipText;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    protected boolean handleMouseEvent(MouseEvent evt) {\r\n        Rectangle loArea = null;\r\n        if (mouseEventHandling == MOUSE_BACKGROUND) {\r\n            loArea = translatedBackgroundImageArea;\r\n        } else if (mouseEventHandling == MOUSE_SCROLLAREA) {\r\n            loArea = translatedScrollArea;\r\n        } else if (mouseEventHandling == MOUSE_DISABLED) {\r\n            return false;\r\n        }\r\n        Point loPoint = evt.getPoint();\r\n        if (loArea == null) {\r\n            // -> default: MOUSE_COMPONENT\r\n            return contains(loPoint);\r\n        }\r\n        if (loArea.contains(loPoint)) {\r\n            // MOUSE_BACKGROUND / MOUSE_SCROLLAREA\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Increases the ScrollPosition by SCROLL_PIXELS. This method is called by the\r\n     * scroll-thread and calls <code>setScrollPosition</code>, therefore causing a\r\n     * repaint of the scroll-area..\r\n     *\r\n     * @see #setScrollPosition\r\n     */\r\n    protected void increaseScrollPosition() {\r\n        setScrollPosition(scrollPosition + SCROLL_PIXELS);\r\n    }\r\n\r\n    /**\r\n     * Sets the scrollPosition attribute of the <code>AboutPanel</code> object. The\r\n     * value will be corrected according Minimum- and MaximumScrollPosition.\r\n     * Changing the scroll-position will result in a repaint of the scroll-area.\r\n     *\r\n     * @param scrollPosition The new scrollPosition value. This value indicates\r\n     *                       the height-offset of the scroll-area.\r\n     * @see #getMinimumScrollPosition\r\n     * @see #getMaximumScrollPosition\r\n     */\r\n    public void setScrollPosition(int scrollPosition) {\r\n        if (scrollPosition > maxScrollPosition) {\r\n            int remainder = scrollPosition % maxScrollPosition;\r\n            scrollPosition = minScrollPosition + remainder;\r\n        } else if (scrollPosition < minScrollPosition) {\r\n            int remainder = scrollPosition % minScrollPosition;\r\n            scrollPosition = maxScrollPosition + remainder;\r\n        }\r\n        if (this.scrollPosition != scrollPosition) {\r\n            this.scrollPosition = scrollPosition;\r\n            repaintScrollArea();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the ScrollPosition attribute of the <code>AboutPanel</code> object\r\n     *\r\n     * @return this value indicates the height-offset of the scroll-area.\r\n     */\r\n    public int getScrollPosition() {\r\n        return scrollPosition;\r\n    }\r\n\r\n    /**\r\n     * Gets the MinimumScrollPosition attribute of the <code>AboutPanel</code>\r\n     * object. It's value is the negated value of the scroll-area-height.\r\n     *\r\n     * @return The MinimumScrollPosition value\r\n     */\r\n    public int getMinimumScrollPosition() {\r\n        return minScrollPosition;\r\n    }\r\n\r\n    /**\r\n     * Gets the MaximumScrollPosition attribute of the <code>AboutPanel</code>\r\n     * object. It's value is the height needed for all lines of text plus (if\r\n     * available) the height of the image with an additional empty line.\r\n     *\r\n     * @return The MaximumScrollPosition value\r\n     */\r\n    public int getMaximumScrollPosition() {\r\n        return maxScrollPosition;\r\n    }\r\n\r\n    /**\r\n     * This method creates the offscreen-image when needed (when called for the\r\n     * first time or recreated because of a changed font) and updates it on\r\n     * subsequent calls by calling <code>updateOffscreenImage()</code>.\r\n     */\r\n    private void processOffscreenImage() {\r\n        Graphics2D g;\r\n        if (offscreenImage == null) {\r\n            if (logger.isInfoEnabled())\r\n                logger.info(\"Creating offscreen-image\");\r\n            boolean opaque = false;\r\n            if (isOpaque()) {\r\n                offscreenImage = GraphicsUtilities.createOpaqueCompatibleImage(backgroundImageArea.width, backgroundImageArea.height);\r\n                opaque = true;\r\n            } else {\r\n                offscreenImage = GraphicsUtilities.createTranslucentCompatibleImage(backgroundImageArea.width, backgroundImageArea.height);\r\n            }\r\n            g = (Graphics2D) offscreenImage.getGraphics();\r\n            if (opaque) {\r\n                g.setColor(getBackground());\r\n                g.fillRect(backgroundImageArea.x, backgroundImageArea.y, backgroundImageArea.width, backgroundImageArea.height);\r\n            }\r\n            g.drawImage(backgroundImage, 0, 0, null);\r\n            if (versionText != null) {\r\n                // draw version-text...\r\n                g.setColor(getForeground());\r\n                g.drawString(versionText, maxScrollArea.x + (maxScrollArea.width - fontMetrics.stringWidth(versionText)) / 2, versionHeight);\r\n            }\r\n        } else {\r\n            g = (Graphics2D) offscreenImage.getGraphics();\r\n        }\r\n        g.setFont(getFont());\r\n        drawScrollArea(g);\r\n        g.dispose();\r\n    }\r\n\r\n    /**\r\n     * Updates the offscreen-image to represent the current scroll-position. It\r\n     * calls <code>initScrollImage()</code>.\r\n     *\r\n     * @param g <code>Graphics</code>-object\r\n     */\r\n    private void drawScrollArea(Graphics2D g) {\r\n        initScrollImage();\r\n        // only draw in the scroll-area\r\n        g.setClip(scrollArea.x, scrollArea.y, scrollArea.width, scrollArea.height);\r\n        // clear background for transparent bg-images\r\n        g.setColor(getBackground());\r\n        g.fillRect(scrollArea.x, scrollArea.y, scrollArea.width, scrollArea.height);\r\n        // draw background-image\r\n        g.drawImage(backgroundImage, 0, 0, this);\r\n        // redraw version-text if available.\r\n        if (versionText != null) {\r\n            g.setColor(getForeground());\r\n            g.drawString(versionText, maxScrollArea.x + (maxScrollArea.width - fontMetrics.stringWidth(versionText)) / 2, versionHeight);\r\n        }\r\n        // draw proper part of precalculated scroll-image.\r\n        g.drawImage(scrollImage, scrollArea.x, scrollArea.y - scrollPosition, this);\r\n        if (debug) {\r\n            g.setColor(Color.YELLOW);\r\n            g.drawRect(scrollArea.x, scrollArea.y, scrollArea.width - 1, scrollArea.height - 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the scroll-image if needed. The scroll-image is as high as\r\n     * needed to contain all the scroll-lines and (if available) the image.\r\n     */\r\n    private void initScrollImage() {\r\n        int fontHeight = fontMetrics.getHeight();\r\n        maxScrollPosition = fontHeight * (scrollLines.length);\r\n        int additionalImageOffset = 0;\r\n        int imageWidth = 0;\r\n        if (aboutImage != null) {\r\n            imageWidth = aboutImage.getWidth();\r\n            additionalImageOffset = aboutImage.getHeight() + 2 * fontHeight;\r\n            maxScrollPosition = maxScrollPosition + additionalImageOffset;\r\n        }\r\n        if (scrollImage != null && scrollImage.getHeight() != maxScrollPosition) {\r\n            flushScrollImage();\r\n        }\r\n        if (scrollImage == null) {\r\n            int maxWidth = imageWidth + 2 * fontHeight;\r\n            if (logger.isInfoEnabled())\r\n                logger.info(\"imageWidth={}, maxWidth={}\", imageWidth, maxWidth);\r\n            for (String scrollLine : scrollLines) {\r\n                int curWidth = fontMetrics.stringWidth(scrollLine);\r\n                if (curWidth > maxWidth) {\r\n                    maxWidth = curWidth;\r\n                }\r\n            }\r\n            if (maxWidth > maxScrollArea.width) {\r\n                if (logger.isInfoEnabled())\r\n                    logger.info(\"maxWidth={} != maxScrollArea=\", maxWidth, maxScrollArea);\r\n                maxWidth = maxScrollArea.width;\r\n            }\r\n            scrollArea.x = maxScrollArea.x + (maxScrollArea.width - maxWidth) / 2;\r\n            scrollArea.y = maxScrollArea.y;\r\n            scrollArea.width = maxWidth;\r\n            scrollArea.height = maxScrollArea.height;\r\n            scrollImage = GraphicsUtilities.createTranslucentCompatibleImage(scrollArea.width, maxScrollPosition);\r\n            Color foreground = getForeground();\r\n            Graphics2D g;\r\n            g = (Graphics2D) scrollImage.getGraphics();\r\n            g.setFont(getFont());\r\n            if (aboutImage != null) {\r\n                g.drawImage(aboutImage, (((scrollArea.width - imageWidth) / 2)), fontHeight, null);\r\n            }\r\n            g.setColor(foreground);\r\n            int y = fontMetrics.getAscent() + additionalImageOffset;\r\n            for (String line : scrollLines) {\r\n                g.drawString(line, (scrollArea.width - fontMetrics.stringWidth(line)) / 2, y);\r\n                y += fontHeight;\r\n            }\r\n            g.dispose();\r\n            BufferedImage copy = GraphicsUtilities.createCompatibleCopy(scrollImage);\r\n            BufferedImageOp filter;\r\n            final int blurSize = 10;\r\n            filter = getGaussianBlurFilter(blurSize, false);\r\n            scrollImage = filter.filter(scrollImage, null);\r\n            filter = getGaussianBlurFilter(blurSize, true);\r\n            scrollImage = filter.filter(scrollImage, null);\r\n            filter = new ColorTintFilter(Color.GREEN, 1.0f);\r\n            scrollImage = filter.filter(scrollImage, null);\r\n            g = (Graphics2D) scrollImage.getGraphics();\r\n            g.setComposite(AlphaComposite.SrcOver);\r\n            g.drawImage(copy, 0, 0, null);\r\n            if (debug) {\r\n                g.setColor(Color.RED);\r\n                g.drawRect(0, 0, scrollImage.getWidth() - 1, scrollImage.getHeight() - 1);\r\n                g.setColor(Color.GREEN);\r\n                g.drawRect((((scrollArea.width - imageWidth) / 2)), fontHeight, aboutImage.getWidth(), aboutImage.getHeight());\r\n            }\r\n            g.dispose();\r\n            copy.flush();\r\n        }\r\n    }\r\n\r\n    public static ConvolveOp getGaussianBlurFilter(int radius, boolean horizontal) {\r\n        final Logger logger = LoggerFactory.getLogger(AboutPanel.class);\r\n        if (radius < 1) {\r\n            throw new IllegalArgumentException(\"Radius must be >= 1\");\r\n        }\r\n        int size = radius * 2 + 1;\r\n        float[] data = new float[size];\r\n        float sigma = radius / 3.0f;\r\n        float twoSigmaSquare = 2.0f * sigma * sigma;\r\n        float sigmaRoot = (float) Math.sqrt(twoSigmaSquare * Math.PI);\r\n        float total = 0.0f;\r\n        for (int i = -radius; i <= radius; i++) {\r\n            float distance = i * i;\r\n            int index = i + radius;\r\n            data[index] = (float) Math.exp(-distance / twoSigmaSquare) / sigmaRoot;\r\n            total += data[index];\r\n        }\r\n        for (int i = 0; i < data.length; i++) {\r\n            data[i] /= total;\r\n            if (logger.isDebugEnabled())\r\n                logger.debug(\"data[{}]={}\", i, data[i]);\r\n        }\r\n        Kernel kernel = null;\r\n        if (horizontal) {\r\n            kernel = new Kernel(size, 1, data);\r\n        } else {\r\n            kernel = new Kernel(1, size, data);\r\n        }\r\n        return new ConvolveOp(kernel, ConvolveOp.EDGE_NO_OP, null);\r\n    }\r\n\r\n    /**\r\n     * Sets the font attribute of the <code>AboutPanel</code> object. Setting it\r\n     * will result in the recreation of all buffers. The font can even be safely\r\n     * changed while the component is visible. It will be used for the version- and\r\n     * scroll-text.<p />\r\n     * <p/>\r\n     * If the parameter is <code>null</code> then <code>UIManager.getFont( \"Label.font\" )</code>\r\n     * will be used.\r\n     *\r\n     * @param newFont The new font value.\r\n     */\r\n    public void setFont(Font newFont) {\r\n        if (newFont == null) {\r\n            newFont = UIManager.getFont(\"Label.font\");\r\n        }\r\n        if (newFont != null && !newFont.equals(getFont())) {\r\n            super.setFont(newFont);\r\n            fontMetrics = getFontMetrics(newFont);\r\n            flushScrollImage();\r\n        }\r\n    }\r\n\r\n    /*\r\n\tFontRenderContext frc = g2.getFontRenderContext();\r\n        Font f = new Font(\"sansserif\",Font.PLAIN,w/8);\r\n        Font f1 = new Font(\"sansserif\",Font.ITALIC,w/8);\r\n        String s = \"AttributedString\";\r\n        AttributedString as = new AttributedString(s);\r\n\r\n\r\n        // applies the TextAttribute.Font attribute to the AttributedString\r\n        // with the range 0 to 10, which encompasses the letters 'A' through\r\n        // 'd' of the String \"AttributedString\"\r\n        as.addAttribute(TextAttribute.FONT, f, 0, 10 );\r\n\r\n        // applies the TextAttribute.Font attribute to the AttributedString\r\n        // with the range 10 to the length of the String s, which encompasses\r\n        // the letters 'S' through 'g' of String \"AttributedString\"\r\n        as.addAttribute(TextAttribute.FONT, f1, 10, s.length() );\r\n\r\n        AttributedCharacterIterator aci = as.getIterator();\r\n\r\n        // creates a TextLayout from the AttributedCharacterIterator\r\n        TextLayout tl = new TextLayout (aci, frc);\r\n        float sw = (float) tl.getBounds().getWidth();\r\n        float sh = (float) tl.getBounds().getHeight();\r\n\r\n        // creates an outline shape from the TextLayout and centers it\r\n        // with respect to the width of the surface\r\n        Shape sha = tl.getOutline(AffineTransform.getTranslateInstance(w/2-sw/2, h*0.2+sh/2));\r\n        g2.setColor(Color.blue);\r\n        g2.setStroke(new BasicStroke(1.5f));\r\n        g2.draw(sha);\r\n        g2.setColor(Color.magenta);\r\n        g2.fill(sha);\r\n\t*/\r\n    /**\r\n     * Paints this component.\r\n     *\r\n     * @param _g <code>Graphics</code>-object\r\n     */\r\n    public void paintComponent(Graphics _g) {\r\n        super.paintComponent(_g);\r\n        processOffscreenImage();\r\n        // we need to create a copy of the given graphics since we\r\n        // change the clip. Otherwise the border wouldn't be painted\r\n        // propertly (not at all in this case).\r\n        Graphics2D g = (Graphics2D) _g.create();\r\n        g.setClip(paintArea.x, paintArea.y, paintArea.width, paintArea.height);\r\n        g.drawImage(offscreenImage, paintArea.x + offscreenOffset.x, paintArea.y + offscreenOffset.y, this);\r\n        g.dispose();\r\n        //setPainted(true);\r\n    }\r\n\r\n    /**\r\n     * Makes sure that the private attributes size, paintArea, offscreenOffset and\r\n     * translated areas have sane values. It's called on component-resize.\r\n     */\r\n    private void calculateAttributes() {\r\n        size = getSize(size);\r\n        paintArea.x = insets.left;\r\n        paintArea.y = insets.top;\r\n        paintArea.width = size.width - insets.left - insets.right;\r\n        paintArea.height = size.height - insets.top - insets.bottom;\r\n        int loOffscreenOffsetX = (paintArea.width - preferredSize.width) / 2;\r\n        int loOffscreenOffsetY = (paintArea.height - preferredSize.height) / 2;\r\n        if (loOffscreenOffsetX < 0) {\r\n            loOffscreenOffsetX = 0;\r\n        }\r\n        if (loOffscreenOffsetY < 0) {\r\n            loOffscreenOffsetY = 0;\r\n        }\r\n        offscreenOffset.x = loOffscreenOffsetX;\r\n        offscreenOffset.y = loOffscreenOffsetY;\r\n        translatedScrollArea.x = maxScrollArea.x + offscreenOffset.x;\r\n        translatedScrollArea.y = maxScrollArea.y + offscreenOffset.y;\r\n        translatedScrollArea.width = maxScrollArea.width;\r\n        translatedScrollArea.height = maxScrollArea.height;\r\n        translatedBackgroundImageArea.x = backgroundImageArea.x + offscreenOffset.x;\r\n        translatedBackgroundImageArea.y = backgroundImageArea.y + offscreenOffset.y;\r\n        translatedBackgroundImageArea.width = backgroundImageArea.width;\r\n        translatedBackgroundImageArea.height = backgroundImageArea.height;\r\n        repaint();\r\n    }\r\n\r\n    /**\r\n     * This methods takes the insets (the border) of this component into account\r\n     * when the preferred size is calculated. Any border will work. It is called by\r\n     * the property-change-listener if the border was changed.\r\n     */\r\n    protected void calculatePreferredSize() {\r\n        insets = getInsets(insets);\r\n        preferredSize.width = insets.left + insets.right + backgroundImageArea.width;\r\n        preferredSize.height = insets.top + insets.bottom + backgroundImageArea.height;\r\n        setPreferredSize(preferredSize);\r\n        invalidate();\r\n    }\r\n\r\n    /**\r\n     * This method requests a repaint of the scroll-area. The rest of the component\r\n     * will not be repainted. It is called by <code>setScrollPosition()</code> .\r\n     *\r\n     * @see\r\n     */\r\n    private void repaintScrollArea() {\r\n        //setPainted(false);\r\n        repaint(scrollArea.x + offscreenOffset.x, scrollArea.y + offscreenOffset.y, // + 1,\r\n        scrollArea.width, // + 1 );\r\n        scrollArea.height);\r\n    }\r\n\r\n    /**\r\n     * This method calls <code>super.addNotify()</code> and notifies the\r\n     * scroll-thread by calling <code>setScrolling(true)</code>. It also\r\n     * (re)initializes the scroll-position to MinimumScrollPosition (this is always\r\n     * the negative height of the scroll-rectangle) and registers tbis component at\r\n     * the <code>ToolTipManager</code>.\r\n     *\r\n     * @see #setScrolling\r\n     * @see #setScrollPosition\r\n     * @see #getMinimumScrollPosition\r\n     */\r\n    public void addNotify() {\r\n        super.addNotify();\r\n        setScrolling(true);\r\n        ToolTipManager.sharedInstance().registerComponent(this);\r\n    }\r\n\r\n    /**\r\n     * This method calls <code>super.removeNotify()</code> and sends the\r\n     * scroll-thread into a wait-state by calling <code>setScrolling(false)</code>\r\n     * . It also unregisters this component from the <code>ToolTipManager</code>.\r\n     *\r\n     * @see #setScrolling\r\n     */\r\n    public void removeNotify() {\r\n        super.removeNotify();\r\n        setScrolling(false);\r\n        ToolTipManager.sharedInstance().unregisterComponent(this);\r\n        // flush used buffer-images.\r\n        flushOffscreenImage();\r\n        flushScrollImage();\r\n    }\r\n\r\n    /**\r\n     * This method is used to set the scrolling-property of this component. A value\r\n     * of <code>true</code> will notify the scroll-thread that it has to resume\r\n     * work. A value of <code>false</code> will send it into wait-state instead.\r\n     *\r\n     * @param Scrolling The new scrolling value\r\n     */\r\n    public void setScrolling(boolean Scrolling) {\r\n        if (scrolling != Scrolling) {\r\n            scrolling = Scrolling;\r\n            if (scrolling) {\r\n                timer.start();\r\n                if (logger.isInfoEnabled())\r\n                    logger.info(\"Timer started.\");\r\n            } else {\r\n                timer.stop();\r\n                if (logger.isInfoEnabled())\r\n                    logger.info(\"Timer stopped.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method returns <code>true</code> if scrolling is currently active. If\r\n     * it returns <code>false</code> then the scroll-thread is waiting.\r\n     *\r\n     * @return The scrolling value\r\n     */\r\n    public boolean isScrolling() {\r\n        return scrolling;\r\n    }\r\n\r\n    /**\r\n     * Description of the Class\r\n     *\r\n     * @author Joern Huxhorn\r\n     */\r\n    class AboutComponentListener extends ComponentAdapter {\r\n\r\n        /**\r\n         * Description of the Method\r\n         *\r\n         * @param e Description of the Parameter\r\n         */\r\n        public void componentResized(ComponentEvent e) {\r\n            AboutPanel.this.calculateAttributes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Description of the Class\r\n     *\r\n     * @author Joern Huxhorn\r\n     */\r\n    class AboutPropertyChangeListener implements PropertyChangeListener {\r\n\r\n        /**\r\n         * Description of the Method\r\n         *\r\n         * @param evt Description of the Parameter\r\n         */\r\n        public void propertyChange(PropertyChangeEvent evt) {\r\n            String propertyName = evt.getPropertyName();\r\n            if (propertyName.equals(\"border\")) {\r\n                calculatePreferredSize();\r\n            } else if (propertyName.equals(\"foreground\")) {\r\n                flushScrollImage();\r\n            } else if (propertyName.equals(\"background\")) {\r\n                flushScrollImage();\r\n            }\r\n            //\t\t\telse if ( propertyName.equals( \"locale\" ) )\r\n            //\t\t\t{\r\n            //\t\t\t\tinitResources();\r\n            //\t\t\t}\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This <code>MouseInputListener</code> handles the pause/resume on click as\r\n     * well as the dragging inside the scroll-area.\r\n     *\r\n     * @author Joern Huxhorn\r\n     */\r\n    class AboutMouseInputListener extends MouseInputAdapter {\r\n\r\n        Point lastPoint = null;\r\n\r\n        boolean scrollingBeforePress = false;\r\n\r\n        boolean dragged = false;\r\n\r\n        /**\r\n         * Description of the Method\r\n         *\r\n         * @param evt Description of the Parameter\r\n         */\r\n        public void mousePressed(MouseEvent evt) {\r\n            if (handleMouseEvent(evt)) {\r\n                // always stop scrolling if mouse is pressed inside\r\n                // the scroll-area\r\n                lastPoint = evt.getPoint();\r\n                scrollingBeforePress = isScrolling();\r\n                setScrolling(false);\r\n            } else {\r\n                lastPoint = null;\r\n            }\r\n            dragged = false;\r\n        }\r\n\r\n        /**\r\n         * Description of the Method\r\n         *\r\n         * @param evt Description of the Parameter\r\n         */\r\n        public void mouseReleased(MouseEvent evt) {\r\n            if (dragged) {\r\n                // set scrolling-attribute to the value before the user dragged.\r\n                lastPoint = null;\r\n                setScrolling(scrollingBeforePress);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Description of the Method\r\n         *\r\n         * @param evt Description of the Parameter\r\n         */\r\n        public void mouseClicked(MouseEvent evt) {\r\n            // this is only called after mouseReleased if no drag occurred.\r\n            if (handleMouseEvent(evt)) {\r\n                // toggle scrolling.\r\n                setScrolling(!scrollingBeforePress);\r\n            }\r\n            dragged = false;\r\n        }\r\n\r\n        /**\r\n         * Description of the Method\r\n         *\r\n         * @param evt Description of the Parameter\r\n         */\r\n        public void mouseDragged(MouseEvent evt) {\r\n            // only drag if original press was inside scroll-rectangle\r\n            if (lastPoint != null) {\r\n                dragged = true;\r\n                Point currentPoint = evt.getPoint();\r\n                int yOffset = lastPoint.y - currentPoint.y;\r\n                setScrollPosition(getScrollPosition() + yOffset);\r\n                lastPoint = currentPoint;\r\n            }\r\n        }\r\n    }\r\n\r\n    private class TimerActionListener implements ActionListener {\r\n\r\n        private final Logger logger = LoggerFactory.getLogger(AboutPanel.class);\r\n\r\n        private long lastRepaintStart;\r\n\r\n        private long frequency = 25;\r\n\r\n        public void actionPerformed(ActionEvent e) {\r\n            long currentTime = System.nanoTime() / 1000000;\r\n            long meanTime = currentTime - lastRepaintStart;\r\n            if (meanTime > frequency) {\r\n                if (logger.isDebugEnabled())\r\n                    logger.debug(\"Tick! meanTime={}\", meanTime);\r\n                increaseScrollPosition();\r\n                lastRepaintStart = currentTime;\r\n            }\r\n        }\r\n    }\r\n    //\tpublic static class Example\r\n    //\t{\r\n    //\t\tprivate JFrame dummyFrame;\r\n    //\t\tprivate JDialog dialog;\r\n    //\r\n    //\t\tprivate AboutPanel theAboutPanel;\r\n    //\t\tprivate static JFileChooser chooser=new JFileChooser(new File(\".\"));\r\n    //\r\n    //\t\tabstract class SelectionAction extends AbstractAction\r\n    //\t\t{\r\n    //\t\t\tprotected SelectionAction(String name)\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(name);\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic abstract void setImage(URL url);\r\n    //\r\n    //\t\t\tpublic void actionPerformed(ActionEvent evt)\r\n    //\t\t\t{\r\n    //\t\t\t\tint returnVal = chooser.showOpenDialog(dialog);\r\n    //\t\t\t\tif(returnVal == JFileChooser.APPROVE_OPTION)\r\n    //\t\t\t\t{\r\n    //\t\t\t\t\tFile file = chooser.getSelectedFile();\r\n    //\t\t\t\t\tSystem.out.println(\"You chose to open this file: \" + file.getName());\r\n    //\t\t\t\t\ttry\r\n    //\t\t\t\t\t{\r\n    //\t\t\t\t\t\tsetImage(file.toURL());\r\n    //\t\t\t\t\t\tAboutPanel.Example.this.theAboutPanel.setScrollArea(null);\r\n    //\t\t\t\t\t\tdialog.pack();\r\n    //\t\t\t\t\t}\r\n    //\t\t\t\t\tcatch(Exception loEx)\r\n    //\t\t\t\t\t{\r\n    //\t\t\t\t\t\tSystem.out.println(loEx);\r\n    //\t\t\t\t\t}\r\n    //\t\t\t\t}\r\n    //\t\t\t}\r\n    //\t\t}\r\n    //\r\n    //\t\tclass ImageSelectionAction extends SelectionAction\r\n    //\t\t{\r\n    //\t\t\tImageSelectionAction()\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(\"Select image\");\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic void setImage(URL url)\r\n    //\t\t\t{\r\n    //\t\t\t\tAboutPanel.Example.this.theAboutPanel.setAboutImage(url);\r\n    //\t\t\t}\r\n    //\t\t}\r\n    //\r\n    //\t\tclass BackgroundImageSelectionAction extends SelectionAction\r\n    //\t\t{\r\n    //\t\t\tBackgroundImageSelectionAction()\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(\"Select background-image\");\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic void setImage(URL url)\r\n    //\t\t\t{\r\n    //\t\t\t\tAboutPanel.Example.this.theAboutPanel.setBackgroundImage(url);\r\n    //\t\t\t}\r\n    //\t\t}\r\n    //\r\n    //\t\tclass CloseAction extends AbstractAction\r\n    //\t\t{\r\n    //\t\t\tCloseAction()\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(\"Close\");\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic void actionPerformed( ActionEvent evt )\r\n    //\t\t\t{\r\n    //\t\t\t\tdialog.dispose();\r\n    //\t\t\t}\r\n    //\t\t}\r\n    //\r\n    //\t\tclass FontSizeAction extends AbstractAction\r\n    //\t\t{\r\n    //\t\t\tint fontChange;\r\n    //\r\n    //\r\n    //\t\t\tpublic FontSizeAction( String name, int FontChange )\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(name);\r\n    //\t\t\t\tfontChange = FontChange;\r\n    //\t\t\t}\r\n    //\r\n    //\r\n    //\t\t\tpublic void actionPerformed( java.awt.event.ActionEvent evt )\r\n    //\t\t\t{\r\n    //\t\t\t\tFont loFont = AboutPanel.Example.this.theAboutPanel.getFont();\r\n    //\t\t\t\tfloat loSize = loFont.getSize2D() + fontChange;\r\n    //\r\n    //\t\t\t\tAboutPanel.Example.this.theAboutPanel.setFont( loFont.deriveFont( loSize ) );\r\n    //\t\t\t}\r\n    //\t\t}\r\n    //\r\n    //\t\tabstract class ChooseColorAction extends AbstractAction\r\n    //\t\t{\r\n    //\t\t\tprivate JColorChooser chooser;\r\n    //\t\t\tprivate String chooserTitle;\r\n    //\r\n    //\t\t\tpublic ChooseColorAction( String name)//, String chooserTitle)\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(name);\r\n    //\t\t\t\tchooserTitle=name;\r\n    //\t\t\t\tchooser=new JColorChooser();\r\n    ////\t\t\tthis.chooserTitle=chooserTitle;\r\n    //\t\t\t}\r\n    //\r\n    //\r\n    //\t\t\tpublic void actionPerformed( java.awt.event.ActionEvent evt )\r\n    //\t\t\t{\r\n    //\t\t\t\tColor c=chooser.showDialog(dialog, chooserTitle, getSelectColor());\r\n    //\t\t\t\tif(c!=null)\r\n    //\t\t\t\t{\r\n    //\t\t\t\t\tsetSelectColor(c);\r\n    //\t\t\t\t}\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic abstract Color getSelectColor();\r\n    //\t\t\tpublic abstract void setSelectColor(Color c);\r\n    //\t\t}\r\n    //\r\n    //\t\tclass ChooseBackgroundColorAction extends ChooseColorAction\r\n    //\t\t{\r\n    //\t\t\tpublic ChooseBackgroundColorAction()\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(\"Choose background-color\");\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic Color getSelectColor()\r\n    //\t\t\t{\r\n    //\t\t\t\treturn AboutPanel.Example.this.theAboutPanel.getBackground();\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic void setSelectColor(Color c)\r\n    //\t\t\t{\r\n    //\t\t\t\tAboutPanel.Example.this.theAboutPanel.setBackground(c);\r\n    //\t\t\t}\r\n    //\t\t}\r\n    //\r\n    //\t\tclass ChooseTextColorAction extends ChooseColorAction\r\n    //\t\t{\r\n    //\t\t\tpublic ChooseTextColorAction()\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(\"Choose text-color\");\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic Color getSelectColor()\r\n    //\t\t\t{\r\n    //\t\t\t\treturn AboutPanel.Example.this.theAboutPanel.getForeground();\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic void setSelectColor(Color c)\r\n    //\t\t\t{\r\n    //\t\t\t\tAboutPanel.Example.this.theAboutPanel.setForeground(c);\r\n    //\t\t\t}\r\n    //\t\t}\r\n    //\r\n    //\t\tclass ResetAction extends AbstractAction\r\n    //\t\t{\r\n    //\t\t\tpublic ResetAction()\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(\"Reset dialog\");\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic void actionPerformed(ActionEvent evt)\r\n    //\t\t\t{\r\n    //\t\t\t\tAboutPanel panel = AboutPanel.Example.this.theAboutPanel;\r\n    ////\t\t\t\tpanel.initResources();\r\n    //\t\t\t\tdialog.pack();\r\n    //\t\t\t}\r\n    //\t\t}\r\n    //\r\n    //\t\tclass PackAction extends AbstractAction\r\n    //\t\t{\r\n    //\t\t\tpublic PackAction()\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(\"Pack dialog\");\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic void actionPerformed(ActionEvent evt)\r\n    //\t\t\t{\r\n    //\t\t\t\tdialog.pack();\r\n    //\t\t\t}\r\n    //\t\t}\r\n    //\r\n    //\t\tclass ShowDialogAction extends AbstractAction\r\n    //\t\t{\r\n    //\t\t\tpublic ShowDialogAction()\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(\"Show dialog\");\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic void actionPerformed(ActionEvent evt)\r\n    //\t\t\t{\r\n    //\t\t\t\tdialog.setVisible(true);\r\n    //\t\t\t}\r\n    //\t\t}\r\n    //\r\n    //\t\tclass ExitMenuAction extends AbstractAction\r\n    //\t\t{\r\n    //\t\t\tpublic ExitMenuAction()\r\n    //\t\t\t{\r\n    //\t\t\t\tsuper(\"Exit\");\r\n    //\t\t\t}\r\n    //\r\n    //\t\t\tpublic void actionPerformed(ActionEvent evt)\r\n    //\t\t\t{\r\n    //\t\t\t\texit();\r\n    //\t\t\t}\r\n    //\t\t}\r\n    //\r\n    //\t\t// TODO: Select font\r\n    //\t\t// TODO: Select scroll-area\r\n    //\t\t// TODO: Select scroll-text\r\n    //\t\t// TODO: Select version-text/height\r\n    //\r\n    //\t\tpublic Example()\r\n    //\t\t{\r\n    //\t\t\tJMenuBar menuBar=new JMenuBar();\r\n    //\t\t\tdummyFrame=new JFrame( \"DummyFrame\" );\r\n    //\t\t\tdummyFrame.setDefaultCloseOperation( javax.swing.JFrame.EXIT_ON_CLOSE );\r\n    //\t\t\tdummyFrame.setJMenuBar(menuBar);\r\n    //\t\t\tJMenu fileMenu=new JMenu(\"File\");\r\n    //\t\t\tmenuBar.add(fileMenu);\r\n    //\t\t\tfileMenu.add(new JMenuItem(new ShowDialogAction()));\r\n    //\t\t\tfileMenu.addSeparator();\r\n    //\t\t\tfileMenu.add(new JMenuItem(new ExitMenuAction()));\r\n    //\r\n    //\t\t\tdummyFrame.setBounds(10,10,100,100);\r\n    //\t\t\tdialog = new JDialog( dummyFrame, \"About example\", false );\r\n    //\r\n    //\t\t\tJPanel content = new JPanel( new BorderLayout() );\r\n    //\r\n    //\t\t\tdialog.setContentPane( content );\r\n    //\t\t\tcontent.setBorder( new EmptyBorder( 12, 12, 12, 12 ) );\r\n    //\r\n    //\r\n    //\t\t\tAboutPanel aboutPanel = new AboutPanel();\r\n    //\r\n    //\t\t\tcontent.add(BorderLayout.CENTER,aboutPanel);\r\n    //\r\n    //\t\t\ttheAboutPanel=aboutPanel;\r\n    //\r\n    //\t\t\tCloseAction closeAction = new CloseAction();\r\n    //\t\t\tJButton closeButton = new JButton( closeAction );\r\n    //\r\n    //\t\t\tdialog.getRootPane().setDefaultButton( closeButton );\r\n    //\t\t\tJPanel buttonPanel = new JPanel();\r\n    //\r\n    //\t\t\tbuttonPanel.setLayout( new BoxLayout( buttonPanel, BoxLayout.X_AXIS ) );\r\n    //\t\t\tbuttonPanel.setBorder( new EmptyBorder( 12, 0, 0, 0 ) );\r\n    //\t\t\tbuttonPanel.add( Box.createGlue() );\r\n    //\t\t\tbuttonPanel.add( closeButton );\r\n    //\t\t\tbuttonPanel.add( Box.createGlue() );\r\n    //\t\t\tcontent.add( BorderLayout.SOUTH, buttonPanel );\r\n    //\r\n    //\t\t\tJMenuBar dialogBar=new JMenuBar();\r\n    //\t\t\tdialog.setJMenuBar(dialogBar);\r\n    //\t\t\tJMenu optionsMenu=new JMenu(\"Options\");\r\n    //\t\t\tdialogBar.add(optionsMenu);\r\n    //\r\n    //\t\t\tJMenuItem bgImageItem = new JMenuItem( new BackgroundImageSelectionAction() );\r\n    //\t\t\tJMenuItem imageItem = new JMenuItem( new ImageSelectionAction() );\r\n    //\t\t\tJMenuItem textColorItem = new JMenuItem( new ChooseTextColorAction() );\r\n    //\t\t\tJMenuItem bgColorItem = new JMenuItem( new ChooseBackgroundColorAction() );\r\n    //\t\t\tJMenuItem fontPlusItem = new JMenuItem( new FontSizeAction(\"Increase font-size\", 1));\r\n    //\t\t\tJMenuItem fontMinusItem = new JMenuItem(  new FontSizeAction(\"Decrease font-size\", -1));\r\n    //\t\t\tJMenuItem packItem = new JMenuItem( new PackAction() );\r\n    //\t\t\tJMenuItem resetItem = new JMenuItem( new ResetAction() );\r\n    //\t\t\tJMenuItem closeItem = new JMenuItem( closeAction );\r\n    //\t\t\tJMenuItem exitItem = new JMenuItem( new ExitMenuAction() );\r\n    //\r\n    //\t\t\toptionsMenu.add( bgImageItem );\r\n    //\t\t\toptionsMenu.add( imageItem );\r\n    //\t\t\toptionsMenu.add( textColorItem );\r\n    //\t\t\toptionsMenu.add( bgColorItem );\r\n    //\t\t\toptionsMenu.add( fontPlusItem );\r\n    //\t\t\toptionsMenu.add( fontMinusItem );\r\n    //\t\t\toptionsMenu.addSeparator();\r\n    //\t\t\toptionsMenu.add( packItem );\r\n    //\t\t\toptionsMenu.add( resetItem );\r\n    //\t\t\toptionsMenu.addSeparator();\r\n    //\t\t\toptionsMenu.add( closeItem );\r\n    //\t\t\toptionsMenu.add( exitItem );\r\n    //\r\n    //\t\t\tdialog.pack();\r\n    //\t\t\tdummyFrame.setVisible(true);\r\n    //\t\t}\r\n    //\r\n    //\t\tpublic void showDialog()\r\n    //\t\t{\r\n    //\t\t\tdialog.setVisible(true);\r\n    //\t\t}\r\n    //\r\n    //\t\tpublic void exit()\r\n    //\t\t{\r\n    //\t\t\tSystem.exit(0);\r\n    //\t\t}\r\n    //\r\n    //\t\tpublic static void main(String args[])\r\n    //\t\t{\r\n    //            Example example=new Example();\r\n    //\t\t\texample.showDialog();\r\n    //\t\t}\r\n    //\t}\r\n}\r\n",
    "test_prompt": "// AboutPanel_0Test.java\npackage de.huxhorn.lilith.swing;\n\nimport de.huxhorn.sulky.swing.GraphicsUtilities;\nimport de.huxhorn.sulky.swing.filters.ColorTintFilter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.MouseEvent;\nimport java.awt.image.BufferedImage;\nimport java.awt.image.BufferedImageOp;\nimport java.awt.image.ConvolveOp;\nimport java.awt.image.Kernel;\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport javax.swing.*;\nimport javax.swing.event.MouseInputAdapter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AboutPanel}.\n* It contains ten unit test cases for the {@link AboutPanel#getToolTipText(MouseEvent)} method.\n*/\nclass AboutPanel_0Test {",
    "time_taken": -1
},
{
    "choices": [
        {
            "finish_reason": "ERROR - This model's maximum context length is 8001 tokens, however you requested 20373 tokens (18373 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.",
            "text": ""
        }
    ],
    "id": "070d5fa1-8f46-4437-a6a4-b645a700e9c6",
    "prompt_id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/ApplicationPreferences_8Test.java",
    "original_code": "// ApplicationPreferences.java\n/*\n * Lilith - a log event viewer.\n * Copyright (C) 2007-2009 Joern Huxhorn\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage de.huxhorn.lilith.swing;\n\nimport de.huxhorn.lilith.Lilith;\nimport de.huxhorn.lilith.LilithSounds;\nimport de.huxhorn.lilith.data.access.HttpStatus;\nimport de.huxhorn.lilith.data.logging.LoggingEvent;\nimport de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;\nimport de.huxhorn.lilith.swing.preferences.SavedCondition;\nimport de.huxhorn.lilith.swing.table.ColorScheme;\nimport de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;\nimport de.huxhorn.sulky.conditions.Condition;\nimport org.apache.commons.io.IOUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.awt.*;\nimport java.beans.Encoder;\nimport java.beans.Expression;\nimport java.beans.PersistenceDelegate;\nimport java.beans.PropertyChangeListener;\nimport java.beans.PropertyChangeSupport;\nimport java.beans.XMLDecoder;\nimport java.beans.XMLEncoder;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.DataInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.security.MessageDigest;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.prefs.BackingStoreException;\nimport java.util.prefs.Preferences;\nimport javax.swing.*;\n\npublic class ApplicationPreferences {\n\n    public static enum SourceFiltering {\n\n        NONE, BLACKLIST, WHITELIST\n    }\n\n    private static final Preferences PREFERENCES = Preferences.userNodeForPackage(ApplicationPreferences.class);\n\n    private static final String STATUS_COLORS_XML_FILENAME = \"statusColors.xml\";\n\n    private static final String LEVEL_COLORS_XML_FILENAME = \"levelColors.xml\";\n\n    private static final String DETAILS_VIEW_ROOT_FOLDER = \"detailsView\";\n\n    public static final String DETAILS_VIEW_CSS_FILENAME = \"detailsView.css\";\n\n    public static final String DETAILS_VIEW_GROOVY_FILENAME = \"detailsView.groovy\";\n\n    private static final String CONDITIONS_XML_FILENAME = \"savedConditions.xml\";\n\n    public static final String STATUS_COLORS_PROPERTY = \"statusColors\";\n\n    public static final String LEVEL_COLORS_PROPERTY = \"levelColors\";\n\n    public static final String LOOK_AND_FEEL_PROPERTY = \"lookAndFeel\";\n\n    public static final String CLEANING_LOGS_ON_EXIT_PROPERTY = \"cleaningLogsOnExit\";\n\n    public static final String COLORING_WHOLE_ROW_PROPERTY = \"coloringWholeRow\";\n\n    public static final String SHOWING_IDENTIFIER_PROPERTY = \"showingIdentifier\";\n\n    public static final String SHOWING_FULL_CALLSTACK_PROPERTY = \"showingFullCallstack\";\n\n    public static final String SHOWING_STACKTRACE_PROPERTY = \"showingStackTrace\";\n\n    public static final String CHECKING_FOR_UPDATE_PROPERTY = \"checkingForUpdate\";\n\n    public static final String SOURCE_FILTERING_PROPERTY = \"sourceFiltering\";\n\n    public static final String SOUND_LOCATIONS_PROPERTY = \"soundLocations\";\n\n    public static final String MUTE_PROPERTY = \"mute\";\n\n    public static final String USING_INTERNAL_FRAMES_PROPERTY = \"usingInternalFrames\";\n\n    public static final String SCROLLING_TO_BOTTOM_PROPERTY = \"scrollingToBottom\";\n\n    public static final String SOURCE_NAMES_PROPERTY = \"sourceNames\";\n\n    public static final String APPLICATION_PATH_PROPERTY = \"applicationPath\";\n\n    public static final String AUTO_OPENING_PROPERTY = \"autoOpening\";\n\n    public static final String AUTO_CLOSING_PROPERTY = \"autoClosing\";\n\n    public static final String IMAGE_PATH_PROPERTY = \"imagePath\";\n\n    public static final String SOUND_PATH_PROPERTY = \"soundPath\";\n\n    public static final String AUTO_FOCUSING_WINDOW_PROPERTY = \"autoFocusingWindow\";\n\n    public static final String SOURCE_LISTS_PROPERTY = \"sourceLists\";\n\n    public static final String BLACK_LIST_NAME_PROPERTY = \"blackListName\";\n\n    public static final String WHITE_LIST_NAME_PROPERTY = \"whiteListName\";\n\n    public static final String CONDITIONS_PROPERTY = \"conditions\";\n\n    public static final String SPLASH_SCREEN_DISABLED_PROPERTY = \"splashScreenDisabled\";\n\n    public static final String ASKING_BEFORE_QUIT_PROPERTY = \"askingBeforeQuit\";\n\n    public static final String LOGGING_LAYOUT_GLOBAL_XML_FILENAME = \"loggingLayoutGlobal.xml\";\n\n    public static final String LOGGING_LAYOUT_XML_FILENAME = \"loggingLayout.xml\";\n\n    public static final String ACCESS_LAYOUT_GLOBAL_XML_FILENAME = \"accessLayoutGlobal.xml\";\n\n    public static final String ACCESS_LAYOUT_XML_FILENAME = \"accessLayout.xml\";\n\n    public static final String SOURCE_NAMES_XML_FILENAME = \"SourceNames.xml\";\n\n    public static final String SOURCE_LISTS_XML_FILENAME = \"SourceLists.xml\";\n\n    public static final String SOURCE_NAMES_PROPERTIES_FILENAME = \"SourceNames.properties\";\n\n    public static final String SOUND_LOCATIONS_XML_FILENAME = \"SoundLocations.xml\";\n\n    public static final String SOUND_LOCATIONS_PROPERTIES_FILENAME = \"SoundLocations.properties\";\n\n    public static final String PREVIOUS_APPLICATION_PATH_FILENAME = \".previous.application.path\";\n\n    private static final String OLD_LICENSED_PREFERENCES_KEY = \"licensed\";\n\n    private static final String LICENSED_PREFERENCES_KEY = \"licensedVersion\";\n\n    public static final String USER_HOME;\n\n    public static final String DEFAULT_APPLICATION_PATH;\n\n    private static final Map<String, String> DEFAULT_SOURCE_NAMES;\n\n    private static final Map<String, String> DEFAULT_SOUND_LOCATIONS;\n\n    private static final Map<LoggingEvent.Level, ColorScheme> DEFAULT_LEVEL_COLORS;\n\n    private static final Map<HttpStatus.Type, ColorScheme> DEFAULT_STATUS_COLORS;\n\n    private static final String PREVIOUS_OPEN_PATH_PROPERTY = \"previousOpenPath\";\n\n    private static final String PREVIOUS_IMPORT_PATH_PROPERTY = \"previousImportPath\";\n\n    public static final String STARTUP_LOOK_AND_FEEL;\n\n    private static final long CONDITIONS_CHECK_INTERVAL = 30000;\n\n    private static final String GROOVY_SUFFIX = \".groovy\";\n\n    private static final String EXAMPLE_GROOVY_BASE = \"/conditions/\";\n\n    private static final String EXAMPLE_GROOVY_LIST = \"conditions.txt\";\n\n    static {\n        // remove garbage\n        PREFERENCES.remove(OLD_LICENSED_PREFERENCES_KEY);\n        USER_HOME = System.getProperty(\"user.home\");\n        File defaultAppPath = new File(USER_HOME, \".lilith\");\n        DEFAULT_APPLICATION_PATH = defaultAppPath.getAbsolutePath();\n        Map<String, String> defaultSoundLocations = new HashMap<String, String>();\n        defaultSoundLocations.put(LilithSounds.SOURCE_ADDED, \"/events/SourceAdded.mp3\");\n        defaultSoundLocations.put(LilithSounds.SOURCE_REMOVED, \"/events/SourceRemoved.mp3\");\n        defaultSoundLocations.put(LilithSounds.ERROR_EVENT_ALARM, \"/events/ErrorEventAlarm.mp3\");\n        DEFAULT_SOUND_LOCATIONS = Collections.unmodifiableMap(defaultSoundLocations);\n        Map<String, String> defaultSourceNames = new HashMap<String, String>();\n        defaultSourceNames.put(\"127.0.0.1\", \"Localhost\");\n        DEFAULT_SOURCE_NAMES = Collections.unmodifiableMap(defaultSourceNames);\n        HashMap<LoggingEvent.Level, ColorScheme> defaultLevelColors = new HashMap<LoggingEvent.Level, ColorScheme>();\n        defaultLevelColors.put(LoggingEvent.Level.TRACE, new ColorScheme(new Color(0x1F, 0x44, 0x58), new Color(0x80, 0xBA, 0xD9)));\n        defaultLevelColors.put(LoggingEvent.Level.DEBUG, new ColorScheme(Color.BLACK, Color.GREEN));\n        defaultLevelColors.put(LoggingEvent.Level.INFO, new ColorScheme(Color.BLACK, Color.WHITE));\n        defaultLevelColors.put(LoggingEvent.Level.WARN, new ColorScheme(Color.BLACK, Color.YELLOW));\n        defaultLevelColors.put(LoggingEvent.Level.ERROR, new ColorScheme(Color.YELLOW, Color.RED, Color.ORANGE));\n        DEFAULT_LEVEL_COLORS = Collections.unmodifiableMap(defaultLevelColors);\n        HashMap<HttpStatus.Type, ColorScheme> defaultStatusColors = new HashMap<HttpStatus.Type, ColorScheme>();\n        defaultStatusColors.put(HttpStatus.Type.SUCCESSFUL, new ColorScheme(Color.BLACK, Color.GREEN));\n        defaultStatusColors.put(HttpStatus.Type.INFORMATIONAL, new ColorScheme(Color.BLACK, Color.WHITE));\n        defaultStatusColors.put(HttpStatus.Type.REDIRECTION, new ColorScheme(Color.BLACK, Color.YELLOW));\n        defaultStatusColors.put(HttpStatus.Type.CLIENT_ERROR, new ColorScheme(Color.GREEN, Color.RED, Color.ORANGE));\n        defaultStatusColors.put(HttpStatus.Type.SERVER_ERROR, new ColorScheme(Color.YELLOW, Color.RED, Color.ORANGE));\n        DEFAULT_STATUS_COLORS = Collections.unmodifiableMap(defaultStatusColors);\n        STARTUP_LOOK_AND_FEEL = UIManager.getLookAndFeel().getName();\n    }\n\n    private final Logger logger = LoggerFactory.getLogger(ApplicationPreferences.class);\n\n    private PropertyChangeSupport propertyChangeSupport;\n\n    private File startupApplicationPath;\n\n    private File detailsViewRoot;\n\n    private ArrayList<String> installedLookAndFeels;\n\n    private String[] conditionScriptFiles;\n\n    private long lastConditionsCheck;\n\n    private Map<LoggingEvent.Level, ColorScheme> levelColors;\n\n    private Map<HttpStatus.Type, ColorScheme> statusColors;\n\n    private URL detailsViewRootUrl;\n\n    /**\n     * Identifier => Name\n     */\n    private Map<String, String> sourceNames;\n\n    private long lastSourceNamesModified;\n\n    private long lastConditionsModified;\n\n    private Map<String, String> soundLocations;\n\n    private long lastSoundLocationsModified;\n\n    private Map<String, Set<String>> sourceLists;\n\n    private long lastSourceListsModified;\n\n    private SourceFiltering sourceFiltering;\n\n    private Set<String> blackList;\n\n    private Set<String> whiteList;\n\n    private List<SavedCondition> conditions;\n\n    private File groovyConditionsPath;\n\n    public ApplicationPreferences() {\n        lastSourceNamesModified = -1;\n        lastConditionsModified = -1;\n        propertyChangeSupport = new PropertyChangeSupport(this);\n        startupApplicationPath = getApplicationPath();\n        installedLookAndFeels = new ArrayList<String>();\n        for (UIManager.LookAndFeelInfo info : UIManager.getInstalledLookAndFeels()) {\n            installedLookAndFeels.add(info.getName());\n        }\n        Collections.sort(installedLookAndFeels);\n        groovyConditionsPath = new File(startupApplicationPath, \"conditions\");\n        if (groovyConditionsPath.mkdirs()) {\n            // groovy Conditions was generated, create examples...\n            installExampleConditions();\n        }\n    }\n\n    public File resolveConditionScriptFile(String input) {\n        if (!input.endsWith(GROOVY_SUFFIX)) {\n            input = input + GROOVY_SUFFIX;\n        }\n        File scriptFile = new File(groovyConditionsPath, input);\n        if (scriptFile.isFile()) {\n            return scriptFile;\n        }\n        return null;\n    }\n\n    public String[] getAllConditionScriptFiles() {\n        if (conditionScriptFiles == null || ((System.currentTimeMillis() - lastConditionsCheck) > CONDITIONS_CHECK_INTERVAL)) {\n            File[] groovyFiles = groovyConditionsPath.listFiles(new GroovyConditionFileFilter());\n            if (groovyFiles != null && groovyFiles.length > 0) {\n                conditionScriptFiles = new String[groovyFiles.length];\n                for (int i = 0; i < groovyFiles.length; i++) {\n                    File current = groovyFiles[i];\n                    conditionScriptFiles[i] = current.getName();\n                }\n                Arrays.sort(conditionScriptFiles);\n                lastConditionsCheck = System.currentTimeMillis();\n            }\n        }\n        return conditionScriptFiles;\n    }\n\n    public void installExampleConditions() {\n        String path = EXAMPLE_GROOVY_BASE + EXAMPLE_GROOVY_LIST;\n        URL url = ApplicationPreferences.class.getResource(path);\n        if (url == null) {\n            if (logger.isErrorEnabled())\n                logger.error(\"Couldn't find resource at \" + path + \"!\");\n        } else {\n            List<String> lines = readLines(url);\n            for (String current : lines) {\n                path = EXAMPLE_GROOVY_BASE + current;\n                url = ApplicationPreferences.class.getResource(path);\n                if (url == null) {\n                    if (logger.isErrorEnabled())\n                        logger.error(\"Couldn't find resource at \" + path + \"!\");\n                    continue;\n                }\n                File target = new File(groovyConditionsPath, current);\n                copy(url, target, true);\n            }\n        }\n    }\n\n    private void initLevelColors() {\n        if (levelColors == null) {\n            File appPath = getStartupApplicationPath();\n            File levelColorsFile = new File(appPath, LEVEL_COLORS_XML_FILENAME);\n            if (levelColorsFile.isFile()) {\n                XMLDecoder d = null;\n                try {\n                    d = new XMLDecoder(new BufferedInputStream(new FileInputStream(levelColorsFile)));\n                    //noinspection unchecked\n                    levelColors = (Map<LoggingEvent.Level, ColorScheme>) d.readObject();\n                } catch (Throwable ex) {\n                    if (logger.isWarnEnabled()) {\n                        logger.warn(\"Exception while loading level colors from sourceListsFile '\" + levelColorsFile.getAbsolutePath() + \"'!\", ex);\n                    }\n                    levelColors = null;\n                } finally {\n                    if (d != null) {\n                        d.close();\n                    }\n                }\n            }\n        }\n        if (levelColors != null && levelColors.size() != DEFAULT_LEVEL_COLORS.size()) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Reverting level colors to defaults.\");\n            levelColors = null;\n        }\n        if (levelColors == null) {\n            levelColors = cloneLevelColors(DEFAULT_LEVEL_COLORS);\n        }\n    }\n\n    private Map<LoggingEvent.Level, ColorScheme> cloneLevelColors(Map<LoggingEvent.Level, ColorScheme> input) {\n        if (input != null && input.size() != DEFAULT_LEVEL_COLORS.size()) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Reverting colors to defaults.\");\n            input = null;\n        }\n        if (input == null) {\n            input = DEFAULT_LEVEL_COLORS;\n        }\n        Map<LoggingEvent.Level, ColorScheme> result = new HashMap<LoggingEvent.Level, ColorScheme>();\n        try {\n            for (Map.Entry<LoggingEvent.Level, ColorScheme> current : input.entrySet()) {\n                result.put(current.getKey(), current.getValue().clone());\n            }\n        } catch (Throwable e) {\n            if (logger.isErrorEnabled())\n                logger.error(\"Exception while cloning colors!\", e);\n        }\n        return result;\n    }\n\n    public void setLevelColors(Map<LoggingEvent.Level, ColorScheme> colors) {\n        Object oldValue = getLevelColors();\n        colors = cloneLevelColors(colors);\n        writeLevelColors(colors);\n        this.levelColors = colors;\n        Object newValue = getLevelColors();\n        propertyChangeSupport.firePropertyChange(LEVEL_COLORS_PROPERTY, oldValue, newValue);\n        if (logger.isInfoEnabled())\n            logger.info(\"LevelColors set to {}.\", this.levelColors);\n    }\n\n    private void writeLevelColors(Map<LoggingEvent.Level, ColorScheme> colors) {\n        File appPath = getStartupApplicationPath();\n        File file = new File(appPath, LEVEL_COLORS_XML_FILENAME);\n        Throwable error = null;\n        try {\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file));\n            XMLEncoder e = new XMLEncoder(bos);\n            PersistenceDelegate delegate = new EnumPersistenceDelegate();\n            e.setPersistenceDelegate(LoggingEvent.Level.class, delegate);\n            e.writeObject(colors);\n            e.close();\n        } catch (Throwable ex) {\n            error = ex;\n        }\n        if (error != null) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Exception while writing colors!\", error);\n        }\n    }\n\n    public Map<LoggingEvent.Level, ColorScheme> getLevelColors() {\n        if (levelColors == null) {\n            initLevelColors();\n        }\n        return cloneLevelColors(levelColors);\n    }\n\n    private void initStatusColors() {\n        if (statusColors == null) {\n            File appPath = getStartupApplicationPath();\n            File statusColorsFile = new File(appPath, STATUS_COLORS_XML_FILENAME);\n            if (statusColorsFile.isFile()) {\n                XMLDecoder d = null;\n                try {\n                    d = new XMLDecoder(new BufferedInputStream(new FileInputStream(statusColorsFile)));\n                    //noinspection unchecked\n                    statusColors = (Map<HttpStatus.Type, ColorScheme>) d.readObject();\n                } catch (Throwable ex) {\n                    if (logger.isWarnEnabled()) {\n                        logger.warn(\"Exception while loading status colors from sourceListsFile '\" + statusColorsFile.getAbsolutePath() + \"'!\", ex);\n                    }\n                    statusColors = null;\n                } finally {\n                    if (d != null) {\n                        d.close();\n                    }\n                }\n            }\n        }\n        if (statusColors != null && statusColors.size() != DEFAULT_STATUS_COLORS.size()) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Reverting status colors to defaults.\");\n            statusColors = null;\n        }\n        if (statusColors == null) {\n            statusColors = cloneStatusColors(DEFAULT_STATUS_COLORS);\n        }\n    }\n\n    private Map<HttpStatus.Type, ColorScheme> cloneStatusColors(Map<HttpStatus.Type, ColorScheme> input) {\n        if (input != null && input.size() != DEFAULT_STATUS_COLORS.size()) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Reverting colors to defaults.\");\n            input = null;\n        }\n        if (input == null) {\n            input = DEFAULT_STATUS_COLORS;\n        }\n        Map<HttpStatus.Type, ColorScheme> result = new HashMap<HttpStatus.Type, ColorScheme>();\n        try {\n            for (Map.Entry<HttpStatus.Type, ColorScheme> current : input.entrySet()) {\n                result.put(current.getKey(), current.getValue().clone());\n            }\n        } catch (Throwable e) {\n            if (logger.isErrorEnabled())\n                logger.error(\"Exception while cloning colors!\", e);\n        }\n        return result;\n    }\n\n    public void setStatusColors(Map<HttpStatus.Type, ColorScheme> colors) {\n        Object oldValue = getStatusColors();\n        colors = cloneStatusColors(colors);\n        writeStatusColors(colors);\n        this.statusColors = colors;\n        Object newValue = getStatusColors();\n        propertyChangeSupport.firePropertyChange(STATUS_COLORS_PROPERTY, oldValue, newValue);\n        if (logger.isInfoEnabled())\n            logger.info(\"StatusColors set to {}.\", this.statusColors);\n    }\n\n    private void writeStatusColors(Map<HttpStatus.Type, ColorScheme> colors) {\n        File appPath = getStartupApplicationPath();\n        File file = new File(appPath, STATUS_COLORS_XML_FILENAME);\n        Throwable error = null;\n        try {\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file));\n            XMLEncoder e = new XMLEncoder(bos);\n            PersistenceDelegate delegate = new EnumPersistenceDelegate();\n            e.setPersistenceDelegate(HttpStatus.Type.class, delegate);\n            e.writeObject(colors);\n            e.close();\n        } catch (Throwable ex) {\n            error = ex;\n        }\n        if (error != null) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Exception while writing colors!\", error);\n        }\n    }\n\n    public Map<HttpStatus.Type, ColorScheme> getStatusColors() {\n        if (statusColors == null) {\n            initStatusColors();\n        }\n        return cloneStatusColors(statusColors);\n    }\n\n    public void setSourceFiltering(SourceFiltering sourceFiltering) {\n        Object oldValue = getSourceFiltering();\n        PREFERENCES.put(SOURCE_FILTERING_PROPERTY, sourceFiltering.toString());\n        this.sourceFiltering = sourceFiltering;\n        propertyChangeSupport.firePropertyChange(SOURCE_FILTERING_PROPERTY, oldValue, sourceFiltering);\n        if (logger.isInfoEnabled())\n            logger.info(\"SourceFiltering set to {}.\", this.sourceFiltering);\n    }\n\n    private void initSourceLists() {\n        File appPath = getStartupApplicationPath();\n        File sourceListsFile = new File(appPath, SOURCE_LISTS_XML_FILENAME);\n        if (sourceListsFile.isFile()) {\n            long lastModified = sourceListsFile.lastModified();\n            if (sourceLists != null && lastSourceListsModified >= lastModified) {\n                if (logger.isDebugEnabled())\n                    logger.debug(\"Won't reload source lists.\");\n                return;\n            }\n            XMLDecoder d = null;\n            try {\n                d = new XMLDecoder(new BufferedInputStream(new FileInputStream(sourceListsFile)));\n                //noinspection unchecked\n                sourceLists = (Map<String, Set<String>>) d.readObject();\n                lastSourceListsModified = lastModified;\n            } catch (Throwable ex) {\n                if (logger.isWarnEnabled()) {\n                    logger.warn(\"Exception while loading source lists from sourceListsFile '\" + sourceListsFile.getAbsolutePath() + \"'!\", ex);\n                }\n                sourceLists = new HashMap<String, Set<String>>();\n            } finally {\n                if (d != null) {\n                    d.close();\n                }\n            }\n        } else if (sourceLists == null) {\n            sourceLists = new HashMap<String, Set<String>>();\n        }\n    }\n\n    public Map<String, Set<String>> getSourceLists() {\n        initSourceLists();\n        return new HashMap<String, Set<String>>(sourceLists);\n    }\n\n    public void setSourceLists(Map<String, Set<String>> sourceLists) {\n        Object oldValue = getSourceLists();\n        writeSourceLists(sourceLists);\n        Object newValue = getSourceLists();\n        blackList = null;\n        whiteList = null;\n        propertyChangeSupport.firePropertyChange(SOURCE_LISTS_PROPERTY, oldValue, newValue);\n    }\n\n    public SourceFiltering getSourceFiltering() {\n        if (sourceFiltering != null) {\n            return sourceFiltering;\n        }\n        String sf = PREFERENCES.get(SOURCE_FILTERING_PROPERTY, \"NONE\");\n        try {\n            sourceFiltering = SourceFiltering.valueOf(sf);\n        } catch (IllegalArgumentException e) {\n            sourceFiltering = SourceFiltering.NONE;\n        }\n        return sourceFiltering;\n    }\n\n    public void initDetailsViewRoot(boolean overwriteAlways) {\n        detailsViewRoot = new File(startupApplicationPath, DETAILS_VIEW_ROOT_FOLDER);\n        if (detailsViewRoot.mkdirs()) {\n            if (logger.isInfoEnabled())\n                logger.info(\"Created directory {}.\", detailsViewRoot.getAbsolutePath());\n        }\n        try {\n            detailsViewRootUrl = detailsViewRoot.toURI().toURL();\n        } catch (MalformedURLException e) {\n            if (logger.isWarnEnabled()) {\n                logger.warn(\"Exception while creating detailsViewRootUrl for '{}'!\", detailsViewRoot.getAbsolutePath());\n            }\n            detailsViewRootUrl = null;\n        }\n        {\n            String resourcePath = \"/detailsView/\" + DETAILS_VIEW_CSS_FILENAME;\n            String historyBasePath = \"/detailsView/history/detailsView.css/\";\n            File detailsViewCssFile = new File(detailsViewRoot, DETAILS_VIEW_CSS_FILENAME);\n            initIfNecessary(detailsViewCssFile, resourcePath, historyBasePath, overwriteAlways);\n        }\n        {\n            String resourcePath = \"/detailsView/\" + DETAILS_VIEW_GROOVY_FILENAME;\n            String historyBasePath = \"/detailsView/history/detailsView.groovy/\";\n            File detailsViewGroovyFile = new File(detailsViewRoot, DETAILS_VIEW_GROOVY_FILENAME);\n            initIfNecessary(detailsViewGroovyFile, resourcePath, historyBasePath, overwriteAlways);\n        }\n    }\n\n    private void initIfNecessary(File file, String resourcePath, String historyBasePath, boolean overwriteAlways) {\n        boolean delete = false;\n        if (overwriteAlways) {\n            delete = true;\n        } else if (file.isFile()) {\n            byte[] available = null;\n            try {\n                FileInputStream availableFile = new FileInputStream(file);\n                available = getMD5(availableFile);\n            } catch (FileNotFoundException e) {\n                // ignore\n            }\n            byte[] current = getMD5(getClass().getResourceAsStream(resourcePath));\n            if (Arrays.equals(available, current)) {\n                // we are done already. The current version is the latest version.\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"The current version of {} is also the latest version.\", file.getAbsolutePath());\n                }\n                return;\n            }\n            if (available != null) {\n                // check older versions if available\n                URL historyUrl = getClass().getResource(historyBasePath + \"history.txt\");\n                if (historyUrl != null) {\n                    List<String> historyList = readLines(historyUrl);\n                    for (String currentLine : historyList) {\n                        InputStream is = getClass().getResourceAsStream(historyBasePath + currentLine + \".md5\");\n                        if (is != null) {\n                            DataInputStream dis = new DataInputStream(is);\n                            byte[] checksum = new byte[16];\n                            try {\n                                dis.readFully(checksum);\n                                if (Arrays.equals(available, checksum)) {\n                                    if (logger.isInfoEnabled()) {\n                                        logger.info(\"Found old version of {}: {}\", file.getAbsolutePath(), currentLine);\n                                    }\n                                    delete = true;\n                                    break;\n                                }\n                            } catch (IOException e) {\n                                if (logger.isWarnEnabled()) {\n                                    logger.warn(\"Exception while reading checksum of \" + currentLine + \"!\", e);\n                                }\n                            } finally {\n                                try {\n                                    dis.close();\n                                } catch (IOException e) {\n                                    // ignore\n                                }\n                            }\n                        }\n                    }\n                }\n            } else {\n                // we couldn't calculate the checksum. Try to delete it...\n                delete = true;\n            }\n        }\n        URL resourceUrl = ApplicationPreferences.class.getResource(resourcePath);\n        if (resourceUrl == null) {\n            if (logger.isErrorEnabled())\n                logger.error(\"Couldn't find resource {}!\", resourcePath);\n            return;\n        }\n        copy(resourceUrl, file, delete);\n    }\n\n    private void copy(URL source, File target, boolean overwrite) {\n        if (overwrite) {\n            if (target.isFile()) {\n                if (target.delete()) {\n                    if (logger.isInfoEnabled())\n                        logger.info(\"Deleted {}. \", target.getAbsolutePath());\n                } else {\n                    if (logger.isWarnEnabled()) {\n                        logger.warn(\"Tried to delete {} but couldn't!\", target.getAbsolutePath());\n                    }\n                }\n            }\n        }\n        if (!target.isFile()) {\n            InputStream is = null;\n            FileOutputStream os = null;\n            try {\n                os = new FileOutputStream(target);\n                is = source.openStream();\n                IOUtils.copy(is, os);\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"Initialized file at '{}' with data from '{}'.\", target.getAbsolutePath(), source);\n                }\n            } catch (IOException e) {\n                if (logger.isWarnEnabled()) {\n                    logger.warn(\"Exception while initializing '\" + target.getAbsolutePath() + \"' with data from '\" + source + \"'.!\", e);\n                }\n            } finally {\n                IOUtils.closeQuietly(is);\n                IOUtils.closeQuietly(os);\n            }\n        } else {\n            if (logger.isInfoEnabled())\n                logger.info(\"Won't overwrite '{}'.\", target.getAbsolutePath());\n        }\n    }\n\n    /**\n     * Returns a list of strings containing all non-empty, non-comment lines found in the given URL.\n     * Commented lines start with a #.\n     *\n     * @param url the URL to read the lines from.\n     * @return a List of type String containing all non-empty, non-comment lines.\n     */\n    private List<String> readLines(URL url) {\n        List<String> result = new ArrayList<String>();\n        BufferedReader reader = null;\n        try {\n            reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            for (; ; ) {\n                String currentLine = reader.readLine();\n                if (currentLine == null) {\n                    break;\n                }\n                currentLine = currentLine.trim();\n                if (!\"\".equals(currentLine) && !currentLine.startsWith(\"#\")) {\n                    result.add(currentLine);\n                }\n            }\n        } catch (IOException e) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Exception while reading lines from \" + url + \"!\", e);\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    // ignore\n                }\n            }\n        }\n        return result;\n    }\n\n    public File getDetailsViewRoot() {\n        if (detailsViewRoot != null) {\n            return detailsViewRoot;\n        }\n        initDetailsViewRoot(false);\n        return detailsViewRoot;\n    }\n\n    public URL getDetailsViewRootUrl() {\n        if (detailsViewRootUrl != null) {\n            return detailsViewRootUrl;\n        }\n        initDetailsViewRoot(false);\n        return detailsViewRootUrl;\n    }\n\n    public boolean isValidSource(String source) {\n        if (source == null) {\n            return false;\n        }\n        SourceFiltering filtering = getSourceFiltering();\n        switch(filtering) {\n            case BLACKLIST:\n                return !isBlackListed(source);\n            case WHITELIST:\n                return isWhiteListed(source);\n        }\n        return true;\n    }\n\n    public boolean isBlackListed(String source) {\n        if (blackList == null) {\n            String listName = getBlackListName();\n            initSourceLists();\n            blackList = sourceLists.get(listName);\n            if (blackList == null) {\n                // meaning there was no list of the given blacklist name.\n                if (logger.isInfoEnabled())\n                    logger.info(\"Couldn't find blacklist '{}'!\", listName);\n                setSourceFiltering(SourceFiltering.NONE);\n                setBlackListName(\"\");\n                return true;\n            }\n        }\n        return blackList.contains(source);\n    }\n\n    public void setBlackListName(String name) {\n        Object oldValue = getBlackListName();\n        PREFERENCES.put(BLACK_LIST_NAME_PROPERTY, name);\n        Object newValue = getBlackListName();\n        propertyChangeSupport.firePropertyChange(BLACK_LIST_NAME_PROPERTY, oldValue, newValue);\n        if (logger.isInfoEnabled())\n            logger.info(\"BlackListName set to {}.\", newValue);\n    }\n\n    public String getBlackListName() {\n        return PREFERENCES.get(BLACK_LIST_NAME_PROPERTY, \"\");\n    }\n\n    public boolean isWhiteListed(String source) {\n        if (whiteList == null) {\n            String listName = getWhiteListName();\n            initSourceLists();\n            whiteList = sourceLists.get(listName);\n            if (whiteList == null) {\n                // meaning there was no list of the given blacklist name.\n                if (logger.isInfoEnabled())\n                    logger.info(\"Couldn't find whitelist '{}'!\", listName);\n                setSourceFiltering(SourceFiltering.NONE);\n                setWhiteListName(\"\");\n                return true;\n            }\n        }\n        return whiteList.contains(source);\n    }\n\n    public void setWhiteListName(String name) {\n        Object oldValue = getWhiteListName();\n        PREFERENCES.put(WHITE_LIST_NAME_PROPERTY, name);\n        Object newValue = getWhiteListName();\n        propertyChangeSupport.firePropertyChange(WHITE_LIST_NAME_PROPERTY, oldValue, newValue);\n        if (logger.isInfoEnabled())\n            logger.info(\"WhiteListName set to {}.\", newValue);\n    }\n\n    public String getWhiteListName() {\n        return PREFERENCES.get(WHITE_LIST_NAME_PROPERTY, \"\");\n    }\n\n    public void setLookAndFeel(String name) {\n        Object oldValue = getLookAndFeel();\n        PREFERENCES.put(LOOK_AND_FEEL_PROPERTY, name);\n        Object newValue = getLookAndFeel();\n        propertyChangeSupport.firePropertyChange(LOOK_AND_FEEL_PROPERTY, oldValue, newValue);\n        if (logger.isInfoEnabled())\n            logger.info(\"LookAndFeel set to {}.\", newValue);\n    }\n\n    public String getLookAndFeel() {\n        String result = PREFERENCES.get(LOOK_AND_FEEL_PROPERTY, STARTUP_LOOK_AND_FEEL);\n        if (!installedLookAndFeels.contains(result)) {\n            result = STARTUP_LOOK_AND_FEEL;\n            if (logger.isInfoEnabled())\n                logger.info(\"Look and Feel corrected to \\\"{}\\\".\", result);\n        }\n        return result;\n    }\n\n    private void initConditions() {\n        File appPath = getStartupApplicationPath();\n        File conditionsFile = new File(appPath, CONDITIONS_XML_FILENAME);\n        if (conditionsFile.isFile()) {\n            long lastModified = conditionsFile.lastModified();\n            if (conditions != null && lastConditionsModified >= lastModified) {\n                if (logger.isDebugEnabled())\n                    logger.debug(\"Won't reload conditions.\");\n                return;\n            }\n            XMLDecoder d = null;\n            try {\n                d = new XMLDecoder(new BufferedInputStream(new FileInputStream(conditionsFile)));\n                //noinspection unchecked\n                conditions = (List<SavedCondition>) d.readObject();\n                lastConditionsModified = lastModified;\n                if (logger.isDebugEnabled())\n                    logger.debug(\"Loaded conditions {}.\", conditions);\n            } catch (Throwable ex) {\n                if (logger.isWarnEnabled()) {\n                    logger.warn(\"Exception while loading conditions from file '\" + conditionsFile.getAbsolutePath() + \"'!\", ex);\n                }\n            } finally {\n                if (d != null) {\n                    d.close();\n                }\n            }\n        }\n        if (conditions == null) {\n            conditions = new ArrayList<SavedCondition>();\n        }\n    }\n\n    public SavedCondition resolveSavedCondition(Condition condition) {\n        if (condition == null) {\n            return null;\n        }\n        initConditions();\n        for (SavedCondition current : conditions) {\n            if (condition.equals(current.getCondition())) {\n                try {\n                    return current.clone();\n                } catch (CloneNotSupportedException e) {\n                    return null;\n                }\n            }\n        }\n        return null;\n    }\n\n    public SavedCondition resolveSavedCondition(String conditionName) {\n        if (conditionName == null) {\n            return null;\n        }\n        initConditions();\n        for (SavedCondition current : conditions) {\n            if (conditionName.equals(current.getName())) {\n                try {\n                    return current.clone();\n                } catch (CloneNotSupportedException e) {\n                    return null;\n                }\n            }\n        }\n        return null;\n    }\n\n    public List<SavedCondition> getConditions() {\n        initConditions();\n        // perform deep clone... otherwise no propchange would be fired.\n        ArrayList<SavedCondition> result = new ArrayList<SavedCondition>(conditions.size());\n        for (SavedCondition current : conditions) {\n            try {\n                result.add(current.clone());\n            } catch (CloneNotSupportedException e) {\n                // ignore\n            }\n        }\n        return result;\n    }\n\n    public void setConditions(List<SavedCondition> conditions) {\n        Object oldValue = getConditions();\n        writeConditions(conditions);\n        Object newValue = getConditions();\n        propertyChangeSupport.firePropertyChange(CONDITIONS_PROPERTY, oldValue, newValue);\n    }\n\n    public void setAutoOpening(boolean autoOpening) {\n        Object oldValue = isAutoOpening();\n        PREFERENCES.putBoolean(AUTO_OPENING_PROPERTY, autoOpening);\n        Object newValue = isAutoOpening();\n        propertyChangeSupport.firePropertyChange(AUTO_OPENING_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isAutoOpening() {\n        return PREFERENCES.getBoolean(AUTO_OPENING_PROPERTY, true);\n    }\n\n    public void setShowingIdentifier(boolean showingIdentifierWithName) {\n        Object oldValue = isShowingIdentifier();\n        PREFERENCES.putBoolean(SHOWING_IDENTIFIER_PROPERTY, showingIdentifierWithName);\n        Object newValue = isShowingIdentifier();\n        propertyChangeSupport.firePropertyChange(SHOWING_IDENTIFIER_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isShowingIdentifier() {\n        return PREFERENCES.getBoolean(SHOWING_IDENTIFIER_PROPERTY, true);\n    }\n\n    public void setSplashScreenDisabled(boolean splashScreenDisabled) {\n        Object oldValue = isSplashScreenDisabled();\n        PREFERENCES.putBoolean(SPLASH_SCREEN_DISABLED_PROPERTY, splashScreenDisabled);\n        Object newValue = isSplashScreenDisabled();\n        propertyChangeSupport.firePropertyChange(SPLASH_SCREEN_DISABLED_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isSplashScreenDisabled() {\n        return PREFERENCES.getBoolean(SPLASH_SCREEN_DISABLED_PROPERTY, false);\n    }\n\n    public void setAskingBeforeQuit(boolean askingBeforeQuit) {\n        Object oldValue = isAskingBeforeQuit();\n        PREFERENCES.putBoolean(ASKING_BEFORE_QUIT_PROPERTY, askingBeforeQuit);\n        Object newValue = isAskingBeforeQuit();\n        propertyChangeSupport.firePropertyChange(ASKING_BEFORE_QUIT_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isAskingBeforeQuit() {\n        return PREFERENCES.getBoolean(ASKING_BEFORE_QUIT_PROPERTY, false);\n    }\n\n    public void setShowingFullCallstack(boolean showingFullCallstack) {\n        Object oldValue = isShowingFullCallstack();\n        PREFERENCES.putBoolean(SHOWING_FULL_CALLSTACK_PROPERTY, showingFullCallstack);\n        Object newValue = isShowingFullCallstack();\n        propertyChangeSupport.firePropertyChange(SHOWING_FULL_CALLSTACK_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isShowingFullCallstack() {\n        return PREFERENCES.getBoolean(SHOWING_FULL_CALLSTACK_PROPERTY, false);\n    }\n\n    public void setShowingStackTrace(boolean showingStackTrace) {\n        Object oldValue = isShowingStackTrace();\n        PREFERENCES.putBoolean(SHOWING_STACKTRACE_PROPERTY, showingStackTrace);\n        Object newValue = isShowingStackTrace();\n        propertyChangeSupport.firePropertyChange(SHOWING_STACKTRACE_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isShowingStackTrace() {\n        return PREFERENCES.getBoolean(SHOWING_STACKTRACE_PROPERTY, true);\n    }\n\n    public void setCleaningLogsOnExit(boolean cleaningLogsOnExit) {\n        Object oldValue = isCleaningLogsOnExit();\n        PREFERENCES.putBoolean(CLEANING_LOGS_ON_EXIT_PROPERTY, cleaningLogsOnExit);\n        Object newValue = isCleaningLogsOnExit();\n        propertyChangeSupport.firePropertyChange(CLEANING_LOGS_ON_EXIT_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isCleaningLogsOnExit() {\n        return PREFERENCES.getBoolean(CLEANING_LOGS_ON_EXIT_PROPERTY, false);\n    }\n\n    public void setColoringWholeRow(boolean coloringWholeRow) {\n        Object oldValue = isColoringWholeRow();\n        PREFERENCES.putBoolean(COLORING_WHOLE_ROW_PROPERTY, coloringWholeRow);\n        Object newValue = isColoringWholeRow();\n        propertyChangeSupport.firePropertyChange(COLORING_WHOLE_ROW_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isColoringWholeRow() {\n        return PREFERENCES.getBoolean(COLORING_WHOLE_ROW_PROPERTY, false);\n    }\n\n    public void setCheckingForUpdate(boolean checkingForUpdate) {\n        Object oldValue = isCheckingForUpdate();\n        PREFERENCES.putBoolean(CHECKING_FOR_UPDATE_PROPERTY, checkingForUpdate);\n        Object newValue = isCheckingForUpdate();\n        propertyChangeSupport.firePropertyChange(CHECKING_FOR_UPDATE_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isCheckingForUpdate() {\n        return PREFERENCES.getBoolean(CHECKING_FOR_UPDATE_PROPERTY, true);\n    }\n\n    public void setAutoClosing(boolean autoClosing) {\n        Object oldValue = isAutoClosing();\n        PREFERENCES.putBoolean(AUTO_CLOSING_PROPERTY, autoClosing);\n        Object newValue = isAutoClosing();\n        propertyChangeSupport.firePropertyChange(AUTO_CLOSING_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isAutoClosing() {\n        return PREFERENCES.getBoolean(AUTO_CLOSING_PROPERTY, false);\n    }\n\n    public File getImagePath() {\n        String imagePath = PREFERENCES.get(IMAGE_PATH_PROPERTY, USER_HOME);\n        File result = new File(imagePath);\n        if (!result.isDirectory()) {\n            result = new File(USER_HOME);\n        }\n        return result;\n    }\n\n    public void setImagePath(File imagePath) {\n        if (!imagePath.isDirectory()) {\n            throw new IllegalArgumentException(\"'\" + imagePath.getAbsolutePath() + \"' is not a directory!\");\n        }\n        Object oldValue = getImagePath();\n        PREFERENCES.put(IMAGE_PATH_PROPERTY, imagePath.getAbsolutePath());\n        Object newValue = getImagePath();\n        propertyChangeSupport.firePropertyChange(IMAGE_PATH_PROPERTY, oldValue, newValue);\n    }\n\n    public File getPreviousOpenPath() {\n        String imagePath = PREFERENCES.get(PREVIOUS_OPEN_PATH_PROPERTY, USER_HOME);\n        File result = new File(imagePath);\n        if (!result.isDirectory()) {\n            result = new File(USER_HOME);\n        }\n        return result;\n    }\n\n    public void setPreviousOpenPath(File openPath) {\n        if (!openPath.isDirectory()) {\n            throw new IllegalArgumentException(\"'\" + openPath.getAbsolutePath() + \"' is not a directory!\");\n        }\n        Object oldValue = getPreviousOpenPath();\n        PREFERENCES.put(PREVIOUS_OPEN_PATH_PROPERTY, openPath.getAbsolutePath());\n        Object newValue = getPreviousOpenPath();\n        propertyChangeSupport.firePropertyChange(PREVIOUS_OPEN_PATH_PROPERTY, oldValue, newValue);\n    }\n\n    public File getPreviousImportPath() {\n        String imagePath = PREFERENCES.get(PREVIOUS_IMPORT_PATH_PROPERTY, USER_HOME);\n        File result = new File(imagePath);\n        if (!result.isDirectory()) {\n            result = new File(USER_HOME);\n        }\n        return result;\n    }\n\n    public void setPreviousImportPath(File importPath) {\n        if (!importPath.isDirectory()) {\n            throw new IllegalArgumentException(\"'\" + importPath.getAbsolutePath() + \"' is not a directory!\");\n        }\n        Object oldValue = getPreviousImportPath();\n        PREFERENCES.put(PREVIOUS_IMPORT_PATH_PROPERTY, importPath.getAbsolutePath());\n        Object newValue = getPreviousImportPath();\n        propertyChangeSupport.firePropertyChange(PREVIOUS_IMPORT_PATH_PROPERTY, oldValue, newValue);\n    }\n\n    public File getSoundPath() {\n        String soundPath = PREFERENCES.get(SOUND_PATH_PROPERTY, USER_HOME);\n        File result = new File(soundPath);\n        if (!result.isDirectory()) {\n            result = new File(USER_HOME);\n        }\n        return result;\n    }\n\n    public void setSoundPath(File soundPath) {\n        if (!soundPath.isDirectory()) {\n            throw new IllegalArgumentException(\"'\" + soundPath.getAbsolutePath() + \"' is not a directory!\");\n        }\n        Object oldValue = getSoundPath();\n        PREFERENCES.put(SOUND_PATH_PROPERTY, soundPath.getAbsolutePath());\n        Object newValue = getSoundPath();\n        propertyChangeSupport.firePropertyChange(SOUND_PATH_PROPERTY, oldValue, newValue);\n    }\n\n    public void setMute(boolean mute) {\n        Object oldValue = isMute();\n        PREFERENCES.putBoolean(MUTE_PROPERTY, mute);\n        Object newValue = isMute();\n        propertyChangeSupport.firePropertyChange(MUTE_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isMute() {\n        return PREFERENCES.getBoolean(MUTE_PROPERTY, false);\n    }\n\n    public void setLicensed(boolean licensed) {\n        Object oldValue = isLicensed();\n        if (licensed) {\n            PREFERENCES.put(LICENSED_PREFERENCES_KEY, Lilith.APP_VERSION);\n        } else {\n            PREFERENCES.remove(LICENSED_PREFERENCES_KEY);\n        }\n        Object newValue = isLicensed();\n        propertyChangeSupport.firePropertyChange(LICENSED_PREFERENCES_KEY, oldValue, newValue);\n    }\n\n    public boolean isLicensed() {\n        return Lilith.APP_VERSION.equals(PREFERENCES.get(LICENSED_PREFERENCES_KEY, null));\n    }\n\n    public void setApplicationPath(File applicationPath) {\n        if (applicationPath.mkdirs()) {\n            if (logger.isInfoEnabled())\n                logger.info(\"Created directory {}.\", applicationPath.getAbsolutePath());\n        }\n        if (!applicationPath.isDirectory()) {\n            throw new IllegalArgumentException(\"'\" + applicationPath.getAbsolutePath() + \"' is not a directory!\");\n        }\n        // !!!\n        Object oldValue = getStartupApplicationPath();\n        PREFERENCES.put(APPLICATION_PATH_PROPERTY, applicationPath.getAbsolutePath());\n        Object newValue = getApplicationPath();\n        propertyChangeSupport.firePropertyChange(APPLICATION_PATH_PROPERTY, oldValue, newValue);\n    }\n\n    public File getApplicationPath() {\n        String appPath = PREFERENCES.get(APPLICATION_PATH_PROPERTY, DEFAULT_APPLICATION_PATH);\n        File result = new File(appPath);\n        if (result.mkdirs()) {\n            if (logger.isInfoEnabled())\n                logger.info(\"Created directory {}.\", result.getAbsolutePath());\n        }\n        return result;\n    }\n\n    /**\n     * The StartupApplicationPath is initialized on application startup via ApplicationPreferences.getApplicationPath.\n     * If a part of the application needs the application path it should *always* use this method instead of\n     * getApplicationPath() since the application path might change while this one will always stay\n     * the same.\n     * <p/>\n     * A switch of the application path while the application is running isn't safe so it's changed for real\n     * upon next restart.\n     *\n     * @return the application path at startup time.\n     */\n    public File getStartupApplicationPath() {\n        return startupApplicationPath;\n    }\n\n    public void setUsingInternalFrames(boolean usingInternalFrames) {\n        Object oldValue = isUsingInternalFrames();\n        PREFERENCES.putBoolean(USING_INTERNAL_FRAMES_PROPERTY, usingInternalFrames);\n        Object newValue = isUsingInternalFrames();\n        propertyChangeSupport.firePropertyChange(USING_INTERNAL_FRAMES_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isUsingInternalFrames() {\n        return PREFERENCES.getBoolean(USING_INTERNAL_FRAMES_PROPERTY, true);\n    }\n\n    public void setAutoFocusingWindow(boolean autoFocusingWindow) {\n        Object oldValue = isAutoFocusingWindow();\n        PREFERENCES.putBoolean(AUTO_FOCUSING_WINDOW_PROPERTY, autoFocusingWindow);\n        Object newValue = isAutoFocusingWindow();\n        propertyChangeSupport.firePropertyChange(AUTO_FOCUSING_WINDOW_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isAutoFocusingWindow() {\n        return PREFERENCES.getBoolean(AUTO_FOCUSING_WINDOW_PROPERTY, false);\n    }\n\n    public void setSourceNames(Map<String, String> sourceNames) {\n        Object oldValue = getSourceNames();\n        writeSourceNames(sourceNames);\n        Object newValue = getSourceNames();\n        propertyChangeSupport.firePropertyChange(SOURCE_NAMES_PROPERTY, oldValue, newValue);\n    }\n\n    public Map<String, String> getSourceNames() {\n        File appPath = getStartupApplicationPath();\n        File sourceNamesFile = new File(appPath, SOURCE_NAMES_XML_FILENAME);\n        if (sourceNamesFile.isFile()) {\n            if (loadSourceNamesXml(sourceNamesFile)) {\n                return new HashMap<String, String>(sourceNames);\n            }\n        }\n        sourceNamesFile = new File(appPath, SOURCE_NAMES_PROPERTIES_FILENAME);\n        if (sourceNamesFile.isFile()) {\n            if (loadSourceNamesProperties(sourceNamesFile)) {\n                return new HashMap<String, String>(sourceNames);\n            }\n        }\n        return new HashMap<String, String>(DEFAULT_SOURCE_NAMES);\n    }\n\n    public Map<String, String> getSoundLocations() {\n        File appPath = getStartupApplicationPath();\n        File file = new File(appPath, SOUND_LOCATIONS_XML_FILENAME);\n        if (file.isFile()) {\n            if (loadSoundLocationsXml(file)) {\n                return new HashMap<String, String>(soundLocations);\n            }\n        }\n        return new HashMap<String, String>(DEFAULT_SOUND_LOCATIONS);\n    }\n\n    public void setSoundLocations(Map<String, String> soundLocations) {\n        Object oldValue = getSoundLocations();\n        writeSoundLocations(soundLocations);\n        Object newValue = getSoundLocations();\n        propertyChangeSupport.firePropertyChange(SOUND_LOCATIONS_PROPERTY, oldValue, newValue);\n    }\n\n    public void resetSoundLocations() {\n        if (logger.isInfoEnabled())\n            logger.info(\"Initializing preferences with default sound locations.\");\n        setSoundLocations(DEFAULT_SOUND_LOCATIONS);\n    }\n\n    public void addPropertyChangeListener(PropertyChangeListener listener) {\n        propertyChangeSupport.addPropertyChangeListener(listener);\n    }\n\n    public void removePropertyChangeListener(PropertyChangeListener listener) {\n        propertyChangeSupport.removePropertyChangeListener(listener);\n    }\n\n    public void reset() {\n        final Logger logger = LoggerFactory.getLogger(ApplicationPreferences.class);\n        boolean licensed = isLicensed();\n        try {\n            PREFERENCES.clear();\n            resetSoundLocations();\n            setLicensed(licensed);\n            setApplicationPath(new File(DEFAULT_APPLICATION_PATH));\n        } catch (BackingStoreException e) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Exception while clearing preferences!\");\n        }\n    }\n\n    public void setScrollingToBottom(boolean scrollingToBottom) {\n        Object oldValue = isScrollingToBottom();\n        PREFERENCES.putBoolean(SCROLLING_TO_BOTTOM_PROPERTY, scrollingToBottom);\n        Object newValue = isScrollingToBottom();\n        propertyChangeSupport.firePropertyChange(SCROLLING_TO_BOTTOM_PROPERTY, oldValue, newValue);\n    }\n\n    public boolean isScrollingToBottom() {\n        return PREFERENCES.getBoolean(SCROLLING_TO_BOTTOM_PROPERTY, true);\n    }\n\n    private boolean loadSoundLocationsXml(File file) {\n        long lastModified = file.lastModified();\n        if (soundLocations != null && lastSoundLocationsModified >= lastModified) {\n            if (logger.isDebugEnabled())\n                logger.debug(\"Won't reload sound locations.\");\n            return true;\n        }\n        Map<String, String> props = loadPropertiesXml(file);\n        if (props != null) {\n            lastSoundLocationsModified = lastModified;\n            soundLocations = props;\n            return true;\n        }\n        return false;\n    }\n\n    private boolean writeSoundLocations(Map<String, String> sourceNames) {\n        File appPath = getStartupApplicationPath();\n        File file = new File(appPath, SOUND_LOCATIONS_XML_FILENAME);\n        return writePropertiesXml(file, sourceNames, \"Sound locations\");\n    }\n\n    private boolean loadSourceNamesXml(File file) {\n        long lastModified = file.lastModified();\n        if (sourceNames != null && lastSourceNamesModified >= lastModified) {\n            if (logger.isDebugEnabled())\n                logger.debug(\"Won't reload source names.\");\n            return true;\n        }\n        Map<String, String> props = loadPropertiesXml(file);\n        if (props != null) {\n            lastSourceNamesModified = lastModified;\n            sourceNames = props;\n            return true;\n        }\n        return false;\n    }\n\n    private boolean loadSourceNamesProperties(File sourceNamesFile) {\n        long lastModified = sourceNamesFile.lastModified();\n        if (sourceNames != null && lastSourceNamesModified >= lastModified) {\n            if (logger.isDebugEnabled())\n                logger.debug(\"Won't reload source names.\");\n            return true;\n        }\n        Map<String, String> props = loadProperties(sourceNamesFile);\n        if (props != null) {\n            lastSourceNamesModified = lastModified;\n            sourceNames = props;\n            return true;\n        }\n        return false;\n    }\n\n    private boolean writeSourceNames(Map<String, String> sourceNames) {\n        File appPath = getStartupApplicationPath();\n        File file = new File(appPath, SOURCE_NAMES_XML_FILENAME);\n        return writePropertiesXml(file, sourceNames, \"Source names\");\n    }\n\n    private boolean writeSourceLists(Map<String, Set<String>> sourceLists) {\n        File appPath = getStartupApplicationPath();\n        File file = new File(appPath, SOURCE_LISTS_XML_FILENAME);\n        XMLEncoder e = null;\n        Throwable error = null;\n        try {\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file));\n            e = new XMLEncoder(bos);\n            e.writeObject(sourceLists);\n        } catch (FileNotFoundException ex) {\n            error = ex;\n        } finally {\n            if (e != null) {\n                e.close();\n            }\n        }\n        if (error != null) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Exception while writing source lists!\", error);\n            return false;\n        }\n        return true;\n    }\n\n    private boolean writeConditions(List<SavedCondition> conditions) {\n        File appPath = getStartupApplicationPath();\n        File file = new File(appPath, CONDITIONS_XML_FILENAME);\n        XMLEncoder e = null;\n        Throwable error = null;\n        try {\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file));\n            e = new XMLEncoder(bos);\n            e.writeObject(conditions);\n            if (logger.isInfoEnabled())\n                logger.info(\"Wrote conditions {}.\", conditions);\n        } catch (FileNotFoundException ex) {\n            error = ex;\n        } finally {\n            if (e != null) {\n                e.close();\n            }\n        }\n        if (error != null) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Exception while writing source lists!\", error);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @noinspection MismatchedQueryAndUpdateOfCollection\n     */\n    private Map<String, String> loadPropertiesXml(File file) {\n        InputStream is = null;\n        try {\n            is = new BufferedInputStream(new FileInputStream(file));\n            Properties props = new Properties();\n            props.loadFromXML(is);\n            Map<String, String> result = new HashMap<String, String>();\n            for (Object keyObj : props.keySet()) {\n                String key = (String) keyObj;\n                String value = (String) props.get(key);\n                if (value != null) {\n                    result.put(key, value);\n                }\n            }\n            return result;\n        } catch (IOException e) {\n            if (logger.isWarnEnabled()) {\n                logger.warn(\"Couldn't load properties from '\" + file.getAbsolutePath() + \"'!\", e);\n            }\n        } finally {\n            IOUtils.closeQuietly(is);\n        }\n        return null;\n    }\n\n    /**\n     * @noinspection MismatchedQueryAndUpdateOfCollection\n     */\n    private boolean writePropertiesXml(File file, Map<String, String> sourceNames, String comment) {\n        Properties output = new Properties();\n        for (Map.Entry<String, String> entry : sourceNames.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            if (value != null) {\n                output.put(key, value);\n            }\n        }\n        OutputStream os = null;\n        Throwable error = null;\n        try {\n            os = new BufferedOutputStream(new FileOutputStream(file));\n            output.storeToXML(os, comment, \"UTF-8\");\n        } catch (FileNotFoundException e) {\n            error = e;\n        } catch (IOException e) {\n            error = e;\n        } finally {\n            IOUtils.closeQuietly(os);\n        }\n        if (error != null) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Exception while writing source names!\", error);\n            return false;\n        }\n        return true;\n    }\n\n    private Map<String, String> loadProperties(File file) {\n        InputStream is = null;\n        try {\n            is = new BufferedInputStream(new FileInputStream(file));\n            Properties props = new Properties();\n            props.load(is);\n            Map<String, String> result = new HashMap<String, String>();\n            for (Object keyObj : props.keySet()) {\n                String key = (String) keyObj;\n                String value = (String) props.get(key);\n                if (value != null) {\n                    result.put(key, value);\n                }\n            }\n            return result;\n        } catch (IOException e) {\n            if (logger.isWarnEnabled()) {\n                logger.warn(\"Couldn't load properties from '\" + file.getAbsolutePath() + \"'!\", e);\n            }\n        } finally {\n            IOUtils.closeQuietly(is);\n        }\n        return null;\n    }\n\n    public void writeLoggingColumnLayout(boolean global, List<PersistentTableColumnModel.TableColumnLayoutInfo> layoutInfos) {\n        File appPath = getStartupApplicationPath();\n        File file;\n        if (global) {\n            file = new File(appPath, LOGGING_LAYOUT_GLOBAL_XML_FILENAME);\n        } else {\n            file = new File(appPath, LOGGING_LAYOUT_XML_FILENAME);\n        }\n        writeColumnLayout(file, layoutInfos);\n    }\n\n    public void writeAccessColumnLayout(boolean global, List<PersistentTableColumnModel.TableColumnLayoutInfo> layoutInfos) {\n        File appPath = getStartupApplicationPath();\n        File file;\n        if (global) {\n            file = new File(appPath, ACCESS_LAYOUT_GLOBAL_XML_FILENAME);\n        } else {\n            file = new File(appPath, ACCESS_LAYOUT_XML_FILENAME);\n        }\n        writeColumnLayout(file, layoutInfos);\n    }\n\n    public List<PersistentTableColumnModel.TableColumnLayoutInfo> readLoggingColumnLayout(boolean global) {\n        File appPath = getStartupApplicationPath();\n        File file;\n        if (global) {\n            file = new File(appPath, LOGGING_LAYOUT_GLOBAL_XML_FILENAME);\n        } else {\n            file = new File(appPath, LOGGING_LAYOUT_XML_FILENAME);\n        }\n        return readColumnLayout(file);\n    }\n\n    public List<PersistentTableColumnModel.TableColumnLayoutInfo> readAccessColumnLayout(boolean global) {\n        File appPath = getStartupApplicationPath();\n        File file;\n        if (global) {\n            file = new File(appPath, ACCESS_LAYOUT_GLOBAL_XML_FILENAME);\n        } else {\n            file = new File(appPath, ACCESS_LAYOUT_XML_FILENAME);\n        }\n        return readColumnLayout(file);\n    }\n\n    private boolean writeColumnLayout(File file, List<PersistentTableColumnModel.TableColumnLayoutInfo> layoutInfos) {\n        XMLEncoder e = null;\n        Throwable error = null;\n        try {\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file));\n            e = new XMLEncoder(bos);\n            e.writeObject(layoutInfos);\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Wrote layouts {} to file '{}'.\", layoutInfos, file.getAbsolutePath());\n            }\n        } catch (FileNotFoundException ex) {\n            error = ex;\n        } finally {\n            if (e != null) {\n                e.close();\n            }\n        }\n        if (error != null) {\n            if (logger.isWarnEnabled()) {\n                logger.warn(\"Exception while writing layouts to file '\" + file.getAbsolutePath() + \"'!\", error);\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private List<PersistentTableColumnModel.TableColumnLayoutInfo> readColumnLayout(File file) {\n        XMLDecoder d = null;\n        List<PersistentTableColumnModel.TableColumnLayoutInfo> result;\n        try {\n            d = new XMLDecoder(new BufferedInputStream(new FileInputStream(file)));\n            //noinspection unchecked\n            result = (List<PersistentTableColumnModel.TableColumnLayoutInfo>) d.readObject();\n        } catch (Throwable ex) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Exception while loading layouts from file '{}'':\", file.getAbsolutePath(), ex.getMessage());\n            }\n            result = null;\n        } finally {\n            if (d != null) {\n                d.close();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Quick & dirty MD5 checksum function.\n     * Returns null in case of error.\n     *\n     * @param input the input\n     * @return the checksum\n     */\n    public static byte[] getMD5(InputStream input) {\n        if (input == null) {\n            return null;\n        }\n        MessageDigest messageDigest;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n            byte[] buffer = new byte[1024];\n            for (; ; ) {\n                int read = input.read(buffer);\n                if (read < 0) {\n                    break;\n                }\n                messageDigest.update(buffer, 0, read);\n            }\n            return messageDigest.digest();\n        } catch (Throwable t) {\n            final Logger logger = LoggerFactory.getLogger(ApplicationPreferences.class);\n            if (logger.isWarnEnabled())\n                logger.warn(\"Exception while calculating checksum!\", t);\n        } finally {\n            try {\n                input.close();\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n        return null;\n    }\n\n    public void flush() {\n        try {\n            PREFERENCES.flush();\n        } catch (BackingStoreException e) {\n            if (logger.isWarnEnabled())\n                logger.warn(\"Exception while flushing preferences!\", e);\n        }\n    }\n\n    /**\n     * As described in http://weblogs.java.net/blog/malenkov/archive/2006/08/how_to_encode_e.html\n     */\n    static class EnumPersistenceDelegate extends PersistenceDelegate {\n\n        protected boolean mutatesTo(Object oldInstance, Object newInstance) {\n            return oldInstance == newInstance;\n        }\n\n        protected Expression instantiate(Object oldInstance, Encoder out) {\n            Enum e = (Enum) oldInstance;\n            return new Expression(e, e.getClass(), \"valueOf\", new Object[] { e.name() });\n        }\n    }\n}\n",
    "test_prompt": "// ApplicationPreferences_8Test.java\npackage de.huxhorn.lilith.swing;\n\nimport de.huxhorn.lilith.Lilith;\nimport de.huxhorn.lilith.LilithSounds;\nimport de.huxhorn.lilith.data.access.HttpStatus;\nimport de.huxhorn.lilith.data.logging.LoggingEvent;\nimport de.huxhorn.lilith.swing.filefilters.GroovyConditionFileFilter;\nimport de.huxhorn.lilith.swing.preferences.SavedCondition;\nimport de.huxhorn.lilith.swing.table.ColorScheme;\nimport de.huxhorn.lilith.swing.table.model.PersistentTableColumnModel;\nimport de.huxhorn.sulky.conditions.Condition;\nimport org.apache.commons.io.IOUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.awt.*;\nimport java.beans.Encoder;\nimport java.beans.Expression;\nimport java.beans.PersistenceDelegate;\nimport java.beans.PropertyChangeListener;\nimport java.beans.PropertyChangeSupport;\nimport java.beans.XMLDecoder;\nimport java.beans.XMLEncoder;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.DataInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.security.MessageDigest;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.prefs.BackingStoreException;\nimport java.util.prefs.Preferences;\nimport javax.swing.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ApplicationPreferences}.\n* It contains ten unit test cases for the {@link ApplicationPreferences#getMD5(InputStream)} method.\n*/\nclass ApplicationPreferences_8Test {",
    "time_taken": -1
},
{
    "id": "cmpl-6wSO6jICzmbCCIxp7ZcrhirEXeiDZ",
    "object": "text_completion",
    "created": 1679390166,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\tprivate final Logger logger = LoggerFactory.getLogger(IndexingCallableTest.class);\n\t\t\n\t\t/**\n\t\t* Test case for {@link IndexingCallable#call()} method.\n\t\t* Test data: File 'test.data' does not exist.\n\t\t* Expected result: FileNotFoundException.\n\t\t*/\n\t\t@Test\n\t\tpublic void testCall_1() throws Exception {\n\t\t\t\tFile dataFile = new File(\"test.data\");\n\t\t\t\tFile indexFile = new File(\"test.index\");\n\t\t\t\tIndexingCallable indexingCallable = new IndexingCallable(dataFile, indexFile);\n\t\t\t\tassertThrows(FileNotFoundException.class, () -&gt; {\n\t\t\t\t\t\tindexingCallable.call();\n\t\t\t\t});\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link IndexingCallable#call()} method.\n\t\t* Test data: File 'test.data' is not a file.\n\t\t* Expected result: FileNotFoundException.\n\t\t*/\n\t\t@Test\n\t\tpublic void testCall_2() throws Exception {\n\t\t\t\tFile dataFile = new File(\"test.data\");\n\t\t\t\tFile indexFile = new File(\"test.index\");\n\t\t\t\tIndexingCallable indexingCallable = new IndexingCallable(dataFile, indexFile);\n\t\t\t\tassertThrows(FileNotFoundException.class, () -&gt; {\n\t\t\t\t\t\tindexingCallable.call();\n\t\t\t\t});\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link IndexingCallable#call()} method.\n\t\t* Test data: File 'test.data' is a valid file.\n\t\t* Expected result: Long.\n\t\t*/\n\t\t@Test\n\t\tpublic void testCall_3() throws Exception {\n\t\t\t\tFile dataFile = new File(\"test.data\");\n\t\t\t\tFile indexFile = new File(\"test.index\");\n\t\t\t\tIndexingCallable indexingCallable = new IndexingCallable(dataFile, indexFile);\n\t\t\t\tassertEquals(Long.class, indexingCallable.call().getClass());\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link IndexingCallable#call()} method.\n\t\t* Test data: File 'test.data' is a valid file.\n\t\t* Expected result: Long.\n\t\t*/\n\t\t@Test\n\t\tpublic void testCall_4() throws Exception {\n\t\t\t\tFile dataFile = new File(\"test.data\");\n\t\t\t\tFile indexFile = new File(\"test.index\");\n\t\t\t\tIndexingCallable indexingCallable = new IndexingCallable(dataFile, indexFile);\n\t\t\t\tassertEquals(Long.class, indexingCallable.call().getClass());\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link IndexingCallable#call()} method.\n\t\t* Test data: File 'test.data' is a valid file.\n\t\t* Expected result: Long.\n\t\t*/\n\t\t@Test\n\t\tpublic void testCall_5() throws Exception {\n\t\t\t\tFile dataFile = new File(\"test.data\");\n\t\t\t\tFile indexFile = new File(\"test.index\");\n\t\t\t\tIndexingCallable indexingCallable = new IndexingCallable(dataFile, indexFile);\n\t\t\t\tassertEquals(Long.class, indexingCallable.call().getClass());\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link IndexingCallable#call()} method.\n\t\t* Test data: File 'test.data' is a valid file.\n\t\t* Expected result: Long.\n\t\t*/\n\t\t@Test\n\t\tpublic void testCall_6() throws Exception {\n\t\t\t\tFile dataFile = new File(\"test.data\");\n\t\t\t\tFile indexFile = new File(\"test.index\");\n\t\t\t\tIndexingCallable indexingCallable = new IndexingCallable(dataFile, indexFile);\n\t\t\t\tassertEquals(Long.class, indexingCallable.call().getClass());\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link IndexingCallable#call()} method.\n\t\t* Test data: File 'test.data' is a valid file.\n\t\t* Expected result: Long.\n\t\t*/\n\t\t@Test\n\t\tpublic void testCall_7() throws Exception {\n\t\t\t\tFile dataFile = new File(\"test.data\");\n\t\t\t\tFile indexFile = new File(\"test.index\");\n\t\t\t\tIndexingCallable indexingCallable = new IndexingCallable(dataFile, indexFile);\n\t\t\t\tassertEquals(Long.class, indexingCallable.call().getClass());\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link IndexingCallable#call()} method.\n\t\t* Test data: File 'test.data' is a valid file.\n\t\t* Expected result: Long.\n\t\t*/\n\t\t@Test\n\t\tpublic void testCall_8() throws Exception {\n\t\t\t\tFile dataFile = new File(\"test.data\");\n\t\t\t\tFile indexFile = new File(\"test.index\");\n\t\t\t\tIndexingCallable indexingCallable = new IndexingCallable(dataFile, indexFile);\n\t\t\t\tassertEquals(Long.class, indexingCallable.call().getClass());\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link IndexingCallable#call()} method.\n\t\t* Test data: File 'test.data' is a valid file.\n\t\t* Expected result: Long.\n\t\t*/\n\t\t@Test\n\t\tpublic void testCall_9() throws Exception {\n\t\t\t\tFile dataFile = new File(\"test.data\");\n\t\t\t\tFile indexFile = new File(\"test.index\");\n\t\t\t\tIndexingCallable indexingCallable = new IndexingCallable(dataFile, indexFile);\n\t\t\t\tassertEquals(Long.class, indexingCallable.call().getClass());\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link IndexingCallable#call()} method.\n\t\t* Test data: File 'test.data' is a valid file.\n\t\t* Expected result: Long.\n\t\t*/\n\t\t@Test\n\t\tpublic void testCall_10() throws Exception {\n\t\t\t\tFile dataFile = new File(\"test.data\");\n\t\t\t\tFile indexFile = new File(\"test.index\");\n\t\t\t\tIndexingCallable indexingCallable = new IndexingCallable(dataFile, indexFile);\n\t\t\t\tassertEquals(Long.class, indexingCallable.call().getClass());\n\t\t}\n\t\t\n}\n\n// IndexingTask.java\n/*\n * Lilith - a log event viewer.\n * Copyright (C) 2007-2009 Joern Huxhorn\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage de.huxhorn.lilith.swing.taskmanager;\n\nimport de.huxhorn.lilith.swing.taskmanager.TaskStatus.State;\nimport de.huxhorn.sulky.tasks.AbstractProgressingCallable;\nimport de.huxhorn.sulky.tasks.Task;\nimport de.huxhorn.sulky.tasks.TaskListener;\nimport de.huxhorn.sul",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 1886,
        "completion_tokens": 2000,
        "total_tokens": 3886
    },
    "time_taken": 60.98687124252319,
    "prompt_id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/callables/IndexingCallable.java",
    "original_code": "// IndexingCallable.java\n/*\r\n * Lilith - a log event viewer.\r\n * Copyright (C) 2007-2009 Joern Huxhorn\r\n * \r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.huxhorn.lilith.swing.callables;\r\n\r\nimport de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;\r\nimport de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;\r\nimport de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;\r\nimport de.huxhorn.sulky.codec.filebuffer.FileHeader;\r\nimport de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;\r\nimport de.huxhorn.sulky.codec.filebuffer.IndexStrategy;\r\nimport de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;\r\nimport de.huxhorn.sulky.tasks.AbstractProgressingCallable;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.IOException;\r\nimport java.io.RandomAccessFile;\r\n\r\n/**\r\n * Should only be executed on inactive files.\r\n */\r\npublic class IndexingCallable extends AbstractProgressingCallable<Long> {\r\n\r\n    private final Logger logger = LoggerFactory.getLogger(IndexingCallable.class);\r\n\r\n    private File dataFile;\r\n\r\n    private File indexFile;\r\n\r\n    public IndexingCallable(File dataFile, File indexFile) {\r\n        this.dataFile = dataFile;\r\n        this.indexFile = indexFile;\r\n    }\r\n\r\n    /**\r\n     * Computes a result, or throws an exception if unable to do so.\r\n     *\r\n     * @return computed result\r\n     * @throws Exception if unable to compute a result\r\n     */\r\n    public Long call() throws Exception {\r\n        if (!dataFile.exists()) {\r\n            throw new FileNotFoundException(\"File '\" + dataFile.getAbsolutePath() + \"' does not exist!\");\r\n        }\r\n        if (!dataFile.isFile()) {\r\n            throw new FileNotFoundException(\"File '\" + dataFile.getAbsolutePath() + \"' is not a file!\");\r\n        }\r\n        long fileSize = dataFile.length();\r\n        setNumberOfSteps(fileSize);\r\n        FileHeaderStrategy fhs = new DefaultFileHeaderStrategy();\r\n        FileHeader fileHeader = fhs.readFileHeader(dataFile);\r\n        if (fileHeader != null) {\r\n            boolean sparse = fileHeader.getMetaData().isSparse();\r\n            long offset = fileHeader.getDataOffset();\r\n            RandomAccessFile dataRAFile = null;\r\n            RandomAccessFile indexRAFile = null;\r\n            Exception ex = null;\r\n            long counter = 0;\r\n            IndexStrategy indexStrategy = new DefaultIndexStrategy();\r\n            try {\r\n                dataRAFile = new RandomAccessFile(dataFile, \"r\");\r\n                indexRAFile = new RandomAccessFile(indexFile, \"rw\");\r\n                indexRAFile.setLength(0);\r\n                while (offset < fileSize) {\r\n                    dataRAFile.seek(offset);\r\n                    int dataSize = dataRAFile.readInt();\r\n                    if (!sparse) {\r\n                        indexStrategy.setOffset(indexRAFile, counter, offset);\r\n                        offset = offset + dataSize + DefaultDataStrategy.DATA_LENGTH_SIZE;\r\n                    } else {\r\n                        long index = dataRAFile.readLong();\r\n                        indexStrategy.setOffset(indexRAFile, index, offset);\r\n                        offset = offset + dataSize + SparseDataStrategy.DATA_LENGTH_SIZE + SparseDataStrategy.INDEX_SIZE;\r\n                    }\r\n                    counter++;\r\n                    setCurrentStep(offset);\r\n                }\r\n            } catch (IOException e) {\r\n                ex = e;\r\n            } catch (InterruptedException e) {\r\n                ex = e;\r\n            } finally {\r\n                closeQuietly(dataRAFile);\r\n                closeQuietly(indexRAFile);\r\n            }\r\n            if (ex != null) {\r\n                if (!indexFile.delete()) {\r\n                    if (logger.isWarnEnabled()) {\r\n                        logger.warn(\"Failed to delete index file '{}'!\", indexFile.getAbsolutePath());\r\n                    }\r\n                }\r\n                // rethrow\r\n                throw ex;\r\n            }\r\n            if (logger.isInfoEnabled())\r\n                logger.info(\"File '{}' has {} entries.\", dataFile.getAbsolutePath(), counter);\r\n            return counter;\r\n        } else {\r\n            throw new IllegalArgumentException(\"File '\" + dataFile.getAbsolutePath() + \"' is not a valid file!\");\r\n        }\r\n    }\r\n\r\n    public File getDataFile() {\r\n        return dataFile;\r\n    }\r\n\r\n    public File getIndexFile() {\r\n        return indexFile;\r\n    }\r\n\r\n    private static void closeQuietly(RandomAccessFile file) {\r\n        if (file != null) {\r\n            try {\r\n                file.close();\r\n            } catch (IOException e) {\r\n                // ignore\r\n            }\r\n        }\r\n    }\r\n}\r\n",
    "test_prompt": "// IndexingCallableTest.java\npackage de.huxhorn.lilith.swing.callables;\n\nimport de.huxhorn.sulky.codec.filebuffer.DefaultDataStrategy;\nimport de.huxhorn.sulky.codec.filebuffer.DefaultFileHeaderStrategy;\nimport de.huxhorn.sulky.codec.filebuffer.DefaultIndexStrategy;\nimport de.huxhorn.sulky.codec.filebuffer.FileHeader;\nimport de.huxhorn.sulky.codec.filebuffer.FileHeaderStrategy;\nimport de.huxhorn.sulky.codec.filebuffer.IndexStrategy;\nimport de.huxhorn.sulky.codec.filebuffer.SparseDataStrategy;\nimport de.huxhorn.sulky.tasks.AbstractProgressingCallable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link IndexingCallable}.\n* It contains ten unit test cases for the {@link IndexingCallable#call()} method.\n*/\nclass IndexingCallableTest {"
},
{
    "id": "cmpl-6wSP59kGIk1Hlxx6RIPGwVqCJv8K2",
    "object": "text_completion",
    "created": 1679390227,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\t@Test\n\t\tpublic void testGetElementAt() {\n\t\t\t\tList<String> data = new ArrayList<String>();\n\t\t\t\tdata.add(\"a\");\n\t\t\t\tdata.add(\"b\");\n\t\t\t\tdata.add(\"c\");\n\t\t\t\tdata.add(\"d\");\n\t\t\t\tdata.add(\"e\");\n\t\t\t\tdata.add(\"f\");\n\t\t\t\tdata.add(\"g\");\n\t\t\t\tdata.add(\"h\");\n\t\t\t\tdata.add(\"i\");\n\t\t\t\tdata.add(\"j\");\n\t\t\t\tGenericSortedListModel<String> model = new GenericSortedListModel<String>();\n\t\t\t\tmodel.setData(data);\n\t\t\t\tassertEquals(\"a\", model.getElementAt(0));\n\t\t\t\tassertEquals(\"b\", model.getElementAt(1));\n\t\t\t\tassertEquals(\"c\", model.getElementAt(2));\n\t\t\t\tassertEquals(\"d\", model.getElementAt(3));\n\t\t\t\tassertEquals(\"e\", model.getElementAt(4));\n\t\t\t\tassertEquals(\"f\", model.getElementAt(5));\n\t\t\t\tassertEquals(\"g\", model.getElementAt(6));\n\t\t\t\tassertEquals(\"h\", model.getElementAt(7));\n\t\t\t\tassertEquals(\"i\", model.getElementAt(8));\n\t\t\t\tassertEquals(\"j\", model.getElementAt(9));\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testGetElementAt2() {\n\t\t\t\tList<String> data = new ArrayList<String>();\n\t\t\t\tdata.add(\"a\");\n\t\t\t\tdata.add(\"b\");\n\t\t\t\tdata.add(\"c\");\n\t\t\t\tdata.add(\"d\");\n\t\t\t\tdata.add(\"e\");\n\t\t\t\tdata.add(\"f\");\n\t\t\t\tdata.add(\"g\");\n\t\t\t\tdata.add(\"h\");\n\t\t\t\tdata.add(\"i\");\n\t\t\t\tdata.add(\"j\");\n\t\t\t\tGenericSortedListModel<String> model = new GenericSortedListModel<String>(new Comparator<String>() {\n\t\t\t\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\t\t\t\t\treturn o2.compareTo(o1);\n\t\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tmodel.setData(data);\n\t\t\t\tassertEquals(\"j\", model.getElementAt(0));\n\t\t\t\tassertEquals(\"i\", model.getElementAt(1));\n\t\t\t\tassertEquals(\"h\", model.getElementAt(2));\n\t\t\t\tassertEquals(\"g\", model.getElementAt(3));\n\t\t\t\tassertEquals(\"f\", model.getElementAt(4));\n\t\t\t\tassertEquals(\"e\", model.getElementAt(5));\n\t\t\t\tassertEquals(\"d\", model.getElementAt(6));\n\t\t\t\tassertEquals(\"c\", model.getElementAt(7));\n\t\t\t\tassertEquals(\"b\", model.getElementAt(8));\n\t\t\t\tassertEquals(\"a\", model.getElementAt(9));\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testGetElementAt3() {\n\t\t\t\tList<String> data = new ArrayList<String>();\n\t\t\t\tdata.add(\"a\");\n\t\t\t\tdata.add(\"b\");\n\t\t\t\tdata.add(\"c\");\n\t\t\t\tdata.add(\"d\");\n\t\t\t\tdata.add(\"e\");\n\t\t\t\tdata.add(\"f\");\n\t\t\t\tdata.add(\"g\");\n\t\t\t\tdata.add(\"h\");\n\t\t\t\tdata.add(\"i\");\n\t\t\t\tdata.add(\"j\");\n\t\t\t\tGenericSortedListModel<String> model = new GenericSortedListModel<String>();\n\t\t\t\tmodel.setData(data);\n\t\t\t\tmodel.add(\"k\");\n\t\t\t\tassertEquals(\"a\", model.getElementAt(0));\n\t\t\t\tassertEquals(\"b\", model.getElementAt(1));\n\t\t\t\tassertEquals(\"c\", model.getElementAt(2));\n\t\t\t\tassertEquals(\"d\", model.getElementAt(3));\n\t\t\t\tassertEquals(\"e\", model.getElementAt(4));\n\t\t\t\tassertEquals(\"f\", model.getElementAt(5));\n\t\t\t\tassertEquals(\"g\", model.getElementAt(6));\n\t\t\t\tassertEquals(\"h\", model.getElementAt(7));\n\t\t\t\tassertEquals(\"i\", model.getElementAt(8));\n\t\t\t\tassertEquals(\"j\", model.getElementAt(9));\n\t\t\t\tassertEquals(\"k\", model.getElementAt(10));\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testGetElementAt4() {\n\t\t\t\tList<String> data = new ArrayList<String>();\n\t\t\t\tdata.add(\"a\");\n\t\t\t\tdata.add(\"b\");\n\t\t\t\tdata.add(\"c\");\n\t\t\t\tdata.add(\"d\");\n\t\t\t\tdata.add(\"e\");\n\t\t\t\tdata.add(\"f\");\n\t\t\t\tdata.add(\"g\");\n\t\t\t\tdata.add(\"h\");\n\t\t\t\tdata.add(\"i\");\n\t\t\t\tdata.add(\"j\");\n\t\t\t\tGenericSortedListModel<String> model = new GenericSortedListModel<String>();\n\t\t\t\tmodel.setData(data);\n\t\t\t\tmodel.add(\"a\");\n\t\t\t\tassertEquals(\"a\", model.getElementAt(0));\n\t\t\t\tassertEquals(\"b\", model.getElementAt(1));\n\t\t\t\tassertEquals(\"c\", model.getElementAt(2));\n\t\t\t\tassertEquals(\"d\", model.getElementAt(3));\n\t\t\t\tassertEquals(\"e\", model.getElementAt(4));\n\t\t\t\tassertEquals(\"f\", model.getElementAt(5));\n\t\t\t\tassertEquals(\"g\", model.getElementAt(6));\n\t\t\t\tassertEquals(\"h\", model.getElementAt(7));\n\t\t\t\tassertEquals(\"i\", model.getElementAt(8));\n\t\t\t\tassertEquals(\"j\", model.getElementAt(9));\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testGetElementAt5() {\n\t\t\t\tList<String> data = new ArrayList<String>();\n\t\t\t\tdata.add(\"a\");\n\t\t\t\tdata.add(\"b\");\n\t\t\t\tdata.add(\"c\");\n\t\t\t\tdata.add(\"d\");\n\t\t\t\tdata.add(\"e\");\n\t\t\t\tdata.add(\"f\");\n\t\t\t\tdata.add(\"g\");\n\t\t\t\tdata.add(\"h\");\n\t\t\t\tdata.add(\"i\");\n\t\t\t\tdata.add(\"j\");\n\t\t\t\tGenericSortedListModel<String> model = new GenericSortedListModel<String>();\n\t\t\t\tmodel.setData(data);\n\t\t\t\tmodel.remove(\"a\");\n\t\t\t\tassertEquals(\"b\", model.getElementAt(0));\n\t\t\t\tassertEquals(\"c\", model.getElementAt(1));\n\t\t\t\tassertEquals(\"d\", model.getElementAt(2));\n\t\t\t\tassertEquals(\"e\", model.getElementAt(3));\n\t\t\t\tassertEquals(\"f\", model.getElementAt(4));\n\t\t\t\tassertEquals(\"g\", model.getElementAt(5));\n\t\t\t\tassertEquals(\"h\", model.getElementAt(6));\n\t\t\t\tassertEquals(\"i\", model.getElementAt(7));\n\t\t\t\tassertEquals(\"j\", model.getElementAt(8));\n\t\t}\n\t\t\n\t\t@Test\n\t\tpublic void testGet",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 1117,
        "completion_tokens": 2000,
        "total_tokens": 3117
    },
    "time_taken": 55.92951059341431,
    "prompt_id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/preferences/GenericSortedListModel.java",
    "original_code": "// GenericSortedListModel.java\n/*\r\n * Lilith - a log event viewer.\r\n * Copyright (C) 2007-2009 Joern Huxhorn\r\n * \r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n * \r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n * \r\n * You should have received a copy of the GNU General Public License\r\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.huxhorn.lilith.swing.preferences;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.List;\r\nimport javax.swing.*;\r\n\r\npublic class GenericSortedListModel<T extends Comparable> extends AbstractListModel {\r\n\r\n    private final List<T> data;\r\n\r\n    private final Comparator<T> comparator;\r\n\r\n    public GenericSortedListModel() {\r\n        this(null);\r\n    }\r\n\r\n    public GenericSortedListModel(Comparator<T> comparator) {\r\n        this.data = new ArrayList<T>();\r\n        this.comparator = comparator;\r\n    }\r\n\r\n    public void setData(List<T> data) {\r\n        if (!this.data.equals(data)) {\r\n            int size = this.data.size();\r\n            if (size > 0) {\r\n                this.data.clear();\r\n                fireIntervalRemoved(this, 0, size - 1);\r\n            }\r\n            size = data.size();\r\n            if (size > 0) {\r\n                this.data.addAll(data);\r\n                if (comparator != null) {\r\n                    Collections.sort(this.data, comparator);\r\n                } else {\r\n                    Collections.sort(this.data);\r\n                }\r\n                fireIntervalAdded(this, 0, size - 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    public List<T> getData() {\r\n        return new ArrayList<T>(data);\r\n    }\r\n\r\n    public void add(T element) {\r\n        if (!data.contains(element)) {\r\n            data.add(element);\r\n            if (comparator != null) {\r\n                Collections.sort(this.data, comparator);\r\n            } else {\r\n                Collections.sort(this.data);\r\n            }\r\n            int size = data.size();\r\n            fireContentsChanged(this, 0, size - 1);\r\n        }\r\n    }\r\n\r\n    public void remove(T element) {\r\n        int index = data.indexOf(element);\r\n        if (index >= 0) {\r\n            data.remove(index);\r\n            fireIntervalRemoved(this, index, index);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the length of the list.\r\n     *\r\n     * @return the length of the list\r\n     */\r\n    public int getSize() {\r\n        return data.size();\r\n    }\r\n\r\n    /**\r\n     * Returns the value at the specified index.\r\n     *\r\n     * @param index the requested index\r\n     * @return the value at <code>index</code>\r\n     */\r\n    public T getElementAt(int index) {\r\n        return data.get(index);\r\n    }\r\n}\r\n",
    "test_prompt": "// GenericSortedListModelTest.java\npackage de.huxhorn.lilith.swing.preferences;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport javax.swing.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GenericSortedListModel}.\n* It contains ten unit test cases for the {@link GenericSortedListModel#getElementAt(int)} method.\n*/\nclass GenericSortedListModelTest {"
},
{
    "id": "cmpl-6wSQ8OE97WOOoZvQ5SRID8CZkxHqc",
    "object": "text_completion",
    "created": 1679390292,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t@Test\n\tvoid testIsColumnVisible_0() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tTableColumn tableColumn = new TableColumn();\n\t\tboolean result = persistentTableColumnModel.isColumnVisible(tableColumn);\n\t\tassertFalse(result);\n\t}\n\t\n\t@Test\n\tvoid testIsColumnVisible_1() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tTableColumn tableColumn = new TableColumn();\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tboolean result = persistentTableColumnModel.isColumnVisible(tableColumn);\n\t\tassertTrue(result);\n\t}\n\t\n\t@Test\n\tvoid testIsColumnVisible_2() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tTableColumn tableColumn = new TableColumn();\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tpersistentTableColumnModel.removeColumn(tableColumn);\n\t\tboolean result = persistentTableColumnModel.isColumnVisible(tableColumn);\n\t\tassertFalse(result);\n\t}\n\t\n\t@Test\n\tvoid testIsColumnVisible_3() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tTableColumn tableColumn = new TableColumn();\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tpersistentTableColumnModel.removeColumn(tableColumn);\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tboolean result = persistentTableColumnModel.isColumnVisible(tableColumn);\n\t\tassertTrue(result);\n\t}\n\t\n\t@Test\n\tvoid testIsColumnVisible_4() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tTableColumn tableColumn = new TableColumn();\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tpersistentTableColumnModel.removeColumn(tableColumn);\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tpersistentTableColumnModel.removeColumn(tableColumn);\n\t\tboolean result = persistentTableColumnModel.isColumnVisible(tableColumn);\n\t\tassertFalse(result);\n\t}\n\t\n\t@Test\n\tvoid testIsColumnVisible_5() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tTableColumn tableColumn = new TableColumn();\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tpersistentTableColumnModel.removeColumn(tableColumn);\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tpersistentTableColumnModel.removeColumn(tableColumn);\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tboolean result = persistentTableColumnModel.isColumnVisible(tableColumn);\n\t\tassertTrue(result);\n\t}\n\t\n\t@Test\n\tvoid testIsColumnVisible_6() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tTableColumn tableColumn = new TableColumn();\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tpersistentTableColumnModel.removeColumn(tableColumn);\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tpersistentTableColumnModel.removeColumn(tableColumn);\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tpersistentTableColumnModel.removeColumn(tableColumn);\n\t\tboolean result = persistentTableColumnModel.isColumnVisible(tableColumn);\n\t\tassertFalse(result);\n\t}\n\t\n\t@Test\n\tvoid testIsColumnVisible_7() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tTableColumn tableColumn = new TableColumn();\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tpersistentTableColumnModel.removeColumn(tableColumn);\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tpersistentTableColumnModel.removeColumn(tableColumn);\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tpersistentTableColumnModel.removeColumn(tableColumn);\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tboolean result = persistentTableColumnModel.isColumnVisible(tableColumn);\n\t\tassertTrue(result);\n\t}\n\t\n\t@Test\n\tvoid testIsColumnVisible_8() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tTableColumn tableColumn = new TableColumn();\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tpersistentTableColumnModel.removeColumn(tableColumn);\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tpersistentTableColumnModel.removeColumn(tableColumn);\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tpersistentTableColumnModel.removeColumn(tableColumn);\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tpersistentTableColumnModel.removeColumn(tableColumn);\n\t\tboolean result = persistentTableColumnModel.isColumnVisible(tableColumn);\n\t\tassertFalse(result);\n\t}\n\t\n\t@Test\n\tvoid testIsColumnVisible_9() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tTableColumn tableColumn = new TableColumn();\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tpersistentTableColumnModel.removeColumn(tableColumn);\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tpersistentTableColumnModel.removeColumn(tableColumn);\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tpersistentTableColumnModel.removeColumn(tableColumn);\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tpersistentTableColumnModel.removeColumn(tableColumn);\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\n\t\tboolean result = persistentTableColumnModel.isColumnVisible(tableColumn);\n\t\tassertTrue(result);\n\t}\n\t\n}</code>\n\n\n\nI have also tried to use the following code to generate the test cases:\n\n\n<code>// PersistentTableColumnModel_0Test.java\r\npackage de.huxhorn.lilith.swing.table.model;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport javax.swing.table.DefaultTableColumnModel;\r\nimport javax.swing.table.TableColumn;\r\nimport org.junit.jupiter.api.Test;\r\nimport static org.junit.jupiter.api.Assertions.*;\r\n\r\n/**\r\n* Test class of {@link PersistentTableColumnModel}.\r\n* It contains ten unit test cases for the {@link PersistentTableColumnModel#isColumnVisible(TableColumn)} method.\r\n*/\r\nclass PersistentTableColumnModel_0Test {\r\n\t\t\r\n\t@Test\r\n\tvoid testIsColumnVisible_0() {\r\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\r\n\t\tTableColumn tableColumn = new TableColumn();\r\n\t\tboolean result = persistentTableColumnModel.isColumnVisible(tableColumn);\r\n\t\tassertFalse(result);\r\n\t}\r\n\t\r\n\t@Test\r\n\tvoid testIsColumnVisible_1() {\r\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\r\n\t\tTableColumn tableColumn = new TableColumn();\r\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\r\n\t\tboolean result = persistentTableColumnModel.isColumnVisible(tableColumn);\r\n\t\tassertTrue(result);\r\n\t}\r\n\t\r\n\t@Test\r\n\tvoid testIsColumnVisible_2() {\r\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\r\n\t\tTableColumn tableColumn = new TableColumn();\r\n\t\tpersistentTableColumnModel.addColumn(tableColumn);\r\n\t\tpersistentTableColumnModel.removeColumn(tableColumn);\r\n\t\tboolean",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 2987,
        "completion_tokens": 2000,
        "total_tokens": 4987
    },
    "time_taken": 59.07998538017273,
    "prompt_id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_0Test.java",
    "original_code": "// PersistentTableColumnModel.java\npackage de.huxhorn.lilith.swing.table.model;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport javax.swing.table.DefaultTableColumnModel;\r\nimport javax.swing.table.TableColumn;\r\n\r\n/**\r\n * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.\r\n */\r\npublic class PersistentTableColumnModel extends DefaultTableColumnModel {\r\n\r\n    protected List<TableColumn> allTableColumns = new ArrayList<TableColumn>();\r\n\r\n    /**\r\n     * Creates an extended table column model.\r\n     */\r\n    public PersistentTableColumnModel() {\r\n        allTableColumns = new ArrayList<TableColumn>();\r\n        initColumns();\r\n    }\r\n\r\n    /**\r\n     * Should be implemented by subclasses if needed.\r\n     */\r\n    protected void initColumns() {\r\n    }\r\n\r\n    /**\r\n     * Sets the visibility of the specified TableColumn.\r\n     * The call is ignored if the TableColumn is not found in this column model\r\n     * or its visibility status did not change.\r\n     * <p/>\r\n     *\r\n     * @param column  the column to show/hide\r\n     * @param visible its new visibility status\r\n     */\r\n    // listeners will receive columnAdded()/columnRemoved() event\r\n    public void setColumnVisible(TableColumn column, boolean visible) {\r\n        if (!visible) {\r\n            super.removeColumn(column);\r\n        } else {\r\n            // find the visible index of the column:\r\n            // iterate through both collections of visible and all columns, counting\r\n            // visible columns up to the one that's about to be shown again\r\n            int noVisibleColumns = tableColumns.size();\r\n            int noInvisibleColumns = allTableColumns.size();\r\n            int visibleIndex = 0;\r\n            for (int invisibleIndex = 0; invisibleIndex < noInvisibleColumns; ++invisibleIndex) {\r\n                TableColumn visibleColumn = (visibleIndex < noVisibleColumns ? tableColumns.get(visibleIndex) : null);\r\n                TableColumn testColumn = allTableColumns.get(invisibleIndex);\r\n                if (testColumn == column) {\r\n                    if (visibleColumn != column) {\r\n                        super.addColumn(column);\r\n                        super.moveColumn(tableColumns.size() - 1, visibleIndex);\r\n                    }\r\n                    // ####################\r\n                    return;\r\n                }\r\n                if (testColumn == visibleColumn) {\r\n                    ++visibleIndex;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Makes all columns in this model visible\r\n     */\r\n    public void setAllColumnsVisible() {\r\n        int noColumns = allTableColumns.size();\r\n        for (int columnIndex = 0; columnIndex < noColumns; ++columnIndex) {\r\n            TableColumn visibleColumn = (columnIndex < tableColumns.size() ? tableColumns.get(columnIndex) : null);\r\n            TableColumn invisibleColumn = allTableColumns.get(columnIndex);\r\n            if (visibleColumn != invisibleColumn) {\r\n                super.addColumn(invisibleColumn);\r\n                super.moveColumn(tableColumns.size() - 1, columnIndex);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks wether the specified column is currently visible.\r\n     *\r\n     * @param aColumn column to check\r\n     * @return visibility of specified column (false if there is no such column at all. [It's not visible, right?])\r\n     */\r\n    public boolean isColumnVisible(TableColumn aColumn) {\r\n        return (tableColumns.indexOf(aColumn) >= 0);\r\n    }\r\n\r\n    /**\r\n     * Append <code>column</code> to the right of exisiting columns.\r\n     * Posts <code>columnAdded</code> event.\r\n     *\r\n     * @param column The column to be added\r\n     * @throws IllegalArgumentException if <code>column</code> is <code>null</code>\r\n     * @see #removeColumn\r\n     */\r\n    @Override\r\n    public void addColumn(TableColumn column) {\r\n        allTableColumns.add(column);\r\n        super.addColumn(column);\r\n    }\r\n\r\n    /**\r\n     * Removes <code>column</code> from this column model.\r\n     * Posts <code>columnRemoved</code> event.\r\n     * Will do nothing if the column is not in this model.\r\n     *\r\n     * @param column the column to be added\r\n     * @see #addColumn\r\n     */\r\n    @Override\r\n    public void removeColumn(TableColumn column) {\r\n        int allColumnsIndex = allTableColumns.indexOf(column);\r\n        if (allColumnsIndex != -1) {\r\n            allTableColumns.remove(allColumnsIndex);\r\n        }\r\n        super.removeColumn(column);\r\n    }\r\n\r\n    /**\r\n     * Moves the column from <code>oldIndex</code> to <code>newIndex</code>.\r\n     * Posts  <code>columnMoved</code> event.\r\n     * Will not move any columns if <code>oldIndex</code> equals <code>newIndex</code>.\r\n     *\r\n     * @throws IllegalArgumentException if either <code>oldIndex</code> or\r\n     *                                  <code>newIndex</code>\r\n     *                                  are not in [0, getColumnCount() - 1]\r\n     * @param\toldIndex\t\t\tindex of column to be moved\r\n     * @param\tnewIndex\t\t\tnew index of the column\r\n     */\r\n    @Override\r\n    public void moveColumn(int oldIndex, int newIndex) {\r\n        if ((oldIndex < 0) || (oldIndex >= getColumnCount()) || (newIndex < 0) || (newIndex >= getColumnCount())) {\r\n            throw new IllegalArgumentException(\"moveColumn() - Index out of range\");\r\n        }\r\n        TableColumn fromColumn = tableColumns.get(oldIndex);\r\n        TableColumn toColumn = tableColumns.get(newIndex);\r\n        int allColumnsOldIndex = allTableColumns.indexOf(fromColumn);\r\n        int allColumnsNewIndex = allTableColumns.indexOf(toColumn);\r\n        if (oldIndex != newIndex) {\r\n            allTableColumns.remove(allColumnsOldIndex);\r\n            allTableColumns.add(allColumnsNewIndex, fromColumn);\r\n        }\r\n        super.moveColumn(oldIndex, newIndex);\r\n    }\r\n\r\n    /**\r\n     * Returns the total number of columns in this model.\r\n     *\r\n     * @param onlyVisible if set only visible columns will be counted\r\n     * @return the number of columns in the <code>tableColumns</code> array\r\n     * @see\t#getColumns\r\n     */\r\n    public int getColumnCount(boolean onlyVisible) {\r\n        return (onlyVisible ? tableColumns.size() : allTableColumns.size());\r\n    }\r\n\r\n    /**\r\n     * Returns an <code>Enumeration</code> of all the columns in the model.\r\n     *\r\n     * @param onlyVisible if set all invisible columns will be missing from the enumeration.\r\n     * @return an <code>Enumeration</code> of the columns in the model\r\n     */\r\n    public Iterator<TableColumn> getColumns(boolean onlyVisible) {\r\n        return (onlyVisible ? tableColumns.iterator() : allTableColumns.iterator());\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first column whose identifier equals <code>identifier</code>.\r\n     * Position is the the index in all visible columns if <code>onlyVisible</code> is true or\r\n     * else the index in all columns.\r\n     *\r\n     * @return the index of the first column whose identifier\r\n     *         equals <code>identifier</code>\r\n     * @throws IllegalArgumentException if <code>identifier</code>\r\n     *                                  is <code>null</code>, or if no\r\n     *                                  <code>TableColumn</code> has this\r\n     *                                  <code>identifier</code>\r\n     * @param\tidentifier the identifier object to search for\r\n     * @param\tonlyVisible if set searches only visible columns\r\n     * @see\t\t#getColumn\r\n     */\r\n    public int getColumnIndex(Object identifier, boolean onlyVisible) {\r\n        if (identifier == null) {\r\n            throw new IllegalArgumentException(\"Identifier is null\");\r\n        }\r\n        List<TableColumn> columns = (onlyVisible ? tableColumns : allTableColumns);\r\n        int noColumns = columns.size();\r\n        TableColumn column;\r\n        for (int columnIndex = 0; columnIndex < noColumns; ++columnIndex) {\r\n            column = columns.get(columnIndex);\r\n            if (identifier.equals(column.getIdentifier())) {\r\n                return columnIndex;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"Identifier not found\");\r\n    }\r\n\r\n    public List<TableColumnLayoutInfo> getColumnLayoutInfos() {\r\n        final List<TableColumnLayoutInfo> tableColumnLayoutInfos = new ArrayList<TableColumnLayoutInfo>(allTableColumns.size());\r\n        for (TableColumn current : allTableColumns) {\r\n            boolean visible = tableColumns.contains(current);\r\n            TableColumnLayoutInfo tableColumnLayoutInfo = new TableColumnLayoutInfo(current.getIdentifier().toString(), current.getWidth(), visible);\r\n            tableColumnLayoutInfos.add(tableColumnLayoutInfo);\r\n        }\r\n        return tableColumnLayoutInfos;\r\n    }\r\n\r\n    public static class TableColumnLayoutInfo implements Serializable {\r\n\r\n        private String columnName;\r\n\r\n        private int width;\r\n\r\n        private boolean visible;\r\n\r\n        public TableColumnLayoutInfo() {\r\n        }\r\n\r\n        public TableColumnLayoutInfo(String columnName, int width, boolean visible) {\r\n            this.columnName = columnName;\r\n            this.width = width;\r\n            this.visible = visible;\r\n        }\r\n\r\n        public int getWidth() {\r\n            return width;\r\n        }\r\n\r\n        public void setWidth(int width) {\r\n            this.width = width;\r\n        }\r\n\r\n        public String getColumnName() {\r\n            return columnName;\r\n        }\r\n\r\n        public void setColumnName(String columnName) {\r\n            this.columnName = columnName;\r\n        }\r\n\r\n        public boolean isVisible() {\r\n            return visible;\r\n        }\r\n\r\n        public void setVisible(boolean visible) {\r\n            this.visible = visible;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"TableColumnLayoutInfo[columnName=\" + columnName + \", width=\" + width + \", visible=\" + visible + \"]\";\r\n        }\r\n    }\r\n}\r\n",
    "test_prompt": "// PersistentTableColumnModel_0Test.java\npackage de.huxhorn.lilith.swing.table.model;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.swing.table.DefaultTableColumnModel;\nimport javax.swing.table.TableColumn;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PersistentTableColumnModel}.\n* It contains ten unit test cases for the {@link PersistentTableColumnModel#isColumnVisible(TableColumn)} method.\n*/\nclass PersistentTableColumnModel_0Test {"
},
{
    "id": "cmpl-6wSRB3YP4Ovwl91CANKC7lu1VFEwr",
    "object": "text_completion",
    "created": 1679390357,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t/**\n\t* Test case for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.\n\t* The test case tests the {@link PersistentTableColumnModel#getColumnCount(boolean)} method with the following parameters:\n\t* <ul>\n\t* <li>onlyVisible: true</li>\n\t* </ul>\n\t* The test case expects the following result:\n\t* <ul>\n\t* <li>The method returns the number of visible columns.</li>\n\t* </ul>\n\t*/\n\t@Test\n\tpublic void testGetColumnCount_1() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tint result = persistentTableColumnModel.getColumnCount(true);\n\t\tassertEquals(0, result);\n\t}\n\t\n\t/**\n\t* Test case for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.\n\t* The test case tests the {@link PersistentTableColumnModel#getColumnCount(boolean)} method with the following parameters:\n\t* <ul>\n\t* <li>onlyVisible: false</li>\n\t* </ul>\n\t* The test case expects the following result:\n\t* <ul>\n\t* <li>The method returns the number of all columns.</li>\n\t* </ul>\n\t*/\n\t@Test\n\tpublic void testGetColumnCount_2() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tint result = persistentTableColumnModel.getColumnCount(false);\n\t\tassertEquals(10, result);\n\t}\n\t\n\t/**\n\t* Test case for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.\n\t* The test case tests the {@link PersistentTableColumnModel#getColumnCount(boolean)} method with the following parameters:\n\t* <ul>\n\t* <li>onlyVisible: true</li>\n\t* </ul>\n\t* The test case expects the following result:\n\t* <ul>\n\t* <li>The method returns the number of visible columns.</li>\n\t* </ul>\n\t*/\n\t@Test\n\tpublic void testGetColumnCount_3() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 2986,
        "completion_tokens": 2000,
        "total_tokens": 4986
    },
    "time_taken": 57.78695631027222,
    "prompt_id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_1Test.java",
    "original_code": "// PersistentTableColumnModel.java\npackage de.huxhorn.lilith.swing.table.model;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport javax.swing.table.DefaultTableColumnModel;\r\nimport javax.swing.table.TableColumn;\r\n\r\n/**\r\n * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.\r\n */\r\npublic class PersistentTableColumnModel extends DefaultTableColumnModel {\r\n\r\n    protected List<TableColumn> allTableColumns = new ArrayList<TableColumn>();\r\n\r\n    /**\r\n     * Creates an extended table column model.\r\n     */\r\n    public PersistentTableColumnModel() {\r\n        allTableColumns = new ArrayList<TableColumn>();\r\n        initColumns();\r\n    }\r\n\r\n    /**\r\n     * Should be implemented by subclasses if needed.\r\n     */\r\n    protected void initColumns() {\r\n    }\r\n\r\n    /**\r\n     * Sets the visibility of the specified TableColumn.\r\n     * The call is ignored if the TableColumn is not found in this column model\r\n     * or its visibility status did not change.\r\n     * <p/>\r\n     *\r\n     * @param column  the column to show/hide\r\n     * @param visible its new visibility status\r\n     */\r\n    // listeners will receive columnAdded()/columnRemoved() event\r\n    public void setColumnVisible(TableColumn column, boolean visible) {\r\n        if (!visible) {\r\n            super.removeColumn(column);\r\n        } else {\r\n            // find the visible index of the column:\r\n            // iterate through both collections of visible and all columns, counting\r\n            // visible columns up to the one that's about to be shown again\r\n            int noVisibleColumns = tableColumns.size();\r\n            int noInvisibleColumns = allTableColumns.size();\r\n            int visibleIndex = 0;\r\n            for (int invisibleIndex = 0; invisibleIndex < noInvisibleColumns; ++invisibleIndex) {\r\n                TableColumn visibleColumn = (visibleIndex < noVisibleColumns ? tableColumns.get(visibleIndex) : null);\r\n                TableColumn testColumn = allTableColumns.get(invisibleIndex);\r\n                if (testColumn == column) {\r\n                    if (visibleColumn != column) {\r\n                        super.addColumn(column);\r\n                        super.moveColumn(tableColumns.size() - 1, visibleIndex);\r\n                    }\r\n                    // ####################\r\n                    return;\r\n                }\r\n                if (testColumn == visibleColumn) {\r\n                    ++visibleIndex;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Makes all columns in this model visible\r\n     */\r\n    public void setAllColumnsVisible() {\r\n        int noColumns = allTableColumns.size();\r\n        for (int columnIndex = 0; columnIndex < noColumns; ++columnIndex) {\r\n            TableColumn visibleColumn = (columnIndex < tableColumns.size() ? tableColumns.get(columnIndex) : null);\r\n            TableColumn invisibleColumn = allTableColumns.get(columnIndex);\r\n            if (visibleColumn != invisibleColumn) {\r\n                super.addColumn(invisibleColumn);\r\n                super.moveColumn(tableColumns.size() - 1, columnIndex);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks wether the specified column is currently visible.\r\n     *\r\n     * @param aColumn column to check\r\n     * @return visibility of specified column (false if there is no such column at all. [It's not visible, right?])\r\n     */\r\n    public boolean isColumnVisible(TableColumn aColumn) {\r\n        return (tableColumns.indexOf(aColumn) >= 0);\r\n    }\r\n\r\n    /**\r\n     * Append <code>column</code> to the right of exisiting columns.\r\n     * Posts <code>columnAdded</code> event.\r\n     *\r\n     * @param column The column to be added\r\n     * @throws IllegalArgumentException if <code>column</code> is <code>null</code>\r\n     * @see #removeColumn\r\n     */\r\n    @Override\r\n    public void addColumn(TableColumn column) {\r\n        allTableColumns.add(column);\r\n        super.addColumn(column);\r\n    }\r\n\r\n    /**\r\n     * Removes <code>column</code> from this column model.\r\n     * Posts <code>columnRemoved</code> event.\r\n     * Will do nothing if the column is not in this model.\r\n     *\r\n     * @param column the column to be added\r\n     * @see #addColumn\r\n     */\r\n    @Override\r\n    public void removeColumn(TableColumn column) {\r\n        int allColumnsIndex = allTableColumns.indexOf(column);\r\n        if (allColumnsIndex != -1) {\r\n            allTableColumns.remove(allColumnsIndex);\r\n        }\r\n        super.removeColumn(column);\r\n    }\r\n\r\n    /**\r\n     * Moves the column from <code>oldIndex</code> to <code>newIndex</code>.\r\n     * Posts  <code>columnMoved</code> event.\r\n     * Will not move any columns if <code>oldIndex</code> equals <code>newIndex</code>.\r\n     *\r\n     * @throws IllegalArgumentException if either <code>oldIndex</code> or\r\n     *                                  <code>newIndex</code>\r\n     *                                  are not in [0, getColumnCount() - 1]\r\n     * @param\toldIndex\t\t\tindex of column to be moved\r\n     * @param\tnewIndex\t\t\tnew index of the column\r\n     */\r\n    @Override\r\n    public void moveColumn(int oldIndex, int newIndex) {\r\n        if ((oldIndex < 0) || (oldIndex >= getColumnCount()) || (newIndex < 0) || (newIndex >= getColumnCount())) {\r\n            throw new IllegalArgumentException(\"moveColumn() - Index out of range\");\r\n        }\r\n        TableColumn fromColumn = tableColumns.get(oldIndex);\r\n        TableColumn toColumn = tableColumns.get(newIndex);\r\n        int allColumnsOldIndex = allTableColumns.indexOf(fromColumn);\r\n        int allColumnsNewIndex = allTableColumns.indexOf(toColumn);\r\n        if (oldIndex != newIndex) {\r\n            allTableColumns.remove(allColumnsOldIndex);\r\n            allTableColumns.add(allColumnsNewIndex, fromColumn);\r\n        }\r\n        super.moveColumn(oldIndex, newIndex);\r\n    }\r\n\r\n    /**\r\n     * Returns the total number of columns in this model.\r\n     *\r\n     * @param onlyVisible if set only visible columns will be counted\r\n     * @return the number of columns in the <code>tableColumns</code> array\r\n     * @see\t#getColumns\r\n     */\r\n    public int getColumnCount(boolean onlyVisible) {\r\n        return (onlyVisible ? tableColumns.size() : allTableColumns.size());\r\n    }\r\n\r\n    /**\r\n     * Returns an <code>Enumeration</code> of all the columns in the model.\r\n     *\r\n     * @param onlyVisible if set all invisible columns will be missing from the enumeration.\r\n     * @return an <code>Enumeration</code> of the columns in the model\r\n     */\r\n    public Iterator<TableColumn> getColumns(boolean onlyVisible) {\r\n        return (onlyVisible ? tableColumns.iterator() : allTableColumns.iterator());\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first column whose identifier equals <code>identifier</code>.\r\n     * Position is the the index in all visible columns if <code>onlyVisible</code> is true or\r\n     * else the index in all columns.\r\n     *\r\n     * @return the index of the first column whose identifier\r\n     *         equals <code>identifier</code>\r\n     * @throws IllegalArgumentException if <code>identifier</code>\r\n     *                                  is <code>null</code>, or if no\r\n     *                                  <code>TableColumn</code> has this\r\n     *                                  <code>identifier</code>\r\n     * @param\tidentifier the identifier object to search for\r\n     * @param\tonlyVisible if set searches only visible columns\r\n     * @see\t\t#getColumn\r\n     */\r\n    public int getColumnIndex(Object identifier, boolean onlyVisible) {\r\n        if (identifier == null) {\r\n            throw new IllegalArgumentException(\"Identifier is null\");\r\n        }\r\n        List<TableColumn> columns = (onlyVisible ? tableColumns : allTableColumns);\r\n        int noColumns = columns.size();\r\n        TableColumn column;\r\n        for (int columnIndex = 0; columnIndex < noColumns; ++columnIndex) {\r\n            column = columns.get(columnIndex);\r\n            if (identifier.equals(column.getIdentifier())) {\r\n                return columnIndex;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"Identifier not found\");\r\n    }\r\n\r\n    public List<TableColumnLayoutInfo> getColumnLayoutInfos() {\r\n        final List<TableColumnLayoutInfo> tableColumnLayoutInfos = new ArrayList<TableColumnLayoutInfo>(allTableColumns.size());\r\n        for (TableColumn current : allTableColumns) {\r\n            boolean visible = tableColumns.contains(current);\r\n            TableColumnLayoutInfo tableColumnLayoutInfo = new TableColumnLayoutInfo(current.getIdentifier().toString(), current.getWidth(), visible);\r\n            tableColumnLayoutInfos.add(tableColumnLayoutInfo);\r\n        }\r\n        return tableColumnLayoutInfos;\r\n    }\r\n\r\n    public static class TableColumnLayoutInfo implements Serializable {\r\n\r\n        private String columnName;\r\n\r\n        private int width;\r\n\r\n        private boolean visible;\r\n\r\n        public TableColumnLayoutInfo() {\r\n        }\r\n\r\n        public TableColumnLayoutInfo(String columnName, int width, boolean visible) {\r\n            this.columnName = columnName;\r\n            this.width = width;\r\n            this.visible = visible;\r\n        }\r\n\r\n        public int getWidth() {\r\n            return width;\r\n        }\r\n\r\n        public void setWidth(int width) {\r\n            this.width = width;\r\n        }\r\n\r\n        public String getColumnName() {\r\n            return columnName;\r\n        }\r\n\r\n        public void setColumnName(String columnName) {\r\n            this.columnName = columnName;\r\n        }\r\n\r\n        public boolean isVisible() {\r\n            return visible;\r\n        }\r\n\r\n        public void setVisible(boolean visible) {\r\n            this.visible = visible;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"TableColumnLayoutInfo[columnName=\" + columnName + \", width=\" + width + \", visible=\" + visible + \"]\";\r\n        }\r\n    }\r\n}\r\n",
    "test_prompt": "// PersistentTableColumnModel_1Test.java\npackage de.huxhorn.lilith.swing.table.model;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.swing.table.DefaultTableColumnModel;\nimport javax.swing.table.TableColumn;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PersistentTableColumnModel}.\n* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumnCount(boolean)} method.\n*/\nclass PersistentTableColumnModel_1Test {"
},
{
    "id": "cmpl-6wSSEDLS2xG17Ln0FwpHLzQbvpumi",
    "object": "text_completion",
    "created": 1679390422,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t/**\n\t* Test case for the method {@link PersistentTableColumnModel#getColumns(boolean)}.\n\t* It tests if the method returns an empty list if no columns are added.\n\t*/\n\t@Test\n\tvoid testGetColumns_1() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tIterator<TableColumn> columns = persistentTableColumnModel.getColumns(true);\n\t\tassertFalse(columns.hasNext());\n\t}\n\t\n\t/**\n\t* Test case for the method {@link PersistentTableColumnModel#getColumns(boolean)}.\n\t* It tests if the method returns an empty list if no columns are added.\n\t*/\n\t@Test\n\tvoid testGetColumns_2() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tIterator<TableColumn> columns = persistentTableColumnModel.getColumns(false);\n\t\tassertFalse(columns.hasNext());\n\t}\n\t\n\t/**\n\t* Test case for the method {@link PersistentTableColumnModel#getColumns(boolean)}.\n\t* It tests if the method returns an empty list if no columns are added.\n\t*/\n\t@Test\n\tvoid testGetColumns_3() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tIterator<TableColumn> columns = persistentTableColumnModel.getColumns(true);\n\t\tassertTrue(columns.hasNext());\n\t}\n\t\n\t/**\n\t* Test case for the method {@link PersistentTableColumnModel#getColumns(boolean)}.\n\t* It tests if the method returns an empty list if no columns are added.\n\t*/\n\t@Test\n\tvoid testGetColumns_4() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tIterator<TableColumn> columns = persistentTableColumnModel.getColumns(false);\n\t\tassertTrue(columns.hasNext());\n\t}\n\t\n\t/**\n\t* Test case for the method {@link PersistentTableColumnModel#getColumns(boolean)}.\n\t* It tests if the method returns an empty list if no columns are added.\n\t*/\n\t@Test\n\tvoid testGetColumns_5() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tIterator<TableColumn> columns = persistentTableColumnModel.getColumns(true);\n\t\tassertFalse(columns.hasNext());\n\t}\n\t\n\t/**\n\t* Test case for the method {@link PersistentTableColumnModel#getColumns(boolean)}.\n\t* It tests if the method returns an empty list if no columns are added.\n\t*/\n\t@Test\n\tvoid testGetColumns_6() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tIterator<TableColumn> columns = persistentTableColumnModel.getColumns(false);\n\t\tassertTrue(columns.hasNext());\n\t}\n\t\n\t/**\n\t* Test case for the method {@link PersistentTableColumnModel#getColumns(boolean)}.\n\t* It tests if the method returns an empty list if no columns are added.\n\t*/\n\t@Test\n\tvoid testGetColumns_7() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tIterator<TableColumn> columns = persistentTableColumnModel.getColumns(true);\n\t\tassertTrue(columns.hasNext());\n\t}\n\t\n\t/**\n\t* Test case for the method {@link PersistentTableColumnModel#getColumns(boolean)}.\n\t* It tests if the method returns an empty list if no columns are added.\n\t*/\n\t@Test\n\tvoid testGetColumns_8() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tIterator<TableColumn> columns = persistentTableColumnModel.getColumns(false);\n\t\tassertTrue(columns.hasNext());\n\t}\n\t\n\t/**\n\t* Test case for the method {@link PersistentTableColumnModel#getColumns(boolean)}.\n\t* It tests if the method returns an empty list if no columns are added.\n\t*/\n\t@Test\n\tvoid testGetColumns_9() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tIterator<TableColumn> columns = persistentTableColumnModel.getColumns(true);\n\t\tassertFalse(columns.hasNext());\n\t}\n\t\n\t/**\n\t* Test case for the method {@link PersistentTableColumnModel#getColumns(boolean)}.\n\t* It tests if the method returns an empty list if no columns are added.\n\t*/\n\t@Test\n\tvoid testGetColumns_10() {\n\t\tPersistentTableColumnModel persistentTableColumnModel = new PersistentTableColumnModel();\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tpersistentTableColumnModel.addColumn(new TableColumn());\n\t\tpersistentTableColumnModel.removeColumn(persistentTableColumnModel.getColumn(0));\n\t\tIterator<TableColumn> columns = persistentTableColumnModel.getColumns(false);\n\t\tassertTrue(columns.hasNext());\n\t}\n}</code>\n\n\n\nI have a test class for the <code>PersistentTableColumnModel</code> class.\nThe test class contains ten unit test cases for the <code>getColumns(boolean)</code> method.\nThe test class is shown below.\nThe test class contains ten unit test cases for the <code>getColumns(boolean)</code> method.\nThe test class is shown below.\nThe test class contains ten unit test cases for the <code>getColumns(boolean)</code> method.\nThe test class is shown below.\nThe test class contains ten unit test cases for the <code>getColumns(boolean)</code> method.\nThe test class is shown below.\nThe test class contains ten unit test cases for the <code>getColumns(boolean)</code> method.\nThe test class is shown below.\nThe test class contains ten unit test cases for the <code>getColumns(boolean)</code> method.\nThe test class is shown below.\nThe test class contains ten unit test cases for the <code>getColumns(boolean)</code> method.\nThe test class is shown below.\nThe test class contains ten unit test cases for the <code>getColumns(boolean)</code> method.\nThe test class is shown below.\nThe test class contains ten unit test cases for the <code>getColumns(boolean)</code> method.\nThe test class is shown below.\nThe test class contains ten unit test cases for the <code>getColumns(boolean)</code> method.\nThe test class is shown below.\nThe test class contains ten unit test cases for the <code>getColumns(boolean)</code> method.\nThe test class is shown below.\nThe test class contains ten unit test cases for the <code>get",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 2986,
        "completion_tokens": 2000,
        "total_tokens": 4986
    },
    "time_taken": 48.66766834259033,
    "prompt_id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_2Test.java",
    "original_code": "// PersistentTableColumnModel.java\npackage de.huxhorn.lilith.swing.table.model;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport javax.swing.table.DefaultTableColumnModel;\r\nimport javax.swing.table.TableColumn;\r\n\r\n/**\r\n * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.\r\n */\r\npublic class PersistentTableColumnModel extends DefaultTableColumnModel {\r\n\r\n    protected List<TableColumn> allTableColumns = new ArrayList<TableColumn>();\r\n\r\n    /**\r\n     * Creates an extended table column model.\r\n     */\r\n    public PersistentTableColumnModel() {\r\n        allTableColumns = new ArrayList<TableColumn>();\r\n        initColumns();\r\n    }\r\n\r\n    /**\r\n     * Should be implemented by subclasses if needed.\r\n     */\r\n    protected void initColumns() {\r\n    }\r\n\r\n    /**\r\n     * Sets the visibility of the specified TableColumn.\r\n     * The call is ignored if the TableColumn is not found in this column model\r\n     * or its visibility status did not change.\r\n     * <p/>\r\n     *\r\n     * @param column  the column to show/hide\r\n     * @param visible its new visibility status\r\n     */\r\n    // listeners will receive columnAdded()/columnRemoved() event\r\n    public void setColumnVisible(TableColumn column, boolean visible) {\r\n        if (!visible) {\r\n            super.removeColumn(column);\r\n        } else {\r\n            // find the visible index of the column:\r\n            // iterate through both collections of visible and all columns, counting\r\n            // visible columns up to the one that's about to be shown again\r\n            int noVisibleColumns = tableColumns.size();\r\n            int noInvisibleColumns = allTableColumns.size();\r\n            int visibleIndex = 0;\r\n            for (int invisibleIndex = 0; invisibleIndex < noInvisibleColumns; ++invisibleIndex) {\r\n                TableColumn visibleColumn = (visibleIndex < noVisibleColumns ? tableColumns.get(visibleIndex) : null);\r\n                TableColumn testColumn = allTableColumns.get(invisibleIndex);\r\n                if (testColumn == column) {\r\n                    if (visibleColumn != column) {\r\n                        super.addColumn(column);\r\n                        super.moveColumn(tableColumns.size() - 1, visibleIndex);\r\n                    }\r\n                    // ####################\r\n                    return;\r\n                }\r\n                if (testColumn == visibleColumn) {\r\n                    ++visibleIndex;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Makes all columns in this model visible\r\n     */\r\n    public void setAllColumnsVisible() {\r\n        int noColumns = allTableColumns.size();\r\n        for (int columnIndex = 0; columnIndex < noColumns; ++columnIndex) {\r\n            TableColumn visibleColumn = (columnIndex < tableColumns.size() ? tableColumns.get(columnIndex) : null);\r\n            TableColumn invisibleColumn = allTableColumns.get(columnIndex);\r\n            if (visibleColumn != invisibleColumn) {\r\n                super.addColumn(invisibleColumn);\r\n                super.moveColumn(tableColumns.size() - 1, columnIndex);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks wether the specified column is currently visible.\r\n     *\r\n     * @param aColumn column to check\r\n     * @return visibility of specified column (false if there is no such column at all. [It's not visible, right?])\r\n     */\r\n    public boolean isColumnVisible(TableColumn aColumn) {\r\n        return (tableColumns.indexOf(aColumn) >= 0);\r\n    }\r\n\r\n    /**\r\n     * Append <code>column</code> to the right of exisiting columns.\r\n     * Posts <code>columnAdded</code> event.\r\n     *\r\n     * @param column The column to be added\r\n     * @throws IllegalArgumentException if <code>column</code> is <code>null</code>\r\n     * @see #removeColumn\r\n     */\r\n    @Override\r\n    public void addColumn(TableColumn column) {\r\n        allTableColumns.add(column);\r\n        super.addColumn(column);\r\n    }\r\n\r\n    /**\r\n     * Removes <code>column</code> from this column model.\r\n     * Posts <code>columnRemoved</code> event.\r\n     * Will do nothing if the column is not in this model.\r\n     *\r\n     * @param column the column to be added\r\n     * @see #addColumn\r\n     */\r\n    @Override\r\n    public void removeColumn(TableColumn column) {\r\n        int allColumnsIndex = allTableColumns.indexOf(column);\r\n        if (allColumnsIndex != -1) {\r\n            allTableColumns.remove(allColumnsIndex);\r\n        }\r\n        super.removeColumn(column);\r\n    }\r\n\r\n    /**\r\n     * Moves the column from <code>oldIndex</code> to <code>newIndex</code>.\r\n     * Posts  <code>columnMoved</code> event.\r\n     * Will not move any columns if <code>oldIndex</code> equals <code>newIndex</code>.\r\n     *\r\n     * @throws IllegalArgumentException if either <code>oldIndex</code> or\r\n     *                                  <code>newIndex</code>\r\n     *                                  are not in [0, getColumnCount() - 1]\r\n     * @param\toldIndex\t\t\tindex of column to be moved\r\n     * @param\tnewIndex\t\t\tnew index of the column\r\n     */\r\n    @Override\r\n    public void moveColumn(int oldIndex, int newIndex) {\r\n        if ((oldIndex < 0) || (oldIndex >= getColumnCount()) || (newIndex < 0) || (newIndex >= getColumnCount())) {\r\n            throw new IllegalArgumentException(\"moveColumn() - Index out of range\");\r\n        }\r\n        TableColumn fromColumn = tableColumns.get(oldIndex);\r\n        TableColumn toColumn = tableColumns.get(newIndex);\r\n        int allColumnsOldIndex = allTableColumns.indexOf(fromColumn);\r\n        int allColumnsNewIndex = allTableColumns.indexOf(toColumn);\r\n        if (oldIndex != newIndex) {\r\n            allTableColumns.remove(allColumnsOldIndex);\r\n            allTableColumns.add(allColumnsNewIndex, fromColumn);\r\n        }\r\n        super.moveColumn(oldIndex, newIndex);\r\n    }\r\n\r\n    /**\r\n     * Returns the total number of columns in this model.\r\n     *\r\n     * @param onlyVisible if set only visible columns will be counted\r\n     * @return the number of columns in the <code>tableColumns</code> array\r\n     * @see\t#getColumns\r\n     */\r\n    public int getColumnCount(boolean onlyVisible) {\r\n        return (onlyVisible ? tableColumns.size() : allTableColumns.size());\r\n    }\r\n\r\n    /**\r\n     * Returns an <code>Enumeration</code> of all the columns in the model.\r\n     *\r\n     * @param onlyVisible if set all invisible columns will be missing from the enumeration.\r\n     * @return an <code>Enumeration</code> of the columns in the model\r\n     */\r\n    public Iterator<TableColumn> getColumns(boolean onlyVisible) {\r\n        return (onlyVisible ? tableColumns.iterator() : allTableColumns.iterator());\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first column whose identifier equals <code>identifier</code>.\r\n     * Position is the the index in all visible columns if <code>onlyVisible</code> is true or\r\n     * else the index in all columns.\r\n     *\r\n     * @return the index of the first column whose identifier\r\n     *         equals <code>identifier</code>\r\n     * @throws IllegalArgumentException if <code>identifier</code>\r\n     *                                  is <code>null</code>, or if no\r\n     *                                  <code>TableColumn</code> has this\r\n     *                                  <code>identifier</code>\r\n     * @param\tidentifier the identifier object to search for\r\n     * @param\tonlyVisible if set searches only visible columns\r\n     * @see\t\t#getColumn\r\n     */\r\n    public int getColumnIndex(Object identifier, boolean onlyVisible) {\r\n        if (identifier == null) {\r\n            throw new IllegalArgumentException(\"Identifier is null\");\r\n        }\r\n        List<TableColumn> columns = (onlyVisible ? tableColumns : allTableColumns);\r\n        int noColumns = columns.size();\r\n        TableColumn column;\r\n        for (int columnIndex = 0; columnIndex < noColumns; ++columnIndex) {\r\n            column = columns.get(columnIndex);\r\n            if (identifier.equals(column.getIdentifier())) {\r\n                return columnIndex;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"Identifier not found\");\r\n    }\r\n\r\n    public List<TableColumnLayoutInfo> getColumnLayoutInfos() {\r\n        final List<TableColumnLayoutInfo> tableColumnLayoutInfos = new ArrayList<TableColumnLayoutInfo>(allTableColumns.size());\r\n        for (TableColumn current : allTableColumns) {\r\n            boolean visible = tableColumns.contains(current);\r\n            TableColumnLayoutInfo tableColumnLayoutInfo = new TableColumnLayoutInfo(current.getIdentifier().toString(), current.getWidth(), visible);\r\n            tableColumnLayoutInfos.add(tableColumnLayoutInfo);\r\n        }\r\n        return tableColumnLayoutInfos;\r\n    }\r\n\r\n    public static class TableColumnLayoutInfo implements Serializable {\r\n\r\n        private String columnName;\r\n\r\n        private int width;\r\n\r\n        private boolean visible;\r\n\r\n        public TableColumnLayoutInfo() {\r\n        }\r\n\r\n        public TableColumnLayoutInfo(String columnName, int width, boolean visible) {\r\n            this.columnName = columnName;\r\n            this.width = width;\r\n            this.visible = visible;\r\n        }\r\n\r\n        public int getWidth() {\r\n            return width;\r\n        }\r\n\r\n        public void setWidth(int width) {\r\n            this.width = width;\r\n        }\r\n\r\n        public String getColumnName() {\r\n            return columnName;\r\n        }\r\n\r\n        public void setColumnName(String columnName) {\r\n            this.columnName = columnName;\r\n        }\r\n\r\n        public boolean isVisible() {\r\n            return visible;\r\n        }\r\n\r\n        public void setVisible(boolean visible) {\r\n            this.visible = visible;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"TableColumnLayoutInfo[columnName=\" + columnName + \", width=\" + width + \", visible=\" + visible + \"]\";\r\n        }\r\n    }\r\n}\r\n",
    "test_prompt": "// PersistentTableColumnModel_2Test.java\npackage de.huxhorn.lilith.swing.table.model;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.swing.table.DefaultTableColumnModel;\nimport javax.swing.table.TableColumn;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PersistentTableColumnModel}.\n* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumns(boolean)} method.\n*/\nclass PersistentTableColumnModel_2Test {"
},
{
    "id": "cmpl-6wSTHEKTqBjMnydQ1m5qG60LlAnzR",
    "object": "text_completion",
    "created": 1679390487,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t/**\n\t* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.\n\t* Tested with a column model with two columns, one visible and one invisible.\n\t* The identifier of the visible column is searched.\n\t* The expected result is 0.\n\t*/\n\t@Test\n\tpublic void testGetColumnIndex_1() {\n\t\tPersistentTableColumnModel columnModel = new PersistentTableColumnModel();\n\t\tTableColumn column1 = new TableColumn(0);\n\t\tcolumn1.setIdentifier(\"Column1\");\n\t\tcolumnModel.addColumn(column1);\n\t\tTableColumn column2 = new TableColumn(1);\n\t\tcolumn2.setIdentifier(\"Column2\");\n\t\tcolumnModel.addColumn(column2);\n\t\tcolumnModel.removeColumn(column2);\n\t\tint result = columnModel.getColumnIndex(\"Column1\", true);\n\t\tassertEquals(0, result);\n\t}\n\t\n\t/**\n\t* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.\n\t* Tested with a column model with two columns, one visible and one invisible.\n\t* The identifier of the invisible column is searched.\n\t* The expected result is 0.\n\t*/\n\t@Test\n\tpublic void testGetColumnIndex_2() {\n\t\tPersistentTableColumnModel columnModel = new PersistentTableColumnModel();\n\t\tTableColumn column1 = new TableColumn(0);\n\t\tcolumn1.setIdentifier(\"Column1\");\n\t\tcolumnModel.addColumn(column1);\n\t\tTableColumn column2 = new TableColumn(1);\n\t\tcolumn2.setIdentifier(\"Column2\");\n\t\tcolumnModel.addColumn(column2);\n\t\tcolumnModel.removeColumn(column2);\n\t\tint result = columnModel.getColumnIndex(\"Column2\", false);\n\t\tassertEquals(1, result);\n\t}\n\t\n\t/**\n\t* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.\n\t* Tested with a column model with two columns, one visible and one invisible.\n\t* The identifier of the visible column is searched.\n\t* The expected result is 0.\n\t*/\n\t@Test\n\tpublic void testGetColumnIndex_3() {\n\t\tPersistentTableColumnModel columnModel = new PersistentTableColumnModel();\n\t\tTableColumn column1 = new TableColumn(0);\n\t\tcolumn1.setIdentifier(\"Column1\");\n\t\tcolumnModel.addColumn(column1);\n\t\tTableColumn column2 = new TableColumn(1);\n\t\tcolumn2.setIdentifier(\"Column2\");\n\t\tcolumnModel.addColumn(column2);\n\t\tcolumnModel.removeColumn(column2);\n\t\tint result = columnModel.getColumnIndex(\"Column1\", false);\n\t\tassertEquals(0, result);\n\t}\n\t\n\t/**\n\t* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.\n\t* Tested with a column model with two columns, one visible and one invisible.\n\t* The identifier of the invisible column is searched.\n\t* The expected result is 0.\n\t*/\n\t@Test\n\tpublic void testGetColumnIndex_4() {\n\t\tPersistentTableColumnModel columnModel = new PersistentTableColumnModel();\n\t\tTableColumn column1 = new TableColumn(0);\n\t\tcolumn1.setIdentifier(\"Column1\");\n\t\tcolumnModel.addColumn(column1);\n\t\tTableColumn column2 = new TableColumn(1);\n\t\tcolumn2.setIdentifier(\"Column2\");\n\t\tcolumnModel.addColumn(column2);\n\t\tcolumnModel.removeColumn(column2);\n\t\tint result = columnModel.getColumnIndex(\"Column2\", true);\n\t\tassertEquals(1, result);\n\t}\n\t\n\t/**\n\t* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.\n\t* Tested with a column model with two columns, both visible.\n\t* The identifier of the first column is searched.\n\t* The expected result is 0.\n\t*/\n\t@Test\n\tpublic void testGetColumnIndex_5() {\n\t\tPersistentTableColumnModel columnModel = new PersistentTableColumnModel();\n\t\tTableColumn column1 = new TableColumn(0);\n\t\tcolumn1.setIdentifier(\"Column1\");\n\t\tcolumnModel.addColumn(column1);\n\t\tTableColumn column2 = new TableColumn(1);\n\t\tcolumn2.setIdentifier(\"Column2\");\n\t\tcolumnModel.addColumn(column2);\n\t\tint result = columnModel.getColumnIndex(\"Column1\", true);\n\t\tassertEquals(0, result);\n\t}\n\t\n\t/**\n\t* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.\n\t* Tested with a column model with two columns, both visible.\n\t* The identifier of the second column is searched.\n\t* The expected result is 0.\n\t*/\n\t@Test\n\tpublic void testGetColumnIndex_6() {\n\t\tPersistentTableColumnModel columnModel = new PersistentTableColumnModel();\n\t\tTableColumn column1 = new TableColumn(0);\n\t\tcolumn1.setIdentifier(\"Column1\");\n\t\tcolumnModel.addColumn(column1);\n\t\tTableColumn column2 = new TableColumn(1);\n\t\tcolumn2.setIdentifier(\"Column2\");\n\t\tcolumnModel.addColumn(column2);\n\t\tint result = columnModel.getColumnIndex(\"Column2\", true);\n\t\tassertEquals(1, result);\n\t}\n\t\n\t/**\n\t* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.\n\t* Tested with a column model with two columns, both visible.\n\t* The identifier of the first column is searched.\n\t* The expected result is 0.\n\t*/\n\t@Test\n\tpublic void testGetColumnIndex_7() {\n\t\tPersistentTableColumnModel columnModel = new PersistentTableColumnModel();\n\t\tTableColumn column1 = new TableColumn(0);\n\t\tcolumn1.setIdentifier(\"Column1\");\n\t\tcolumnModel.addColumn(column1);\n\t\tTableColumn column2 = new TableColumn(1);\n\t\tcolumn2.setIdentifier(\"Column2\");\n\t\tcolumnModel.addColumn(column2);\n\t\tint result = columnModel.getColumnIndex(\"Column1\", false);\n\t\tassertEquals(0, result);\n\t}\n\t\n\t/**\n\t* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.\n\t* Tested with a column model with two columns, both visible.\n\t* The identifier of the second column is searched.\n\t* The expected result is 0.\n\t*/\n\t@Test\n\tpublic void testGetColumnIndex_8() {\n\t\tPersistentTableColumnModel columnModel = new PersistentTableColumnModel();\n\t\tTableColumn column1 = new TableColumn(0);\n\t\tcolumn1.setIdentifier(\"Column1\");\n\t\tcolumnModel.addColumn(column1);\n\t\tTableColumn column2 = new TableColumn(1);\n\t\tcolumn2.setIdentifier(\"Column2\");\n\t\tcolumnModel.addColumn(column2);\n\t\tint result = columnModel.getColumnIndex(\"Column2\", false);\n\t\tassertEquals(1, result);\n\t}\n\t\n\t/**\n\t* Test case for {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.\n\t* Tested with a column model with two columns, both visible.\n\t* The identifier of the first column is searched.\n\t* The expected result is 0.\n\t*/\n\t@Test\n\tpublic void testGetColumnIndex_9() {\n\t\tPersistentTableColumnModel columnModel = new PersistentTableColumnModel();\n\t\tTableColumn column1 = new TableColumn(0);\n\t\tcolumn1.setIdentifier(\"Column1\");\n\t\tcolumnModel.addColumn(column1);\n\t\tTableColumn column2 = new TableColumn(1);\n\t\tcolumn2.setIdentifier(\"Column2\");\n\t\tcolumnModel.addColumn(column2);\n\t\tint result = columnModel.getColumnIndex(\"Column1\", true);\n\t\tassertEquals(0, result);\n\t}\n\t\n\t/**\n\t* Test case for {@link Persistent",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 2987,
        "completion_tokens": 2000,
        "total_tokens": 4987
    },
    "time_taken": 47.73233246803284,
    "prompt_id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/model/PersistentTableColumnModel_3Test.java",
    "original_code": "// PersistentTableColumnModel.java\npackage de.huxhorn.lilith.swing.table.model;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport javax.swing.table.DefaultTableColumnModel;\r\nimport javax.swing.table.TableColumn;\r\n\r\n/**\r\n * This class is based on code and ideas from Stephen Kelvin (mail at StephenKelvin.de) and Thomas Darimont.\r\n */\r\npublic class PersistentTableColumnModel extends DefaultTableColumnModel {\r\n\r\n    protected List<TableColumn> allTableColumns = new ArrayList<TableColumn>();\r\n\r\n    /**\r\n     * Creates an extended table column model.\r\n     */\r\n    public PersistentTableColumnModel() {\r\n        allTableColumns = new ArrayList<TableColumn>();\r\n        initColumns();\r\n    }\r\n\r\n    /**\r\n     * Should be implemented by subclasses if needed.\r\n     */\r\n    protected void initColumns() {\r\n    }\r\n\r\n    /**\r\n     * Sets the visibility of the specified TableColumn.\r\n     * The call is ignored if the TableColumn is not found in this column model\r\n     * or its visibility status did not change.\r\n     * <p/>\r\n     *\r\n     * @param column  the column to show/hide\r\n     * @param visible its new visibility status\r\n     */\r\n    // listeners will receive columnAdded()/columnRemoved() event\r\n    public void setColumnVisible(TableColumn column, boolean visible) {\r\n        if (!visible) {\r\n            super.removeColumn(column);\r\n        } else {\r\n            // find the visible index of the column:\r\n            // iterate through both collections of visible and all columns, counting\r\n            // visible columns up to the one that's about to be shown again\r\n            int noVisibleColumns = tableColumns.size();\r\n            int noInvisibleColumns = allTableColumns.size();\r\n            int visibleIndex = 0;\r\n            for (int invisibleIndex = 0; invisibleIndex < noInvisibleColumns; ++invisibleIndex) {\r\n                TableColumn visibleColumn = (visibleIndex < noVisibleColumns ? tableColumns.get(visibleIndex) : null);\r\n                TableColumn testColumn = allTableColumns.get(invisibleIndex);\r\n                if (testColumn == column) {\r\n                    if (visibleColumn != column) {\r\n                        super.addColumn(column);\r\n                        super.moveColumn(tableColumns.size() - 1, visibleIndex);\r\n                    }\r\n                    // ####################\r\n                    return;\r\n                }\r\n                if (testColumn == visibleColumn) {\r\n                    ++visibleIndex;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Makes all columns in this model visible\r\n     */\r\n    public void setAllColumnsVisible() {\r\n        int noColumns = allTableColumns.size();\r\n        for (int columnIndex = 0; columnIndex < noColumns; ++columnIndex) {\r\n            TableColumn visibleColumn = (columnIndex < tableColumns.size() ? tableColumns.get(columnIndex) : null);\r\n            TableColumn invisibleColumn = allTableColumns.get(columnIndex);\r\n            if (visibleColumn != invisibleColumn) {\r\n                super.addColumn(invisibleColumn);\r\n                super.moveColumn(tableColumns.size() - 1, columnIndex);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks wether the specified column is currently visible.\r\n     *\r\n     * @param aColumn column to check\r\n     * @return visibility of specified column (false if there is no such column at all. [It's not visible, right?])\r\n     */\r\n    public boolean isColumnVisible(TableColumn aColumn) {\r\n        return (tableColumns.indexOf(aColumn) >= 0);\r\n    }\r\n\r\n    /**\r\n     * Append <code>column</code> to the right of exisiting columns.\r\n     * Posts <code>columnAdded</code> event.\r\n     *\r\n     * @param column The column to be added\r\n     * @throws IllegalArgumentException if <code>column</code> is <code>null</code>\r\n     * @see #removeColumn\r\n     */\r\n    @Override\r\n    public void addColumn(TableColumn column) {\r\n        allTableColumns.add(column);\r\n        super.addColumn(column);\r\n    }\r\n\r\n    /**\r\n     * Removes <code>column</code> from this column model.\r\n     * Posts <code>columnRemoved</code> event.\r\n     * Will do nothing if the column is not in this model.\r\n     *\r\n     * @param column the column to be added\r\n     * @see #addColumn\r\n     */\r\n    @Override\r\n    public void removeColumn(TableColumn column) {\r\n        int allColumnsIndex = allTableColumns.indexOf(column);\r\n        if (allColumnsIndex != -1) {\r\n            allTableColumns.remove(allColumnsIndex);\r\n        }\r\n        super.removeColumn(column);\r\n    }\r\n\r\n    /**\r\n     * Moves the column from <code>oldIndex</code> to <code>newIndex</code>.\r\n     * Posts  <code>columnMoved</code> event.\r\n     * Will not move any columns if <code>oldIndex</code> equals <code>newIndex</code>.\r\n     *\r\n     * @throws IllegalArgumentException if either <code>oldIndex</code> or\r\n     *                                  <code>newIndex</code>\r\n     *                                  are not in [0, getColumnCount() - 1]\r\n     * @param\toldIndex\t\t\tindex of column to be moved\r\n     * @param\tnewIndex\t\t\tnew index of the column\r\n     */\r\n    @Override\r\n    public void moveColumn(int oldIndex, int newIndex) {\r\n        if ((oldIndex < 0) || (oldIndex >= getColumnCount()) || (newIndex < 0) || (newIndex >= getColumnCount())) {\r\n            throw new IllegalArgumentException(\"moveColumn() - Index out of range\");\r\n        }\r\n        TableColumn fromColumn = tableColumns.get(oldIndex);\r\n        TableColumn toColumn = tableColumns.get(newIndex);\r\n        int allColumnsOldIndex = allTableColumns.indexOf(fromColumn);\r\n        int allColumnsNewIndex = allTableColumns.indexOf(toColumn);\r\n        if (oldIndex != newIndex) {\r\n            allTableColumns.remove(allColumnsOldIndex);\r\n            allTableColumns.add(allColumnsNewIndex, fromColumn);\r\n        }\r\n        super.moveColumn(oldIndex, newIndex);\r\n    }\r\n\r\n    /**\r\n     * Returns the total number of columns in this model.\r\n     *\r\n     * @param onlyVisible if set only visible columns will be counted\r\n     * @return the number of columns in the <code>tableColumns</code> array\r\n     * @see\t#getColumns\r\n     */\r\n    public int getColumnCount(boolean onlyVisible) {\r\n        return (onlyVisible ? tableColumns.size() : allTableColumns.size());\r\n    }\r\n\r\n    /**\r\n     * Returns an <code>Enumeration</code> of all the columns in the model.\r\n     *\r\n     * @param onlyVisible if set all invisible columns will be missing from the enumeration.\r\n     * @return an <code>Enumeration</code> of the columns in the model\r\n     */\r\n    public Iterator<TableColumn> getColumns(boolean onlyVisible) {\r\n        return (onlyVisible ? tableColumns.iterator() : allTableColumns.iterator());\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the first column whose identifier equals <code>identifier</code>.\r\n     * Position is the the index in all visible columns if <code>onlyVisible</code> is true or\r\n     * else the index in all columns.\r\n     *\r\n     * @return the index of the first column whose identifier\r\n     *         equals <code>identifier</code>\r\n     * @throws IllegalArgumentException if <code>identifier</code>\r\n     *                                  is <code>null</code>, or if no\r\n     *                                  <code>TableColumn</code> has this\r\n     *                                  <code>identifier</code>\r\n     * @param\tidentifier the identifier object to search for\r\n     * @param\tonlyVisible if set searches only visible columns\r\n     * @see\t\t#getColumn\r\n     */\r\n    public int getColumnIndex(Object identifier, boolean onlyVisible) {\r\n        if (identifier == null) {\r\n            throw new IllegalArgumentException(\"Identifier is null\");\r\n        }\r\n        List<TableColumn> columns = (onlyVisible ? tableColumns : allTableColumns);\r\n        int noColumns = columns.size();\r\n        TableColumn column;\r\n        for (int columnIndex = 0; columnIndex < noColumns; ++columnIndex) {\r\n            column = columns.get(columnIndex);\r\n            if (identifier.equals(column.getIdentifier())) {\r\n                return columnIndex;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"Identifier not found\");\r\n    }\r\n\r\n    public List<TableColumnLayoutInfo> getColumnLayoutInfos() {\r\n        final List<TableColumnLayoutInfo> tableColumnLayoutInfos = new ArrayList<TableColumnLayoutInfo>(allTableColumns.size());\r\n        for (TableColumn current : allTableColumns) {\r\n            boolean visible = tableColumns.contains(current);\r\n            TableColumnLayoutInfo tableColumnLayoutInfo = new TableColumnLayoutInfo(current.getIdentifier().toString(), current.getWidth(), visible);\r\n            tableColumnLayoutInfos.add(tableColumnLayoutInfo);\r\n        }\r\n        return tableColumnLayoutInfos;\r\n    }\r\n\r\n    public static class TableColumnLayoutInfo implements Serializable {\r\n\r\n        private String columnName;\r\n\r\n        private int width;\r\n\r\n        private boolean visible;\r\n\r\n        public TableColumnLayoutInfo() {\r\n        }\r\n\r\n        public TableColumnLayoutInfo(String columnName, int width, boolean visible) {\r\n            this.columnName = columnName;\r\n            this.width = width;\r\n            this.visible = visible;\r\n        }\r\n\r\n        public int getWidth() {\r\n            return width;\r\n        }\r\n\r\n        public void setWidth(int width) {\r\n            this.width = width;\r\n        }\r\n\r\n        public String getColumnName() {\r\n            return columnName;\r\n        }\r\n\r\n        public void setColumnName(String columnName) {\r\n            this.columnName = columnName;\r\n        }\r\n\r\n        public boolean isVisible() {\r\n            return visible;\r\n        }\r\n\r\n        public void setVisible(boolean visible) {\r\n            this.visible = visible;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"TableColumnLayoutInfo[columnName=\" + columnName + \", width=\" + width + \", visible=\" + visible + \"]\";\r\n        }\r\n    }\r\n}\r\n",
    "test_prompt": "// PersistentTableColumnModel_3Test.java\npackage de.huxhorn.lilith.swing.table.model;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.swing.table.DefaultTableColumnModel;\nimport javax.swing.table.TableColumn;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PersistentTableColumnModel}.\n* It contains ten unit test cases for the {@link PersistentTableColumnModel#getColumnIndex(Object, boolean)} method.\n*/\nclass PersistentTableColumnModel_3Test {"
},
{
    "id": "cmpl-6wSUKoPGz7S5OdyAb1sDOMoOcxJgH",
    "object": "text_completion",
    "created": 1679390552,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\t@Test\n\t\tvoid test_0() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 0);\n\t\t\t\tInsets insets = border.getBorderInsets(null);\n\t\t\t\tassertEquals(1, insets.top);\n\t\t\t\tassertEquals(1, insets.left);\n\t\t\t\tassertEquals(1, insets.bottom);\n\t\t\t\tassertEquals(1, insets.right);\n\t\t}\n\t\t\n\t\t@Test\n\t\tvoid test_1() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 2, 0);\n\t\t\t\tInsets insets = border.getBorderInsets(null);\n\t\t\t\tassertEquals(2, insets.top);\n\t\t\t\tassertEquals(2, insets.left);\n\t\t\t\tassertEquals(2, insets.bottom);\n\t\t\t\tassertEquals(2, insets.right);\n\t\t}\n\t\t\n\t\t@Test\n\t\tvoid test_2() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 3, 0);\n\t\t\t\tInsets insets = border.getBorderInsets(null);\n\t\t\t\tassertEquals(3, insets.top);\n\t\t\t\tassertEquals(3, insets.left);\n\t\t\t\tassertEquals(3, insets.bottom);\n\t\t\t\tassertEquals(3, insets.right);\n\t\t}\n\t\t\n\t\t@Test\n\t\tvoid test_3() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 4, 0);\n\t\t\t\tInsets insets = border.getBorderInsets(null);\n\t\t\t\tassertEquals(4, insets.top);\n\t\t\t\tassertEquals(4, insets.left);\n\t\t\t\tassertEquals(4, insets.bottom);\n\t\t\t\tassertEquals(4, insets.right);\n\t\t}\n\t\t\n\t\t@Test\n\t\tvoid test_4() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 5, 0);\n\t\t\t\tInsets insets = border.getBorderInsets(null);\n\t\t\t\tassertEquals(5, insets.top);\n\t\t\t\tassertEquals(5, insets.left);\n\t\t\t\tassertEquals(5, insets.bottom);\n\t\t\t\tassertEquals(5, insets.right);\n\t\t}\n\t\t\n\t\t@Test\n\t\tvoid test_5() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 6, 0);\n\t\t\t\tInsets insets = border.getBorderInsets(null);\n\t\t\t\tassertEquals(6, insets.top);\n\t\t\t\tassertEquals(6, insets.left);\n\t\t\t\tassertEquals(6, insets.bottom);\n\t\t\t\tassertEquals(6, insets.right);\n\t\t}\n\t\t\n\t\t@Test\n\t\tvoid test_6() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 7, 0);\n\t\t\t\tInsets insets = border.getBorderInsets(null);\n\t\t\t\tassertEquals(7, insets.top);\n\t\t\t\tassertEquals(7, insets.left);\n\t\t\t\tassertEquals(7, insets.bottom);\n\t\t\t\tassertEquals(7, insets.right);\n\t\t}\n\t\t\n\t\t@Test\n\t\tvoid test_7() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 8, 0);\n\t\t\t\tInsets insets = border.getBorderInsets(null);\n\t\t\t\tassertEquals(8, insets.top);\n\t\t\t\tassertEquals(8, insets.left);\n\t\t\t\tassertEquals(8, insets.bottom);\n\t\t\t\tassertEquals(8, insets.right);\n\t\t}\n\t\t\n\t\t@Test\n\t\tvoid test_8() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 9, 0);\n\t\t\t\tInsets insets = border.getBorderInsets(null);\n\t\t\t\tassertEquals(9, insets.top);\n\t\t\t\tassertEquals(9, insets.left);\n\t\t\t\tassertEquals(9, insets.bottom);\n\t\t\t\tassertEquals(9, insets.right);\n\t\t}\n\t\t\n\t\t@Test\n\t\tvoid test_9() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 10, 0);\n\t\t\t\tInsets insets = border.getBorderInsets(null);\n\t\t\t\tassertEquals(10, insets.top);\n\t\t\t\tassertEquals(10, insets.left);\n\t\t\t\tassertEquals(10, insets.bottom);\n\t\t\t\tassertEquals(10, insets.right);\n\t\t}\n}\n\n// ConditionalBorder_1Test.java\npackage de.huxhorn.lilith.swing.table.renderer;\n\nimport java.awt.*;\nimport javax.swing.border.AbstractBorder;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConditionalBorder}.\n* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component)} method.\n*/\nclass ConditionalBorder_1Test {\n\t\t\n\t\t@Test\n\t\tvoid test_0() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 0, 1);\n\t\t\t\tInsets insets = border.getBorderInsets(null);\n\t\t\t\tassertEquals(1, insets.top);\n\t\t\t\tassertEquals(1, insets.left);\n\t\t\t\tassertEquals(1, insets.bottom);\n\t\t\t\tassertEquals(1, insets.right);\n\t\t}\n\t\t\n\t\t@Test\n\t\tvoid test_1() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 0, 2);\n\t\t\t\tInsets insets = border.getBorderInsets(null);\n\t\t\t\tassertEquals(2, insets.top);\n\t\t\t\tassertEquals(2, insets.left);\n\t\t\t\tassertEquals(2, insets.bottom);\n\t\t\t\tassertEquals(2, insets.right);\n\t\t}\n\t\t\n\t\t@Test\n\t\tvoid test_2() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 0, 3);\n\t\t\t\tInsets insets = border.getBorderInsets(null);\n\t\t\t\tassertEquals(3, insets.top);\n\t\t\t\tassertEquals(3, insets.left);\n\t\t\t\tassertEquals(3, insets.bottom);\n\t\t\t\tassertEquals(3, insets.right);\n\t\t}\n\t\t\n\t\t@Test\n\t\tvoid test_3() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 0, 4);\n\t\t\t\tInsets insets = border.getBorderInsets(null);\n\t\t\t\tassertEquals(4, insets.top);\n\t\t\t\tassertEquals(4, insets.left);\n\t\t\t\tassertEquals(4, insets.bottom);\n\t\t\t\tassertEquals(4, insets.right);\n\t\t}\n\t\t\n\t\t@Test\n\t\tvoid test_4() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 0, 5);\n\t\t\t\tInsets insets = border.getBorderInsets(null);\n\t\t\t\tassertEquals(5, insets",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 1676,
        "completion_tokens": 2000,
        "total_tokens": 3676
    },
    "time_taken": 53.67000150680542,
    "prompt_id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/renderer/ConditionalBorder_0Test.java",
    "original_code": "// ConditionalBorder.java\n/*\r\n * Lilith - a log event viewer.\r\n * Copyright (C) 2007-2009 Joern Huxhorn\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.huxhorn.lilith.swing.table.renderer;\r\n\r\nimport java.awt.*;\r\nimport javax.swing.border.AbstractBorder;\r\n\r\n/**\r\n * This is basically a mutable, simplified LineBorder-EmptyBorder combination.\r\n */\r\npublic class ConditionalBorder extends AbstractBorder {\r\n\r\n    private static final long serialVersionUID = -2372658104457011019L;\r\n\r\n    private int thickness;\r\n\r\n    private int innerThickness;\r\n\r\n    private Color borderColor;\r\n\r\n    public ConditionalBorder(Color color) {\r\n        this(color, 1, 0);\r\n    }\r\n\r\n    public ConditionalBorder(Color color, int thickness) {\r\n        this(color, thickness, 0);\r\n    }\r\n\r\n    public ConditionalBorder(Color color, int thickness, int innerThickness) {\r\n        setBorderColor(color);\r\n        setThickness(thickness);\r\n        setInnerThickness(innerThickness);\r\n    }\r\n\r\n    /**\r\n     * Paints the border for the specified component with the\r\n     * specified position and size.\r\n     *\r\n     * @param c      the component for which this border is being painted\r\n     * @param g      the paint graphics\r\n     * @param x      the x position of the painted border\r\n     * @param y      the y position of the painted border\r\n     * @param width  the width of the painted border\r\n     * @param height the height of the painted border\r\n     */\r\n    public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {\r\n        if (borderColor != null && thickness > 0) {\r\n            Color oldColor = g.getColor();\r\n            g.setColor(borderColor);\r\n            for (int i = 0; i < thickness; i++) {\r\n                g.drawRect(x + i, y + i, width - i - i - 1, height - i - i - 1);\r\n            }\r\n            g.setColor(oldColor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the insets of the border.\r\n     *\r\n     * @param c the component for which this border insets value applies\r\n     */\r\n    public Insets getBorderInsets(Component c) {\r\n        int actualThickness = thickness + innerThickness;\r\n        return new Insets(actualThickness, actualThickness, actualThickness, actualThickness);\r\n    }\r\n\r\n    /**\r\n     * Reinitialize the insets parameter with this Border's current Insets.\r\n     *\r\n     * @param c      the component for which this border insets value applies\r\n     * @param insets the object to be reinitialized\r\n     */\r\n    public Insets getBorderInsets(Component c, Insets insets) {\r\n        int actualThickness = thickness + innerThickness;\r\n        insets.left = actualThickness;\r\n        insets.top = actualThickness;\r\n        insets.right = actualThickness;\r\n        insets.bottom = actualThickness;\r\n        return insets;\r\n    }\r\n\r\n    /**\r\n     * Returns the color of the border.\r\n     *\r\n     * @return the color of the border.\r\n     */\r\n    public Color getBorderColor() {\r\n        return borderColor;\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the border.\r\n     *\r\n     * @param borderColor the color of the border.\r\n     */\r\n    public void setBorderColor(Color borderColor) {\r\n        this.borderColor = borderColor;\r\n    }\r\n\r\n    /**\r\n     * Returns the inner thickness of the border.\r\n     *\r\n     * @return Returns the inner thickness of the border.\r\n     */\r\n    public int getInnerThickness() {\r\n        return innerThickness;\r\n    }\r\n\r\n    /**\r\n     * Sets the inner thickness of the border.\r\n     *\r\n     * @param innerThickness Returns the inner thickness of the border.\r\n     */\r\n    public void setInnerThickness(int innerThickness) {\r\n        if (innerThickness < 0) {\r\n            throw new IllegalArgumentException(\"innerThickness must not be negative!\");\r\n        }\r\n        this.innerThickness = innerThickness;\r\n    }\r\n\r\n    /**\r\n     * Returns the thickness of the border.\r\n     *\r\n     * @return Returns the thickness of the border.\r\n     */\r\n    public int getThickness() {\r\n        return thickness;\r\n    }\r\n\r\n    /**\r\n     * Sets the thickness of the border.\r\n     *\r\n     * @param thickness the thickness of the border.\r\n     */\r\n    public void setThickness(int thickness) {\r\n        if (thickness < 0) {\r\n            throw new IllegalArgumentException(\"thickness must not be negative!\");\r\n        }\r\n        this.thickness = thickness;\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the border is opaque.\r\n     */\r\n    public boolean isBorderOpaque() {\r\n        return innerThickness == 0 && thickness > 0 && borderColor != null;\r\n    }\r\n}\r\n",
    "test_prompt": "// ConditionalBorder_0Test.java\npackage de.huxhorn.lilith.swing.table.renderer;\n\nimport java.awt.*;\nimport javax.swing.border.AbstractBorder;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConditionalBorder}.\n* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component)} method.\n*/\nclass ConditionalBorder_0Test {"
},
{
    "id": "cmpl-6wSVNMFOTI16DUJBv7SmlNeP2QlLA",
    "object": "text_completion",
    "created": 1679390617,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\t/**\n\t\t* Test case for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.\n\t\t* The test case tests the border insets for a border with a thickness of 1 and an inner thickness of 0.\n\t\t*/\n\t\t@Test\n\t\tpublic void testGetBorderInsets_1_0() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 1, 0);\n\t\t\t\tInsets insets = new Insets(0, 0, 0, 0);\n\t\t\t\tborder.getBorderInsets(null, insets);\n\t\t\t\tassertEquals(1, insets.top);\n\t\t\t\tassertEquals(1, insets.left);\n\t\t\t\tassertEquals(1, insets.bottom);\n\t\t\t\tassertEquals(1, insets.right);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.\n\t\t* The test case tests the border insets for a border with a thickness of 2 and an inner thickness of 0.\n\t\t*/\n\t\t@Test\n\t\tpublic void testGetBorderInsets_2_0() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 2, 0);\n\t\t\t\tInsets insets = new Insets(0, 0, 0, 0);\n\t\t\t\tborder.getBorderInsets(null, insets);\n\t\t\t\tassertEquals(2, insets.top);\n\t\t\t\tassertEquals(2, insets.left);\n\t\t\t\tassertEquals(2, insets.bottom);\n\t\t\t\tassertEquals(2, insets.right);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.\n\t\t* The test case tests the border insets for a border with a thickness of 3 and an inner thickness of 0.\n\t\t*/\n\t\t@Test\n\t\tpublic void testGetBorderInsets_3_0() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 3, 0);\n\t\t\t\tInsets insets = new Insets(0, 0, 0, 0);\n\t\t\t\tborder.getBorderInsets(null, insets);\n\t\t\t\tassertEquals(3, insets.top);\n\t\t\t\tassertEquals(3, insets.left);\n\t\t\t\tassertEquals(3, insets.bottom);\n\t\t\t\tassertEquals(3, insets.right);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.\n\t\t* The test case tests the border insets for a border with a thickness of 4 and an inner thickness of 0.\n\t\t*/\n\t\t@Test\n\t\tpublic void testGetBorderInsets_4_0() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 4, 0);\n\t\t\t\tInsets insets = new Insets(0, 0, 0, 0);\n\t\t\t\tborder.getBorderInsets(null, insets);\n\t\t\t\tassertEquals(4, insets.top);\n\t\t\t\tassertEquals(4, insets.left);\n\t\t\t\tassertEquals(4, insets.bottom);\n\t\t\t\tassertEquals(4, insets.right);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.\n\t\t* The test case tests the border insets for a border with a thickness of 5 and an inner thickness of 0.\n\t\t*/\n\t\t@Test\n\t\tpublic void testGetBorderInsets_5_0() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 5, 0);\n\t\t\t\tInsets insets = new Insets(0, 0, 0, 0);\n\t\t\t\tborder.getBorderInsets(null, insets);\n\t\t\t\tassertEquals(5, insets.top);\n\t\t\t\tassertEquals(5, insets.left);\n\t\t\t\tassertEquals(5, insets.bottom);\n\t\t\t\tassertEquals(5, insets.right);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.\n\t\t* The test case tests the border insets for a border with a thickness of 6 and an inner thickness of 0.\n\t\t*/\n\t\t@Test\n\t\tpublic void testGetBorderInsets_6_0() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 6, 0);\n\t\t\t\tInsets insets = new Insets(0, 0, 0, 0);\n\t\t\t\tborder.getBorderInsets(null, insets);\n\t\t\t\tassertEquals(6, insets.top);\n\t\t\t\tassertEquals(6, insets.left);\n\t\t\t\tassertEquals(6, insets.bottom);\n\t\t\t\tassertEquals(6, insets.right);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.\n\t\t* The test case tests the border insets for a border with a thickness of 7 and an inner thickness of 0.\n\t\t*/\n\t\t@Test\n\t\tpublic void testGetBorderInsets_7_0() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 7, 0);\n\t\t\t\tInsets insets = new Insets(0, 0, 0, 0);\n\t\t\t\tborder.getBorderInsets(null, insets);\n\t\t\t\tassertEquals(7, insets.top);\n\t\t\t\tassertEquals(7, insets.left);\n\t\t\t\tassertEquals(7, insets.bottom);\n\t\t\t\tassertEquals(7, insets.right);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.\n\t\t* The test case tests the border insets for a border with a thickness of 8 and an inner thickness of 0.\n\t\t*/\n\t\t@Test\n\t\tpublic void testGetBorderInsets_8_0() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 8, 0);\n\t\t\t\tInsets insets = new Insets(0, 0, 0, 0);\n\t\t\t\tborder.getBorderInsets(null, insets);\n\t\t\t\tassertEquals(8, insets.top);\n\t\t\t\tassertEquals(8, insets.left);\n\t\t\t\tassertEquals(8, insets.bottom);\n\t\t\t\tassertEquals(8, insets.right);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.\n\t\t* The test case tests the border insets for a border with a thickness of 9 and an inner thickness of 0.\n\t\t*/\n\t\t@Test\n\t\tpublic void testGetBorderInsets_9_0() {\n\t\t\t\tConditionalBorder border = new ConditionalBorder(Color.BLACK, 9, 0);\n\t\t\t\tInsets insets = new Insets(0, 0, 0, 0);\n\t\t\t\tborder.getBorderInsets(null, insets);\n\t\t\t\tassertEquals(9, insets.top);\n\t\t\t\tassertEquals(9, insets.left);\n\t\t\t\tassertEquals(9, insets.bottom);\n\t\t\t\tassertEquals(9, insets.right);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.\n\t\t* The test case tests the border insets for a border with",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 1679,
        "completion_tokens": 2000,
        "total_tokens": 3679
    },
    "time_taken": 43.71235013008118,
    "prompt_id": "/EvoSuiteBenchmark/original/43_lilith/src/main/java/de/huxhorn/lilith/swing/table/renderer/ConditionalBorder_1Test.java",
    "original_code": "// ConditionalBorder.java\n/*\r\n * Lilith - a log event viewer.\r\n * Copyright (C) 2007-2009 Joern Huxhorn\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.huxhorn.lilith.swing.table.renderer;\r\n\r\nimport java.awt.*;\r\nimport javax.swing.border.AbstractBorder;\r\n\r\n/**\r\n * This is basically a mutable, simplified LineBorder-EmptyBorder combination.\r\n */\r\npublic class ConditionalBorder extends AbstractBorder {\r\n\r\n    private static final long serialVersionUID = -2372658104457011019L;\r\n\r\n    private int thickness;\r\n\r\n    private int innerThickness;\r\n\r\n    private Color borderColor;\r\n\r\n    public ConditionalBorder(Color color) {\r\n        this(color, 1, 0);\r\n    }\r\n\r\n    public ConditionalBorder(Color color, int thickness) {\r\n        this(color, thickness, 0);\r\n    }\r\n\r\n    public ConditionalBorder(Color color, int thickness, int innerThickness) {\r\n        setBorderColor(color);\r\n        setThickness(thickness);\r\n        setInnerThickness(innerThickness);\r\n    }\r\n\r\n    /**\r\n     * Paints the border for the specified component with the\r\n     * specified position and size.\r\n     *\r\n     * @param c      the component for which this border is being painted\r\n     * @param g      the paint graphics\r\n     * @param x      the x position of the painted border\r\n     * @param y      the y position of the painted border\r\n     * @param width  the width of the painted border\r\n     * @param height the height of the painted border\r\n     */\r\n    public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {\r\n        if (borderColor != null && thickness > 0) {\r\n            Color oldColor = g.getColor();\r\n            g.setColor(borderColor);\r\n            for (int i = 0; i < thickness; i++) {\r\n                g.drawRect(x + i, y + i, width - i - i - 1, height - i - i - 1);\r\n            }\r\n            g.setColor(oldColor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the insets of the border.\r\n     *\r\n     * @param c the component for which this border insets value applies\r\n     */\r\n    public Insets getBorderInsets(Component c) {\r\n        int actualThickness = thickness + innerThickness;\r\n        return new Insets(actualThickness, actualThickness, actualThickness, actualThickness);\r\n    }\r\n\r\n    /**\r\n     * Reinitialize the insets parameter with this Border's current Insets.\r\n     *\r\n     * @param c      the component for which this border insets value applies\r\n     * @param insets the object to be reinitialized\r\n     */\r\n    public Insets getBorderInsets(Component c, Insets insets) {\r\n        int actualThickness = thickness + innerThickness;\r\n        insets.left = actualThickness;\r\n        insets.top = actualThickness;\r\n        insets.right = actualThickness;\r\n        insets.bottom = actualThickness;\r\n        return insets;\r\n    }\r\n\r\n    /**\r\n     * Returns the color of the border.\r\n     *\r\n     * @return the color of the border.\r\n     */\r\n    public Color getBorderColor() {\r\n        return borderColor;\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the border.\r\n     *\r\n     * @param borderColor the color of the border.\r\n     */\r\n    public void setBorderColor(Color borderColor) {\r\n        this.borderColor = borderColor;\r\n    }\r\n\r\n    /**\r\n     * Returns the inner thickness of the border.\r\n     *\r\n     * @return Returns the inner thickness of the border.\r\n     */\r\n    public int getInnerThickness() {\r\n        return innerThickness;\r\n    }\r\n\r\n    /**\r\n     * Sets the inner thickness of the border.\r\n     *\r\n     * @param innerThickness Returns the inner thickness of the border.\r\n     */\r\n    public void setInnerThickness(int innerThickness) {\r\n        if (innerThickness < 0) {\r\n            throw new IllegalArgumentException(\"innerThickness must not be negative!\");\r\n        }\r\n        this.innerThickness = innerThickness;\r\n    }\r\n\r\n    /**\r\n     * Returns the thickness of the border.\r\n     *\r\n     * @return Returns the thickness of the border.\r\n     */\r\n    public int getThickness() {\r\n        return thickness;\r\n    }\r\n\r\n    /**\r\n     * Sets the thickness of the border.\r\n     *\r\n     * @param thickness the thickness of the border.\r\n     */\r\n    public void setThickness(int thickness) {\r\n        if (thickness < 0) {\r\n            throw new IllegalArgumentException(\"thickness must not be negative!\");\r\n        }\r\n        this.thickness = thickness;\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the border is opaque.\r\n     */\r\n    public boolean isBorderOpaque() {\r\n        return innerThickness == 0 && thickness > 0 && borderColor != null;\r\n    }\r\n}\r\n",
    "test_prompt": "// ConditionalBorder_1Test.java\npackage de.huxhorn.lilith.swing.table.renderer;\n\nimport java.awt.*;\nimport javax.swing.border.AbstractBorder;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConditionalBorder}.\n* It contains ten unit test cases for the {@link ConditionalBorder#getBorderInsets(Component, Insets)} method.\n*/\nclass ConditionalBorder_1Test {"
}
]