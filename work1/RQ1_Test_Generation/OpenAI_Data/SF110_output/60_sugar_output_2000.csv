ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6wUzaieUBdWSv2PZzRQyNSOQzZ8Ap,/EvoSuiteBenchmark/original/60_sugar/src/main/java/net/sf/sugar/fspath/DefaultFSPath_0Test.java,58.45855522155762,length,"// DefaultFSPath.java
/**
 * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)
 *
 * All rights reserved.
 *
 * This file is part of FSPath.
 *
 * FSPath is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FSPath is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * DefaultFSPath.java
 *
 * Created on 18 September 2006, 00:25
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.IOException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import javax.xml.namespace.QName;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import net.sf.sugar.fspath.xpath.RegexFunctionResolver;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

/**
 *  The default implementation of the FSPath interface.
 *  This class uses the JDK's XPath implementation as the basis for
 *  FSPath queries.
 *  On instantiation, a DOM is created of the filesystem metadata starting form the <code>rootDirectory</code>.
 *  This DOM can then be queried using standard XML tools.
 *  <br/>
 *  Whilst this approach has been relatively quick to implement, it is still tied to the limitations of XPath.
 *  Future implementations of this class are likely to implement the FSPath language fully themselves wthout relying on XPath.
 *  <br/>
 *  todo: develop some front end substitution to enable the short queries i.e. /var/www etc
 *
 * @author keith
 *  $Id$
 */
public class DefaultFSPath implements FSPath {

    /**
     *  Escape characters, we must escape any characters that are
     *  illegal in XML attribute text.
     *
     *  i.e. &amp; "" < >
     */
    private Map escapeChars;

    private DocumentBuilder documentBuilder;

    private XPath xpath;

    private Document dom;

    /**
     *  The date format used to correspond to the xs:date format i.e. yyyy-MM-dd'T'HH:mm:ss.SSS
     */
    private DateFormat format;

    private File rootDirectory;

    public DefaultFSPath() {
        //used for unit test instantiation
        this.xpath = XPathFactory.newInstance().newXPath();
        //this.xpath.setNamespaceContext(new FSNamespaceContext());
        //this effectively enables the user of our custom XPath function
        //fs:match()
        this.xpath.setXPathFunctionResolver(new RegexFunctionResolver());
        this.escapeChars = this.createEscapeCharsMap();
        this.format = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSS"");
    }

    /**
     * Creates a new instance of DefaultFSPath, based on the directory supplied
     */
    public DefaultFSPath(File currentDir) {
        this();
        this.rootDirectory = currentDir;
        //check if file is a directory
        if (!currentDir.isDirectory()) {
            throw new InstantiationError(""the java.io.File specified must be a Directory"");
        }
        try {
            this.createDocumentBuilder();
            //build DOM representation
            this.dom = this.buildDOM(currentDir);
        } catch (ParserConfigurationException pce) {
            pce.printStackTrace();
            throw new InstantiationError(""FSDom threw a ParserConfigurationException : "" + pce.getMessage());
        } catch (IOException ioe) {
            ioe.printStackTrace();
            throw new InstantiationError(""FSDom threw an IOException : "" + ioe.getMessage());
        }
    }

    protected Map createEscapeCharsMap() {
        Map<String, String> escapeChars = new HashMap<String, String>();
        escapeChars.put(""&"", ""&#26;"");
        escapeChars.put(""<"", ""&#3c;"");
        escapeChars.put("">"", ""&#3e;"");
        escapeChars.put(""\"""", ""&#22;"");
        return escapeChars;
    }

    protected void createDocumentBuilder() throws ParserConfigurationException {
        try {
            this.documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
        } catch (ParserConfigurationException pce) {
            pce.printStackTrace();
            throw pce;
        }
    }

    protected Document buildDOM(File currentDir) throws IOException {
        Document dom = this.documentBuilder.newDocument();
        dom.appendChild(this.createChildElement(dom, currentDir));
        return dom;
    }

    private Element createChildElement(Document dom, File currentFile) throws IOException {
        Element currentElement = null;
        if (currentFile.isDirectory()) {
            currentElement = dom.createElement(FSPathAttributes.dir.name());
            //recurse and create child elements for all its children
            File[] children = currentFile.listFiles();
            if (children != null) {
                for (int i = 0; i < children.length; i++) {
                    currentElement.appendChild(this.createChildElement(dom, children[i]));
                }
            }
        } else {
            currentElement = dom.createElement(FSPathAttributes.file.name());
        }
        currentElement.setAttribute(FSPathAttributes.name.name(), currentFile.getName());
        currentElement.setAttribute(FSPathAttributes.absolutePath.name(), currentFile.getAbsolutePath());
        //optional for speed?
        currentElement.setAttribute(FSPathAttributes.canRead.name(), Boolean.toString(currentFile.canRead()));
        //optional for speed?
        currentElement.setAttribute(FSPathAttributes.canWrite.name(), Boolean.toString(currentFile.canWrite()));
        currentElement.setAttribute(FSPathAttributes.canonicalPath.name(), currentFile.getCanonicalPath());
        //optional for speed?
        currentElement.setAttribute(FSPathAttributes.exists.name(), Boolean.toString(currentFile.exists()));
        currentElement.setAttribute(FSPathAttributes.isAbsolute.name(), Boolean.toString(currentFile.isAbsolute()));
        currentElement.setAttribute(FSPathAttributes.isDirectory.name(), Boolean.toString(currentFile.isDirectory()));
        currentElement.setAttribute(FSPathAttributes.isFile.name(), Boolean.toString(currentFile.isFile()));
        currentElement.setAttribute(FSPathAttributes.isHidden.name(), Boolean.toString(currentFile.isHidden()));
        currentElement.setAttribute(FSPathAttributes.lastModified.name(), this.format.format(new Date(currentFile.lastModified())));
        currentElement.setAttribute(FSPathAttributes.length.name(), Long.toString(currentFile.length()));
        currentElement.setAttribute(FSPathAttributes.parent.name(), currentFile.getParent());
        currentElement.setAttribute(FSPathAttributes.path.name(), currentFile.getPath());
        return currentElement;
    }

    /**
     *  Calls this.query(expression, XPathConstants.NODESET)
     *
     *  Note : This method MUST be passed an expression which returns a nodeset.
     *
     *  @param expression the FSPath expression to execute.
     *  @returns <code>FSPathResultList</code> the FSPathResult objects contained
     *  in this list will be of type <code>java.io.File</code>,
     *  <code>java.lang.Double</code>, <code>java.lang.Boolean</code>,
     *  <code>java.lang.String</code>
     */
    public FSPathResultList query(String expression) {
        return this.query(expression, XPathConstants.NODESET);
    }

    /**
     */
    public FSPathResultList query(String expression, QName returnType) {
        FSPathResultList results = new FSPathResultListImpl();
        try {
            if (XPathConstants.NODESET.equals(returnType)) {
                NodeList nodelist = (NodeList) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NODESET);
                if (nodelist.getLength() > 0) {
                    for (int i = 0; i < nodelist.getLength(); i++) {
                        processNode(nodelist.item(i), results);
                    }
                }
                return results;
            }
            if (XPathConstants.NODE.equals(returnType)) {
                Node node = (Node) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NODE);
                processNode(node, results);
                return results;
            }
            if (XPathConstants.BOOLEAN.equals(returnType)) {
                Boolean result = (Boolean) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.BOOLEAN);
                results.add(new FSPathResult(result));
                return results;
            }
            if (XPathConstants.NUMBER.equals(returnType)) {
                Double result = (Double) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NUMBER);
                results.add(new FSPathResult(result));
                return results;
            }
            if (XPathConstants.STRING.equals(returnType)) {
                String result = (String) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.STRING);
                results.add(new FSPathResult(result));
                return results;
            }
        } catch (XPathExpressionException xpee) {
            System.out.println(""Invalid FSPath expression : "" + xpee.getCause().getMessage());
        } catch (IllegalArgumentException iae) {
            iae.printStackTrace();
            System.out.println(""IllegalArgumentException"");
        } catch (ParseException pe) {
            pe.printStackTrace();
            System.out.println(""ParseException"");
        }
        return results;
    }

    private void processNode(Node node, FSPathResultList results) throws XPathExpressionException, IllegalArgumentException, ParseException {
        //as the only elements in our dom are files or directories we will try to
        //create File objects of those nodes.
        if (node.getNodeType() == Node.ELEMENT_NODE) {
            String fileName = node.getAttributes().getNamedItem(FSPathAttributes.absolutePath.name()).getNodeValue();
            //System.out.println(""Filename : "" + fileName);
            results.add(new FSPathResult(new File(fileName)));
            return;
        }
        if (node.getNodeType() == Node.ATTRIBUTE_NODE) {
            Attr attr = (Attr) node;
            //now work out which attirutes were Dates, Longs and Strings
            if (FSPathAttributes.absolutePath.name().equals(attr.getName()) | FSPathAttributes.canonicalPath.name().equals(attr.getName()) | FSPathAttributes.name.name().equals(attr.getName()) | FSPathAttributes.parent.name().equals(attr.getName()) | FSPathAttributes.path.name().equals(attr.getName())) {
                results.add(new FSPathResult(attr.getValue()));
                return;
            }
            if (FSPathAttributes.canRead.name().equals(attr.getName()) | FSPathAttributes.canWrite.name().equals(attr.getName()) | FSPathAttributes.exists.name().equals(attr.getName()) | FSPathAttributes.isAbsolute.name().equals(attr.getName()) | FSPathAttributes.isDirectory.name().equals(attr.getName()) | FSPathAttributes.isFile.name().equals(attr.getName()) | FSPathAttributes.isHidden.name().equals(attr.getName())) {
                results.add(new FSPathResult(new Boolean(attr.getValue())));
                return;
            }
            if (FSPathAttributes.lastModified.name().equals(attr.getName())) {
                results.add(new FSPathResult(this.format.parse(attr.getValue())));
                return;
            }
            if (FSPathAttributes.length.name().equals(attr.getName())) {
                results.add(new FSPathResult(Double.parseDouble(attr.getValue())));
                return;
            }
        }
    }

    public File getRootDirectory() {
        return this.rootDirectory;
    }
}
","// DefaultFSPath_0Test.java
/*
 * DefaultFSPath.java
 *
 * Created on 18 September 2006, 00:25
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.IOException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import javax.xml.namespace.QName;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import net.sf.sugar.fspath.xpath.RegexFunctionResolver;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultFSPath}.
* It contains ten unit test cases for the {@link DefaultFSPath#query(String)} method.
*/
class DefaultFSPath_0Test {","// DefaultFSPath_0Test.java
/*
 * DefaultFSPath.java
 *
 * Created on 18 September 2006, 00:25
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.IOException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import javax.xml.namespace.QName;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import net.sf.sugar.fspath.xpath.RegexFunctionResolver;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultFSPath}.
* It contains ten unit test cases for the {@link DefaultFSPath#query(String)} method.
*/
class DefaultFSPath_0Test {

		private static final String TEST_DIR = ""test/net/sf/sugar/fspath/"";
		
		private static final String TEST_DIR_1 = TEST_DIR + ""test1/"";
		
		private static final String TEST_DIR_2 = TEST_DIR + ""test2/"";
		
		private static final String TEST_DIR_3 = TEST_DIR + ""test3/"";
		
		private static final String TEST_DIR_4 = TEST_DIR + ""test4/"";
		
		private static final String TEST_DIR_5 = TEST_DIR + ""test5/"";
		
		private static final String TEST_DIR_6 = TEST_DIR + ""test6/"";
		
		private static final String TEST_DIR_7 = TEST_DIR + ""test7/"";
		
		private static final String TEST_DIR_8 = TEST_DIR + ""test8/"";
		
		private static final String TEST_DIR_9 = TEST_DIR + ""test9/"";
		
		private static final String TEST_DIR_10 = TEST_DIR + ""test10/"";
		
		private static final String TEST_DIR_11 = TEST_DIR + ""test11/"";
		
		private static final String TEST_DIR_12 = TEST_DIR + ""test12/"";
		
		private static final String TEST_DIR_13 = TEST_DIR + ""test13/"";
		
		private static final String TEST_DIR_14 = TEST_DIR + ""test14/"";
		
		private static final String TEST_DIR_15 = TEST_DIR + ""test15/"";
		
		private static final String TEST_DIR_16 = TEST_DIR + ""test16/"";
		
		private static final String TEST_DIR_17 = TEST_DIR + ""test17/"";
		
		private static final String TEST_DIR_18 = TEST_DIR + ""test18/"";
		
		private static final String TEST_DIR_19 = TEST_DIR + ""test19/"";
		
		private static final String TEST_DIR_20 = TEST_DIR + ""test20/"";
		
		private static final String TEST_DIR_21 = TEST_DIR + ""test21/"";
		
		private static final String TEST_DIR_22 = TEST_DIR + ""test22/"";
		
		private static final String TEST_DIR_23 = TEST_DIR + ""test23/"";
		
		private static final String TEST_DIR_24 = TEST_DIR + ""test24/"";
		
		private static final String TEST_DIR_25 = TEST_DIR + ""test25/"";
		
		private static final String TEST_DIR_26 = TEST_DIR + ""test26/"";
		
		private static final String TEST_DIR_27 = TEST_DIR + ""test27/"";
		
		private static final String TEST_DIR_28 = TEST_DIR + ""test28/"";
		
		private static final String TEST_DIR_29 = TEST_DIR + ""test29/"";
		
		private static final String TEST_DIR_30 = TEST_DIR + ""test30/"";
		
		private static final String TEST_DIR_31 = TEST_DIR + ""test31/"";
		
		private static final String TEST_DIR_32 = TEST_DIR + ""test32/"";
		
		private static final String TEST_DIR_33 = TEST_DIR + ""test33/"";
		
		private static final String TEST_DIR_34 = TEST_DIR + ""test34/"";
		
		private static final String TEST_DIR_35 = TEST_DIR + ""test35/"";
		
		private static final String TEST_DIR_36 = TEST_DIR + ""test36/"";
		
		private static final String TEST_DIR_37 = TEST_DIR + ""test37/"";
		
		private static final String TEST_DIR_38 = TEST_DIR + ""test38/"";
		
		private static final String TEST_DIR_39 = TEST_DIR + ""test39/"";
		
		private static final String TEST_DIR_40 = TEST_DIR + ""test40/"";
		
		private static final String TEST_DIR_41 = TEST_DIR + ""test41/"";
		
		private static final String TEST_DIR_42 = TEST_DIR + ""test42/"";
		
		private static final String TEST_DIR_43 = TEST_DIR + ""test43/"";
		
		private static final String TEST_DIR_44 = TEST_DIR + ""test44/"";
		
		private static final String TEST_DIR_45 = TEST_DIR + ""test45/"";
		
		private static final String TEST_DIR_46 = TEST_DIR + ""test46/"";
		
		private static final String TEST_DIR_47 = TEST_DIR + ""test47/"";
		
		private static final String TEST_DIR_48 = TEST_DIR + ""test48/"";
		
		private static final String TEST_DIR_49 = TEST_DIR + ""test49/"";
		
		private static final String TEST_DIR_50 = TEST_DIR + ""test50/"";
		
		private static final String TEST_DIR_51 = TEST_DIR + ""test51/"";
		
		private static final String TEST_DIR_52 = TEST_DIR + ""test52/"";
		
		private static final String TEST_DIR_53 = TEST_DIR + ""test53/"";
		
		private static final String TEST_DIR_54 = TEST_DIR + ""test54/"";
		
		private static final String TEST_DIR_55 = TEST_DIR + ""test55/"";
		
		private static final String TEST_DIR_56 = TEST_DIR + ""test56/"";
		
		private static final String TEST_DIR_57 = TEST_DIR + ""test57/"";
		
		private static final String TEST_DIR_58 = TEST_DIR + ""test58/"";
		
		private static final String TEST_DIR_59 = TEST_DIR + ""test59/"";
		
		private static final String TEST_DIR_60 = TEST_DIR + ""test60/"";
		
		private static final String TEST_DIR_61 = TEST_DIR + ""test61/"";
		
		private static final String TEST_DIR_62 = TEST_DIR + ""test62/"";
		
		private static final String TEST_DIR_63 = TEST_DIR + ""test63/"";
		
		private static final String TEST_DIR_64 = TEST_DIR + ""test64/"";
		
		private static final String TEST_DIR_65 = TEST_DIR + ""test65/"";
		
		private static final String TEST_DIR_66 = TEST_DIR + ""test66/"";
		
		private static final String TEST_DIR_67 = TEST_DIR + ""test67/"";
		
		private static final String TEST_DIR_68 = TEST_DIR + ""test68/"";
		
		private static final String TEST_DIR_69 = TEST_DIR + ""test69/"";
		
		private static final String TEST_DIR_70 = TEST_DIR + ""test70/"";
		
		private static final String TEST_DIR_71 = TEST_DIR + ""test71/"";
		
		private static final String TEST_DIR_72 = TEST_DIR + ""test72/"";
		
		private static final String TEST_DIR_73 = TEST_DIR + ""test73/"";
		
		private static final String TEST_DIR_74 = TEST_DIR + ""test74/"";
		
		private static final String TEST_DIR_75 = TEST_DIR + ""test75/"";
		
		private static final String TEST_DIR_76 = TEST_DIR + ""test76/"";
		
		private static final String TEST_DIR_77 = TEST_DIR + ""test77/"";
		
		private static final String TEST_DIR_78 = TEST_DIR + ""test78/"";
		
		private static final String TEST_DIR_79 = TEST_DIR + ""test79/"
cmpl-6wV0dKEI7IcAUKr3hX6ZeXoxLKO5r,/EvoSuiteBenchmark/original/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathFactory_0Test.java,58.403406381607056,length,"// FSPathFactory.java
/**
 * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)
 *
 * All rights reserved.
 *
 * This file is part of FSPath.
 *
 * FSPath is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FSPath is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * FSPathFactory.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;

/**
 * @author kbishop
 */
public class FSPathFactory {

    /**
     * Creates a new instance of FSPathFactory
     */
    public FSPathFactory() {
    }

    /**
     *  @returns FSPath a new DefaultFSPath instance which uses the current user directory (System.getProperty(""user.dir"")) to search from.
     */
    public static FSPath newFSPath() {
        return new DefaultFSPath(new File(System.getProperty(""user.dir"")));
    }

    /**
     *  @returns FSPath a new DefaultFSPath instance which uses the directory provided to search from.
     */
    public static FSPath newFSPath(File file) {
        return new DefaultFSPath(file);
    }

    /**
     *  @returns FSPath a new DefaultFSPath instance which uses the directory path String provided to search from.
     */
    public static FSPath newFSPath(String path) {
        return new DefaultFSPath(new File(path));
    }
}
","// FSPathFactory_0Test.java
/*
 * FSPathFactory.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathFactory}.
* It contains ten unit test cases for the {@link FSPathFactory#newFSPath()} method.
*/
class FSPathFactory_0Test {","// FSPathFactory_0Test.java
/*
 * FSPathFactory.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathFactory}.
* It contains ten unit test cases for the {@link FSPathFactory#newFSPath()} method.
*/
class FSPathFactory_0Test {

	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath() {
		System.out.println(""newFSPath"");
		FSPath result = FSPathFactory.newFSPath();
		assertNotNull(result);
		assertEquals(new File(System.getProperty(""user.dir"")), result.getFile());
	}
}

// FSPathFactory_1Test.java
/*
 * FSPathFactory.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathFactory}.
* It contains ten unit test cases for the {@link FSPathFactory#newFSPath(File)} method.
*/
class FSPathFactory_1Test {
		
	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath() {
		System.out.println(""newFSPath"");
		File file = new File(""."");
		FSPath result = FSPathFactory.newFSPath(file);
		assertNotNull(result);
		assertEquals(file, result.getFile());
	}
}

// FSPathFactory_2Test.java
/*
 * FSPathFactory.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathFactory}.
* It contains ten unit test cases for the {@link FSPathFactory#newFSPath(String)} method.
*/
class FSPathFactory_2Test {
		
	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath() {
		System.out.println(""newFSPath"");
		String path = ""."";
		FSPath result = FSPathFactory.newFSPath(path);
		assertNotNull(result);
		assertEquals(new File(path), result.getFile());
	}
}

// FSPath_0Test.java
/*
 * FSPath.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPath}.
* It contains ten unit test cases for the {@link FSPath#getFile()} method.
*/
class FSPath_0Test {
		
	/**
	 * Test of getFile method, of class FSPath.
	 */
	@Test
	void testGetFile() {
		System.out.println(""getFile"");
		FSPath instance = FSPathFactory.newFSPath();
		File expResult = new File(System.getProperty(""user.dir""));
		File result = instance.getFile();
		assertEquals(expResult, result);
	}
}

// FSPath_1Test.java
/*
 * FSPath.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPath}.
* It contains ten unit test cases for the {@link FSPath#getPath()} method.
*/
class FSPath_1Test {
		
	/**
	 * Test of getPath method, of class FSPath.
	 */
	@Test
	void testGetPath() {
		System.out.println(""getPath"");
		FSPath instance = FSPathFactory.newFSPath();
		String expResult = System.getProperty(""user.dir"");
		String result = instance.getPath();
		assertEquals(expResult, result);
	}
}

// FSPath_2Test.java
/*
 * FSPath.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPath}.
* It contains ten unit test cases for the {@link FSPath#getName()} method.
*/
class FSPath_2Test {
		
	/**
	 * Test of getName method, of class FSPath.
	 */
	@Test
	void testGetName() {
		System.out.println(""getName"");
		FSPath instance = FSPathFactory.newFSPath();
		String expResult = new File(System.getProperty(""user.dir"")).getName();
		String result = instance.getName();
		assertEquals(expResult, result);
	}
}

// FSPath_3Test.java
/*
 * FSPath.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPath}.
* It contains ten unit test cases for the {@link FSPath#getParent()} method.
*/
class FSPath_3Test {
		
	/**
	 * Test of getParent method, of class FSPath.
	 */
	@Test
	void testGetParent() {
		System.out.println(""getParent"");
		FSPath instance = FSPathFactory.newFSPath();
		FSPath expResult = FSPathFactory.newFSPath(new File(System.getProperty(""user.dir"")).getParent());
		FSPath result = instance.getParent();
		assertEquals(expResult, result);
	}
}

// FSPath_4Test.java
/*
 * FSPath.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPath}.
* It contains ten unit test cases for the {@link FSPath#getParentPath()} method.
*/
class FSPath_4Test {
		
	/**
	 * Test of getParentPath method, of class FSPath.
	 */
	@Test
	void testGetParentPath() {
		System.out.println(""getParent"
cmpl-6wV1g5pq9FQS8Dg66u1f7Ft1Y3w6a,/EvoSuiteBenchmark/original/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathResultListImpl_0Test.java,58.6618492603302,length,"// FSPathResultListImpl.java
/**
 * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)
 *
 * All rights reserved.
 *
 * This file is part of FSPath.
 *
 * FSPath is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FSPath is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @author kbishop
 * @version $Id$
 */
public class FSPathResultListImpl extends ArrayList<FSPathResult> implements FSPathResultList {

    /**
     * Creates a new instance of FSPathResultListImpl
     */
    public FSPathResultListImpl() {
    }

    /**
     *  A convenience method for defining custom filesystem interaction
     *  across the whole list of results.
     *
     *  This method loops through the results and calls the call(Result result)
     *  method of the Callback class passed to it for each individual result.
     *
     *  @param Callback - a custom implementation of the Callback interface.
     *  @throws IOException
     */
    public FSPathResultList each(Callback callback) throws IOException {
        for (FSPathResult result : this) {
            callback.call(result);
        }
        return this;
    }

    /**
     *  Deletes each file contained in this FSPathResultList.
     *  <br/>
     *  <pre>
     *  ************************************************************************
     *  *               IMPORTANT !!!!!    Use with caution                    *
     *  *   This method makes it extremely easy to trash your filesystem       *
     *  *   Its advised that FSPath queries are tested thouroughly before use  *
     *  *   in order to verify which files would be deleted                    *
     *  *                                                                      *
     *  ************************************************************************
     *  </pre>
     *  @returns FSPathResultModificationListImpl - all successfully deleted files<br/>
     *  will be added as a success, and the failures will be added as failures.
     *
     *  @throws IOException - NOTE this method does not currently thrown an IOException
     *  @throws OperationNotPermittedException - this exception will be thrown if<br/>
     *  The FSPathResult objects contained in this FSPathResultList don't contain<br/>
     *  java.io.File objects<br/>
     *  (i.e the FSPath query was written to return Boolean, String nor numerical results).
     */
    public FSPathResultModificationList delete() throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Delete is only permitted on FSPathResult objects containing a File object"");
        }
        FSPathResultModificationList deletionList = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            try {
                File file = result.getFile();
                boolean success = file.delete();
                if (success) {
                    deletionList.addSuccess(result);
                } else {
                    deletionList.addFailure(result);
                }
            } catch (Exception e) {
                //todo: log this ?
                deletionList.addFailure(result);
            }
        }
        return deletionList;
    }

    /**
     *  This method will copy each file contained in this FSPathResultList to the
     *  destination path supplied.
     *
     *  @param String - the destination path which you would like to copy files to.
     *
     *  @returns FSPathResultModificationListImpl - all successfully copied files
     *  will be added as a success, and the failures will be added as failures.
     *
     *  @param String the absolute or realtive path of the destination Directory
     *  @throws IOException - NOTE this is currently not thrown by this method.
     *  @throws OperationNotPermittedException - this exception is thrown upon
     *  the following conditions :<br/>
     *  <br/>
     *  1)  The FSPathResult objects contained in this FSPathResultList don't contain<br/>
     *      java.io.File objects<br/>
     *      (i.e the FSPath query was written to return Boolean, String nor numerical results).<br/>
     *  2)  The directory denoted by the destination path doesn't exist.<br/>
     *  3)  The destination path doesn't resolve to a directory.<br/>
     *  4)  The destination path isn't writeable.<br/>
     *  5)  The current java process doesn't have sufficient priveledges to<br/>
     *      access the destination path.<br/>
     */
    public FSPathResultModificationList copy(String destinationDirPath) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Copy is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        File destinationDir = new File(destinationDirPath);
        try {
            if (!destinationDir.exists()) {
                throw new OperationNotPermittedException(""Unable to copy to a directory that doesn't exist"");
            }
            if (!destinationDir.isDirectory()) {
                throw new OperationNotPermittedException(""Destination path "" + destinationDir.getAbsolutePath() + "" does not resolve to a directory"");
            }
            if (!destinationDir.canWrite()) {
                throw new OperationNotPermittedException(""Desination path "" + destinationDir.getAbsolutePath() + "" is not writable"");
            }
        } catch (SecurityException se) {
            throw new OperationNotPermittedException(""The current process does not have sufficent priveledges to access "" + destinationDir.getAbsolutePath(), se);
        }
        FSPathResultModificationList results = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            File destinationFile = new File(destinationDir + result.getFile().getName());
            try {
                FileReader inputReader = new FileReader(result.getFile());
                FileWriter outputReader = new FileWriter(destinationFile);
                int charsRead = 0;
                while ((charsRead = inputReader.read()) != -1) {
                    outputReader.write(charsRead);
                }
                inputReader.close();
                outputReader.close();
                results.addSuccess(new FSPathResult(destinationFile));
            } catch (Exception e) {
                results.addFailure(new FSPathResult(destinationFile));
            }
        }
        return results;
    }

    public boolean isListOfFiles() {
        return (this.size() > 0 && this.get(0).getFile() != null);
    }

    /**
     *  Renames each file in the FSPathResultList based on a regex match
     *  expression and a replace expression.
     *  <br/>
     *  This method is designed to enable simple renaming i.e. renaming from<br/>
     *  ""a.txt"" to ""b.txt"" but also complex renaming using regular expressions.<br/>
     *  <br/>
     *  Example simple renaming : <br/>
     *  <pre>fspath.query(""/dir[@name='logs']/file[@name='error.log']"").rename(""error.log"", ""error.log.1"");</pre> <br/>
     *  This would work fine for a single file but not much use for multiple files.<br/>
     *  <br/>
     *  Example complex renaming : <br/>
     *  <br/>
     *  Imagine a directory full of files with a format such as : <br/>
     *  <pre>
     *  appLog-01_01_2008.log.1
     *  appLog-01_01_2008.log.2
     *  ...
     *  </pre>
     *  Now imagine that we wanted to rename the files so that they end in .log but they also keep their<br/>
     *  uniqueness (i.e. the number at the end of the file needs to move to a new position in the filename)<br/>
     *  <br/>
     *  The following code expression would work :<br/>
     *  <pre>fspath.query(""dir[@name = 'logs']/file"").rename(""(.*)\.log\.([0-9]+)"", ""$1_$2.log"");</pre> <br/>
     *  Here the matchExpression has two capturing groups, one being everything up to the '.log' in the filename, <br/>
     *  and the other being the number after the "".log."" .<br/>
     *  The replace expression simply specifies that the new file name will have the text in the first capturing group,<br/>
     *  followed by a ""_"" then the text in the second capturing group and then "".log"".
     */
    public FSPathResultModificationList rename(String matchExpression, String replaceExpresion) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Copy is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        Pattern pattern = Pattern.compile(matchExpression);
        FSPathResultModificationList results = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            File origFile = null;
            File newFile = null;
            try {
                origFile = result.getFile();
                Matcher matcher = pattern.matcher(origFile.getName());
                String newName = matcher.replaceAll(replaceExpresion);
                newFile = new File(newName);
                origFile.renameTo(newFile);
                results.addSuccess(new FSPathResult(newFile));
            } catch (Exception e) {
                results.addFailure(new FSPathResult(newFile));
            }
        }
        return results;
    }

    /**
     *  Moves each file in the list to the specified desination path.
     *
     *  This method effecively calls copy() and then delete() on itself.
     *  If any file fails to sucessfully copy, then this method 'fails fast'
     *  and returns the results of the copy. This should prevent the situation arising
     *  where the copied files are completely deleted.
     *  If the copy suceeds, then it will attempt to delete the original files.
     *
     *  @param String - the directory path to move the files to.
     *  @throws OperationNotPermittedException - see the comments for <code>copy</code>
     */
    public FSPathResultModificationList move(String destinationPath) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""move is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        FSPathResultModificationList copyResults = this.copy(destinationPath);
        //if we detect a failure then cease what we're doing and return the results so far
        if (copyResults.hasFailures()) {
            return copyResults;
        }
        //if we're happy with the copy, delete the original files,
        //and return the results of the deletion
        return this.delete();
    }
}
","// FSPathResultListImpl_0Test.java
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathResultListImpl}.
* It contains ten unit test cases for the {@link FSPathResultListImpl#each(Callback)} method.
*/
class FSPathResultListImpl_0Test {","// FSPathResultListImpl_0Test.java
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathResultListImpl}.
* It contains ten unit test cases for the {@link FSPathResultListImpl#each(Callback)} method.
*/
class FSPathResultListImpl_0Test {

	/**
	 * Test of each method, of class FSPathResultListImpl.
	 */
	@Test
	void testEach() throws Exception {
		System.out.println(""each"");
		Callback callback = null;
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultList expResult = null;
		FSPathResultList result = instance.each(callback);
		assertEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.delete();
		assertEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
	/**
	 * Test of copy method, of class FSPathResultListImpl.
	 */
	@Test
	void testCopy() throws Exception {
		System.out.println(""copy"");
		String destinationDirPath = """";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.copy(destinationDirPath);
		assertEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
	/**
	 * Test of isListOfFiles method, of class FSPathResultListImpl.
	 */
	@Test
	void testIsListOfFiles() {
		System.out.println(""isListOfFiles"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		boolean expResult = false;
		boolean result = instance.isListOfFiles();
		assertEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
	/**
	 * Test of rename method, of class FSPathResultListImpl.
	 */
	@Test
	void testRename() throws Exception {
		System.out.println(""rename"");
		String matchExpression = """";
		String replaceExpresion = """";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.rename(matchExpression, replaceExpresion);
		assertEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
	/**
	 * Test of move method, of class FSPathResultListImpl.
	 */
	@Test
	void testMove() throws Exception {
		System.out.println(""move"");
		String destinationPath = """";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.move(destinationPath);
		assertEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
}

// FSPathResultListImpl_1Test.java
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathResultListImpl}.
* It contains ten unit test cases for the {@link FSPathResultListImpl#each(Callback)} method.
*/
class FSPathResultListImpl_1Test {
		
	/**
	 * Test of each method, of class FSPathResultListImpl.
	 */
	@Test
	void testEach() throws Exception {
		System.out.println(""each"");
		Callback callback = null;
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultList expResult = null;
		FSPathResultList result = instance.each(callback);
		assertEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.delete();
		assertEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
	/**
	 * Test of copy method, of class FSPathResultListImpl.
	 */
	@Test
	void testCopy() throws Exception {
		System.out.println(""copy"");
		String destinationDirPath = """";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.copy(destinationDirPath);
		assertEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
	/**
	 * Test of isListOfFiles method, of class FSPathResultListImpl.
	 */
	@Test
	void testIsListOfFiles() {
		System.out.println(""isListOfFiles"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		boolean expResult = false;
		boolean result = instance.isListOfFiles();
		assertEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
	/**
	 * Test of rename method, of class FSPathResultListImpl.
	 */
	@Test
	void testRename() throws Exception {
		System.out.println(""rename"");
		String matchExpression = """";
		String replaceExpresion = """";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.rename(matchExpression, replaceExpresion);
		assertEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
	/**
	 * Test of move method, of class FSPathResultListImpl.
	 */
	@Test
	void testMove() throws Exception {
		System.out.println(""move"");
		String destinationPath ="
cmpl-6wV2j02bRni3xAiVZpU9CupSRld9L,/EvoSuiteBenchmark/original/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathResultListImpl_1Test.java,64.15224647521973,length,"// FSPathResultListImpl.java
/**
 * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)
 *
 * All rights reserved.
 *
 * This file is part of FSPath.
 *
 * FSPath is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FSPath is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @author kbishop
 * @version $Id$
 */
public class FSPathResultListImpl extends ArrayList<FSPathResult> implements FSPathResultList {

    /**
     * Creates a new instance of FSPathResultListImpl
     */
    public FSPathResultListImpl() {
    }

    /**
     *  A convenience method for defining custom filesystem interaction
     *  across the whole list of results.
     *
     *  This method loops through the results and calls the call(Result result)
     *  method of the Callback class passed to it for each individual result.
     *
     *  @param Callback - a custom implementation of the Callback interface.
     *  @throws IOException
     */
    public FSPathResultList each(Callback callback) throws IOException {
        for (FSPathResult result : this) {
            callback.call(result);
        }
        return this;
    }

    /**
     *  Deletes each file contained in this FSPathResultList.
     *  <br/>
     *  <pre>
     *  ************************************************************************
     *  *               IMPORTANT !!!!!    Use with caution                    *
     *  *   This method makes it extremely easy to trash your filesystem       *
     *  *   Its advised that FSPath queries are tested thouroughly before use  *
     *  *   in order to verify which files would be deleted                    *
     *  *                                                                      *
     *  ************************************************************************
     *  </pre>
     *  @returns FSPathResultModificationListImpl - all successfully deleted files<br/>
     *  will be added as a success, and the failures will be added as failures.
     *
     *  @throws IOException - NOTE this method does not currently thrown an IOException
     *  @throws OperationNotPermittedException - this exception will be thrown if<br/>
     *  The FSPathResult objects contained in this FSPathResultList don't contain<br/>
     *  java.io.File objects<br/>
     *  (i.e the FSPath query was written to return Boolean, String nor numerical results).
     */
    public FSPathResultModificationList delete() throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Delete is only permitted on FSPathResult objects containing a File object"");
        }
        FSPathResultModificationList deletionList = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            try {
                File file = result.getFile();
                boolean success = file.delete();
                if (success) {
                    deletionList.addSuccess(result);
                } else {
                    deletionList.addFailure(result);
                }
            } catch (Exception e) {
                //todo: log this ?
                deletionList.addFailure(result);
            }
        }
        return deletionList;
    }

    /**
     *  This method will copy each file contained in this FSPathResultList to the
     *  destination path supplied.
     *
     *  @param String - the destination path which you would like to copy files to.
     *
     *  @returns FSPathResultModificationListImpl - all successfully copied files
     *  will be added as a success, and the failures will be added as failures.
     *
     *  @param String the absolute or realtive path of the destination Directory
     *  @throws IOException - NOTE this is currently not thrown by this method.
     *  @throws OperationNotPermittedException - this exception is thrown upon
     *  the following conditions :<br/>
     *  <br/>
     *  1)  The FSPathResult objects contained in this FSPathResultList don't contain<br/>
     *      java.io.File objects<br/>
     *      (i.e the FSPath query was written to return Boolean, String nor numerical results).<br/>
     *  2)  The directory denoted by the destination path doesn't exist.<br/>
     *  3)  The destination path doesn't resolve to a directory.<br/>
     *  4)  The destination path isn't writeable.<br/>
     *  5)  The current java process doesn't have sufficient priveledges to<br/>
     *      access the destination path.<br/>
     */
    public FSPathResultModificationList copy(String destinationDirPath) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Copy is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        File destinationDir = new File(destinationDirPath);
        try {
            if (!destinationDir.exists()) {
                throw new OperationNotPermittedException(""Unable to copy to a directory that doesn't exist"");
            }
            if (!destinationDir.isDirectory()) {
                throw new OperationNotPermittedException(""Destination path "" + destinationDir.getAbsolutePath() + "" does not resolve to a directory"");
            }
            if (!destinationDir.canWrite()) {
                throw new OperationNotPermittedException(""Desination path "" + destinationDir.getAbsolutePath() + "" is not writable"");
            }
        } catch (SecurityException se) {
            throw new OperationNotPermittedException(""The current process does not have sufficent priveledges to access "" + destinationDir.getAbsolutePath(), se);
        }
        FSPathResultModificationList results = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            File destinationFile = new File(destinationDir + result.getFile().getName());
            try {
                FileReader inputReader = new FileReader(result.getFile());
                FileWriter outputReader = new FileWriter(destinationFile);
                int charsRead = 0;
                while ((charsRead = inputReader.read()) != -1) {
                    outputReader.write(charsRead);
                }
                inputReader.close();
                outputReader.close();
                results.addSuccess(new FSPathResult(destinationFile));
            } catch (Exception e) {
                results.addFailure(new FSPathResult(destinationFile));
            }
        }
        return results;
    }

    public boolean isListOfFiles() {
        return (this.size() > 0 && this.get(0).getFile() != null);
    }

    /**
     *  Renames each file in the FSPathResultList based on a regex match
     *  expression and a replace expression.
     *  <br/>
     *  This method is designed to enable simple renaming i.e. renaming from<br/>
     *  ""a.txt"" to ""b.txt"" but also complex renaming using regular expressions.<br/>
     *  <br/>
     *  Example simple renaming : <br/>
     *  <pre>fspath.query(""/dir[@name='logs']/file[@name='error.log']"").rename(""error.log"", ""error.log.1"");</pre> <br/>
     *  This would work fine for a single file but not much use for multiple files.<br/>
     *  <br/>
     *  Example complex renaming : <br/>
     *  <br/>
     *  Imagine a directory full of files with a format such as : <br/>
     *  <pre>
     *  appLog-01_01_2008.log.1
     *  appLog-01_01_2008.log.2
     *  ...
     *  </pre>
     *  Now imagine that we wanted to rename the files so that they end in .log but they also keep their<br/>
     *  uniqueness (i.e. the number at the end of the file needs to move to a new position in the filename)<br/>
     *  <br/>
     *  The following code expression would work :<br/>
     *  <pre>fspath.query(""dir[@name = 'logs']/file"").rename(""(.*)\.log\.([0-9]+)"", ""$1_$2.log"");</pre> <br/>
     *  Here the matchExpression has two capturing groups, one being everything up to the '.log' in the filename, <br/>
     *  and the other being the number after the "".log."" .<br/>
     *  The replace expression simply specifies that the new file name will have the text in the first capturing group,<br/>
     *  followed by a ""_"" then the text in the second capturing group and then "".log"".
     */
    public FSPathResultModificationList rename(String matchExpression, String replaceExpresion) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Copy is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        Pattern pattern = Pattern.compile(matchExpression);
        FSPathResultModificationList results = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            File origFile = null;
            File newFile = null;
            try {
                origFile = result.getFile();
                Matcher matcher = pattern.matcher(origFile.getName());
                String newName = matcher.replaceAll(replaceExpresion);
                newFile = new File(newName);
                origFile.renameTo(newFile);
                results.addSuccess(new FSPathResult(newFile));
            } catch (Exception e) {
                results.addFailure(new FSPathResult(newFile));
            }
        }
        return results;
    }

    /**
     *  Moves each file in the list to the specified desination path.
     *
     *  This method effecively calls copy() and then delete() on itself.
     *  If any file fails to sucessfully copy, then this method 'fails fast'
     *  and returns the results of the copy. This should prevent the situation arising
     *  where the copied files are completely deleted.
     *  If the copy suceeds, then it will attempt to delete the original files.
     *
     *  @param String - the directory path to move the files to.
     *  @throws OperationNotPermittedException - see the comments for <code>copy</code>
     */
    public FSPathResultModificationList move(String destinationPath) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""move is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        FSPathResultModificationList copyResults = this.copy(destinationPath);
        //if we detect a failure then cease what we're doing and return the results so far
        if (copyResults.hasFailures()) {
            return copyResults;
        }
        //if we're happy with the copy, delete the original files,
        //and return the results of the deletion
        return this.delete();
    }
}
","// FSPathResultListImpl_1Test.java
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathResultListImpl}.
* It contains ten unit test cases for the {@link FSPathResultListImpl#delete()} method.
*/
class FSPathResultListImpl_1Test {","// FSPathResultListImpl_1Test.java
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathResultListImpl}.
* It contains ten unit test cases for the {@link FSPathResultListImpl#delete()} method.
*/
class FSPathResultListImpl_1Test {

	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList result = instance.delete();
		assertTrue(result.getSuccesses().isEmpty());
		assertTrue(result.getFailures().isEmpty());
	}

	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete_1() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""/tmp/test.txt"")));
		FSPathResultModificationList result = instance.delete();
		assertTrue(result.getSuccesses().isEmpty());
		assertTrue(result.getFailures().isEmpty());
	}

	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete_2() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""/tmp/test.txt"")));
		FileWriter writer = new FileWriter(new File(""/tmp/test.txt""));
		writer.write(""test"");
		writer.close();
		FSPathResultModificationList result = instance.delete();
		assertTrue(result.getSuccesses().size() == 1);
		assertTrue(result.getFailures().isEmpty());
	}

	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete_3() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""/tmp/test.txt"")));
		instance.add(new FSPathResult(new File(""/tmp/test2.txt"")));
		FileWriter writer = new FileWriter(new File(""/tmp/test.txt""));
		writer.write(""test"");
		writer.close();
		writer = new FileWriter(new File(""/tmp/test2.txt""));
		writer.write(""test"");
		writer.close();
		FSPathResultModificationList result = instance.delete();
		assertTrue(result.getSuccesses().size() == 2);
		assertTrue(result.getFailures().isEmpty());
	}

	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete_4() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""/tmp/test.txt"")));
		instance.add(new FSPathResult(new File(""/tmp/test2.txt"")));
		FileWriter writer = new FileWriter(new File(""/tmp/test.txt""));
		writer.write(""test"");
		writer.close();
		FSPathResultModificationList result = instance.delete();
		assertTrue(result.getSuccesses().size() == 1);
		assertTrue(result.getFailures().size() == 1);
	}

	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete_5() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""/tmp/test.txt"")));
		instance.add(new FSPathResult(new File(""/tmp/test2.txt"")));
		FileWriter writer = new FileWriter(new File(""/tmp/test.txt""));
		writer.write(""test"");
		writer.close();
		writer = new FileWriter(new File(""/tmp/test2.txt""));
		writer.write(""test"");
		writer.close();
		FSPathResultModificationList result = instance.delete();
		assertTrue(result.getSuccesses().size() == 2);
		assertTrue(result.getFailures().isEmpty());
	}

	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete_6() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""/tmp/test.txt"")));
		instance.add(new FSPathResult(new File(""/tmp/test2.txt"")));
		FileWriter writer = new FileWriter(new File(""/tmp/test.txt""));
		writer.write(""test"");
		writer.close();
		writer = new FileWriter(new File(""/tmp/test2.txt""));
		writer.write(""test"");
		writer.close();
		FSPathResultModificationList result = instance.delete();
		assertTrue(result.getSuccesses().size() == 2);
		assertTrue(result.getFailures().isEmpty());
	}

	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete_7() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""/tmp/test.txt"")));
		instance.add(new FSPathResult(new File(""/tmp/test2.txt"")));
		FileWriter writer = new FileWriter(new File(""/tmp/test.txt""));
		writer.write(""test"");
		writer.close();
		writer = new FileWriter(new File(""/tmp/test2.txt""));
		writer.write(""test"");
		writer.close();
		FSPathResultModificationList result = instance.delete();
		assertTrue(result.getSuccesses().size() == 2);
		assertTrue(result.getFailures().isEmpty());
	}

	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete_8() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""/tmp/test.txt"")));
		instance.add(new FSPathResult(new File(""/tmp/test2.txt"")));
		FileWriter writer = new FileWriter(new File(""/tmp/test.txt""));
		writer.write(""test"");
		writer.close();
		writer = new FileWriter(new File(""/tmp/test2.txt""));
		writer.write(""test"");
		writer.close();
		FSPathResultModificationList result = instance.delete();
		assertTrue(result.getSuccesses().size() == 2);
		assertTrue(result.getFailures().isEmpty());
	}

	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete_9() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""/tmp/test.txt"")));
		instance.add(new FSPathResult(new File(""/tmp/test2.txt"")));
		FileWriter writer = new FileWriter(new File(""/tmp/test.txt""));
"
