[
{
    "id": "cmpl-6woDns7xCI1yak6cwlyfilBxeZU6h",
    "object": "text_completion",
    "created": 1679474095,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\t/**\n\t\t* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.\n\t\t* It tests if the method returns a new instance of {@link ExplorerModel}.\n\t\t*/\n\t\t@Test\n\t\tvoid testCreateNewExplorerModelWithFigure() {\n\t\t\t\tExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();\n\t\t\t\tExplorerModel result = instance.createNewExplorerModelWithFigure();\n\t\t\t\tassertNotNull(result);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.\n\t\t* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure}.\n\t\t*/\n\t\t@Test\n\t\tvoid testCreateNewExplorerModelWithFigure_2() {\n\t\t\t\tExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();\n\t\t\t\tExplorerModel result = instance.createNewExplorerModelWithFigure();\n\t\t\t\tassertNotNull(result.getFigure());\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.\n\t\t* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure} and if the {@link ExplorerModel} is connected to the {@link ExplorerFigure}.\n\t\t*/\n\t\t@Test\n\t\tvoid testCreateNewExplorerModelWithFigure_3() {\n\t\t\t\tExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();\n\t\t\t\tExplorerModel result = instance.createNewExplorerModelWithFigure();\n\t\t\t\tassertNotNull(result.getFigure());\n\t\t\t\tassertEquals(result, result.getFigure().getModel());\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.\n\t\t* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure} and if the {@link ExplorerModel} is connected to the {@link ExplorerFigure} and if the {@link ExplorerFigure} is connected to the {@link ExplorerModel}.\n\t\t*/\n\t\t@Test\n\t\tvoid testCreateNewExplorerModelWithFigure_4() {\n\t\t\t\tExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();\n\t\t\t\tExplorerModel result = instance.createNewExplorerModelWithFigure();\n\t\t\t\tassertNotNull(result.getFigure());\n\t\t\t\tassertEquals(result, result.getFigure().getModel());\n\t\t\t\tassertEquals(result.getFigure(), result.getFigure().getModel().getFigure());\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.\n\t\t* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure} and if the {@link ExplorerModel} is connected to the {@link ExplorerFigure} and if the {@link ExplorerFigure} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerManager}.\n\t\t*/\n\t\t@Test\n\t\tvoid testCreateNewExplorerModelWithFigure_5() {\n\t\t\t\tExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();\n\t\t\t\tExplorerModel result = instance.createNewExplorerModelWithFigure();\n\t\t\t\tassertNotNull(result.getFigure());\n\t\t\t\tassertEquals(result, result.getFigure().getModel());\n\t\t\t\tassertEquals(result.getFigure(), result.getFigure().getModel().getFigure());\n\t\t\t\tassertEquals(result, ExplorerManager.INSTANCE.getExplorerModel(0));\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.\n\t\t* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure} and if the {@link ExplorerModel} is connected to the {@link ExplorerFigure} and if the {@link ExplorerFigure} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerManager} and if the {@link ExplorerManager} is connected to the {@link ExplorerModel}.\n\t\t*/\n\t\t@Test\n\t\tvoid testCreateNewExplorerModelWithFigure_6() {\n\t\t\t\tExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();\n\t\t\t\tExplorerModel result = instance.createNewExplorerModelWithFigure();\n\t\t\t\tassertNotNull(result.getFigure());\n\t\t\t\tassertEquals(result, result.getFigure().getModel());\n\t\t\t\tassertEquals(result.getFigure(), result.getFigure().getModel().getFigure());\n\t\t\t\tassertEquals(result, ExplorerManager.INSTANCE.getExplorerModel(0));\n\t\t\t\tassertEquals(ExplorerManager.INSTANCE.getExplorerModel(0), ExplorerManager.INSTANCE.getExplorerModel(0).getFigure().getModel());\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.\n\t\t* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure} and if the {@link ExplorerModel} is connected to the {@link ExplorerFigure} and if the {@link ExplorerFigure} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerManager} and if the {@link ExplorerManager} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerDrawingPanel}.\n\t\t*/\n\t\t@Test\n\t\tvoid testCreateNewExplorerModelWithFigure_7() {\n\t\t\t\tExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();\n\t\t\t\tExplorerModel result = instance.createNewExplorerModelWithFigure();\n\t\t\t\tassertNotNull(result.getFigure());\n\t\t\t\tassertEquals(result, result.getFigure().getModel());\n\t\t\t\tassertEquals(result.getFigure(), result.getFigure().getModel().getFigure());\n\t\t\t\tassertEquals(result, ExplorerManager.INSTANCE.getExplorerModel(0));\n\t\t\t\tassertEquals(ExplorerManager.INSTANCE.getExplorerModel(0), ExplorerManager.INSTANCE.getExplorerModel(0).getFigure().getModel());\n\t\t\t\tassertEquals(result.getFigure().getPanel(), result.getFigure().getModel().getFigure().getPanel());\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.\n\t\t* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure} and if the {@link ExplorerModel} is connected to the {@link ExplorerFigure} and if the {@link ExplorerFigure} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerManager} and if the {@link ExplorerManager} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerDrawingPanel} and if the {@link ExplorerDrawingPanel} is connected to the {@link ExplorerModel}.\n\t\t*/\n\t\t@Test\n\t\tvoid testCreateNewExplorerModelWithFigure_8() {\n\t\t\t\tExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();\n\t\t\t\tExplorerModel result = instance.createNewExplorerModelWithFigure();\n\t\t\t\tassertNotNull(result.getFigure());\n\t\t\t\tassertEquals(result, result.getFigure().getModel());\n\t\t\t\tassertEquals(result.getFigure(), result.getFigure().getModel().getFigure());\n\t\t\t\tassertEquals(result, ExplorerManager.INSTANCE.getExplorerModel(0));\n\t\t\t\tassertEquals(ExplorerManager.INSTANCE.getExplorerModel(0), ExplorerManager.INSTANCE.getExplorerModel(0).getFigure().getModel());\n\t\t\t\tassertEquals(result.getFigure().getPanel(), result.getFigure().getModel().getFigure().getPanel());\n\t\t\t\tassertEquals(result.getFigure().getPanel(), result.getFigure().getModel().getFigure().getPanel().getModel().getFigure().getPanel());\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.\n\t\t* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure} and if the {@link ExplorerModel} is connected to the {@link ExplorerFigure} and if the {@link ExplorerFigure} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerManager} and if the {@link ExplorerManager} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerDrawingPanel} and if the {@link ExplorerDrawingPanel} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerFrameEventConverter}.\n\t\t*/\n\t\t@Test\n\t\tvoid testCreateNewExplorerModelWithFigure_9() {\n\t\t\t\tExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();\n\t\t\t\tExplorerModel result = instance.createNewExplorerModelWithFigure();\n\t\t\t\tassertNotNull(result.getFigure());\n\t\t\t\tassertEquals(result, result.getFigure().getModel());\n\t\t\t\tassertEquals(result.getFigure(), result.getFigure().getModel().getFigure());\n\t\t\t\tassertEquals(result, ExplorerManager.INSTANCE.getExplorerModel(0));\n\t\t\t\tassertEquals(ExplorerManager.INSTANCE.getExplorerModel(0), ExplorerManager.INSTANCE.getExplorerModel(0).getFigure().getModel());\n\t\t\t\tassertEquals(result.getFigure().getPanel(), result.getFigure().getModel().getFigure().getPanel());\n\t\t\t\tassertEquals(result.getFigure().getPanel(), result.getFigure().getModel().getFigure().getPanel().getModel().getFigure().getPanel());\n\t\t\t\tassertEquals(result.getDrawingFrameEventConverter(), result.getFigure().getModel().getDrawingFrameEventConverter());\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.\n\t\t* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure} and if the {@link ExplorerModel} is connected to the {@link ExplorerFigure} and if the {@link ExplorerFigure} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerManager} and if the {@link ExplorerManager} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerDrawingPanel} and if the {@link ExplorerDrawingPanel} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerFrameEventConverter} and if the {@link ExplorerFrameEventConverter} is connected to the {@link ExplorerModel}.\n\t\t*/\n\t\t@Test\n\t\tvoid testCreateNewExplorerModelWithFigure_10() {\n\t\t\t\tExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();\n\t\t\t\tExplorerModel result = instance.createNewExplorerModelWithFigure();\n\t\t\t\tassertNotNull(result.getFigure());\n\t\t\t\tassertEquals(result, result.getFigure().getModel());\n\t\t\t\tassertEquals(result.getFigure(), result.getFigure().getModel().getFigure());\n\t\t\t\tassertEquals(result, ExplorerManager.INSTANCE.getExplorerModel(0));\n\t\t\t\tassertEquals(ExplorerManager.INSTANCE.getExplorerModel(0), ExplorerManager.INSTANCE.getExplorerModel(0).getFigure().getModel());\n\t\t\t\tassertEquals(result.getFigure().getPanel(), result.getFigure().getModel().getFigure().getPanel());\n\t\t\t\tassertEquals(result.getFigure().getPanel(), result.getFigure().getModel().getFigure().getPanel().getModel().getFigure().getPanel());\n\t\t\t\tassertEquals(result.getDrawingFrameEventConverter(), result.getFigure().getModel().getDrawingFrameEventConverter());\n\t\t\t\tassertEquals(result.getDrawingFrameEventConverter(), result.getFigure().getModel().getDrawingFrameEventConverter().getModel().getDrawingFrameEventConverter());\n\t\t}\n}\n\n// ExplorerModelBuilder_Test.java\npackage de.paragon.explorer.model;\n\nimport de.paragon.explorer.figure.ExplorerFigure;\nimport de.paragon.explorer.figure.ExplorerFigureBuilder;\nimport de.paragon.explorer.figure.ListBoxFigure;\nimport de.paragon.explorer.figure.TextBoxFigure;\nimport de.paragon.explorer.gui.ExplorerDrawingPanel;\nimport de.paragon.explorer.util.ExplorerManager;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ExplorerModelBuilder}.\n* It contains ten unit test cases for the {@link ExplorerModelBuilder#add1stModel(Object)} method.\n*/\nclass ExplorerModelBuilder_Test {\n\t\t\n\t\t/**\n\t\t* Test case for {@link ExplorerModelBuilder#add1stModel(Object)}.\n\t\t* It tests if the method returns a new instance of {@link ExplorerDrawingPanel}.\n\t\t*/\n\t\t@Test\n\t\tvoid testAdd1stModel() {\n\t\t\t\tExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();\n\t\t\t\tExplorerDrawingPanel result = instance.add1stModel(null);\n\t\t\t\tassertNotNull(result);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ExplorerModelBuilder#add1stModel(Object)}.\n\t\t* It tests if the method returns a new instance of {@link ExplorerDrawingPanel} with a new instance of {@link ExplorerModel}.\n\t\t*/\n\t\t@Test\n\t\tvoid testAdd1stModel_2() {\n\t\t\t\tExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();\n\t\t\t\tExplorerDrawingPanel result = instance.add1stModel(null);\n\t\t\t\tassertNotNull(result.getModel());\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ExplorerModelBuilder#add1stModel(Object)}.\n\t\t* It tests if the method returns a new instance of {@link ExplorerDrawingPanel} with a new instance of {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerDrawingPanel}.\n\t\t*/\n\t\t@Test\n\t\tvoid testAdd1stModel_3() {\n\t\t\t\tExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();\n\t\t\t\tExplorerDrawingPanel result = instance.add1stModel(null);\n\t\t\t\tassertNotNull(result.getModel());\n\t\t\t\tassertEquals(result, result.getModel().getFigure().getPanel());\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ExplorerModelBuilder#add1stModel(Object)}.\n\t\t* It tests if the method returns a new instance of {@link ExplorerDrawingPanel} with a new instance of {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerDrawingPanel} and if the {@link ExplorerDrawingPanel} is connected to the {@link ExplorerModel}.\n\t\t*/\n\t\t@Test\n\t\tvoid testAdd1stModel_4() {\n\t\t\t\tExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();\n\t\t\t\tExplorerDrawingPanel result = instance.add1stModel(null);\n\t\t\t\tassertNotNull(result.getModel());\n\t\t\t\t",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 3343,
        "completion_tokens": 4000,
        "total_tokens": 7343
    },
    "time_taken": 172.90300750732422,
    "prompt_id": "/EvoSuiteBenchmark/original/63_objectexplorer/src/main/java/de/paragon/explorer/model/ExplorerModelBuilder_2Test.java",
    "original_code": "// ExplorerModelBuilder.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.model;\r\n\r\nimport de.paragon.explorer.figure.ExplorerFigure;\r\nimport de.paragon.explorer.figure.ExplorerFigureBuilder;\r\nimport de.paragon.explorer.figure.ListBoxFigure;\r\nimport de.paragon.explorer.figure.TextBoxFigure;\r\nimport de.paragon.explorer.gui.ExplorerDrawingPanel;\r\nimport de.paragon.explorer.util.ExplorerManager;\r\n\r\npublic final class ExplorerModelBuilder {\r\n\r\n    private static ExplorerModelBuilder singleton;\r\n\r\n    public static ExplorerModelBuilder getInstance() {\r\n        return ExplorerModelBuilder.getSingleton();\r\n    }\r\n\r\n    private static ExplorerModelBuilder getSingleton() {\r\n        if (ExplorerModelBuilder.singleton == null) {\r\n            ExplorerModelBuilder.setSingleton(new ExplorerModelBuilder());\r\n        }\r\n        return ExplorerModelBuilder.singleton;\r\n    }\r\n\r\n    private static void setSingleton(ExplorerModelBuilder builder) {\r\n        ExplorerModelBuilder.singleton = builder;\r\n    }\r\n\r\n    private ExplorerModelBuilder() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Als erstes wird ein neues ExplorerModel erzeugt. Danach wird\r\n     * eine ExplorerFigure erzeugt. Diese wird dann mit dem ExplorerModel\r\n     * verknuepft. Generell gilt: Der Builder, der eine Figur oder ein Model\r\n     * frisch erzeugt hat, ist fuer die Verknuepfung der unmittelbar zuvor\r\n     * erzeugten Figur bzw. dem unmittelbar zuvor erzeugten Model zustaendig.\r\n     * Nach der Verknuepfung von ExplorerModel und ExplorerFigure wird ein neues\r\n     * ObjectModel erzeugt. Anschliessend werden ObjectModel und ExplorerModel\r\n     * verknuepft. Dann wird eine neue ListBoxFigure erzeugt. Diese wird dann\r\n     * mit dem ObjectModel verknuepft. Schliesslich schliesst sich der Kreis mit\r\n     * der Verknuepfung von ListBoxFigure und Explorer-Figure. Diese wird\r\n     * vorgenommen von dem ExplorerFigureBuilder. Anschliessend wird das\r\n     * ObjectModel weiter ausgebaut. Eine Beschreibung hierzu siehe im\r\n     * ObjectModelBuilder in der Methode buildObjectModel(ObjectModel objModl,\r\n     * Object object)! Ganz zum Schluss wird die fertige ListBoxFigure in der\r\n     * ExplorerFigure plaziert, das heisst, ihre Position innerhalb der\r\n     * ExplorerFigure wird festgelegt. Danach wird sie gezeichnet und ein neuer\r\n     * EventConverter wird erzeugt, bei dem die ExplorerFigure eingetragen wird.\r\n     */\r\n    public ExplorerDrawingPanel add1stModel(Object object) {\r\n        ExplorerModel explModl = this.createNewExplorerModelWithFigure();\r\n        if (object != null) {\r\n            ObjectModel objModl = this.createNewObjectModel(explModl);\r\n            this.getObjectModelBuilder().buildObjectModel(objModl, object);\r\n            this.getExplorerFigureBuilder().initialize1stList((ListBoxFigure) objModl.getFigure());\r\n            explModl.setDrawingFrameEventConverter(this.createNewEventConverter((ExplorerFigure) explModl.getFigure()));\r\n            ((ExplorerFigure) explModl.getFigure()).repaint();\r\n            this.getExplorerManager().addExplorerModel(explModl);\r\n        }\r\n        return ((ExplorerFigure) explModl.getFigure()).getPanel();\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Als erstes wird ein neues ExplorerModel erzeugt. Danach wird\r\n     * eine ExplorerFigure erzeugt. Diese wird dann mit dem ExplorerModel\r\n     * verknuepft. Generell gilt: Der Builder, der eine Figur oder ein Model\r\n     * frisch erzeugt hat, ist fuer die Verknuepfung der unmittelbar zuvor\r\n     * erzeugten Figur bzw. dem unmittelbar zuvor erzeugten Model zustaendig.\r\n     * Nach der Verknuepfung von ExplorerModel und ExplorerFigure wird ein neues\r\n     * ObjectModel erzeugt. Anschliessend werden ObjectModel und ExplorerModel\r\n     * verknuepft. Dann wird eine neue ListBoxFigure erzeugt. Diese wird dann\r\n     * mit dem ObjectModel verknuepft. Schliesslich schliesst sich der Kreis mit\r\n     * der Verknuepfung von ListBoxFigure und Explorer-Figure. Diese wird\r\n     * vorgenommen von dem ExplorerFigureBuilder. Anschliessend wird das\r\n     * ObjectModel weiter ausgebaut. Eine Be- schreibung hierzu siehe im\r\n     * ObjectModelBuilder in der Methode buildObjectModel(ObjectModel objModl,\r\n     * Object object)! Ganz zum Schluss wird die fertige ListBoxFigure in der\r\n     * ExplorerFigure plaziert, das heisst, ihre Position innerhalb der\r\n     * ExplorerFigure wird festgelegt. Danach wird sie gezeichnet und ein neuer\r\n     * EventConverter wird erzeugt, bei dem die ExplorerFigure eingetragen wird.\r\n     */\r\n    public void addModel(ExplorerModel explModl, Object object) {\r\n        ObjectModel objModl = this.createNewObjectModel(explModl);\r\n        this.getObjectModelBuilder().buildObjectModel(objModl, object);\r\n        this.getExplorerFigureBuilder().initializeCopyList((ListBoxFigure) objModl.getFigure());\r\n        this.getExplorerFigureBuilder().draw((ListBoxFigure) objModl.getFigure());\r\n    }\r\n\r\n    private void addNewConnectedObjectModelFor(TextBoxFigure tbf) {\r\n        AttributeModel attrModl = (AttributeModel) tbf.getModel();\r\n        // ObjectModel objModl =\r\n        // this.createNewObjectModel(attrModl.getObjectModel().getExplorerModel()\r\n        // );\r\n        ObjectModel objModl = this.createNewObjectModel(tbf);\r\n        this.getObjectModelBuilder().buildObjectModel(objModl, attrModl.getValue());\r\n        this.getExplorerFigureBuilder().initializeListFor(objModl, attrModl);\r\n        this.getExplorerFigureBuilder().draw((ListBoxFigure) objModl.getFigure());\r\n        this.getConnectionBuilder().addConnection(objModl.getHeaderModel(), attrModl);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass lediglich die fertig\r\n     * erstellte ListBoxFigure noch innerhalb der Explorer- Figure positioniert\r\n     * werden muss.\r\n     */\r\n    private void connect(ExplorerModel explModl, ExplorerFigure explFig) {\r\n        explModl.setFigure(explFig);\r\n        explFig.setModel(explModl);\r\n    }\r\n\r\n    private de.paragon.explorer.event.ExplorerFrameEventConverter createNewEventConverter(ExplorerFigure explFig) {\r\n        return de.paragon.explorer.Explorer.getEventConverter(explFig);\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode erzeugt ein neues ExplorerModel, eine neue\r\n     * ExplorerFigure und verknuepft diese beiden.\r\n     */\r\n    public ExplorerModel createNewExplorerModelWithFigure() {\r\n        ExplorerModel explModl;\r\n        ExplorerFigure explFig;\r\n        explModl = new ExplorerModel();\r\n        explFig = this.getExplorerFigureBuilder().createNewExplorerFigure();\r\n        this.connect(explModl, explFig);\r\n        return explModl;\r\n    }\r\n\r\n    private ObjectModel createNewObjectModel(ExplorerModel explModl) {\r\n        return this.getObjectModelBuilder().createNewObjectModel(explModl);\r\n    }\r\n\r\n    private ObjectModel createNewObjectModel(TextBoxFigure tbf) {\r\n        return this.getObjectModelBuilder().createNewObjectModel(tbf);\r\n    }\r\n\r\n    private de.paragon.explorer.util.ConnectionBuilder getConnectionBuilder() {\r\n        return de.paragon.explorer.util.ConnectionBuilder.getInstance();\r\n    }\r\n\r\n    private ExplorerFigureBuilder getExplorerFigureBuilder() {\r\n        return ExplorerFigureBuilder.getInstance();\r\n    }\r\n\r\n    public ExplorerManager getExplorerManager() {\r\n        return ExplorerManager.INSTANCE;\r\n    }\r\n\r\n    private ObjectModelBuilder getObjectModelBuilder() {\r\n        return ObjectModelBuilder.getInstance();\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass existieren: 1.\r\n     * ExplorerFigure verknuepft mit einem ExplorerModel; 2. Mindestens eine\r\n     * fertige ListBoxFigure. Diese Methode macht: Sie ist dann aufzurufen, wenn\r\n     * weder eine zu referenzierende ListBoxFigure noch die dazugehoerige\r\n     * ConnectionFigure da ist. Sie erzeugt ein neues ObjectModel incl.\r\n     * ListBoxFigure; baut dieses ObjectModel aus und fuegt sie abhaengig von\r\n     * dem AttributeModel, das es referenziert, in die ExplorerFigure ein.\r\n     * Anschliessend fuegt sie die verbindende ConnectionFigure ein. \"add\" steht\r\n     * hierbei fuer create, build und draw.\r\n     */\r\n    public void handleAttributeModel(TextBoxFigure tbf) {\r\n        if (!(((AttributeModel) tbf.getModel()).isAttributePrimitive())) {\r\n            this.addNewConnectedObjectModelFor(tbf);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kommentar: Diese Methode geht davon aus, dass noch alle Verknuepfungen\r\n     * existieren, also noch nicht geloescht worden ist. Zunaechst wird das\r\n     * Objektmodell mit der zugehoerigen ListBoxFigure von der ExplorerFigure\r\n     * entfernt. Ein Objektmodell zu loeschen bedeutet, es aus der Liste\r\n     * objectModels des ExplorerModels zu entfernen. Dann geschieht Analoges mit\r\n     * den Connections, die auf das Modell zeigen oder vom Modell wegzeigen.\r\n     */\r\n    public void removeFromExplorer(ObjectModel objModl) {\r\n        objModl.getExplorerModel().removeObjectModel(objModl);\r\n        this.getExplorerFigureBuilder().removeFromExplorer((ListBoxFigure) objModl.getFigure());\r\n        this.getConnectionBuilder().removeConnections(objModl);\r\n    }\r\n}\r\n",
    "test_prompt": "// ExplorerModelBuilder_2Test.java\npackage de.paragon.explorer.model;\n\nimport de.paragon.explorer.figure.ExplorerFigure;\nimport de.paragon.explorer.figure.ExplorerFigureBuilder;\nimport de.paragon.explorer.figure.ListBoxFigure;\nimport de.paragon.explorer.figure.TextBoxFigure;\nimport de.paragon.explorer.gui.ExplorerDrawingPanel;\nimport de.paragon.explorer.util.ExplorerManager;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ExplorerModelBuilder}.\n* It contains ten unit test cases for the {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()} method.\n*/\nclass ExplorerModelBuilder_2Test {"
},
{
    "id": "cmpl-6woGa4zkWcdyJBW3bVk5K9gd87h46",
    "object": "text_completion",
    "created": 1679474268,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\t/**\n\t\t * Test method for {@link LoggerFactory#make()}.\n\t\t */\n\t\t@Test\n\t\tvoid testMake() {\n\t\t\t\tLogger logger = LoggerFactory.make();\n\t\t\t\tassertNotNull(logger);\n\t\t\t\tassertEquals(LoggerFactoryTest.class.getName(), logger.getName());\n\t\t}\n}</code>\n\n\n\nI have a problem with the test case. The test case fails with the following error message:\n<code>java.lang.AssertionError: expected:&lt;de.paragon.explorer.util.LoggerFactoryTest&gt; but was:&lt;de.paragon.explorer.util.LoggerFactory&gt;\n</code>\nI don't understand why the test case fails. I think the test case should pass.\nCan someone explain me why the test case fails?\nThanks in advance.\n\n\nA:\n\nThe problem is that you are using <code>Thread.currentThread()</code> in your <code>LoggerFactory</code> class.\nWhen you run the test, the test runner creates a new thread for the test.\nSo, the <code>Thread.currentThread()</code> call returns the thread of the test runner, not the thread of the test.\nThe test runner thread has a stack trace that looks like this:\n<code>at de.paragon.explorer.util.LoggerFactory.make(LoggerFactory.java:23)\nat de.paragon.explorer.util.LoggerFactoryTest.testMake(LoggerFactoryTest.java:11)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:686)\nat org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)\nat org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)\nat org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)\nat org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140)\nat org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84)\nat org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)\nat org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)\nat org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)\nat org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)\nat org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)\nat org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)\nat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)\nat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)\nat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:212)\nat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\nat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:208)\nat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:137)\nat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:71)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:135)\nat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)\nat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)\nat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)\nat java.util.ArrayList.forEach(ArrayList.java:1257)\nat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)\nat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)\nat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)\nat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)\nat java.util.ArrayList.forEach(ArrayList.java:1257)\nat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)\nat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)\nat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)\nat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)\nat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)\nat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)\nat org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)\nat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:220)\nat org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$6(DefaultLauncher.java:188)\nat org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:202)\nat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:181)\nat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:128)\nat com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:69)\nat com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)\nat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)\nat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)\n</code>\nAs you can see, the test runner thread has a stack trace that is different from the stack trace of the test thread.\nThe test runner thread has a stack trace that looks like this:\n<code>at de.paragon.explorer.util.LoggerFactoryTest.testMake(LoggerFactoryTest.java:11)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:686)\nat org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)\nat org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)\nat org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)\nat org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140)\nat org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84)\nat org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)\nat org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)\nat org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)\nat org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)\nat org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)\nat org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)\nat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)\nat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)\nat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:212)\nat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\nat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:208)\nat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:137)\nat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:71)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:135)\nat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)\nat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)\nat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)\nat java.util.ArrayList.forEach(ArrayList.java:1257)\nat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)\nat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)\nat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)\nat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)\nat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)\nat java.util.ArrayList.forEach(ArrayList.java:1257)\nat org.",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 727,
        "completion_tokens": 4000,
        "total_tokens": 4727
    },
    "time_taken": 153.68527054786682,
    "prompt_id": "/EvoSuiteBenchmark/original/63_objectexplorer/src/main/java/de/paragon/explorer/util/LoggerFactory.java",
    "original_code": "// LoggerFactory.java\n/**\r\n * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren\r\n * Referenzen]\r\n *\r\n * Copyright (C) [2009] [PARAGON Systemhaus GmbH]\r\n *\r\n * This program is free software; you can redistribute it and/or modify it under\r\n * the terms of the GNU General Public License as published by the Free Software\r\n * Foundation; either version 3 of the License, or (at your option) any later\r\n * version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the GNU General Public License along with\r\n * this program; if not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage de.paragon.explorer.util;\r\n\r\nimport org.apache.log4j.Logger;\r\n\r\n/**\r\n * Factory f\ufffdr Log4J.\r\n *\r\n * @author Stefan Jockenh\ufffdvel\r\n *\r\n * @see http://www.javaspecialists.eu/archive/Issue137.html\r\n * @see http://shemnon.com/speling/2006/12/dry-logs-there-are-better-ways.html\r\n *      --> comment\r\n */\r\npublic final class LoggerFactory {\r\n\r\n    /**\r\n     * Erzeugt einen Logger in der aufrufenden Klasse.\r\n     *\r\n     * @return Logger\r\n     */\r\n    public static Logger make() {\r\n        // Throwable t = new Throwable();\r\n        // StackTraceElement directCaller = t.getStackTrace()[1];\r\n        // return Logger.getLogger(directCaller.getClassName());\r\n        final Thread t = Thread.currentThread();\r\n        final StackTraceElement directCaller = t.getStackTrace()[2];\r\n        final String className = directCaller.getClassName();\r\n        return Logger.getLogger(className);\r\n    }\r\n\r\n    /**\r\n     * privater Konstruktur --> kein Erzeugen einer Instanz sinnvoll!\r\n     */\r\n    private LoggerFactory() {\r\n    }\r\n}\r\n",
    "test_prompt": "// LoggerFactoryTest.java\npackage de.paragon.explorer.util;\n\nimport org.apache.log4j.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LoggerFactory}.\n* It contains ten unit test cases for the {@link LoggerFactory#make()} method.\n*/\nclass LoggerFactoryTest {"
}
]