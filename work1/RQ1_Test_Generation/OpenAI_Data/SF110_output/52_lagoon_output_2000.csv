ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
bb33db65-cfe1-4274-bb28-53a17a0136fc,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8060 tokens (6060 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// FTPClient.java
/*
 * Copyright (c) 2002, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_0Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#store(String)} method.
*/
class FTPClient_0Test {","// FTPClient_0Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#store(String)} method.
*/
class FTPClient_0Test {
"
24e84731-c2e6-4781-acb3-194ed8050987,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8062 tokens (6062 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// FTPClient.java
/*
 * Copyright (c) 2002, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_1Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#store(String, boolean)} method.
*/
class FTPClient_1Test {","// FTPClient_1Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#store(String, boolean)} method.
*/
class FTPClient_1Test {
"
29803311-b69f-4d07-b449-03b8d72a9bc1,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8060 tokens (6060 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// FTPClient.java
/*
 * Copyright (c) 2002, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_2Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#append(String)} method.
*/
class FTPClient_2Test {","// FTPClient_2Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#append(String)} method.
*/
class FTPClient_2Test {
"
0aebb978-5e2b-4068-badc-48a8d5da77b3,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_3Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8062 tokens (6062 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// FTPClient.java
/*
 * Copyright (c) 2002, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_3Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#append(String, boolean)} method.
*/
class FTPClient_3Test {","// FTPClient_3Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#append(String, boolean)} method.
*/
class FTPClient_3Test {
"
c09a3b03-2293-4cbd-82cd-5e5cfb602d17,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_4Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8061 tokens (6061 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// FTPClient.java
/*
 * Copyright (c) 2002, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_4Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#storeUnique(String)} method.
*/
class FTPClient_4Test {","// FTPClient_4Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#storeUnique(String)} method.
*/
class FTPClient_4Test {
"
423dd1d3-f2cb-4210-958a-6a6616559b0f,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_5Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8063 tokens (6063 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// FTPClient.java
/*
 * Copyright (c) 2002, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_5Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#storeUnique(String, boolean)} method.
*/
class FTPClient_5Test {","// FTPClient_5Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#storeUnique(String, boolean)} method.
*/
class FTPClient_5Test {
"
aaae958c-5763-4edc-9c6e-4fc6e2058dca,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_6Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8061 tokens (6061 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// FTPClient.java
/*
 * Copyright (c) 2002, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_6Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#deleteFile(String)} method.
*/
class FTPClient_6Test {","// FTPClient_6Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#deleteFile(String)} method.
*/
class FTPClient_6Test {
"
cmpl-6wVAZvEWOom8L0sSYazOuYiux6ic0,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/core/LagoonProcessor_0Test.java,64.20567226409912,length,"// LagoonProcessor.java
/*
 * Copyright (c) 2001-2004, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.core;

import java.io.*;
import java.util.*;
import nu.staldal.xtree.*;
import nu.staldal.util.Utils;

/**
 * The main worker class of the Lagoon core.
 *
 * Initialized with the sitemap,
 * a source dir and a target storage URL.
 * Then building the website may be done several times,
 * until destroy() is invoked.
 *
 * This class is not thread-safe. The methods must not
 * be invoked concurrently from different threads.
 */
public class LagoonProcessor implements LagoonContext {

    private static final boolean DEBUG = false;

    private final String targetURL;

    private final FileStorage targetLocation;

    private File repositoryDir;

    private File tempDir;

    private File classDir;

    private File sourceRootDir;

    private java.net.URL[] classLoaderURLs;

    private ClassLoader repositoryClassLoader;

    private final Hashtable classDict;

    private final Hashtable paramDict;

    private final Hashtable filestorageDict;

    private Sitemap sitemap;

    PrintWriter log;

    PrintWriter err;

    /**
     * Constructs and initializes a LagoonProcessor.
     *
     * @param targetURL  where to put the generated files,
     *                   must be an absolute URL or a local file path
     * @param sitemapTree  the Sitemap as an XTree
     * @param sourceDir  where the source files are
     * @param password  password to access the target storage, or
     *                  <code>null</code> if not nessesary.
     * @param log  where to write progress messages.
     * @param err  where to write error messages.
     */
    public LagoonProcessor(String targetURL, Element sitemapTree, File sourceDir, String password, PrintWriter log, PrintWriter err) throws IOException, LagoonException, AuthenticationException, AuthenticationMissingException {
        this.targetURL = targetURL;
        this.log = log;
        this.err = err;
        classDict = new Hashtable();
        paramDict = new Hashtable();
        filestorageDict = new Hashtable();
        targetLocation = createFileStorage(targetURL);
        if (targetLocation == null)
            throw new LagoonException(""Cannot find FileStorage for URL "" + targetURL);
        if (targetLocation.needPassword() && (password == null)) {
            throw new AuthenticationMissingException();
        }
        String absPath = sourceDir.getAbsolutePath();
        this.sourceRootDir = new File(absPath);
        if (!this.sourceRootDir.isDirectory())
            throw new LagoonException(""sourceDir must be an existing directory: "" + sourceDir);
        sitemap = new Sitemap(this, sitemapTree, sourceRootDir);
        File workDir = new File(System.getProperty(""user.home""), "".lagoon"");
        if (!workDir.exists()) {
            if (!workDir.mkdir())
                throw new IOException(""Unable to create directory: "" + workDir);
        } else {
            if (!workDir.isDirectory()) {
                throw new IOException(""Unable to create directory (a file with that name exists): "" + workDir);
            }
        }
        if (sitemap.getSiteName() != null) {
            repositoryDir = new File(workDir, sitemap.getSiteName());
            if (!repositoryDir.exists()) {
                if (!repositoryDir.mkdir())
                    throw new IOException(""Unable to create directory: "" + repositoryDir);
            } else {
                if (!repositoryDir.isDirectory()) {
                    throw new IOException(""Unable to create directory (a file with that name exists): "" + repositoryDir);
                }
            }
        } else {
            repositoryDir = null;
        }
        if (repositoryDir != null) {
            tempDir = new File(repositoryDir, ""temp"");
            classDir = new File(repositoryDir, ""classes"");
        } else {
            tempDir = new File(workDir, ""temp"");
        }
        if (!tempDir.exists()) {
            if (!tempDir.mkdir())
                throw new IOException(""Unable to create directory: "" + tempDir);
        } else {
            if (!tempDir.isDirectory()) {
                throw new IOException(""Unable to create directory (a file with that name exists): "" + tempDir);
            }
        }
        if (classDir == null) {
            classDir = new File(tempDir, ""classes"");
        }
        if (!classDir.exists()) {
            if (!classDir.mkdir())
                throw new IOException(""Unable to create directory: "" + classDir);
        } else {
            if (!classDir.isDirectory()) {
                throw new IOException(""Unable to create directory (a file with that name exists): "" + classDir);
            }
        }
        classLoaderURLs = new java.net.URL[] { classDir.toURL() };
        reloadClasses();
        sitemap.init();
        targetLocation.open(targetURL, this, password);
    }

    /**
     * Get the Sitemap.
     *
     * @return the Sitemap.
     */
    Sitemap getSitemap() {
        return sitemap;
    }

    /**
     * Get the target location.
     *
     * @return the target location.
     */
    FileStorage getTargetLocation() {
        return targetLocation;
    }

    /**
     * Perform the building of the website.
     * May be invoked multiple times.
     * Synchronous, returns when the building is complete.
     *
     * @param force force a rebuild of all files, otherwise dependency
     *        checking is used to check which files that needs rebuilding.
     *
     * @return true if successful, false if any non-fatal error occured
     * @throws IOException  if any fatal error occur
     */
    public boolean build(boolean force) throws IOException {
        boolean success = true;
        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {
            SitemapEntry ent = (SitemapEntry) e.nextElement();
            ent.beforeBuild(force);
        }
        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {
            SitemapEntry ent = (SitemapEntry) e.nextElement();
            if (!ent.build(force))
                success = false;
        }
        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {
            SitemapEntry ent = (SitemapEntry) e.nextElement();
            ent.afterBuild(force);
        }
        return success;
    }

    /**
     * Dispose this object and release any resources it holds.
     * This causes the FileStorage to be closed.
     */
    public void destroy() throws IOException {
        sitemap.destroy();
        targetLocation.close();
        repositoryClassLoader = null;
        if (repositoryDir == null) {
            File[] classFiles = classDir.listFiles();
            for (int i = 0; i < classFiles.length; i++) {
                classFiles[i].delete();
            }
        }
    }

    public File getTempDir() {
        return tempDir;
    }

    public InputStream readFileFromRepository(String key) {
        return readFileFromRepository(null, key);
    }

    InputStream readFileFromRepository(String dir, String key) {
        if (repositoryDir == null)
            return null;
        File theDir = (dir == null) ? repositoryDir : new File(repositoryDir, dir);
        File theFile = new File(theDir, key);
        if (DEBUG)
            System.out.println(""readFileFromRepository: "" + theFile);
        try {
            return new FileInputStream(theFile);
        } catch (FileNotFoundException e) {
            return null;
        }
    }

    public OutputStream storeFileInRepository(String key) throws IOException {
        return storeFileInRepository(null, key);
    }

    OutputStream storeFileInRepository(String dir, String key) throws IOException {
        if (repositoryDir == null)
            return null;
        File theDir = (dir == null) ? repositoryDir : new File(repositoryDir, dir);
        theDir.mkdir();
        File theFile = new File(theDir, key);
        if (DEBUG)
            System.out.println(""storeFileInRepository: "" + theFile);
        return new FileOutputStream(theFile);
    }

    public Class loadClassFromRepository(String className) throws ClassNotFoundException {
        if (DEBUG)
            System.out.println(""loadClassFromRepository: "" + className);
        try {
            return Class.forName(className, true, repositoryClassLoader);
        } catch (ClassFormatError e) {
            File classFile = new File(classDir, className + "".class"");
            classFile.delete();
            err.println(e.toString());
            throw new ClassNotFoundException(className + "" is malformed"");
        } catch (VerifyError e) {
            File classFile = new File(classDir, className + "".class"");
            classFile.delete();
            err.println(e.toString());
            throw new ClassNotFoundException(className + "" does not verify"");
        }
    }

    public OutputStream storeClassInRepository(String className) throws IOException {
        if (classDir == null)
            return null;
        File theFile = new File(classDir, className + "".class"");
        if (DEBUG)
            System.out.println(""storeClassInRepository: "" + theFile);
        return new FileOutputStream(theFile);
    }

    public void deleteClassInRepository(String className) throws IOException {
        if (classDir == null)
            return;
        File theFile = new File(classDir, className + "".class"");
        if (DEBUG)
            System.out.println(""deleteClassInRepository: "" + theFile);
        if (theFile.isFile() && !theFile.delete())
            throw new IOException(""Unable to delete file: "" + theFile);
    }

    public void reloadClasses() {
        repositoryClassLoader = new java.net.URLClassLoader(classLoaderURLs);
    }

    public Object getObjectFromRepository(String key) throws IOException {
        return getObjectFromRepository(null, key);
    }

    Object getObjectFromRepository(String dir, String key) throws IOException {
        InputStream is = readFileFromRepository(dir, key);
        if (is == null)
            return null;
        ObjectInputStream ois = new ObjectInputStream(is);
        try {
            return ois.readObject();
        } catch (ClassNotFoundException e) {
            if (DEBUG)
                System.out.println(e);
            return null;
        } catch (ObjectStreamException e) {
            if (DEBUG)
                System.out.println(e);
            return null;
        } catch (ClassCastException e) {
            if (DEBUG)
                System.out.println(e);
            return null;
        } catch (EOFException e) {
            if (DEBUG)
                System.out.println(e);
            return null;
        } finally {
            is.close();
        }
    }

    public boolean putObjectIntoRepository(String key, Object obj) throws IOException {
        return putObjectIntoRepository(null, key, obj);
    }

    boolean putObjectIntoRepository(String dir, String key, Object obj) throws IOException {
        OutputStream os = storeFileInRepository(dir, key);
        if (os == null)
            return false;
        ObjectOutputStream oos = new ObjectOutputStream(os);
        try {
            oos.writeObject(obj);
            return true;
        } finally {
            oos.close();
        }
    }

    /**
     * Create a new producer.
     *
     * @param cat  the producer category (format, transform, source,
     *             read, parse or process).
     * @param type the producer type, use """" for default.
     *
     * @return  a new Producer
     *          or <code>null</code> if it cannot be found.
     */
    Producer createProducer(String cat, String type) throws LagoonException {
        Class cls = (Class) classDict.get(cat + "":"" + type);
        if (cls == null)
            try {
                String fileName = ""/nu/staldal/lagoon/producer/"" + cat + ((type == """") ? """" : (""-"" + type));
                InputStream is = getClass().getResourceAsStream(fileName);
                if (is == null)
                    return null;
                BufferedReader br = new BufferedReader(new InputStreamReader(is));
                String className = br.readLine();
                if (className == null)
                    throw new LagoonException(""Illegal Producer config file: "" + fileName);
                String baseClassName = ""nu.staldal.lagoon.core."" + Character.toUpperCase(cat.charAt(0)) + cat.substring(1);
                try {
                    cls = Class.forName(className);
                    if (!Class.forName(baseClassName).isAssignableFrom(cls))
                        throw new LagoonException(cat + "" class must derive from "" + baseClassName);
                    classDict.put(cat + "":"" + type, cls);
                } catch (ClassNotFoundException e) {
                    throw new LagoonException(""Producer class cannot be found:"" + e.getMessage());
                }
                Hashtable params = new Hashtable();
                for (; ; ) {
                    String s = br.readLine();
                    if (s == null)
                        break;
                    int colon = s.indexOf(':');
                    if (colon < 1)
                        throw new LagoonException(""Illegal producer config file: "" + fileName);
                    String paramName = s.substring(0, colon).trim();
                    String paramValue = s.substring(colon + 1).trim();
                    params.put(paramName, paramValue);
                }
                br.close();
                paramDict.put(cat + "":"" + type, params);
            } catch (IOException e) {
                throw new LagoonException(""Unable to read producer config file: "" + e.toString());
            }
        try {
            Producer prod = (Producer) cls.newInstance();
            Hashtable params = (Hashtable) paramDict.get(cat + "":"" + type);
            for (Enumeration e = params.keys(); e.hasMoreElements(); ) {
                String name = (String) e.nextElement();
                String value = (String) params.get(name);
                prod.addParam(name, value);
            }
            return prod;
        } catch (IllegalAccessException e) {
            throw new LagoonException(""Unable to instantiate producer class (illegal access): "" + e.getMessage());
        } catch (InstantiationException e) {
            throw new LagoonException(""Unable to instantiate producer class (instantiation failed): "" + e.getMessage());
        }
    }

    /**
     * Create a new file storage
     *
     * @param url  the URL
     *
     * @return  a new FileStorage
     *          or <code>null</code> if it cannot be found.
     */
    FileStorage createFileStorage(String url) throws LagoonException {
        Class cls = null;
        String prefix;
        int colon = url.indexOf(':');
        if (colon < 1) {
            prefix = """";
            cls = (Class) filestorageDict.get("""");
        } else {
            prefix = url.substring(0, colon);
            cls = (Class) filestorageDict.get(prefix);
            if (cls == null) {
                cls = (Class) filestorageDict.get("""");
            }
        }
        if (cls == null)
            try {
                String fileName = ""/nu/staldal/lagoon/filestorage/FileStorage"" + ((prefix == """") ? """" : (""-"" + prefix));
                InputStream is = getClass().getResourceAsStream(fileName);
                if (is == null) {
                    fileName = ""/nu/staldal/lagoon/filestorage/FileStorage"";
                    is = getClass().getResourceAsStream(fileName);
                    prefix = """";
                }
                if (is == null)
                    return null;
                BufferedReader br = new BufferedReader(new InputStreamReader(is));
                String className = br.readLine();
                br.close();
                if (className == null)
                    throw new LagoonException(""Illegal FileStorage config file: "" + fileName);
                String baseClassName = ""nu.staldal.lagoon.core.FileStorage"";
                try {
                    cls = Class.forName(className);
                    if (!Class.forName(baseClassName).isAssignableFrom(cls))
                        throw new LagoonException(""file storage class must derive from "" + baseClassName);
                    filestorageDict.put(prefix, cls);
                } catch (ClassNotFoundException e) {
                    throw new LagoonException(""FileStorage class cannot be found:"" + e.getMessage());
                }
            } catch (IOException e) {
                throw new LagoonException(""Unable to read producer config file: "" + e.toString());
            }
        try {
            return (FileStorage) cls.newInstance();
        } catch (IllegalAccessException e) {
            throw new LagoonException(""Unable to instantiate file storage class (illegal access): "" + e.getMessage());
        } catch (InstantiationException e) {
            throw new LagoonException(""Unable to instantiate file storage class (instantiation failed): "" + e.getMessage());
        }
    }

    public boolean canCheckFileHasBeenUpdated(String url) {
        return !Utils.absoluteURL(url) || url.startsWith(""part:"") || url.startsWith(""file:"") || url.startsWith(""res:"");
    }

    public File getSourceRootDir() {
        return sourceRootDir;
    }

    public String getFileURLRelativeTo(String url, String base) {
        if (Utils.absoluteURL(url) || Utils.pseudoAbsoluteURL(url)) {
            return url;
        } else {
            if (!Utils.pseudoAbsoluteURL(base))
                throw new IllegalArgumentException(""base must be a pseudo-absolute URL"");
            int slash = base.lastIndexOf('/');
            String baseDir = base.substring(0, slash + 1);
            return baseDir + url;
        }
    }

    public String getProperty(String key) {
        return sitemap.getProperty(key);
    }
}
","// LagoonProcessor_0Test.java
package nu.staldal.lagoon.core;

import java.io.*;
import java.util.*;
import nu.staldal.xtree.*;
import nu.staldal.util.Utils;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LagoonProcessor}.
* It contains ten unit test cases for the {@link LagoonProcessor#build(boolean)} method.
*/
class LagoonProcessor_0Test {","// LagoonProcessor_0Test.java
package nu.staldal.lagoon.core;

import java.io.*;
import java.util.*;
import nu.staldal.xtree.*;
import nu.staldal.util.Utils;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LagoonProcessor}.
* It contains ten unit test cases for the {@link LagoonProcessor#build(boolean)} method.
*/
class LagoonProcessor_0Test {

		private static final String SITEMAP_XML = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"" +
				""<Sitemap>\n"" +
				""  <SiteName>Test</SiteName>\n"" +
				""  <SourceDir>src/test/resources/nu/staldal/lagoon/core/</SourceDir>\n"" +
				""  <TargetDir>target/test-output/nu/staldal/lagoon/core/</TargetDir>\n"" +
				""  <Entry>\n"" +
				""    <Source>index.html</Source>\n"" +
				""    <Target>index.html</Target>\n"" +
				""    <Format>html</Format>\n"" +
				""  </Entry>\n"" +
				""  <Entry>\n"" +
				""    <Source>index.xml</Source>\n"" +
				""    <Target>index.xml</Target>\n"" +
				""    <Format>xml</Format>\n"" +
				""  </Entry>\n"" +
				""  <Entry>\n"" +
				""    <Source>index.xsp</Source>\n"" +
				""    <Target>index.xml</Target>\n"" +
				""    <Format>xml</Format>\n"" +
				""    <Process>\n"" +
				""      <XSP>\n"" +
				""        <Param name=\""foo\"">bar</Param>\n"" +
				""      </XSP>\n"" +
				""    </Process>\n"" +
				""  </Entry>\n"" +
				""  <Entry>\n"" +
				""    <Source>index.xsp</Source>\n"" +
				""    <Target>index.html</Target>\n"" +
				""    <Format>html</Format>\n"" +
				""    <Process>\n"" +
				""      <XSP>\n"" +
				""        <Param name=\""foo\"">bar</Param>\n"" +
				""      </XSP>\n"" +
				""      <XSLT>\n"" +
				""        <Param name=\""foo\"">bar</Param>\n"" +
				""      </XSLT>\n"" +
				""    </Process>\n"" +
				""  </Entry>\n"" +
				""  <Entry>\n"" +
				""    <Source>index.xsp</Source>\n"" +
				""    <Target>index.html</Target>\n"" +
				""    <Format>html</Format>\n"" +
				""    <Process>\n"" +
				""      <XSP>\n"" +
				""        <Param name=\""foo\"">bar</Param>\n"" +
				""      </XSP>\n"" +
				""      <XSLT>\n"" +
				""        <Param name=\""foo\"">bar</Param>\n"" +
				""      </XSLT>\n"" +
				""    </Process>\n"" +
				""  </Entry>\n"" +
				""  <Entry>\n"" +
				""    <Source>index.xsp</Source>\n"" +
				""    <Target>index.html</Target>\n"" +
				""    <Format>html</Format>\n"" +
				""    <Process>\n"" +
				""      <XSP>\n"" +
				""        <Param name=\""foo\"">bar</Param>\n"" +
				""      </XSP>\n"" +
				""      <XSLT>\n"" +
				""        <Param name=\""foo\"">bar</Param>\n"" +
				""      </XSLT>\n"" +
				""    </Process>\n"" +
				""  </Entry>\n"" +
				""  <Entry>\n"" +
				""    <Source>index.xsp</Source>\n"" +
				""    <Target>index.html</Target>\n"" +
				""    <Format>html</Format>\n"" +
				""    <Process>\n"" +
				""      <XSP>\n"" +
				""        <Param name=\""foo\"">bar</Param>\n"" +
				""      </XSP>\n"" +
				""      <XSLT>\n"" +
				""        <Param name=\""foo\"">bar</Param>\n"" +
				""      </XSLT>\n"" +
				""    </Process>\n"" +
				""  </Entry>\n"" +
				""  <Entry>\n"" +
				""    <Source>index.xsp</Source>\n"" +
				""    <Target>index.html</Target>\n"" +
				""    <Format>html</Format>\n"" +
				""    <Process>\n"" +
				""      <XSP>\n"" +
				""        <Param name=\""foo\"">bar</Param>\n"" +
				""      </XSP>\n"" +
				""      <XSLT>\n"" +
				""        <Param name=\""foo\"">bar</Param>\n"" +
				""      </XSLT>\n"" +
				""    </Process>\n"" +
				""  </Entry>\n"" +
				""  <Entry>\n"" +
				""    <Source>index.xsp</Source>\n"" +
				""    <Target>index.html</Target>\n"" +
				""    <Format>html</Format>\n"" +
				""    <Process>\n"" +
				""      <XSP>\n"" +
				""        <Param name=\""foo\"">bar</Param>\n"" +
				""      </XSP>\n"" +
				""      <XSLT>\n"" +
				""        <Param name=\""foo\"">bar</Param>\n"" +
				""      </XSLT>\n"" +
				""    </Process>\n"" +
				""  </Entry>\n"" +
				""  <Entry>\n"" +
				""    <Source>index.xsp</Source>\n"" +
				""    <Target>index.html</Target>\n"" +
				""    <Format>html</Format>\n"" +
				""    <Process>\n"" +
				""      <XSP>\n"" +
				""        <Param name=\""foo\"">bar</Param>\n"" +
				""      </XSP>\n"" +
				""      <XSLT>\n"" +
				""        <Param name=\""foo\"">bar</Param>\n"" +
				""      </XSLT>\n"" +
				""    </Process>\n"" +"
cmpl-6wVBbBkvlVVFgzuHaWrdnXgyBYFuk,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/FTPFileStorage_1Test.java,54.12764048576355,length,"// FTPFileStorage.java
/*
 * Copyright (c) 2001-2002, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.*;
import nu.staldal.lagoon.core.*;
import nu.staldal.ftp.*;

/**
 * A FileStorage which transfers files to a remote site using FTP.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPFileStorage extends RemoteFileStorage {

    private static final boolean DEBUG = false;

    private FTPClient ftp;

    private String url;

    private String password;

    /**
     * Default constructor.
     */
    public FTPFileStorage() {
    }

    public boolean needPassword() {
        return true;
    }

    public boolean isReentrant() {
        return false;
    }

    public void open(String url, LagoonContext context, String password) throws MalformedURLException, UnknownHostException, FTPException, IOException, AuthenticationException {
        this.url = url;
        this.password = password;
        ftp = new FTPClient(url, password);
        openDateFile(context);
    }

    /**
     * Close the file system and release any resources it holds.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        closeDateFile();
        ftp.close();
        ftp = null;
    }

    /**
     * Create a new file, or overwrite an existing file.
     *
     * @param pathname  path to the file
     */
    public OutputHandler createFile(String pathname) throws IOException {
        OutputStream os;
        try {
            os = ftp.store(pathname);
        } catch (IOException e) {
            if (DEBUG)
                System.out.println(""FTP reconnecting: "" + e.toString());
            try {
                ftp.close();
            } catch (IOException ignore) {
            }
            ftp = new FTPClient(url, password);
            os = ftp.store(pathname);
        }
        return new FTPOutputHandler(pathname, os);
    }

    /**
     * Deletes a file.
     * Does not signal any error if the file doesn't exist.
     *
     * @param pathname  path to the file
     */
    public void deleteFile(String pathname) throws java.io.IOException {
        try {
            ftp.deleteFile(pathname);
        } catch (IOException e) {
            if (DEBUG)
                System.out.println(""FTP reconnecting: "" + e.toString());
            try {
                ftp.close();
            } catch (IOException ignore) {
            }
            ftp = new FTPClient(url, password);
            ftp.deleteFile(pathname);
        }
    }

    class FTPOutputHandler extends OutputHandler {

        private String currentPathname;

        FTPOutputHandler(String currentPathname, OutputStream out) {
            super(out);
            this.currentPathname = currentPathname;
        }

        public void commit() throws java.io.IOException {
            out.close();
            fileModified(currentPathname);
        }

        public void discard() throws java.io.IOException {
            try {
                commit();
            } catch (FTPException e) {
                // ignore exception
            }
            ftp.deleteFile(currentPathname);
        }
    }
}
","// FTPFileStorage_1Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.*;
import nu.staldal.lagoon.core.*;
import nu.staldal.ftp.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPFileStorage}.
* It contains ten unit test cases for the {@link FTPFileStorage#createFile(String)} method.
*/
class FTPFileStorage_1Test {","// FTPFileStorage_1Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.*;
import nu.staldal.lagoon.core.*;
import nu.staldal.ftp.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPFileStorage}.
* It contains ten unit test cases for the {@link FTPFileStorage#createFile(String)} method.
*/
class FTPFileStorage_1Test {

		/**
		* Test case 1 for method {@link FTPFileStorage#createFile(String)}.
		*
		* @throws IOException
		* @throws FTPException
		* @throws AuthenticationException
		* @throws UnknownHostException
		* @throws MalformedURLException
		*/
		@Test
		public void testCreateFile_1() throws MalformedURLException, UnknownHostException, AuthenticationException, FTPException, IOException {
				FTPFileStorage fileStorage = new FTPFileStorage();
				fileStorage.open(""ftp://localhost/"", null, ""password"");
				OutputHandler outputHandler = fileStorage.createFile(""testCreateFile_1"");
				outputHandler.commit();
				fileStorage.close();
		}
		
		/**
		* Test case 2 for method {@link FTPFileStorage#createFile(String)}.
		*
		* @throws IOException
		* @throws FTPException
		* @throws AuthenticationException
		* @throws UnknownHostException
		* @throws MalformedURLException
		*/
		@Test
		public void testCreateFile_2() throws MalformedURLException, UnknownHostException, AuthenticationException, FTPException, IOException {
				FTPFileStorage fileStorage = new FTPFileStorage();
				fileStorage.open(""ftp://localhost/"", null, ""password"");
				OutputHandler outputHandler = fileStorage.createFile(""testCreateFile_2"");
				outputHandler.commit();
				fileStorage.close();
		}
		
		/**
		* Test case 3 for method {@link FTPFileStorage#createFile(String)}.
		*
		* @throws IOException
		* @throws FTPException
		* @throws AuthenticationException
		* @throws UnknownHostException
		* @throws MalformedURLException
		*/
		@Test
		public void testCreateFile_3() throws MalformedURLException, UnknownHostException, AuthenticationException, FTPException, IOException {
				FTPFileStorage fileStorage = new FTPFileStorage();
				fileStorage.open(""ftp://localhost/"", null, ""password"");
				OutputHandler outputHandler = fileStorage.createFile(""testCreateFile_3"");
				outputHandler.commit();
				fileStorage.close();
		}
		
		/**
		* Test case 4 for method {@link FTPFileStorage#createFile(String)}.
		*
		* @throws IOException
		* @throws FTPException
		* @throws AuthenticationException
		* @throws UnknownHostException
		* @throws MalformedURLException
		*/
		@Test
		public void testCreateFile_4() throws MalformedURLException, UnknownHostException, AuthenticationException, FTPException, IOException {
				FTPFileStorage fileStorage = new FTPFileStorage();
				fileStorage.open(""ftp://localhost/"", null, ""password"");
				OutputHandler outputHandler = fileStorage.createFile(""testCreateFile_4"");
				outputHandler.commit();
				fileStorage.close();
		}
		
		/**
		* Test case 5 for method {@link FTPFileStorage#createFile(String)}.
		*
		* @throws IOException
		* @throws FTPException
		* @throws AuthenticationException
		* @throws UnknownHostException
		* @throws MalformedURLException
		*/
		@Test
		public void testCreateFile_5() throws MalformedURLException, UnknownHostException, AuthenticationException, FTPException, IOException {
				FTPFileStorage fileStorage = new FTPFileStorage();
				fileStorage.open(""ftp://localhost/"", null, ""password"");
				OutputHandler outputHandler = fileStorage.createFile(""testCreateFile_5"");
				outputHandler.commit();
				fileStorage.close();
		}
		
		/**
		* Test case 6 for method {@link FTPFileStorage#createFile(String)}.
		*
		* @throws IOException
		* @throws FTPException
		* @throws AuthenticationException
		* @throws UnknownHostException
		* @throws MalformedURLException
		*/
		@Test
		public void testCreateFile_6() throws MalformedURLException, UnknownHostException, AuthenticationException, FTPException, IOException {
				FTPFileStorage fileStorage = new FTPFileStorage();
				fileStorage.open(""ftp://localhost/"", null, ""password"");
				OutputHandler outputHandler = fileStorage.createFile(""testCreateFile_6"");
				outputHandler.commit();
				fileStorage.close();
		}
		
		/**
		* Test case 7 for method {@link FTPFileStorage#createFile(String)}.
		*
		* @throws IOException
		* @throws FTPException
		* @throws AuthenticationException
		* @throws UnknownHostException
		* @throws MalformedURLException
		*/
		@Test
		public void testCreateFile_7() throws MalformedURLException, UnknownHostException, AuthenticationException, FTPException, IOException {
				FTPFileStorage fileStorage = new FTPFileStorage();
				fileStorage.open(""ftp://localhost/"", null, ""password"");
				OutputHandler outputHandler = fileStorage.createFile(""testCreateFile_7"");
				outputHandler.commit();
				fileStorage.close();
		}
		
		/**
		* Test case 8 for method {@link FTPFileStorage#createFile(String)}.
		*
		* @throws IOException
		* @throws FTPException
		* @throws AuthenticationException
		* @throws UnknownHostException
		* @throws MalformedURLException
		*/
		@Test
		public void testCreateFile_8() throws MalformedURLException, UnknownHostException, AuthenticationException, FTPException, IOException {
				FTPFileStorage fileStorage = new FTPFileStorage();
				fileStorage.open(""ftp://localhost/"", null, ""password"");
				OutputHandler outputHandler = fileStorage.createFile(""testCreateFile_8"");
				outputHandler.commit();
				fileStorage.close();
		}
		
		/**
		* Test case 9 for method {@link FTPFileStorage#createFile(String)}.
		*
		* @throws IOException
		* @throws FTPException
		* @throws AuthenticationException
		* @throws UnknownHostException
		* @throws MalformedURLException
		*/
		@Test
		public void testCreateFile_9() throws MalformedURLException, UnknownHostException, AuthenticationException, FTPException, IOException {
				FTPFileStorage fileStorage = new FTPFileStorage();
				fileStorage.open(""ftp://localhost/"", null, ""password"");
				OutputHandler outputHandler = fileStorage.createFile(""testCreateFile_9"");
				outputHandler.commit();
				fileStorage.close();
		}
		
		/**
		* Test case 10 for method {@link FTPFileStorage#createFile(String)}.
		*
		* @throws IOException
		* @throws FTPException
		* @throws AuthenticationException
		* @throws UnknownHostException
		* @throws MalformedURLException
		*/
		@Test
		public void testCreateFile_10() throws MalformedURLException, UnknownHostException, AuthenticationException, FTPException, IOException {
				FTP"
cmpl-6wVCeUM2JaQUouVq62Wrzzu0OXC4I,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/LocalFileStorage_1Test.java,47.749462366104126,length,"// LocalFileStorage.java
/*
 * Copyright (c) 2001-2002, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;

/**
 * A FileStorage using the local file system.
 */
public class LocalFileStorage implements FileStorage {

    private File root;

    /**
     * Default constructor.
     */
    public LocalFileStorage() {
        root = null;
    }

    public boolean needPassword() {
        return false;
    }

    public boolean isReentrant() {
        return true;
    }

    public void open(String loc, LagoonContext context, String password) throws java.io.IOException {
        root = new File(loc);
        if (root.exists()) {
            if (!root.isDirectory())
                throw new IOException(""Location exists but is not a directory"");
        } else {
            if (!root.mkdir())
                throw new IOException(""Location didn't exist and couldn't be created"");
        }
    }

    /**
     * Close the file system and release any resources it holds.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() // throws java.io.IOException;
    {
        root = null;
    }

    /**
     * Check if a file exists and when it was last modified.
     *
     * @param path  path to the file
     *
     * @return  the time when the file was last modified,
     * or -1 if that information is not avaliable,
     * or 0 if the file doesn't exists.
     */
    public long fileLastModified(String path) // throws java.io.IOException
    {
        File file = root;
        int oldPos = 1;
        int pos;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            file = new File(file, comp);
            if (!file.exists())
                return 0;
            oldPos = pos + 1;
        }
        file = new File(file, path.substring(oldPos));
        return file.lastModified();
    }

    /**
     * Create a new file, or overwrite an existing file.
     */
    public OutputHandler createFile(String path) throws java.io.IOException {
        File file = root;
        int oldPos = 1;
        int pos;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            file = new File(file, comp);
            if (!file.exists())
                if (!file.mkdir())
                    throw new IOException(""Unable to create directory: "" + file);
            oldPos = pos + 1;
        }
        File currentFile = new File(file, path.substring(oldPos));
        return new LocalOutputHandler(currentFile, new FileOutputStream(currentFile));
    }

    /**
     * Deletes a file.
     * Does not signal any error if the file doesn't exist.
     *
     * @param path  path to the file
     */
    public void deleteFile(String path) throws java.io.IOException {
        File file = root;
        int oldPos = 1;
        int pos;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            file = new File(file, comp);
            // file doesn't exist
            if (!file.exists())
                return;
            oldPos = pos + 1;
        }
        file = new File(file, path.substring(oldPos));
        if (!file.exists())
            return;
        if (file.delete()) {
            return;
        } else {
            throw new IOException(""Unable to delete file: "" + file);
        }
    }

    static class LocalOutputHandler extends OutputHandler {

        private File currentFile;

        LocalOutputHandler(File currentFile, OutputStream out) {
            super(out);
            this.currentFile = currentFile;
        }

        public void commit() throws java.io.IOException {
            out.close();
        }

        public void discard() throws java.io.IOException {
            out.close();
            if (!currentFile.exists())
                return;
            if (currentFile.delete()) {
                return;
            } else {
                throw new IOException(""Unable to delete file: "" + currentFile);
            }
        }
    }
}
","// LocalFileStorage_1Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LocalFileStorage}.
* It contains ten unit test cases for the {@link LocalFileStorage#fileLastModified(String)} method.
*/
class LocalFileStorage_1Test {","// LocalFileStorage_1Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LocalFileStorage}.
* It contains ten unit test cases for the {@link LocalFileStorage#fileLastModified(String)} method.
*/
class LocalFileStorage_1Test {

		private LocalFileStorage localFileStorage;
		private LagoonContext context;
		private String password;
		private String path;
		private long result;
		
		/**
		* Test case 1 for method {@link LocalFileStorage#fileLastModified(String)}.
		*
		* @throws IOException
		*/
		@Test
		void testFileLastModified_1() throws IOException {
				localFileStorage = new LocalFileStorage();
				localFileStorage.open(""/home/user/test"", context, password);
				path = ""test.txt"";
				result = localFileStorage.fileLastModified(path);
				assertEquals(0, result);
		}
		
		/**
		* Test case 2 for method {@link LocalFileStorage#fileLastModified(String)}.
		*
		* @throws IOException
		*/
		@Test
		void testFileLastModified_2() throws IOException {
				localFileStorage = new LocalFileStorage();
				localFileStorage.open(""/home/user/test"", context, password);
				path = ""test.txt"";
				result = localFileStorage.fileLastModified(path);
				assertEquals(0, result);
		}
		
		/**
		* Test case 3 for method {@link LocalFileStorage#fileLastModified(String)}.
		*
		* @throws IOException
		*/
		@Test
		void testFileLastModified_3() throws IOException {
				localFileStorage = new LocalFileStorage();
				localFileStorage.open(""/home/user/test"", context, password);
				path = ""test.txt"";
				result = localFileStorage.fileLastModified(path);
				assertEquals(0, result);
		}
		
		/**
		* Test case 4 for method {@link LocalFileStorage#fileLastModified(String)}.
		*
		* @throws IOException
		*/
		@Test
		void testFileLastModified_4() throws IOException {
				localFileStorage = new LocalFileStorage();
				localFileStorage.open(""/home/user/test"", context, password);
				path = ""test.txt"";
				result = localFileStorage.fileLastModified(path);
				assertEquals(0, result);
		}
		
		/**
		* Test case 5 for method {@link LocalFileStorage#fileLastModified(String)}.
		*
		* @throws IOException
		*/
		@Test
		void testFileLastModified_5() throws IOException {
				localFileStorage = new LocalFileStorage();
				localFileStorage.open(""/home/user/test"", context, password);
				path = ""test.txt"";
				result = localFileStorage.fileLastModified(path);
				assertEquals(0, result);
		}
		
		/**
		* Test case 6 for method {@link LocalFileStorage#fileLastModified(String)}.
		*
		* @throws IOException
		*/
		@Test
		void testFileLastModified_6() throws IOException {
				localFileStorage = new LocalFileStorage();
				localFileStorage.open(""/home/user/test"", context, password);
				path = ""test.txt"";
				result = localFileStorage.fileLastModified(path);
				assertEquals(0, result);
		}
		
		/**
		* Test case 7 for method {@link LocalFileStorage#fileLastModified(String)}.
		*
		* @throws IOException
		*/
		@Test
		void testFileLastModified_7() throws IOException {
				localFileStorage = new LocalFileStorage();
				localFileStorage.open(""/home/user/test"", context, password);
				path = ""test.txt"";
				result = localFileStorage.fileLastModified(path);
				assertEquals(0, result);
		}
		
		/**
		* Test case 8 for method {@link LocalFileStorage#fileLastModified(String)}.
		*
		* @throws IOException
		*/
		@Test
		void testFileLastModified_8() throws IOException {
				localFileStorage = new LocalFileStorage();
				localFileStorage.open(""/home/user/test"", context, password);
				path = ""test.txt"";
				result = localFileStorage.fileLastModified(path);
				assertEquals(0, result);
		}
		
		/**
		* Test case 9 for method {@link LocalFileStorage#fileLastModified(String)}.
		*
		* @throws IOException
		*/
		@Test
		void testFileLastModified_9() throws IOException {
				localFileStorage = new LocalFileStorage();
				localFileStorage.open(""/home/user/test"", context, password);
				path = ""test.txt"";
				result = localFileStorage.fileLastModified(path);
				assertEquals(0, result);
		}
		
		/**
		* Test case 10 for method {@link LocalFileStorage#fileLastModified(String)}.
		*
		* @throws IOException
		*/
		@Test
		void testFileLastModified_10() throws IOException {
				localFileStorage = new LocalFileStorage();
				localFileStorage.open(""/home/user/test"", context, password);
				path = ""test.txt"";
				result = localFileStorage.fileLastModified(path);
				assertEquals(0, result);
		}
}

// LocalFileStorage_2Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LocalFileStorage}.
* It contains ten unit test cases for the {@link LocalFileStorage#createFile(String)} method.
*/
class LocalFileStorage_2Test {
		
		private LocalFileStorage localFileStorage;
		private LagoonContext context;
		private String password;
		private String path;
		private OutputHandler result;
		
		/**
		* Test case 1 for method {@link LocalFileStorage#createFile(String)}.
		*
		* @throws IOException
		*/
		@Test
		void testCreateFile_1() throws IOException {
				localFileStorage = new LocalFileStorage();
				localFileStorage.open(""/home/user/test"", context, password);
				path = ""test.txt"";
				result = localFileStorage.createFile(path);
				assertNotNull(result);
		}
		
		/**
		* Test case 2 for method {@link LocalFileStorage#createFile(String)}.
		*
		* @throws IOException
		*/
		@Test
		void testCreateFile_2() throws IOException {
				localFileStorage = new LocalFileStorage();
				localFileStorage.open(""/home/user/test"", context, password);
				path = ""test.txt"";
				"
cmpl-6wVDhjenvme6QflXyo0j6qAR4S9Wa,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/SSHFileStorage_1Test.java,32.29969573020935,stop,"// SSHFileStorage.java
/*
 * Copyright (c) 2001-2002, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;

/**
 * A FileStorage which transfers files to a remote site using SSH.
 */
public class SSHFileStorage extends RemoteFileStorage {

    private static final boolean DEBUG = false;

    private String host;

    private int port;

    private String username;

    private String rootPath;

    private Runtime rt;

    private Process runSSH(String[] command) throws IOException {
        String[] cmdline = new String[command.length + ((port > 0) ? 9 : 7)];
        cmdline[0] = ""ssh"";
        cmdline[1] = ""-q"";
        cmdline[2] = ""-e"";
        cmdline[3] = ""none"";
        cmdline[4] = ""-l"";
        cmdline[5] = username;
        if (port > 0) {
            cmdline[6] = ""-p"";
            cmdline[7] = Integer.toString(port);
        }
        cmdline[(port > 0) ? 8 : 6] = host;
        System.arraycopy(command, 0, cmdline, ((port > 0) ? 9 : 7), command.length);
        if (DEBUG) {
            System.out.println(""Executing: "");
            for (int i = 0; i < cmdline.length; i++) System.out.println(cmdline[i]);
            System.out.println();
        }
        return rt.exec(cmdline);
    }

    /**
     * Default constructor.
     */
    public SSHFileStorage() {
    }

    public boolean needPassword() {
        return false;
    }

    public boolean isReentrant() {
        return true;
    }

    public void open(String url, LagoonContext context, String passoword) throws MalformedURLException, IOException {
        if (!url.startsWith(""ssh://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.lastIndexOf('@');
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 0 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        if ((path.length() == 0) || (path.charAt(path.length() - 1) != '/')) {
            this.rootPath = path;
        } else {
            this.rootPath = path.substring(0, path.length() - 1);
        }
        this.rt = Runtime.getRuntime();
        openDateFile(context);
    }

    /**
     * Close the file system and release any resources it holds.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        closeDateFile();
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Use close() on the returned OutputStream when finished
     * writing to the file, and then commitFile() or discardFile()
     * on the FileStorage.
     *
     * @param path  path to the file
     *
     * @return an OutputStream to write to
     *
     * @see #commitFile
     * @see #discardFile
     */
    public OutputHandler createFile(String path) throws java.io.IOException {
        String currentPath = path;
        String s = rootPath + path;
        int i = s.lastIndexOf('/');
        String dir = (i < 0) ? ""."" : s.substring(0, i);
        if (DEBUG)
            System.out.println(""dir: "" + dir);
        Process currentProc = runSSH(new String[] { ""mkdir"", ""-p"", dir, ""&&"", ""rm"", ""-f"", rootPath + path, ""&&"", ""cat"", "">"" + rootPath + path });
        return new SSHOutputHandler(currentPath, currentProc, currentProc.getOutputStream());
    }

    /**
     * Deletes a file.
     * Does not signal any error if the file doesn't exist.
     *
     * @param path  path to the file
     */
    public void deleteFile(String path) throws java.io.IOException {
        Process proc = runSSH(new String[] { ""rm"", ""-f"", rootPath + path });
        proc.getOutputStream().close();
        try {
            proc.waitFor();
        } catch (InterruptedException e) {
        }
    }

    class SSHOutputHandler extends OutputHandler {

        private String currentPath;

        private Process currentProc;

        SSHOutputHandler(String currentPath, Process currentProc, OutputStream out) {
            super(out);
            this.currentPath = currentPath;
            this.currentProc = currentProc;
        }

        public void commit() throws java.io.IOException {
            out.close();
            try {
                currentProc.waitFor();
            } catch (InterruptedException e) {
            }
            fileModified(currentPath);
        }

        public void discard() throws java.io.IOException {
            out.close();
            try {
                currentProc.waitFor();
            } catch (InterruptedException e) {
            }
            Process proc = runSSH(new String[] { ""rm"", ""-f"", rootPath + currentPath });
            proc.getOutputStream().close();
            try {
                proc.waitFor();
            } catch (InterruptedException e) {
            }
        }
    }
}
","// SSHFileStorage_1Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SSHFileStorage}.
* It contains ten unit test cases for the {@link SSHFileStorage#createFile(String)} method.
*/
class SSHFileStorage_1Test {","// SSHFileStorage_1Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SSHFileStorage}.
* It contains ten unit test cases for the {@link SSHFileStorage#createFile(String)} method.
*/
class SSHFileStorage_1Test {

		@Test
		void testCase1() throws MalformedURLException, IOException {
				SSHFileStorage sshFileStorage0 = new SSHFileStorage();
				sshFileStorage0.open(""ssh://user@host:80/path/"", (LagoonContext) null, ""password"");
				OutputHandler outputHandler0 = sshFileStorage0.createFile("""");
				outputHandler0.commit();
				sshFileStorage0.close();
		}
		
		@Test
		void testCase2() throws MalformedURLException, IOException {
				SSHFileStorage sshFileStorage0 = new SSHFileStorage();
				sshFileStorage0.open(""ssh://user@host:80/path/"", (LagoonContext) null, ""password"");
				OutputHandler outputHandler0 = sshFileStorage0.createFile("""");
				outputHandler0.discard();
				sshFileStorage0.close();
		}
		
		@Test
		void testCase3() throws MalformedURLException, IOException {
				SSHFileStorage sshFileStorage0 = new SSHFileStorage();
				sshFileStorage0.open(""ssh://user@host:80/path/"", (LagoonContext) null, ""password"");
				OutputHandler outputHandler0 = sshFileStorage0.createFile("""");
				outputHandler0.commit();
				sshFileStorage0.close();
		}
		
		@Test
		void testCase4() throws MalformedURLException, IOException {
				SSHFileStorage sshFileStorage0 = new SSHFileStorage();
				sshFileStorage0.open(""ssh://user@host:80/path/"", (LagoonContext) null, ""password"");
				OutputHandler outputHandler0 = sshFileStorage0.createFile("""");
				outputHandler0.discard();
				sshFileStorage0.close();
		}
		
		@Test
		void testCase5() throws MalformedURLException, IOException {
				SSHFileStorage sshFileStorage0 = new SSHFileStorage();
				sshFileStorage0.open(""ssh://user@host:80/path/"", (LagoonContext) null, ""password"");
				OutputHandler outputHandler0 = sshFileStorage0.createFile("""");
				outputHandler0.commit();
				sshFileStorage0.close();
		}
		
		@Test
		void testCase6() throws MalformedURLException, IOException {
				SSHFileStorage sshFileStorage0 = new SSHFileStorage();
				sshFileStorage0.open(""ssh://user@host:80/path/"", (LagoonContext) null, ""password"");
				OutputHandler outputHandler0 = sshFileStorage0.createFile("""");
				outputHandler0.discard();
				sshFileStorage0.close();
		}
		
		@Test
		void testCase7() throws MalformedURLException, IOException {
				SSHFileStorage sshFileStorage0 = new SSHFileStorage();
				sshFileStorage0.open(""ssh://user@host:80/path/"", (LagoonContext) null, ""password"");
				OutputHandler outputHandler0 = sshFileStorage0.createFile("""");
				outputHandler0.commit();
				sshFileStorage0.close();
		}
		
		@Test
		void testCase8() throws MalformedURLException, IOException {
				SSHFileStorage sshFileStorage0 = new SSHFileStorage();
				sshFileStorage0.open(""ssh://user@host:80/path/"", (LagoonContext) null, ""password"");
				OutputHandler outputHandler0 = sshFileStorage0.createFile("""");
				outputHandler0.discard();
				sshFileStorage0.close();
		}
		
		@Test
		void testCase9() throws MalformedURLException, IOException {
				SSHFileStorage sshFileStorage0 = new SSHFileStorage();
				sshFileStorage0.open(""ssh://user@host:80/path/"", (LagoonContext) null, ""password"");
				OutputHandler outputHandler0 = sshFileStorage0.createFile("""");
				outputHandler0.commit();
				sshFileStorage0.close();
		}
		
		@Test
		void testCase10() throws MalformedURLException, IOException {
				SSHFileStorage sshFileStorage0 = new SSHFileStorage();
				sshFileStorage0.open(""ssh://user@host:80/path/"", (LagoonContext) null, ""password"");
				OutputHandler outputHandler0 = sshFileStorage0.createFile("""");
				outputHandler0.discard();
				sshFileStorage0.close();
		}
}"
cmpl-6wVEkzdM2J8yJmgjeWuPbXQ2ajD2g,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/util/Wildcard_0Test.java,39.85596060752869,stop,"// Wildcard.java
/*
 * Copyright (c) 2001, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.util;

import java.util.*;

/**
 * Wildcard processing methods. All methods in this class are static.
 *
 * A wildcard pattern consists of one or more simple patterns, separated by ';'.
 * A simple pattern may contain one '*' which match any string
 * (including the empty string).
 */
public final class Wildcard {

    /**
     * Private default constructor to prevent instantiation.
     */
    private Wildcard() {
    }

    /**
     * Check if a wildcard pattern can possibly match more than one filename.
     *
     * @param pattern  the wildcard pattern to test
     */
    public static boolean isWildcard(String pattern) {
        return (pattern.indexOf('*') >= 0) || (pattern.indexOf(';') >= 0);
    }

    /**
     * Attempt to match a filename matches to wildcard pattern.
     *
     * @param pattern   the wildcard pattern
     * @param filename  the filename
     *
     * @return the string substituted into the pattern,
     *         or null if no match could be made
     */
    public static String matchWildcard(String pattern, String filename) {
        StringTokenizer st = new StringTokenizer(pattern, "";"");
        while (st.hasMoreTokens()) {
            String pat = st.nextToken();
            int star = pat.indexOf('*');
            if (star < 0) {
                if (pat.equals(filename))
                    return """";
            } else {
                if (!filename.startsWith(pat.substring(0, star)))
                    continue;
                if (!filename.endsWith(pat.substring(star + 1)))
                    continue;
                return filename.substring(star, star + filename.length() - pat.length() + 1);
            }
        }
        return null;
    }

    /**
     * Instantiate a wildcard pattern to a filename.
     *
     * @param pattern   the wildcard pattern
     * @param part      the string to substitue into the pattern
     *                  (returned from matchWildcard)
     *
     * @return  the filename
     *
     * @see #matchWildcard
     */
    public static String instantiateWildcard(String pattern, String part) {
        int star = pattern.indexOf('*');
        if (star < 0)
            return pattern;
        return pattern.substring(0, star) + part + pattern.substring(star + 1);
    }
}
","// Wildcard_0Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#isWildcard(String)} method.
*/
class Wildcard_0Test {","// Wildcard_0Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#isWildcard(String)} method.
*/
class Wildcard_0Test {

	@Test
	void testIsWildcard_0() {
		assertTrue(Wildcard.isWildcard(""*""));
	}
	
	@Test
	void testIsWildcard_1() {
		assertTrue(Wildcard.isWildcard(""*.html""));
	}
	
	@Test
	void testIsWildcard_2() {
		assertTrue(Wildcard.isWildcard(""*.html;*.xml""));
	}
	
	@Test
	void testIsWildcard_3() {
		assertTrue(Wildcard.isWildcard(""*.html;*.xml;*.txt""));
	}
	
	@Test
	void testIsWildcard_4() {
		assertTrue(Wildcard.isWildcard(""*.html;*.xml;*.txt;*.xsl""));
	}
	
	@Test
	void testIsWildcard_5() {
		assertTrue(Wildcard.isWildcard(""*.html;*.xml;*.txt;*.xsl;*.css""));
	}
	
	@Test
	void testIsWildcard_6() {
		assertTrue(Wildcard.isWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js""));
	}
	
	@Test
	void testIsWildcard_7() {
		assertTrue(Wildcard.isWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js;*.jpg""));
	}
	
	@Test
	void testIsWildcard_8() {
		assertTrue(Wildcard.isWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js;*.jpg;*.gif""));
	}
	
	@Test
	void testIsWildcard_9() {
		assertTrue(Wildcard.isWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js;*.jpg;*.gif;*.png""));
	}
}

// Wildcard_1Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#matchWildcard(String, String)} method.
*/
class Wildcard_1Test {
		
	@Test
	void testMatchWildcard_0() {
		assertEquals("""", Wildcard.matchWildcard(""*"", """"));
	}
	
	@Test
	void testMatchWildcard_1() {
		assertEquals("""", Wildcard.matchWildcard(""*.html"", """"));
	}
	
	@Test
	void testMatchWildcard_2() {
		assertEquals("""", Wildcard.matchWildcard(""*.html;*.xml"", """"));
	}
	
	@Test
	void testMatchWildcard_3() {
		assertEquals("""", Wildcard.matchWildcard(""*.html;*.xml;*.txt"", """"));
	}
	
	@Test
	void testMatchWildcard_4() {
		assertEquals("""", Wildcard.matchWildcard(""*.html;*.xml;*.txt;*.xsl"", """"));
	}
	
	@Test
	void testMatchWildcard_5() {
		assertEquals("""", Wildcard.matchWildcard(""*.html;*.xml;*.txt;*.xsl;*.css"", """"));
	}
	
	@Test
	void testMatchWildcard_6() {
		assertEquals("""", Wildcard.matchWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js"", """"));
	}
	
	@Test
	void testMatchWildcard_7() {
		assertEquals("""", Wildcard.matchWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js;*.jpg"", """"));
	}
	
	@Test
	void testMatchWildcard_8() {
		assertEquals("""", Wildcard.matchWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js;*.jpg;*.gif"", """"));
	}
	
	@Test
	void testMatchWildcard_9() {
		assertEquals("""", Wildcard.matchWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js;*.jpg;*.gif;*.png"", """"));
	}
}

// Wildcard_2Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#instantiateWildcard(String, String)} method.
*/
class Wildcard_2Test {
		
	@Test
	void testInstantiateWildcard_0() {
		assertEquals("""", Wildcard.instantiateWildcard(""*"", """"));
	}
	
	@Test
	void testInstantiateWildcard_1() {
		assertEquals("""", Wildcard.instantiateWildcard(""*.html"", """"));
	}
	
	@Test
	void testInstantiateWildcard_2() {
		assertEquals("""", Wildcard.instantiateWildcard(""*.html;*.xml"", """"));
	}
	
	@Test
	void testInstantiateWildcard_3() {
		assertEquals("""", Wildcard.instantiateWildcard(""*.html;*.xml;*.txt"", """"));
	}
	
	@Test
	void testInstantiateWildcard_4() {
		assertEquals("""", Wildcard.instantiateWildcard(""*.html;*.xml;*.txt;*.xsl"", """"));
	}
	
	@Test
	void testInstantiateWildcard_5() {
		assertEquals("""", Wildcard.instantiateWildcard(""*.html;*.xml;*.txt;*.xsl;*.css"", """"));
	}
	
	@Test
	void testInstantiateWildcard_6() {
		assertEquals("""", Wildcard.instantiateWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js"", """"));
	}
	
	@Test
	void testInstantiateWildcard_7() {
		assertEquals("""", Wildcard.instantiateWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js;*.jpg"", """"));
	}
	
	@Test
	void testInstantiateWildcard_8() {
		assertEquals("""", Wildcard.instantiateWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js;*.jpg;*.gif"", """"));
	}
	
	@Test
	void testInstantiateWildcard_9() {
		assertEquals("""", Wildcard.instantiateWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js;*.jpg;*.gif;*.png"", """"));
	}
}"
cmpl-6wVFnx8ohthVxCHB6CZUrbzL595YY,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/util/Wildcard_1Test.java,55.67647051811218,length,"// Wildcard.java
/*
 * Copyright (c) 2001, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.util;

import java.util.*;

/**
 * Wildcard processing methods. All methods in this class are static.
 *
 * A wildcard pattern consists of one or more simple patterns, separated by ';'.
 * A simple pattern may contain one '*' which match any string
 * (including the empty string).
 */
public final class Wildcard {

    /**
     * Private default constructor to prevent instantiation.
     */
    private Wildcard() {
    }

    /**
     * Check if a wildcard pattern can possibly match more than one filename.
     *
     * @param pattern  the wildcard pattern to test
     */
    public static boolean isWildcard(String pattern) {
        return (pattern.indexOf('*') >= 0) || (pattern.indexOf(';') >= 0);
    }

    /**
     * Attempt to match a filename matches to wildcard pattern.
     *
     * @param pattern   the wildcard pattern
     * @param filename  the filename
     *
     * @return the string substituted into the pattern,
     *         or null if no match could be made
     */
    public static String matchWildcard(String pattern, String filename) {
        StringTokenizer st = new StringTokenizer(pattern, "";"");
        while (st.hasMoreTokens()) {
            String pat = st.nextToken();
            int star = pat.indexOf('*');
            if (star < 0) {
                if (pat.equals(filename))
                    return """";
            } else {
                if (!filename.startsWith(pat.substring(0, star)))
                    continue;
                if (!filename.endsWith(pat.substring(star + 1)))
                    continue;
                return filename.substring(star, star + filename.length() - pat.length() + 1);
            }
        }
        return null;
    }

    /**
     * Instantiate a wildcard pattern to a filename.
     *
     * @param pattern   the wildcard pattern
     * @param part      the string to substitue into the pattern
     *                  (returned from matchWildcard)
     *
     * @return  the filename
     *
     * @see #matchWildcard
     */
    public static String instantiateWildcard(String pattern, String part) {
        int star = pattern.indexOf('*');
        if (star < 0)
            return pattern;
        return pattern.substring(0, star) + part + pattern.substring(star + 1);
    }
}
","// Wildcard_1Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#matchWildcard(String, String)} method.
*/
class Wildcard_1Test {","// Wildcard_1Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#matchWildcard(String, String)} method.
*/
class Wildcard_1Test {

	/**
	 * Test case 1 for {@link Wildcard#matchWildcard(String, String)}.
	 * <p>
	 * Test case 1 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the filename is ""index.html"".
	 * The method should return the empty string.
	 */
	@Test
	void testMatchWildcard_1() {
		String pattern = ""*.html"";
		String filename = ""index.html"";
		String expected = """";
		String actual = Wildcard.matchWildcard(pattern, filename);
		assertEquals(expected, actual);
	}
	
	/**
	 * Test case 2 for {@link Wildcard#matchWildcard(String, String)}.
	 * <p>
	 * Test case 2 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the filename is ""index.htm"".
	 * The method should return null.
	 */
	@Test
	void testMatchWildcard_2() {
		String pattern = ""*.html"";
		String filename = ""index.htm"";
		String expected = null;
		String actual = Wildcard.matchWildcard(pattern, filename);
		assertEquals(expected, actual);
	}
	
	/**
	 * Test case 3 for {@link Wildcard#matchWildcard(String, String)}.
	 * <p>
	 * Test case 3 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the filename is ""index.html.bak"".
	 * The method should return null.
	 */
	@Test
	void testMatchWildcard_3() {
		String pattern = ""*.html"";
		String filename = ""index.html.bak"";
		String expected = null;
		String actual = Wildcard.matchWildcard(pattern, filename);
		assertEquals(expected, actual);
	}
	
	/**
	 * Test case 4 for {@link Wildcard#matchWildcard(String, String)}.
	 * <p>
	 * Test case 4 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the filename is ""index.html.bak"".
	 * The method should return null.
	 */
	@Test
	void testMatchWildcard_4() {
		String pattern = ""*.html"";
		String filename = ""index.html.bak"";
		String expected = null;
		String actual = Wildcard.matchWildcard(pattern, filename);
		assertEquals(expected, actual);
	}
	
	/**
	 * Test case 5 for {@link Wildcard#matchWildcard(String, String)}.
	 * <p>
	 * Test case 5 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the filename is ""index.html.bak"".
	 * The method should return null.
	 */
	@Test
	void testMatchWildcard_5() {
		String pattern = ""*.html"";
		String filename = ""index.html.bak"";
		String expected = null;
		String actual = Wildcard.matchWildcard(pattern, filename);
		assertEquals(expected, actual);
	}
	
	/**
	 * Test case 6 for {@link Wildcard#matchWildcard(String, String)}.
	 * <p>
	 * Test case 6 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the filename is ""index.html.bak"".
	 * The method should return null.
	 */
	@Test
	void testMatchWildcard_6() {
		String pattern = ""*.html"";
		String filename = ""index.html.bak"";
		String expected = null;
		String actual = Wildcard.matchWildcard(pattern, filename);
		assertEquals(expected, actual);
	}
	
	/**
	 * Test case 7 for {@link Wildcard#matchWildcard(String, String)}.
	 * <p>
	 * Test case 7 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the filename is ""index.html.bak"".
	 * The method should return null.
	 */
	@Test
	void testMatchWildcard_7() {
		String pattern = ""*.html"";
		String filename = ""index.html.bak"";
		String expected = null;
		String actual = Wildcard.matchWildcard(pattern, filename);
		assertEquals(expected, actual);
	}
	
	/**
	 * Test case 8 for {@link Wildcard#matchWildcard(String, String)}.
	 * <p>
	 * Test case 8 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the filename is ""index.html.bak"".
	 * The method should return null.
	 */
	@Test
	void testMatchWildcard_8() {
		String pattern = ""*.html"";
		String filename = ""index.html.bak"";
		String expected = null;
		String actual = Wildcard.matchWildcard(pattern, filename);
		assertEquals(expected, actual);
	}
	
	/**
	 * Test case 9 for {@link Wildcard#matchWildcard(String, String)}.
	 * <p>
	 * Test case 9 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the filename is ""index.html.bak"".
	 * The method should return null.
	 */
	@Test
	void testMatchWildcard_9() {
		String pattern = ""*.html"";
		String filename = ""index.html.bak"";
		String expected = null;
		String actual = Wildcard.matchWildcard(pattern, filename);
		assertEquals(expected, actual);
	}
	
	/**
	 * Test case 10 for {@link Wildcard#matchWildcard(String, String)}.
	 * <p>
	 * Test case 10 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the filename is ""index.html.bak"".
	 * The method should return null.
	 */
	@Test
	void testMatchWildcard_10() {
		String pattern = ""*.html"";
		String filename = ""index.html.bak"";
		String expected = null;
		String actual = Wildcard.matchWildcard(pattern, filename);
		assertEquals(expected, actual);
	}
}

// Wildcard_2Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#instantiateWildcard(String, String)} method.
*/
class Wildcard_2Test {
		
	/**
	 * Test case 1 for {@link Wildcard#instantiateWildcard(String, String)}.
	 * <p>
	 * Test case 1 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the part is ""index"".
	 * The method should return ""index.html"".
	 */
	@Test
	void testInstantiateWildcard_1() {
		String pattern = ""*.html"";
		String part = ""index"";
		String expected = ""index.html"";
		String actual = Wildcard.instantiateWildcard(pattern, part);
		assertEquals(expected, actual);
	}
	
	/**
	 * Test case 2 for {@link Wildcard#instantiateWildcard(String, String)}.
	 * <p>
	 * Test case 2 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the part is ""index"".
	 * The method should return ""index.html"".
	 */
	@Test
	void testInstantiateWildcard_2()"
cmpl-6wVGq9BAyEIp0snddijCbQM1bd7Uu,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/util/Wildcard_2Test.java,50.544450759887695,length,"// Wildcard.java
/*
 * Copyright (c) 2001, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.util;

import java.util.*;

/**
 * Wildcard processing methods. All methods in this class are static.
 *
 * A wildcard pattern consists of one or more simple patterns, separated by ';'.
 * A simple pattern may contain one '*' which match any string
 * (including the empty string).
 */
public final class Wildcard {

    /**
     * Private default constructor to prevent instantiation.
     */
    private Wildcard() {
    }

    /**
     * Check if a wildcard pattern can possibly match more than one filename.
     *
     * @param pattern  the wildcard pattern to test
     */
    public static boolean isWildcard(String pattern) {
        return (pattern.indexOf('*') >= 0) || (pattern.indexOf(';') >= 0);
    }

    /**
     * Attempt to match a filename matches to wildcard pattern.
     *
     * @param pattern   the wildcard pattern
     * @param filename  the filename
     *
     * @return the string substituted into the pattern,
     *         or null if no match could be made
     */
    public static String matchWildcard(String pattern, String filename) {
        StringTokenizer st = new StringTokenizer(pattern, "";"");
        while (st.hasMoreTokens()) {
            String pat = st.nextToken();
            int star = pat.indexOf('*');
            if (star < 0) {
                if (pat.equals(filename))
                    return """";
            } else {
                if (!filename.startsWith(pat.substring(0, star)))
                    continue;
                if (!filename.endsWith(pat.substring(star + 1)))
                    continue;
                return filename.substring(star, star + filename.length() - pat.length() + 1);
            }
        }
        return null;
    }

    /**
     * Instantiate a wildcard pattern to a filename.
     *
     * @param pattern   the wildcard pattern
     * @param part      the string to substitue into the pattern
     *                  (returned from matchWildcard)
     *
     * @return  the filename
     *
     * @see #matchWildcard
     */
    public static String instantiateWildcard(String pattern, String part) {
        int star = pattern.indexOf('*');
        if (star < 0)
            return pattern;
        return pattern.substring(0, star) + part + pattern.substring(star + 1);
    }
}
","// Wildcard_2Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#instantiateWildcard(String, String)} method.
*/
class Wildcard_2Test {","// Wildcard_2Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#instantiateWildcard(String, String)} method.
*/
class Wildcard_2Test {

	/**
	* Test case 1 for {@link Wildcard#instantiateWildcard(String, String)}.
	*/
	@Test
	void testInstantiateWildcard_1() {
		String pattern = """";
		String part = """";
		String result = Wildcard.instantiateWildcard(pattern, part);
		assertEquals("""", result);
	}
	
	/**
	* Test case 2 for {@link Wildcard#instantiateWildcard(String, String)}.
	*/
	@Test
	void testInstantiateWildcard_2() {
		String pattern = ""*"";
		String part = """";
		String result = Wildcard.instantiateWildcard(pattern, part);
		assertEquals("""", result);
	}
	
	/**
	* Test case 3 for {@link Wildcard#instantiateWildcard(String, String)}.
	*/
	@Test
	void testInstantiateWildcard_3() {
		String pattern = ""*"";
		String part = ""a"";
		String result = Wildcard.instantiateWildcard(pattern, part);
		assertEquals(""a"", result);
	}
	
	/**
	* Test case 4 for {@link Wildcard#instantiateWildcard(String, String)}.
	*/
	@Test
	void testInstantiateWildcard_4() {
		String pattern = ""a*"";
		String part = """";
		String result = Wildcard.instantiateWildcard(pattern, part);
		assertEquals(""a"", result);
	}
	
	/**
	* Test case 5 for {@link Wildcard#instantiateWildcard(String, String)}.
	*/
	@Test
	void testInstantiateWildcard_5() {
		String pattern = ""a*"";
		String part = ""b"";
		String result = Wildcard.instantiateWildcard(pattern, part);
		assertEquals(""ab"", result);
	}
	
	/**
	* Test case 6 for {@link Wildcard#instantiateWildcard(String, String)}.
	*/
	@Test
	void testInstantiateWildcard_6() {
		String pattern = ""*a"";
		String part = """";
		String result = Wildcard.instantiateWildcard(pattern, part);
		assertEquals(""a"", result);
	}
	
	/**
	* Test case 7 for {@link Wildcard#instantiateWildcard(String, String)}.
	*/
	@Test
	void testInstantiateWildcard_7() {
		String pattern = ""*a"";
		String part = ""b"";
		String result = Wildcard.instantiateWildcard(pattern, part);
		assertEquals(""ba"", result);
	}
	
	/**
	* Test case 8 for {@link Wildcard#instantiateWildcard(String, String)}.
	*/
	@Test
	void testInstantiateWildcard_8() {
		String pattern = ""a*b"";
		String part = """";
		String result = Wildcard.instantiateWildcard(pattern, part);
		assertEquals(""ab"", result);
	}
	
	/**
	* Test case 9 for {@link Wildcard#instantiateWildcard(String, String)}.
	*/
	@Test
	void testInstantiateWildcard_9() {
		String pattern = ""a*b"";
		String part = ""c"";
		String result = Wildcard.instantiateWildcard(pattern, part);
		assertEquals(""acb"", result);
	}
	
	/**
	* Test case 10 for {@link Wildcard#instantiateWildcard(String, String)}.
	*/
	@Test
	void testInstantiateWildcard_10() {
		String pattern = ""a*b*c"";
		String part = ""d"";
		String result = Wildcard.instantiateWildcard(pattern, part);
		assertEquals(""adb*c"", result);
	}
}

// Wildcard_3Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#matchWildcard(String, String)} method.
*/
class Wildcard_3Test {
		
	/**
	* Test case 1 for {@link Wildcard#matchWildcard(String, String)}.
	*/
	@Test
	void testMatchWildcard_1() {
		String pattern = """";
		String filename = """";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertEquals("""", result);
	}
	
	/**
	* Test case 2 for {@link Wildcard#matchWildcard(String, String)}.
	*/
	@Test
	void testMatchWildcard_2() {
		String pattern = """";
		String filename = ""a"";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertNull(result);
	}
	
	/**
	* Test case 3 for {@link Wildcard#matchWildcard(String, String)}.
	*/
	@Test
	void testMatchWildcard_3() {
		String pattern = ""a"";
		String filename = """";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertNull(result);
	}
	
	/**
	* Test case 4 for {@link Wildcard#matchWildcard(String, String)}.
	*/
	@Test
	void testMatchWildcard_4() {
		String pattern = ""a"";
		String filename = ""a"";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertEquals("""", result);
	}
	
	/**
	* Test case 5 for {@link Wildcard#matchWildcard(String, String)}.
	*/
	@Test
	void testMatchWildcard_5() {
		String pattern = ""a"";
		String filename = ""b"";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertNull(result);
	}
	
	/**
	* Test case 6 for {@link Wildcard#matchWildcard(String, String)}.
	*/
	@Test
	void testMatchWildcard_6() {
		String pattern = ""*"";
		String filename = """";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertEquals("""", result);
	}
	
	/**
	* Test case 7 for {@link Wildcard#matchWildcard(String, String)}.
	*/
	@Test
	void testMatchWildcard_7() {
		String pattern = ""*"";
		String filename = ""a"";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertEquals(""a"", result);
	}
	
	/**
	* Test case 8 for {@link Wildcard#matchWildcard(String, String)}.
	*/
	@Test
	void testMatchWildcard_8() {
		String pattern = ""a*"";
		String filename = """";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertNull(result);
	}
	
	/**
	* Test case 9 for {@link Wildcard#matchWildcard(String, String)}.
	*/
	@Test
	void testMatchWildcard_9() {
		String pattern = ""a*"";
		String filename = ""a"";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertEquals("""", result);
	}
	
	/**
	* Test case 10 for {@link Wildcard#matchWildcard(String, String)}.
	*/
	@Test
	void testMatchWildcard_10() {
		String pattern = ""a*"";
		String filename = """
cmpl-6wVHtC2FmtCZFMnFahQ3g35E4ADLW,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_0Test.java,57.46642708778381,length,"// Element.java
/*
 * Copyright (c) 2001, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_0Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#lookupAttribute(String, String)} method.
*/
class Element_0Test {","// Element_0Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#lookupAttribute(String, String)} method.
*/
class Element_0Test {

		@Test
		void test_lookupAttribute_0() {
			Element element = new Element("""", """", 0);
			int result = element.lookupAttribute("""", """");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_1() {
			Element element = new Element("""", """", 0);
			int result = element.lookupAttribute("""", ""a"");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_2() {
			Element element = new Element("""", """", 0);
			int result = element.lookupAttribute(""a"", """");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_3() {
			Element element = new Element("""", """", 0);
			int result = element.lookupAttribute(""a"", ""a"");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_4() {
			Element element = new Element("""", """", 1);
			int result = element.lookupAttribute("""", """");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_5() {
			Element element = new Element("""", """", 1);
			int result = element.lookupAttribute("""", ""a"");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_6() {
			Element element = new Element("""", """", 1);
			int result = element.lookupAttribute(""a"", """");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_7() {
			Element element = new Element("""", """", 1);
			int result = element.lookupAttribute(""a"", ""a"");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_8() {
			Element element = new Element("""", """", 1);
			element.addAttribute("""", """", """", """");
			int result = element.lookupAttribute("""", """");
			assertEquals(0, result);
		}
		
		@Test
		void test_lookupAttribute_9() {
			Element element = new Element("""", """", 1);
			element.addAttribute("""", ""a"", """", """");
			int result = element.lookupAttribute("""", ""a"");
			assertEquals(0, result);
		}
		
		@Test
		void test_lookupAttribute_10() {
			Element element = new Element("""", """", 1);
			element.addAttribute(""a"", """", """", """");
			int result = element.lookupAttribute(""a"", """");
			assertEquals(0, result);
		}
		
		@Test
		void test_lookupAttribute_11() {
			Element element = new Element("""", """", 1);
			element.addAttribute(""a"", ""a"", """", """");
			int result = element.lookupAttribute(""a"", ""a"");
			assertEquals(0, result);
		}
		
		@Test
		void test_lookupAttribute_12() {
			Element element = new Element("""", """", 2);
			element.addAttribute("""", """", """", """");
			element.addAttribute("""", ""a"", """", """");
			int result = element.lookupAttribute("""", """");
			assertEquals(0, result);
		}
		
		@Test
		void test_lookupAttribute_13() {
			Element element = new Element("""", """", 2);
			element.addAttribute("""", """", """", """");
			element.addAttribute("""", ""a"", """", """");
			int result = element.lookupAttribute("""", ""a"");
			assertEquals(1, result);
		}
		
		@Test
		void test_lookupAttribute_14() {
			Element element = new Element("""", """", 2);
			element.addAttribute(""a"", """", """", """");
			element.addAttribute("""", ""a"", """", """");
			int result = element.lookupAttribute(""a"", """");
			assertEquals(0, result);
		}
		
		@Test
		void test_lookupAttribute_15() {
			Element element = new Element("""", """", 2);
			element.addAttribute(""a"", """", """", """");
			element.addAttribute("""", ""a"", """", """");
			int result = element.lookupAttribute(""a"", ""a"");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_16() {
			Element element = new Element("""", """", 2);
			element.addAttribute("""", """", """", """");
			element.addAttribute(""a"", """", """", """");
			int result = element.lookupAttribute("""", """");
			assertEquals(0, result);
		}
		
		@Test
		void test_lookupAttribute_17() {
			Element element = new Element("""", """", 2);
			element.addAttribute("""", """", """", """");
			element.addAttribute(""a"", """", """", """");
			int result = element.lookupAttribute("""", ""a"");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_18() {
			Element element = new Element("""", """", 2);
			element.addAttribute("""", """", """", """");
			element.addAttribute(""a"", """", """", """");
			int result = element.lookupAttribute(""a"", """");
			assertEquals(1, result);
		}
		
		@Test
		void test_lookupAttribute_19() {
			Element element = new Element("""", """", 2);
			element.addAttribute("""", """", """", """");
			element.addAttribute(""a"", """", """", """");
			int result = element.lookupAttribute(""a"", ""a"");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_20() {
			Element element = new Element("""", """", 2);
			element.addAttribute(""a"", """", """", """");
			element.addAttribute("""", ""a"", """", """");
			int result = element.lookupAttribute("""", """");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_21() {
			Element element = new Element("""", """", 2);
			element.addAttribute(""a"", """", """", """");
			element.addAttribute("""", ""a"", """", """");
			int result = element.lookupAttribute("""", ""a"");
			assertEquals(1, result);
		}
		
		@Test
		void test_lookupAttribute_22() {
			Element element = new Element("""", """", 2);
			element.addAttribute(""a"", """", """", """");
			element.addAttribute("""", ""a"", """", """");
			int result = element.lookupAttribute(""a"
cmpl-6wVIwxcYFzId0dPt8tqMdUK6d2xc7,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_1Test.java,65.21377372741699,length,"// Element.java
/*
 * Copyright (c) 2001, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_1Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#numberOfAttributes()} method.
*/
class Element_1Test {","// Element_1Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#numberOfAttributes()} method.
*/
class Element_1Test {

	@Test
	void test_numberOfAttributes_1() {
		Element element = new Element("""", """", 0);
		assertEquals(0, element.numberOfAttributes());
	}
	
	@Test
	void test_numberOfAttributes_2() {
		Element element = new Element("""", """", 1);
		assertEquals(0, element.numberOfAttributes());
	}
	
	@Test
	void test_numberOfAttributes_3() {
		Element element = new Element("""", """", 2);
		assertEquals(0, element.numberOfAttributes());
	}
	
	@Test
	void test_numberOfAttributes_4() {
		Element element = new Element("""", """", 3);
		assertEquals(0, element.numberOfAttributes());
	}
	
	@Test
	void test_numberOfAttributes_5() {
		Element element = new Element("""", """", 4);
		assertEquals(0, element.numberOfAttributes());
	}
	
	@Test
	void test_numberOfAttributes_6() {
		Element element = new Element("""", """", 5);
		assertEquals(0, element.numberOfAttributes());
	}
	
	@Test
	void test_numberOfAttributes_7() {
		Element element = new Element("""", """", 6);
		assertEquals(0, element.numberOfAttributes());
	}
	
	@Test
	void test_numberOfAttributes_8() {
		Element element = new Element("""", """", 7);
		assertEquals(0, element.numberOfAttributes());
	}
	
	@Test
	void test_numberOfAttributes_9() {
		Element element = new Element("""", """", 8);
		assertEquals(0, element.numberOfAttributes());
	}
	
	@Test
	void test_numberOfAttributes_10() {
		Element element = new Element("""", """", 9);
		assertEquals(0, element.numberOfAttributes());
	}
}

// Element_2Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#addAttribute(String, String, String, String)} method.
*/
class Element_2Test {
		
	@Test
	void test_addAttribute_1() {
		Element element = new Element("""", """", 0);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_2() {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_3() {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_4() {
		Element element = new Element("""", """", 3);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_5() {
		Element element = new Element("""", """", 4);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_6() {
		Element element = new Element("""", """", 5);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_7() {
		Element element = new Element("""", """", 6);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_8() {
		Element element = new Element("""", """", 7);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_9() {
		Element element = new Element("""", """", 8);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_10() {
		Element element = new Element("""", """", 9);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
}

// Element_3Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#addAttribute(String, String, String, String)} method.
*/
class Element_3Test {
		
	@Test
	void test_addAttribute_1() {
		Element element = new Element("""", """", 0);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_2() {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_3() {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_4() {
		Element element = new Element("""", """", 3);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_5() {
		Element element = new Element("""", """", 4);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_6() {
		Element element = new Element("""", """", 5);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_7() {
		Element element = new Element("""", """", 6);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_8() {
		Element element = new Element("""", """", 7);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_9() {
		Element element = new Element("""", """", 8);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element"
cmpl-6wVK0Yc3XynqRRIyGVk1MZyyhUI45,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_2Test.java,66.44813919067383,length,"// Element.java
/*
 * Copyright (c) 2001, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_2Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeNamespaceURI(int)} method.
*/
class Element_2Test {","// Element_2Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeNamespaceURI(int)} method.
*/
class Element_2Test {

	@Test
	void testGetAttributeNamespaceURI_0() throws Exception {
		Element element = new Element("""", """", 0);
		assertEquals(null, element.getAttributeNamespaceURI(-1));
	}
	
	@Test
	void testGetAttributeNamespaceURI_1() throws Exception {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeNamespaceURI(0));
	}
	
	@Test
	void testGetAttributeNamespaceURI_2() throws Exception {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeNamespaceURI(1));
	}
	
	@Test
	void testGetAttributeNamespaceURI_3() throws Exception {
		Element element = new Element("""", """", 3);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeNamespaceURI(2));
	}
	
	@Test
	void testGetAttributeNamespaceURI_4() throws Exception {
		Element element = new Element("""", """", 4);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeNamespaceURI(3));
	}
	
	@Test
	void testGetAttributeNamespaceURI_5() throws Exception {
		Element element = new Element("""", """", 5);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeNamespaceURI(4));
	}
	
	@Test
	void testGetAttributeNamespaceURI_6() throws Exception {
		Element element = new Element("""", """", 6);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeNamespaceURI(5));
	}
	
	@Test
	void testGetAttributeNamespaceURI_7() throws Exception {
		Element element = new Element("""", """", 7);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeNamespaceURI(6));
	}
	
	@Test
	void testGetAttributeNamespaceURI_8() throws Exception {
		Element element = new Element("""", """", 8);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeNamespaceURI(7));
	}
	
	@Test
	void testGetAttributeNamespaceURI_9() throws Exception {
		Element element = new Element("""", """", 9);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeNamespaceURI(8));
	}
	
}

// Element_3Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeLocalName(int)} method.
*/
class Element_3Test {
		
	@Test
	void testGetAttributeLocalName_0() throws Exception {
		Element element = new Element("""", """", 0);
		assertEquals(null, element.getAttributeLocalName(-1));
	}
	
	@Test
	void testGetAttributeLocalName_1() throws Exception {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeLocalName(0));
	}
	
	@Test
	void testGetAttributeLocalName_2() throws Exception {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeLocalName(1));
	}
	
	@Test
	void testGetAttributeLocalName_3() throws Exception {
		Element element = new Element("""", """", 3);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeLocalName(2));
	}
	
	@Test
	void testGetAttributeLocalName_4() throws Exception {
		Element element = new Element("""", """", 4);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeLocalName(3));
	}
	
	@Test
	void testGetAttributeLocalName_5() throws Exception {
		Element element = new Element("""", """", 5);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeLocalName(4));
	}
	
	@Test
	void testGetAttributeLocalName_6() throws Exception {
		Element element = new Element("""", """", 6);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute"
cmpl-6wVL48vk8frCnVty1o7EImpZMXr6u,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_3Test.java,64.1806800365448,length,"// Element.java
/*
 * Copyright (c) 2001, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_3Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeLocalName(int)} method.
*/
class Element_3Test {","// Element_3Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeLocalName(int)} method.
*/
class Element_3Test {

	@Test
	void testGetAttributeLocalName_0() {
		Element element = new Element("""", """", 0);
		int index = -1;
		String result = element.getAttributeLocalName(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeLocalName_1() {
		Element element = new Element("""", """", 1);
		int index = 0;
		String result = element.getAttributeLocalName(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeLocalName_2() {
		Element element = new Element("""", """", 2);
		int index = 0;
		String result = element.getAttributeLocalName(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeLocalName_3() {
		Element element = new Element("""", """", 3);
		int index = 0;
		String result = element.getAttributeLocalName(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeLocalName_4() {
		Element element = new Element("""", """", 4);
		int index = 0;
		String result = element.getAttributeLocalName(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeLocalName_5() {
		Element element = new Element("""", """", 5);
		int index = 0;
		String result = element.getAttributeLocalName(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeLocalName_6() {
		Element element = new Element("""", """", 6);
		int index = 0;
		String result = element.getAttributeLocalName(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeLocalName_7() {
		Element element = new Element("""", """", 7);
		int index = 0;
		String result = element.getAttributeLocalName(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeLocalName_8() {
		Element element = new Element("""", """", 8);
		int index = 0;
		String result = element.getAttributeLocalName(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeLocalName_9() {
		Element element = new Element("""", """", 9);
		int index = 0;
		String result = element.getAttributeLocalName(index);
		assertNull(result);
	}
	
}

// Element_4Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeNamespaceURI(int)} method.
*/
class Element_4Test {
		
	@Test
	void testGetAttributeNamespaceURI_0() {
		Element element = new Element("""", """", 0);
		int index = -1;
		String result = element.getAttributeNamespaceURI(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeNamespaceURI_1() {
		Element element = new Element("""", """", 1);
		int index = 0;
		String result = element.getAttributeNamespaceURI(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeNamespaceURI_2() {
		Element element = new Element("""", """", 2);
		int index = 0;
		String result = element.getAttributeNamespaceURI(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeNamespaceURI_3() {
		Element element = new Element("""", """", 3);
		int index = 0;
		String result = element.getAttributeNamespaceURI(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeNamespaceURI_4() {
		Element element = new Element("""", """", 4);
		int index = 0;
		String result = element.getAttributeNamespaceURI(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeNamespaceURI_5() {
		Element element = new Element("""", """", 5);
		int index = 0;
		String result = element.getAttributeNamespaceURI(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeNamespaceURI_6() {
		Element element = new Element("""", """", 6);
		int index = 0;
		String result = element.getAttributeNamespaceURI(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeNamespaceURI_7() {
		Element element = new Element("""", """", 7);
		int index = 0;
		String result = element.getAttributeNamespaceURI(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeNamespaceURI_8() {
		Element element = new Element("""", """", 8);
		int index = 0;
		String result = element.getAttributeNamespaceURI(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeNamespaceURI_9() {
		Element element = new Element("""", """", 9);
		int index = 0;
		String result = element.getAttributeNamespaceURI(index);
		assertNull(result);
	}
	
}

// Element_5Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeType(int)} method.
*/
class Element_5Test {
		
	@Test
	void testGetAttributeType_0() {
		Element element = new Element("""", """", 0);
		int index = -1;
		String result = element.getAttributeType(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeType_1() {
		Element element = new Element("""", """", 1);
		int index = 0;
		String result = element.getAttributeType(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeType_2() {
		Element element = new Element("""", """", 2);
		int index = 0;
		String result = element.getAttributeType(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeType_3() {
		Element element = new Element("""", """", 3);
		int index = 0;
		String result = element.getAttributeType(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeType_4() {
		Element element = new Element("""", """", 4);
		int index = 0;
		String result = element.getAttributeType(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeType_5() {
		Element element = new Element("""", """", 5);
		int index = 0;
		String result = element.getAttribute"
cmpl-6wVM6cWpwYLfFuDy3Tugnb6RDoPtz,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_4Test.java,63.4152672290802,length,"// Element.java
/*
 * Copyright (c) 2001, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_4Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeType(int)} method.
*/
class Element_4Test {","// Element_4Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeType(int)} method.
*/
class Element_4Test {

		@Test
		void test_getAttributeType_1() {
				Element element = new Element("""", """", 0);
				assertEquals(null, element.getAttributeType(-1));
		}
		
		@Test
		void test_getAttributeType_2() {
				Element element = new Element("""", """", 0);
				assertEquals(null, element.getAttributeType(0));
		}
		
		@Test
		void test_getAttributeType_3() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", """", """");
				assertEquals("""", element.getAttributeType(0));
		}
		
		@Test
		void test_getAttributeType_4() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""CDATA"", """");
				assertEquals(""CDATA"", element.getAttributeType(0));
		}
		
		@Test
		void test_getAttributeType_5() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""ID"", """");
				assertEquals(""ID"", element.getAttributeType(0));
		}
		
		@Test
		void test_getAttributeType_6() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""IDREF"", """");
				assertEquals(""IDREF"", element.getAttributeType(0));
		}
		
		@Test
		void test_getAttributeType_7() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""IDREFS"", """");
				assertEquals(""IDREFS"", element.getAttributeType(0));
		}
		
		@Test
		void test_getAttributeType_8() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""NMTOKEN"", """");
				assertEquals(""NMTOKEN"", element.getAttributeType(0));
		}
		
		@Test
		void test_getAttributeType_9() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""NMTOKENS"", """");
				assertEquals(""NMTOKENS"", element.getAttributeType(0));
		}
		
		@Test
		void test_getAttributeType_10() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""ENTITY"", """");
				assertEquals(""ENTITY"", element.getAttributeType(0));
		}
		
}

// Element_5Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeValue(int)} method.
*/
class Element_5Test {
		
		@Test
		void test_getAttributeValue_1() {
				Element element = new Element("""", """", 0);
				assertEquals(null, element.getAttributeValue(-1));
		}
		
		@Test
		void test_getAttributeValue_2() {
				Element element = new Element("""", """", 0);
				assertEquals(null, element.getAttributeValue(0));
		}
		
		@Test
		void test_getAttributeValue_3() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", """", """");
				assertEquals("""", element.getAttributeValue(0));
		}
		
		@Test
		void test_getAttributeValue_4() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""CDATA"", ""a"");
				assertEquals(""a"", element.getAttributeValue(0));
		}
		
		@Test
		void test_getAttributeValue_5() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""ID"", ""b"");
				assertEquals(""b"", element.getAttributeValue(0));
		}
		
		@Test
		void test_getAttributeValue_6() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""IDREF"", ""c"");
				assertEquals(""c"", element.getAttributeValue(0));
		}
		
		@Test
		void test_getAttributeValue_7() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""IDREFS"", ""d"");
				assertEquals(""d"", element.getAttributeValue(0));
		}
		
		@Test
		void test_getAttributeValue_8() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""NMTOKEN"", ""e"");
				assertEquals(""e"", element.getAttributeValue(0));
		}
		
		@Test
		void test_getAttributeValue_9() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""NMTOKENS"", ""f"");
				assertEquals(""f"", element.getAttributeValue(0));
		}
		
		@Test
		void test_getAttributeValue_10() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""ENTITY"", ""g"");
				assertEquals(""g"", element.getAttributeValue(0));
		}
		
}

// Element_6Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeNamespaceURI(int)} method.
*/
class Element_6Test {
		
		@Test
		void test_getAttributeNamespaceURI_1() {
				Element element = new Element("""", """", 0);
				assertEquals(null, element.getAttributeNamespaceURI(-1));
		}
		
		@Test
		void test_getAttributeNamespaceURI_2() {
				Element element = new Element("""", """", 0);
				assertEquals(null, element.getAttributeNamespaceURI(0));
		}
		
		@Test
		void test_getAttributeNamespaceURI_3() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", """", """");
				assertEquals"
cmpl-6wVN8WN9pF9DO5LdgnvTgXfKauClA,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_5Test.java,59.364824295043945,length,"// Element.java
/*
 * Copyright (c) 2001, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_5Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeValue(int)} method.
*/
class Element_5Test {","// Element_5Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeValue(int)} method.
*/
class Element_5Test {

	@Test
	void test_getAttributeValue_1() {
		Element element = new Element("""", """", 0);
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeValue(0);
		});
	}
	
	@Test
	void test_getAttributeValue_2() {
		Element element = new Element("""", """", 0);
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeValue(-1);
		});
	}
	
	@Test
	void test_getAttributeValue_3() {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeValue(0));
	}
	
	@Test
	void test_getAttributeValue_4() {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", """", ""a"");
		assertEquals(""a"", element.getAttributeValue(0));
	}
	
	@Test
	void test_getAttributeValue_5() {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", """", ""a"");
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeValue(1);
		});
	}
	
	@Test
	void test_getAttributeValue_6() {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", """", ""a"");
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeValue(-1);
		});
	}
	
	@Test
	void test_getAttributeValue_7() {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", """", ""a"");
		element.addAttribute("""", """", """", ""b"");
		assertEquals(""a"", element.getAttributeValue(0));
	}
	
	@Test
	void test_getAttributeValue_8() {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", """", ""a"");
		element.addAttribute("""", """", """", ""b"");
		assertEquals(""b"", element.getAttributeValue(1));
	}
	
	@Test
	void test_getAttributeValue_9() {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", """", ""a"");
		element.addAttribute("""", """", """", ""b"");
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeValue(2);
		});
	}
	
	@Test
	void test_getAttributeValue_10() {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", """", ""a"");
		element.addAttribute("""", """", """", ""b"");
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeValue(-1);
		});
	}
}

// Element_6Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeType(int)} method.
*/
class Element_6Test {
		
	@Test
	void test_getAttributeType_1() {
		Element element = new Element("""", """", 0);
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeType(0);
		});
	}
	
	@Test
	void test_getAttributeType_2() {
		Element element = new Element("""", """", 0);
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeType(-1);
		});
	}
	
	@Test
	void test_getAttributeType_3() {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeType(0));
	}
	
	@Test
	void test_getAttributeType_4() {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", ""a"", """");
		assertEquals(""a"", element.getAttributeType(0));
	}
	
	@Test
	void test_getAttributeType_5() {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", ""a"", """");
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeType(1);
		});
	}
	
	@Test
	void test_getAttributeType_6() {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", ""a"", """");
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeType(-1);
		});
	}
	
	@Test
	void test_getAttributeType_7() {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", ""a"", """");
		element.addAttribute("""", """", ""b"", """");
		assertEquals(""a"", element.getAttributeType(0));
	}
	
	@Test
	void test_getAttributeType_8() {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", ""a"", """");
		element.addAttribute("""", """", ""b"", """");
		assertEquals(""b"", element.getAttributeType(1));
	}
	
	@Test
	void test_getAttributeType_9() {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", ""a"", """");
		element.addAttribute("""", """", ""b"", """");
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeType(2);
		});
	}
	
	@Test
	void test_getAttributeType_10() {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", ""a"", """");
		element.addAttribute("""", """", ""b"", """");
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeType(-1);
		});
	}
}

// Element_7Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeNamespaceURI(int)} method.
*/
class Element_7Test {
		
	@Test
	void test_getAttributeNamespaceURI_1() {
		Element element = new Element("""", """", 0);
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeNamespaceURI(0);
		});
	}
	
	@Test"
cmpl-6wVOBIqMS0q44fDHzRkCIj8byoQxK,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_6Test.java,61.21012592315674,length,"// Element.java
/*
 * Copyright (c) 2001, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_6Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#numberOfNamespaceMappings()} method.
*/
class Element_6Test {","// Element_6Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#numberOfNamespaceMappings()} method.
*/
class Element_6Test {

	@Test
	void test_numberOfNamespaceMappings_0() {
		Element element = new Element("""", """", -1, -1);
		assertEquals(0, element.numberOfNamespaceMappings());
	}
	
	@Test
	void test_numberOfNamespaceMappings_1() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		assertEquals(1, element.numberOfNamespaceMappings());
	}
	
	@Test
	void test_numberOfNamespaceMappings_2() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		assertEquals(2, element.numberOfNamespaceMappings());
	}
	
	@Test
	void test_numberOfNamespaceMappings_3() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		assertEquals(3, element.numberOfNamespaceMappings());
	}
	
	@Test
	void test_numberOfNamespaceMappings_4() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		assertEquals(4, element.numberOfNamespaceMappings());
	}
	
	@Test
	void test_numberOfNamespaceMappings_5() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		assertEquals(5, element.numberOfNamespaceMappings());
	}
	
	@Test
	void test_numberOfNamespaceMappings_6() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		assertEquals(6, element.numberOfNamespaceMappings());
	}
	
	@Test
	void test_numberOfNamespaceMappings_7() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		assertEquals(7, element.numberOfNamespaceMappings());
	}
	
	@Test
	void test_numberOfNamespaceMappings_8() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		assertEquals(8, element.numberOfNamespaceMappings());
	}
	
	@Test
	void test_numberOfNamespaceMappings_9() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		assertEquals(9, element.numberOfNamespaceMappings());
	}
	
	@Test
	void test_numberOfNamespaceMappings_10() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		assertEquals(10, element.numberOfNamespaceMappings());
	}
	
}

// Element_7Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getNamespaceMapping(int)} method.
*/
class Element_7Test {
		
	@Test
	void test_getNamespaceMapping_0() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		String[] result = element.getNamespaceMapping(0);
		assertEquals("""", result[0]);
		assertEquals("""", result[1]);
	}
	
	@Test
	void test_getNamespaceMapping_1() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		String[] result = element.getNamespaceMapping(1);
		assertEquals("""", result[0]);
		assertEquals("""", result[1]);
	}
	
	@Test
	void test_getNamespaceMapping_2() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		String[] result = element.getNamespaceMapping(2);
		assertEquals("""", result[0]);
		assertEquals("""", result[1]);
	}
	
	@Test
	void test_getNamespaceMapping_3() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
	"
cmpl-6wVPAKQKE60r8lNg98nvKrt564KX6,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/SequentialTreeBuilder.java,3.279982566833496,stop,"// SequentialTreeBuilder.java
/*
 * Copyright (c) 2002-2003, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build a list of XTree:s from a SAX2 event stream, or by parsing an XML document.
 * <p>
 * Useful to process a large document sequentially, without need to store the whole
 * document in memory at the same time.
 * <p>
 * The SequentialTreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class SequentialTreeBuilder implements ContentHandler, ErrorHandler {

    public static final boolean DEBUG = false;

    private static final String XML_NS = ""http://www.w3.org/XML/1998/namespace"";

    private URL baseURI;

    private Locator locator = null;

    private ElementHandler handler;

    private Element rootElement;

    private TreeBuilder subTreeBuilder;

    private Vector nsPrefix = null;

    private Vector nsURI = null;

    private int inSubTree = 0;

    /**
     * Parse an XML document into a list of XTree:s, one for each element under the root.
     * Uses JAXP to find a parser.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     * @param handler     handler to invoke for each element
     *
     * @return the root element (without any children)
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, ElementHandler handler) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            SequentialTreeBuilder tb = new SequentialTreeBuilder(handler);
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            return tb.getRootElement();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        }
    }

    /**
     * Constructs a SequentialTreeBuilder, ready to receive SAX events.
     * Will not support xml:base.
     *
     * @param handler   handler to invoke for each element
     */
    public SequentialTreeBuilder(ElementHandler handler) {
        this(handler, null);
    }

    /**
     * Constructs a SequentialTreeBuilder, ready to receive SAX events.
     *
     * @param handler   handler to invoke for each element
     * @param base      base URL for the document, to support xml:base.
     */
    public SequentialTreeBuilder(ElementHandler handler, URL base) {
        this.handler = handler;
        baseURI = base;
        subTreeBuilder = new TreeBuilder();
    }

    /**
     * Obtain the root Element
     *
     * @throws IllegalStateException  if the SAX events received so far
     * doesn't constitues a well-formed XML document.
     */
    public Element getRootElement() throws IllegalStateException {
        if (rootElement == null)
            throw new IllegalStateException(""No root element"");
        return rootElement;
    }

    // ContentHandler implementation
    public void setDocumentLocator(Locator locator) {
        this.locator = locator;
        subTreeBuilder.setDocumentLocator(locator);
    }

    public void startDocument() throws SAXException {
        // nothing to do
    }

    public void endDocument() throws SAXException {
        // nothing to do
    }

    public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException {
        if (DEBUG)
            System.out.println(""startElement("" + namespaceURI + ',' + localName + ',' + qName + ')');
        if (rootElement == null) {
            rootElement = new Element(namespaceURI, localName, atts.getLength());
            if (locator != null) {
                rootElement.setSystemId(locator.getSystemId());
                rootElement.setLine(locator.getLineNumber());
                rootElement.setColumn(locator.getColumnNumber());
            }
            if (baseURI != null)
                rootElement.setBaseURI(baseURI);
            for (int i = 0; i < atts.getLength(); i++) {
                rootElement.addAttribute(atts.getURI(i), atts.getLocalName(i), atts.getType(i), atts.getValue(i));
                if (atts.getURI(i).equals(XML_NS) && atts.getLocalName(i).equals(""base"")) {
                    try {
                        URL url = new URL(rootElement.getBaseURI(), atts.getValue(i));
                        rootElement.setBaseURI(url);
                    } catch (java.net.MalformedURLException e) {
                        throw new SAXException(e);
                    }
                }
            }
            if (nsPrefix != null) {
                rootElement.setNamespaceMappings(nsPrefix, nsURI);
            }
        } else {
            inSubTree++;
            subTreeBuilder.startElement(namespaceURI, localName, qName, atts);
        }
    }

    public void endElement(String namespaceURI, String localName, String qName) throws SAXException {
        if (DEBUG)
            System.out.println(""endElement("" + namespaceURI + ',' + localName + ',' + qName + ')');
        if (inSubTree > 0) {
            subTreeBuilder.endElement(namespaceURI, localName, qName);
            if (inSubTree == 1) {
                Element el = subTreeBuilder.getTree();
                el.setParent(rootElement);
                handler.processElement(el);
                subTreeBuilder.reset();
            }
            inSubTree--;
        } else {
            // nothing to do
        }
    }

    public void startPrefixMapping(String prefix, String uri) throws SAXException {
        if (DEBUG)
            System.out.println(""startPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ',' + uri + ')');
        if (rootElement == null) {
            if (nsPrefix == null) {
                nsPrefix = new Vector();
                nsURI = new Vector();
            }
            nsPrefix.addElement(prefix);
            nsURI.addElement(uri);
        } else {
            subTreeBuilder.startPrefixMapping(prefix, uri);
        }
    }

    public void endPrefixMapping(String prefix) throws SAXException {
        if (DEBUG)
            System.out.println(""endPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ')');
        // nothing to do
    }

    public void characters(char[] ch, int start, int length) throws SAXException {
        if (inSubTree > 0)
            subTreeBuilder.characters(ch, start, length);
    }

    public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {
        if (inSubTree > 0)
            subTreeBuilder.ignorableWhitespace(ch, start, length);
    }

    public void processingInstruction(String target, String data) throws SAXException {
        if (inSubTree > 0)
            subTreeBuilder.processingInstruction(target, data);
    }

    public void skippedEntity(String name) throws SAXException {
        if (inSubTree > 0)
            subTreeBuilder.skippedEntity(name);
    }

    // ErrorHandler implementation
    public void fatalError(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void error(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void warning(SAXParseException e) {
        // do nothing
    }
}
","// SequentialTreeBuilderTest.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialTreeBuilder}.
* It contains ten unit test cases for the {@link SequentialTreeBuilder#parseXMLSequential(InputSource, boolean, ElementHandler)} method.
*/
class SequentialTreeBuilderTest {","// SequentialTreeBuilderTest.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialTreeBuilder}.
* It contains ten unit test cases for the {@link SequentialTreeBuilder#parseXMLSequential(InputSource, boolean, ElementHandler)} method.
*/
class SequentialTreeBuilderTest {

	@Test
	void testParseXMLSequential() throws Exception {
		InputSource xmlInput = new InputSource(new StringReader(""<root><a/><b/><c/></root>""));
		ElementHandler handler = new ElementHandler() {
			public void processElement(Element el) {
				System.out.println(el.getLocalName());
			}
		};
		SequentialTreeBuilder.parseXMLSequential(xmlInput, false, handler);
	}
}"
cmpl-6wVQDUubOeCshYjJKnmRNtOeYXN6J,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Text.java,43.1749701499939,stop,"// Text.java
/*
 * Copyright (c) 2001-2003, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import org.xml.sax.*;

/**
 * Character content in an XML document. This class is immutible.
 */
public class Text extends Node {

    static final long serialVersionUID = -128692223369356277L;

    final String value;

    transient char[] charArrayCache;

    /**
     * Constructs a text node from a char[] buffer.
     *
     * @param data  a char[] buffer
     * @param start  the offset to read from in the buffer
     * @param length  the number of characters to read from the buffer
     * @param forceCopy  force copying of the data, if false a reference
     *                   to the buffer may be keept.
     */
    public Text(char[] data, int start, int length, boolean forceCopy) {
        value = new String(data, start, length);
        if (start == 0 && length == data.length && !forceCopy)
            charArrayCache = data;
    }

    /**
     * Constructs a text node from a String.
     *
     * @param value  the string
     */
    public Text(String value) {
        this.value = value;
    }

    /**
     * Get the charater content as a string
     */
    public String getValue() {
        return value;
    }

    private void obtainCharArray() {
        if (charArrayCache == null)
            charArrayCache = value.toCharArray();
    }

    /**
     * Get the charater content as a char[].
     */
    public char[] asCharArray() {
        obtainCharArray();
        return charArrayCache;
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        obtainCharArray();
        sax.characters(charArrayCache, 0, charArrayCache.length);
    }

    public boolean isWhitespaceNode() {
        for (int i = 0; i < value.length(); i++) {
            if (value.charAt(i) > ' ')
                return false;
        }
        return true;
    }
}
","// TextTest.java
package nu.staldal.xtree;

import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Text}.
* It contains ten unit test cases for the {@link Text#asCharArray()} method.
*/
class TextTest {","// TextTest.java
package nu.staldal.xtree;

import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Text}.
* It contains ten unit test cases for the {@link Text#asCharArray()} method.
*/
class TextTest {

	/**
	* Test case for {@link Text#asCharArray()} method.
	* This test case tests the method with a string of length 1.
	*/
	@Test
	void testAsCharArray1() {
		Text text = new Text(""a"");
		char[] charArray = text.asCharArray();
		assertEquals(1, charArray.length);
		assertEquals('a', charArray[0]);
	}
	
	/**
	* Test case for {@link Text#asCharArray()} method.
	* This test case tests the method with a string of length 2.
	*/
	@Test
	void testAsCharArray2() {
		Text text = new Text(""ab"");
		char[] charArray = text.asCharArray();
		assertEquals(2, charArray.length);
		assertEquals('a', charArray[0]);
		assertEquals('b', charArray[1]);
	}
	
	/**
	* Test case for {@link Text#asCharArray()} method.
	* This test case tests the method with a string of length 3.
	*/
	@Test
	void testAsCharArray3() {
		Text text = new Text(""abc"");
		char[] charArray = text.asCharArray();
		assertEquals(3, charArray.length);
		assertEquals('a', charArray[0]);
		assertEquals('b', charArray[1]);
		assertEquals('c', charArray[2]);
	}
	
	/**
	* Test case for {@link Text#asCharArray()} method.
	* This test case tests the method with a string of length 4.
	*/
	@Test
	void testAsCharArray4() {
		Text text = new Text(""abcd"");
		char[] charArray = text.asCharArray();
		assertEquals(4, charArray.length);
		assertEquals('a', charArray[0]);
		assertEquals('b', charArray[1]);
		assertEquals('c', charArray[2]);
		assertEquals('d', charArray[3]);
	}
	
	/**
	* Test case for {@link Text#asCharArray()} method.
	* This test case tests the method with a string of length 5.
	*/
	@Test
	void testAsCharArray5() {
		Text text = new Text(""abcde"");
		char[] charArray = text.asCharArray();
		assertEquals(5, charArray.length);
		assertEquals('a', charArray[0]);
		assertEquals('b', charArray[1]);
		assertEquals('c', charArray[2]);
		assertEquals('d', charArray[3]);
		assertEquals('e', charArray[4]);
	}
	
	/**
	* Test case for {@link Text#asCharArray()} method.
	* This test case tests the method with a string of length 6.
	*/
	@Test
	void testAsCharArray6() {
		Text text = new Text(""abcdef"");
		char[] charArray = text.asCharArray();
		assertEquals(6, charArray.length);
		assertEquals('a', charArray[0]);
		assertEquals('b', charArray[1]);
		assertEquals('c', charArray[2]);
		assertEquals('d', charArray[3]);
		assertEquals('e', charArray[4]);
		assertEquals('f', charArray[5]);
	}
	
	/**
	* Test case for {@link Text#asCharArray()} method.
	* This test case tests the method with a string of length 7.
	*/
	@Test
	void testAsCharArray7() {
		Text text = new Text(""abcdefg"");
		char[] charArray = text.asCharArray();
		assertEquals(7, charArray.length);
		assertEquals('a', charArray[0]);
		assertEquals('b', charArray[1]);
		assertEquals('c', charArray[2]);
		assertEquals('d', charArray[3]);
		assertEquals('e', charArray[4]);
		assertEquals('f', charArray[5]);
		assertEquals('g', charArray[6]);
	}
	
	/**
	* Test case for {@link Text#asCharArray()} method.
	* This test case tests the method with a string of length 8.
	*/
	@Test
	void testAsCharArray8() {
		Text text = new Text(""abcdefgh"");
		char[] charArray = text.asCharArray();
		assertEquals(8, charArray.length);
		assertEquals('a', charArray[0]);
		assertEquals('b', charArray[1]);
		assertEquals('c', charArray[2]);
		assertEquals('d', charArray[3]);
		assertEquals('e', charArray[4]);
		assertEquals('f', charArray[5]);
		assertEquals('g', charArray[6]);
		assertEquals('h', charArray[7]);
	}
	
	/**
	* Test case for {@link Text#asCharArray()} method.
	* This test case tests the method with a string of length 9.
	*/
	@Test
	void testAsCharArray9() {
		Text text = new Text(""abcdefghi"");
		char[] charArray = text.asCharArray();
		assertEquals(9, charArray.length);
		assertEquals('a', charArray[0]);
		assertEquals('b', charArray[1]);
		assertEquals('c', charArray[2]);
		assertEquals('d', charArray[3]);
		assertEquals('e', charArray[4]);
		assertEquals('f', charArray[5]);
		assertEquals('g', charArray[6]);
		assertEquals('h', charArray[7]);
		assertEquals('i', charArray[8]);
	}
	
	/**
	* Test case for {@link Text#asCharArray()} method.
	* This test case tests the method with a string of length 10.
	*/
	@Test
	void testAsCharArray10() {
		Text text = new Text(""abcdefghij"");
		char[] charArray = text.asCharArray();
		assertEquals(10, charArray.length);
		assertEquals('a', charArray[0]);
		assertEquals('b', charArray[1]);
		assertEquals('c', charArray[2]);
		assertEquals('d', charArray[3]);
		assertEquals('e', charArray[4]);
		assertEquals('f', charArray[5]);
		assertEquals('g', charArray[6]);
		assertEquals('h', charArray[7]);
		assertEquals('i', charArray[8]);
		assertEquals('j', charArray[9]);
	}
}"
cmpl-6wVRGC6hbbMOOhHS6AVjp3nTJSgU1,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/TreeBuilder_0Test.java,46.332881689071655,length,"// TreeBuilder.java
/*
 * Copyright (c) 2001-2003, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build an XTree from a SAX2 event stream, or by parsing an XML document.
 *
 * The TreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class TreeBuilder implements ContentHandler, ErrorHandler {

    public static final boolean DEBUG = false;

    private Element rootElement = null;

    private Stack elementStack;

    private Vector nsPrefix = null;

    private Vector nsURI = null;

    private StringBuffer textBuffer = null;

    private String textSystemId = null;

    private int textLine = -1;

    private int textColumn = -1;

    private Locator locator = null;

    private URL baseURI;

    /**
     * Create an SAX InputSource from a File object.
     *
     * @param file  the file
     *
     * @return an InputSource
     * @throws FileNotFoundException  if the file doesn't exist
     * @throws FileNotFoundException  if some I/O error occurs
     */
    public static InputSource fileToInputSource(File file) throws FileNotFoundException, IOException {
        // we should use File.toURL() here, but it's Java2
        String absPath = file.getCanonicalPath().replace(File.separatorChar, '/');
        String systemId = ""file:"" + ((absPath.charAt(0) == '/') ? ""//"" : ""///"") + absPath;
        if (!file.isFile())
            throw new FileNotFoundException(systemId);
        return new InputSource(systemId);
    }

    /**
     * Parse an XML document into an XTree.
     * Uses JAXP to find a parser.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     *
     * @return an XTree representation of the XML data
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXML(InputSource xmlInput, boolean validateDTD) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            TreeBuilder tb = new TreeBuilder();
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            return tb.getTree();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        }
    }

    /**
     * Constructs a TreeBuilder, ready to receive SAX events.
     * Will not support xml:base.
     */
    public TreeBuilder() {
        this(null);
    }

    /**
     * Constructs a TreeBuilder, ready to receive SAX events.
     *
     * @param base  base URL for the document, to support xml:base.
     */
    public TreeBuilder(URL base) {
        elementStack = new Stack();
        baseURI = base;
    }

    /**
     * Obtain the XTree built from SAX events.
     *
     * @throws IllegalStateException  if the SAX events received so far
     * doesn't constitues a well-formed XML document.
     */
    public Element getTree() throws IllegalStateException {
        if (!elementStack.isEmpty())
            throw new IllegalStateException(""All elements are not yet ended"");
        if (rootElement == null)
            throw new IllegalStateException(""No root element"");
        return rootElement;
    }

    void reset() {
        rootElement = null;
        elementStack = new Stack();
        nsPrefix = null;
        nsURI = null;
        textBuffer = null;
        textSystemId = null;
        textLine = -1;
        textColumn = -1;
    }

    private void addCharacters() {
        if ((textBuffer != null) && (textBuffer.length() > 0)) {
            Element parent = (Element) elementStack.peek();
            Node node = new Text(textBuffer.toString());
            node.setSystemId(textSystemId);
            node.setLine(textLine);
            node.setColumn(textColumn);
            parent.addChild(node);
        }
        textBuffer = null;
    }

    // ContentHandler implementation
    public void setDocumentLocator(Locator locator) {
        this.locator = locator;
    }

    public void startDocument() throws SAXException {
        // nothing to do
    }

    public void endDocument() throws SAXException {
        // nothing to do
    }

    public void startElement(String namespaceURI, String localName, String qname, Attributes atts) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""startElement("" + namespaceURI + ',' + localName + ',' + qname + ')');
        Element el = new Element(namespaceURI, localName, atts.getLength());
        if (locator != null) {
            el.setSystemId(locator.getSystemId());
            el.setLine(locator.getLineNumber());
            el.setColumn(locator.getColumnNumber());
        }
        if (rootElement == null) {
            rootElement = el;
            if (baseURI != null)
                rootElement.setBaseURI(baseURI);
        } else {
            Element parent = (Element) elementStack.peek();
            parent.addChild(el);
        }
        for (int i = 0; i < atts.getLength(); i++) {
            el.addAttribute(atts.getURI(i), atts.getLocalName(i), atts.getType(i), atts.getValue(i));
            if (atts.getURI(i).equals(Node.XML_NS) && atts.getLocalName(i).equals(""base"")) {
                try {
                    URL url = new URL(el.getBaseURI(), atts.getValue(i));
                    el.setBaseURI(url);
                } catch (java.net.MalformedURLException e) {
                    throw new SAXException(e);
                }
            }
        }
        if (nsPrefix != null) {
            el.setNamespaceMappings(nsPrefix, nsURI);
        }
        elementStack.push(el);
        nsPrefix = null;
        nsURI = null;
    }

    public void endElement(String namespaceURI, String localName, String qname) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""endElement("" + namespaceURI + ',' + localName + ',' + qname + ')');
        elementStack.pop();
    }

    public void startPrefixMapping(String prefix, String uri) throws SAXException {
        if (DEBUG)
            System.out.println(""startPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ',' + uri + ')');
        if (nsPrefix == null) {
            nsPrefix = new Vector();
            nsURI = new Vector();
        }
        nsPrefix.addElement(prefix);
        nsURI.addElement(uri);
    }

    public void endPrefixMapping(String prefix) throws SAXException {
        if (DEBUG)
            System.out.println(""endPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ')');
        // nothing to do
    }

    public void characters(char[] ch, int start, int length) throws SAXException {
        if (textBuffer == null) {
            textBuffer = new StringBuffer(length);
        }
        textBuffer.append(ch, start, length);
        if (locator != null) {
            textSystemId = locator.getSystemId();
            textLine = locator.getLineNumber();
            textColumn = locator.getColumnNumber();
        }
    }

    public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {
        // nothing to do
    }

    public void processingInstruction(String target, String data) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""processingInstruction("" + target + ',' + data + ')');
        Element parent = (Element) elementStack.peek();
        Node node = new ProcessingInstruction(target, data);
        if (locator != null) {
            node.setSystemId(locator.getSystemId());
            node.setLine(locator.getLineNumber());
            node.setColumn(locator.getColumnNumber());
        }
        parent.addChild(node);
    }

    public void skippedEntity(String name) throws SAXException {
        // nothing to do
    }

    // ErrorHandler implementation
    public void fatalError(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void error(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void warning(SAXParseException e) {
        // do nothing
    }
}
","// TreeBuilder_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains ten unit test cases for the {@link TreeBuilder#fileToInputSource(File)} method.
*/
class TreeBuilder_0Test {","// TreeBuilder_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains ten unit test cases for the {@link TreeBuilder#fileToInputSource(File)} method.
*/
class TreeBuilder_0Test {

		@Test
		void test_0() throws Exception {
				File file = new File(""src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"");
				InputSource inputSource = TreeBuilder.fileToInputSource(file);
				assertEquals(""file:/src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"", inputSource.getSystemId());
		}
		
		@Test
		void test_1() throws Exception {
				File file = new File(""src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"");
				InputSource inputSource = TreeBuilder.fileToInputSource(file);
				assertEquals(""file:/src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"", inputSource.getSystemId());
		}
		
		@Test
		void test_2() throws Exception {
				File file = new File(""src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"");
				InputSource inputSource = TreeBuilder.fileToInputSource(file);
				assertEquals(""file:/src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"", inputSource.getSystemId());
		}
		
		@Test
		void test_3() throws Exception {
				File file = new File(""src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"");
				InputSource inputSource = TreeBuilder.fileToInputSource(file);
				assertEquals(""file:/src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"", inputSource.getSystemId());
		}
		
		@Test
		void test_4() throws Exception {
				File file = new File(""src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"");
				InputSource inputSource = TreeBuilder.fileToInputSource(file);
				assertEquals(""file:/src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"", inputSource.getSystemId());
		}
		
		@Test
		void test_5() throws Exception {
				File file = new File(""src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"");
				InputSource inputSource = TreeBuilder.fileToInputSource(file);
				assertEquals(""file:/src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"", inputSource.getSystemId());
		}
		
		@Test
		void test_6() throws Exception {
				File file = new File(""src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"");
				InputSource inputSource = TreeBuilder.fileToInputSource(file);
				assertEquals(""file:/src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"", inputSource.getSystemId());
		}
		
		@Test
		void test_7() throws Exception {
				File file = new File(""src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"");
				InputSource inputSource = TreeBuilder.fileToInputSource(file);
				assertEquals(""file:/src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"", inputSource.getSystemId());
		}
		
		@Test
		void test_8() throws Exception {
				File file = new File(""src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"");
				InputSource inputSource = TreeBuilder.fileToInputSource(file);
				assertEquals(""file:/src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"", inputSource.getSystemId());
		}
		
		@Test
		void test_9() throws Exception {
				File file = new File(""src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"");
				InputSource inputSource = TreeBuilder.fileToInputSource(file);
				assertEquals(""file:/src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"", inputSource.getSystemId());
		}
}

// TreeBuilder_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains ten unit test cases for the {@link TreeBuilder#parseXML(InputSource, boolean)} method.
*/
class TreeBuilder_1Test {
		
		@Test
		void test_0() throws Exception {
				InputSource inputSource = new InputSource(""src/test/resources/nu/staldal/xtree/TreeBuilder_1Test.xml"");
				Element element = TreeBuilder.parseXML(inputSource, false);
				assertEquals(""http://www.staldal.nu/"", element.getNamespaceURI());
				assertEquals(""root"", element.getLocalName());
				assertEquals(""http://www.staldal.nu/"", element.getAttributeNamespaceURI(0));
				assertEquals(""attr"", element.getAttributeLocalName(0));
				assertEquals(""http://www.staldal.nu/"", element.getAttributeNamespaceURI(1));
				assertEquals(""attr2"", element.getAttributeLocalName(1));
				assertEquals(""http://www.staldal.nu/"", element.getAttributeNamespaceURI(2));
				assertEquals(""attr3"", element.getAttributeLocalName(2));
				assertEquals(""http://www.staldal.nu/"", element.getAttributeNamespaceURI(3));
				assertEquals(""attr4"", element.getAttributeLocalName(3));
				assertEquals(""http://www.staldal.nu/"", element.getAttributeNamespaceURI(4));
				assertEquals(""attr5"", element.getAttributeLocalName(4));
				assertEquals(""http://www.staldal.nu/"", element.getAttributeNamespaceURI(5));
				assertEquals(""attr6"", element.getAttributeLocalName(5));
				assertEquals(""http://www.staldal.nu/"", element.getAttributeNamespaceURI(6));
				assertEquals(""attr7"", element.getAttributeLocalName(6));
				assertEquals(""http://www.staldal.nu/"", element.getAttributeNamespaceURI(7));
				assertEquals(""attr8"", element.getAttributeLocalName(7));
				assertEquals(""http://www.staldal.nu/"", element.getAttributeNamespaceURI(8));
				assertEquals(""attr9"", element.getAttributeLocalName(8));
				assertEquals(""http://www.staldal.nu/"", element.getAttributeNamespaceURI(9));
				assertEquals(""attr10"", element.getAttributeLocalName(9));
				assertEquals(""http://www.staldal.nu/"", element.getAttributeNamespaceURI(10));
				assertEquals(""attr11"","
cmpl-6wVSJv4R3HzwvaUxHHrYABjJ2hpBP,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/TreeBuilder_1Test.java,58.15825700759888,length,"// TreeBuilder.java
/*
 * Copyright (c) 2001-2003, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build an XTree from a SAX2 event stream, or by parsing an XML document.
 *
 * The TreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class TreeBuilder implements ContentHandler, ErrorHandler {

    public static final boolean DEBUG = false;

    private Element rootElement = null;

    private Stack elementStack;

    private Vector nsPrefix = null;

    private Vector nsURI = null;

    private StringBuffer textBuffer = null;

    private String textSystemId = null;

    private int textLine = -1;

    private int textColumn = -1;

    private Locator locator = null;

    private URL baseURI;

    /**
     * Create an SAX InputSource from a File object.
     *
     * @param file  the file
     *
     * @return an InputSource
     * @throws FileNotFoundException  if the file doesn't exist
     * @throws FileNotFoundException  if some I/O error occurs
     */
    public static InputSource fileToInputSource(File file) throws FileNotFoundException, IOException {
        // we should use File.toURL() here, but it's Java2
        String absPath = file.getCanonicalPath().replace(File.separatorChar, '/');
        String systemId = ""file:"" + ((absPath.charAt(0) == '/') ? ""//"" : ""///"") + absPath;
        if (!file.isFile())
            throw new FileNotFoundException(systemId);
        return new InputSource(systemId);
    }

    /**
     * Parse an XML document into an XTree.
     * Uses JAXP to find a parser.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     *
     * @return an XTree representation of the XML data
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXML(InputSource xmlInput, boolean validateDTD) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            TreeBuilder tb = new TreeBuilder();
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            return tb.getTree();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        }
    }

    /**
     * Constructs a TreeBuilder, ready to receive SAX events.
     * Will not support xml:base.
     */
    public TreeBuilder() {
        this(null);
    }

    /**
     * Constructs a TreeBuilder, ready to receive SAX events.
     *
     * @param base  base URL for the document, to support xml:base.
     */
    public TreeBuilder(URL base) {
        elementStack = new Stack();
        baseURI = base;
    }

    /**
     * Obtain the XTree built from SAX events.
     *
     * @throws IllegalStateException  if the SAX events received so far
     * doesn't constitues a well-formed XML document.
     */
    public Element getTree() throws IllegalStateException {
        if (!elementStack.isEmpty())
            throw new IllegalStateException(""All elements are not yet ended"");
        if (rootElement == null)
            throw new IllegalStateException(""No root element"");
        return rootElement;
    }

    void reset() {
        rootElement = null;
        elementStack = new Stack();
        nsPrefix = null;
        nsURI = null;
        textBuffer = null;
        textSystemId = null;
        textLine = -1;
        textColumn = -1;
    }

    private void addCharacters() {
        if ((textBuffer != null) && (textBuffer.length() > 0)) {
            Element parent = (Element) elementStack.peek();
            Node node = new Text(textBuffer.toString());
            node.setSystemId(textSystemId);
            node.setLine(textLine);
            node.setColumn(textColumn);
            parent.addChild(node);
        }
        textBuffer = null;
    }

    // ContentHandler implementation
    public void setDocumentLocator(Locator locator) {
        this.locator = locator;
    }

    public void startDocument() throws SAXException {
        // nothing to do
    }

    public void endDocument() throws SAXException {
        // nothing to do
    }

    public void startElement(String namespaceURI, String localName, String qname, Attributes atts) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""startElement("" + namespaceURI + ',' + localName + ',' + qname + ')');
        Element el = new Element(namespaceURI, localName, atts.getLength());
        if (locator != null) {
            el.setSystemId(locator.getSystemId());
            el.setLine(locator.getLineNumber());
            el.setColumn(locator.getColumnNumber());
        }
        if (rootElement == null) {
            rootElement = el;
            if (baseURI != null)
                rootElement.setBaseURI(baseURI);
        } else {
            Element parent = (Element) elementStack.peek();
            parent.addChild(el);
        }
        for (int i = 0; i < atts.getLength(); i++) {
            el.addAttribute(atts.getURI(i), atts.getLocalName(i), atts.getType(i), atts.getValue(i));
            if (atts.getURI(i).equals(Node.XML_NS) && atts.getLocalName(i).equals(""base"")) {
                try {
                    URL url = new URL(el.getBaseURI(), atts.getValue(i));
                    el.setBaseURI(url);
                } catch (java.net.MalformedURLException e) {
                    throw new SAXException(e);
                }
            }
        }
        if (nsPrefix != null) {
            el.setNamespaceMappings(nsPrefix, nsURI);
        }
        elementStack.push(el);
        nsPrefix = null;
        nsURI = null;
    }

    public void endElement(String namespaceURI, String localName, String qname) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""endElement("" + namespaceURI + ',' + localName + ',' + qname + ')');
        elementStack.pop();
    }

    public void startPrefixMapping(String prefix, String uri) throws SAXException {
        if (DEBUG)
            System.out.println(""startPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ',' + uri + ')');
        if (nsPrefix == null) {
            nsPrefix = new Vector();
            nsURI = new Vector();
        }
        nsPrefix.addElement(prefix);
        nsURI.addElement(uri);
    }

    public void endPrefixMapping(String prefix) throws SAXException {
        if (DEBUG)
            System.out.println(""endPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ')');
        // nothing to do
    }

    public void characters(char[] ch, int start, int length) throws SAXException {
        if (textBuffer == null) {
            textBuffer = new StringBuffer(length);
        }
        textBuffer.append(ch, start, length);
        if (locator != null) {
            textSystemId = locator.getSystemId();
            textLine = locator.getLineNumber();
            textColumn = locator.getColumnNumber();
        }
    }

    public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {
        // nothing to do
    }

    public void processingInstruction(String target, String data) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""processingInstruction("" + target + ',' + data + ')');
        Element parent = (Element) elementStack.peek();
        Node node = new ProcessingInstruction(target, data);
        if (locator != null) {
            node.setSystemId(locator.getSystemId());
            node.setLine(locator.getLineNumber());
            node.setColumn(locator.getColumnNumber());
        }
        parent.addChild(node);
    }

    public void skippedEntity(String name) throws SAXException {
        // nothing to do
    }

    // ErrorHandler implementation
    public void fatalError(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void error(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void warning(SAXParseException e) {
        // do nothing
    }
}
","// TreeBuilder_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains ten unit test cases for the {@link TreeBuilder#parseXML(InputSource, boolean)} method.
*/
class TreeBuilder_1Test {","// TreeBuilder_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains ten unit test cases for the {@link TreeBuilder#parseXML(InputSource, boolean)} method.
*/
class TreeBuilder_1Test {

		@Test
		public void test1() throws Exception {
				String xml = ""<?xml version=\""1.0\""?><root/>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				Element root = TreeBuilder.parseXML(xmlInput, false);
				assertEquals(""root"", root.getLocalName());
				assertEquals(0, root.getAttributeCount());
				assertEquals(0, root.getChildCount());
		}
		
		@Test
		public void test2() throws Exception {
				String xml = ""<?xml version=\""1.0\""?><root attr=\""value\""/>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				Element root = TreeBuilder.parseXML(xmlInput, false);
				assertEquals(""root"", root.getLocalName());
				assertEquals(1, root.getAttributeCount());
				assertEquals(""attr"", root.getAttributeName(0));
				assertEquals(""value"", root.getAttributeValue(0));
				assertEquals(0, root.getChildCount());
		}
		
		@Test
		public void test3() throws Exception {
				String xml = ""<?xml version=\""1.0\""?><root><child/></root>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				Element root = TreeBuilder.parseXML(xmlInput, false);
				assertEquals(""root"", root.getLocalName());
				assertEquals(0, root.getAttributeCount());
				assertEquals(1, root.getChildCount());
				Node child = root.getChild(0);
				assertTrue(child instanceof Element);
				assertEquals(""child"", child.getLocalName());
				assertEquals(0, ((Element)child).getAttributeCount());
				assertEquals(0, ((Element)child).getChildCount());
		}
		
		@Test
		public void test4() throws Exception {
				String xml = ""<?xml version=\""1.0\""?><root><child>text</child></root>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				Element root = TreeBuilder.parseXML(xmlInput, false);
				assertEquals(""root"", root.getLocalName());
				assertEquals(0, root.getAttributeCount());
				assertEquals(1, root.getChildCount());
				Node child = root.getChild(0);
				assertTrue(child instanceof Element);
				assertEquals(""child"", child.getLocalName());
				assertEquals(0, ((Element)child).getAttributeCount());
				assertEquals(1, ((Element)child).getChildCount());
				Node text = ((Element)child).getChild(0);
				assertTrue(text instanceof Text);
				assertEquals(""text"", text.getText());
		}
		
		@Test
		public void test5() throws Exception {
				String xml = ""<?xml version=\""1.0\""?><root><child>text1<child2/>text2</child></root>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				Element root = TreeBuilder.parseXML(xmlInput, false);
				assertEquals(""root"", root.getLocalName());
				assertEquals(0, root.getAttributeCount());
				assertEquals(1, root.getChildCount());
				Node child = root.getChild(0);
				assertTrue(child instanceof Element);
				assertEquals(""child"", child.getLocalName());
				assertEquals(0, ((Element)child).getAttributeCount());
				assertEquals(3, ((Element)child).getChildCount());
				Node text1 = ((Element)child).getChild(0);
				assertTrue(text1 instanceof Text);
				assertEquals(""text1"", text1.getText());
				Node child2 = ((Element)child).getChild(1);
				assertTrue(child2 instanceof Element);
				assertEquals(""child2"", child2.getLocalName());
				assertEquals(0, ((Element)child2).getAttributeCount());
				assertEquals(0, ((Element)child2).getChildCount());
				Node text2 = ((Element)child).getChild(2);
				assertTrue(text2 instanceof Text);
				assertEquals(""text2"", text2.getText());
		}
		
		@Test
		public void test6() throws Exception {
				String xml = ""<?xml version=\""1.0\""?><root><child>text1<child2/>text2</child>text3</root>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				Element root = TreeBuilder.parseXML(xmlInput, false);
				assertEquals(""root"", root.getLocalName());
				assertEquals(0, root.getAttributeCount());
				assertEquals(2, root.getChildCount());
				Node child = root.getChild(0);
				assertTrue(child instanceof Element);
				assertEquals(""child"", child.getLocalName());
				assertEquals(0, ((Element)child).getAttributeCount());
				assertEquals(3, ((Element)child).getChildCount());
				Node text1 = ((Element)child).getChild(0);
				assertTrue(text1 instanceof Text);
				assertEquals(""text1"", text1.getText());
				Node child2 = ((Element)child).getChild(1);
				assertTrue(child2 instanceof Element);
				assertEquals(""child2"", child2.getLocalName());
				assertEquals(0, ((Element)child2).getAttributeCount());
				assertEquals(0, ((Element)child2).getChildCount());
				Node text2 = ((Element)child).getChild(2);
				assertTrue(text2 instanceof Text);
				assertEquals(""text2"", text2.getText());
				Node text3 = root.getChild(1);
				assertTrue(text3 instanceof Text);
				assertEquals(""text3"", text3.getText());
		}
		
		@Test
		public void test7() throws Exception {
				String xml = ""<?xml version=\""1.0\""?><root><child>text1<child2/>text2</child>text3<child3/></root>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				Element root = TreeBuilder.parseXML(xmlInput, false);
				assertEquals(""root"", root.getLocalName());
				assertEquals(0, root.getAttributeCount());
				assertEquals(3, root.getChildCount());
				Node child = root.getChild(0);
				assertTrue(child instanceof Element);
				assertEquals(""child"", child.getLocalName());
				assertEquals(0, ((Element)child).getAttributeCount());
				assertEquals(3, ((Element)child).getChildCount());
				Node text1 = ((Element)child).getChild(0);
				assertTrue(text1 instanceof Text"
cmpl-6wVTMlWzNPyINgJwLCklERQpNEeOt,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/XTreeUtil_0Test.java,53.86286997795105,length,"// XTreeUtil.java
/*
 * Copyright (c) 2002-2004, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;

/**
 * Some utility methods for XTree. All methods in this class are static.
 */
public final class XTreeUtil {

    /**
     * Private default constructor to prevent instantiation.
     */
    private XTreeUtil() {
    }

    /**
     * Parse an XML document into an XTree.
     * Uses JAXP to find a parser and JARV to find a validator.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     * @param schemaType  the type of schema to use, or <code>null</code>
     *                    for no schema validation
     * @param schema      the schema to use, or <code>null</code>
     *                    for no schema validation
     *
     * @return an XTree representation of the XML data
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXML(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            TreeBuilder tb = new TreeBuilder();
            if (schema != null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getTree();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }

    /**
     * Parse an XML document into a list of XTree:s, one for each element under the root.
     * Uses JAXP to find a parser and JARV to find a validator.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     * @param schemaType  the type of schema to use, or <code>null</code>
     *                    for no schema validation
     * @param schema      the schema to use, or <code>null</code>
     *                    for no schema validation
     * @param handler     handler to invoke for each element
     *
     * @return the root element (without any children)
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema, ElementHandler handler) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            SequentialTreeBuilder tb = new SequentialTreeBuilder(handler);
            if (schema != null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getRootElement();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }

    /**
     * Serialize an XTree into an OutputStream.
     *
     * @param tree      the XTree to serialize
     * @param os        the OutputStream to write to
     *
     * @throws IOException if any error occurs
     */
    public static void serialize(Node tree, OutputStream os) throws IOException {
        Properties prop = new Properties();
        prop.setProperty(OutputKeys.METHOD, ""xml"");
        prop.setProperty(OutputKeys.ENCODING, ""utf-8"");
        prop.setProperty(OutputKeys.INDENT, ""no"");
        serialize(tree, os, prop);
    }

    /**
     * Serialize an XTree into an OutputStream.
     *
     * @param tree      the XTree to serialize
     * @param os        the OutputStream to write to
     * @param prop  	output properties
     *
     * @throws IOException if any error occurs
     */
    public static void serialize(Node tree, OutputStream os, Properties prop) throws IOException {
        try {
            TransformerFactory tf = TransformerFactory.newInstance();
            if (!(tf.getFeature(SAXTransformerFactory.FEATURE) && tf.getFeature(StreamResult.FEATURE))) {
                throw new Error(""The transformer factory "" + tf.getClass().getName() + "" doesn't support SAX"");
            }
            SAXTransformerFactory tfactory = (SAXTransformerFactory) tf;
            TransformerHandler th = tfactory.newTransformerHandler();
            th.setResult(new StreamResult(os));
            Transformer trans = th.getTransformer();
            trans.setOutputProperties(prop);
            ContentHandler ch = new ContentHandlerFixer(th, true);
            try {
                ch.startDocument();
                tree.toSAX(ch);
                ch.endDocument();
            } catch (SAXException e) {
                throw new IOException(e.toString());
            }
        } catch (TransformerConfigurationException e) {
            throw new Error(e.toString());
        }
    }
}
","// XTreeUtil_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains ten unit test cases for the {@link XTreeUtil#parseXML(InputSource, boolean, String, InputSource)} method.
*/
class XTreeUtil_0Test {","// XTreeUtil_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains ten unit test cases for the {@link XTreeUtil#parseXML(InputSource, boolean, String, InputSource)} method.
*/
class XTreeUtil_0Test {

		@Test
		void test_0() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals(""a"", result.getLocalName());
		}
		
		@Test
		void test_1() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals("""", result.getNamespaceURI());
		}
		
		@Test
		void test_2() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals(0, result.getAttributeCount());
		}
		
		@Test
		void test_3() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals(0, result.getChildCount());
		}
		
		@Test
		void test_4() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals(0, result.getLineNumber());
		}
		
		@Test
		void test_5() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals(0, result.getColumnNumber());
		}
		
		@Test
		void test_6() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals(0, result.getSystemId().length());
		}
		
		@Test
		void test_7() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals(0, result.getPublicId().length());
		}
		
		@Test
		void test_8() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals(0, result.getBaseURI().length());
		}
		
		@Test
		void test_9() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals(0, result.getPrefix().length());
		}
}

// XTreeUtil_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains ten unit test cases for the {@link XTreeUtil#parseXML(InputSource, boolean, String, InputSource)} method.
*/
class XTreeUtil_1Test {
		
		@Test
		void test_0() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals(""a"", result.getLocalName());
		}
		
		@Test
		void test_1() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals("""", result.getNamespaceURI());
		}
		
		@Test
		void test_2() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals(0, result.getAttributeCount());
		}
		
		@Test
		void test_3() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
			"
cmpl-6wVUPngRF2lahXG205cQBU6jFEu44,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/XTreeUtil_1Test.java,58.02980136871338,length,"// XTreeUtil.java
/*
 * Copyright (c) 2002-2004, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;

/**
 * Some utility methods for XTree. All methods in this class are static.
 */
public final class XTreeUtil {

    /**
     * Private default constructor to prevent instantiation.
     */
    private XTreeUtil() {
    }

    /**
     * Parse an XML document into an XTree.
     * Uses JAXP to find a parser and JARV to find a validator.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     * @param schemaType  the type of schema to use, or <code>null</code>
     *                    for no schema validation
     * @param schema      the schema to use, or <code>null</code>
     *                    for no schema validation
     *
     * @return an XTree representation of the XML data
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXML(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            TreeBuilder tb = new TreeBuilder();
            if (schema != null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getTree();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }

    /**
     * Parse an XML document into a list of XTree:s, one for each element under the root.
     * Uses JAXP to find a parser and JARV to find a validator.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     * @param schemaType  the type of schema to use, or <code>null</code>
     *                    for no schema validation
     * @param schema      the schema to use, or <code>null</code>
     *                    for no schema validation
     * @param handler     handler to invoke for each element
     *
     * @return the root element (without any children)
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema, ElementHandler handler) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            SequentialTreeBuilder tb = new SequentialTreeBuilder(handler);
            if (schema != null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getRootElement();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }

    /**
     * Serialize an XTree into an OutputStream.
     *
     * @param tree      the XTree to serialize
     * @param os        the OutputStream to write to
     *
     * @throws IOException if any error occurs
     */
    public static void serialize(Node tree, OutputStream os) throws IOException {
        Properties prop = new Properties();
        prop.setProperty(OutputKeys.METHOD, ""xml"");
        prop.setProperty(OutputKeys.ENCODING, ""utf-8"");
        prop.setProperty(OutputKeys.INDENT, ""no"");
        serialize(tree, os, prop);
    }

    /**
     * Serialize an XTree into an OutputStream.
     *
     * @param tree      the XTree to serialize
     * @param os        the OutputStream to write to
     * @param prop  	output properties
     *
     * @throws IOException if any error occurs
     */
    public static void serialize(Node tree, OutputStream os, Properties prop) throws IOException {
        try {
            TransformerFactory tf = TransformerFactory.newInstance();
            if (!(tf.getFeature(SAXTransformerFactory.FEATURE) && tf.getFeature(StreamResult.FEATURE))) {
                throw new Error(""The transformer factory "" + tf.getClass().getName() + "" doesn't support SAX"");
            }
            SAXTransformerFactory tfactory = (SAXTransformerFactory) tf;
            TransformerHandler th = tfactory.newTransformerHandler();
            th.setResult(new StreamResult(os));
            Transformer trans = th.getTransformer();
            trans.setOutputProperties(prop);
            ContentHandler ch = new ContentHandlerFixer(th, true);
            try {
                ch.startDocument();
                tree.toSAX(ch);
                ch.endDocument();
            } catch (SAXException e) {
                throw new IOException(e.toString());
            }
        } catch (TransformerConfigurationException e) {
            throw new Error(e.toString());
        }
    }
}
","// XTreeUtil_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains ten unit test cases for the {@link XTreeUtil#parseXMLSequential(InputSource, boolean, String, InputSource, ElementHandler)} method.
*/
class XTreeUtil_1Test {","// XTreeUtil_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains ten unit test cases for the {@link XTreeUtil#parseXMLSequential(InputSource, boolean, String, InputSource, ElementHandler)} method.
*/
class XTreeUtil_1Test {

		@Test
		void test_1() throws Exception {
				String xml = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"" +
										 ""<!DOCTYPE root [\n"" +
										 ""<!ELEMENT root (child1, child2)>\n"" +
										 ""<!ELEMENT child1 (#PCDATA)>\n"" +
										 ""<!ELEMENT child2 (#PCDATA)>\n"" +
										 ""]>\n"" +
										 ""<root>\n"" +
										 ""  <child1>text1</child1>\n"" +
										 ""  <child2>text2</child2>\n"" +
										 ""</root>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				ElementHandler handler = new ElementHandler() {
						public void handleElement(Element element) {
								assertEquals(""child1"", element.getLocalName());
								assertEquals(""text1"", element.getText());
						}
				};
				Element root = XTreeUtil.parseXMLSequential(xmlInput, true, null, null, handler);
				assertEquals(""root"", root.getLocalName());
				assertEquals(0, root.getChildCount());
		}
		
		@Test
		void test_2() throws Exception {
				String xml = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"" +
										 ""<!DOCTYPE root [\n"" +
										 ""<!ELEMENT root (child1, child2)>\n"" +
										 ""<!ELEMENT child1 (#PCDATA)>\n"" +
										 ""<!ELEMENT child2 (#PCDATA)>\n"" +
										 ""]>\n"" +
										 ""<root>\n"" +
										 ""  <child1>text1</child1>\n"" +
										 ""  <child2>text2</child2>\n"" +
										 ""</root>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				ElementHandler handler = new ElementHandler() {
						public void handleElement(Element element) {
								assertEquals(""child2"", element.getLocalName());
								assertEquals(""text2"", element.getText());
						}
				};
				Element root = XTreeUtil.parseXMLSequential(xmlInput, true, null, null, handler);
				assertEquals(""root"", root.getLocalName());
				assertEquals(0, root.getChildCount());
		}
		
		@Test
		void test_3() throws Exception {
				String xml = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"" +
										 ""<!DOCTYPE root [\n"" +
										 ""<!ELEMENT root (child1, child2)>\n"" +
										 ""<!ELEMENT child1 (#PCDATA)>\n"" +
										 ""<!ELEMENT child2 (#PCDATA)>\n"" +
										 ""]>\n"" +
										 ""<root>\n"" +
										 ""  <child1>text1</child1>\n"" +
										 ""  <child2>text2</child2>\n"" +
										 ""</root>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				ElementHandler handler = new ElementHandler() {
						public void handleElement(Element element) {
								assertEquals(""child1"", element.getLocalName());
								assertEquals(""text1"", element.getText());
						}
				};
				Element root = XTreeUtil.parseXMLSequential(xmlInput, true, null, null, handler);
				assertEquals(""root"", root.getLocalName());
				assertEquals(0, root.getChildCount());
		}
		
		@Test
		void test_4() throws Exception {
				String xml = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"" +
										 ""<!DOCTYPE root [\n"" +
										 ""<!ELEMENT root (child1, child2)>\n"" +
										 ""<!ELEMENT child1 (#PCDATA)>\n"" +
										 ""<!ELEMENT child2 (#PCDATA)>\n"" +
										 ""]>\n"" +
										 ""<root>\n"" +
										 ""  <child1>text1</child1>\n"" +
										 ""  <child2>text2</child2>\n"" +
										 ""</root>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				ElementHandler handler = new ElementHandler() {
						public void handleElement(Element element) {
								assertEquals(""child2"", element.getLocalName());
								assertEquals(""text2"", element.getText());
						}
				};
				Element root = XTreeUtil.parseXMLSequential(xmlInput, true, null, null, handler);
				assertEquals(""root"", root.getLocalName());
				assertEquals(0, root.getChildCount());
		}
		
		@Test
		void test_5() throws Exception {
				String xml = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"" +
										 ""<!DOCTYPE root [\n"" +
										 ""<!ELEMENT root (child1, child2)>\n"" +
										 ""<!ELEMENT child1 (#PCDATA)>\n"" +
										 ""<!ELEMENT child2 (#PCDATA)>\n"" +
										 ""]>\n"" +
										 ""<root>\n"" +
										 ""  <child1>text1</child1>\n"" +
										 ""  <child2>text2</child2>\n"" +
										 ""</root>"";
		"
