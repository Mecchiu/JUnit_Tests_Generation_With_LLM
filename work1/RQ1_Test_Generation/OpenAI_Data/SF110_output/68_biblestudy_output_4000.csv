ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6wgwWNdjp5xDg1xmnUGqPbH6gdTqM,/EvoSuiteBenchmark/original/68_biblestudy/src/main/java/bible/servlet/HTMLOutputStream.java,108.58687448501587,length,"// HTMLOutputStream.java
/*
 * BufferedOutputStream.java: Writes to a
 * buffer and handles ContentLength's and Types, as well as cleanup.
 * Copyright (C) 1998. All rights reserved.
 * St. Paul Software, St. Paul, MN, USA
 */
package bible.servlet;

import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
import java.net.*;

/**
 * A container for output streams with its own buffers
 *
 * @author  Luke Samaha
 */
public class HTMLOutputStream {

    //  Use-specific Constructors
    public HTMLOutputStream(HttpServletResponse response) throws IOException {
        this.response = response;
        baos = new ByteArrayOutputStream(4096);
        OutputStream out = baos;
        //  Initialization routines specific to content type
        pw = new PrintWriter(out, true);
    }

    //  Public client methods
    public void print(String str) {
        pw.print(str);
    }

    public void print(int n) {
        pw.print(n);
    }

    public void println(String str) {
        pw.println(str);
    }

    public void println(int n) {
        pw.println(n);
    }

    public void flush() throws IOException {
        response.setContentType(""text/html"");
        response.setContentLength(baos.size());
        OutputStream os = response.getOutputStream();
        baos.writeTo(os);
        os.flush();
        reset();
    }

    public int getSize() {
        return baos.size();
    }

    public PrintWriter getPW() {
        return pw;
    }

    /**
     * @author James Stauffer
     * @return String the contents of the buffer.
     */
    public String reset() {
        String contents = baos.toString();
        baos.reset();
        return contents;
    }

    public String toString() {
        return getClass().getName() + "": [size="" + getSize() + "", response="" + response + ((baos != null) ? "", baos"" : """") + ((pw != null) ? "", pw"" : """") + ""]"";
    }

    //  Private instance variables
    private HttpServletResponse response = null;

    private boolean binary = false;

    private ByteArrayOutputStream baos = null;

    private PrintWriter pw = null;
}
","// HTMLOutputStreamTest.java
package bible.servlet;

import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HTMLOutputStream}.
* It contains ten unit test cases for the {@link HTMLOutputStream#reset()} method.
*/
class HTMLOutputStreamTest {","// HTMLOutputStreamTest.java
package bible.servlet;

import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HTMLOutputStream}.
* It contains ten unit test cases for the {@link HTMLOutputStream#reset()} method.
*/
class HTMLOutputStreamTest {

	/**
	* Test case for {@link HTMLOutputStream#reset()} method.
	* It tests the case when the buffer is empty.
	*/
	@Test
	public void testResetEmpty() {
		HTMLOutputStream hos = new HTMLOutputStream(new HttpServletResponse() {
			public void addCookie(Cookie cookie) {}
			public void addDateHeader(String name, long date) {}
			public void addHeader(String name, String value) {}
			public void addIntHeader(String name, int value) {}
			public boolean containsHeader(String name) {return false;}
			public String encodeRedirectURL(String url) {return null;}
			public String encodeRedirectUrl(String url) {return null;}
			public String encodeURL(String url) {return null;}
			public String encodeUrl(String url) {return null;}
			public void sendError(int sc) throws IOException {}
			public void sendError(int sc, String msg) throws IOException {}
			public void sendRedirect(String location) throws IOException {}
			public void setDateHeader(String name, long date) {}
			public void setHeader(String name, String value) {}
			public void setIntHeader(String name, int value) {}
			public void setStatus(int sc) {}
			public void setStatus(int sc, String sm) {}
			public void flushBuffer() throws IOException {}
			public int getBufferSize() {return 0;}
			public String getCharacterEncoding() {return null;}
			public String getContentType() {return null;}
			public Locale getLocale() {return null;}
			public ServletOutputStream getOutputStream() throws IOException {return null;}
			public PrintWriter getWriter() throws IOException {return null;}
			public boolean isCommitted() {return false;}
			public void reset() {}
			public void resetBuffer() {}
			public void setBufferSize(int size) {}
			public void setCharacterEncoding(String charset) {}
			public void setContentLength(int len) {}
			public void setContentType(String type) {}
			public void setLocale(Locale loc) {}
		});
		assertEquals("""", hos.reset());
	}
	
	/**
	* Test case for {@link HTMLOutputStream#reset()} method.
	* It tests the case when the buffer is not empty.
	*/
	@Test
	public void testResetNotEmpty() {
		HTMLOutputStream hos = new HTMLOutputStream(new HttpServletResponse() {
			public void addCookie(Cookie cookie) {}
			public void addDateHeader(String name, long date) {}
			public void addHeader(String name, String value) {}
			public void addIntHeader(String name, int value) {}
			public boolean containsHeader(String name) {return false;}
			public String encodeRedirectURL(String url) {return null;}
			public String encodeRedirectUrl(String url) {return null;}
			public String encodeURL(String url) {return null;}
			public String encodeUrl(String url) {return null;}
			public void sendError(int sc) throws IOException {}
			public void sendError(int sc, String msg) throws IOException {}
			public void sendRedirect(String location) throws IOException {}
			public void setDateHeader(String name, long date) {}
			public void setHeader(String name, String value) {}
			public void setIntHeader(String name, int value) {}
			public void setStatus(int sc) {}
			public void setStatus(int sc, String sm) {}
			public void flushBuffer() throws IOException {}
			public int getBufferSize() {return 0;}
			public String getCharacterEncoding() {return null;}
			public String getContentType() {return null;}
			public Locale getLocale() {return null;}
			public ServletOutputStream getOutputStream() throws IOException {return null;}
			public PrintWriter getWriter() throws IOException {return null;}
			public boolean isCommitted() {return false;}
			public void reset() {}
			public void resetBuffer() {}
			public void setBufferSize(int size) {}
			public void setCharacterEncoding(String charset) {}
			public void setContentLength(int len) {}
			public void setContentType(String type) {}
			public void setLocale(Locale loc) {}
		});
		hos.print(""test"");
		assertEquals(""test"", hos.reset());
	}
	
	/**
	* Test case for {@link HTMLOutputStream#reset()} method.
	* It tests the case when the buffer is not empty and contains a new line.
	*/
	@Test
	public void testResetNotEmptyNewLine() {
		HTMLOutputStream hos = new HTMLOutputStream(new HttpServletResponse() {
			public void addCookie(Cookie cookie) {}
			public void addDateHeader(String name, long date) {}
			public void addHeader(String name, String value) {}
			public void addIntHeader(String name, int value) {}
			public boolean containsHeader(String name) {return false;}
			public String encodeRedirectURL(String url) {return null;}
			public String encodeRedirectUrl(String url) {return null;}
			public String encodeURL(String url) {return null;}
			public String encodeUrl(String url) {return null;}
			public void sendError(int sc) throws IOException {}
			public void sendError(int sc, String msg) throws IOException {}
			public void sendRedirect(String location) throws IOException {}
			public void setDateHeader(String name, long date) {}
			public void setHeader(String name, String value) {}
			public void setIntHeader(String name, int value) {}
			public void setStatus(int sc) {}
			public void setStatus(int sc, String sm) {}
			public void flushBuffer() throws IOException {}
			public int getBufferSize() {return 0;}
			public String getCharacterEncoding() {return null;}
			public String getContentType() {return null;}
			public Locale getLocale() {return null;}
			public ServletOutputStream getOutputStream() throws IOException {return null;}
			public PrintWriter getWriter() throws IOException {return null;}
			public boolean isCommitted() {return false;}
			public void reset() {}
			public void resetBuffer() {}
			public void setBufferSize(int size) {}
			public void setCharacterEncoding(String charset) {}
			public void setContentLength(int len) {}
			public void setContentType(String type) {}
			public void setLocale(Locale loc) {}
		});
		hos.print(""test\n"");
		assertEquals(""test\n"", hos.reset());
	}
	
	/**
	* Test case for {@link HTMLOutputStream#reset()} method.
	* It tests the case when the buffer is not empty and contains a new line and a tab.
	*/
	@Test
	public void testResetNotEmptyNewLineTab() {
		HTMLOutputStream hos = new HTMLOutputStream(new HttpServletResponse() {
			public void addCookie(Cookie cookie) {}
			public void addDateHeader(String name, long date) {}
			public void addHeader(String name, String value) {}
			public void addIntHeader(String name, int value) {}
			public boolean containsHeader(String name) {return false;}
			public String encodeRedirectURL(String url) {return null;}
			public String encodeRedirectUrl(String url) {return null;}
			public String encodeURL(String url) {return null;}
			public String encodeUrl(String url) {return null;}
			public void sendError(int sc) throws IOException {}
			public void sendError(int sc, String msg) throws IOException {}
			public void sendRedirect(String location) throws IOException {}
			public void setDateHeader(String name, long date) {}
			public void setHeader(String name, String value) {}
			public void setIntHeader(String name, int value) {}
			public void setStatus(int sc) {}
			public void setStatus(int sc, String sm) {}
			public void flushBuffer() throws IOException {}
			public int getBufferSize() {return 0;}
			public String getCharacterEncoding() {return null;}
			public String getContentType() {return null;}
			public Locale getLocale() {return null;}
			public ServletOutputStream getOutputStream() throws IOException {return null;}
			public PrintWriter getWriter() throws IOException {return null;}
			public boolean isCommitted() {return false;}
			public void reset() {}
			public void resetBuffer() {}
			public void setBufferSize(int size) {}
			public void setCharacterEncoding(String charset) {}
			public void setContentLength(int len) {}
			public void setContentType(String type) {}
			public void setLocale(Locale loc) {}
		});
		hos.print(""test\n\t"");
		assertEquals(""test\n\t"", hos.reset());
	}
	
	/**
	* Test case for {@link HTMLOutputStream#reset()} method.
	* It tests the case when the buffer is not empty and contains a new line, a tab and a space.
	*/
	@Test
	public void testResetNotEmptyNewLineTabSpace() {
		HTMLOutputStream hos = new HTMLOutputStream(new HttpServletResponse() {
			public void addCookie(Cookie cookie) {}
			public void addDateHeader(String name, long date) {}
			public void addHeader(String name, String value) {}
			public void addIntHeader(String name, int value) {}
			public boolean containsHeader(String name) {return false;}
			public String encodeRedirectURL(String url) {return null;}
			public String encodeRedirectUrl(String url) {return null;}
			public String encodeURL(String url) {return null;}
			public String encodeUrl(String url) {return null;}
			public void sendError(int sc) throws IOException {}
			public void sendError(int sc, String msg) throws IOException {}
			public void sendRedirect(String location) throws IOException {}
			public void setDateHeader(String name, long date) {}
			public void setHeader(String name, String value) {}
			public void setIntHeader(String name, int value) {}
			public void setStatus(int sc) {}
			public void setStatus(int sc, String sm) {}
			public void flushBuffer() throws IOException {}
			public int getBufferSize() {return 0;}
			public String getCharacterEncoding() {return null;}
			public String getContentType() {return null;}
			public Locale getLocale() {return null;}
			public ServletOutputStream getOutputStream() throws IOException {return null;}
			public PrintWriter getWriter() throws IOException {return null;}
			public boolean isCommitted() {return false;}
			public void reset() {}
			public void resetBuffer() {}
			public void setBufferSize(int size) {}
			public void setCharacterEncoding(String charset) {}
			public void setContentLength(int len) {}
			public void setContentType(String type) {}
			public void setLocale(Locale loc) {}
		});
		hos.print(""test\n\t "");
		assertEquals(""test\n\t "", hos.reset());
	}
	
	/**
	* Test case for {@link HTMLOutputStream#reset()} method.
	* It tests the case when the buffer is not empty and contains a new line, a tab, a space and a carriage return.
	*/
	@Test
	public void testResetNotEmptyNewLineTabSpaceCR() {
		HTMLOutputStream hos = new HTMLOutputStream(new HttpServletResponse() {
			public void addCookie(Cookie cookie) {}
			public void addDateHeader(String name, long date) {}
			public void addHeader(String name, String value) {}
			public void addIntHeader(String name, int value) {}
			public boolean containsHeader(String name) {return false;}
			public String encodeRedirectURL(String url) {return null;}
			public String encodeRedirectUrl(String url) {return null;}
			public String encodeURL(String url) {return null;}
			public String encodeUrl(String url) {return null;}
			public void sendError(int sc) throws IOException {}
			public void sendError(int sc, String msg) throws IOException {}
			public void sendRedirect(String location) throws IOException {}
			public void setDateHeader(String name, long date) {}
			public void setHeader(String name, String value) {}
			public void setIntHeader(String name, int value) {}
			public void setStatus(int sc) {}
			public void setStatus(int sc, String sm) {}
			public void flushBuffer() throws IOException {}
			public int getBufferSize() {return 0;}
			public String getCharacterEncoding() {return null;}
			public String getContentType() {return null;}
			public Locale getLocale() {return null;}
			public ServletOutputStream getOutputStream() throws IOException {return null;}
			public PrintWriter getWriter() throws IOException {return null;}
			public boolean isCommitted() {return false;}
			public void reset() {}
			public void resetBuffer() {}
			public void setBufferSize(int size) {}
			public void setCharacterEncoding(String charset) {}
			public void setContentLength(int len) {}
			public void setContentType(String type) {}
			public void setLocale(Locale loc) {}
		});
		hos.print(""test\n\t \r"");
		assertEquals(""test\n\t \r"", hos.reset());
	}
	
	/**
	* Test case for {@link HTMLOutputStream#reset()} method.
	* It tests the case when the buffer is not empty and contains a new line, a tab, a space, a carriage return and a form feed.
	*/
	@Test
	public void testResetNotEmptyNewLineTabSpaceCRFF() {
		HTMLOutputStream hos = new HTMLOutputStream(new HttpServletResponse() {
			public void addCookie(Cookie cookie) {}
			public void addDateHeader(String name, long date) {}
			public void addHeader(String name, String value) {}
			public void addIntHeader(String name, int value) {}
			public boolean containsHeader(String name) {return false;}
			public String encodeRedirectURL(String url) {return null;}
			public String encodeRedirectUrl(String url) {return null;}
			public String encodeURL(String url) {return null;}
			public String encodeUrl(String url) {return null;}
			public void sendError(int sc) throws IOException {}
			public void sendError(int sc, String msg) throws IOException {}
			public void sendRedirect(String location) throws IOException {}
			public void setDateHeader(String name, long"
cmpl-6wgyG0l636Ajnj27PXGvSglsQshJx,/EvoSuiteBenchmark/original/68_biblestudy/src/main/java/bible/util/Queue_0Test.java,97.56712102890015,length,"// Queue.java
package bible.util;

import java.util.*;

/**
 * Queue is a storage class to link together <b>Node</b> objects which are
 * stored in a first in first out storage system.
 *
 * @see Node
 * @version   1.0
 * @author    LaMoine Zielieke, James Stauffer
 */
public class Queue {

    public final static int NO_MAXIMUM = -1;

    /**
     * number of items in this list
     */
    private int numItems;

    private int maxNumItems;

    private int maxCapacity;

    /**
     * first Node in list
     */
    private Node first;

    /**
     * last Node in list
     */
    private Node last;

    /**
     * Constructor creating an empty Queue.  All variables are set to zero
     * or null.
     */
    public Queue() {
        this(NO_MAXIMUM);
    }

    /**
     * Constructor creating an empty Queue.  All variables are set to zero
     * or null.
     */
    public Queue(int capacity) {
        first = null;
        last = null;
        numItems = 0;
        maxNumItems = 0;
        maxCapacity = capacity;
    }

    /**
     * See if the queue is empty.
     * @return     <code>true</code> if Queue is empty;
     *             <code>false</code> otherwise.
     */
    public boolean isEmpty() {
        return (first == null);
    }

    /**
     * Insert an object into the end of the queue
     *
     * @param someObject  the Object to store
     */
    public void enqueue(Object someObject) {
        if (someObject != null) {
            Node newNode = new Node(someObject);
            synchronized (this) {
                //System.out.println(""+++"" + someObject);
                if (isEmpty()) {
                    first = newNode;
                    last = newNode;
                } else {
                    //Add at end
                    last.next = newNode;
                    last = newNode;
                }
                numItems++;
                if (numItems > maxNumItems) {
                    maxNumItems = numItems;
                }
            }
        }
    }

    /**
     * Remove an object from the front of the Queue
     *
     * @return       Object if Queue is not empty
     *               otherwise print message to dos window
     * @see GameQuestion
     */
    public synchronized Object dequeue() {
        Object obj = null;
        if (isEmpty()) {
            System.out.println(""Cannot remove when queue is empty"");
        } else if (first == last) {
            // first see if we only have one item in the queue
            obj = first.value;
            first = null;
            last = null;
        } else {
            obj = first.value;
            first = first.next;
        }
        numItems--;
        return obj;
    }

    /**
     *  Removes all nodes where Node.value.equals(object).
     */
    public synchronized int remove(Object object) {
        //System.out.println(""---"" + object);
        int originalNumItems = numItems;
        while ((first != null) && (first.value.equals(object))) {
            // found it
            first = first.next;
            numItems--;
        }
        if (first == null) {
            //All elements removed
            last = null;
        } else {
            //Now it isn't in the first node
            for (Node current = first; current.next != null; ) {
                if (current.next.value.equals(object)) {
                    // found it in the next Node
                    current.next = current.next.next;
                    numItems--;
                    if (current.next == null) {
                        // we are removing the last element
                        last = current;
                        // the for loop will be exited
                    }
                } else {
                    current = current.next;
                }
            }
            // of for
        }
        return originalNumItems - numItems;
    }

    /**
     *  Moves element to back of que.
     */
    public synchronized void refreshElement(Object object) {
        remove(object);
        enqueue(object);
    }

    /**
     * See how many items are in the queue.
     *
     * @return integer value of number of items in queue
     */
    public int getNumberItems() {
        return numItems;
    }

    /**
     * The peak number of items in the Queue.
     *
     * @return peak number of items in queue
     */
    public int getPeakNumberItems() {
        return maxNumItems;
    }

    /**
     * The Queue is stepped through one node at a time and the
     * QuestionNumber is inserted into a Vector.This action copies
     * unused question numbers from queue into temp vector.
     *
     * @return   Vector of unused question numbers. In this way when
     *           a new vector of randomized numbers is created the nunbers
     *           already in the queue will not be duplicated.  If number
     *           396 is in the queue we do not want 396 to appear in the
     *           new randomized vector.  This method is only called in
     *           <b>DataBase</b>
     * @see      Database#load
     * @see      GameQuestion
     */
    public Vector getObjects() {
        Node i;
        Vector tempVector = new Vector(numItems, 10);
        for (i = first; i != null; i = i.next) {
            tempVector.addElement(i.value);
        }
        // end for
        return tempVector;
    }

    // end getUnused
    /**
     *  Returns true if the first should be removed.
     */
    public boolean maxCapacityExceeded() {
        return (numItems > (maxCapacity - 1)) && (maxCapacity != NO_MAXIMUM);
    }

    public String toString() {
        return getClass().getName() + "":[numItems="" + numItems + "", maxNumItems="" + maxNumItems + "", maxCapacity="" + maxCapacity + "", getObjects()="" + getObjects() + ""\r\n]"";
    }

    /**
     * Node objects hold the Object to be stored and the next node in our linked list.
     * In this way we can access the next node in our <b>Queue</b>.
     *
     * @version   2.0
     * @author    LaMoine Zielieke
     */
    class Node {

        /**
         * The next Node in the chain.
         */
        Node next;

        /**
         * The Object this node stores.
         */
        Object value;

        /**
         * @param  obj   the Object to be inserted into the node.
         */
        public Node(Object obj) {
            value = obj;
        }
    }
}
","// Queue_0Test.java
package bible.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Queue}.
* It contains ten unit test cases for the {@link Queue#dequeue()} method.
*/
class Queue_0Test {","// Queue_0Test.java
package bible.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Queue}.
* It contains ten unit test cases for the {@link Queue#dequeue()} method.
*/
class Queue_0Test {

	/**
	* Test case for {@link Queue#dequeue()}.
	*/
	@Test
	void testDequeue_0() {
		Queue queue = new Queue();
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue.dequeue();
		queue"
cmpl-6wgzqgBVujNGbsKLSYd83gTiFamSp,/EvoSuiteBenchmark/original/68_biblestudy/src/main/java/bible/util/Queue_2Test.java,35.66756057739258,,"// Queue.java
package bible.util;

import java.util.*;

/**
 * Queue is a storage class to link together <b>Node</b> objects which are
 * stored in a first in first out storage system.
 *
 * @see Node
 * @version   1.0
 * @author    LaMoine Zielieke, James Stauffer
 */
public class Queue {

    public final static int NO_MAXIMUM = -1;

    /**
     * number of items in this list
     */
    private int numItems;

    private int maxNumItems;

    private int maxCapacity;

    /**
     * first Node in list
     */
    private Node first;

    /**
     * last Node in list
     */
    private Node last;

    /**
     * Constructor creating an empty Queue.  All variables are set to zero
     * or null.
     */
    public Queue() {
        this(NO_MAXIMUM);
    }

    /**
     * Constructor creating an empty Queue.  All variables are set to zero
     * or null.
     */
    public Queue(int capacity) {
        first = null;
        last = null;
        numItems = 0;
        maxNumItems = 0;
        maxCapacity = capacity;
    }

    /**
     * See if the queue is empty.
     * @return     <code>true</code> if Queue is empty;
     *             <code>false</code> otherwise.
     */
    public boolean isEmpty() {
        return (first == null);
    }

    /**
     * Insert an object into the end of the queue
     *
     * @param someObject  the Object to store
     */
    public void enqueue(Object someObject) {
        if (someObject != null) {
            Node newNode = new Node(someObject);
            synchronized (this) {
                //System.out.println(""+++"" + someObject);
                if (isEmpty()) {
                    first = newNode;
                    last = newNode;
                } else {
                    //Add at end
                    last.next = newNode;
                    last = newNode;
                }
                numItems++;
                if (numItems > maxNumItems) {
                    maxNumItems = numItems;
                }
            }
        }
    }

    /**
     * Remove an object from the front of the Queue
     *
     * @return       Object if Queue is not empty
     *               otherwise print message to dos window
     * @see GameQuestion
     */
    public synchronized Object dequeue() {
        Object obj = null;
        if (isEmpty()) {
            System.out.println(""Cannot remove when queue is empty"");
        } else if (first == last) {
            // first see if we only have one item in the queue
            obj = first.value;
            first = null;
            last = null;
        } else {
            obj = first.value;
            first = first.next;
        }
        numItems--;
        return obj;
    }

    /**
     *  Removes all nodes where Node.value.equals(object).
     */
    public synchronized int remove(Object object) {
        //System.out.println(""---"" + object);
        int originalNumItems = numItems;
        while ((first != null) && (first.value.equals(object))) {
            // found it
            first = first.next;
            numItems--;
        }
        if (first == null) {
            //All elements removed
            last = null;
        } else {
            //Now it isn't in the first node
            for (Node current = first; current.next != null; ) {
                if (current.next.value.equals(object)) {
                    // found it in the next Node
                    current.next = current.next.next;
                    numItems--;
                    if (current.next == null) {
                        // we are removing the last element
                        last = current;
                        // the for loop will be exited
                    }
                } else {
                    current = current.next;
                }
            }
            // of for
        }
        return originalNumItems - numItems;
    }

    /**
     *  Moves element to back of que.
     */
    public synchronized void refreshElement(Object object) {
        remove(object);
        enqueue(object);
    }

    /**
     * See how many items are in the queue.
     *
     * @return integer value of number of items in queue
     */
    public int getNumberItems() {
        return numItems;
    }

    /**
     * The peak number of items in the Queue.
     *
     * @return peak number of items in queue
     */
    public int getPeakNumberItems() {
        return maxNumItems;
    }

    /**
     * The Queue is stepped through one node at a time and the
     * QuestionNumber is inserted into a Vector.This action copies
     * unused question numbers from queue into temp vector.
     *
     * @return   Vector of unused question numbers. In this way when
     *           a new vector of randomized numbers is created the nunbers
     *           already in the queue will not be duplicated.  If number
     *           396 is in the queue we do not want 396 to appear in the
     *           new randomized vector.  This method is only called in
     *           <b>DataBase</b>
     * @see      Database#load
     * @see      GameQuestion
     */
    public Vector getObjects() {
        Node i;
        Vector tempVector = new Vector(numItems, 10);
        for (i = first; i != null; i = i.next) {
            tempVector.addElement(i.value);
        }
        // end for
        return tempVector;
    }

    // end getUnused
    /**
     *  Returns true if the first should be removed.
     */
    public boolean maxCapacityExceeded() {
        return (numItems > (maxCapacity - 1)) && (maxCapacity != NO_MAXIMUM);
    }

    public String toString() {
        return getClass().getName() + "":[numItems="" + numItems + "", maxNumItems="" + maxNumItems + "", maxCapacity="" + maxCapacity + "", getObjects()="" + getObjects() + ""\r\n]"";
    }

    /**
     * Node objects hold the Object to be stored and the next node in our linked list.
     * In this way we can access the next node in our <b>Queue</b>.
     *
     * @version   2.0
     * @author    LaMoine Zielieke
     */
    class Node {

        /**
         * The next Node in the chain.
         */
        Node next;

        /**
         * The Object this node stores.
         */
        Object value;

        /**
         * @param  obj   the Object to be inserted into the node.
         */
        public Node(Object obj) {
            value = obj;
        }
    }
}
","// Queue_2Test.java
package bible.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Queue}.
* It contains ten unit test cases for the {@link Queue#maxCapacityExceeded()} method.
*/
class Queue_2Test {","// Queue_2Test.java
package bible.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Queue}.
* It contains ten unit test cases for the {@link Queue#maxCapacityExceeded()} method.
*/
class Queue_2Test {

	/**
	* Test case for {@link Queue#maxCapacityExceeded()}.
	* The test case is successful if the method returns <code>false</code>.
	*/
	@Test
	void testMaxCapacityExceeded_1() {
		Queue queue = new Queue(10);
		assertFalse(queue.maxCapacityExceeded());
	}
	
	/**
	* Test case for {@link Queue#maxCapacityExceeded()}.
	* The test case is successful if the method returns <code>false</code>.
	*/
	@Test
	void testMaxCapacityExceeded_2() {
		Queue queue = new Queue(10);
		queue.enqueue(new Object());
		assertFalse(queue.maxCapacityExceeded());
	}
	
	/**
	* Test case for {@link Queue#maxCapacityExceeded()}.
	* The test case is successful if the method returns <code>false</code>.
	*/
	@Test
	void testMaxCapacityExceeded_3() {
		Queue queue = new Queue(10);
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		assertFalse(queue.maxCapacityExceeded());
	}
	
	/**
	* Test case for {@link Queue#maxCapacityExceeded()}.
	* The test case is successful if the method returns <code>false</code>.
	*/
	@Test
	void testMaxCapacityExceeded_4() {
		Queue queue = new Queue(10);
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		assertFalse(queue.maxCapacityExceeded());
	}
	
	/**
	* Test case for {@link Queue#maxCapacityExceeded()}.
	* The test case is successful if the method returns <code>false</code>.
	*/
	@Test
	void testMaxCapacityExceeded_5() {
		Queue queue = new Queue(10);
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		assertFalse(queue.maxCapacityExceeded());
	}
	
	/**
	* Test case for {@link Queue#maxCapacityExceeded()}.
	* The test case is successful if the method returns <code>false</code>.
	*/
	@Test
	void testMaxCapacityExceeded_6() {
		Queue queue = new Queue(10);
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		assertFalse(queue.maxCapacityExceeded());
	}
	
	/**
	* Test case for {@link Queue#maxCapacityExceeded()}.
	* The test case is successful if the method returns <code>false</code>.
	*/
	@Test
	void testMaxCapacityExceeded_7() {
		Queue queue = new Queue(10);
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		assertFalse(queue.maxCapacityExceeded());
	}
	
	/**
	* Test case for {@link Queue#maxCapacityExceeded()}.
	* The test case is successful if the method returns <code>false</code>.
	*/
	@Test
	void testMaxCapacityExceeded_8() {
		Queue queue = new Queue(10);
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		assertFalse(queue.maxCapacityExceeded());
	}
	
	/**
	* Test case for {@link Queue#maxCapacityExceeded()}.
	* The test case is successful if the method returns <code>false</code>.
	*/
	@Test
	void testMaxCapacityExceeded_9() {
		Queue queue = new Queue(10);
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		assertFalse(queue.maxCapacityExceeded());
	}
	
	/**
	* Test case for {@link Queue#maxCapacityExceeded()}.
	* The test case is successful if the method returns <code>true</code>.
	*/
	@Test
	void testMaxCapacityExceeded_10() {
		Queue queue = new Queue(10);
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		queue.enqueue(new Object());
		assertTrue(queue.maxCapacityExceeded());
	}
}"
