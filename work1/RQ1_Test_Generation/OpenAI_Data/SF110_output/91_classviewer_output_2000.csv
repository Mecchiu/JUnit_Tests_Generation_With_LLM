ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6wS72a2LREjqdIXyhCMKVd0rvpyqv,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_0Test.java,58.74748611450195,length,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_0Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printFields()} method.
*/
class ClassInfo_0Test {","// ClassInfo_0Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printFields()} method.
*/
class ClassInfo_0Test {

		@Test
		void testPrintFields() {
				ClassInfo ci = new ClassInfo(""java.lang.String"");
				String[] fields = ci.printFields();
				assertEquals(fields[0], ""public static final int java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[1], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[2], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[3], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[4], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[5], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[6], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[7], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[8], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[9], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[10], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[11], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[12], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[13], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[14], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[15], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[16], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[17], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[18], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[19], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[20], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[21], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[22], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[23], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[24], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[25], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[26], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[27], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[28], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[29], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[30], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[31], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[32], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[33], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[34], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[35], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[36], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[37], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[38], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[39], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[40], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[41], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[42], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[43], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[44], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[45], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[46], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[47], ""public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER"");
				assertEquals(fields[48], ""public static final java.util.Comparator java.lang.String.CASE_INSENS"
cmpl-6wS855waXwbevimJ8ov9Jklow06CC,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_1Test.java,72.85919547080994,length,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_1Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printMethods()} method.
*/
class ClassInfo_1Test {","// ClassInfo_1Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printMethods()} method.
*/
class ClassInfo_1Test {

		/**
		* Test case for {@link ClassInfo#printMethods()} method.
		* <p>
		* This test case checks if the method returns the correct array of strings.
		*/
		@Test
		void testPrintMethods() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				String[] data = myClassInfo.printMethods();
				assertEquals(data[0], ""public boolean java.lang.String.equals(java.lang.Object)"");
				assertEquals(data[1], ""public java.lang.String java.lang.String.toString()"");
				assertEquals(data[2], ""public int java.lang.String.hashCode()"");
				assertEquals(data[3], ""public int java.lang.String.length()"");
				assertEquals(data[4], ""public char java.lang.String.charAt(int)"");
				assertEquals(data[5], ""public int java.lang.String.compareTo(java.lang.String)"");
				assertEquals(data[6], ""public int java.lang.String.compareTo(java.lang.Object)"");
				assertEquals(data[7], ""public int java.lang.String.compareToIgnoreCase(java.lang.String)"");
				assertEquals(data[8], ""public boolean java.lang.String.equalsIgnoreCase(java.lang.String)"");
				assertEquals(data[9], ""public int java.lang.String.indexOf(int)"");
				assertEquals(data[10], ""public int java.lang.String.indexOf(int,int)"");
				assertEquals(data[11], ""public int java.lang.String.indexOf(java.lang.String)"");
				assertEquals(data[12], ""public int java.lang.String.indexOf(java.lang.String,int)"");
				assertEquals(data[13], ""public java.lang.String java.lang.String.intern()"");
				assertEquals(data[14], ""public int java.lang.String.lastIndexOf(int)"");
				assertEquals(data[15], ""public int java.lang.String.lastIndexOf(int,int)"");
				assertEquals(data[16], ""public int java.lang.String.lastIndexOf(java.lang.String)"");
				assertEquals(data[17], ""public int java.lang.String.lastIndexOf(java.lang.String,int)"");
				assertEquals(data[18], ""public int java.lang.String.length()"");
				assertEquals(data[19], ""public boolean java.lang.String.matches(java.lang.String)"");
				assertEquals(data[20], ""public boolean java.lang.String.regionMatches(boolean,int,java.lang.String,int,int)"");
				assertEquals(data[21], ""public boolean java.lang.String.regionMatches(int,java.lang.String,int,int)"");
				assertEquals(data[22], ""public java.lang.String java.lang.String.replaceAll(java.lang.String,java.lang.String)"");
				assertEquals(data[23], ""public java.lang.String java.lang.String.replaceFirst(java.lang.String,java.lang.String)"");
				assertEquals(data[24], ""public java.lang.String[] java.lang.String.split(java.lang.String)"");
				assertEquals(data[25], ""public java.lang.String[] java.lang.String.split(java.lang.String,int)"");
				assertEquals(data[26], ""public boolean java.lang.String.startsWith(java.lang.String,int)"");
				assertEquals(data[27], ""public boolean java.lang.String.startsWith(java.lang.String)"");
				assertEquals(data[28], ""public java.lang.CharSequence java.lang.String.subSequence(int,int)"");
				assertEquals(data[29], ""public java.lang.String java.lang.String.substring(int)"");
				assertEquals(data[30], ""public java.lang.String java.lang.String.substring(int,int)"");
				assertEquals(data[31], ""public char[] java.lang.String.toCharArray()"");
				assertEquals(data[32], ""public java.lang.String java.lang.String.toLowerCase()"");
				assertEquals(data[33], ""public java.lang.String java.lang.String.toString()"");
				assertEquals(data[34], ""public java.lang.String java.lang.String.toUpperCase()"");
				assertEquals(data[35], ""public java.lang.String java.lang.String.trim()"");
				assertEquals(data[36], ""public static java.lang.String java.lang.String.valueOf(boolean)"");
				assertEquals(data[37], ""public static java.lang.String java.lang.String.valueOf(char)"");
				assertEquals(data[38], ""public static java.lang.String java.lang.String.valueOf(char[])"");
				assertEquals(data[39], ""public static java.lang.String java.lang.String.valueOf(char[],int,int)"");
				assertEquals(data[40], ""public static java.lang.String java.lang.String.valueOf(double)"");
				assertEquals(data[41], ""public static java.lang.String java.lang.String.valueOf(float)"");
				assertEquals(data[42], ""public static java.lang.String java.lang.String.valueOf(int)"");
				assertEquals(data[43], ""public static java.lang.String java.lang.String.valueOf(long)"");
				assertEquals(data[44], ""public static java.lang.String java.lang.String.valueOf(java.lang.Object)"");
				assertEquals(data[45], ""public static java.lang.String java.lang.String.valueOf(java.lang.String)"");
				assertEquals(data[46], ""public void java.lang.String.getChars(int,int,char[],int)"");
				assertEquals(data[47], ""public void java.lang.String.getBytes(int,int,byte[],int)"");
				assertEquals(data[48], ""public byte[] java.lang.String.getBytes(java.lang.String) throws java.io.UnsupportedEncodingException"");
				assertEquals(data[49], ""public byte[] java.lang.String.getBytes()"");
				assertEquals(data[50], ""public boolean java.lang.String.contentEquals(java.lang.StringBuffer)"");
				assertEquals(data[51], ""public boolean java.lang.String.contentEquals(java.lang.CharSequence)"");
				assertEquals(data[52], ""public boolean java.lang.String.equalsIgnoreCase(java.lang.String)"");
				assertEquals(data[53], ""public int java.lang.String.compareToIgnoreCase(java.lang.String)"");
				assertEquals(data[54], ""public boolean java.lang.String.regionMatches(boolean,int,java.lang.String,int,int)"");
				assertEquals(data[55], ""public boolean java.lang.String.regionMatches(int,java.lang.String,int,int)"");
				assertEquals(data[56],"
cmpl-6wS9G9C1mhXnK47B4tRA6aEosf6Kz,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_2Test.java,70.4148268699646,length,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_2Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printMethods(int)} method.
*/
class ClassInfo_2Test {","// ClassInfo_2Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printMethods(int)} method.
*/
class ClassInfo_2Test {

		private ClassInfo myClassInfo;
		
		private String[] cMethods;
		
		private String[] fndMethods;
		
		private String[] tempArray;
		
		private String[] data;
		
		private String[] tempArray2;
		
		private String[] data2;
		
		private String[] tempArray3;
		
		private String[] data3;
		
		private String[] tempArray4;
		
		private String[] data4;
		
		private String[] tempArray5;
		
		private String[] data5;
		
		private String[] tempArray6;
		
		private String[] data6;
		
		private String[] tempArray7;
		
		private String[] data7;
		
		private String[] tempArray8;
		
		private String[] data8;
		
		private String[] tempArray9;
		
		private String[] data9;
		
		private String[] tempArray10;
		
		private String[] data10;
		
		private String[] tempArray11;
		
		private String[] data11;
		
		private String[] tempArray12;
		
		private String[] data12;
		
		private String[] tempArray13;
		
		private String[] data13;
		
		private String[] tempArray14;
		
		private String[] data14;
		
		private String[] tempArray15;
		
		private String[] data15;
		
		private String[] tempArray16;
		
		private String[] data16;
		
		private String[] tempArray17;
		
		private String[] data17;
		
		private String[] tempArray18;
		
		private String[] data18;
		
		private String[] tempArray19;
		
		private String[] data19;
		
		private String[] tempArray20;
		
		private String[] data20;
		
		private String[] tempArray21;
		
		private String[] data21;
		
		private String[] tempArray22;
		
		private String[] data22;
		
		private String[] tempArray23;
		
		private String[] data23;
		
		private String[] tempArray24;
		
		private String[] data24;
		
		private String[] tempArray25;
		
		private String[] data25;
		
		private String[] tempArray26;
		
		private String[] data26;
		
		private String[] tempArray27;
		
		private String[] data27;
		
		private String[] tempArray28;
		
		private String[] data28;
		
		private String[] tempArray29;
		
		private String[] data29;
		
		private String[] tempArray30;
		
		private String[] data30;
		
		private String[] tempArray31;
		
		private String[] data31;
		
		private String[] tempArray32;
		
		private String[] data32;
		
		private String[] tempArray33;
		
		private String[] data33;
		
		private String[] tempArray34;
		
		private String[] data34;
		
		private String[] tempArray35;
		
		private String[] data35;
		
		private String[] tempArray36;
		
		private String[] data36;
		
		private String[] tempArray37;
		
		private String[] data37;
		
		private String[] tempArray38;
		
		private String[] data38;
		
		private String[] tempArray39;
		
		private String[] data39;
		
		private String[] tempArray40;
		
		private String[] data40;
		
		private String[] tempArray41;
		
		private String[] data41;
		
		private String[] tempArray42;
		
		private String[] data42;
		
		private String[] tempArray43;
		
		private String[] data43;
		
		private String[] tempArray44;
		
		private String[] data44;
		
		private String[] tempArray45;
		
		private String[] data45;
		
		private String[] tempArray46;
		
		private String[] data46;
		
		private String[] tempArray47;
		
		private String[] data47;
		
		private String[] tempArray48;
		
		private String[] data48;
		
		private String[] tempArray49;
		
		private String[] data49;
		
		private String[] tempArray50;
		
		private String[] data50;
		
		private String[] tempArray51;
		
		private String[] data51;
		
		private String[] tempArray52;
		
		private String[] data52;
		
		private String[] tempArray53;
		
		private String[] data53;
		
		private String[] tempArray54;
		
		private String[] data54;
		
		private String[] tempArray55;
		
		private String[] data55;
		
		private String[] tempArray56;
		
		private String[] data56;
		
		private String[] tempArray57;
		
		private String[] data57;
		
		private String[] tempArray58;
		
		private String[] data58;
		
		private String[] tempArray59;
		
		private String[] data59;
		
		private String[] tempArray60;
		
		private String[] data60;
		
		private String[] tempArray61;
		
		private String[] data61;
		
		private String[] tempArray62;
		
		private String[] data62;
		
		private String[] tempArray63;
		
		private String[] data63;
		
		private String[] tempArray64;
		
		private String[] data64;
		
		private String[] tempArray65;
		
		private String[] data65;
		
		private String[] tempArray66;
		
		private String[] data66;
		
		private String[] tempArray67;
		
		private String[] data67;
		
		private String[] tempArray68;
		
		private String[] data68;
		
		private String[] tempArray69;
		
		private String[] data69;
		
		private String[] tempArray70;
		
		private String[] data70;
		
		private String[] tempArray71;
		
		private String[] data71;
		
		private String[] tempArray72;
		
		private String[] data72;
		
		private String[] tempArray73;
		
		private String[] data73;
		
		private String[] tempArray74;
		
		private String[] data74;
		
		private String[] tempArray75;
		
		private String[] data75;
		
		private String[] tempArray76;
		
		private String[] data76;
		
		private String[] tempArray77;
		
		private String[] data77;
		
		private String[] tempArray78;
		
		private String[] data78;
		
		private String[] tempArray79;
		
"
cmpl-6wSAO2avHBaBNV1mcWOrXLRsPOW1A,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_3Test.java,62.0814106464386,length,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_3Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printConstructors()} method.
*/
class ClassInfo_3Test {","// ClassInfo_3Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printConstructors()} method.
*/
class ClassInfo_3Test {

		private ClassInfo myClassInfo;
		
		private String[] cMethods;
		
		private String[] fndMethods;
		
		private String[] cConstructors;
		
		private String[] fndConstructors;
		
		private String[] cInterfaces;
		
		private String[] fndInterfaces;
		
		private String[] cFields;
		
		private String[] fndFields;
		
		private String[] cPackages;
		
		private String[] fndPackages;
		
		private String[] cClasses;
		
		private String[] fndClasses;
		
		private String[] cSuperClasses;
		
		private String[] fndSuperClasses;
		
		private String[] cSuperPackages;
		
		private String[] fndSuperPackages;
		
		private String[] cSuperInterfaces;
		
		private String[] fndSuperInterfaces;
		
		private String[] cSuperFields;
		
		private String[] fndSuperFields;
		
		private String[] cSuperMethods;
		
		private String[] fndSuperMethods;
		
		private String[] cSuperConstructors;
		
		private String[] fndSuperConstructors;
		
		private String[] cSuperClasses2;
		
		private String[] fndSuperClasses2;
		
		private String[] cSuperPackages2;
		
		private String[] fndSuperPackages2;
		
		private String[] cSuperInterfaces2;
		
		private String[] fndSuperInterfaces2;
		
		private String[] cSuperFields2;
		
		private String[] fndSuperFields2;
		
		private String[] cSuperMethods2;
		
		private String[] fndSuperMethods2;
		
		private String[] cSuperConstructors2;
		
		private String[] fndSuperConstructors2;
		
		private String[] cSuperClasses3;
		
		private String[] fndSuperClasses3;
		
		private String[] cSuperPackages3;
		
		private String[] fndSuperPackages3;
		
		private String[] cSuperInterfaces3;
		
		private String[] fndSuperInterfaces3;
		
		private String[] cSuperFields3;
		
		private String[] fndSuperFields3;
		
		private String[] cSuperMethods3;
		
		private String[] fndSuperMethods3;
		
		private String[] cSuperConstructors3;
		
		private String[] fndSuperConstructors3;
		
		private String[] cSuperClasses4;
		
		private String[] fndSuperClasses4;
		
		private String[] cSuperPackages4;
		
		private String[] fndSuperPackages4;
		
		private String[] cSuperInterfaces4;
		
		private String[] fndSuperInterfaces4;
		
		private String[] cSuperFields4;
		
		private String[] fndSuperFields4;
		
		private String[] cSuperMethods4;
		
		private String[] fndSuperMethods4;
		
		private String[] cSuperConstructors4;
		
		private String[] fndSuperConstructors4;
		
		private String[] cSuperClasses5;
		
		private String[] fndSuperClasses5;
		
		private String[] cSuperPackages5;
		
		private String[] fndSuperPackages5;
		
		private String[] cSuperInterfaces5;
		
		private String[] fndSuperInterfaces5;
		
		private String[] cSuperFields5;
		
		private String[] fndSuperFields5;
		
		private String[] cSuperMethods5;
		
		private String[] fndSuperMethods5;
		
		private String[] cSuperConstructors5;
		
		private String[] fndSuperConstructors5;
		
		private String[] cSuperClasses6;
		
		private String[] fndSuperClasses6;
		
		private String[] cSuperPackages6;
		
		private String[] fndSuperPackages6;
		
		private String[] cSuperInterfaces6;
		
		private String[] fndSuperInterfaces6;
		
		private String[] cSuperFields6;
		
		private String[] fndSuperFields6;
		
		private String[] cSuperMethods6;
		
		private String[] fndSuperMethods6;
		
		private String[] cSuperConstructors6;
		
		private String[] fndSuperConstructors6;
		
		private String[] cSuperClasses7;
		
		private String[] fndSuperClasses7;
		
		private String[] cSuperPackages7;
		
		private String[] fndSuperPackages7;
		
		private String[] cSuperInterfaces7;
		
		private String[] fndSuperInterfaces7;
		
		private String[] cSuperFields7;
		
		private String[] fndSuperFields7;
		
		private String[] cSuperMethods7;
		
		private String[] fndSuperMethods7;
		
		private String[] cSuperConstructors7;
		
		private String[] fndSuperConstructors7;
		
		private String[] cSuperClasses8;
		
		private String[] fndSuperClasses8;
		
		private String[] cSuperPackages8;
		
		private String[] fndSuperPackages8;
		
		private String[] cSuperInterfaces8;
		
		private String[] fndSuperInterfaces8;
		
		private String[] cSuperFields8;
		
		private String[] fndSuperFields8;
		
		private String[] cSuperMethods8;
		
		private String[] fndSuperMethods8;
		
		private String[] cSuperConstructors8;
		
		private String[] fndSuperConstructors8;
		
		private String[] cSuperClasses9;
		
		private String[] fndSuperClasses9;
		
		private String[] cSuperPackages9;
		
		private String[] fndSuperPackages9;
		
		private String[] cSuperInterfaces9;
		
		private String[] fndSuperInterfaces9;
		
		private String[] cSuperFields9;
		
		private String[] fndSuperFields9;
		
		private String[] cSuperMethods9;
		
		private String[] fndSuperMethods9;
		
		private String[] cSuperConstructors9;
		
		private String[] fndSuperConstructors9;
		
		private String[] cSuperClasses10;
		
		private String[] fndSuperClasses10;
		
		private String[] cSuperPackages10;
		
		private String[] fndSuperPackages10;
		
		private String[] cSuperInterfaces10;
		
		private String[] fndSuperInterfaces10;
		
		private String[] cSuperFields10;
		
		private String[] fndSuperFields10;
		
		private String[] cSuperMethods10;
		
		private String[] fndSuperMethods10;
		
		private String[] cSuperConstructors10;
		
		private String[] fndSuperConstructors10;
	"
cmpl-6wSBOTZR1SsSsAhkilyv0ammzQjkJ,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_4Test.java,71.08352708816528,length,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_4Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printInterfaces()} method.
*/
class ClassInfo_4Test {","// ClassInfo_4Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printInterfaces()} method.
*/
class ClassInfo_4Test {

		private ClassInfo ci;
		
		private String[] interfaces;
		
		private String[] expected;
		
		private String[] actual;
		
		private String[] expected2;
		
		private String[] actual2;
		
		private String[] expected3;
		
		private String[] actual3;
		
		private String[] expected4;
		
		private String[] actual4;
		
		private String[] expected5;
		
		private String[] actual5;
		
		private String[] expected6;
		
		private String[] actual6;
		
		private String[] expected7;
		
		private String[] actual7;
		
		private String[] expected8;
		
		private String[] actual8;
		
		private String[] expected9;
		
		private String[] actual9;
		
		private String[] expected10;
		
		private String[] actual10;
		
		private String[] expected11;
		
		private String[] actual11;
		
		private String[] expected12;
		
		private String[] actual12;
		
		private String[] expected13;
		
		private String[] actual13;
		
		private String[] expected14;
		
		private String[] actual14;
		
		private String[] expected15;
		
		private String[] actual15;
		
		private String[] expected16;
		
		private String[] actual16;
		
		private String[] expected17;
		
		private String[] actual17;
		
		private String[] expected18;
		
		private String[] actual18;
		
		private String[] expected19;
		
		private String[] actual19;
		
		private String[] expected20;
		
		private String[] actual20;
		
		private String[] expected21;
		
		private String[] actual21;
		
		private String[] expected22;
		
		private String[] actual22;
		
		private String[] expected23;
		
		private String[] actual23;
		
		private String[] expected24;
		
		private String[] actual24;
		
		private String[] expected25;
		
		private String[] actual25;
		
		private String[] expected26;
		
		private String[] actual26;
		
		private String[] expected27;
		
		private String[] actual27;
		
		private String[] expected28;
		
		private String[] actual28;
		
		private String[] expected29;
		
		private String[] actual29;
		
		private String[] expected30;
		
		private String[] actual30;
		
		private String[] expected31;
		
		private String[] actual31;
		
		private String[] expected32;
		
		private String[] actual32;
		
		private String[] expected33;
		
		private String[] actual33;
		
		private String[] expected34;
		
		private String[] actual34;
		
		private String[] expected35;
		
		private String[] actual35;
		
		private String[] expected36;
		
		private String[] actual36;
		
		private String[] expected37;
		
		private String[] actual37;
		
		private String[] expected38;
		
		private String[] actual38;
		
		private String[] expected39;
		
		private String[] actual39;
		
		private String[] expected40;
		
		private String[] actual40;
		
		private String[] expected41;
		
		private String[] actual41;
		
		private String[] expected42;
		
		private String[] actual42;
		
		private String[] expected43;
		
		private String[] actual43;
		
		private String[] expected44;
		
		private String[] actual44;
		
		private String[] expected45;
		
		private String[] actual45;
		
		private String[] expected46;
		
		private String[] actual46;
		
		private String[] expected47;
		
		private String[] actual47;
		
		private String[] expected48;
		
		private String[] actual48;
		
		private String[] expected49;
		
		private String[] actual49;
		
		private String[] expected50;
		
		private String[] actual50;
		
		private String[] expected51;
		
		private String[] actual51;
		
		private String[] expected52;
		
		private String[] actual52;
		
		private String[] expected53;
		
		private String[] actual53;
		
		private String[] expected54;
		
		private String[] actual54;
		
		private String[] expected55;
		
		private String[] actual55;
		
		private String[] expected56;
		
		private String[] actual56;
		
		private String[] expected57;
		
		private String[] actual57;
		
		private String[] expected58;
		
		private String[] actual58;
		
		private String[] expected59;
		
		private String[] actual59;
		
		private String[] expected60;
		
		private String[] actual60;
		
		private String[] expected61;
		
		private String[] actual61;
		
		private String[] expected62;
		
		private String[] actual62;
		
		private String[] expected63;
		
		private String[] actual63;
		
		private String[] expected64;
		
		private String[] actual64;
		
		private String[] expected65;
		
		private String[] actual65;
		
		private String[] expected66;
		
		private String[] actual66;
		
		private String[] expected67;
		
		private String[] actual67;
		
		private String[] expected68;
		
		private String[] actual68;
		
		private String[] expected69;
		
		private String[] actual69;
		
		private String[] expected70;
		
		private String[] actual70;
		
		private String[] expected71;
		
		private String[] actual71;
		
		private String[] expected72;
		
		private String[] actual72;
		
		private String[] expected73;
		
		private String[] actual73;
		
		private String[] expected74;
		
		private String[] actual74;
		
		private String[] expected75;
		
		private String[] actual75;
		
		private String[] expected76;
		
		private String[] actual76;
		
		private String[] expected77;
		
		private String[] actual77;
		
		private String[] expected78;
		
		private String[] actual78;
		
		private String[] expected79;
		
		private String[] actual79;
		
		private String[] expected80;
		
		private String[] actual80;
		
		private String[] expected81;
		
		private String[] actual81;
		
		private String[] expected82;
		
		private String[] actual82;
		
		private String[] expected83;
	"
cmpl-6wSCXtMlk3MhGV9yclTJFZ4vZJ5gk,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_5Test.java,61.3284387588501,length,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_5Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getData(Member[])} method.
*/
class ClassInfo_5Test {","// ClassInfo_5Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getData(Member[])} method.
*/
class ClassInfo_5Test {

		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with a null array.
		*/
		@Test
		void testGetData_1() {
				Member[] m = null;
				String[] result = ClassInfo.getData(m);
				assertNull(result);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with an empty array.
		*/
		@Test
		void testGetData_2() {
				Member[] m = new Member[0];
				String[] result = ClassInfo.getData(m);
				assertNull(result);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with an array of one element.
		*/
		@Test
		void testGetData_3() {
				Member[] m = new Member[1];
				m[0] = new Member() {
						public String toString() {
								return ""test"";
						}
				};
				String[] result = ClassInfo.getData(m);
				assertEquals(1, result.length);
				assertEquals(""test"", result[0]);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with an array of two elements.
		*/
		@Test
		void testGetData_4() {
				Member[] m = new Member[2];
				m[0] = new Member() {
						public String toString() {
								return ""test"";
						}
				};
				m[1] = new Member() {
						public String toString() {
								return ""test2"";
						}
				};
				String[] result = ClassInfo.getData(m);
				assertEquals(2, result.length);
				assertEquals(""test"", result[0]);
				assertEquals(""test2"", result[1]);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with an array of three elements.
		*/
		@Test
		void testGetData_5() {
				Member[] m = new Member[3];
				m[0] = new Member() {
						public String toString() {
								return ""test"";
						}
				};
				m[1] = new Member() {
						public String toString() {
								return ""test2"";
						}
				};
				m[2] = new Member() {
						public String toString() {
								return ""test3"";
						}
				};
				String[] result = ClassInfo.getData(m);
				assertEquals(3, result.length);
				assertEquals(""test"", result[0]);
				assertEquals(""test2"", result[1]);
				assertEquals(""test3"", result[2]);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with an array of four elements.
		*/
		@Test
		void testGetData_6() {
				Member[] m = new Member[4];
				m[0] = new Member() {
						public String toString() {
								return ""test"";
						}
				};
				m[1] = new Member() {
						public String toString() {
								return ""test2"";
						}
				};
				m[2] = new Member() {
						public String toString() {
								return ""test3"";
						}
				};
				m[3] = new Member() {
						public String toString() {
								return ""test4"";
						}
				};
				String[] result = ClassInfo.getData(m);
				assertEquals(4, result.length);
				assertEquals(""test"", result[0]);
				assertEquals(""test2"", result[1]);
				assertEquals(""test3"", result[2]);
				assertEquals(""test4"", result[3]);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with an array of five elements.
		*/
		@Test
		void testGetData_7() {
				Member[] m = new Member[5];
				m[0] = new Member() {
						public String toString() {
								return ""test"";
						}
				};
				m[1] = new Member() {
						public String toString() {
								return ""test2"";
						}
				};
				m[2] = new Member() {
						public String toString() {
								return ""test3"";
						}
				};
				m[3] = new Member() {
						public String toString() {
								return ""test4"";
						}
				};
				m[4] = new Member() {
						public String toString() {
								return ""test5"";
						}
				};
				String[] result = ClassInfo.getData(m);
				assertEquals(5, result.length);
				assertEquals(""test"", result[0]);
				assertEquals(""test2"", result[1]);
				assertEquals(""test3"", result[2]);
				assertEquals(""test4"", result[3]);
				assertEquals(""test5"", result[4]);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with an array of six elements.
		*/
		@Test
		void testGetData_8() {
				Member[] m = new Member[6];
				m[0] = new Member() {
						public String toString() {
								return ""test"";
						}
				};
				m[1] = new Member() {
						public String toString() {
							"
cmpl-6wSDW1PgleQQnutx0cfd5yLQeeKwc,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_6Test.java,62.7135968208313,length,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_6Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getData(Class[])} method.
*/
class ClassInfo_6Test {","// ClassInfo_6Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getData(Class[])} method.
*/
class ClassInfo_6Test {

		/**
		* Test case for {@link ClassInfo#getData(Class[])} method.
		* It tests the method with a null array.
		*/
		@Test
		void testGetData_1() {
				Class[] m = null;
				String[] result = ClassInfo.getData(m);
				assertNull(result);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Class[])} method.
		* It tests the method with an empty array.
		*/
		@Test
		void testGetData_2() {
				Class[] m = new Class[0];
				String[] result = ClassInfo.getData(m);
				assertNull(result);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Class[])} method.
		* It tests the method with an array of one element.
		*/
		@Test
		void testGetData_3() {
				Class[] m = new Class[1];
				m[0] = ClassInfo.class;
				String[] result = ClassInfo.getData(m);
				assertNotNull(result);
				assertEquals(1, result.length);
				assertEquals(""class com.jstevh.viewer.ClassInfo"", result[0]);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Class[])} method.
		* It tests the method with an array of two elements.
		*/
		@Test
		void testGetData_4() {
				Class[] m = new Class[2];
				m[0] = ClassInfo.class;
				m[1] = ClassInfo_6Test.class;
				String[] result = ClassInfo.getData(m);
				assertNotNull(result);
				assertEquals(2, result.length);
				assertEquals(""class com.jstevh.viewer.ClassInfo"", result[0]);
				assertEquals(""class com.jstevh.viewer.ClassInfo_6Test"", result[1]);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Class[])} method.
		* It tests the method with an array of three elements.
		*/
		@Test
		void testGetData_5() {
				Class[] m = new Class[3];
				m[0] = ClassInfo.class;
				m[1] = ClassInfo_6Test.class;
				m[2] = ClassInfo_6Test.class;
				String[] result = ClassInfo.getData(m);
				assertNotNull(result);
				assertEquals(3, result.length);
				assertEquals(""class com.jstevh.viewer.ClassInfo"", result[0]);
				assertEquals(""class com.jstevh.viewer.ClassInfo_6Test"", result[1]);
				assertEquals(""class com.jstevh.viewer.ClassInfo_6Test"", result[2]);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Class[])} method.
		* It tests the method with an array of four elements.
		*/
		@Test
		void testGetData_6() {
				Class[] m = new Class[4];
				m[0] = ClassInfo.class;
				m[1] = ClassInfo_6Test.class;
				m[2] = ClassInfo_6Test.class;
				m[3] = ClassInfo.class;
				String[] result = ClassInfo.getData(m);
				assertNotNull(result);
				assertEquals(4, result.length);
				assertEquals(""class com.jstevh.viewer.ClassInfo"", result[0]);
				assertEquals(""class com.jstevh.viewer.ClassInfo_6Test"", result[1]);
				assertEquals(""class com.jstevh.viewer.ClassInfo_6Test"", result[2]);
				assertEquals(""class com.jstevh.viewer.ClassInfo"", result[3]);
		}
}

// ClassInfo_7Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getData(Member[])} method.
*/
class ClassInfo_7Test {
		
		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with a null array.
		*/
		@Test
		void testGetData_1() {
				Member[] m = null;
				String[] result = ClassInfo.getData(m);
				assertNull(result);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with an empty array.
		*/
		@Test
		void testGetData_2() {
				Member[] m = new Member[0];
				String[] result = ClassInfo.getData(m);
				assertNull(result);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with an array of one element.
		*/
		@Test
		void testGetData_3() {
				Member[] m = new Member[1];
				m[0] = ClassInfo.class;
				String[] result = ClassInfo.getData(m);
				assertNotNull(result);
				assertEquals(1, result.length);
				assertEquals(""class com.jstevh.viewer.ClassInfo"", result[0]);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with an array of two elements.
		*/
		@Test
		void testGetData_4() {
				Member[] m = new Member[2];
				m[0] = ClassInfo.class;
				m[1] = ClassInfo_7Test.class;
				String[] result = ClassInfo.getData(m);
				assertNotNull(result);
				assertEquals(2, result.length);
				assertEquals(""class com.jstevh.viewer.ClassInfo"", result[0]);
				assertEquals(""class com.jstevh.viewer.ClassInfo_7Test"", result[1]);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Member["
cmpl-6wSEXOLZnMMaMYRYQaE7wKdOHUUSX,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_7Test.java,65.13782286643982,length,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_7Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#srchMethods(String)} method.
*/
class ClassInfo_7Test {","// ClassInfo_7Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#srchMethods(String)} method.
*/
class ClassInfo_7Test {

		private ClassInfo myClassInfo;
		
		private String[] cMethods;
		
		private String[] fndMethods;
		
		private String[] index;
		
		private String tempStr;
		
		private String[] tempArray;
		
		private String[] tempArray2;
		
		private String[] tempArray3;
		
		private String[] tempArray4;
		
		private String[] tempArray5;
		
		private String[] tempArray6;
		
		private String[] tempArray7;
		
		private String[] tempArray8;
		
		private String[] tempArray9;
		
		private String[] tempArray10;
		
		private String[] tempArray11;
		
		private String[] tempArray12;
		
		private String[] tempArray13;
		
		private String[] tempArray14;
		
		private String[] tempArray15;
		
		private String[] tempArray16;
		
		private String[] tempArray17;
		
		private String[] tempArray18;
		
		private String[] tempArray19;
		
		private String[] tempArray20;
		
		private String[] tempArray21;
		
		private String[] tempArray22;
		
		private String[] tempArray23;
		
		private String[] tempArray24;
		
		private String[] tempArray25;
		
		private String[] tempArray26;
		
		private String[] tempArray27;
		
		private String[] tempArray28;
		
		private String[] tempArray29;
		
		private String[] tempArray30;
		
		private String[] tempArray31;
		
		private String[] tempArray32;
		
		private String[] tempArray33;
		
		private String[] tempArray34;
		
		private String[] tempArray35;
		
		private String[] tempArray36;
		
		private String[] tempArray37;
		
		private String[] tempArray38;
		
		private String[] tempArray39;
		
		private String[] tempArray40;
		
		private String[] tempArray41;
		
		private String[] tempArray42;
		
		private String[] tempArray43;
		
		private String[] tempArray44;
		
		private String[] tempArray45;
		
		private String[] tempArray46;
		
		private String[] tempArray47;
		
		private String[] tempArray48;
		
		private String[] tempArray49;
		
		private String[] tempArray50;
		
		private String[] tempArray51;
		
		private String[] tempArray52;
		
		private String[] tempArray53;
		
		private String[] tempArray54;
		
		private String[] tempArray55;
		
		private String[] tempArray56;
		
		private String[] tempArray57;
		
		private String[] tempArray58;
		
		private String[] tempArray59;
		
		private String[] tempArray60;
		
		private String[] tempArray61;
		
		private String[] tempArray62;
		
		private String[] tempArray63;
		
		private String[] tempArray64;
		
		private String[] tempArray65;
		
		private String[] tempArray66;
		
		private String[] tempArray67;
		
		private String[] tempArray68;
		
		private String[] tempArray69;
		
		private String[] tempArray70;
		
		private String[] tempArray71;
		
		private String[] tempArray72;
		
		private String[] tempArray73;
		
		private String[] tempArray74;
		
		private String[] tempArray75;
		
		private String[] tempArray76;
		
		private String[] tempArray77;
		
		private String[] tempArray78;
		
		private String[] tempArray79;
		
		private String[] tempArray80;
		
		private String[] tempArray81;
		
		private String[] tempArray82;
		
		private String[] tempArray83;
		
		private String[] tempArray84;
		
		private String[] tempArray85;
		
		private String[] tempArray86;
		
		private String[] tempArray87;
		
		private String[] tempArray88;
		
		private String[] tempArray89;
		
		private String[] tempArray90;
		
		private String[] tempArray91;
		
		private String[] tempArray92;
		
		private String[] tempArray93;
		
		private String[] tempArray94;
		
		private String[] tempArray95;
		
		private String[] tempArray96;
		
		private String[] tempArray97;
		
		private String[] tempArray98;
		
		private String[] tempArray99;
		
		private String[] tempArray100;
		
		private String[] tempArray101;
		
		private String[] tempArray102;
		
		private String[] tempArray103;
		
		private String[] tempArray104;
		
		private String[] tempArray105;
		
		private String[] tempArray106;
		
		private String[] tempArray107;
		
		private String[] tempArray108;
		
		private String[] tempArray109;
		
		private String[] tempArray110;
		
		private String[] tempArray111;
		
		private String[] tempArray112;
		
		private String[] tempArray113;
		
		private String[] tempArray114;
		
		private String[] tempArray115;
		
		private String[] tempArray116;
		
		private String[] tempArray117;
		
		private String[] tempArray118;
		
		private String[] tempArray119;
		
		private String[] tempArray120;
		
		private String[] tempArray121;
		
		private String[] tempArray122;
		
		private String[] tempArray123;
		
		private String[] tempArray124;
		
		private String[] tempArray125;
		
		private String[] tempArray126;
		
		private String[] tempArray127;
		
		private String[] tempArray128;
		
		private String[] tempArray129;
		
		private String[] tempArray130;
		
		private String[] tempArray131;
		
		private String[] tempArray132;
		
		private String[] tempArray133;
		
		private String[] tempArray134;
		
		private String[] tempArray135;
		
		private String[] tempArray136;
		
		private String[] tempArray137;
		
		private String[] tempArray138;
		
		private String[] tempArray139;
		
		private String[] tempArray140;
		
		private String[] tempArray141;
		
		private String[] tempArray142;
		
		private String[] tempArray143;
		
		private String[] tempArray144;
		
		private String[] tempArray145;
		
		private String[] tempArray146;
		
		private String[] tempArray147;
		
		private String[] tempArray148;
		
		private String[] tempArray149;
		
		private"
cmpl-6wSFapcyxQHcvjNfdMATGzxYqUuQW,/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_9Test.java,65.40243315696716,length,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_9Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getFoundMethod(int)} method.
*/
class ClassInfo_9Test {","// ClassInfo_9Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getFoundMethod(int)} method.
*/
class ClassInfo_9Test {

		/**
		* Test case for {@link ClassInfo#getFoundMethod(int)} method.
		* <p>
		* This test case checks if the method returns null when the position is out of range.
		*/
		@Test
		void testGetFoundMethod_1() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				myClassInfo.srchMethods(""charAt"");
				assertNull(myClassInfo.getFoundMethod(3));
		}
		
		/**
		* Test case for {@link ClassInfo#getFoundMethod(int)} method.
		* <p>
		* This test case checks if the method returns null when the position is out of range.
		*/
		@Test
		void testGetFoundMethod_2() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				myClassInfo.srchMethods(""charAt"");
				assertNull(myClassInfo.getFoundMethod(-1));
		}
		
		/**
		* Test case for {@link ClassInfo#getFoundMethod(int)} method.
		* <p>
		* This test case checks if the method returns null when the position is out of range.
		*/
		@Test
		void testGetFoundMethod_3() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				myClassInfo.srchMethods(""charAt"");
				assertNull(myClassInfo.getFoundMethod(0));
		}
		
		/**
		* Test case for {@link ClassInfo#getFoundMethod(int)} method.
		* <p>
		* This test case checks if the method returns null when the position is out of range.
		*/
		@Test
		void testGetFoundMethod_4() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				myClassInfo.srchMethods(""charAt"");
				assertNull(myClassInfo.getFoundMethod(1));
		}
		
		/**
		* Test case for {@link ClassInfo#getFoundMethod(int)} method.
		* <p>
		* This test case checks if the method returns null when the position is out of range.
		*/
		@Test
		void testGetFoundMethod_5() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				myClassInfo.srchMethods(""charAt"");
				assertNull(myClassInfo.getFoundMethod(2));
		}
		
		/**
		* Test case for {@link ClassInfo#getFoundMethod(int)} method.
		* <p>
		* This test case checks if the method returns null when the position is out of range.
		*/
		@Test
		void testGetFoundMethod_6() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				myClassInfo.srchMethods(""charAt"");
				assertNull(myClassInfo.getFoundMethod(4));
		}
		
		/**
		* Test case for {@link ClassInfo#getFoundMethod(int)} method.
		* <p>
		* This test case checks if the method returns null when the position is out of range.
		*/
		@Test
		void testGetFoundMethod_7() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				myClassInfo.srchMethods(""charAt"");
				assertNull(myClassInfo.getFoundMethod(5));
		}
		
		/**
		* Test case for {@link ClassInfo#getFoundMethod(int)} method.
		* <p>
		* This test case checks if the method returns null when the position is out of range.
		*/
		@Test
		void testGetFoundMethod_8() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				myClassInfo.srchMethods(""charAt"");
				assertNull(myClassInfo.getFoundMethod(6));
		}
		
		/**
		* Test case for {@link ClassInfo#getFoundMethod(int)} method.
		* <p>
		* This test case checks if the method returns null when the position is out of range.
		*/
		@Test
		void testGetFoundMethod_9() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				myClassInfo.srchMethods(""charAt"");
				assertNull(myClassInfo.getFoundMethod(7));
		}
}

// ClassInfo_Test.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getFoundMethod(int)} method.
*/
class ClassInfo_Test {
		
		/**
		* Test case for {@link ClassInfo#getFoundMethod(int)} method.
		* <p>
		* This test case checks if the method returns null when the position is out of range.
		*/
		@Test
		void testGetFoundMethod_1() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				myClassInfo.srchMethods(""charAt"");
				assertNull(myClassInfo.getFoundMethod(3));
		}
		
		/**
		* Test case for {@link ClassInfo#getFoundMethod(int)} method.
		* <p>
		* This test case checks if the method returns null when the position is out of range.
		*/
		@Test
		void testGetFoundMethod_2() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				myClassInfo.srchMethods(""charAt"");
				assertNull(myClassInfo.getFoundMethod(-"
