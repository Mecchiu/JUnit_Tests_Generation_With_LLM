ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6wgTr8fu8Oy1rohNOiuF1DjfH67VE,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/qsadmin/QSAdminAPI_0Test.java,120.25080680847168,length,"// QSAdminAPI.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.qsadmin;

import java.io.*;
import java.net.*;
import java.util.logging.*;

/**
 *  QSAdminAPI class to communicate to QsAdmin from java applications.
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * 	QSAdminAPI qsAdminApi = new QSAdminAPI(""127.0.0.1"", 9080);
 * 	if(qsAdminApi.logon()) {
 * 		System.out.println(""Logged in"");
 * 		String info = qsAdminApi.sendCommand(""info server"");
 * 		System.out.println(""Info on Server :\n""+info);
 * 		qsAdminApi.logoff();
 * 	} else {
 * 		System.out.println(""Bad Login"");
 * 		qsAdminApi.close();
 * 	}
 * </pre></BLOCKQUOTE></code></p>
 *  @see QSAdminServer
 *  @since 1.4
 *  @author Akshathkumar Shetty
 */
public class QSAdminAPI {

    private static final Logger logger = Logger.getLogger(QSAdminAPI.class.getName());

    private String username = ""Admin"";

    private String password = ""QsAdm1n"";

    private String host = ""localhost"";

    private int port = 9877;

    private Socket socket;

    private InputStream in;

    private OutputStream out;

    private BufferedReader br;

    private BufferedWriter bw;

    /**
     * Creates QSAdminAPI object that will communicate with the
     * passed host and port.
     */
    public QSAdminAPI(String host, int port) {
        this.host = host;
        this.port = port;
    }

    /**
     * Will attempt to connect and logon to the remote QsAdminServer.
     */
    public boolean logon() throws IOException {
        return logon(username, password);
    }

    /**
     * Will attempt to connect and logon to the remote QsAdminServer.
     */
    public boolean logon(String username, String password) throws IOException {
        this.username = username;
        this.password = password;
        logger.fine(""Connecting to "" + host + "":"" + port);
        socket = new Socket(host, port);
        in = socket.getInputStream();
        out = socket.getOutputStream();
        br = new BufferedReader(new InputStreamReader(in, ""UTF-8""));
        bw = new BufferedWriter(new OutputStreamWriter(out, ""UTF-8""));
        logger.fine(""Got : "" + br.readLine());
        logger.fine(""Got : "" + br.readLine());
        logger.fine(""Got : "" + br.readLine());
        logger.fine(""Got : "" + br.readLine());
        logger.fine(""Sending username"");
        bw.write(username + ""\r\n"");
        bw.flush();
        logger.fine(""Got : "" + br.readLine());
        logger.fine(""Sending password"");
        bw.write(password + ""\r\n"");
        bw.flush();
        String temp = br.readLine();
        logger.fine(""Got : "" + temp);
        return temp.startsWith(""+OK "");
    }

    /**
     * Sends the given command to QSAdmin and gives the response back.
     */
    public String sendCommand(String data) throws IOException {
        logger.fine(""Sending command : "" + data);
        bw.write(data + ""\r\n"");
        bw.flush();
        String temp = readResponse();
        logger.fine(""Got : "" + temp);
        return temp;
    }

    private String readResponse() throws IOException {
        StringBuilder command = new StringBuilder();
        String res = br.readLine();
        if (res != null && res.equals(""+OK info follows"") == false)
            return res;
        while (res != null && res.equals(""."") == false) {
            command.append(res + ""\r\n"");
            res = br.readLine();
        }
        return command.toString();
    }

    /**
     * Logoff the QSAdminServer and closed the socket associated.
     */
    public void logoff() throws IOException {
        logger.fine(""Logging off"");
        logger.fine(""Sending command : quit"");
        bw.write(""quit"" + ""\r\n"");
        bw.flush();
        logger.fine(""Got : "" + br.readLine());
        close();
    }

    /**
     * Closes the socket associated.
     */
    public void close() throws IOException {
        logger.fine(""Closing"");
        socket.close();
        socket = null;
    }

    public static void main(String[] args) throws Exception {
        QSAdminAPI qsAdminApi = new QSAdminAPI(""127.0.0.1"", 9080);
        if (qsAdminApi.logon()) {
            logger.info(""Logged in"");
            String info = qsAdminApi.sendCommand(""info server"");
            logger.info(""Info on Server :\n"" + info);
            qsAdminApi.logoff();
        } else {
            logger.warning(""Bad Login!"");
            qsAdminApi.close();
        }
    }
}
","// QSAdminAPI_0Test.java
package org.quickserver.net.qsadmin;

import java.io.*;
import java.net.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QSAdminAPI}.
* It contains ten unit test cases for the {@link QSAdminAPI#logon()} method.
*/
class QSAdminAPI_0Test {","// QSAdminAPI_0Test.java
package org.quickserver.net.qsadmin;

import java.io.*;
import java.net.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QSAdminAPI}.
* It contains ten unit test cases for the {@link QSAdminAPI#logon()} method.
*/
class QSAdminAPI_0Test {

	private static final Logger logger = Logger.getLogger(QSAdminAPI_0Test.class.getName());
	
	private static final String host = ""127.0.0.1"";
	private static final int port = 9080;
	private static final String username = ""Admin"";
	private static final String password = ""QsAdm1n"";
	
	private static final String[] commands = {
		""info server"",
		""info clients"",
		""info clients all"",
		""info clients all detail"",
		""info clients all detail xml"",
		""info clients all detail xml"",
		""info clients all detail xml"",
		""info clients all detail xml"",
		""info clients all detail xml"",
		""info clients all detail xml""
	};
	
	private static final String[] responses = {
		""+OK info follows\r\n"" +
		""Server Name: QuickServer\r\n"" +
		""Server Version: 1.4.5\r\n"" +
		""Server Build: 201502211500\r\n"" +
		""Server Started: Thu Feb 26 16:00:00 IST 2015\r\n"" +
		""Server Uptime: 0 days, 0 hours, 0 minutes, 0 seconds\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info: QuickServer is a Java based server designed to provide a quick and easy way to set up a TCP server.\r\n"" +
		""Server Info:"
6dcf04fb-3db8-480a-a166-0bf0fad91c92,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 37496 tokens (33496 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_0Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getVersion()} method.
*/
class QuickServer_0Test {","// QuickServer_0Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getVersion()} method.
*/
class QuickServer_0Test {
"
6b84cd5d-be7f-4b0d-8dd1-183560df959a,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_10Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 37495 tokens (33495 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_10Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#info()} method.
*/
class QuickServer_10Test {","// QuickServer_10Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#info()} method.
*/
class QuickServer_10Test {
"
e461370c-b57b-4b76-8041-ab8ab7f56c27,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_13Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 37497 tokens (33497 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_13Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#findAllClient()} method.
*/
class QuickServer_13Test {","// QuickServer_13Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#findAllClient()} method.
*/
class QuickServer_13Test {
"
7d844c50-d889-4a1b-9c06-ea77bf04b455,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_18Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 37498 tokens (33498 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_18Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getSSLContext(String)} method.
*/
class QuickServer_18Test {","// QuickServer_18Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getSSLContext(String)} method.
*/
class QuickServer_18Test {
"
f2dc480a-dc4d-4d96-969b-d894731336c3,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_19Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 37500 tokens (33500 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_19Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getSSLSocketFactory(String)} method.
*/
class QuickServer_19Test {","// QuickServer_19Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getSSLSocketFactory(String)} method.
*/
class QuickServer_19Test {
"
56c5173b-0949-4f36-bea8-098e3181118e,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 37497 tokens (33497 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_1Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getVersionNo()} method.
*/
class QuickServer_1Test {","// QuickServer_1Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getVersionNo()} method.
*/
class QuickServer_1Test {
"
e847cb2c-16f3-41fc-9f2d-fbe8d4979bcd,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_22Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 37497 tokens (33497 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_22Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getPID()} method.
*/
class QuickServer_22Test {","// QuickServer_22Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getPID()} method.
*/
class QuickServer_22Test {
"
a8cf4f89-a1c0-4a89-b1df-00a78bc50541,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_3Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 37497 tokens (33497 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_3Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getNewLine()} method.
*/
class QuickServer_3Test {","// QuickServer_3Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#getNewLine()} method.
*/
class QuickServer_3Test {
"
cfef2917-01f0-4824-9e34-0cf41137a03b,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_4Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 37499 tokens (33499 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_4Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#initService(Object[])} method.
*/
class QuickServer_4Test {","// QuickServer_4Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#initService(Object[])} method.
*/
class QuickServer_4Test {
"
ab76c7e9-db92-4c9e-96ce-6541a0abc41a,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_5Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 37499 tokens (33499 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_5Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#initService(QuickServerConfig)} method.
*/
class QuickServer_5Test {","// QuickServer_5Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#initService(QuickServerConfig)} method.
*/
class QuickServer_5Test {
"
331ec960-2f89-4191-813b-d96695d5cccf,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_6Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 37496 tokens (33496 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_6Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#startService()} method.
*/
class QuickServer_6Test {","// QuickServer_6Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#startService()} method.
*/
class QuickServer_6Test {
"
63db9318-970d-4567-b3dc-84007b75b728,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_7Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 37496 tokens (33496 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_7Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#stopService()} method.
*/
class QuickServer_7Test {","// QuickServer_7Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#stopService()} method.
*/
class QuickServer_7Test {
"
4e5c0de2-5d18-4bda-af7a-ad1c6dd3cd6c,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_8Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 37497 tokens (33497 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_8Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#suspendService()} method.
*/
class QuickServer_8Test {","// QuickServer_8Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#suspendService()} method.
*/
class QuickServer_8Test {
"
1237eb43-061f-45a4-9ee9-71afe1c5b7f2,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_9Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 37497 tokens (33497 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// QuickServer.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;

/**
 *  Main class of QuickServer library. This class is used to create
 *  multi client servers quickly.
 *  <p>
 *  Ones a client is connected, it creates {@link ClientHandler} object,
 *  which is run using any thread available from the pool of threads
 *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which
 *  handles the client. <br/>
 *  QuickServer divides the application logic of its developer over eight
 *  class, <br>
 *  	<ul>
 * 		<li>ClientEventHandler<br>
 *  		   &nbsp;Handles client events [Optional Class].
 *  		<li>ClientCommandHandler [#]<br>
 *  		   &nbsp;Handles client character/string commands.
 *  		<li>ClientObjectHandler [#]<br>
 *  		   &nbsp;Handles client interaction - Object commands.
 * 		<li>ClientBinaryHandler [#]<br>
 *  		   &nbsp;Handles client interaction - binary data.
 * 		<li>ClientWriteHandler [Optional Class]<br>
 *  		   &nbsp;Handles client interaction - writing data (Only used in non-blocking mode).
 *  		<li>ClientAuthenticationHandler [Optional Class]<br>
 *  			&nbsp;Used to Authencatet a client.
 *  		<li>ClientData [Optional Class]<br>
 *  			&nbsp;Client data carrier (support class)
 * 		<li>ClientExtendedEventHandler [Optional Class]<br>
 *  		   &nbsp;Handles extended client events.
 *  	</ul>
 *
 *  [#] = Any one of these have to be set based on default DataMode for input.
 *  The default DataMode for input is String so if not changes you will
 *  have to set ClientCommandHandler.
 *  </p>
 *  <p>
 *   Eg:
 *  <code><BLOCKQUOTE><pre>
 * package echoserver;
 *
 * import org.quickserver.net.*;
 * import org.quickserver.net.server.*;
 *
 * import java.io.*;
 *
 * public class EchoServer {
 * 	public static void main(String args[])	{
 * 		String cmdHandle = ""echoserver.EchoCommandHandler"";
 *
 * 		QuickServer myServer = new QuickServer();
 * 		myServer.setClientCommandHandler(cmdHandle);
 * 		myServer.setPort(4123);
 * 		myServer.setName(Echo Server v1.0"");
 * 		try {
 * 			myServer.startServer();
 * 		} catch(AppException e) {
 * 			System.err.println(""Error in server : ""+e);
 * 			e.printStackTrace();
 * 		}
 * 	}
 * }
 * </pre></BLOCKQUOTE></code></p>
 *
 *  @version 1.4.8
 *  @author Akshathkumar Shetty
 */
public class QuickServer implements Runnable, Service, Cloneable, Serializable {

    //Some variable are not initialised to any value because the
    //default java value was desired initial value.
    //'dev ' = development build not yet final
    //'beta' = test build all features
    //change also in QSAdminMain
    private final static String VER = ""2.0.0 RC1"";

    private final static String NEW_LINE;

    private final static String pid;

    static {
        if (System.getProperty(""org.quickserver.useOSLineSeparator"") != null && System.getProperty(""org.quickserver.useOSLineSeparator"").equals(""true"")) {
            NEW_LINE = System.getProperty(""line.separator"");
        } else {
            NEW_LINE = ""\r\n"";
        }
        String _pid = ManagementFactory.getRuntimeMXBean().getName();
        int i = _pid.indexOf(""@"");
        pid = _pid.substring(0, i);
        System.out.print(""Loading QuickServer v"" + getVersion() + "" [PID:"" + pid + ""]"");
    }

    private String serverBanner;

    //v1.4.6
    private String clientAuthenticationHandlerString;

    //v1.4.6
    private String clientEventHandlerString;

    //v1.4.6
    private String clientExtendedEventHandlerString;

    private String clientCommandHandlerString;

    //v1.2
    private String clientObjectHandlerString;

    //v1.4
    private String clientBinaryHandlerString;

    //v1.4.5
    private String clientWriteHandlerString;

    private String clientDataString;

    private Authenticator authenticator;

    //v1.4.6
    private ClientAuthenticationHandler clientAuthenticationHandler;

    //v1.4.6
    private ClientEventHandler clientEventHandler;

    //v1.4.6
    private ClientExtendedEventHandler clientExtendedEventHandler;

    private ClientCommandHandler clientCommandHandler;

    //v1.2
    private ClientObjectHandler clientObjectHandler;

    //v1.4
    private ClientBinaryHandler clientBinaryHandler;

    //v1.4.5
    private ClientWriteHandler clientWriteHandler;

    private ClientData clientData;

    protected Class clientDataClass;

    private int serverPort = 9876;

    //Main thread
    private Thread t;

    private ServerSocket server;

    private String serverName = ""QuickServer"";

    private long maxConnection = -1;

    //1 min socket timeout
    private int socketTimeout = 60 * 1000;

    private String maxConnectionMsg = ""-ERR Server Busy. Max Connection Reached"";

    private String timeoutMsg = ""-ERR Timeout"";

    private String maxAuthTryMsg = ""-ERR Max Auth Try Reached"";

    //v1.2
    private int maxAuthTry = 5;

    static {
        System.out.print(""."");
    }

    //--v1.1
    private InetAddress ipAddr;

    private boolean stopServer;

    private Object[] storeObjects;

    private QSAdminServer adminServer;

    //--v1.2
    //Logger for QuickServer
    private static final Logger logger = Logger.getLogger(QuickServer.class.getName());

    //Logger for the application using this QuickServer
    private Logger appLogger;

    //for Service interface
    //backup
    private long suspendMaxConnection;

    //backup
    private String suspendMaxConnectionMsg;

    private int serviceState = Service.UNKNOWN;

    static {
        System.out.print(""."");
    }

    //--v1.3
    private QuickServerConfig config = new QuickServerConfig();

    private String consoleLoggingformatter;

    private String consoleLoggingLevel = ""INFO"";

    private ClientPool pool;

    private ObjectPool clientHandlerPool;

    private ObjectPool clientDataPool;

    private DBPoolUtil dBPoolUtil;

    //--v1.3.1
    private String loggingLevel = ""INFO"";

    //--v1.3.2
    private boolean skipValidation = false;

    private boolean communicationLogging = true;

    //--v1.3.3
    private String securityManagerClass;

    private AccessConstraintConfig accessConstraintConfig;

    private ClassLoader classLoader;

    private String applicationJarPath;

    private ServerHooks serverHooks;

    private ArrayList listOfServerHooks;

    static {
        System.out.print(""."");
    }

    //--v1.4.0
    private Secure secure;

    private BasicServerConfig basicConfig = config;

    private SSLContext sslc;

    private KeyManager[] km = null;

    private TrustManager[] tm = null;

    private boolean runningSecure = false;

    private SecureStoreManager secureStoreManager = null;

    private Exception exceptionInRun = null;

    //--v1.4.5
    private ServerSocketChannel serverSocketChannel;

    private Selector selector;

    private boolean blockingMode = true;

    private ObjectPool byteBufferPool;

    private java.util.Date lastStartTime;

    private ClientIdentifier clientIdentifier;

    private GhostSocketReaper ghostSocketReaper;

    private PoolManager poolManager;

    private QSObjectPoolMaker qsObjectPoolMaker;

    //--v1.4.6
    private DataMode defaultDataModeIN = DataMode.STRING;

    private DataMode defaultDataModeOUT = DataMode.STRING;

    //-v1.4.7
    private Throwable serviceError;

    private Map registerChannelRequestMap;

    //v-1.4.8
    private boolean rawCommunicationLogging = false;

    private int rawCommunicationMaxLength = 100;

    static {
        System.out.println("" Done"");
        //should be commented if not a patch release
        //System.out.println(""[Includes patch(#): t=152&p=532]"");
        //should be commented if not a dev release
        //System.out.println(""[Dev Build Date: Saturday, October 29, 2005]"");
        logger.log(Level.FINE, ""PID: {0}"", pid);
    }

    /**
     * Returns the version of the library.
     */
    public static final String getVersion() {
        return VER;
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.2
     */
    public static final float getVersionNo() {
        return getVersionNo(VER);
    }

    /**
     * Returns the numerical version of the library.
     * @since 1.4.5
     */
    public static final float getVersionNo(String ver) {
        //String ver = getVersion();
        float version = 0;
        //check if beta
        int i = ver.indexOf("" "");
        if (i == -1)
            i = ver.length();
        ver = ver.substring(0, i);
        //check for sub version
        i = ver.indexOf(""."");
        if (i != -1) {
            int j = ver.indexOf(""."", i);
            if (j != -1) {
                ver = ver.substring(0, i) + ""."" + MyString.replaceAll(ver.substring(i + 1), ""."", """");
            }
        }
        try {
            version = Float.parseFloat(ver);
        } catch (NumberFormatException e) {
            throw new RuntimeException(""Corrupt QuickServer"");
        }
        return version;
    }

    /**
     * Returns the new line string used by QuickServer.
     * @since 1.2
     */
    public static String getNewLine() {
        return NEW_LINE;
    }

    /**
     * Returns the Server name : port of the QuickServer.
     */
    public String toString() {
        return serverName + "" : "" + getPort();
    }

    /**
     * Creates a new server without any configuration.
     * Make sure you configure the QuickServer, before
     * calling startServer()
     * @see org.quickserver.net.server.ClientEventHandler
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientObjectHandler
     * @see org.quickserver.net.server.ClientBinaryHandler
     * @see org.quickserver.net.server.ClientWriteHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #configQuickServer
     * @see #initService
     * @see #setPort
     * @see #setClientCommandHandler
     * @since 1.2
     */
    public QuickServer() {
    }

    /**
     * Creates a new server with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     * @param commandHandler the fully qualified name of the
     *  desired class that implements {@link ClientCommandHandler}
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     * @see #setPort
     */
    public QuickServer(String commandHandler) {
        setClientCommandHandler(commandHandler);
    }

    /**
     * Creates a new server at <code>port</code> with the specified
     * <code>commandHandler</code> has it {@link ClientCommandHandler}.
     *
     * @param commandHandler fully qualified name of the class that
     * implements {@link ClientCommandHandler}
     * @param port to listen on.
     *
     * @see org.quickserver.net.server.ClientCommandHandler
     * @see org.quickserver.net.server.ClientAuthenticationHandler
     * @see org.quickserver.net.server.ClientHandler
     */
    public QuickServer(String commandHandler, int port) {
        //send to another constructor
        this(commandHandler);
        setPort(port);
    }

    /**
     * Starts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @see #startService
     */
    public void startServer() throws AppException {
        logger.log(Level.FINE, ""Starting {0}"", getName());
        if (isClosed() == false) {
            logger.log(Level.WARNING, ""Server {0} already running."", getName());
            throw new AppException(""Server "" + getName() + "" already running."");
        }
        blockingMode = getBasicConfig().getServerMode().getBlocking();
        if (getSecure().isEnable() && blockingMode == false) {
            //TODO we need to fix this..
            logger.warning(""QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode."");
            blockingMode = true;
            getBasicConfig().getServerMode().setBlocking(blockingMode);
        }
        if (serverBanner == null) {
            serverBanner = ""\n-------------------------------"" + ""\n Name : "" + getName() + ""\n Port : "" + getPort() + ""\n-------------------------------\n"";
            logger.finest(""Default Server Banner Generated"");
        }
        try {
            loadApplicationClasses();
            //load class from Advanced Settings
            Class clientIdentifierClass = getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);
            clientIdentifier = (ClientIdentifier) clientIdentifierClass.newInstance();
            clientIdentifier.setQuickServer(QuickServer.this);
            //load class from ObjectPoolConfig
            Class poolManagerClass = getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);
            poolManager = (PoolManager) poolManagerClass.newInstance();
            //load class QSObjectPoolMaker
            Class qsObjectPoolMakerClass = getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);
            qsObjectPoolMaker = (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();
            loadServerHooksClasses();
            processServerHooks(ServerHook.PRE_STARTUP);
            if (getSecure().isLoad() == true)
                //v1.4.0
                loadSSLContext();
            loadBusinessLogic();
        } catch (ClassNotFoundException e) {
            logger.log(Level.SEVERE, ""Could not load class/s: "" + e, e);
            throw new AppException(""Could not load class/s : "" + e);
        } catch (InstantiationException e) {
            logger.log(Level.SEVERE, ""Could not instantiate class/s: "" + e, e);
            throw new AppException(""Could not instantiate class/s: "" + e);
        } catch (IllegalAccessException e) {
            logger.log(Level.SEVERE, ""Illegal access to class/s: "" + e, e);
            throw new AppException(""Illegal access to class/s: "" + e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, ""IOException: "" + e, e);
            throw new AppException(""IOException: "" + e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Exception: "" + e, e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Exception : "" + e);
        }
        //v1.3.3
        if (getSecurityManagerClass() != null) {
            System.setSecurityManager(getSecurityManager());
        }
        setServiceState(Service.INIT);
        t = new Thread(this, ""QuickServer - "" + getName());
        t.start();
        do {
            Thread.yield();
        } while (getServiceState() == Service.INIT);
        if (getServiceState() != Service.RUNNING) {
            if (exceptionInRun != null)
                throw new AppException(""Could not start server "" + getName() + ""! Details: "" + exceptionInRun);
            else
                throw new AppException(""Could not start server "" + getName());
        }
        lastStartTime = new java.util.Date();
        logger.log(Level.FINE, ""Started {0}, Date: {1}"", new Object[] { getName(), lastStartTime });
    }

    /**
     * Stops the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server
     * @since 1.1
     * @see #stopService
     */
    public void stopServer() throws AppException {
        processServerHooks(ServerHook.PRE_SHUTDOWN);
        logger.log(Level.WARNING, ""Stopping {0}"", getName());
        stopServer = true;
        Socket death = null;
        if (isClosed() == true) {
            logger.log(Level.WARNING, ""Server {0} is not running!"", getName());
            throw new AppException(""Server "" + getName() + "" is not running!"");
        }
        try {
            if (getBlockingMode() == true) {
                if (getSecure().isEnable() == false) {
                    death = new Socket(server.getInetAddress(), server.getLocalPort());
                    death.getInputStream().read();
                    death.close();
                } else {
                    death = getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());
                    Thread.sleep(100);
                    death.close();
                }
            }
            if (serverSocketChannel != null) {
                serverSocketChannel.close();
            }
        } catch (IOException e) {
            logger.log(Level.FINE, ""IOError stopping {0}: {1}"", new Object[] { getName(), e });
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error stopping {0}: {1}"", new Object[] { getName(), e });
            throw new AppException(""Error in stopServer "" + getName() + "": "" + e);
        }
        for (int i = 0; getServiceState() != Service.STOPPED; i++) {
            try {
                Thread.sleep(60);
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error waiting for {0} to fully stop. Error: {1}"", new Object[] { getName(), e });
            }
            if (i > 1000) {
                logger.severe(""Server was not stopped even after 10sec.. will terminate now."");
                System.exit(-1);
            }
        }
        if (adminServer == null || getQSAdminServer().getServer() != this) {
            //so this is not qsadmin
            setClassLoader(null);
        }
        logger.log(Level.INFO, ""Stopped {0}"", getName());
    }

    /**
     * Restarts the QuickServer.
     *
     * @exception org.quickserver.net.AppException
     *  if could not stop server or if it could not start the server.
     * @since 1.2
     */
    public void restartServer() throws AppException {
        stopServer();
        startServer();
    }

    /**
     * Returns the name of the QuickServer. Default is 'QuickServer'.
     * @see #setName
     */
    public String getName() {
        return serverName;
    }

    /**
     * Sets the name for the QuickServer
     * @param name for the QuickServer
     * @see #getName
     */
    public void setName(String name) {
        serverName = name;
        logger.log(Level.FINEST, ""Set to : {0}"", name);
    }

    /**
     * Returns the Server Banner of the QuickServer
     * @see #setServerBanner
     */
    public String getServerBanner() {
        return serverBanner;
    }

    /**
     * Sets the serverBanner for the QuickServer
     * that will be displayed on the standard output [console]
     * when server starts. <br>&nbsp;<br>
     * To set welcome message to your client
     * {@link ClientEventHandler#gotConnected}
     * @param banner for the QuickServer
     * @see #getServerBanner
     */
    public void setServerBanner(String banner) {
        serverBanner = banner;
        logger.log(Level.FINEST, ""Set to : {0}"", banner);
    }

    /**
     * Sets the port for the QuickServer to listen on.
     * If not set, it will run on Port 9876
     * @param port to listen on.
     * @see #getPort
     */
    public void setPort(int port) {
        if (port < 0) {
            throw new IllegalArgumentException(""Port number can not be less than 0!"");
        }
        serverPort = port;
        logger.log(Level.FINEST, ""Set to {0}"", port);
    }

    /**
     * Returns the port for the QuickServer.
     * @see #setPort
     */
    public int getPort() {
        if (isClosed() == false) {
            return server.getLocalPort();
        }
        if (getSecure().isEnable() == false) {
            return serverPort;
        } else {
            int _port = getSecure().getPort();
            if (_port == -1)
                return serverPort;
            else
                return _port;
        }
    }

    /**
     * Sets the ClientCommandHandler class that interacts with
     * client sockets.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientCommandHandler}
     * @see #getClientCommandHandler
     */
    public void setClientCommandHandler(String handler) {
        clientCommandHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientCommandHandler class that interacts with
     * client sockets.
     * @see #setClientCommandHandler
     * @since 1.1
     */
    public String getClientCommandHandler() {
        return clientCommandHandlerString;
    }

    /**
     * Sets the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link ClientAuthenticationHandler}.
     * @see #getClientAuthenticationHandler
     * @since 1.4.6
     */
    public void setClientAuthenticationHandler(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the ClientAuthenticationHandler class that
     * handles the authentication of a client.
     * @see #setClientAuthenticationHandler
     * @since 1.4.6
     */
    public String getClientAuthenticationHandler() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the Authenticator class that
     * handles the authentication of a client.
     * @param authenticator the fully qualified name of the class
     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.
     * @see #getAuthenticator
     * @deprecated since 1.4.6 use setClientAuthenticationHandler
     * @since 1.3
     */
    public void setAuthenticator(String authenticator) {
        clientAuthenticationHandlerString = authenticator;
        logger.log(Level.FINEST, ""Set to {0}"", authenticator);
    }

    /**
     * Returns the Authenticator class that
     * handles the authentication of a client.
     * @see #setAuthenticator
     * @deprecated since 1.4.6 use getClientAuthenticationHandler
     * @since 1.3
     */
    public String getAuthenticator() {
        return clientAuthenticationHandlerString;
    }

    /**
     * Sets the ClientData class that carries client data.
     * @param data the fully qualified name of the class that
     * extends {@link ClientData}.
     * @see #getClientData
     */
    public void setClientData(String data) {
        this.clientDataString = data;
        logger.log(Level.FINEST, ""Set to {0}"", data);
    }

    /**
     * Returns the ClientData class string that carries client data
     * @return the fully qualified name of the class that
     * implements {@link ClientData}.
     * @see #setClientData
     */
    public String getClientData() {
        return clientDataString;
    }

    /**
     * Sets the client socket's timeout.
     * @param time client socket timeout in milliseconds.
     * @see #getTimeout
     */
    public void setTimeout(int time) {
        if (time > 0)
            socketTimeout = time;
        else
            socketTimeout = 0;
        logger.log(Level.FINEST, ""Set to {0}"", socketTimeout);
    }

    /**
     * Returns the Client socket timeout in milliseconds.
     * @see #setTimeout
     */
    public int getTimeout() {
        return socketTimeout;
    }

    /**
     * Sets max allowed login attempts.
     * @since 1.2
     * @see #getMaxAuthTry
     */
    public void setMaxAuthTry(int authTry) {
        maxAuthTry = authTry;
        logger.log(Level.FINEST, ""Set to {0}"", authTry);
    }

    /**
     * Returns max allowed login attempts. Default is <code>5</code>.
     * @since 1.2
     * @see #setMaxAuthTry
     */
    public int getMaxAuthTry() {
        return maxAuthTry;
    }

    /**
     * Sets message to be displayed when maximum allowed login
     * attempts has reached.
     * Default is : -ERR Max Auth Try Reached
     * @see #getMaxAuthTryMsg
     */
    public void setMaxAuthTryMsg(String msg) {
        maxAuthTryMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns message to be displayed when maximum allowed login
     * attempts has reached.
     * @see #getMaxAuthTryMsg
     */
    public String getMaxAuthTryMsg() {
        return maxAuthTryMsg;
    }

    /**
     * Sets timeout message.
     * Default is : -ERR Timeout
     * @see #getTimeoutMsg
     */
    public void setTimeoutMsg(String msg) {
        timeoutMsg = msg;
        logger.log(Level.FINEST, ""Set to {0}"", msg);
    }

    /**
     * Returns timeout message.
     * @see #setTimeoutMsg
     */
    public String getTimeoutMsg() {
        return timeoutMsg;
    }

    private TheClient initTheClient() {
        TheClient theClient = new TheClient();
        theClient.setServer(QuickServer.this);
        theClient.setTimeoutMsg(getTimeoutMsg());
        //v1.2
        theClient.setMaxAuthTry(getMaxAuthTry());
        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());
        theClient.setClientEventHandler(clientEventHandler);
        //v1.4.6
        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);
        theClient.setClientCommandHandler(clientCommandHandler);
        //v1.2
        theClient.setClientObjectHandler(clientObjectHandler);
        //v1.4
        theClient.setClientBinaryHandler(clientBinaryHandler);
        //v1.4.5
        theClient.setClientWriteHandler(clientWriteHandler);
        //v1.3
        theClient.setAuthenticator(authenticator);
        //v1.4.6
        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);
        theClient.setTimeout(socketTimeout);
        theClient.setMaxConnectionMsg(maxConnectionMsg);
        //v1.3.2
        theClient.setCommunicationLogging(getCommunicationLogging());
        return theClient;
    }

    public void run() {
        exceptionInRun = null;
        TheClient theClient = initTheClient();
        try {
            stopServer = false;
            closeAllPools();
            initAllPools();
            makeServerSocket();
            //print banner
            System.out.println(serverBanner);
            //v1.2
            setServiceState(Service.RUNNING);
            //v1.3.3
            processServerHooks(ServerHook.POST_STARTUP);
            if (getBlockingMode() == false) {
                runNonBlocking(theClient);
                if (stopServer == true) {
                    logger.log(Level.FINEST, ""Closing selector for {0}"", getName());
                    selector.close();
                }
                return;
            } else {
                runBlocking(theClient);
            }
        } catch (BindException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""{0} BindException for Port {1} @ {2} : {3}"", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });
        } catch (javax.net.ssl.SSLException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""SSLException {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (IOException e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""IOError {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } catch (Exception e) {
            exceptionInRun = e;
            logger.log(Level.SEVERE, ""Error {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
        } finally {
            if (getBlockingMode() == true) {
                logger.log(Level.WARNING, ""Closing {0}"", getName());
                try {
                    if (isClosed() == false) {
                        server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            } else if (getBlockingMode() == false && exceptionInRun != null) {
                logger.log(Level.WARNING, ""Closing {0} - Had Error: {1}"", new Object[] { getName(), exceptionInRun });
                try {
                    if (isClosed() == false) {
                        if (serverSocketChannel != null)
                            serverSocketChannel.close();
                        if (server != null)
                            server.close();
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.log(Level.WARNING, ""Closed {0}"", getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
        }
    }

    //end of run
    /**
     * Sets the maximum number of client connection allowed.
     * @since 1.1
     * @see #getMaxConnection
     */
    public void setMaxConnection(long maxConnection) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnection = maxConnection;
        else
            this.maxConnection = maxConnection;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnection);
    }

    /**
     * Returns the maximum number of client connection allowed.
     * @since 1.1
     * @see #setMaxConnection
     */
    public long getMaxConnection() {
        return maxConnection;
    }

    /**
     * Returns number of clients connected.
     * @since 1.1
     */
    public long getClientCount() {
        if (clientHandlerPool != null) {
            try {
                return getClientHandlerPool().getNumActive();
            } catch (Exception e) {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Sets the message to be sent to any new client connected after
     * maximum client connection has reached.
     * Default is : <code>-ERR Server Busy. Max Connection Reached</code>
     * @since 1.1
     * @see #getMaxConnectionMsg
     */
    public void setMaxConnectionMsg(String maxConnectionMsg) {
        if (getServiceState() == Service.SUSPENDED)
            suspendMaxConnectionMsg = maxConnectionMsg;
        else
            this.maxConnectionMsg = maxConnectionMsg;
        logger.log(Level.FINEST, ""Set to {0}"", maxConnectionMsg);
    }

    /**
     * Returns the message to be sent to any new client connected
     * after maximum client connection has reached.
     * @since 1.1
     * @see #setMaxConnectionMsg
     */
    public String getMaxConnectionMsg() {
        return maxConnectionMsg;
    }

    /**
     * Sets the Ip address to bind to.
     * @param bindAddr argument can be used on a multi-homed host for a
     * QuickServer that will only accept connect requests to one
     * of its addresses. If not set, it will default accepting
     * connections on any/all local addresses.
     * @exception java.net.UnknownHostException if no IP address for
     * the host could be found
     * @since 1.1
     * @see #getBindAddr
     */
    public void setBindAddr(String bindAddr) throws UnknownHostException {
        ipAddr = InetAddress.getByName(bindAddr);
        logger.log(Level.FINEST, ""Set to {0}"", bindAddr);
    }

    /**
     * Returns the IP address binding to.
     * @since 1.1
     * @see #setBindAddr
     */
    public InetAddress getBindAddr() {
        if (ipAddr == null) {
            try {
                ipAddr = InetAddress.getByName(""0.0.0.0"");
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Unable to create default ip(0.0.0.0) : {0}"", e);
                throw new RuntimeException(""Error: Unable to find servers own ip : "" + e);
            }
        }
        return ipAddr;
    }

    /**
     * Sets the store of objects to QuickServer, it is an array of objects
     * that main program or the class that created QuickServer passes to
     * the QuickServer.
     * @param storeObjects array of objects
     * @see #getStoreObjects
     * @since 1.1
     */
    public void setStoreObjects(Object[] storeObjects) {
        this.storeObjects = storeObjects;
    }

    /**
     * Returns store of objects from QuickServer, if nothing was set will
     * return <code>null</code>.
     * @see #setStoreObjects
     * @since 1.1
     */
    public Object[] getStoreObjects() {
        return storeObjects;
    }

    /**
     * Set the port to run QSAdminServer on.
     * @since 1.2
     */
    public void setQSAdminServerPort(int port) {
        getQSAdminServer().getServer().setPort(port);
    }

    /**
     * Returns the port to run QSAdminServer on.
     * @since 1.2
     */
    public int getQSAdminServerPort() {
        return getQSAdminServer().getServer().getPort();
    }

    /**
     * Set the ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public void setQSAdminServerAuthenticator(String authenticator) {
        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);
    }

    /**
     * Returns the Authenticator or ClientAuthenticationHandler class of
     * QSAdminServer that handles the authentication of a client.
     * @since 1.2
     */
    public String getQSAdminServerAuthenticator() {
        return getQSAdminServer().getServer().getAuthenticator();
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @param authenticator sets the ClientAuthenticationHandler class that
     *   handles the authentication of a client,
     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.
     * @param port to run QSAdminServer on
     * @exception org.quickserver.net.AppException
     *  if Server already running or if it could not load the classes
     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].
     * @since 1.1
     */
    public void startQSAdminServer(int port, String authenticator) throws AppException {
        getQSAdminServer().setClientAuthenticationHandler(authenticator);
        getQSAdminServer().startServer(port);
    }

    /**
     * Starts QSAdminServer for this QuickServer.
     * @see org.quickserver.net.qsadmin.QSAdminServer
     * @since 1.2
     */
    public void startQSAdminServer() throws AppException {
        getQSAdminServer().startServer();
    }

    /**
     * Returns {@link QSAdminServer} associated with this QuickServer
     * @since 1.1
     */
    public QSAdminServer getQSAdminServer() {
        if (adminServer == null)
            adminServer = new QSAdminServer(QuickServer.this);
        return adminServer;
    }

    /**
     * Sets {@link QSAdminServer} associated with this QuickServer
     * @since 1.3.3
     */
    public void setQSAdminServer(QSAdminServer adminServer) {
        if (adminServer == null)
            this.adminServer = adminServer;
    }

    /**
     * Returns the closed state of the QuickServer Socket.
     * @since 1.1
     */
    public boolean isClosed() {
        if (server == null)
            return true;
        return server.isClosed();
    }

    /**
     * Returns the application logger associated with QuickServer.
     * If it was not set will return QuickServer's own logger.
     * @since 1.2
     */
    public Logger getAppLogger() {
        if (appLogger != null)
            return appLogger;
        return logger;
    }

    /**
     * Sets the application logger associated with QuickServer
     * @since 1.2
     */
    public void setAppLogger(Logger appLogger) {
        this.appLogger = appLogger;
    }

    /**
     * Sets the ClientObjectHandler class that interacts with
     * client sockets to handle java objects.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientObjectHandler}
     * @see #getClientObjectHandler
     * @since 1.2
     */
    public void setClientObjectHandler(String handler) {
        clientObjectHandlerString = handler;
        logger.log(Level.FINEST, ""Set to {0}"", handler);
    }

    /**
     * Returns the ClientObjectHandler class that interacts with
     * client sockets.
     * @see #setClientObjectHandler
     * @since 1.2
     */
    public String getClientObjectHandler() {
        return clientObjectHandlerString;
    }

    /**
     * Sets the console log handler formatter.
     * @param formatter fully qualified name of the class that implements
     * {@link java.util.logging.Formatter}
     * @since 1.2
     */
    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (formatter == null)
            return;
        consoleLoggingformatter = formatter;
        java.util.logging.Formatter conformatter = (java.util.logging.Formatter) getClass(formatter, true).newInstance();
        Logger jdkLogger = Logger.getLogger("""");
        Handler[] handlers = jdkLogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                handlers[index].setFormatter(conformatter);
            }
        }
        logger.log(Level.FINEST, ""Set to {0}"", formatter);
    }

    /**
     * Gets the console log handler formatter.
     * @since 1.3
     */
    public String getConsoleLoggingFormatter() {
        return consoleLoggingformatter;
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MiniFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMini() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MiniFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to logging.MiniFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler formater to
     * {@link org.quickserver.util.logging.MicroFormatter}
     * @since 1.2
     */
    public void setConsoleLoggingToMicro() {
        try {
            setConsoleLoggingFormatter(""org.quickserver.util.logging.MicroFormatter"");
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Setting to MicroFormatter : {0}"", e);
        }
    }

    /**
     * Sets the console log handler level.
     * @since 1.2
     */
    public void setConsoleLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        boolean isConsole = true;
        try {
            if (System.console() == null) {
                isConsole = false;
            }
        } catch (Throwable e) {
            //ignore
        }
        for (int index = 0; index < handlers.length; index++) {
            if (ConsoleHandler.class.isInstance(handlers[index])) {
                if (isConsole == false && level != Level.OFF) {
                    System.out.println(""QuickServer: You do not have a console.. so turning console logger off.."");
                    level = Level.OFF;
                }
                if (level == Level.OFF) {
                    logger.info(""QuickServer: Removing console handler.. "");
                    rlogger.removeHandler(handlers[index]);
                    handlers[index].setLevel(level);
                    handlers[index].close();
                } else {
                    handlers[index].setLevel(level);
                }
            }
        }
        if (level == Level.SEVERE)
            consoleLoggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            consoleLoggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            consoleLoggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            consoleLoggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            consoleLoggingLevel = ""FINE"";
        else if (level == Level.FINER)
            consoleLoggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            consoleLoggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            consoleLoggingLevel = ""OFF"";
        else
            consoleLoggingLevel = ""UNKNOWN"";
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    /**
     * Gets the console log handler level.
     * @since 1.3
     */
    public String getConsoleLoggingLevel() {
        return consoleLoggingLevel;
    }

    /**
     * Sets the level for all log handlers.
     * @since 1.3.1
     */
    public void setLoggingLevel(Level level) {
        Logger rlogger = Logger.getLogger("""");
        Handler[] handlers = rlogger.getHandlers();
        for (int index = 0; index < handlers.length; index++) {
            handlers[index].setLevel(level);
        }
        if (level == Level.SEVERE)
            loggingLevel = ""SEVERE"";
        else if (level == Level.WARNING)
            loggingLevel = ""WARNING"";
        else if (level == Level.INFO)
            loggingLevel = ""INFO"";
        else if (level == Level.CONFIG)
            loggingLevel = ""CONFIG"";
        else if (level == Level.FINE)
            loggingLevel = ""FINE"";
        else if (level == Level.FINER)
            loggingLevel = ""FINER"";
        else if (level == Level.FINEST)
            loggingLevel = ""FINEST"";
        else if (level == Level.OFF)
            loggingLevel = ""OFF"";
        else
            loggingLevel = ""UNKNOWN"";
        consoleLoggingLevel = loggingLevel;
        logger.log(Level.FINE, ""Set to {0}"", level);
    }

    //*** Start of Service interface methods
    /**
     * Returns service error if any.
     * @since 1.4.7
     */
    public Throwable getServiceError() {
        return serviceError;
    }

    /**
     * Initialise and create the service.
     * @param param of the xml configuration file.
     * @since 1.2
     */
    public synchronized boolean initService(Object[] param) {
        serviceError = null;
        try {
            initServer(param);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.6
     */
    public synchronized boolean initService(QuickServerConfig qsConfig) {
        serviceError = null;
        try {
            initServer(qsConfig);
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Start the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean startService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING)
            return false;
        try {
            startServer();
        } catch (AppException e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Stop the service.
     * @return true if serivce was stopped from Running state.
     * @since 1.2
     */
    public boolean stopService() {
        serviceError = null;
        if (getServiceState() == Service.STOPPED)
            return false;
        try {
            stopServer();
            clearAllPools();
        } catch (AppException e) {
            serviceError = e;
            return false;
        } catch (Exception e) {
            serviceError = e;
            return false;
        }
        return true;
    }

    /**
     * Suspends the service.
     * @return true if service was suspended from resumed state.
     * @since 1.2
     */
    public boolean suspendService() {
        serviceError = null;
        if (getServiceState() == Service.RUNNING) {
            suspendMaxConnection = maxConnection;
            suspendMaxConnectionMsg = maxConnectionMsg;
            maxConnection = 0;
            maxConnectionMsg = ""Service is suspended."";
            setServiceState(Service.SUSPENDED);
            logger.log(Level.INFO, ""Service {0} is suspended."", getName());
            return true;
        }
        return false;
    }

    /**
     * Resume the service.
     * @return true if service was resumed from suspended state.
     * @since 1.2
     */
    public boolean resumeService() {
        serviceError = null;
        if (getServiceState() == Service.SUSPENDED) {
            maxConnection = suspendMaxConnection;
            maxConnectionMsg = suspendMaxConnectionMsg;
            setServiceState(Service.RUNNING);
            logger.log(Level.INFO, ""Service {0} resumed."", getName());
            return true;
        }
        return false;
    }

    /**
     * Information about the service.
     * @since 1.2
     */
    public String info() {
        serviceError = null;
        StringBuilder buf = new StringBuilder();
        buf.append(getName()).append(""\n"");
        buf.append(getBindAddr().getHostAddress()).append("" "");
        buf.append(getPort()).append(""\n"");
        return buf.toString();
    }

    // *** End of Service interface methods
    /**
     * Initialise and create the server.
     * @param param of the xml configuration file.
     * @exception AppException if QuickServerConfig creation failed from the xml config file.
     * @since 1.4.7
     */
    public synchronized void initServer(Object[] param) throws AppException {
        QuickServerConfig qsConfig = null;
        try {
            qsConfig = ConfigReader.read((String) param[0]);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not init server from xml file {0} : {1}"", new Object[] { new File((String) param[0]).getAbsolutePath(), e });
            throw new AppException(""Could not init server from xml file"", e);
        }
        initServer(qsConfig);
    }

    /**
     * Initialise and create the service.
     * @param qsConfig QuickServerConfig object.
     * @since 1.4.7
     */
    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {
        setConfig(qsConfig);
        try {
            configQuickServer();
            loadApplicationClasses();
            //start InitServerHooks
            InitServerHooks ish = getConfig().getInitServerHooks();
            if (ish != null) {
                Iterator iterator = ish.iterator();
                String initServerHookClassName = null;
                Class initServerHookClass = null;
                InitServerHook initServerHook = null;
                while (iterator.hasNext()) {
                    initServerHookClassName = (String) iterator.next();
                    initServerHookClass = getClass(initServerHookClassName, true);
                    initServerHook = (InitServerHook) initServerHookClass.newInstance();
                    logger.log(Level.INFO, ""Loaded init server hook: {0}"", initServerHookClassName);
                    logger.log(Level.FINE, ""Init server hook info: {0}"", initServerHook.info());
                    initServerHook.handleInit(QuickServer.this);
                }
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""Could not load init server hook: {0}"", e);
            logger.log(Level.WARNING, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw new AppException(""Could not load init server hook"", e);
        }
        setServiceState(Service.INIT);
        logger.log(Level.FINEST, ""\r\n{0}"", MyString.getSystemInfo(getVersion()));
    }

    /**
     * Returns the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public int getServiceState() {
        return serviceState;
    }

    /**
     * Sets the state of the process
     * As any constant of {@link Service} interface.
     * @since 1.2
     */
    public void setServiceState(int state) {
        serviceState = state;
    }

    private void configConsoleLoggingLevel(QuickServer qs, String temp) {
        if (temp.equals(""SEVERE""))
            qs.setConsoleLoggingLevel(Level.SEVERE);
        else if (temp.equals(""WARNING""))
            qs.setConsoleLoggingLevel(Level.WARNING);
        else if (temp.equals(""INFO""))
            qs.setConsoleLoggingLevel(Level.INFO);
        else if (temp.equals(""CONFIG""))
            qs.setConsoleLoggingLevel(Level.CONFIG);
        else if (temp.equals(""FINE""))
            qs.setConsoleLoggingLevel(Level.FINE);
        else if (temp.equals(""FINER""))
            qs.setConsoleLoggingLevel(Level.FINER);
        else if (temp.equals(""FINEST""))
            qs.setConsoleLoggingLevel(Level.FINEST);
        else if (temp.equals(""OFF""))
            qs.setConsoleLoggingLevel(Level.OFF);
        else
            logger.log(Level.WARNING, ""unknown level {0}"", temp);
    }

    /**
     * Configures QuickServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QuickServerConfig config) throws Exception {
        QuickServer qs = QuickServer.this;
        //v1.3
        qs.setConfig(config);
        qs.setBasicConfig(config);
        String temp = config.getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        temp = null;
        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        //v1.3.3
        qs.setSecurityManagerClass(config.getSecurityManagerClass());
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        temp = config.getApplicationJarPath();
        if (temp != null) {
            File ajp = new File(temp);
            if (ajp.isAbsolute() == false) {
                temp = config.getConfigFile();
                ajp = new File(temp);
                temp = ajp.getParent() + File.separatorChar + config.getApplicationJarPath();
                config.setApplicationJarPath(temp);
                temp = null;
            }
            qs.setApplicationJarPath(config.getApplicationJarPath());
            //set path also to QSAdmin
            if (config.getQSAdminServerConfig() != null) {
                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());
            }
        }
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer based on the passed QuickServerConfig object.
     * @since 1.2
     */
    public void configQuickServer(QSAdminServerConfig config) throws Exception {
        QuickServer qs = getQSAdminServer().getServer();
        qs.setBasicConfig(config);
        //set the Logging Level to same as main QS
        //config.getConsoleLoggingLevel();
        String temp = getConsoleLoggingLevel();
        configConsoleLoggingLevel(qs, temp);
        //set the Logging Formatter to same as main QS
        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());
        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());
        //v1.4.6
        qs.setClientEventHandler(config.getClientEventHandler());
        qs.setClientCommandHandler(config.getClientCommandHandler());
        qs.setName(config.getName());
        qs.setPort(config.getPort());
        if (config.getAuthenticator() != null)
            //v1.3
            qs.setAuthenticator(config.getAuthenticator());
        else if (config.getClientAuthenticationHandler() != null)
            //v1.4.6
            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());
        qs.setClientObjectHandler(config.getClientObjectHandler());
        //v1.4
        qs.setClientBinaryHandler(config.getClientBinaryHandler());
        //v1.4.5
        qs.setClientWriteHandler(config.getClientWriteHandler());
        qs.setClientData(config.getClientData());
        //v1.4.6
        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());
        //v1.4.6
        qs.setDefaultDataMode(config.getDefaultDataMode());
        qs.setServerBanner(config.getServerBanner());
        qs.setTimeout(config.getTimeout());
        qs.setMaxAuthTry(config.getMaxAuthTry());
        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());
        qs.setTimeoutMsg(config.getTimeoutMsg());
        qs.setMaxConnection(config.getMaxConnection());
        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());
        qs.setBindAddr(config.getBindAddr());
        //v1.3.2
        qs.setCommunicationLogging(config.getCommunicationLogging());
        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());
        //v1.3.2
        if (config.getCommandShellEnable().equals(""true""))
            getQSAdminServer().setShellEnable(true);
        getQSAdminServer().setPromptName(config.getCommandShellPromptName());
        //v1.3.3
        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());
        qs.setServerHooks(config.getServerHooks());
        qs.setSecure(config.getSecure());
    }

    /**
     * Configures QSAdminServer and QuickServer based on the
     * internal QuickServerConfig object.
     * @since 1.3
     */
    public void configQuickServer() throws Exception {
        configQuickServer(getConfig());
        if (getConfig().getQSAdminServerConfig() != null) {
            configQuickServer(getConfig().getQSAdminServerConfig());
        }
    }

    /**
     * Usage: QuickServer [-options]<br/>
     * Where options include:<br/>
     *   -about		Opens About Dialogbox<br/>
     *   -load <xml_config_file> [options]	Loads the server from xml file.
     * where options include:
     *    -fullXML2File <new_file_name>
     */
    public static void main(String[] args) {
        try {
            if (args.length >= 1) {
                if (args[0].equals(""-about"")) {
                    org.quickserver.net.server.gui.About.main(null);
                } else if (args[0].equals(""-load"") && args.length >= 2) {
                    QuickServer qs = QuickServer.load(args[1]);
                    if (qs != null)
                        handleOptions(args, qs);
                } else {
                    System.out.println(printUsage());
                }
            } else {
                System.out.println(printUsage());
                org.quickserver.net.server.gui.About.showAbout();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the server from the xml file name passed.
     * @since 1.4.7
     */
    public static QuickServer load(String xml) throws AppException {
        QuickServer qs = new QuickServer();
        Object[] config = new Object[] { xml };
        qs.initServer(config);
        qs.startServer();
        if (qs.getConfig().getQSAdminServerConfig() != null) {
            qs.startQSAdminServer();
        }
        return qs;
    }

    /**
     * Prints usage
     */
    private static String printUsage() {
        StringBuilder sb = new StringBuilder();
        sb.append(""QuickServer - Java library/framework for creating robust multi-client TCP servers.\n"");
        sb.append(""Copyright (C) QuickServer.org\n\n"");
        sb.append(""Usage: QuickServer [-options]\n"");
        sb.append(""Where options include:\n"");
        sb.append(""  -about\t"" + ""Opens About Dialog box\n"");
        sb.append(""  -load <xml_config_file> [load-options]\t"" + ""Loads the server from xml file.\n"");
        sb.append(""  Where load-options include:\n"");
        sb.append(""     -fullXML2File <file_name>\t"" + ""Dumps the Full XML configuration of the QuickServer loaded.\n"");
        return sb.toString();
    }

    private static void handleOptions(String[] args, QuickServer quickserver) {
        if (args.length < 3)
            return;
        if (args[2].equals(""-fullXML2File"") && args.length >= 4) {
            File file = new File(args[3]);
            logger.log(Level.INFO, ""Writing full xml configuration to file: {0}"", file.getAbsolutePath());
            try {
                TextFile.write(file, quickserver.getConfig().toXML(null));
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error writing full xml configuration: {0}"", e);
            }
        }
    }

    /**
     * Cleans all Object and Thread pools
     * @since 1.3
     */
    public void clearAllPools() throws Exception {
        try {
            if (pool != null)
                getClientPool().clear();
            if (clientHandlerPool != null)
                getClientHandlerPool().clear();
            if (getClientDataPool() != null)
                getClientDataPool().clear();
            if (getDBPoolUtil() != null)
                getDBPoolUtil().clean();
            if (byteBufferPool != null)
                getByteBufferPool().clear();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error: {0}"", e);
            throw e;
        }
    }

    /**
     * Closes all Object and Thread pools
     * @since 1.3
     */
    public void closeAllPools() throws Exception {
        if (pool == null && clientHandlerPool == null && getClientDataPool() == null && getDBPoolUtil() == null && byteBufferPool == null) {
            return;
        }
        logger.log(Level.FINE, ""Closing pools for {0}"", getName());
        try {
            if (pool != null && PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {
                logger.finer(""Closing ClientThread pool."");
                getClientPool().close();
            }
            if (clientHandlerPool != null && PoolHelper.isPoolOpen(getClientHandlerPool())) {
                logger.finer(""Closing ClientHandler pool."");
                getClientHandlerPool().close();
            }
            if (getClientDataPool() != null && PoolHelper.isPoolOpen(getClientDataPool())) {
                logger.finer(""Closing ClientData pool."");
                getClientDataPool().close();
            }
            if (getDBPoolUtil() != null) {
                logger.finer(""Closing DB pool."");
                getDBPoolUtil().clean();
            }
            if (byteBufferPool != null && PoolHelper.isPoolOpen(getByteBufferPool())) {
                logger.finer(""Closing ByteBuffer pool."");
                getByteBufferPool().close();
            }
            logger.log(Level.FINE, ""Closed pools for {0}"", getName());
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error closing pools for {0}: {1}"", new Object[] { getName(), e });
            throw e;
        }
    }

    /**
     * Initialise all Object and Thread pools.
     * @since 1.3
     */
    public void initAllPools() throws Exception {
        logger.fine(""Creating pools"");
        if (getBlockingMode() == false) {
            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());
        }
        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());
        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());
        //check if client data is poolable
        if (clientDataClass != null) {
            try {
                clientData = (ClientData) clientDataClass.newInstance();
                if (PoolableObject.class.isInstance(clientData) == true) {
                    PoolableObject po = (PoolableObject) clientData;
                    if (po.isPoolable() == true) {
                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());
                    } else {
                        clientDataPool = null;
                        logger.fine(""ClientData is not poolable!"");
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Error: {0}"", e);
                throw e;
            }
        }
        try {
            makeDBObjectPool();
        } catch (Exception e) {
            logger.log(Level.WARNING, ""Error in makeDBObjectPool() : {0}"", e);
            logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            throw e;
        }
        logger.fine(""Created pools"");
    }

    /**
     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that
     * managing the pool of threads for handling clients.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ClientPool getClientPool() {
        if (pool == null)
            throw new IllegalStateException(""No ClientPool available yet!"");
        return pool;
    }

    /**
     * Makes the pool of ClientHandler
     * @since 1.3
     */
    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientHandler pool"");
        PoolableObjectFactory factory = new ClientHandlerObjectFactory(getBlockingMode());
        clientHandlerPool = poolManager.makeClientHandlerPool(factory, opConfig);
        poolManager.initPool(clientHandlerPool, opConfig);
        clientHandlerPool = makeQSObjectPool(clientHandlerPool);
        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}
     * class.
     * @exception IllegalStateException if pool is not created yet.
     * @since 1.3
     */
    public ObjectPool getClientHandlerPool() {
        if (clientHandlerPool == null)
            throw new IllegalStateException(""No ClientHandler Pool available yet!"");
        return clientHandlerPool;
    }

    /**
     * Sets the configuration of the QuickServer.
     * @since 1.3
     */
    public void setConfig(QuickServerConfig config) {
        this.config = config;
    }

    /**
     * Returns the configuration of the QuickServer.
     * @since 1.3
     */
    public QuickServerConfig getConfig() {
        return config;
    }

    /**
     * Makes the pool of ClientData
     * @since 1.3
     */
    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientData pool"");
        clientDataPool = poolManager.makeClientDataPool(factory, opConfig);
        poolManager.initPool(clientDataPool, opConfig);
        clientDataPool = makeQSObjectPool(clientDataPool);
    }

    /**
     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}
     * class. If ClientData was not poolable will return  null.
     * @since 1.3
     */
    public ObjectPool getClientDataPool() {
        return clientDataPool;
    }

    /**
     * Returns {@link org.quickserver.sql.DBPoolUtil} object if
     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.
     * @return DBPoolUtil object if object could be loaded, else will return <code>null</code>
     * @since 1.3
     */
    public DBPoolUtil getDBPoolUtil() {
        return dBPoolUtil;
    }

    /**
     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}
     * @since 1.3
     */
    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {
        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);
    }

    /**
     * Makes the pool of Database Objects
     * @since 1.3
     */
    private void makeDBObjectPool() throws Exception {
        if (getConfig().getDBObjectPoolConfig() != null) {
            logger.fine(""Creating DBObject Pool"");
            //logger.finest(""Got:\n""+getConfig().getDBObjectPoolConfig().toXML(null));
            Class dbPoolUtilClass = getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);
            dBPoolUtil = (DBPoolUtil) dbPoolUtilClass.newInstance();
            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());
            dBPoolUtil.initPool();
        }
    }

    /**
     *  Tries to find the Client by the Id passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same clinet has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findFirstClientById(String id) {
        return clientIdentifier.findFirstClientById(id);
    }

    /**
     *  Returns an iterator containing all the
     *  {@link org.quickserver.net.server.ClientHandler} that
     *  are currently handling clients.
     *  It is recommended not to change the collection under an iterator.
     *
     *  It is imperative that the user manually synchronize on the returned collection
     *  when iterating over it:
     *  <code><pre>
     *    Eg:
     *
     * 	ClientData foundClientData = null;
     * 	Object syncObj = quickserver.getClientIdentifier().getObjectToSynchronize();
     * 	synchronized(syncObj) {
     * 		Iterator iterator = quickserver.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *
     * 	//OR
     *
     * 	ClientData foundClientData = null;
     * 	ClientIdentifier clientIdentifier = quickserver.getClientIdentifier();
     * 	synchronized(clientIdentifier.getObjectToSynchronize()) {
     * 		Iterator iterator = clientIdentifier.findAllClient();
     * 		while(iterator.hasNext()) {
     * 			foundClientHandler = (ClientHandler) iterator.next();
     * 			....
     * 		}
     * 	}
     *    </code></pre>
     *  @since 1.3.1
     */
    public Iterator findAllClient() {
        return clientIdentifier.findAllClient();
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the Id.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientById(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.2
     */
    public Iterator findAllClientById(String pattern) {
        return clientIdentifier.findAllClientById(pattern);
    }

    /**
     *  Tries to find the Client by the Key passed.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//someother client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findClientByKey(""friendskey"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.3.1
     */
    public ClientHandler findClientByKey(String key) {
        return clientIdentifier.findClientByKey(key);
    }

    /**
     *  Tries to find the Client by the matching pattern passed to the key.
     *  <p>
     *  Note: This command is an expensive so do use it limitedly and
     *  cache the returned object. But before you start sending message to the
     *  cached object do validate that ClientHandler with you is currently
     *  connected and is pointing to the same client has it was before.
     *  This can be done as follows. <pre>
     * 	foundClientHandler.isConnected(); //this method will through SocketException if not connected
     * 	Date newTime = foundClientHandler.getClientConnectedTime();
     * 	if(oldCachedTime!=newTime) {
     * 		//Client had disconnected and ClientHandler was reused for
     * 		//some other client, so write code to again find ur client
     * 		foundClientHandler = handler.getServer().findFirstClientByKey(""friendsid"");
     * 		...
     * 	}</pre>
     *  </p>
     *  @see ClientIdentifiable
     *  @return ClientHandler object if client was found else <code>null</code>
     *  @since 1.4
     */
    public Iterator findAllClientByKey(String pattern) {
        return clientIdentifier.findAllClientByKey(pattern);
    }

    /**
     * Sets next client has a trusted client.
     * <p>This will skip any authentication and will not set any timeout.</p>
     * @since 1.3.2
     */
    public void nextClientIsTrusted() {
        setSkipValidation(true);
    }

    /**
     * @since 1.3.2
     */
    private synchronized boolean getSkipValidation() {
        return skipValidation;
    }

    /**
     * @since 1.3.2
     */
    private synchronized void setSkipValidation(boolean validation) {
        skipValidation = validation;
    }

    /**
     * Sets the communication logging flag.
     * @see #getCommunicationLogging
     * @since 1.3.2
     */
    public void setCommunicationLogging(boolean communicationLogging) {
        this.communicationLogging = communicationLogging;
    }

    /**
     * Returns the communication logging flag.
     * @see #setCommunicationLogging
     * @since 1.3.2
     */
    public boolean getCommunicationLogging() {
        return communicationLogging;
    }

    /**
     * Sets the SecurityManager class
     * @param securityManagerClass the fully qualified name of the class
     * that extends {@link java.lang.SecurityManager}.
     * @see #getSecurityManagerClass
     * @since 1.3.3
     */
    public void setSecurityManagerClass(String securityManagerClass) {
        if (securityManagerClass != null)
            this.securityManagerClass = securityManagerClass;
    }

    /**
     * Returns the SecurityManager class
     * @see #setSecurityManagerClass
     * @since 1.3.3
     */
    public String getSecurityManagerClass() {
        return securityManagerClass;
    }

    public SecurityManager getSecurityManager() throws AppException {
        if (getSecurityManagerClass() == null)
            return null;
        SecurityManager sm = null;
        try {
            sm = (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();
        } catch (ClassNotFoundException e) {
            throw new AppException(e.getMessage());
        } catch (InstantiationException e) {
            throw new AppException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new AppException(e.getMessage());
        }
        return sm;
    }

    /**
     * Sets the Access constraints
     * @since 1.3.3
     */
    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {
        this.accessConstraintConfig = accessConstraintConfig;
    }

    /**
     * Returns Access constraints if present else <code>null</code>.
     * @since 1.3.3
     */
    public AccessConstraintConfig getAccessConstraintConfig() {
        return accessConstraintConfig;
    }

    /**
     * Sets the classloader to be used to load the dynamically resolved
     * classes
     * @since 1.3.3
     */
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        Thread.currentThread().setContextClassLoader(classLoader);
    }

    /**
     * Gets the classloader used to load the dynamically resolved
     * classes.
     * @since 1.4.6
     */
    public ClassLoader getClassLoader() {
        return classLoader;
    }

    /**
     * Utility method to load a class
     * @since 1.3.3
     */
    public Class getClass(String name, boolean reload) throws ClassNotFoundException {
        if (name == null)
            throw new IllegalArgumentException(""Class name can't be null!"");
        logger.log(Level.FINEST, ""Class: {0}, reload: {1}"", new Object[] { name, reload });
        if (reload == true && classLoader != null) {
            return classLoader.loadClass(name);
        } else if (reload == true && classLoader == null && this.getClass().getClassLoader() != null) {
            return this.getClass().getClassLoader().loadClass(name);
        } else if (reload == false && classLoader != null) {
            return Class.forName(name, true, classLoader);
        } else /*if(reload==false && classLoader==null)*/
        {
            return Class.forName(name, true, this.getClass().getClassLoader());
        }
    }

    /**
     * Sets the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing
     * the jars needed by the application.
     * @see #getApplicationJarPath
     * @since 1.3.3
     */
    protected void setApplicationJarPath(String applicationJarPath) {
        this.applicationJarPath = applicationJarPath;
    }

    /**
     * Returns the applications jar/s path. This can be either absolute or
     * relative(to config file) path to the jar file or the directory containing the
     * jars needed by the application.
     * @see #setApplicationJarPath
     * @since 1.3.3
     */
    public String getApplicationJarPath() {
        return applicationJarPath;
    }

    /**
     * Sets the ServerHooks
     * @since 1.3.3
     */
    public void setServerHooks(ServerHooks serverHooks) {
        this.serverHooks = serverHooks;
    }

    /**
     * Returns ServerHooks if present else <code>null</code>.
     * @since 1.3.3
     */
    public ServerHooks getServerHooks() {
        if (serverHooks == null)
            serverHooks = new ServerHooks();
        return serverHooks;
    }

    /**
     * @since 1.3.3
     */
    private void loadServerHooksClasses() {
        if (getServerHooks() == null)
            return;
        listOfServerHooks = new ArrayList();
        ServerHook serverHook = null;
        String serverHookClassName = null;
        Class serverHookClass = null;
        //add system hooks
        serverHook = new GhostSocketReaper();
        serverHook.initHook(QuickServer.this);
        listOfServerHooks.add(serverHook);
        ghostSocketReaper = (GhostSocketReaper) serverHook;
        //add user hooks if any
        Iterator iterator = getServerHooks().iterator();
        while (iterator.hasNext()) {
            serverHookClassName = (String) iterator.next();
            try {
                serverHookClass = getClass(serverHookClassName, true);
                serverHook = (ServerHook) serverHookClass.newInstance();
                serverHook.initHook(QuickServer.this);
                listOfServerHooks.add(serverHook);
                logger.log(Level.INFO, ""Loaded server hook: {0}"", serverHookClassName);
                logger.log(Level.FINE, ""Server hook info: {0}"", serverHook.info());
            } catch (Exception e) {
                logger.log(Level.WARNING, ""Could not load server hook [{0}]: {1}"", new Object[] { serverHookClassName, e });
                logger.log(Level.FINE, ""StackTrace:\n{0}"", MyString.getStackTrace(e));
            }
        }
        //end of while
    }

    /**
     * @since 1.3.3
     */
    private void processServerHooks(int event) {
        if (listOfServerHooks == null) {
            logger.warning(""listOfServerHooks was null!"");
            return;
        }
        ServerHook serverHook = null;
        boolean result = false;
        Iterator iterator = listOfServerHooks.iterator();
        String hooktype = ""UNKNOWN"";
        switch(event) {
            case ServerHook.PRE_STARTUP:
                hooktype = ""PRE_STARTUP"";
                break;
            case ServerHook.POST_STARTUP:
                hooktype = ""POST_STARTUP"";
                break;
            case ServerHook.PRE_SHUTDOWN:
                hooktype = ""PRE_SHUTDOWN"";
                break;
            case ServerHook.POST_SHUTDOWN:
                hooktype = ""POST_SHUTDOWN"";
                break;
        }
        while (iterator.hasNext()) {
            serverHook = (ServerHook) iterator.next();
            try {
                result = serverHook.handleEvent(event);
            } catch (Exception e) {
                result = false;
                logger.log(Level.WARNING, ""Error invoking {0} hook [{1}]: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });
            }
            logger.log(Level.FINE, ""Invoked {0} hook [{1}] was: {2}"", new Object[] { hooktype, serverHook.getClass().getName(), result });
        }
    }

    /**
     * Creates and returns a copy of this object.
     * @since 1.3.3
     */
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
            QuickServer _qs = (QuickServer) object;
            _qs.setQSAdminServer(new QSAdminServer(_qs));
        } catch (CloneNotSupportedException e) {
            //should not happ
            logger.log(Level.WARNING, ""Error cloning : {0}"", e);
        }
        return object;
    }

    /**
     * Sets the Secure setting for QuickServer
     * @since 1.4.0
     */
    public void setSecure(Secure secure) {
        this.secure = secure;
    }

    /**
     * Returns Secure setting for QuickServer
     * @since 1.4.0
     */
    public Secure getSecure() {
        if (secure == null)
            secure = new Secure();
        return secure;
    }

    /**
     * <p>Returns if the server is running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public boolean isRunningSecure() {
        return runningSecure;
    }

    /**
     * <p>Sets the server mode if its running in Secure mode [SSL or TLS].</p>
     * @since 1.4.0
     */
    public void setRunningSecure(boolean runningSecure) {
        this.runningSecure = runningSecure;
    }

    private File makeAbsoluteToConfig(String fileName) {
        Assertion.affirm(fileName != null, ""FileName can't be null"");
        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());
    }

    /**
     * Returns a ServerSocket object to be used for listening.
     * @since 1.4.0
     */
    protected void makeServerSocket() throws BindException, IOException {
        server = null;
        logger.log(Level.FINEST, ""Binding {0} to IP: {1}"", new Object[] { getName(), getBindAddr() });
        InetSocketAddress bindAddress = new InetSocketAddress(getBindAddr(), getPort());
        try {
            NetworkInterface ni = NetworkInterface.getByInetAddress(getBindAddr());
            if (ni != null) {
                logger.fine(""NetworkInterface: "" + ni);
            }
        } catch (Exception igrnore) {
            /*ignore*/
        } catch (Error igrnore) {
            /*ignore*/
        }
        if (getSecure().isEnable() == false) {
            logger.log(Level.FINE, ""Making a normal ServerSocket for {0}"", getName());
            setRunningSecure(false);
            if (getBlockingMode() == false) {
                //for non-blocking
                serverSocketChannel = ServerSocketChannel.open();
                server = serverSocketChannel.socket();
                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
            } else {
                //for blocking
                server = new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
            }
        } else {
            try {
                logger.log(Level.FINE, ""Making a secure ServerSocket for {0}"", getName());
                getSSLContext();
                setRunningSecure(true);
                if (getBlockingMode() == false) {
                    logger.log(Level.FINE, ""Making a secure ServerSocketChannel for {0}"", getName());
                    //for non-blocking
                    serverSocketChannel = ServerSocketChannel.open();
                    server = serverSocketChannel.socket();
                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());
                } else {
                    ServerSocketFactory ssf = getSSLContext().getServerSocketFactory();
                    SSLServerSocket serversocket = (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());
                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());
                    setRunningSecure(true);
                    secureStoreManager.logSSLServerSocketInfo(serversocket);
                    server = serversocket;
                    serverSocketChannel = server.getChannel();
                    if (serverSocketChannel == null && getBlockingMode() == false) {
                        logger.warning(""Secure Server does not support Channel! So will run in blocking mode."");
                        blockingMode = false;
                    }
                }
                //blocking
            } catch (NoSuchAlgorithmException e) {
                logger.log(Level.WARNING, ""NoSuchAlgorithmException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            } catch (KeyManagementException e) {
                logger.log(Level.WARNING, ""KeyManagementException : {0}"", e);
                throw new IOException(""Error creating secure socket : "" + e.getMessage());
            }
        }
        server.setReuseAddress(true);
        int connectionTime = 0;
        int latency = 0;
        int bandwidth = 0;
        connectionTime = getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();
        latency = getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();
        bandwidth = getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();
        logger.log(Level.FINE, ""getPerformancePreferencesConnectionTime : {0}"", connectionTime);
        logger.log(Level.FINE, ""getPerformancePreferencesLatency : {0}"", latency);
        logger.log(Level.FINE, ""getPerformancePreferencesBandwidth : {0}"", bandwidth);
        server.setPerformancePreferences(connectionTime, latency, bandwidth);
        int clientSocketReceiveBufferSize = getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();
        if (clientSocketReceiveBufferSize > 0) {
            logger.log(Level.FINE, ""clientSocketReceiveBufferSize: {0}"", clientSocketReceiveBufferSize);
            server.setReceiveBufferSize(clientSocketReceiveBufferSize);
        }
        if (getBlockingMode() == false) {
            logger.log(Level.FINE, ""Server Mode {0} - Non Blocking"", getName());
            if (selector == null || selector.isOpen() == false) {
                logger.finest(""Opening new selector"");
                selector = Selector.open();
            } else {
                logger.log(Level.FINEST, ""Reusing selector: {0}"", selector);
            }
            serverSocketChannel.configureBlocking(false);
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            selector.wakeup();
        } else {
            logger.log(Level.FINE, ""Server Mode {0} - Blocking"", getName());
        }
    }

    /**
     * Sets the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {
        Assertion.affirm(basicConfig != null, ""BasicServerConfig can't be null"");
        this.basicConfig = basicConfig;
    }

    /**
     * Returns the basic configuration of the QuickServer.
     * @since 1.4.0
     */
    public BasicServerConfig getBasicConfig() {
        return basicConfig;
    }

    /**
     * Loads the <code>SSLContext</code> from Secure configuring if set.
     * @see #setSecure
     * @since 1.4.0
     */
    public void loadSSLContext() throws IOException {
        if (getSecure().isLoad() == false) {
            throw new IllegalStateException(""Secure setting is not yet enabled for loading!"");
        }
        logger.info(""Loading Secure Context.."");
        km = null;
        tm = null;
        try {
            String ssManager = ""org.quickserver.security.SecureStoreManager"";
            if (getSecure().getSecureStore() != null)
                ssManager = getSecure().getSecureStore().getSecureStoreManager();
            Class secureStoreManagerClass = getClass(ssManager, true);
            secureStoreManager = (SecureStoreManager) secureStoreManagerClass.newInstance();
            km = secureStoreManager.loadKeyManagers(getConfig());
            logger.fine(""KeyManager got"");
            tm = secureStoreManager.loadTrustManagers(getConfig());
            logger.fine(""TrustManager got"");
            sslc = secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());
            sslc.init(km, tm, null);
            logger.fine(""SSLContext loaded"");
        } catch (KeyStoreException e) {
            logger.warning(""KeyStoreException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            logger.warning(""NoSuchAlgorithmException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (NoSuchProviderException e) {
            logger.warning(""NoSuchProviderException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (UnrecoverableKeyException e) {
            logger.warning(""UnrecoverableKeyException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (CertificateException e) {
            logger.warning(""CertificateException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (KeyManagementException e) {
            logger.warning(""KeyManagementException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (GeneralSecurityException e) {
            logger.warning(""GeneralSecurityException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (ClassNotFoundException e) {
            logger.warning(""ClassNotFoundException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (InstantiationException e) {
            logger.warning(""InstantiationException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        } catch (IllegalAccessException e) {
            logger.warning(""IllegalAccessException : "" + e);
            throw new IOException(""Error creating secure socket : "" + e.getMessage());
        }
    }

    /**
     * Returns the <code>SSLContext</code> from Secure configuring.
     * @see #loadSSLContext
     * @since 1.4.0
     */
    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        return getSSLContext(null);
    }

    /**
     * Returns the <code>SSLContext</code> object that implements the specified
     * secure socket protocol from Secure configuring.
     * @see #loadSSLContext
     * @param protocol the standard name of the requested protocol. If <code>null</code> will use the protocol set in secure configuration of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        if (protocol != null && secureStoreManager != null) {
            SSLContext _sslc = secureStoreManager.getSSLContext(protocol);
            _sslc.init(km, tm, null);
            return _sslc;
        }
        return sslc;
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * Secure socket protocol will be picked from the Secure configuring.
     * @see #setSecure
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext());
    }

    /**
     * Returns a SSLSocketFactory object to be used for creating SSLSockets.
     * @see #setSecure
     * @param protocol the standard name of the requested protocol. If
     * <code>null</code> will use the protocol set in secure configuration
     * of the server.
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws KeyManagementException
     * @since 1.4.0
     */
    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        if (sslc == null)
            loadSSLContext();
        return secureStoreManager.getSocketFactory(getSSLContext(protocol));
    }

    /**
     * Sets the ClientBinaryHandler class that interacts with
     * client sockets to handle binary data.
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientBinaryHandler}
     * @see #getClientBinaryHandler
     * @since 1.4
     */
    public void setClientBinaryHandler(String handler) {
        clientBinaryHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientBinaryHandler class that interacts with
     * client sockets.
     * @see #setClientBinaryHandler
     * @since 1.4
     */
    public String getClientBinaryHandler() {
        return clientBinaryHandlerString;
    }

    /**
     * Sets the Selector (NIO).
     * @since 1.4.5
     */
    public void setSelector(Selector selector) {
        this.selector = selector;
    }

    /**
     * Returns the Selector (NIO),if any.
     * @since 1.4.5
     */
    public Selector getSelector() {
        return selector;
    }

    /**
     * Starts server in blocking mode.
     * @since 1.4.5
     */
    private void runBlocking(TheClient theClient) throws Exception {
        Socket client = null;
        ClientHandler _chPolled = null;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        //long stime = System.currentTimeMillis();
        //long etime = System.currentTimeMillis();
        while (true) {
            //etime = System.currentTimeMillis();
            //System.out.println(""Time Taken: ""+(etime-stime));
            client = server.accept();
            //stime = System.currentTimeMillis();
            if (linger < 0) {
                client.setSoLinger(false, 0);
            } else {
                client.setSoLinger(true, linger);
            }
            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                //low delay=10
                client.setTrafficClass(socketTrafficClass);
            }
            logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
            }
            if (stopServer) {
                //Client connected when server was about to be shutdown.
                try {
                    client.close();
                } catch (Exception e) {
                }
                break;
            }
            if (checkAccessConstraint(client) == false) {
                continue;
            }
            //Check if max connection has reached
            if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);
            } else {
                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);
            }
            theClient.setTrusted(getSkipValidation());
            theClient.setSocket(client);
            //mostly null
            theClient.setSocketChannel(client.getChannel());
            if (clientDataClass != null) {
                if (getClientDataPool() == null) {
                    clientData = (ClientData) clientDataClass.newInstance();
                } else {
                    clientData = (ClientData) getClientDataPool().borrowObject();
                }
                theClient.setClientData(clientData);
            }
            try {
                _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                _chPolled.handleClient(theClient);
            } catch (java.util.NoSuchElementException nsee) {
                logger.warning(""Could not borrow ClientHandler from pool. Error: "" + nsee);
                logger.warning(""Closing Socket ["" + client + ""] since no ClientHandler available."");
                client.close();
            }
            if (_chPolled != null) {
                try {
                    getClientPool().addClient(_chPolled, true);
                } catch (java.util.NoSuchElementException nsee) {
                    logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                    //logger.warning(""Closing Socket [""+client+""] since no Thread available."");
                    //client.close();
                    //returnClientHandlerToPool(_chPolled);
                }
                _chPolled = null;
            }
            client = null;
            //reset it back
            setSkipValidation(false);
        }
        //end of loop
    }

    /**
     * Starts server in non-blocking mode.
     * @since 1.4.5
     */
    private void runNonBlocking(TheClient theClient) throws Exception {
        int selectCount = 0;
        Iterator iterator = null;
        SelectionKey key = null;
        ServerSocketChannel serverChannel = null;
        SocketChannel socketChannel = null;
        Socket client = null;
        ClientHandler _chPolled = null;
        boolean stopServerProcessed = false;
        int linger = getBasicConfig().getAdvancedSettings().getSocketLinger();
        registerChannelRequestMap = new HashMap();
        int socketTrafficClass = 0;
        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
            socketTrafficClass = Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());
        }
        while (true) {
            selectCount = selector.select(500);
            //selectCount = selector.select();//for testing
            //check for any pending registerChannel req.
            synchronized (registerChannelRequestMap) {
                if (registerChannelRequestMap.size() > 0) {
                    RegisterChannelRequest req = null;
                    Object hashkey = null;
                    iterator = registerChannelRequestMap.keySet().iterator();
                    while (iterator.hasNext()) {
                        hashkey = iterator.next();
                        req = (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);
                        req.register(getSelector());
                    }
                    iterator = null;
                    registerChannelRequestMap.clear();
                }
                //if
            }
            //sync
            if (stopServer == true && stopServerProcessed == false) {
                logger.warning(""Closing "" + getName());
                serverSocketChannel.close();
                stopServerProcessed = true;
                server = null;
                serverSocketChannel = null;
                setServiceState(Service.STOPPED);
                logger.warning(""Closed "" + getName());
                processServerHooks(ServerHook.POST_SHUTDOWN);
            }
            if (stopServer == false && stopServerProcessed == true) {
                logger.finest(""Server must have re-started.. will break"");
                break;
            }
            if (selectCount == 0 && stopServerProcessed == true) {
                java.util.Set keyset = selector.keys();
                if (keyset.isEmpty() == true && getClientCount() <= 0) {
                    break;
                } else {
                    continue;
                }
            } else if (selectCount == 0) {
                continue;
            }
            iterator = selector.selectedKeys().iterator();
            while (iterator.hasNext()) {
                key = (SelectionKey) iterator.next();
                if (key.isValid() == false) {
                    iterator.remove();
                    continue;
                }
                if (key.isAcceptable() && stopServer == false) {
                    logger.finest(""Key is Acceptable"");
                    serverChannel = (ServerSocketChannel) key.channel();
                    socketChannel = serverChannel.accept();
                    if (socketChannel == null) {
                        iterator.remove();
                        continue;
                    }
                    client = socketChannel.socket();
                    if (linger < 0) {
                        client.setSoLinger(false, 0);
                    } else {
                        client.setSoLinger(true, linger);
                    }
                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() != null) {
                        //low delay=10
                        client.setTrafficClass(socketTrafficClass);
                    }
                    logger.fine(""ReceiveBufferSize: "" + client.getReceiveBufferSize());
                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() != 0) {
                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());
                        logger.fine(""SendBufferSize: "" + client.getSendBufferSize());
                    }
                    if (checkAccessConstraint(client) == false) {
                        iterator.remove();
                        continue;
                    }
                    socketChannel.configureBlocking(false);
                    theClient.setTrusted(getSkipValidation());
                    theClient.setSocket(socketChannel.socket());
                    theClient.setSocketChannel(socketChannel);
                    if (clientDataClass != null) {
                        if (getClientDataPool() == null) {
                            clientData = (ClientData) clientDataClass.newInstance();
                        } else {
                            //borrow a object from pool
                            clientData = (ClientData) getClientDataPool().borrowObject();
                        }
                        theClient.setClientData(clientData);
                    }
                    //Check if max connection has reached
                    if (getSkipValidation() != true && maxConnection != -1 && getClientHandlerPool().getNumActive() >= maxConnection) {
                        theClient.setClientEvent(ClientEvent.MAX_CON);
                    } else {
                        theClient.setClientEvent(ClientEvent.ACCEPT);
                    }
                    try {
                        _chPolled = (ClientHandler) getClientHandlerPool().borrowObject();
                        logger.finest(""Asking "" + _chPolled.getName() + "" to handle."");
                        _chPolled.handleClient(theClient);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.warning(""Could not borrow ClientHandler Object from pool. Error: "" + nsee);
                        logger.warning(""Closing SocketChannel ["" + serverChannel.socket() + ""] since no ClientHandler available."");
                        socketChannel.close();
                    }
                    if (_chPolled != null) {
                        try {
                            getClientPool().addClient(_chPolled, true);
                        } catch (java.util.NoSuchElementException nsee) {
                            logger.warning(""Could not borrow Thread from pool. Error: "" + nsee);
                            //logger.warning(""Closing SocketChannel [""+serverChannel.socket()+""] since no Thread available."");
                            //socketChannel.close();
                            //returnClientHandlerToPool(_chPolled);
                        }
                        _chPolled = null;
                    }
                    socketChannel = null;
                    client = null;
                    //reset it back
                    setSkipValidation(false);
                } else if (key.isValid() && key.isReadable()) {
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Readable, removing OP_READ from interestOps for "" + _ch.getName());
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));
                        _ch.addEvent(ClientEvent.READ);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.READ);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (key.isValid() && key.isWritable()) {
                    if (getClientPool().shouldNioWriteHappen() == false) {
                        //no need to remove the key
                        continue;
                    }
                    boolean addedEvent = false;
                    ClientHandler _ch = null;
                    try {
                        _ch = (ClientHandler) key.attachment();
                        logger.finest(""Key is Writable, removing OP_WRITE from interestOps for "" + _ch.getName());
                        //remove OP_WRITE from interest set
                        key.interestOps(key.interestOps() & (~SelectionKey.OP_WRITE));
                        _ch.addEvent(ClientEvent.WRITE);
                        addedEvent = true;
                        //_ch.setSelectionKey(key);
                        getClientPool().addClient(_ch);
                    } catch (CancelledKeyException cke) {
                        logger.fine(""Ignored Error - Key was Cancelled: "" + cke);
                    } catch (java.util.NoSuchElementException nsee) {
                        logger.finest(""NoSuchElementException: "" + nsee);
                        if (addedEvent)
                            _ch.removeEvent(ClientEvent.WRITE);
                        //no need to remove the key
                        continue;
                    }
                    _ch = null;
                } else if (stopServer == true && key.isAcceptable()) {
                    //we will not accept this key
                    //reset it back
                    setSkipValidation(false);
                } else {
                    logger.warning(""Unknown key got in SelectionKey: "" + key);
                }
                //Remove key
                iterator.remove();
                Thread.yield();
            }
            //end of iterator
            iterator = null;
        }
        //end of loop
    }

    private boolean checkAccessConstraint(Socket socket) {
        try {
            if (getAccessConstraintConfig() != null) {
                getAccessConstraintConfig().checkAccept(socket);
            }
            return true;
        } catch (SecurityException se) {
            logger.warning(""SecurityException occurred accepting connection : "" + se.getMessage());
            return false;
        }
    }

    /**
     * Register the given channel for the given operations. This adds the request
     * to a list and will be processed after selector select wakes up.
     * @return boolean flag to indicate if new entry was added to the list to register.
     * @since 1.4.5
     */
    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {
        if (getSelector() == null) {
            throw new IllegalStateException(""Selector is not open!"");
        }
        if (channel == null) {
            throw new IllegalArgumentException(""Can't register a null channel!"");
        }
        if (channel.isConnected() == false) {
            throw new ClosedChannelException();
        }
        RegisterChannelRequest req = new RegisterChannelRequest(channel, ops, att);
        RegisterChannelRequest reqOld = null;
        synchronized (registerChannelRequestMap) {
            reqOld = (RegisterChannelRequest) registerChannelRequestMap.get(channel);
            if (reqOld == null) {
                registerChannelRequestMap.put(channel, req);
                getSelector().wakeup();
                return true;
            } else {
                if (reqOld.equals(req) == false) {
                    reqOld.setOps(reqOld.getOps() | req.getOps());
                    reqOld.setAtt(req.getAtt());
                    return true;
                }
                return false;
            }
        }
        /*
		logger.warning(""Before register..."");
		channel.register(getSelector(), ops, att);
		logger.warning(""Before wakeup and after register..."");
		getSelector().wakeup();
		logger.warning(""After wakeup..."");
		*/
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeByteBufferPool(PoolConfig opConfig) {
        logger.finer(""Creating ByteBufferPool pool"");
        int bufferSize = getBasicConfig().getAdvancedSettings().getByteBufferSize();
        boolean useDirectByteBuffer = getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();
        PoolableObjectFactory factory = new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);
        byteBufferPool = poolManager.makeByteBufferPool(factory, opConfig);
        poolManager.initPool(byteBufferPool, opConfig);
    }

    /**
     * Returns ObjectPool of java.nio.ByteBuffer class.
     * @since 1.4.5
     */
    public ObjectPool getByteBufferPool() {
        return byteBufferPool;
    }

    /**
     * Makes the pool of ByteBuffer
     * @since 1.4.5
     */
    private void makeClientPool(PoolConfig opConfig) throws Exception {
        logger.finer(""Creating ClientThread pool"");
        ThreadObjectFactory factory = new ThreadObjectFactory();
        ObjectPool objectPool = poolManager.makeClientPool(factory, opConfig);
        pool = new ClientPool(makeQSObjectPool(objectPool), opConfig);
        factory.setClientPool(pool);
        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());
        poolManager.initPool(objectPool, opConfig);
    }

    /**
     * Sets the ClientWriteHandler class that interacts with
     * client sockets to handle data write (only used in non-blocking mode).
     * @param handler object the fully qualified name of the class that
     *  implements {@link ClientWriteHandler}
     * @see #getClientWriteHandler
     * @since 1.4.5
     */
    public void setClientWriteHandler(String handler) {
        clientWriteHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientWriteHandler class that interacts with
     * client sockets (only used in non-blocking mode).
     * @see #setClientWriteHandler
     * @since 1.4.5
     */
    public String getClientWriteHandler() {
        return clientWriteHandlerString;
    }

    /**
     * Returns the date/time when the server was last started.
     * @return last started time. Will be <code>null</code> if never started.
     * @since 1.4.5
     */
    public java.util.Date getLastStartTime() {
        return lastStartTime;
    }

    /**
     * Sets the debug flag to ByteBufferOutputStream and
     * ByteBufferInputStream class that are used in non-blcking mode
     * @since 1.4.5
     */
    public static void setDebugNonBlockingMode(boolean flag) {
        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);
        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);
    }

    /**
     * Returns the implementation that is used to do Client Identification.
     * @since 1.4.5
     */
    public ClientIdentifier getClientIdentifier() {
        return clientIdentifier;
    }

    /**
     * Makes QSObjectPool from ObjectPool
     * @since 1.4.5
     */
    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {
        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);
    }

    /**
     * Returns the current blocking mode of the server.
     * @since 1.4.6
     */
    public boolean getBlockingMode() {
        return blockingMode;
    }

    /**
     * Loads all the Business Logic class
     * @since 1.4.6
     */
    protected void loadBusinessLogic() throws Exception {
        if (clientCommandHandlerString == null && clientEventHandlerString == null) {
            logger.severe(""ClientCommandHandler AND ClientEventHandler was not set."");
            throw new AppException(""ClientCommandHandler AND ClientEventHandler was not set."");
        }
        clientCommandHandler = null;
        if (clientCommandHandlerString != null) {
            logger.finest(""Loading ClientCommandHandler class.."");
            Class clientCommandHandlerClass = getClass(clientCommandHandlerString, true);
            clientCommandHandler = (ClientCommandHandler) clientCommandHandlerClass.newInstance();
        }
        boolean setClientCommandHandlerLookup = false;
        clientEventHandler = null;
        if (clientEventHandlerString == null) {
            clientEventHandlerString = ""org.quickserver.net.server.impl.DefaultClientEventHandler"";
            setClientCommandHandlerLookup = true;
        }
        logger.finest(""Loading ClientEventHandler class.."");
        if (clientEventHandlerString.equals(clientCommandHandlerString) && ClientEventHandler.class.isInstance(clientCommandHandler)) {
            clientEventHandler = (ClientEventHandler) clientCommandHandler;
        } else {
            clientEventHandler = (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();
            if (setClientCommandHandlerLookup) {
                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);
            }
        }
        clientExtendedEventHandler = null;
        if (clientExtendedEventHandlerString != null) {
            logger.finest(""Loading ClientExtendedEventHandler class.."");
            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) && ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientCommandHandler;
            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) && ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientEventHandler;
            } else {
                Class clientExtendedEventHandlerClass = getClass(clientExtendedEventHandlerString, true);
                clientExtendedEventHandler = (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();
            }
        }
        clientObjectHandler = null;
        if (clientObjectHandlerString != null) {
            logger.finest(""Loading ClientObjectHandler class.."");
            if (clientObjectHandlerString.equals(clientCommandHandlerString) && ClientObjectHandler.class.isInstance(clientCommandHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientCommandHandler;
            } else if (clientObjectHandlerString.equals(clientEventHandlerString) && ClientObjectHandler.class.isInstance(clientEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientEventHandler;
            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) && ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {
                clientObjectHandler = (ClientObjectHandler) clientExtendedEventHandler;
            } else {
                clientObjectHandler = (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientBinaryHandler = null;
        if (clientBinaryHandlerString != null) {
            logger.finest(""Loading ClientBinaryHandler class.."");
            if (clientBinaryHandlerString.equals(clientCommandHandlerString) && ClientBinaryHandler.class.isInstance(clientCommandHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientCommandHandler;
            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) && ClientBinaryHandler.class.isInstance(clientEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientEventHandler;
            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) && ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientExtendedEventHandler;
            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) && ClientBinaryHandler.class.isInstance(clientObjectHandler)) {
                clientBinaryHandler = (ClientBinaryHandler) clientObjectHandler;
            } else {
                clientBinaryHandler = (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();
            }
        }
        //end of != null
        clientWriteHandler = null;
        if (clientWriteHandlerString != null) {
            logger.finest(""Loading ClientWriteHandler class.."");
            if (clientWriteHandlerString.equals(clientCommandHandlerString) && ClientWriteHandler.class.isInstance(clientCommandHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientCommandHandler;
            } else if (clientWriteHandlerString.equals(clientEventHandlerString) && ClientWriteHandler.class.isInstance(clientEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientEventHandler;
            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) && ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientExtendedEventHandler;
            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) && ClientWriteHandler.class.isInstance(clientObjectHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientObjectHandler;
            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) && ClientWriteHandler.class.isInstance(clientBinaryHandler)) {
                clientWriteHandler = (ClientWriteHandler) clientBinaryHandler;
            } else {
                clientWriteHandler = (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();
            }
        }
        //end of != null
        Class authenticatorClass = null;
        if (clientAuthenticationHandlerString != null) {
            logger.finest(""Loading ClientAuthenticationHandler class.."");
            authenticatorClass = getClass(clientAuthenticationHandlerString, true);
        }
        if (authenticatorClass != null) {
            Object obj = authenticatorClass.newInstance();
            if (ClientAuthenticationHandler.class.isInstance(obj))
                clientAuthenticationHandler = (ClientAuthenticationHandler) obj;
            else
                authenticator = (Authenticator) obj;
        }
        clientDataClass = null;
        if (clientDataString != null) {
            logger.finest(""Loading ClientData class.."");
            clientDataClass = getClass(clientDataString, true);
        }
        Assertion.affirm(clientEventHandler != null, ""ClientEventHandler was not loaded!"");
    }

    /**
     * Sets the ClientEventHandler class that gets notified of
     * client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientEventHandler}
     * @see #getClientEventHandler
     * @since 1.4.6
     */
    public void setClientEventHandler(String handler) {
        clientEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientEventHandler class that gets notified of
     * client events.
     * @see #setClientEventHandler
     * @since 1.4.6
     */
    public String getClientEventHandler() {
        return clientEventHandlerString;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (dataType == DataType.IN)
            this.defaultDataModeIN = dataMode;
        if (dataType == DataType.OUT)
            this.defaultDataModeOUT = dataMode;
    }

    /**
     * Sets the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {
        defaultDataModeIN = defaultDataMode.getDataMode(DataType.IN);
        defaultDataModeOUT = defaultDataMode.getDataMode(DataType.OUT);
        ;
    }

    /**
     * Returns the default {@link DataMode} for the ClientHandler
     * @since 1.4.6
     */
    public DataMode getDefaultDataMode(DataType dataType) {
        if (dataType == DataType.IN)
            return defaultDataModeIN;
        if (dataType == DataType.OUT)
            return defaultDataModeOUT;
        else
            throw new IllegalArgumentException(""Unknown DataType: "" + dataType);
    }

    /**
     * Sets the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @param handler the fully qualified name of the class that
     *  implements {@link ClientExtendedEventHandler}
     * @see #getClientExtendedEventHandler
     * @since 1.4.6
     */
    public void setClientExtendedEventHandler(String handler) {
        clientExtendedEventHandlerString = handler;
        logger.finest(""Set to "" + handler);
    }

    /**
     * Returns the ClientExtendedEventHandler class that gets notified of
     * extended client events.
     * @see #setClientExtendedEventHandler
     * @since 1.4.6
     */
    public String getClientExtendedEventHandler() {
        return clientExtendedEventHandlerString;
    }

    /**
     * If Application Jar Path was set, load the jars
     * @since 1.4.6
     */
    private void loadApplicationClasses() throws Exception {
        if (getApplicationJarPath() != null && getClassLoader() == null) {
            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));
            //update qsadmin to use the same
            if (adminServer != null) {
                adminServer.getServer().setClassLoader(getClassLoader());
            }
        }
    }

    /**
     * Returns PID of the JVM
     * @return PID of the JVM
     * @since 1.4.8
     */
    public static String getPID() {
        return pid;
    }

    public boolean isRawCommunicationLogging() {
        return rawCommunicationLogging;
    }

    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {
        this.rawCommunicationLogging = rawCommunicationLogging;
    }

    public int getRawCommunicationMaxLength() {
        return rawCommunicationMaxLength;
    }

    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {
        this.rawCommunicationMaxLength = rawCommunicationMaxLength;
    }
}
","// QuickServer_9Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#resumeService()} method.
*/
class QuickServer_9Test {","// QuickServer_9Test.java
package org.quickserver.net.server;

import java.io.*;
import java.lang.management.ManagementFactory;
import java.net.*;
import org.quickserver.net.*;
//v1.1
import org.quickserver.net.qsadmin.*;
//v1.2
import java.util.logging.*;
//v1.3
import org.quickserver.util.pool.*;
import org.quickserver.util.pool.thread.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.*;
import org.quickserver.sql.*;
//v1.3.1
import java.util.logging.Formatter;
import java.util.*;
//v1.3.2
import org.quickserver.util.*;
//v1.3.3
import org.quickserver.security.*;
//v1.4.0
import javax.net.ssl.*;
import javax.net.*;
import java.security.*;
import java.security.cert.*;
//v1.4.5
import java.nio.channels.*;
import org.quickserver.net.server.impl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link QuickServer}.
* It contains ten unit test cases for the {@link QuickServer#resumeService()} method.
*/
class QuickServer_9Test {
"
5d277566-731c-4b06-8773-ac70dd0a4fc2,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/impl/NonBlockingClientHandler_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 16330 tokens (12330 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// NonBlockingClientHandler.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;

public class NonBlockingClientHandler extends BasicClientHandler {

    private static final Logger logger = Logger.getLogger(NonBlockingClientHandler.class.getName());

    //v1.4.5
    protected ClientWriteHandler clientWriteHandler;

    private SocketChannel socketChannel;

    protected ArrayList readByteBuffer = new ArrayList();

    protected ArrayList writeByteBuffer = new ArrayList();

    protected SelectionKey selectionKey;

    protected volatile int threadAccessCount = 0;

    protected volatile boolean willReturn;

    protected volatile boolean waitingForFinalWrite;

    //one for each event ACCEPT, WRITE, READ
    private static int maxThreadAccessCount = 5;

    private static boolean wakeupSelectorAfterRegisterWrite = true;

    private static boolean wakeupSelectorAfterRegisterRead = true;

    //nio ssl
    //private final SSLSession session;
    private boolean initialHandshakeStatus = false;

    private SSLEngineResult.HandshakeStatus handshakeStatus;

    private SSLEngineResult.Status status = null;

    private ByteBuffer dummyByteBuffer = ByteBuffer.allocate(0);

    private ByteBuffer peerNetData = null;

    private boolean sslShutdown = false;

    /**
     * Sets the flag to wakeup Selector After RegisterForWrite is called.
     * @since 1.4.7
     */
    public static void setWakeupSelectorAfterRegisterWrite(boolean flag) {
        wakeupSelectorAfterRegisterWrite = flag;
    }

    /**
     * Returns wakeupSelectorAfterRegisterWrite the flag that controls if wakeup is called on Selector
     * after RegisterForWrite is called.
     * @since 1.4.7
     */
    public static boolean getWakeupSelectorAfterRegisterWrite() {
        return wakeupSelectorAfterRegisterWrite;
    }

    /**
     * Sets the flag to wakeup Selector After RegisterForRead is called.
     * @since 1.4.7
     */
    public static void setWakeupSelectorAfterRegisterRead(boolean flag) {
        wakeupSelectorAfterRegisterRead = flag;
    }

    /**
     * Returns wakeupSelectorAfterRegisterRead the flag that controls if wakeup is called on Selector
     * after RegisterForRead is called.
     * @since 1.4.7
     */
    public static boolean getWakeupSelectorAfterRegisterRead() {
        return wakeupSelectorAfterRegisterRead;
    }

    /**
     * Sets the maximum count of thread allowed to run objects of this class at a time.
     * @since 1.4.7
     */
    public static void setMaxThreadAccessCount(int count) {
        if (count < 3 && count != -1)
            throw new IllegalArgumentException(""Value should be >=3 or -1"");
        maxThreadAccessCount = count;
    }

    /**
     * Returns the maximum count of thread allowed to run objects of this class at a time.
     * @since 1.4.7
     */
    public static int getMaxThreadAccessCount() {
        return maxThreadAccessCount;
    }

    //v1.4.7
    private ByteBufferOutputStream byteBufferOutputStream;

    public NonBlockingClientHandler(int instanceCount) {
        super(instanceCount);
    }

    public NonBlockingClientHandler() {
        super();
    }

    public void clean() {
        logger.finest(""Starting clean - "" + getName());
        if (threadAccessCount != 0) {
            logger.warning(""Thread Access Count was not 0!: "" + threadAccessCount);
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
            threadAccessCount = 0;
        }
        while (readByteBuffer.isEmpty() == false) {
            try {
                getServer().getByteBufferPool().returnObject(readByteBuffer.remove(0));
            } catch (Exception er) {
                logger.warning(""Error in returning read ByteBuffer to pool: "" + er);
                break;
            }
        }
        while (writeByteBuffer.isEmpty() == false) {
            try {
                getServer().getByteBufferPool().returnObject(writeByteBuffer.remove(0));
            } catch (Exception er) {
                appLogger.warning(""Error in returning write ByteBuffer to pool: "" + er);
                break;
            }
        }
        if (peerNetData != null) {
            try {
                getServer().getByteBufferPool().returnObject(peerNetData);
            } catch (Exception er) {
                appLogger.warning(""Error in returning peerNetData to pool: "" + er);
            }
        }
        if (selectionKey != null) {
            selectionKey.cancel();
            selectionKey.selector().wakeup();
            selectionKey = null;
        }
        willReturn = false;
        waitingForFinalWrite = false;
        socketChannel = null;
        if (byteBufferOutputStream != null) {
            byteBufferOutputStream.close();
        }
        super.clean();
        //1.4.5
        clientWriteHandler = null;
        byteBufferOutputStream = null;
        sslShutdown = false;
        logger.finest(""Finished clean - "" + getName());
    }

    protected void finalize() throws Throwable {
        clean();
        super.finalize();
    }

    public void handleClient(TheClient theClient) throws Exception {
        super.handleClient(theClient);
        //v1.4.5
        setClientWriteHandler(theClient.getClientWriteHandler());
        //1.4.5
        setSocketChannel(theClient.getSocketChannel());
    }

    protected void setInputStream(InputStream in) throws IOException {
        this.in = in;
        if (getDataMode(DataType.IN) == DataMode.STRING) {
            b_in = null;
            o_in = null;
            bufferedReader = null;
        } else if (getDataMode(DataType.IN) == DataMode.OBJECT) {
            b_in = null;
            bufferedReader = null;
            o_in = new ObjectInputStream(in);
        } else if (getDataMode(DataType.IN) == DataMode.BYTE || getDataMode(DataType.IN) == DataMode.BINARY) {
            o_in = null;
            bufferedReader = null;
            b_in = null;
        }
    }

    public BufferedReader getBufferedReader() {
        throw new IllegalStateException(""Access to BufferedReader in not allowed in Non-Blocking mode!"");
    }

    public void closeConnection() {
        logger.finest(""inside"");
        synchronized (this) {
            if (connection == false)
                return;
            if (waitingForFinalWrite)
                return;
            if (getSelectionKey() != null && getSelectionKey().isValid() && lost == false) {
                waitingForFinalWrite = true;
            } else {
                connection = false;
            }
        }
        try {
            if (getSocketChannel() != null && socket != null) {
                if (waitingForFinalWrite) {
                    try {
                        waitTillFullyWritten();
                    } catch (Exception error) {
                        logger.warning(""Error in waitingForFinalWrite : "" + error);
                        if (logger.isLoggable(Level.FINE)) {
                            logger.fine(""StackTrace:\n"" + MyString.getStackTrace(error));
                        }
                    }
                }
                //end of waitingForFinalWrite
                if (isSecure() == true) {
                    sslShutdown = true;
                    if (lost == false && sslEngine.isOutboundDone() == false) {
                        logger.finest(""SSL isOutboundDone is false"");
                        if (byteBufferOutputStream.doShutdown() == false) {
                            return;
                        }
                    } else if (sslEngine.isOutboundDone()) {
                        logger.finest(""SSL Outbound is done."");
                    }
                }
                doPostCloseActivity();
            }
            //if socket
        } catch (IOException e) {
            logger.warning(""Error in closeConnection : "" + e);
            if (logger.isLoggable(Level.FINE)) {
                logger.fine(""StackTrace:\n"" + MyString.getStackTrace(e));
            }
        } catch (NullPointerException npe) {
            logger.fine(""NullPointerException: "" + npe);
            if (logger.isLoggable(Level.FINE)) {
                logger.fine(""StackTrace:\n"" + MyString.getStackTrace(npe));
            }
        }
    }

    private void doPostCloseActivity() throws IOException {
        connection = false;
        byteBufferOutputStream.forceNotify();
        getSelectionKey().cancel();
        if (getServer() != null) {
            getServer().getSelector().wakeup();
        }
        synchronized (this) {
            if (hasEvent(ClientEvent.MAX_CON) == false) {
                notifyCloseOrLost();
            }
            if (getSocketChannel().isOpen()) {
                logger.finest(""Closing SocketChannel"");
                getSocketChannel().close();
            }
        }
    }

    public boolean closeIfSSLOutboundDone() {
        if (isSecure() == false)
            throw new IllegalStateException(""Client is not in secure mode!"");
        if (sslEngine.isOutboundDone()) {
            logger.finest(""SSL Outbound is done."");
            try {
                if (getSocketChannel().isOpen()) {
                    logger.finest(""Closing SocketChannel"");
                    getSocketChannel().close();
                }
            } catch (IOException e) {
                logger.fine(""IGNORE: Error in Closing SocketChannel: "" + e);
            }
            return true;
        } else {
            logger.finest(""SSL Outbound is not done."");
            return false;
        }
    }

    /**
     * waitTillFullyWritten
     * @since 1.4.7
     */
    public void waitTillFullyWritten() {
        Object waitLock = new Object();
        if (byteBufferOutputStream.isDataAvailableForWrite(waitLock)) {
            if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                logger.finest(""Waiting "" + getName());
            }
            try {
                synchronized (waitLock) {
                    //2 min max
                    waitLock.wait(1000 * 60 * 2);
                }
            } catch (InterruptedException ie) {
                logger.warning(""Error: "" + ie);
            }
            if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                logger.finest(""Done. "" + getName());
            }
        }
    }

    public void run() {
        if (unprocessedClientEvents.isEmpty()) {
            logger.finest(""No unprocessed ClientEvents!"");
            return;
        }
        synchronized (this) {
            if (willReturn) {
                return;
            } else {
                threadAccessCount++;
            }
        }
        ClientEvent currentEvent = (ClientEvent) unprocessedClientEvents.poll();
        if (currentEvent == null) {
            threadEvent.set(null);
            logger.finest(""No unprocessed ClientEvents! pool was null"");
            return;
        }
        if (logger.isLoggable(Level.FINEST)) {
            StringBuilder sb = new StringBuilder();
            sb.append(""Running "").append(getName());
            sb.append("" using "");
            sb.append(Thread.currentThread().getName());
            sb.append("" for "");
            synchronized (clientEvents) {
                if (clientEvents.size() > 1) {
                    sb.append(currentEvent + "", Current Events - "" + clientEvents);
                } else {
                    sb.append(currentEvent);
                }
            }
            logger.finest(sb.toString());
        }
        logger.finest(""threadAccessCount: "" + threadAccessCount);
        threadEvent.set(currentEvent);
        try {
            if (maxThreadAccessCount != -1 && threadAccessCount > maxThreadAccessCount) {
                logger.warning(""ThreadAccessCount can't go beyond "" + maxThreadAccessCount + "": "" + threadAccessCount);
                if (Assertion.isEnabled()) {
                    throw new AssertionError(""ThreadAccessCount can't go beyond "" + maxThreadAccessCount + "": "" + threadAccessCount);
                }
                return;
            }
            if (socket == null)
                throw new SocketException(""Socket was null!"");
            if (getThreadEvent() == ClientEvent.ACCEPT || getThreadEvent() == ClientEvent.MAX_CON) {
                prepareForRun();
                Assertion.affirm(willReturn == false, ""WillReturn has to be false!: "" + willReturn);
            }
            if (getThreadEvent() == ClientEvent.MAX_CON) {
                processMaxConnection(currentEvent);
            }
            try {
                if (getThreadEvent() == ClientEvent.ACCEPT) {
                    registerForRead();
                    clientEventHandler.gotConnected(this);
                    if (authorised == false) {
                        if (clientAuthenticationHandler == null && authenticator == null) {
                            authorised = true;
                            logger.finest(""No Authenticator "" + getName() + "" so return thread."");
                        } else {
                            if (clientAuthenticationHandler != null) {
                                AuthStatus authStatus = null;
                                do {
                                    authStatus = processAuthorisation();
                                } while (authStatus == AuthStatus.FAILURE);
                                if (authStatus == AuthStatus.SUCCESS)
                                    authorised = true;
                            } else {
                                processAuthorisation();
                            }
                            if (authorised)
                                logger.finest(""Authentication done "" + getName() + "", so return thread."");
                            else
                                logger.finest(""askAuthentication() done "" + getName() + "", so return thread."");
                        }
                    }
                    //end authorised
                    //return thread to pool
                    returnThread();
                    return;
                }
                if (connection && getThreadEvent() == ClientEvent.READ) {
                    if (processRead())
                        return;
                }
                if (connection && getThreadEvent() == ClientEvent.WRITE) {
                    if (processWrite())
                        return;
                }
            } catch (SocketException e) {
                appLogger.finest(""SocketException - Client ["" + getHostAddress() + ""]: "" + e.getMessage());
                //e.printStackTrace();
                lost = true;
            } catch (AppException e) {
                //errors from Application
                appLogger.finest(""AppException "" + Thread.currentThread().getName() + "": "" + e.getMessage());
            } catch (javax.net.ssl.SSLException e) {
                lost = true;
                if (Assertion.isEnabled()) {
                    appLogger.info(""SSLException - Client ["" + getHostAddress() + ""] "" + Thread.currentThread().getName() + "": "" + e);
                } else {
                    appLogger.warning(""SSLException - Client ["" + getHostAddress() + ""]: "" + e);
                }
            } catch (ConnectionLostException e) {
                lost = true;
                if (e.getMessage() != null)
                    appLogger.finest(""Connection lost "" + Thread.currentThread().getName() + "": "" + e.getMessage());
                else
                    appLogger.finest(""Connection lost "" + Thread.currentThread().getName());
            } catch (ClosedChannelException e) {
                lost = true;
                appLogger.finest(""Channel closed "" + Thread.currentThread().getName() + "": "" + e);
            } catch (IOException e) {
                lost = true;
                appLogger.fine(""IOError "" + Thread.currentThread().getName() + "": "" + e);
            } catch (AssertionError er) {
                logger.warning(""[AssertionError] "" + getName() + "" "" + er);
                if (logger.isLoggable(Level.FINEST)) {
                    logger.finest(""StackTrace "" + Thread.currentThread().getName() + "": "" + MyString.getStackTrace(er));
                }
                assertionSystemExit();
            } catch (Error er) {
                logger.warning(""[Error] "" + er);
                if (logger.isLoggable(Level.FINEST)) {
                    logger.finest(""StackTrace "" + Thread.currentThread().getName() + "": "" + MyString.getStackTrace(er));
                }
                if (Assertion.isEnabled()) {
                    assertionSystemExit();
                }
                lost = true;
            } catch (RuntimeException re) {
                logger.warning(""[RuntimeException] "" + MyString.getStackTrace(re));
                if (Assertion.isEnabled()) {
                    assertionSystemExit();
                }
                lost = true;
            }
            if (getThreadEvent() != ClientEvent.MAX_CON) {
                notifyCloseOrLost();
            }
            if (connection) {
                logger.finest(Thread.currentThread().getName() + "" calling closeConnection()"");
                closeConnection();
            }
            if (connection == true && lost == true && waitingForFinalWrite) {
                byteBufferOutputStream.forceNotify();
            }
        } catch (javax.net.ssl.SSLException se) {
            logger.warning(""SSLException "" + Thread.currentThread().getName() + "" - "" + se);
        } catch (IOException ie) {
            logger.warning(""IOError "" + Thread.currentThread().getName() + "" - Closing Client : "" + ie);
        } catch (RuntimeException re) {
            logger.warning(""[RuntimeException] "" + getName() + "" "" + Thread.currentThread().getName() + "" - "" + MyString.getStackTrace(re));
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
        } catch (Exception e) {
            logger.warning(""Error "" + Thread.currentThread().getName() + "" - Event:"" + getThreadEvent() + "" - Socket:"" + socket + "" : "" + e);
            logger.fine(""StackTrace: "" + getName() + ""\n"" + MyString.getStackTrace(e));
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
        } catch (Error e) {
            logger.warning(""Error "" + Thread.currentThread().getName() + "" - Event:"" + getThreadEvent() + "" - Socket:"" + socket + "" : "" + e);
            logger.fine(""StackTrace: "" + getName() + ""\n"" + MyString.getStackTrace(e));
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
        }
        synchronized (this) {
            try {
                if (getSelectionKey() != null && getSelectionKey().isValid()) {
                    logger.finest(""Canceling SelectionKey"");
                    getSelectionKey().cancel();
                }
                if (socket != null && socket.isClosed() == false) {
                    logger.finest(""Closing Socket"");
                    socket.close();
                }
                if (getSocketChannel() != null && getSocketChannel().isOpen()) {
                    logger.finest(""Closing SocketChannel"");
                    socketChannel.close();
                }
            } catch (Exception re) {
                logger.warning(""Error closing Socket/Channel: "" + re);
            }
        }
        //end synchronized
        willClean = true;
        returnClientData();
        boolean returnClientHandler = false;
        synchronized (lockObj) {
            returnThread();
            returnClientHandler = checkReturnClientHandler();
        }
        if (returnClientHandler) {
            //return to pool
            returnClientHandler();
        }
    }

    protected boolean checkReturnClientHandler() {
        if (willReturn == false) {
            willReturn = true;
            return true;
        }
        return false;
    }

    /**
     * Process read
     * @return value indicates if the thread should return form run()
     */
    private boolean processRead() throws Exception {
        if (doRead()) {
            //return to pool
            returnThread();
            return true;
        } else {
            return false;
        }
    }

    private boolean doRead() throws Exception {
        int count = 0;
        int fullCount = 0;
        while (true) {
            try {
                if (peerNetData == null) {
                    peerNetData = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
                }
                count = getSocketChannel().read(peerNetData);
                if (count < 0) {
                    //logger.finest(""SocketChannel read was ""+count+""!"");
                    getServer().getByteBufferPool().returnObject(peerNetData);
                    peerNetData = null;
                    break;
                } else {
                    fullCount += count;
                }
                // Make readable
                peerNetData.flip();
                ByteBuffer peerAppData = null;
                //--
                if (sslEngine != null) {
                    SSLEngineResult res;
                    peerAppData = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
                    do {
                        res = sslEngine.unwrap(peerNetData, peerAppData);
                        logger.info(""Unwrapping:\n"" + res);
                    } while (res.getStatus() == SSLEngineResult.Status.OK && res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP && res.bytesProduced() == 0);
                    if (res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED) {
                        logger.info(""HandshakeStatus.FINISHED!"");
                        finishInitialHandshake();
                    }
                    if (peerAppData.position() == 0 && res.getStatus() == SSLEngineResult.Status.OK && peerNetData.hasRemaining()) {
                        logger.info(""peerNetData hasRemaining and pos=0!"");
                        res = sslEngine.unwrap(peerNetData, peerAppData);
                        logger.info(""Unwrapping:\n"" + res);
                    }
                    /*
					 * OK, OVERFLOW, UNDERFLOW, CLOSED
					 */
                    status = res.getStatus();
                    handshakeStatus = res.getHandshakeStatus();
                    if (status != SSLEngineResult.Status.BUFFER_OVERFLOW) {
                        logger.warning(""Buffer overflow: "" + res.toString());
                    } else if (status == SSLEngineResult.Status.CLOSED) {
                        logger.fine(""Connection is being closed by peer."");
                        lost = true;
                        System.out.println(""NEdd to code for shutdow of SSL"");
                        break;
                    }
                    peerNetData.compact();
                    peerAppData.flip();
                    if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_TASK || handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP || handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED) {
                        doHandshake();
                    }
                    //return peerAppData.remaining();
                    logger.fine(""peerAppData.remaining(): "" + peerAppData.remaining());
                } else {
                    peerAppData = peerNetData;
                    peerNetData = null;
                }
                //--
                readByteBuffer.add(peerAppData);
                peerAppData = null;
            } catch (Exception error) {
                logger.finest(""Error in data read: "" + error);
                if (sslEngine != null)
                    sslEngine.closeInbound();
                lost = true;
                synchronized (getInputStream()) {
                    getInputStream().notifyAll();
                }
                throw error;
            }
            if (count == 0)
                break;
        }
        //end while
        if (count < 0) {
            logger.finest(""SocketChannel read was "" + count + ""!"");
            if (sslEngine != null)
                sslEngine.closeInbound();
            lost = true;
            synchronized (getInputStream()) {
                getInputStream().notifyAll();
            }
        } else {
            logger.finest(fullCount + "" bytes read"");
            if (fullCount != 0) {
                updateLastCommunicationTime();
                synchronized (getInputStream()) {
                    //if any are waiting
                    getInputStream().notify();
                }
                if (hasEvent(ClientEvent.ACCEPT) == false) {
                    processGotDataInBuffers();
                }
            }
            //check if any data was read but not yet processed
            while (getInputStream().available() > 0) {
                logger.finest(""Sending again for processing..."");
                if (hasEvent(ClientEvent.ACCEPT) == false) {
                    processGotDataInBuffers();
                    break;
                } else {
                    synchronized (getInputStream()) {
                        getInputStream().notifyAll();
                    }
                    Thread.sleep(100);
                }
            }
            if (connection) {
                registerForRead();
                //getSelectionKey().selector().wakeup();
                return true;
            }
        }
        //end of else
        logger.finest(""We don't have connection, lets return all resources."");
        return false;
    }

    /**
     * Process write
     * @return value indicates if the thread should return form run()
     */
    private boolean processWrite() throws IOException {
        if (doWrite()) {
            //return to pool
            returnThread();
            return true;
        } else {
            return false;
        }
    }

    private boolean doWrite() throws IOException {
        if (sslShutdown) {
            if (byteBufferOutputStream.doShutdown() == false) {
                return true;
            }
            doPostCloseActivity();
            logger.finest(""We don't have connection, lets return all resources."");
            return false;
        }
        updateLastCommunicationTime();
        boolean flag = byteBufferOutputStream.writeAllByteBuffer();
        if (flag == false) {
            registerWrite();
        } else if (/*flag==true && */
        clientWriteHandler != null) {
            clientWriteHandler.handleWrite(this);
        }
        if (connection) {
            return true;
        } else {
            logger.finest(""We don't have connection, lets return all resources."");
            return false;
        }
    }

    protected void returnThread() {
        //System.out.println(""returnThread.."");
        //(new Exception()).printStackTrace();
        threadAccessCount--;
        Assertion.affirm(threadAccessCount >= 0, ""ThreadAccessCount went less the 0! Value: "" + threadAccessCount);
        //return is done at ClientThread end
        removeEvent((ClientEvent) threadEvent.get());
    }

    protected void returnClientHandler() {
        logger.finest(getName());
        try {
            for (int i = 0; threadAccessCount != 0; i++) {
                if (i == 100) {
                    logger.warning(""ClientHandler must have got into a loop waiting for thread to free up! ThreadAccessCount="" + threadAccessCount);
                    threadAccessCount = 0;
                    if (Assertion.isEnabled()) {
                        assertionSystemExit();
                    } else {
                        break;
                    }
                }
                if (threadAccessCount <= 0)
                    break;
                logger.finest(""Waiting for other thread of "" + getName() + "" to finish"");
                Thread.sleep(60);
            }
        } catch (InterruptedException ie) {
            appLogger.warning(""InterruptedException: "" + ie);
        }
        super.returnClientHandler();
    }

    public void setDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (getDataMode(dataType) == dataMode)
            return;
        appLogger.fine(""Setting Type:"" + dataType + "", Mode:"" + dataMode);
        super.checkDataModeSet(dataMode, dataType);
        setDataModeNonBlocking(dataMode, dataType);
    }

    private void setDataModeNonBlocking(DataMode dataMode, DataType dataType) throws IOException {
        logger.finest(""ENTER"");
        if (dataMode == DataMode.STRING) {
            if (dataType == DataType.OUT) {
                if (dataModeOUT == DataMode.BYTE || dataModeOUT == DataMode.BINARY) {
                    dataModeOUT = dataMode;
                } else if (dataModeOUT == DataMode.OBJECT) {
                    dataModeOUT = dataMode;
                    o_out.flush();
                    o_out = null;
                    b_out = new BufferedOutputStream(out);
                } else {
                    Assertion.affirm(false, ""Unknown DataType.OUT DataMode - "" + dataModeOUT);
                }
                Assertion.affirm(b_out != null, ""BufferedOutputStream is still null!"");
                Assertion.affirm(o_out == null, ""ObjectOutputStream is still not null!"");
            } else if (dataType == DataType.IN) {
                dataModeIN = dataMode;
                if (o_in != null) {
                    if (o_in.available() != 0)
                        logger.warning(""Data looks to be present in ObjectInputStream"");
                    o_in = null;
                }
                b_in = null;
                bufferedReader = null;
                //input stream will work
                Assertion.affirm(in != null, ""InputStream is still null!"");
                Assertion.affirm(b_in == null, ""BufferedInputStream is still not null!"");
                Assertion.affirm(bufferedReader == null, ""BufferedReader is still not null!"");
            }
        } else if (dataMode == DataMode.OBJECT) {
            if (dataType == DataType.IN) {
                //we will disable this for now
                throw new IllegalArgumentException(""Can't set DataType.IN mode to OBJECT when blocking mode is set as false!"");
            }
            if (dataType == DataType.OUT) {
                dataModeOUT = dataMode;
                b_out = null;
                o_out = new ObjectOutputStream(out);
                Assertion.affirm(o_out != null, ""ObjectOutputStream is still null!"");
                o_out.flush();
            } else if (dataType == DataType.IN) {
                dataModeIN = dataMode;
                b_in = null;
                bufferedReader = null;
                registerForRead();
                //will block
                o_in = new ObjectInputStream(in);
                Assertion.affirm(o_in != null, ""ObjectInputStream is still null!"");
            }
        } else if (dataMode == DataMode.BYTE || dataMode == DataMode.BINARY) {
            if (dataType == DataType.OUT) {
                if (dataModeOUT == DataMode.STRING || dataModeOUT == DataMode.BYTE || dataModeOUT == DataMode.BINARY) {
                    dataModeOUT = dataMode;
                } else if (dataModeOUT == DataMode.OBJECT) {
                    dataModeOUT = dataMode;
                    o_out = null;
                    b_out = new BufferedOutputStream(out);
                } else {
                    Assertion.affirm(false, ""Unknown DataType.OUT - DataMode: "" + dataModeOUT);
                }
                Assertion.affirm(b_out != null, ""BufferedOutputStream is still null!"");
            } else if (dataType == DataType.IN) {
                dataModeIN = dataMode;
                o_in = null;
                bufferedReader = null;
                b_in = null;
                //input stream will work
                Assertion.affirm(in != null, ""InputStream is still null!"");
            } else {
                throw new IllegalArgumentException(""Unknown DataType : "" + dataType);
            }
        } else {
            throw new IllegalArgumentException(""Unknown DataMode : "" + dataMode);
        }
    }

    protected byte[] readInputStream() throws IOException {
        return readInputStream(getInputStream());
    }

    public void updateInputOutputStreams() throws IOException {
        byteBufferOutputStream = new ByteBufferOutputStream(writeByteBuffer, this);
        setInputStream(new ByteBufferInputStream(readByteBuffer, this, getCharset()));
        setOutputStream(byteBufferOutputStream);
        //logger.warning(""updateInputOutputStreams: ""+sslEngine);
        if (sslEngine != null) {
            sslEngine.setUseClientMode(false);
            sslEngine.beginHandshake();
            handshakeStatus = sslEngine.getHandshakeStatus();
            initialHandshakeStatus = true;
            /*
			try {
				doHandshake();
			} catch(Exception e) {
				logger.warning(""Error: ""+e);
				throw new IOException(e.toString());
			}
			*/
        }
    }

    public boolean getBlockingMode() {
        return false;
    }

    public void setSocketChannel(SocketChannel socketChannel) {
        this.socketChannel = socketChannel;
    }

    public SocketChannel getSocketChannel() {
        return socketChannel;
    }

    public void setSelectionKey(SelectionKey selectionKey) {
        this.selectionKey = selectionKey;
    }

    public SelectionKey getSelectionKey() {
        if (selectionKey == null)
            selectionKey = getSocketChannel().keyFor(getServer().getSelector());
        return selectionKey;
    }

    private void processGotDataInBuffers() throws AppException, ConnectionLostException, ClassNotFoundException, IOException {
        if (getInputStream().available() == 0)
            return;
        logger.finest(""Trying to process got data.. DataMode.IN="" + dataModeIN);
        AuthStatus authStatus = null;
        //--For debug
        ((ByteBufferInputStream) getInputStream()).dumpContent();
        String temp = null;
        String rec = null;
        Object recObject = null;
        byte[] recByte = null;
        boolean timeToCheckForNewLineMiss = false;
        do {
            //updateLastCommunicationTime();
            if (dataModeIN == DataMode.STRING) {
                ByteBufferInputStream bbin = (ByteBufferInputStream) getInputStream();
                timeToCheckForNewLineMiss = true;
                while (bbin.isLineReady()) {
                    rec = bbin.readLine();
                    if (rec == null) {
                        lost = true;
                        return;
                    }
                    if (getCommunicationLogging() && authorised == true) {
                        appLogger.log(Level.FINE, ""Got STRING [{0}] : {1}"", new Object[] { getHostAddress(), rec });
                    }
                    totalReadBytes = totalReadBytes + rec.length();
                    if (authorised == false)
                        authStatus = clientAuthenticationHandler.handleAuthentication(this, rec);
                    else
                        clientCommandHandler.handleCommand(this, rec);
                    if (isClosed() == true)
                        return;
                    while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                    if (authStatus == AuthStatus.SUCCESS)
                        authorised = true;
                    if (dataModeIN != DataMode.STRING) {
                        break;
                    }
                    timeToCheckForNewLineMiss = false;
                }
                //end of while
                if (timeToCheckForNewLineMiss && bbin.availableOnlyInByteBuffer() == 0) {
                    return;
                } else {
                    timeToCheckForNewLineMiss = false;
                }
            }
            //if(dataModeIN == DataMode.OBJECT) {
            while (dataModeIN == DataMode.OBJECT && o_in != null) {
                //not sure if all bytes are in buffer..~ may need more read.. will get stuck..
                recObject = o_in.readObject();
                if (recObject == null) {
                    lost = true;
                    return;
                }
                if (getCommunicationLogging() && authorised == true) {
                    appLogger.log(Level.FINE, ""Got OBJECT [{0}] : {1}"", new Object[] { getHostAddress(), recObject.toString() });
                }
                totalReadBytes = totalReadBytes + 1;
                if (authorised == false)
                    authStatus = clientAuthenticationHandler.handleAuthentication(this, recObject);
                else
                    clientObjectHandler.handleObject(this, recObject);
                if (isClosed() == true)
                    return;
                while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                if (authStatus == AuthStatus.SUCCESS)
                    authorised = true;
            }
            //}
            //if(dataModeIN == DataMode.BYTE) {
            while (dataModeIN == DataMode.BYTE && getInputStream().available() != 0) {
                rec = readBytes();
                if (rec == null) {
                    lost = true;
                    return;
                }
                if (getCommunicationLogging() && authorised == true) {
                    appLogger.log(Level.FINE, ""Got BYTE [{0}] : {1}"", new Object[] { getHostAddress(), rec });
                }
                totalReadBytes = totalReadBytes + rec.length();
                if (authorised == false)
                    authStatus = clientAuthenticationHandler.handleAuthentication(this, rec);
                else
                    clientCommandHandler.handleCommand(this, rec);
                if (isClosed() == true)
                    return;
                while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                if (authStatus == AuthStatus.SUCCESS)
                    authorised = true;
            }
            //} else if(dataModeIN == DataMode.BINARY) {
            while (dataModeIN == DataMode.BINARY && getInputStream().available() != 0) {
                recByte = readBinary();
                if (recByte == null) {
                    lost = true;
                    return;
                }
                if (getCommunicationLogging() && authorised == true) {
                    if (getServer().isRawCommunicationLogging()) {
                        if (getServer().getRawCommunicationMaxLength() > 0 && recByte.length > getServer().getRawCommunicationMaxLength()) {
                            appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}; RAW: {2}{3}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length), new String(recByte, 0, getServer().getRawCommunicationMaxLength(), charset), ""..."" });
                        } else {
                            appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}; RAW: {2}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length), new String(recByte, charset) });
                        }
                    } else {
                        appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length) });
                    }
                } else if (getCommunicationLogging()) {
                    appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length) });
                }
                totalReadBytes = totalReadBytes + recByte.length;
                if (authorised == false)
                    authStatus = clientAuthenticationHandler.handleAuthentication(this, recByte);
                else
                    clientBinaryHandler.handleBinary(this, recByte);
                if (isClosed() == true)
                    return;
                while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                if (authStatus == AuthStatus.SUCCESS)
                    authorised = true;
            }
            //} else {
            if (dataModeIN != DataMode.STRING && dataModeIN != DataMode.OBJECT && dataModeIN != DataMode.BYTE && dataModeIN != DataMode.BINARY) {
                throw new IllegalStateException(""Incoming DataMode is not supported : "" + dataModeIN);
            }
        } while (getInputStream().available() != 0);
    }

    public void registerForRead() throws IOException, ClosedChannelException {
        //System.out.println(""registerForRead.."");
        //(new Exception()).printStackTrace();
        try {
            if (getSelectionKey() == null) {
                boolean flag = getServer().registerChannel(getSocketChannel(), SelectionKey.OP_READ, this);
                if (flag) {
                    logger.finest(""Adding OP_READ as interest Ops for "" + getName());
                } else if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                    logger.finest(""OP_READ is already present in interest Ops for "" + getName());
                }
            } else if (getSelectionKey().isValid()) {
                if ((getSelectionKey().interestOps() & SelectionKey.OP_READ) == 0) {
                    logger.finest(""Adding OP_READ to interest Ops for "" + getName());
                    removeEvent(ClientEvent.READ);
                    getSelectionKey().interestOps(getSelectionKey().interestOps() | SelectionKey.OP_READ);
                    if (wakeupSelectorAfterRegisterRead) {
                        getServer().getSelector().wakeup();
                    }
                } else {
                    if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                        logger.finest(""OP_READ is already present in interest Ops for "" + getName());
                    }
                }
            } else {
                throw new IOException(""SelectionKey is invalid!"");
            }
        } catch (CancelledKeyException e) {
            throw new IOException(""SelectionKey is cancelled!"");
        }
    }

    public void registerForWrite() throws IOException, ClosedChannelException {
        if (hasEvent(ClientEvent.RUN_BLOCKING) || hasEvent(ClientEvent.MAX_CON_BLOCKING)) {
            throw new IllegalStateException(""This method is only allowed under Non-Blocking mode."");
        }
        if (clientWriteHandler == null) {
            throw new IllegalStateException(""ClientWriteHandler has not been set!"");
        }
        registerWrite();
    }

    public void registerWrite() throws IOException {
        //System.out.println(""registerWrite.."");
        //(new Exception()).printStackTrace();
        try {
            if (getSelectionKey() == null) {
                boolean flag = getServer().registerChannel(getSocketChannel(), SelectionKey.OP_WRITE, this);
                if (flag) {
                    logger.finest(""Adding OP_WRITE as interest Ops for "" + getName());
                } else if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                    logger.finest(""OP_WRITE is already present in interest Ops for "" + getName());
                }
            } else if (getSelectionKey().isValid()) {
                if ((getSelectionKey().interestOps() & SelectionKey.OP_WRITE) == 0) {
                    logger.finest(""Adding OP_WRITE to interest Ops for "" + getName());
                    removeEvent(ClientEvent.WRITE);
                    getSelectionKey().interestOps(getSelectionKey().interestOps() | SelectionKey.OP_WRITE);
                    if (wakeupSelectorAfterRegisterWrite) {
                        getServer().getSelector().wakeup();
                    }
                } else {
                    if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                        logger.finest(""OP_WRITE is already present in interest Ops for "" + getName());
                    }
                }
            } else {
                throw new IOException(""SelectionKey is invalid!"");
            }
        } catch (CancelledKeyException e) {
            throw new IOException(""SelectionKey is cancelled!"");
        }
    }

    protected void setClientWriteHandler(ClientWriteHandler handler) {
        clientWriteHandler = handler;
    }

    /**
     * Returns number of thread currently in this object.
     * @since 1.4.6
     */
    public int getThreadAccessCount() {
        return threadAccessCount;
    }

    private void doHandshake() throws Exception {
        while (true) {
            SSLEngineResult res;
            logger.fine(""handshakeStatus: "" + handshakeStatus);
            if (handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED) {
                if (initialHandshakeStatus) {
                    finishInitialHandshake();
                }
                return;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_TASK) {
                doTasks();
                continue;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {
                /*
					doRead();

					if(initialHandshakeStatus && 
							status == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
						registerForRead();
					}
					*/
                return;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP) {
                ByteBuffer netData = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
                //netData.clear();
                res = sslEngine.wrap(dummyByteBuffer, netData);
                logger.info(""Wrapping:\n"" + res);
                assert res.bytesProduced() != 0 : ""No net data produced during handshake wrap."";
                assert res.bytesConsumed() == 0 : ""App data consumed during handshake wrap."";
                handshakeStatus = res.getHandshakeStatus();
                //netData.flip(); -- no need to flip will be done when writing to sc
                byteBufferOutputStream.addEncryptedByteBuffer(netData);
                if (!doWrite()) {
                    return;
                }
                //back to loop
                continue;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
                assert false : ""doHandshake() should never reach the NOT_HANDSHAKING state"";
                return;
            }
            //if
        }
        //loop
    }

    private void doTasks() {
        Runnable task;
        while ((task = sslEngine.getDelegatedTask()) != null) {
            logger.fine(""Running the task.. START "");
            task.run();
            logger.fine(""Running the task.. END"");
        }
        handshakeStatus = sslEngine.getHandshakeStatus();
        logger.fine(""handshakeStatus: "" + handshakeStatus);
    }

    private void finishInitialHandshake() throws IOException {
        initialHandshakeStatus = false;
    }

    public boolean getInitialHandshakeStatus() {
        return initialHandshakeStatus;
    }

    public ByteBuffer encrypt(ByteBuffer src) throws IOException {
        if (initialHandshakeStatus) {
            logger.fine(""Writing not possible during handshake!"");
            //Exception e = new Exception();
            //e.printStackTrace();
            return null;
        }
        ByteBuffer dest = null;
        boolean isException = false;
        try {
            src.flip();
            dest = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
            //dest.clear();
            SSLEngineResult res = sslEngine.wrap(src, dest);
            logger.info(""Wrapping:\n"" + res);
            //dest.flip();
            return dest;
        } catch (IOException e) {
            logger.warning(""IOException:"" + e);
            isException = true;
            throw e;
        } catch (Exception e) {
            logger.warning(""Exception:"" + e);
            isException = true;
            throw new IOException(e.getMessage());
        } finally {
            if (isException == true && dest != null) {
                try {
                    getServer().getByteBufferPool().returnObject(dest);
                } catch (Exception er) {
                    logger.warning(""Error in returning ByteBuffer to pool: "" + er);
                }
            }
        }
    }
}
","// NonBlockingClientHandler_0Test.java
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NonBlockingClientHandler}.
* It contains ten unit test cases for the {@link NonBlockingClientHandler#getWakeupSelectorAfterRegisterWrite()} method.
*/
class NonBlockingClientHandler_0Test {","// NonBlockingClientHandler_0Test.java
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NonBlockingClientHandler}.
* It contains ten unit test cases for the {@link NonBlockingClientHandler#getWakeupSelectorAfterRegisterWrite()} method.
*/
class NonBlockingClientHandler_0Test {
"
169ffb2a-cba5-4cf3-8ed2-062b4dcddc4f,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/impl/NonBlockingClientHandler_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 16330 tokens (12330 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// NonBlockingClientHandler.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;

public class NonBlockingClientHandler extends BasicClientHandler {

    private static final Logger logger = Logger.getLogger(NonBlockingClientHandler.class.getName());

    //v1.4.5
    protected ClientWriteHandler clientWriteHandler;

    private SocketChannel socketChannel;

    protected ArrayList readByteBuffer = new ArrayList();

    protected ArrayList writeByteBuffer = new ArrayList();

    protected SelectionKey selectionKey;

    protected volatile int threadAccessCount = 0;

    protected volatile boolean willReturn;

    protected volatile boolean waitingForFinalWrite;

    //one for each event ACCEPT, WRITE, READ
    private static int maxThreadAccessCount = 5;

    private static boolean wakeupSelectorAfterRegisterWrite = true;

    private static boolean wakeupSelectorAfterRegisterRead = true;

    //nio ssl
    //private final SSLSession session;
    private boolean initialHandshakeStatus = false;

    private SSLEngineResult.HandshakeStatus handshakeStatus;

    private SSLEngineResult.Status status = null;

    private ByteBuffer dummyByteBuffer = ByteBuffer.allocate(0);

    private ByteBuffer peerNetData = null;

    private boolean sslShutdown = false;

    /**
     * Sets the flag to wakeup Selector After RegisterForWrite is called.
     * @since 1.4.7
     */
    public static void setWakeupSelectorAfterRegisterWrite(boolean flag) {
        wakeupSelectorAfterRegisterWrite = flag;
    }

    /**
     * Returns wakeupSelectorAfterRegisterWrite the flag that controls if wakeup is called on Selector
     * after RegisterForWrite is called.
     * @since 1.4.7
     */
    public static boolean getWakeupSelectorAfterRegisterWrite() {
        return wakeupSelectorAfterRegisterWrite;
    }

    /**
     * Sets the flag to wakeup Selector After RegisterForRead is called.
     * @since 1.4.7
     */
    public static void setWakeupSelectorAfterRegisterRead(boolean flag) {
        wakeupSelectorAfterRegisterRead = flag;
    }

    /**
     * Returns wakeupSelectorAfterRegisterRead the flag that controls if wakeup is called on Selector
     * after RegisterForRead is called.
     * @since 1.4.7
     */
    public static boolean getWakeupSelectorAfterRegisterRead() {
        return wakeupSelectorAfterRegisterRead;
    }

    /**
     * Sets the maximum count of thread allowed to run objects of this class at a time.
     * @since 1.4.7
     */
    public static void setMaxThreadAccessCount(int count) {
        if (count < 3 && count != -1)
            throw new IllegalArgumentException(""Value should be >=3 or -1"");
        maxThreadAccessCount = count;
    }

    /**
     * Returns the maximum count of thread allowed to run objects of this class at a time.
     * @since 1.4.7
     */
    public static int getMaxThreadAccessCount() {
        return maxThreadAccessCount;
    }

    //v1.4.7
    private ByteBufferOutputStream byteBufferOutputStream;

    public NonBlockingClientHandler(int instanceCount) {
        super(instanceCount);
    }

    public NonBlockingClientHandler() {
        super();
    }

    public void clean() {
        logger.finest(""Starting clean - "" + getName());
        if (threadAccessCount != 0) {
            logger.warning(""Thread Access Count was not 0!: "" + threadAccessCount);
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
            threadAccessCount = 0;
        }
        while (readByteBuffer.isEmpty() == false) {
            try {
                getServer().getByteBufferPool().returnObject(readByteBuffer.remove(0));
            } catch (Exception er) {
                logger.warning(""Error in returning read ByteBuffer to pool: "" + er);
                break;
            }
        }
        while (writeByteBuffer.isEmpty() == false) {
            try {
                getServer().getByteBufferPool().returnObject(writeByteBuffer.remove(0));
            } catch (Exception er) {
                appLogger.warning(""Error in returning write ByteBuffer to pool: "" + er);
                break;
            }
        }
        if (peerNetData != null) {
            try {
                getServer().getByteBufferPool().returnObject(peerNetData);
            } catch (Exception er) {
                appLogger.warning(""Error in returning peerNetData to pool: "" + er);
            }
        }
        if (selectionKey != null) {
            selectionKey.cancel();
            selectionKey.selector().wakeup();
            selectionKey = null;
        }
        willReturn = false;
        waitingForFinalWrite = false;
        socketChannel = null;
        if (byteBufferOutputStream != null) {
            byteBufferOutputStream.close();
        }
        super.clean();
        //1.4.5
        clientWriteHandler = null;
        byteBufferOutputStream = null;
        sslShutdown = false;
        logger.finest(""Finished clean - "" + getName());
    }

    protected void finalize() throws Throwable {
        clean();
        super.finalize();
    }

    public void handleClient(TheClient theClient) throws Exception {
        super.handleClient(theClient);
        //v1.4.5
        setClientWriteHandler(theClient.getClientWriteHandler());
        //1.4.5
        setSocketChannel(theClient.getSocketChannel());
    }

    protected void setInputStream(InputStream in) throws IOException {
        this.in = in;
        if (getDataMode(DataType.IN) == DataMode.STRING) {
            b_in = null;
            o_in = null;
            bufferedReader = null;
        } else if (getDataMode(DataType.IN) == DataMode.OBJECT) {
            b_in = null;
            bufferedReader = null;
            o_in = new ObjectInputStream(in);
        } else if (getDataMode(DataType.IN) == DataMode.BYTE || getDataMode(DataType.IN) == DataMode.BINARY) {
            o_in = null;
            bufferedReader = null;
            b_in = null;
        }
    }

    public BufferedReader getBufferedReader() {
        throw new IllegalStateException(""Access to BufferedReader in not allowed in Non-Blocking mode!"");
    }

    public void closeConnection() {
        logger.finest(""inside"");
        synchronized (this) {
            if (connection == false)
                return;
            if (waitingForFinalWrite)
                return;
            if (getSelectionKey() != null && getSelectionKey().isValid() && lost == false) {
                waitingForFinalWrite = true;
            } else {
                connection = false;
            }
        }
        try {
            if (getSocketChannel() != null && socket != null) {
                if (waitingForFinalWrite) {
                    try {
                        waitTillFullyWritten();
                    } catch (Exception error) {
                        logger.warning(""Error in waitingForFinalWrite : "" + error);
                        if (logger.isLoggable(Level.FINE)) {
                            logger.fine(""StackTrace:\n"" + MyString.getStackTrace(error));
                        }
                    }
                }
                //end of waitingForFinalWrite
                if (isSecure() == true) {
                    sslShutdown = true;
                    if (lost == false && sslEngine.isOutboundDone() == false) {
                        logger.finest(""SSL isOutboundDone is false"");
                        if (byteBufferOutputStream.doShutdown() == false) {
                            return;
                        }
                    } else if (sslEngine.isOutboundDone()) {
                        logger.finest(""SSL Outbound is done."");
                    }
                }
                doPostCloseActivity();
            }
            //if socket
        } catch (IOException e) {
            logger.warning(""Error in closeConnection : "" + e);
            if (logger.isLoggable(Level.FINE)) {
                logger.fine(""StackTrace:\n"" + MyString.getStackTrace(e));
            }
        } catch (NullPointerException npe) {
            logger.fine(""NullPointerException: "" + npe);
            if (logger.isLoggable(Level.FINE)) {
                logger.fine(""StackTrace:\n"" + MyString.getStackTrace(npe));
            }
        }
    }

    private void doPostCloseActivity() throws IOException {
        connection = false;
        byteBufferOutputStream.forceNotify();
        getSelectionKey().cancel();
        if (getServer() != null) {
            getServer().getSelector().wakeup();
        }
        synchronized (this) {
            if (hasEvent(ClientEvent.MAX_CON) == false) {
                notifyCloseOrLost();
            }
            if (getSocketChannel().isOpen()) {
                logger.finest(""Closing SocketChannel"");
                getSocketChannel().close();
            }
        }
    }

    public boolean closeIfSSLOutboundDone() {
        if (isSecure() == false)
            throw new IllegalStateException(""Client is not in secure mode!"");
        if (sslEngine.isOutboundDone()) {
            logger.finest(""SSL Outbound is done."");
            try {
                if (getSocketChannel().isOpen()) {
                    logger.finest(""Closing SocketChannel"");
                    getSocketChannel().close();
                }
            } catch (IOException e) {
                logger.fine(""IGNORE: Error in Closing SocketChannel: "" + e);
            }
            return true;
        } else {
            logger.finest(""SSL Outbound is not done."");
            return false;
        }
    }

    /**
     * waitTillFullyWritten
     * @since 1.4.7
     */
    public void waitTillFullyWritten() {
        Object waitLock = new Object();
        if (byteBufferOutputStream.isDataAvailableForWrite(waitLock)) {
            if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                logger.finest(""Waiting "" + getName());
            }
            try {
                synchronized (waitLock) {
                    //2 min max
                    waitLock.wait(1000 * 60 * 2);
                }
            } catch (InterruptedException ie) {
                logger.warning(""Error: "" + ie);
            }
            if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                logger.finest(""Done. "" + getName());
            }
        }
    }

    public void run() {
        if (unprocessedClientEvents.isEmpty()) {
            logger.finest(""No unprocessed ClientEvents!"");
            return;
        }
        synchronized (this) {
            if (willReturn) {
                return;
            } else {
                threadAccessCount++;
            }
        }
        ClientEvent currentEvent = (ClientEvent) unprocessedClientEvents.poll();
        if (currentEvent == null) {
            threadEvent.set(null);
            logger.finest(""No unprocessed ClientEvents! pool was null"");
            return;
        }
        if (logger.isLoggable(Level.FINEST)) {
            StringBuilder sb = new StringBuilder();
            sb.append(""Running "").append(getName());
            sb.append("" using "");
            sb.append(Thread.currentThread().getName());
            sb.append("" for "");
            synchronized (clientEvents) {
                if (clientEvents.size() > 1) {
                    sb.append(currentEvent + "", Current Events - "" + clientEvents);
                } else {
                    sb.append(currentEvent);
                }
            }
            logger.finest(sb.toString());
        }
        logger.finest(""threadAccessCount: "" + threadAccessCount);
        threadEvent.set(currentEvent);
        try {
            if (maxThreadAccessCount != -1 && threadAccessCount > maxThreadAccessCount) {
                logger.warning(""ThreadAccessCount can't go beyond "" + maxThreadAccessCount + "": "" + threadAccessCount);
                if (Assertion.isEnabled()) {
                    throw new AssertionError(""ThreadAccessCount can't go beyond "" + maxThreadAccessCount + "": "" + threadAccessCount);
                }
                return;
            }
            if (socket == null)
                throw new SocketException(""Socket was null!"");
            if (getThreadEvent() == ClientEvent.ACCEPT || getThreadEvent() == ClientEvent.MAX_CON) {
                prepareForRun();
                Assertion.affirm(willReturn == false, ""WillReturn has to be false!: "" + willReturn);
            }
            if (getThreadEvent() == ClientEvent.MAX_CON) {
                processMaxConnection(currentEvent);
            }
            try {
                if (getThreadEvent() == ClientEvent.ACCEPT) {
                    registerForRead();
                    clientEventHandler.gotConnected(this);
                    if (authorised == false) {
                        if (clientAuthenticationHandler == null && authenticator == null) {
                            authorised = true;
                            logger.finest(""No Authenticator "" + getName() + "" so return thread."");
                        } else {
                            if (clientAuthenticationHandler != null) {
                                AuthStatus authStatus = null;
                                do {
                                    authStatus = processAuthorisation();
                                } while (authStatus == AuthStatus.FAILURE);
                                if (authStatus == AuthStatus.SUCCESS)
                                    authorised = true;
                            } else {
                                processAuthorisation();
                            }
                            if (authorised)
                                logger.finest(""Authentication done "" + getName() + "", so return thread."");
                            else
                                logger.finest(""askAuthentication() done "" + getName() + "", so return thread."");
                        }
                    }
                    //end authorised
                    //return thread to pool
                    returnThread();
                    return;
                }
                if (connection && getThreadEvent() == ClientEvent.READ) {
                    if (processRead())
                        return;
                }
                if (connection && getThreadEvent() == ClientEvent.WRITE) {
                    if (processWrite())
                        return;
                }
            } catch (SocketException e) {
                appLogger.finest(""SocketException - Client ["" + getHostAddress() + ""]: "" + e.getMessage());
                //e.printStackTrace();
                lost = true;
            } catch (AppException e) {
                //errors from Application
                appLogger.finest(""AppException "" + Thread.currentThread().getName() + "": "" + e.getMessage());
            } catch (javax.net.ssl.SSLException e) {
                lost = true;
                if (Assertion.isEnabled()) {
                    appLogger.info(""SSLException - Client ["" + getHostAddress() + ""] "" + Thread.currentThread().getName() + "": "" + e);
                } else {
                    appLogger.warning(""SSLException - Client ["" + getHostAddress() + ""]: "" + e);
                }
            } catch (ConnectionLostException e) {
                lost = true;
                if (e.getMessage() != null)
                    appLogger.finest(""Connection lost "" + Thread.currentThread().getName() + "": "" + e.getMessage());
                else
                    appLogger.finest(""Connection lost "" + Thread.currentThread().getName());
            } catch (ClosedChannelException e) {
                lost = true;
                appLogger.finest(""Channel closed "" + Thread.currentThread().getName() + "": "" + e);
            } catch (IOException e) {
                lost = true;
                appLogger.fine(""IOError "" + Thread.currentThread().getName() + "": "" + e);
            } catch (AssertionError er) {
                logger.warning(""[AssertionError] "" + getName() + "" "" + er);
                if (logger.isLoggable(Level.FINEST)) {
                    logger.finest(""StackTrace "" + Thread.currentThread().getName() + "": "" + MyString.getStackTrace(er));
                }
                assertionSystemExit();
            } catch (Error er) {
                logger.warning(""[Error] "" + er);
                if (logger.isLoggable(Level.FINEST)) {
                    logger.finest(""StackTrace "" + Thread.currentThread().getName() + "": "" + MyString.getStackTrace(er));
                }
                if (Assertion.isEnabled()) {
                    assertionSystemExit();
                }
                lost = true;
            } catch (RuntimeException re) {
                logger.warning(""[RuntimeException] "" + MyString.getStackTrace(re));
                if (Assertion.isEnabled()) {
                    assertionSystemExit();
                }
                lost = true;
            }
            if (getThreadEvent() != ClientEvent.MAX_CON) {
                notifyCloseOrLost();
            }
            if (connection) {
                logger.finest(Thread.currentThread().getName() + "" calling closeConnection()"");
                closeConnection();
            }
            if (connection == true && lost == true && waitingForFinalWrite) {
                byteBufferOutputStream.forceNotify();
            }
        } catch (javax.net.ssl.SSLException se) {
            logger.warning(""SSLException "" + Thread.currentThread().getName() + "" - "" + se);
        } catch (IOException ie) {
            logger.warning(""IOError "" + Thread.currentThread().getName() + "" - Closing Client : "" + ie);
        } catch (RuntimeException re) {
            logger.warning(""[RuntimeException] "" + getName() + "" "" + Thread.currentThread().getName() + "" - "" + MyString.getStackTrace(re));
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
        } catch (Exception e) {
            logger.warning(""Error "" + Thread.currentThread().getName() + "" - Event:"" + getThreadEvent() + "" - Socket:"" + socket + "" : "" + e);
            logger.fine(""StackTrace: "" + getName() + ""\n"" + MyString.getStackTrace(e));
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
        } catch (Error e) {
            logger.warning(""Error "" + Thread.currentThread().getName() + "" - Event:"" + getThreadEvent() + "" - Socket:"" + socket + "" : "" + e);
            logger.fine(""StackTrace: "" + getName() + ""\n"" + MyString.getStackTrace(e));
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
        }
        synchronized (this) {
            try {
                if (getSelectionKey() != null && getSelectionKey().isValid()) {
                    logger.finest(""Canceling SelectionKey"");
                    getSelectionKey().cancel();
                }
                if (socket != null && socket.isClosed() == false) {
                    logger.finest(""Closing Socket"");
                    socket.close();
                }
                if (getSocketChannel() != null && getSocketChannel().isOpen()) {
                    logger.finest(""Closing SocketChannel"");
                    socketChannel.close();
                }
            } catch (Exception re) {
                logger.warning(""Error closing Socket/Channel: "" + re);
            }
        }
        //end synchronized
        willClean = true;
        returnClientData();
        boolean returnClientHandler = false;
        synchronized (lockObj) {
            returnThread();
            returnClientHandler = checkReturnClientHandler();
        }
        if (returnClientHandler) {
            //return to pool
            returnClientHandler();
        }
    }

    protected boolean checkReturnClientHandler() {
        if (willReturn == false) {
            willReturn = true;
            return true;
        }
        return false;
    }

    /**
     * Process read
     * @return value indicates if the thread should return form run()
     */
    private boolean processRead() throws Exception {
        if (doRead()) {
            //return to pool
            returnThread();
            return true;
        } else {
            return false;
        }
    }

    private boolean doRead() throws Exception {
        int count = 0;
        int fullCount = 0;
        while (true) {
            try {
                if (peerNetData == null) {
                    peerNetData = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
                }
                count = getSocketChannel().read(peerNetData);
                if (count < 0) {
                    //logger.finest(""SocketChannel read was ""+count+""!"");
                    getServer().getByteBufferPool().returnObject(peerNetData);
                    peerNetData = null;
                    break;
                } else {
                    fullCount += count;
                }
                // Make readable
                peerNetData.flip();
                ByteBuffer peerAppData = null;
                //--
                if (sslEngine != null) {
                    SSLEngineResult res;
                    peerAppData = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
                    do {
                        res = sslEngine.unwrap(peerNetData, peerAppData);
                        logger.info(""Unwrapping:\n"" + res);
                    } while (res.getStatus() == SSLEngineResult.Status.OK && res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP && res.bytesProduced() == 0);
                    if (res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED) {
                        logger.info(""HandshakeStatus.FINISHED!"");
                        finishInitialHandshake();
                    }
                    if (peerAppData.position() == 0 && res.getStatus() == SSLEngineResult.Status.OK && peerNetData.hasRemaining()) {
                        logger.info(""peerNetData hasRemaining and pos=0!"");
                        res = sslEngine.unwrap(peerNetData, peerAppData);
                        logger.info(""Unwrapping:\n"" + res);
                    }
                    /*
					 * OK, OVERFLOW, UNDERFLOW, CLOSED
					 */
                    status = res.getStatus();
                    handshakeStatus = res.getHandshakeStatus();
                    if (status != SSLEngineResult.Status.BUFFER_OVERFLOW) {
                        logger.warning(""Buffer overflow: "" + res.toString());
                    } else if (status == SSLEngineResult.Status.CLOSED) {
                        logger.fine(""Connection is being closed by peer."");
                        lost = true;
                        System.out.println(""NEdd to code for shutdow of SSL"");
                        break;
                    }
                    peerNetData.compact();
                    peerAppData.flip();
                    if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_TASK || handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP || handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED) {
                        doHandshake();
                    }
                    //return peerAppData.remaining();
                    logger.fine(""peerAppData.remaining(): "" + peerAppData.remaining());
                } else {
                    peerAppData = peerNetData;
                    peerNetData = null;
                }
                //--
                readByteBuffer.add(peerAppData);
                peerAppData = null;
            } catch (Exception error) {
                logger.finest(""Error in data read: "" + error);
                if (sslEngine != null)
                    sslEngine.closeInbound();
                lost = true;
                synchronized (getInputStream()) {
                    getInputStream().notifyAll();
                }
                throw error;
            }
            if (count == 0)
                break;
        }
        //end while
        if (count < 0) {
            logger.finest(""SocketChannel read was "" + count + ""!"");
            if (sslEngine != null)
                sslEngine.closeInbound();
            lost = true;
            synchronized (getInputStream()) {
                getInputStream().notifyAll();
            }
        } else {
            logger.finest(fullCount + "" bytes read"");
            if (fullCount != 0) {
                updateLastCommunicationTime();
                synchronized (getInputStream()) {
                    //if any are waiting
                    getInputStream().notify();
                }
                if (hasEvent(ClientEvent.ACCEPT) == false) {
                    processGotDataInBuffers();
                }
            }
            //check if any data was read but not yet processed
            while (getInputStream().available() > 0) {
                logger.finest(""Sending again for processing..."");
                if (hasEvent(ClientEvent.ACCEPT) == false) {
                    processGotDataInBuffers();
                    break;
                } else {
                    synchronized (getInputStream()) {
                        getInputStream().notifyAll();
                    }
                    Thread.sleep(100);
                }
            }
            if (connection) {
                registerForRead();
                //getSelectionKey().selector().wakeup();
                return true;
            }
        }
        //end of else
        logger.finest(""We don't have connection, lets return all resources."");
        return false;
    }

    /**
     * Process write
     * @return value indicates if the thread should return form run()
     */
    private boolean processWrite() throws IOException {
        if (doWrite()) {
            //return to pool
            returnThread();
            return true;
        } else {
            return false;
        }
    }

    private boolean doWrite() throws IOException {
        if (sslShutdown) {
            if (byteBufferOutputStream.doShutdown() == false) {
                return true;
            }
            doPostCloseActivity();
            logger.finest(""We don't have connection, lets return all resources."");
            return false;
        }
        updateLastCommunicationTime();
        boolean flag = byteBufferOutputStream.writeAllByteBuffer();
        if (flag == false) {
            registerWrite();
        } else if (/*flag==true && */
        clientWriteHandler != null) {
            clientWriteHandler.handleWrite(this);
        }
        if (connection) {
            return true;
        } else {
            logger.finest(""We don't have connection, lets return all resources."");
            return false;
        }
    }

    protected void returnThread() {
        //System.out.println(""returnThread.."");
        //(new Exception()).printStackTrace();
        threadAccessCount--;
        Assertion.affirm(threadAccessCount >= 0, ""ThreadAccessCount went less the 0! Value: "" + threadAccessCount);
        //return is done at ClientThread end
        removeEvent((ClientEvent) threadEvent.get());
    }

    protected void returnClientHandler() {
        logger.finest(getName());
        try {
            for (int i = 0; threadAccessCount != 0; i++) {
                if (i == 100) {
                    logger.warning(""ClientHandler must have got into a loop waiting for thread to free up! ThreadAccessCount="" + threadAccessCount);
                    threadAccessCount = 0;
                    if (Assertion.isEnabled()) {
                        assertionSystemExit();
                    } else {
                        break;
                    }
                }
                if (threadAccessCount <= 0)
                    break;
                logger.finest(""Waiting for other thread of "" + getName() + "" to finish"");
                Thread.sleep(60);
            }
        } catch (InterruptedException ie) {
            appLogger.warning(""InterruptedException: "" + ie);
        }
        super.returnClientHandler();
    }

    public void setDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (getDataMode(dataType) == dataMode)
            return;
        appLogger.fine(""Setting Type:"" + dataType + "", Mode:"" + dataMode);
        super.checkDataModeSet(dataMode, dataType);
        setDataModeNonBlocking(dataMode, dataType);
    }

    private void setDataModeNonBlocking(DataMode dataMode, DataType dataType) throws IOException {
        logger.finest(""ENTER"");
        if (dataMode == DataMode.STRING) {
            if (dataType == DataType.OUT) {
                if (dataModeOUT == DataMode.BYTE || dataModeOUT == DataMode.BINARY) {
                    dataModeOUT = dataMode;
                } else if (dataModeOUT == DataMode.OBJECT) {
                    dataModeOUT = dataMode;
                    o_out.flush();
                    o_out = null;
                    b_out = new BufferedOutputStream(out);
                } else {
                    Assertion.affirm(false, ""Unknown DataType.OUT DataMode - "" + dataModeOUT);
                }
                Assertion.affirm(b_out != null, ""BufferedOutputStream is still null!"");
                Assertion.affirm(o_out == null, ""ObjectOutputStream is still not null!"");
            } else if (dataType == DataType.IN) {
                dataModeIN = dataMode;
                if (o_in != null) {
                    if (o_in.available() != 0)
                        logger.warning(""Data looks to be present in ObjectInputStream"");
                    o_in = null;
                }
                b_in = null;
                bufferedReader = null;
                //input stream will work
                Assertion.affirm(in != null, ""InputStream is still null!"");
                Assertion.affirm(b_in == null, ""BufferedInputStream is still not null!"");
                Assertion.affirm(bufferedReader == null, ""BufferedReader is still not null!"");
            }
        } else if (dataMode == DataMode.OBJECT) {
            if (dataType == DataType.IN) {
                //we will disable this for now
                throw new IllegalArgumentException(""Can't set DataType.IN mode to OBJECT when blocking mode is set as false!"");
            }
            if (dataType == DataType.OUT) {
                dataModeOUT = dataMode;
                b_out = null;
                o_out = new ObjectOutputStream(out);
                Assertion.affirm(o_out != null, ""ObjectOutputStream is still null!"");
                o_out.flush();
            } else if (dataType == DataType.IN) {
                dataModeIN = dataMode;
                b_in = null;
                bufferedReader = null;
                registerForRead();
                //will block
                o_in = new ObjectInputStream(in);
                Assertion.affirm(o_in != null, ""ObjectInputStream is still null!"");
            }
        } else if (dataMode == DataMode.BYTE || dataMode == DataMode.BINARY) {
            if (dataType == DataType.OUT) {
                if (dataModeOUT == DataMode.STRING || dataModeOUT == DataMode.BYTE || dataModeOUT == DataMode.BINARY) {
                    dataModeOUT = dataMode;
                } else if (dataModeOUT == DataMode.OBJECT) {
                    dataModeOUT = dataMode;
                    o_out = null;
                    b_out = new BufferedOutputStream(out);
                } else {
                    Assertion.affirm(false, ""Unknown DataType.OUT - DataMode: "" + dataModeOUT);
                }
                Assertion.affirm(b_out != null, ""BufferedOutputStream is still null!"");
            } else if (dataType == DataType.IN) {
                dataModeIN = dataMode;
                o_in = null;
                bufferedReader = null;
                b_in = null;
                //input stream will work
                Assertion.affirm(in != null, ""InputStream is still null!"");
            } else {
                throw new IllegalArgumentException(""Unknown DataType : "" + dataType);
            }
        } else {
            throw new IllegalArgumentException(""Unknown DataMode : "" + dataMode);
        }
    }

    protected byte[] readInputStream() throws IOException {
        return readInputStream(getInputStream());
    }

    public void updateInputOutputStreams() throws IOException {
        byteBufferOutputStream = new ByteBufferOutputStream(writeByteBuffer, this);
        setInputStream(new ByteBufferInputStream(readByteBuffer, this, getCharset()));
        setOutputStream(byteBufferOutputStream);
        //logger.warning(""updateInputOutputStreams: ""+sslEngine);
        if (sslEngine != null) {
            sslEngine.setUseClientMode(false);
            sslEngine.beginHandshake();
            handshakeStatus = sslEngine.getHandshakeStatus();
            initialHandshakeStatus = true;
            /*
			try {
				doHandshake();
			} catch(Exception e) {
				logger.warning(""Error: ""+e);
				throw new IOException(e.toString());
			}
			*/
        }
    }

    public boolean getBlockingMode() {
        return false;
    }

    public void setSocketChannel(SocketChannel socketChannel) {
        this.socketChannel = socketChannel;
    }

    public SocketChannel getSocketChannel() {
        return socketChannel;
    }

    public void setSelectionKey(SelectionKey selectionKey) {
        this.selectionKey = selectionKey;
    }

    public SelectionKey getSelectionKey() {
        if (selectionKey == null)
            selectionKey = getSocketChannel().keyFor(getServer().getSelector());
        return selectionKey;
    }

    private void processGotDataInBuffers() throws AppException, ConnectionLostException, ClassNotFoundException, IOException {
        if (getInputStream().available() == 0)
            return;
        logger.finest(""Trying to process got data.. DataMode.IN="" + dataModeIN);
        AuthStatus authStatus = null;
        //--For debug
        ((ByteBufferInputStream) getInputStream()).dumpContent();
        String temp = null;
        String rec = null;
        Object recObject = null;
        byte[] recByte = null;
        boolean timeToCheckForNewLineMiss = false;
        do {
            //updateLastCommunicationTime();
            if (dataModeIN == DataMode.STRING) {
                ByteBufferInputStream bbin = (ByteBufferInputStream) getInputStream();
                timeToCheckForNewLineMiss = true;
                while (bbin.isLineReady()) {
                    rec = bbin.readLine();
                    if (rec == null) {
                        lost = true;
                        return;
                    }
                    if (getCommunicationLogging() && authorised == true) {
                        appLogger.log(Level.FINE, ""Got STRING [{0}] : {1}"", new Object[] { getHostAddress(), rec });
                    }
                    totalReadBytes = totalReadBytes + rec.length();
                    if (authorised == false)
                        authStatus = clientAuthenticationHandler.handleAuthentication(this, rec);
                    else
                        clientCommandHandler.handleCommand(this, rec);
                    if (isClosed() == true)
                        return;
                    while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                    if (authStatus == AuthStatus.SUCCESS)
                        authorised = true;
                    if (dataModeIN != DataMode.STRING) {
                        break;
                    }
                    timeToCheckForNewLineMiss = false;
                }
                //end of while
                if (timeToCheckForNewLineMiss && bbin.availableOnlyInByteBuffer() == 0) {
                    return;
                } else {
                    timeToCheckForNewLineMiss = false;
                }
            }
            //if(dataModeIN == DataMode.OBJECT) {
            while (dataModeIN == DataMode.OBJECT && o_in != null) {
                //not sure if all bytes are in buffer..~ may need more read.. will get stuck..
                recObject = o_in.readObject();
                if (recObject == null) {
                    lost = true;
                    return;
                }
                if (getCommunicationLogging() && authorised == true) {
                    appLogger.log(Level.FINE, ""Got OBJECT [{0}] : {1}"", new Object[] { getHostAddress(), recObject.toString() });
                }
                totalReadBytes = totalReadBytes + 1;
                if (authorised == false)
                    authStatus = clientAuthenticationHandler.handleAuthentication(this, recObject);
                else
                    clientObjectHandler.handleObject(this, recObject);
                if (isClosed() == true)
                    return;
                while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                if (authStatus == AuthStatus.SUCCESS)
                    authorised = true;
            }
            //}
            //if(dataModeIN == DataMode.BYTE) {
            while (dataModeIN == DataMode.BYTE && getInputStream().available() != 0) {
                rec = readBytes();
                if (rec == null) {
                    lost = true;
                    return;
                }
                if (getCommunicationLogging() && authorised == true) {
                    appLogger.log(Level.FINE, ""Got BYTE [{0}] : {1}"", new Object[] { getHostAddress(), rec });
                }
                totalReadBytes = totalReadBytes + rec.length();
                if (authorised == false)
                    authStatus = clientAuthenticationHandler.handleAuthentication(this, rec);
                else
                    clientCommandHandler.handleCommand(this, rec);
                if (isClosed() == true)
                    return;
                while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                if (authStatus == AuthStatus.SUCCESS)
                    authorised = true;
            }
            //} else if(dataModeIN == DataMode.BINARY) {
            while (dataModeIN == DataMode.BINARY && getInputStream().available() != 0) {
                recByte = readBinary();
                if (recByte == null) {
                    lost = true;
                    return;
                }
                if (getCommunicationLogging() && authorised == true) {
                    if (getServer().isRawCommunicationLogging()) {
                        if (getServer().getRawCommunicationMaxLength() > 0 && recByte.length > getServer().getRawCommunicationMaxLength()) {
                            appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}; RAW: {2}{3}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length), new String(recByte, 0, getServer().getRawCommunicationMaxLength(), charset), ""..."" });
                        } else {
                            appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}; RAW: {2}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length), new String(recByte, charset) });
                        }
                    } else {
                        appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length) });
                    }
                } else if (getCommunicationLogging()) {
                    appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length) });
                }
                totalReadBytes = totalReadBytes + recByte.length;
                if (authorised == false)
                    authStatus = clientAuthenticationHandler.handleAuthentication(this, recByte);
                else
                    clientBinaryHandler.handleBinary(this, recByte);
                if (isClosed() == true)
                    return;
                while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                if (authStatus == AuthStatus.SUCCESS)
                    authorised = true;
            }
            //} else {
            if (dataModeIN != DataMode.STRING && dataModeIN != DataMode.OBJECT && dataModeIN != DataMode.BYTE && dataModeIN != DataMode.BINARY) {
                throw new IllegalStateException(""Incoming DataMode is not supported : "" + dataModeIN);
            }
        } while (getInputStream().available() != 0);
    }

    public void registerForRead() throws IOException, ClosedChannelException {
        //System.out.println(""registerForRead.."");
        //(new Exception()).printStackTrace();
        try {
            if (getSelectionKey() == null) {
                boolean flag = getServer().registerChannel(getSocketChannel(), SelectionKey.OP_READ, this);
                if (flag) {
                    logger.finest(""Adding OP_READ as interest Ops for "" + getName());
                } else if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                    logger.finest(""OP_READ is already present in interest Ops for "" + getName());
                }
            } else if (getSelectionKey().isValid()) {
                if ((getSelectionKey().interestOps() & SelectionKey.OP_READ) == 0) {
                    logger.finest(""Adding OP_READ to interest Ops for "" + getName());
                    removeEvent(ClientEvent.READ);
                    getSelectionKey().interestOps(getSelectionKey().interestOps() | SelectionKey.OP_READ);
                    if (wakeupSelectorAfterRegisterRead) {
                        getServer().getSelector().wakeup();
                    }
                } else {
                    if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                        logger.finest(""OP_READ is already present in interest Ops for "" + getName());
                    }
                }
            } else {
                throw new IOException(""SelectionKey is invalid!"");
            }
        } catch (CancelledKeyException e) {
            throw new IOException(""SelectionKey is cancelled!"");
        }
    }

    public void registerForWrite() throws IOException, ClosedChannelException {
        if (hasEvent(ClientEvent.RUN_BLOCKING) || hasEvent(ClientEvent.MAX_CON_BLOCKING)) {
            throw new IllegalStateException(""This method is only allowed under Non-Blocking mode."");
        }
        if (clientWriteHandler == null) {
            throw new IllegalStateException(""ClientWriteHandler has not been set!"");
        }
        registerWrite();
    }

    public void registerWrite() throws IOException {
        //System.out.println(""registerWrite.."");
        //(new Exception()).printStackTrace();
        try {
            if (getSelectionKey() == null) {
                boolean flag = getServer().registerChannel(getSocketChannel(), SelectionKey.OP_WRITE, this);
                if (flag) {
                    logger.finest(""Adding OP_WRITE as interest Ops for "" + getName());
                } else if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                    logger.finest(""OP_WRITE is already present in interest Ops for "" + getName());
                }
            } else if (getSelectionKey().isValid()) {
                if ((getSelectionKey().interestOps() & SelectionKey.OP_WRITE) == 0) {
                    logger.finest(""Adding OP_WRITE to interest Ops for "" + getName());
                    removeEvent(ClientEvent.WRITE);
                    getSelectionKey().interestOps(getSelectionKey().interestOps() | SelectionKey.OP_WRITE);
                    if (wakeupSelectorAfterRegisterWrite) {
                        getServer().getSelector().wakeup();
                    }
                } else {
                    if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                        logger.finest(""OP_WRITE is already present in interest Ops for "" + getName());
                    }
                }
            } else {
                throw new IOException(""SelectionKey is invalid!"");
            }
        } catch (CancelledKeyException e) {
            throw new IOException(""SelectionKey is cancelled!"");
        }
    }

    protected void setClientWriteHandler(ClientWriteHandler handler) {
        clientWriteHandler = handler;
    }

    /**
     * Returns number of thread currently in this object.
     * @since 1.4.6
     */
    public int getThreadAccessCount() {
        return threadAccessCount;
    }

    private void doHandshake() throws Exception {
        while (true) {
            SSLEngineResult res;
            logger.fine(""handshakeStatus: "" + handshakeStatus);
            if (handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED) {
                if (initialHandshakeStatus) {
                    finishInitialHandshake();
                }
                return;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_TASK) {
                doTasks();
                continue;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {
                /*
					doRead();

					if(initialHandshakeStatus && 
							status == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
						registerForRead();
					}
					*/
                return;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP) {
                ByteBuffer netData = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
                //netData.clear();
                res = sslEngine.wrap(dummyByteBuffer, netData);
                logger.info(""Wrapping:\n"" + res);
                assert res.bytesProduced() != 0 : ""No net data produced during handshake wrap."";
                assert res.bytesConsumed() == 0 : ""App data consumed during handshake wrap."";
                handshakeStatus = res.getHandshakeStatus();
                //netData.flip(); -- no need to flip will be done when writing to sc
                byteBufferOutputStream.addEncryptedByteBuffer(netData);
                if (!doWrite()) {
                    return;
                }
                //back to loop
                continue;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
                assert false : ""doHandshake() should never reach the NOT_HANDSHAKING state"";
                return;
            }
            //if
        }
        //loop
    }

    private void doTasks() {
        Runnable task;
        while ((task = sslEngine.getDelegatedTask()) != null) {
            logger.fine(""Running the task.. START "");
            task.run();
            logger.fine(""Running the task.. END"");
        }
        handshakeStatus = sslEngine.getHandshakeStatus();
        logger.fine(""handshakeStatus: "" + handshakeStatus);
    }

    private void finishInitialHandshake() throws IOException {
        initialHandshakeStatus = false;
    }

    public boolean getInitialHandshakeStatus() {
        return initialHandshakeStatus;
    }

    public ByteBuffer encrypt(ByteBuffer src) throws IOException {
        if (initialHandshakeStatus) {
            logger.fine(""Writing not possible during handshake!"");
            //Exception e = new Exception();
            //e.printStackTrace();
            return null;
        }
        ByteBuffer dest = null;
        boolean isException = false;
        try {
            src.flip();
            dest = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
            //dest.clear();
            SSLEngineResult res = sslEngine.wrap(src, dest);
            logger.info(""Wrapping:\n"" + res);
            //dest.flip();
            return dest;
        } catch (IOException e) {
            logger.warning(""IOException:"" + e);
            isException = true;
            throw e;
        } catch (Exception e) {
            logger.warning(""Exception:"" + e);
            isException = true;
            throw new IOException(e.getMessage());
        } finally {
            if (isException == true && dest != null) {
                try {
                    getServer().getByteBufferPool().returnObject(dest);
                } catch (Exception er) {
                    logger.warning(""Error in returning ByteBuffer to pool: "" + er);
                }
            }
        }
    }
}
","// NonBlockingClientHandler_1Test.java
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NonBlockingClientHandler}.
* It contains ten unit test cases for the {@link NonBlockingClientHandler#getWakeupSelectorAfterRegisterRead()} method.
*/
class NonBlockingClientHandler_1Test {","// NonBlockingClientHandler_1Test.java
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NonBlockingClientHandler}.
* It contains ten unit test cases for the {@link NonBlockingClientHandler#getWakeupSelectorAfterRegisterRead()} method.
*/
class NonBlockingClientHandler_1Test {
"
c0a9eac7-8841-44fa-a6d8-fa111cd7a05a,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/impl/NonBlockingClientHandler_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 16326 tokens (12326 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// NonBlockingClientHandler.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;

public class NonBlockingClientHandler extends BasicClientHandler {

    private static final Logger logger = Logger.getLogger(NonBlockingClientHandler.class.getName());

    //v1.4.5
    protected ClientWriteHandler clientWriteHandler;

    private SocketChannel socketChannel;

    protected ArrayList readByteBuffer = new ArrayList();

    protected ArrayList writeByteBuffer = new ArrayList();

    protected SelectionKey selectionKey;

    protected volatile int threadAccessCount = 0;

    protected volatile boolean willReturn;

    protected volatile boolean waitingForFinalWrite;

    //one for each event ACCEPT, WRITE, READ
    private static int maxThreadAccessCount = 5;

    private static boolean wakeupSelectorAfterRegisterWrite = true;

    private static boolean wakeupSelectorAfterRegisterRead = true;

    //nio ssl
    //private final SSLSession session;
    private boolean initialHandshakeStatus = false;

    private SSLEngineResult.HandshakeStatus handshakeStatus;

    private SSLEngineResult.Status status = null;

    private ByteBuffer dummyByteBuffer = ByteBuffer.allocate(0);

    private ByteBuffer peerNetData = null;

    private boolean sslShutdown = false;

    /**
     * Sets the flag to wakeup Selector After RegisterForWrite is called.
     * @since 1.4.7
     */
    public static void setWakeupSelectorAfterRegisterWrite(boolean flag) {
        wakeupSelectorAfterRegisterWrite = flag;
    }

    /**
     * Returns wakeupSelectorAfterRegisterWrite the flag that controls if wakeup is called on Selector
     * after RegisterForWrite is called.
     * @since 1.4.7
     */
    public static boolean getWakeupSelectorAfterRegisterWrite() {
        return wakeupSelectorAfterRegisterWrite;
    }

    /**
     * Sets the flag to wakeup Selector After RegisterForRead is called.
     * @since 1.4.7
     */
    public static void setWakeupSelectorAfterRegisterRead(boolean flag) {
        wakeupSelectorAfterRegisterRead = flag;
    }

    /**
     * Returns wakeupSelectorAfterRegisterRead the flag that controls if wakeup is called on Selector
     * after RegisterForRead is called.
     * @since 1.4.7
     */
    public static boolean getWakeupSelectorAfterRegisterRead() {
        return wakeupSelectorAfterRegisterRead;
    }

    /**
     * Sets the maximum count of thread allowed to run objects of this class at a time.
     * @since 1.4.7
     */
    public static void setMaxThreadAccessCount(int count) {
        if (count < 3 && count != -1)
            throw new IllegalArgumentException(""Value should be >=3 or -1"");
        maxThreadAccessCount = count;
    }

    /**
     * Returns the maximum count of thread allowed to run objects of this class at a time.
     * @since 1.4.7
     */
    public static int getMaxThreadAccessCount() {
        return maxThreadAccessCount;
    }

    //v1.4.7
    private ByteBufferOutputStream byteBufferOutputStream;

    public NonBlockingClientHandler(int instanceCount) {
        super(instanceCount);
    }

    public NonBlockingClientHandler() {
        super();
    }

    public void clean() {
        logger.finest(""Starting clean - "" + getName());
        if (threadAccessCount != 0) {
            logger.warning(""Thread Access Count was not 0!: "" + threadAccessCount);
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
            threadAccessCount = 0;
        }
        while (readByteBuffer.isEmpty() == false) {
            try {
                getServer().getByteBufferPool().returnObject(readByteBuffer.remove(0));
            } catch (Exception er) {
                logger.warning(""Error in returning read ByteBuffer to pool: "" + er);
                break;
            }
        }
        while (writeByteBuffer.isEmpty() == false) {
            try {
                getServer().getByteBufferPool().returnObject(writeByteBuffer.remove(0));
            } catch (Exception er) {
                appLogger.warning(""Error in returning write ByteBuffer to pool: "" + er);
                break;
            }
        }
        if (peerNetData != null) {
            try {
                getServer().getByteBufferPool().returnObject(peerNetData);
            } catch (Exception er) {
                appLogger.warning(""Error in returning peerNetData to pool: "" + er);
            }
        }
        if (selectionKey != null) {
            selectionKey.cancel();
            selectionKey.selector().wakeup();
            selectionKey = null;
        }
        willReturn = false;
        waitingForFinalWrite = false;
        socketChannel = null;
        if (byteBufferOutputStream != null) {
            byteBufferOutputStream.close();
        }
        super.clean();
        //1.4.5
        clientWriteHandler = null;
        byteBufferOutputStream = null;
        sslShutdown = false;
        logger.finest(""Finished clean - "" + getName());
    }

    protected void finalize() throws Throwable {
        clean();
        super.finalize();
    }

    public void handleClient(TheClient theClient) throws Exception {
        super.handleClient(theClient);
        //v1.4.5
        setClientWriteHandler(theClient.getClientWriteHandler());
        //1.4.5
        setSocketChannel(theClient.getSocketChannel());
    }

    protected void setInputStream(InputStream in) throws IOException {
        this.in = in;
        if (getDataMode(DataType.IN) == DataMode.STRING) {
            b_in = null;
            o_in = null;
            bufferedReader = null;
        } else if (getDataMode(DataType.IN) == DataMode.OBJECT) {
            b_in = null;
            bufferedReader = null;
            o_in = new ObjectInputStream(in);
        } else if (getDataMode(DataType.IN) == DataMode.BYTE || getDataMode(DataType.IN) == DataMode.BINARY) {
            o_in = null;
            bufferedReader = null;
            b_in = null;
        }
    }

    public BufferedReader getBufferedReader() {
        throw new IllegalStateException(""Access to BufferedReader in not allowed in Non-Blocking mode!"");
    }

    public void closeConnection() {
        logger.finest(""inside"");
        synchronized (this) {
            if (connection == false)
                return;
            if (waitingForFinalWrite)
                return;
            if (getSelectionKey() != null && getSelectionKey().isValid() && lost == false) {
                waitingForFinalWrite = true;
            } else {
                connection = false;
            }
        }
        try {
            if (getSocketChannel() != null && socket != null) {
                if (waitingForFinalWrite) {
                    try {
                        waitTillFullyWritten();
                    } catch (Exception error) {
                        logger.warning(""Error in waitingForFinalWrite : "" + error);
                        if (logger.isLoggable(Level.FINE)) {
                            logger.fine(""StackTrace:\n"" + MyString.getStackTrace(error));
                        }
                    }
                }
                //end of waitingForFinalWrite
                if (isSecure() == true) {
                    sslShutdown = true;
                    if (lost == false && sslEngine.isOutboundDone() == false) {
                        logger.finest(""SSL isOutboundDone is false"");
                        if (byteBufferOutputStream.doShutdown() == false) {
                            return;
                        }
                    } else if (sslEngine.isOutboundDone()) {
                        logger.finest(""SSL Outbound is done."");
                    }
                }
                doPostCloseActivity();
            }
            //if socket
        } catch (IOException e) {
            logger.warning(""Error in closeConnection : "" + e);
            if (logger.isLoggable(Level.FINE)) {
                logger.fine(""StackTrace:\n"" + MyString.getStackTrace(e));
            }
        } catch (NullPointerException npe) {
            logger.fine(""NullPointerException: "" + npe);
            if (logger.isLoggable(Level.FINE)) {
                logger.fine(""StackTrace:\n"" + MyString.getStackTrace(npe));
            }
        }
    }

    private void doPostCloseActivity() throws IOException {
        connection = false;
        byteBufferOutputStream.forceNotify();
        getSelectionKey().cancel();
        if (getServer() != null) {
            getServer().getSelector().wakeup();
        }
        synchronized (this) {
            if (hasEvent(ClientEvent.MAX_CON) == false) {
                notifyCloseOrLost();
            }
            if (getSocketChannel().isOpen()) {
                logger.finest(""Closing SocketChannel"");
                getSocketChannel().close();
            }
        }
    }

    public boolean closeIfSSLOutboundDone() {
        if (isSecure() == false)
            throw new IllegalStateException(""Client is not in secure mode!"");
        if (sslEngine.isOutboundDone()) {
            logger.finest(""SSL Outbound is done."");
            try {
                if (getSocketChannel().isOpen()) {
                    logger.finest(""Closing SocketChannel"");
                    getSocketChannel().close();
                }
            } catch (IOException e) {
                logger.fine(""IGNORE: Error in Closing SocketChannel: "" + e);
            }
            return true;
        } else {
            logger.finest(""SSL Outbound is not done."");
            return false;
        }
    }

    /**
     * waitTillFullyWritten
     * @since 1.4.7
     */
    public void waitTillFullyWritten() {
        Object waitLock = new Object();
        if (byteBufferOutputStream.isDataAvailableForWrite(waitLock)) {
            if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                logger.finest(""Waiting "" + getName());
            }
            try {
                synchronized (waitLock) {
                    //2 min max
                    waitLock.wait(1000 * 60 * 2);
                }
            } catch (InterruptedException ie) {
                logger.warning(""Error: "" + ie);
            }
            if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                logger.finest(""Done. "" + getName());
            }
        }
    }

    public void run() {
        if (unprocessedClientEvents.isEmpty()) {
            logger.finest(""No unprocessed ClientEvents!"");
            return;
        }
        synchronized (this) {
            if (willReturn) {
                return;
            } else {
                threadAccessCount++;
            }
        }
        ClientEvent currentEvent = (ClientEvent) unprocessedClientEvents.poll();
        if (currentEvent == null) {
            threadEvent.set(null);
            logger.finest(""No unprocessed ClientEvents! pool was null"");
            return;
        }
        if (logger.isLoggable(Level.FINEST)) {
            StringBuilder sb = new StringBuilder();
            sb.append(""Running "").append(getName());
            sb.append("" using "");
            sb.append(Thread.currentThread().getName());
            sb.append("" for "");
            synchronized (clientEvents) {
                if (clientEvents.size() > 1) {
                    sb.append(currentEvent + "", Current Events - "" + clientEvents);
                } else {
                    sb.append(currentEvent);
                }
            }
            logger.finest(sb.toString());
        }
        logger.finest(""threadAccessCount: "" + threadAccessCount);
        threadEvent.set(currentEvent);
        try {
            if (maxThreadAccessCount != -1 && threadAccessCount > maxThreadAccessCount) {
                logger.warning(""ThreadAccessCount can't go beyond "" + maxThreadAccessCount + "": "" + threadAccessCount);
                if (Assertion.isEnabled()) {
                    throw new AssertionError(""ThreadAccessCount can't go beyond "" + maxThreadAccessCount + "": "" + threadAccessCount);
                }
                return;
            }
            if (socket == null)
                throw new SocketException(""Socket was null!"");
            if (getThreadEvent() == ClientEvent.ACCEPT || getThreadEvent() == ClientEvent.MAX_CON) {
                prepareForRun();
                Assertion.affirm(willReturn == false, ""WillReturn has to be false!: "" + willReturn);
            }
            if (getThreadEvent() == ClientEvent.MAX_CON) {
                processMaxConnection(currentEvent);
            }
            try {
                if (getThreadEvent() == ClientEvent.ACCEPT) {
                    registerForRead();
                    clientEventHandler.gotConnected(this);
                    if (authorised == false) {
                        if (clientAuthenticationHandler == null && authenticator == null) {
                            authorised = true;
                            logger.finest(""No Authenticator "" + getName() + "" so return thread."");
                        } else {
                            if (clientAuthenticationHandler != null) {
                                AuthStatus authStatus = null;
                                do {
                                    authStatus = processAuthorisation();
                                } while (authStatus == AuthStatus.FAILURE);
                                if (authStatus == AuthStatus.SUCCESS)
                                    authorised = true;
                            } else {
                                processAuthorisation();
                            }
                            if (authorised)
                                logger.finest(""Authentication done "" + getName() + "", so return thread."");
                            else
                                logger.finest(""askAuthentication() done "" + getName() + "", so return thread."");
                        }
                    }
                    //end authorised
                    //return thread to pool
                    returnThread();
                    return;
                }
                if (connection && getThreadEvent() == ClientEvent.READ) {
                    if (processRead())
                        return;
                }
                if (connection && getThreadEvent() == ClientEvent.WRITE) {
                    if (processWrite())
                        return;
                }
            } catch (SocketException e) {
                appLogger.finest(""SocketException - Client ["" + getHostAddress() + ""]: "" + e.getMessage());
                //e.printStackTrace();
                lost = true;
            } catch (AppException e) {
                //errors from Application
                appLogger.finest(""AppException "" + Thread.currentThread().getName() + "": "" + e.getMessage());
            } catch (javax.net.ssl.SSLException e) {
                lost = true;
                if (Assertion.isEnabled()) {
                    appLogger.info(""SSLException - Client ["" + getHostAddress() + ""] "" + Thread.currentThread().getName() + "": "" + e);
                } else {
                    appLogger.warning(""SSLException - Client ["" + getHostAddress() + ""]: "" + e);
                }
            } catch (ConnectionLostException e) {
                lost = true;
                if (e.getMessage() != null)
                    appLogger.finest(""Connection lost "" + Thread.currentThread().getName() + "": "" + e.getMessage());
                else
                    appLogger.finest(""Connection lost "" + Thread.currentThread().getName());
            } catch (ClosedChannelException e) {
                lost = true;
                appLogger.finest(""Channel closed "" + Thread.currentThread().getName() + "": "" + e);
            } catch (IOException e) {
                lost = true;
                appLogger.fine(""IOError "" + Thread.currentThread().getName() + "": "" + e);
            } catch (AssertionError er) {
                logger.warning(""[AssertionError] "" + getName() + "" "" + er);
                if (logger.isLoggable(Level.FINEST)) {
                    logger.finest(""StackTrace "" + Thread.currentThread().getName() + "": "" + MyString.getStackTrace(er));
                }
                assertionSystemExit();
            } catch (Error er) {
                logger.warning(""[Error] "" + er);
                if (logger.isLoggable(Level.FINEST)) {
                    logger.finest(""StackTrace "" + Thread.currentThread().getName() + "": "" + MyString.getStackTrace(er));
                }
                if (Assertion.isEnabled()) {
                    assertionSystemExit();
                }
                lost = true;
            } catch (RuntimeException re) {
                logger.warning(""[RuntimeException] "" + MyString.getStackTrace(re));
                if (Assertion.isEnabled()) {
                    assertionSystemExit();
                }
                lost = true;
            }
            if (getThreadEvent() != ClientEvent.MAX_CON) {
                notifyCloseOrLost();
            }
            if (connection) {
                logger.finest(Thread.currentThread().getName() + "" calling closeConnection()"");
                closeConnection();
            }
            if (connection == true && lost == true && waitingForFinalWrite) {
                byteBufferOutputStream.forceNotify();
            }
        } catch (javax.net.ssl.SSLException se) {
            logger.warning(""SSLException "" + Thread.currentThread().getName() + "" - "" + se);
        } catch (IOException ie) {
            logger.warning(""IOError "" + Thread.currentThread().getName() + "" - Closing Client : "" + ie);
        } catch (RuntimeException re) {
            logger.warning(""[RuntimeException] "" + getName() + "" "" + Thread.currentThread().getName() + "" - "" + MyString.getStackTrace(re));
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
        } catch (Exception e) {
            logger.warning(""Error "" + Thread.currentThread().getName() + "" - Event:"" + getThreadEvent() + "" - Socket:"" + socket + "" : "" + e);
            logger.fine(""StackTrace: "" + getName() + ""\n"" + MyString.getStackTrace(e));
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
        } catch (Error e) {
            logger.warning(""Error "" + Thread.currentThread().getName() + "" - Event:"" + getThreadEvent() + "" - Socket:"" + socket + "" : "" + e);
            logger.fine(""StackTrace: "" + getName() + ""\n"" + MyString.getStackTrace(e));
            if (Assertion.isEnabled()) {
                assertionSystemExit();
            }
        }
        synchronized (this) {
            try {
                if (getSelectionKey() != null && getSelectionKey().isValid()) {
                    logger.finest(""Canceling SelectionKey"");
                    getSelectionKey().cancel();
                }
                if (socket != null && socket.isClosed() == false) {
                    logger.finest(""Closing Socket"");
                    socket.close();
                }
                if (getSocketChannel() != null && getSocketChannel().isOpen()) {
                    logger.finest(""Closing SocketChannel"");
                    socketChannel.close();
                }
            } catch (Exception re) {
                logger.warning(""Error closing Socket/Channel: "" + re);
            }
        }
        //end synchronized
        willClean = true;
        returnClientData();
        boolean returnClientHandler = false;
        synchronized (lockObj) {
            returnThread();
            returnClientHandler = checkReturnClientHandler();
        }
        if (returnClientHandler) {
            //return to pool
            returnClientHandler();
        }
    }

    protected boolean checkReturnClientHandler() {
        if (willReturn == false) {
            willReturn = true;
            return true;
        }
        return false;
    }

    /**
     * Process read
     * @return value indicates if the thread should return form run()
     */
    private boolean processRead() throws Exception {
        if (doRead()) {
            //return to pool
            returnThread();
            return true;
        } else {
            return false;
        }
    }

    private boolean doRead() throws Exception {
        int count = 0;
        int fullCount = 0;
        while (true) {
            try {
                if (peerNetData == null) {
                    peerNetData = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
                }
                count = getSocketChannel().read(peerNetData);
                if (count < 0) {
                    //logger.finest(""SocketChannel read was ""+count+""!"");
                    getServer().getByteBufferPool().returnObject(peerNetData);
                    peerNetData = null;
                    break;
                } else {
                    fullCount += count;
                }
                // Make readable
                peerNetData.flip();
                ByteBuffer peerAppData = null;
                //--
                if (sslEngine != null) {
                    SSLEngineResult res;
                    peerAppData = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
                    do {
                        res = sslEngine.unwrap(peerNetData, peerAppData);
                        logger.info(""Unwrapping:\n"" + res);
                    } while (res.getStatus() == SSLEngineResult.Status.OK && res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP && res.bytesProduced() == 0);
                    if (res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED) {
                        logger.info(""HandshakeStatus.FINISHED!"");
                        finishInitialHandshake();
                    }
                    if (peerAppData.position() == 0 && res.getStatus() == SSLEngineResult.Status.OK && peerNetData.hasRemaining()) {
                        logger.info(""peerNetData hasRemaining and pos=0!"");
                        res = sslEngine.unwrap(peerNetData, peerAppData);
                        logger.info(""Unwrapping:\n"" + res);
                    }
                    /*
					 * OK, OVERFLOW, UNDERFLOW, CLOSED
					 */
                    status = res.getStatus();
                    handshakeStatus = res.getHandshakeStatus();
                    if (status != SSLEngineResult.Status.BUFFER_OVERFLOW) {
                        logger.warning(""Buffer overflow: "" + res.toString());
                    } else if (status == SSLEngineResult.Status.CLOSED) {
                        logger.fine(""Connection is being closed by peer."");
                        lost = true;
                        System.out.println(""NEdd to code for shutdow of SSL"");
                        break;
                    }
                    peerNetData.compact();
                    peerAppData.flip();
                    if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_TASK || handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP || handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED) {
                        doHandshake();
                    }
                    //return peerAppData.remaining();
                    logger.fine(""peerAppData.remaining(): "" + peerAppData.remaining());
                } else {
                    peerAppData = peerNetData;
                    peerNetData = null;
                }
                //--
                readByteBuffer.add(peerAppData);
                peerAppData = null;
            } catch (Exception error) {
                logger.finest(""Error in data read: "" + error);
                if (sslEngine != null)
                    sslEngine.closeInbound();
                lost = true;
                synchronized (getInputStream()) {
                    getInputStream().notifyAll();
                }
                throw error;
            }
            if (count == 0)
                break;
        }
        //end while
        if (count < 0) {
            logger.finest(""SocketChannel read was "" + count + ""!"");
            if (sslEngine != null)
                sslEngine.closeInbound();
            lost = true;
            synchronized (getInputStream()) {
                getInputStream().notifyAll();
            }
        } else {
            logger.finest(fullCount + "" bytes read"");
            if (fullCount != 0) {
                updateLastCommunicationTime();
                synchronized (getInputStream()) {
                    //if any are waiting
                    getInputStream().notify();
                }
                if (hasEvent(ClientEvent.ACCEPT) == false) {
                    processGotDataInBuffers();
                }
            }
            //check if any data was read but not yet processed
            while (getInputStream().available() > 0) {
                logger.finest(""Sending again for processing..."");
                if (hasEvent(ClientEvent.ACCEPT) == false) {
                    processGotDataInBuffers();
                    break;
                } else {
                    synchronized (getInputStream()) {
                        getInputStream().notifyAll();
                    }
                    Thread.sleep(100);
                }
            }
            if (connection) {
                registerForRead();
                //getSelectionKey().selector().wakeup();
                return true;
            }
        }
        //end of else
        logger.finest(""We don't have connection, lets return all resources."");
        return false;
    }

    /**
     * Process write
     * @return value indicates if the thread should return form run()
     */
    private boolean processWrite() throws IOException {
        if (doWrite()) {
            //return to pool
            returnThread();
            return true;
        } else {
            return false;
        }
    }

    private boolean doWrite() throws IOException {
        if (sslShutdown) {
            if (byteBufferOutputStream.doShutdown() == false) {
                return true;
            }
            doPostCloseActivity();
            logger.finest(""We don't have connection, lets return all resources."");
            return false;
        }
        updateLastCommunicationTime();
        boolean flag = byteBufferOutputStream.writeAllByteBuffer();
        if (flag == false) {
            registerWrite();
        } else if (/*flag==true && */
        clientWriteHandler != null) {
            clientWriteHandler.handleWrite(this);
        }
        if (connection) {
            return true;
        } else {
            logger.finest(""We don't have connection, lets return all resources."");
            return false;
        }
    }

    protected void returnThread() {
        //System.out.println(""returnThread.."");
        //(new Exception()).printStackTrace();
        threadAccessCount--;
        Assertion.affirm(threadAccessCount >= 0, ""ThreadAccessCount went less the 0! Value: "" + threadAccessCount);
        //return is done at ClientThread end
        removeEvent((ClientEvent) threadEvent.get());
    }

    protected void returnClientHandler() {
        logger.finest(getName());
        try {
            for (int i = 0; threadAccessCount != 0; i++) {
                if (i == 100) {
                    logger.warning(""ClientHandler must have got into a loop waiting for thread to free up! ThreadAccessCount="" + threadAccessCount);
                    threadAccessCount = 0;
                    if (Assertion.isEnabled()) {
                        assertionSystemExit();
                    } else {
                        break;
                    }
                }
                if (threadAccessCount <= 0)
                    break;
                logger.finest(""Waiting for other thread of "" + getName() + "" to finish"");
                Thread.sleep(60);
            }
        } catch (InterruptedException ie) {
            appLogger.warning(""InterruptedException: "" + ie);
        }
        super.returnClientHandler();
    }

    public void setDataMode(DataMode dataMode, DataType dataType) throws IOException {
        if (getDataMode(dataType) == dataMode)
            return;
        appLogger.fine(""Setting Type:"" + dataType + "", Mode:"" + dataMode);
        super.checkDataModeSet(dataMode, dataType);
        setDataModeNonBlocking(dataMode, dataType);
    }

    private void setDataModeNonBlocking(DataMode dataMode, DataType dataType) throws IOException {
        logger.finest(""ENTER"");
        if (dataMode == DataMode.STRING) {
            if (dataType == DataType.OUT) {
                if (dataModeOUT == DataMode.BYTE || dataModeOUT == DataMode.BINARY) {
                    dataModeOUT = dataMode;
                } else if (dataModeOUT == DataMode.OBJECT) {
                    dataModeOUT = dataMode;
                    o_out.flush();
                    o_out = null;
                    b_out = new BufferedOutputStream(out);
                } else {
                    Assertion.affirm(false, ""Unknown DataType.OUT DataMode - "" + dataModeOUT);
                }
                Assertion.affirm(b_out != null, ""BufferedOutputStream is still null!"");
                Assertion.affirm(o_out == null, ""ObjectOutputStream is still not null!"");
            } else if (dataType == DataType.IN) {
                dataModeIN = dataMode;
                if (o_in != null) {
                    if (o_in.available() != 0)
                        logger.warning(""Data looks to be present in ObjectInputStream"");
                    o_in = null;
                }
                b_in = null;
                bufferedReader = null;
                //input stream will work
                Assertion.affirm(in != null, ""InputStream is still null!"");
                Assertion.affirm(b_in == null, ""BufferedInputStream is still not null!"");
                Assertion.affirm(bufferedReader == null, ""BufferedReader is still not null!"");
            }
        } else if (dataMode == DataMode.OBJECT) {
            if (dataType == DataType.IN) {
                //we will disable this for now
                throw new IllegalArgumentException(""Can't set DataType.IN mode to OBJECT when blocking mode is set as false!"");
            }
            if (dataType == DataType.OUT) {
                dataModeOUT = dataMode;
                b_out = null;
                o_out = new ObjectOutputStream(out);
                Assertion.affirm(o_out != null, ""ObjectOutputStream is still null!"");
                o_out.flush();
            } else if (dataType == DataType.IN) {
                dataModeIN = dataMode;
                b_in = null;
                bufferedReader = null;
                registerForRead();
                //will block
                o_in = new ObjectInputStream(in);
                Assertion.affirm(o_in != null, ""ObjectInputStream is still null!"");
            }
        } else if (dataMode == DataMode.BYTE || dataMode == DataMode.BINARY) {
            if (dataType == DataType.OUT) {
                if (dataModeOUT == DataMode.STRING || dataModeOUT == DataMode.BYTE || dataModeOUT == DataMode.BINARY) {
                    dataModeOUT = dataMode;
                } else if (dataModeOUT == DataMode.OBJECT) {
                    dataModeOUT = dataMode;
                    o_out = null;
                    b_out = new BufferedOutputStream(out);
                } else {
                    Assertion.affirm(false, ""Unknown DataType.OUT - DataMode: "" + dataModeOUT);
                }
                Assertion.affirm(b_out != null, ""BufferedOutputStream is still null!"");
            } else if (dataType == DataType.IN) {
                dataModeIN = dataMode;
                o_in = null;
                bufferedReader = null;
                b_in = null;
                //input stream will work
                Assertion.affirm(in != null, ""InputStream is still null!"");
            } else {
                throw new IllegalArgumentException(""Unknown DataType : "" + dataType);
            }
        } else {
            throw new IllegalArgumentException(""Unknown DataMode : "" + dataMode);
        }
    }

    protected byte[] readInputStream() throws IOException {
        return readInputStream(getInputStream());
    }

    public void updateInputOutputStreams() throws IOException {
        byteBufferOutputStream = new ByteBufferOutputStream(writeByteBuffer, this);
        setInputStream(new ByteBufferInputStream(readByteBuffer, this, getCharset()));
        setOutputStream(byteBufferOutputStream);
        //logger.warning(""updateInputOutputStreams: ""+sslEngine);
        if (sslEngine != null) {
            sslEngine.setUseClientMode(false);
            sslEngine.beginHandshake();
            handshakeStatus = sslEngine.getHandshakeStatus();
            initialHandshakeStatus = true;
            /*
			try {
				doHandshake();
			} catch(Exception e) {
				logger.warning(""Error: ""+e);
				throw new IOException(e.toString());
			}
			*/
        }
    }

    public boolean getBlockingMode() {
        return false;
    }

    public void setSocketChannel(SocketChannel socketChannel) {
        this.socketChannel = socketChannel;
    }

    public SocketChannel getSocketChannel() {
        return socketChannel;
    }

    public void setSelectionKey(SelectionKey selectionKey) {
        this.selectionKey = selectionKey;
    }

    public SelectionKey getSelectionKey() {
        if (selectionKey == null)
            selectionKey = getSocketChannel().keyFor(getServer().getSelector());
        return selectionKey;
    }

    private void processGotDataInBuffers() throws AppException, ConnectionLostException, ClassNotFoundException, IOException {
        if (getInputStream().available() == 0)
            return;
        logger.finest(""Trying to process got data.. DataMode.IN="" + dataModeIN);
        AuthStatus authStatus = null;
        //--For debug
        ((ByteBufferInputStream) getInputStream()).dumpContent();
        String temp = null;
        String rec = null;
        Object recObject = null;
        byte[] recByte = null;
        boolean timeToCheckForNewLineMiss = false;
        do {
            //updateLastCommunicationTime();
            if (dataModeIN == DataMode.STRING) {
                ByteBufferInputStream bbin = (ByteBufferInputStream) getInputStream();
                timeToCheckForNewLineMiss = true;
                while (bbin.isLineReady()) {
                    rec = bbin.readLine();
                    if (rec == null) {
                        lost = true;
                        return;
                    }
                    if (getCommunicationLogging() && authorised == true) {
                        appLogger.log(Level.FINE, ""Got STRING [{0}] : {1}"", new Object[] { getHostAddress(), rec });
                    }
                    totalReadBytes = totalReadBytes + rec.length();
                    if (authorised == false)
                        authStatus = clientAuthenticationHandler.handleAuthentication(this, rec);
                    else
                        clientCommandHandler.handleCommand(this, rec);
                    if (isClosed() == true)
                        return;
                    while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                    if (authStatus == AuthStatus.SUCCESS)
                        authorised = true;
                    if (dataModeIN != DataMode.STRING) {
                        break;
                    }
                    timeToCheckForNewLineMiss = false;
                }
                //end of while
                if (timeToCheckForNewLineMiss && bbin.availableOnlyInByteBuffer() == 0) {
                    return;
                } else {
                    timeToCheckForNewLineMiss = false;
                }
            }
            //if(dataModeIN == DataMode.OBJECT) {
            while (dataModeIN == DataMode.OBJECT && o_in != null) {
                //not sure if all bytes are in buffer..~ may need more read.. will get stuck..
                recObject = o_in.readObject();
                if (recObject == null) {
                    lost = true;
                    return;
                }
                if (getCommunicationLogging() && authorised == true) {
                    appLogger.log(Level.FINE, ""Got OBJECT [{0}] : {1}"", new Object[] { getHostAddress(), recObject.toString() });
                }
                totalReadBytes = totalReadBytes + 1;
                if (authorised == false)
                    authStatus = clientAuthenticationHandler.handleAuthentication(this, recObject);
                else
                    clientObjectHandler.handleObject(this, recObject);
                if (isClosed() == true)
                    return;
                while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                if (authStatus == AuthStatus.SUCCESS)
                    authorised = true;
            }
            //}
            //if(dataModeIN == DataMode.BYTE) {
            while (dataModeIN == DataMode.BYTE && getInputStream().available() != 0) {
                rec = readBytes();
                if (rec == null) {
                    lost = true;
                    return;
                }
                if (getCommunicationLogging() && authorised == true) {
                    appLogger.log(Level.FINE, ""Got BYTE [{0}] : {1}"", new Object[] { getHostAddress(), rec });
                }
                totalReadBytes = totalReadBytes + rec.length();
                if (authorised == false)
                    authStatus = clientAuthenticationHandler.handleAuthentication(this, rec);
                else
                    clientCommandHandler.handleCommand(this, rec);
                if (isClosed() == true)
                    return;
                while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                if (authStatus == AuthStatus.SUCCESS)
                    authorised = true;
            }
            //} else if(dataModeIN == DataMode.BINARY) {
            while (dataModeIN == DataMode.BINARY && getInputStream().available() != 0) {
                recByte = readBinary();
                if (recByte == null) {
                    lost = true;
                    return;
                }
                if (getCommunicationLogging() && authorised == true) {
                    if (getServer().isRawCommunicationLogging()) {
                        if (getServer().getRawCommunicationMaxLength() > 0 && recByte.length > getServer().getRawCommunicationMaxLength()) {
                            appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}; RAW: {2}{3}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length), new String(recByte, 0, getServer().getRawCommunicationMaxLength(), charset), ""..."" });
                        } else {
                            appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}; RAW: {2}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length), new String(recByte, charset) });
                        }
                    } else {
                        appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length) });
                    }
                } else if (getCommunicationLogging()) {
                    appLogger.log(Level.FINE, ""Got BINARY [{0}] : {1}"", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length) });
                }
                totalReadBytes = totalReadBytes + recByte.length;
                if (authorised == false)
                    authStatus = clientAuthenticationHandler.handleAuthentication(this, recByte);
                else
                    clientBinaryHandler.handleBinary(this, recByte);
                if (isClosed() == true)
                    return;
                while (authStatus == AuthStatus.FAILURE) authStatus = processAuthorisation();
                if (authStatus == AuthStatus.SUCCESS)
                    authorised = true;
            }
            //} else {
            if (dataModeIN != DataMode.STRING && dataModeIN != DataMode.OBJECT && dataModeIN != DataMode.BYTE && dataModeIN != DataMode.BINARY) {
                throw new IllegalStateException(""Incoming DataMode is not supported : "" + dataModeIN);
            }
        } while (getInputStream().available() != 0);
    }

    public void registerForRead() throws IOException, ClosedChannelException {
        //System.out.println(""registerForRead.."");
        //(new Exception()).printStackTrace();
        try {
            if (getSelectionKey() == null) {
                boolean flag = getServer().registerChannel(getSocketChannel(), SelectionKey.OP_READ, this);
                if (flag) {
                    logger.finest(""Adding OP_READ as interest Ops for "" + getName());
                } else if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                    logger.finest(""OP_READ is already present in interest Ops for "" + getName());
                }
            } else if (getSelectionKey().isValid()) {
                if ((getSelectionKey().interestOps() & SelectionKey.OP_READ) == 0) {
                    logger.finest(""Adding OP_READ to interest Ops for "" + getName());
                    removeEvent(ClientEvent.READ);
                    getSelectionKey().interestOps(getSelectionKey().interestOps() | SelectionKey.OP_READ);
                    if (wakeupSelectorAfterRegisterRead) {
                        getServer().getSelector().wakeup();
                    }
                } else {
                    if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                        logger.finest(""OP_READ is already present in interest Ops for "" + getName());
                    }
                }
            } else {
                throw new IOException(""SelectionKey is invalid!"");
            }
        } catch (CancelledKeyException e) {
            throw new IOException(""SelectionKey is cancelled!"");
        }
    }

    public void registerForWrite() throws IOException, ClosedChannelException {
        if (hasEvent(ClientEvent.RUN_BLOCKING) || hasEvent(ClientEvent.MAX_CON_BLOCKING)) {
            throw new IllegalStateException(""This method is only allowed under Non-Blocking mode."");
        }
        if (clientWriteHandler == null) {
            throw new IllegalStateException(""ClientWriteHandler has not been set!"");
        }
        registerWrite();
    }

    public void registerWrite() throws IOException {
        //System.out.println(""registerWrite.."");
        //(new Exception()).printStackTrace();
        try {
            if (getSelectionKey() == null) {
                boolean flag = getServer().registerChannel(getSocketChannel(), SelectionKey.OP_WRITE, this);
                if (flag) {
                    logger.finest(""Adding OP_WRITE as interest Ops for "" + getName());
                } else if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                    logger.finest(""OP_WRITE is already present in interest Ops for "" + getName());
                }
            } else if (getSelectionKey().isValid()) {
                if ((getSelectionKey().interestOps() & SelectionKey.OP_WRITE) == 0) {
                    logger.finest(""Adding OP_WRITE to interest Ops for "" + getName());
                    removeEvent(ClientEvent.WRITE);
                    getSelectionKey().interestOps(getSelectionKey().interestOps() | SelectionKey.OP_WRITE);
                    if (wakeupSelectorAfterRegisterWrite) {
                        getServer().getSelector().wakeup();
                    }
                } else {
                    if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {
                        logger.finest(""OP_WRITE is already present in interest Ops for "" + getName());
                    }
                }
            } else {
                throw new IOException(""SelectionKey is invalid!"");
            }
        } catch (CancelledKeyException e) {
            throw new IOException(""SelectionKey is cancelled!"");
        }
    }

    protected void setClientWriteHandler(ClientWriteHandler handler) {
        clientWriteHandler = handler;
    }

    /**
     * Returns number of thread currently in this object.
     * @since 1.4.6
     */
    public int getThreadAccessCount() {
        return threadAccessCount;
    }

    private void doHandshake() throws Exception {
        while (true) {
            SSLEngineResult res;
            logger.fine(""handshakeStatus: "" + handshakeStatus);
            if (handshakeStatus == SSLEngineResult.HandshakeStatus.FINISHED) {
                if (initialHandshakeStatus) {
                    finishInitialHandshake();
                }
                return;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_TASK) {
                doTasks();
                continue;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {
                /*
					doRead();

					if(initialHandshakeStatus && 
							status == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
						registerForRead();
					}
					*/
                return;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP) {
                ByteBuffer netData = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
                //netData.clear();
                res = sslEngine.wrap(dummyByteBuffer, netData);
                logger.info(""Wrapping:\n"" + res);
                assert res.bytesProduced() != 0 : ""No net data produced during handshake wrap."";
                assert res.bytesConsumed() == 0 : ""App data consumed during handshake wrap."";
                handshakeStatus = res.getHandshakeStatus();
                //netData.flip(); -- no need to flip will be done when writing to sc
                byteBufferOutputStream.addEncryptedByteBuffer(netData);
                if (!doWrite()) {
                    return;
                }
                //back to loop
                continue;
            } else if (handshakeStatus == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
                assert false : ""doHandshake() should never reach the NOT_HANDSHAKING state"";
                return;
            }
            //if
        }
        //loop
    }

    private void doTasks() {
        Runnable task;
        while ((task = sslEngine.getDelegatedTask()) != null) {
            logger.fine(""Running the task.. START "");
            task.run();
            logger.fine(""Running the task.. END"");
        }
        handshakeStatus = sslEngine.getHandshakeStatus();
        logger.fine(""handshakeStatus: "" + handshakeStatus);
    }

    private void finishInitialHandshake() throws IOException {
        initialHandshakeStatus = false;
    }

    public boolean getInitialHandshakeStatus() {
        return initialHandshakeStatus;
    }

    public ByteBuffer encrypt(ByteBuffer src) throws IOException {
        if (initialHandshakeStatus) {
            logger.fine(""Writing not possible during handshake!"");
            //Exception e = new Exception();
            //e.printStackTrace();
            return null;
        }
        ByteBuffer dest = null;
        boolean isException = false;
        try {
            src.flip();
            dest = (ByteBuffer) getServer().getByteBufferPool().borrowObject();
            //dest.clear();
            SSLEngineResult res = sslEngine.wrap(src, dest);
            logger.info(""Wrapping:\n"" + res);
            //dest.flip();
            return dest;
        } catch (IOException e) {
            logger.warning(""IOException:"" + e);
            isException = true;
            throw e;
        } catch (Exception e) {
            logger.warning(""Exception:"" + e);
            isException = true;
            throw new IOException(e.getMessage());
        } finally {
            if (isException == true && dest != null) {
                try {
                    getServer().getByteBufferPool().returnObject(dest);
                } catch (Exception er) {
                    logger.warning(""Error in returning ByteBuffer to pool: "" + er);
                }
            }
        }
    }
}
","// NonBlockingClientHandler_2Test.java
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NonBlockingClientHandler}.
* It contains ten unit test cases for the {@link NonBlockingClientHandler#getMaxThreadAccessCount()} method.
*/
class NonBlockingClientHandler_2Test {","// NonBlockingClientHandler_2Test.java
package org.quickserver.net.server.impl;

import org.quickserver.net.server.*;
import org.quickserver.net.*;
import org.quickserver.util.*;
import org.quickserver.util.io.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import java.nio.*;
import java.nio.channels.*;
import javax.net.ssl.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link NonBlockingClientHandler}.
* It contains ten unit test cases for the {@link NonBlockingClientHandler#getMaxThreadAccessCount()} method.
*/
class NonBlockingClientHandler_2Test {
"
cmpl-6wgmMzzxM4puxCHUG3RZe0bRs3AhW,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/util/ClassUtil_1Test.java,132.20178079605103,length,"// ClassUtil.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;

/**
 * A utility class to load class.
 * @author Akshathkumar Shetty
 * @since 1.3.2
 */
public class ClassUtil {

    private static Logger logger = Logger.getLogger(ClassUtil.class.getName());

    /**
     * Tries to load the classes present in the array
     * passed has second parameter from
     * the ClassLoader passed has first parameter.
     * Returns the HashMap of all the classed successfully loaded.
     * @param classLoader ClassLoader used to find the class
     * @param classes[] array of classes to load.
     */
    public static Map loadClass(ClassLoader classLoader, String[] classNames) throws Exception {
        Class classloded = null;
        HashMap classHash = new HashMap();
        for (int i = 0; i < classNames.length; i++) {
            try {
                classloded = classLoader.loadClass(classNames[i]);
                classHash.put(classNames[i], classloded);
            } catch (Exception e) {
                logger.warning(""Could not load classes : "" + e);
            }
        }
        return classHash;
    }

    /**
     * Returns the ClassLoader to all the jars present in the
     * dir passed has first parameter.
     * @param jarDir path to the directory containing the jars
     */
    public static ClassLoader getClassLoaderFromJars(String jarDir) throws Exception {
        logger.fine(""Getting ClassLoader for jars in "" + jarDir);
        File file = new File(jarDir);
        ArrayList list = new ArrayList();
        File[] jars = file.listFiles(new JarFileList());
        for (int j = 0; j < jars.length; j++) {
            list.add(jars[j].toURL());
        }
        Object[] array = list.toArray();
        URL[] jarurl = new URL[array.length];
        for (int i = 0; i < array.length; i++) {
            jarurl[i] = (URL) array[i];
        }
        URLClassLoader classLoader = URLClassLoader.newInstance(jarurl);
        return classLoader;
    }

    /**
     * Returns the ClassLoader to a jar
     * @since 1.3.3
     */
    public static ClassLoader getClassLoaderFromJar(String jarPath) throws Exception {
        File file = new File(jarPath);
        logger.fine(""Getting ClassLoader for "" + file.getCanonicalPath());
        URL[] jarurl = { file.toURL() };
        URLClassLoader classLoader = URLClassLoader.newInstance(jarurl);
        return classLoader;
    }

    /**
     * Returns the ClassLoader
     * @since 1.3.3
     */
    public static ClassLoader getClassLoader(String path) throws Exception {
        File file = new File(path);
        if (file.canRead() == false) {
            logger.warning(""Could not read path: "" + path);
            return null;
        }
        if (file.isDirectory())
            return getClassLoaderFromJars(path);
        else
            return getClassLoaderFromJar(path);
    }
}
","// ClassUtil_1Test.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassUtil}.
* It contains ten unit test cases for the {@link ClassUtil#getClassLoaderFromJars(String)} method.
*/
class ClassUtil_1Test {","// ClassUtil_1Test.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassUtil}.
* It contains ten unit test cases for the {@link ClassUtil#getClassLoaderFromJars(String)} method.
*/
class ClassUtil_1Test {

		private static Logger logger = Logger.getLogger(ClassUtil_1Test.class.getName());
		
		@Test
		public void testGetClassLoaderFromJars() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJars(""lib"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJars(""lib/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJars(""lib/../lib"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJars(""lib/../lib/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJars(""lib/../lib/../lib"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJars(""lib/../lib/../lib/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJars(""lib/../lib/../lib/../lib"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJars(""lib/../lib/../lib/../lib/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJars(""lib/../lib/../lib/../lib/../lib"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJars(""lib/../lib/../lib/../lib/../lib/"");
				assertNotNull(classLoader);
		}
}

// ClassUtil_2Test.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassUtil}.
* It contains ten unit test cases for the {@link ClassUtil#getClassLoaderFromJar(String)} method.
*/
class ClassUtil_2Test {
		
		private static Logger logger = Logger.getLogger(ClassUtil_2Test.class.getName());
		
		@Test
		public void testGetClassLoaderFromJar() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoaderFromJar(""lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJar(""lib/quickserver-1.4.7.jar/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJar(""lib/../lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJar(""lib/../lib/quickserver-1.4.7.jar/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJar(""lib/../lib/../lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJar(""lib/../lib/../lib/quickserver-1.4.7.jar/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJar(""lib/../lib/../lib/../lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJar(""lib/../lib/../lib/../lib/quickserver-1.4.7.jar/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJar(""lib/../lib/../lib/../lib/../lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoaderFromJar(""lib/../lib/../lib/../lib/../lib/quickserver-1.4.7.jar/"");
				assertNotNull(classLoader);
		}
}

// ClassUtil_3Test.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassUtil}.
* It contains ten unit test cases for the {@link ClassUtil#getClassLoader(String)} method.
*/
class ClassUtil_3Test {
		
		private static Logger logger = Logger.getLogger(ClassUtil_3Test.class.getName());
		
		@Test
		public void testGetClassLoader() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""lib"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoader(""lib/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoader(""lib/../lib"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoader(""lib/../lib/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoader(""lib/../lib/../lib"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoader(""lib/../lib/../lib/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoader(""lib/../lib/../lib/../lib"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoader(""lib/../lib/../lib/../lib/"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoader(""lib/../lib/../lib/../lib/../lib"");
				assertNotNull(classLoader);
				
				classLoader = ClassUtil.getClassLoader(""lib/../lib/../lib/../lib/../lib/"");
				assertNotNull(classLoader);
		}
}

// ClassUtil_4Test.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassUtil}.
* It contains ten unit test cases for the {@link ClassUtil#loadClass(ClassLoader, String[])} method.
*/
class ClassUtil_4Test {
		
		private static Logger logger = Logger.getLogger(ClassUtil_4Test.class.getName());
		
		@Test
		public void testLoadClass() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""lib"");
				assertNotNull(classLoader);
				
				String[] classNames = { ""org.quickserver.net.server.QuickServer"" };
				Map classHash = ClassUtil.loadClass(classLoader, classNames);
				assertNotNull(classHash);
				
				classNames = new String[] { ""org.quickserver.net.server.QuickServer"", ""org.quickserver.net.server.ClientHandler"" };
				classHash = ClassUtil.loadClass(classLoader, classNames);
				assertNotNull(classHash);
				
				classNames = new String[] { ""org.quickserver.net.server.QuickServer"", ""org.quickserver.net.server.ClientHandler"", ""org.quickserver.net.server.ClientData"" };
				classHash = ClassUtil.loadClass(classLoader, classNames);
				assertNotNull(classHash);
				
				classNames = new String[] { ""org.quickserver.net.server.QuickServer"", ""org.quickserver.net.server.ClientHandler"", ""org.quickserver.net.server.ClientData"", ""org.quickserver.net.server.ClientCommandHandler"" };
				classHash = ClassUtil.loadClass(classLoader, classNames);
				assertNotNull(classHash);
				
				classNames = new String[] { ""org.quickserver.net.server.QuickServer"", ""org.quickserver.net.server.ClientHandler"", ""org.quickserver.net.server.ClientData"", ""org.quickserver.net.server.ClientCommandHandler"", ""org.quickserver.net.server.ClientEventHandler"" };
				classHash = ClassUtil.loadClass(classLoader, classNames);
				assertNotNull(classHash);
				
				classNames = new String[] { ""org.quickserver.net.server.QuickServer"", ""org.quickserver.net.server.ClientHandler"", ""org.quickserver.net.server.ClientData"", ""org.quickserver.net.server.ClientCommandHandler"", ""org.quickserver.net.server.ClientEventHandler"", ""org.quickserver.net.server.Authenticator"" };
				classHash = ClassUtil.loadClass(classLoader, classNames);
				assertNotNull(classHash);
				
				classNames = new String[] { ""org.quickserver.net.server.QuickServer"", ""org.quickserver.net.server.ClientHandler"", ""org.quickserver.net.server.ClientData"", ""org.quickserver.net.server.ClientCommandHandler"", ""org.quickserver.net.server.ClientEventHandler"", ""org.quickserver.net.server.Authenticator"", ""org.quickserver.net.server.Authorizer"" };
				classHash = ClassUtil.loadClass(classLoader, classNames);
				assertNotNull(classHash);
				
				classNames = new String[] { ""org.quickserver.net.server.QuickServer"", ""org.quickserver.net.server.ClientHandler"", ""org.quickserver.net.server.ClientData"", ""org.quickserver.net.server.ClientCommandHandler"", ""org.quickserver.net.server.ClientEventHandler"", ""org.quickserver.net.server.Authenticator"", ""org.quickserver.net.server.Authorizer"", ""org.quickserver.net.server.BasicServer"" };
				classHash = ClassUtil.loadClass(classLoader, classNames);
				assertNotNull(classHash);
				
				classNames = new String[] { ""org.quickserver.net.server.QuickServer"", ""org.quickserver.net.server.ClientHandler"", ""org.quickserver.net.server.ClientData"", ""org.quickserver.net.server.ClientCommandHandler"", ""org.quickserver.net.server.ClientEventHandler"", ""org.quickserver.net.server.Authenticator"", ""org.quickserver.net.server.Authorizer"", ""org.quickserver.net.server.BasicServer"", ""org.quickserver.net.server.ClientInfo"" };
				classHash = ClassUtil.loadClass(classLoader, classNames);
				assertNotNull(classHash);
		}
}

// ClassUtil_5Test.java
package org.quickserver.util;

import java.util.*;
import java.io.*;
import java.net.*;
import org.quickserver.util.io.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassUtil}.
* It contains ten unit test cases for the {@link ClassUtil#loadClass(ClassLoader, String[])} method.
*/
class ClassUtil_5Test {
		
		private static Logger logger = Logger.getLogger(ClassUtil_5Test.class.getName());
		
		@Test
		public void testLoadClass() throws Exception {
				ClassLoader classLoader = ClassUtil.getClassLoader(""lib/quickserver-1.4.7.jar"");
				assertNotNull(classLoader);
				
				String[] classNames = { ""org.quickserver.net.server.QuickServer"" };
				Map classHash = ClassUtil.loadClass(classLoader, classNames);
				assertNotNull(classHash);
				
				classNames = new String[] { ""org.quickserver.net.server.QuickServer"", ""org.quickserver.net.server.ClientHandler"" };
				classHash = ClassUtil.loadClass(classLoader, classNames);
				assertNotNull(classHash);
				
				classNames = new String[] { ""org.quickserver.net.server.QuickServer"", ""org.quickserver.net.server.ClientHandler"", ""org.quickserver.net.server.ClientData"" };
				classHash = ClassUtil.loadClass(classLoader, classNames);
				assertNotNull(classHash);
				
				classNames = new String[] { ""org.quickserver.net.server.QuickServer"", ""org.quickserver.net.server.ClientHandler"", ""org.quickserver.net.server.ClientData"", ""org.quickserver.net.server.ClientCommandHandler"" };
				classHash = ClassUtil.loadClass(classLoader, classNames);
				assertNotNull(classHash);
				
				classNames = new String[] { ""org.quickserver.net.server.QuickServer"", ""org.quickserver.net.server.ClientHandler"", ""org.quickserver.net.server.ClientData"", ""org.quickserver.net.server.ClientCommandHandler"", ""org.quickserver.net.server.ClientEventHandler"" };
				classHash = ClassUtil.loadClass(classLoader, classNames);
				assertNotNull(classHash);
				
				classNames = new String[] { ""org.quickserver.net.server.QuickServer"", ""org.quickserver.net.server.ClientHandler"", ""org.quickserver.net.server.ClientData"", """
cmpl-6wgoVShtNUpUttMJrQO2FiQbhOEDv,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/util/io/ByteBufferInputStream_8Test.java,145.7860267162323,length,"// ByteBufferInputStream.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.io;

import java.io.*;
import java.nio.*;
import java.nio.charset.*;
import java.util.*;
import org.quickserver.net.server.ClientHandler;
import java.util.logging.*;
import org.quickserver.util.*;

/**
 * This is an InputStream constructed from list of ByteBuffers. This is
 * used in non-blocking mode.
 * @since 1.4.5
 * @author Akshathkumar Shetty
 */
public class ByteBufferInputStream extends InputStream {

    private static final Logger logger = Logger.getLogger(ByteBufferInputStream.class.getName());

    static {
        logger.setLevel(Level.INFO);
    }

    /**
     * Sets the debug flag.
     */
    public static void setDebug(boolean flag) {
        if (flag)
            logger.setLevel(Level.FINEST);
        else
            logger.setLevel(Level.INFO);
    }

    /**
     * @since 1.4.7
     */
    public static boolean isLoggable(Level level) {
        return logger.isLoggable(level);
    }

    private final ArrayList bufferList;

    private ClientHandler handler;

    private CharsetDecoder decoder;

    private CharsetEncoder encoder;

    private StringBuilder strings;

    private int pos = 0;

    private int index = -1;

    private int start = 0;

    private boolean lookingForLineFeed = false;

    public ByteBufferInputStream(ArrayList bufferList, ClientHandler handler, String charset) {
        if (bufferList == null || handler == null)
            throw new IllegalArgumentException(""ArrayList or ClientHandler was null."");
        this.bufferList = bufferList;
        this.handler = handler;
        Charset _charset = Charset.forName(charset);
        decoder = _charset.newDecoder();
        encoder = _charset.newEncoder();
        strings = new StringBuilder();
    }

    public synchronized int availableOnlyInByteBuffer() {
        int count = 0;
        ByteBuffer byteBuffer = null;
        int size = bufferList.size();
        for (int c = 0; c < size; c++) {
            byteBuffer = (ByteBuffer) bufferList.get(c);
            count += byteBuffer.remaining();
        }
        logger.finest(""count: "" + count);
        return count;
    }

    public synchronized int available() {
        int count = 0;
        ByteBuffer byteBuffer = null;
        if (lookingForLineFeed) {
            char c = '\0';
            if (strings.length() != 0) {
                c = strings.charAt(0);
                if (c == '\n') {
                    strings.deleteCharAt(0);
                    lookingForLineFeed = false;
                }
            } else {
                while (!bufferList.isEmpty()) {
                    byteBuffer = (ByteBuffer) bufferList.get(0);
                    if (byteBuffer.remaining() == 0) {
                        returnBufferBack();
                        continue;
                    }
                    int p = byteBuffer.position();
                    c = (char) byteBuffer.get(p);
                    if (c == '\n') {
                        //move position
                        byteBuffer.get();
                        lookingForLineFeed = false;
                    }
                    break;
                }
                //end of while
            }
        }
        count += strings.length();
        int size = bufferList.size();
        for (int c = 0; c < size; c++) {
            byteBuffer = (ByteBuffer) bufferList.get(c);
            count += byteBuffer.remaining();
        }
        //logger.finest(""count: ""+count);
        return count;
    }

    public synchronized void close() throws IOException {
        if (handler.getSocketChannel() != null)
            handler.getSocketChannel().close();
        //handler.closeConnection();
    }

    public boolean markSupported() {
        return false;
    }

    public synchronized int read() throws IOException {
        handler.isConnected();
        if (strings.length() != 0) {
            addStringsBackAsBuffer();
        }
        if (bufferList.isEmpty()) {
            try {
                wait();
            } catch (InterruptedException ie) {
                logger.warning(""InterruptedException: "" + ie);
                return -1;
            }
            if (bufferList.isEmpty())
                return -1;
        }
        ByteBuffer byteBuffer = null;
        while (!bufferList.isEmpty()) {
            byteBuffer = (ByteBuffer) bufferList.get(0);
            if (byteBuffer.remaining() == 0) {
                returnBufferBack();
                continue;
            }
            if (lookingForLineFeed) {
                int lflfChar = (int) byteBuffer.get();
                lookingForLineFeed = false;
                if (lflfChar == (int) '\n') {
                    continue;
                } else {
                    return lflfChar;
                }
            } else {
                return (int) byteBuffer.get();
            }
        }
        return read();
    }

    public int read(byte[] b) throws IOException {
        return read(b, 0, b.length);
    }

    public synchronized int read(byte[] b, int off, int len) throws IOException {
        handler.isConnected();
        if (strings.length() != 0) {
            addStringsBackAsBuffer();
        }
        if (bufferList.isEmpty()) {
            try {
                wait();
            } catch (InterruptedException ie) {
                logger.warning(""InterruptedException: "" + ie);
                //ie.printStackTrace();
                return -1;
            }
            if (bufferList.isEmpty())
                return -1;
        }
        ByteBuffer byteBuffer = null;
        int read = 0;
        int remaining = 0;
        int toRead = len;
        do {
            byteBuffer = (ByteBuffer) bufferList.get(0);
            remaining = byteBuffer.remaining();
            if (remaining == 0) {
                returnBufferBack();
                continue;
            }
            if (lookingForLineFeed) {
                int p = byteBuffer.position();
                byte lflfChar = byteBuffer.get(p);
                lookingForLineFeed = false;
                if (lflfChar == (byte) '\n') {
                    //move position
                    byteBuffer.get();
                    continue;
                }
            }
            if (remaining < toRead) {
                byteBuffer.get(b, off, remaining);
                off = off + remaining;
                read = read + remaining;
                toRead = toRead - remaining;
            } else {
                byteBuffer.get(b, off, toRead);
                read = read + toRead;
                return read;
            }
        } while (!bufferList.isEmpty());
        return read;
    }

    public long skip(long n) throws IOException {
        if (n < 0)
            return 0;
        int s = 0;
        for (; s < n; s++) {
            if (read() == -1)
                break;
        }
        return s;
    }

    private void addStringsBackAsBuffer() {
        try {
            ByteBuffer borrowBuffer = null;
            ByteBuffer bb = encoder.encode(CharBuffer.wrap(strings));
            strings.setLength(0);
            do {
                if (borrowBuffer == null) {
                    borrowBuffer = (ByteBuffer) handler.getServer().getByteBufferPool().borrowObject();
                }
                borrowBuffer.put(bb.get());
                if (borrowBuffer.hasRemaining() == false) {
                    borrowBuffer.flip();
                    bufferList.add(0, borrowBuffer);
                    borrowBuffer = null;
                }
            } while (bb.hasRemaining());
            if (borrowBuffer != null) {
                borrowBuffer.flip();
                bufferList.add(0, borrowBuffer);
            }
        } catch (Exception er) {
            logger.warning(""Error : "" + er);
        }
        start = 0;
        index = -1;
        pos = 0;
    }

    private void returnBufferBack() {
        returnBufferBack((ByteBuffer) bufferList.remove(0));
    }

    private void returnBufferBack(ByteBuffer byteBuffer) {
        try {
            handler.getServer().getByteBufferPool().returnObject(byteBuffer);
        } catch (Exception er) {
            logger.warning(""Error while returning ByteBuffer to pool: "" + er);
        }
    }

    //-- extra helpers
    /**
     * Checks if a line of String is ready to be read.
     * @throws IOException if connection is lost or closed.
     */
    public synchronized boolean isLineReady() throws IOException {
        handler.isConnected();
        boolean result = false;
        result = isLineReadyForStringBuilder();
        if (result == true || bufferList.isEmpty()) {
            if (logger.isLoggable(Level.FINEST))
                logger.finest(""result: "" + result);
            return result;
        }
        ByteBuffer byteBuffer = null;
        CharBuffer charBuffer = null;
        while (result == false && !bufferList.isEmpty()) {
            byteBuffer = (ByteBuffer) bufferList.get(0);
            if (byteBuffer.remaining() == 0) {
                returnBufferBack();
                continue;
            }
            charBuffer = decoder.decode(byteBuffer);
            if (charBuffer == null) {
                returnBufferBack();
                continue;
            }
            strings.append(charBuffer);
            returnBufferBack();
            result = isLineReadyForStringBuilder();
        }
        //end of while
        if (logger.isLoggable(Level.FINEST))
            logger.finest(""result: "" + result);
        return result;
    }

    private boolean isLineReadyForStringBuilder() {
        if (index != -1)
            return true;
        int stringsLength = strings.length();
        while (pos < stringsLength) {
            char c = strings.charAt(pos);
            if (c == '\n') {
                if (lookingForLineFeed) {
                    strings.deleteCharAt(0);
                    stringsLength--;
                    lookingForLineFeed = false;
                    continue;
                } else {
                    index = pos;
                    pos++;
                    return true;
                }
            }
            if (c == '\r') {
                index = pos;
                lookingForLineFeed = true;
                pos++;
                return true;
            } else {
                pos++;
                lookingForLineFeed = false;
            }
        }
        return false;
    }

    /**
     * Reads a line of String if ready. If line is not yet ready this will
     * block. To find out if the line is ready use <code>isLineReady()</code>
     * @see #isLineReady()
     */
    public synchronized String readLine() throws IOException {
        if (index == -1) {
            while (isLineReady() == false) {
                try {
                    wait();
                } catch (InterruptedException ie) {
                    logger.warning(""InterruptedException: "" + ie);
                    return null;
                }
            }
        }
        int stringsLength = strings.length();
        Assertion.affirm(index <= stringsLength);
        String data = strings.substring(start, index);
        if (pos < stringsLength)
            strings.delete(0, pos);
        else
            strings.setLength(0);
        start = 0;
        pos = start;
        index = -1;
        return data;
    }

    public void dumpContent() {
        if (logger.isLoggable(Level.FINE) == false) {
            //logger.warning(""Can't precede. Logging level FINE is not loggable! "");
            return;
        }
        logger.fine(""Start of dump.."");
        synchronized (bufferList) {
            int size = bufferList.size();
            ByteBuffer byteBuffer = null;
            if (strings.length() != 0) {
                logger.fine(""[decoded] "" + strings);
            }
            for (int c = 0; c < size; c++) {
                byteBuffer = (ByteBuffer) bufferList.get(c);
                try {
                    logger.fine(""["" + c + ""] "" + decoder.decode(byteBuffer.duplicate()));
                } catch (Exception e) {
                    logger.fine(""["" + c + ""] Error : "" + e);
                }
            }
        }
        logger.fine(""End of dump.."");
    }
}
","// ByteBufferInputStream_8Test.java
package org.quickserver.util.io;

import java.io.*;
import java.nio.*;
import java.nio.charset.*;
import java.util.*;
import org.quickserver.net.server.ClientHandler;
import java.util.logging.*;
import org.quickserver.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ByteBufferInputStream}.
* It contains ten unit test cases for the {@link ByteBufferInputStream#readLine()} method.
*/
class ByteBufferInputStream_8Test {","// ByteBufferInputStream_8Test.java
package org.quickserver.util.io;

import java.io.*;
import java.nio.*;
import java.nio.charset.*;
import java.util.*;
import org.quickserver.net.server.ClientHandler;
import java.util.logging.*;
import org.quickserver.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ByteBufferInputStream}.
* It contains ten unit test cases for the {@link ByteBufferInputStream#readLine()} method.
*/
class ByteBufferInputStream_8Test {

	private static final Logger logger = Logger.getLogger(ByteBufferInputStream_8Test.class.getName());
	
	static {
		logger.setLevel(Level.INFO);
	}
	
	private static final String charset = ""UTF-8"";
	
	private static final String lineSeparator = System.getProperty(""line.separator"");
	
	private static final String testString = ""This is a test string."";
	
	private static final String testString_1 = ""This is a test string."" + lineSeparator;
	
	private static final String testString_2 = ""This is a test string."" + lineSeparator + lineSeparator;
	
	private static final String testString_3 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_4 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_5 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_6 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_7 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_8 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_9 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_10 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_11 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_12 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_13 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_14 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_15 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_16 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_17 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_18 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_19 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_20 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_21 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_22 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_23 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_24 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_25 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_26 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_27 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_28 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_29 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_30 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_31 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_32 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_33 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_34 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_35 = ""This is a test string."" + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator + lineSeparator;
	
	private static final String testString_36 = ""This is a test string."" + lineSeparator + lineSeparator +"
cmpl-6wgqqXU5Xat3FErp45HnKloYE9lFB,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/util/io/PasswordField_0Test.java,129.5207314491272,length,"// PasswordField.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;

/**
 * This class prompts the user for a password and attempts to mask
 * input.
 * @since 1.4
 */
public class PasswordField {

    private static Logger logger = Logger.getLogger(PasswordField.class.getName());

    /**
     * @param prompt The prompt to display to the user.
     * @return The password as entered by the user.
     */
    public static final char[] getPassword(String prompt) throws IOException {
        return getPassword(System.in, prompt);
    }

    /**
     * @param in input stream to be used (e.g. System.in)
     * @param prompt The prompt to display to the user.
     * @return The password as entered by the user.
     */
    public static final char[] getPassword(InputStream in, String prompt) throws IOException {
        MaskingThread maskingthread = new MaskingThread(prompt);
        Thread thread = new Thread(maskingthread);
        thread.start();
        char[] lineBuffer;
        char[] buf;
        int i;
        buf = lineBuffer = new char[128];
        int room = buf.length;
        int offset = 0;
        int c;
        loop: while (true) {
            c = in.read();
            switch(c) {
                case -1:
                case '\n':
                    break loop;
                case '\r':
                    int c2 = in.read();
                    if ((c2 != '\n') && (c2 != -1)) {
                        if (!(in instanceof PushbackInputStream)) {
                            in = new PushbackInputStream(in);
                        }
                        ((PushbackInputStream) in).unread(c2);
                    } else {
                        break loop;
                    }
                default:
                    if (--room < 0) {
                        buf = new char[offset + 128];
                        room = buf.length - offset - 1;
                        System.arraycopy(lineBuffer, 0, buf, 0, offset);
                        Arrays.fill(lineBuffer, ' ');
                        lineBuffer = buf;
                    }
                    buf[offset++] = (char) c;
                    break;
            }
        }
        maskingthread.stopMasking();
        System.out.print(""\010"");
        //Code to clear doskey on win nt/2000 - Alt+F7
        String os = System.getProperty(""os.name"");
        if (os != null && os.toLowerCase().startsWith(""windows"")) {
            try {
                java.awt.Robot robot = new java.awt.Robot();
                robot.keyPress(java.awt.event.KeyEvent.VK_ALT);
                robot.keyPress(java.awt.event.KeyEvent.VK_F7);
                robot.keyRelease(java.awt.event.KeyEvent.VK_F7);
                robot.keyRelease(java.awt.event.KeyEvent.VK_ALT);
            } catch (Exception ignore) {
                logger.warning(""Could not clears command history: "" + ignore);
            }
        }
        if (offset == 0) {
            return null;
        }
        char[] ret = new char[offset];
        System.arraycopy(buf, 0, ret, 0, offset);
        Arrays.fill(buf, ' ');
        return ret;
    }
}
","// PasswordField_0Test.java
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PasswordField}.
* It contains ten unit test cases for the {@link PasswordField#getPassword(String)} method.
*/
class PasswordField_0Test {","// PasswordField_0Test.java
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PasswordField}.
* It contains ten unit test cases for the {@link PasswordField#getPassword(String)} method.
*/
class PasswordField_0Test {

	@Test
	void testGetPassword_0() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_1() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_2() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_3() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_4() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_5() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_6() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_7() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_8() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_9() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
}

// MaskingThread.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;

/**
 * This class attempts to erase characters echoed to the console.
 * @since 1.4
 */
class MaskingThread extends Thread {
    private volatile boolean stop;
    private char echochar = '*';

    /**
     *@param prompt The prompt displayed to the user
     */
    public MaskingThread(String prompt) {
        System.out.print(prompt);
    }

    /**
     * Begin masking until asked to stop.
     */
    public void run() {
        int priority = Thread.currentThread().getPriority();
        Thread.currentThread().setPriority(Thread.MAX_PRIORITY);
        try {
            stop = true;
            while (stop) {
                System.out.print(""\010"" + echochar);
                try {
                    // attempt masking at this rate
                    Thread.sleep(1);
                } catch (InterruptedException iex) {
                    Thread.currentThread().interrupt();
                    return;
                }
            }
        } finally { // restore the original priority
            Thread.currentThread().setPriority(priority);
        }
    }

    /**
     * Instruct the thread to stop masking.
     */
    public void stopMasking() {
        this.stop = false;
    }
}

// PasswordField_1Test.java
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PasswordField}.
* It contains ten unit test cases for the {@link PasswordField#getPassword(String)} method.
*/
class PasswordField_1Test {
		
	@Test
	void testGetPassword_0() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_1() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_2() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_3() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_4() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_5() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_6() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_7() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_8() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_9() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
}

// PasswordField_2Test.java
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PasswordField}.
* It contains ten unit test cases for the {@link PasswordField#getPassword(String)} method.
*/
class PasswordField_2Test {
		
	@Test
	void testGetPassword_0() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_1() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_2() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_3() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_4() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_5() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_6() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_7() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r\n"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_8() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\r"").getBytes());
		System.setIn(in);
		char[] result = PasswordField.getPassword(System.in, prompt);
		assertEquals(password, new String(result));
	}
	
	@Test
	void testGetPassword_9() throws IOException {
		String prompt = ""Enter password: "";
		String password = ""password"";
		ByteArrayInputStream in = new ByteArrayInputStream((password+""\n"").getBytes());
		System.setIn("
cmpl-6wgsw0kExSTWOm5guwnVo4XWiS5wD,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/util/io/PasswordField_1Test.java,119.00131130218506,length,"// PasswordField.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;

/**
 * This class prompts the user for a password and attempts to mask
 * input.
 * @since 1.4
 */
public class PasswordField {

    private static Logger logger = Logger.getLogger(PasswordField.class.getName());

    /**
     * @param prompt The prompt to display to the user.
     * @return The password as entered by the user.
     */
    public static final char[] getPassword(String prompt) throws IOException {
        return getPassword(System.in, prompt);
    }

    /**
     * @param in input stream to be used (e.g. System.in)
     * @param prompt The prompt to display to the user.
     * @return The password as entered by the user.
     */
    public static final char[] getPassword(InputStream in, String prompt) throws IOException {
        MaskingThread maskingthread = new MaskingThread(prompt);
        Thread thread = new Thread(maskingthread);
        thread.start();
        char[] lineBuffer;
        char[] buf;
        int i;
        buf = lineBuffer = new char[128];
        int room = buf.length;
        int offset = 0;
        int c;
        loop: while (true) {
            c = in.read();
            switch(c) {
                case -1:
                case '\n':
                    break loop;
                case '\r':
                    int c2 = in.read();
                    if ((c2 != '\n') && (c2 != -1)) {
                        if (!(in instanceof PushbackInputStream)) {
                            in = new PushbackInputStream(in);
                        }
                        ((PushbackInputStream) in).unread(c2);
                    } else {
                        break loop;
                    }
                default:
                    if (--room < 0) {
                        buf = new char[offset + 128];
                        room = buf.length - offset - 1;
                        System.arraycopy(lineBuffer, 0, buf, 0, offset);
                        Arrays.fill(lineBuffer, ' ');
                        lineBuffer = buf;
                    }
                    buf[offset++] = (char) c;
                    break;
            }
        }
        maskingthread.stopMasking();
        System.out.print(""\010"");
        //Code to clear doskey on win nt/2000 - Alt+F7
        String os = System.getProperty(""os.name"");
        if (os != null && os.toLowerCase().startsWith(""windows"")) {
            try {
                java.awt.Robot robot = new java.awt.Robot();
                robot.keyPress(java.awt.event.KeyEvent.VK_ALT);
                robot.keyPress(java.awt.event.KeyEvent.VK_F7);
                robot.keyRelease(java.awt.event.KeyEvent.VK_F7);
                robot.keyRelease(java.awt.event.KeyEvent.VK_ALT);
            } catch (Exception ignore) {
                logger.warning(""Could not clears command history: "" + ignore);
            }
        }
        if (offset == 0) {
            return null;
        }
        char[] ret = new char[offset];
        System.arraycopy(buf, 0, ret, 0, offset);
        Arrays.fill(buf, ' ');
        return ret;
    }
}
","// PasswordField_1Test.java
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PasswordField}.
* It contains ten unit test cases for the {@link PasswordField#getPassword(InputStream, String)} method.
*/
class PasswordField_1Test {","// PasswordField_1Test.java
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PasswordField}.
* It contains ten unit test cases for the {@link PasswordField#getPassword(InputStream, String)} method.
*/
class PasswordField_1Test {

	/**
	* Test case for {@link PasswordField#getPassword(InputStream, String)} method.
	* Test data: null.
	* Expected result: NullPointerException.
	*/
	@Test
	public void testGetPassword_1() throws Exception {
		try {
			PasswordField.getPassword(null, ""test"");
			fail(""NullPointerException expected"");
		} catch (NullPointerException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(InputStream, String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_2() throws Exception {
		try {
			PasswordField.getPassword(new ByteArrayInputStream(new byte[0]), ""test"");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(InputStream, String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_3() throws Exception {
		try {
			PasswordField.getPassword(new ByteArrayInputStream(new byte[0]), ""test"");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(InputStream, String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_4() throws Exception {
		try {
			PasswordField.getPassword(new ByteArrayInputStream(new byte[0]), ""test"");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(InputStream, String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_5() throws Exception {
		try {
			PasswordField.getPassword(new ByteArrayInputStream(new byte[0]), ""test"");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(InputStream, String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_6() throws Exception {
		try {
			PasswordField.getPassword(new ByteArrayInputStream(new byte[0]), ""test"");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(InputStream, String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_7() throws Exception {
		try {
			PasswordField.getPassword(new ByteArrayInputStream(new byte[0]), ""test"");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(InputStream, String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_8() throws Exception {
		try {
			PasswordField.getPassword(new ByteArrayInputStream(new byte[0]), ""test"");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(InputStream, String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_9() throws Exception {
		try {
			PasswordField.getPassword(new ByteArrayInputStream(new byte[0]), ""test"");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(InputStream, String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_10() throws Exception {
		try {
			PasswordField.getPassword(new ByteArrayInputStream(new byte[0]), ""test"");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
}

// MaskingThread.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.io;

/**
 * This class attempts to erase characters echoed to the console.
 * @since 1.4
 */
class MaskingThread extends Thread {
    private volatile boolean stop;
    private char echochar = '*';

    /**
     *@param prompt The prompt displayed to the user
     */
    public MaskingThread(String prompt) {
        System.out.print(prompt);
    }

    /**
     * Begin masking until asked to stop.
     */
    public void run() {
        int priority = Thread.currentThread().getPriority();
        Thread.currentThread().setPriority(Thread.MAX_PRIORITY);
        try {
            stop = true;
            while (stop) {
                System.out.print(""\010"" + echochar);
                try {
                    // attempt masking at this rate
                    Thread.sleep(1);
                } catch (InterruptedException iex) {
                    Thread.currentThread().interrupt();
                    return;
                }
            }
        } finally { // restore the original priority
            Thread.currentThread().setPriority(priority);
        }
    }

    /**
     * Instruct the thread to stop masking.
     */
    public void stopMasking() {
        this.stop = false;
    }
}

// PasswordField_2Test.java
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PasswordField}.
* It contains ten unit test cases for the {@link PasswordField#getPassword(String)} method.
*/
class PasswordField_2Test {
		
	/**
	* Test case for {@link PasswordField#getPassword(String)} method.
	* Test data: null.
	* Expected result: NullPointerException.
	*/
	@Test
	public void testGetPassword_1() throws Exception {
		try {
			PasswordField.getPassword(null);
			fail(""NullPointerException expected"");
		} catch (NullPointerException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_2() throws Exception {
		try {
			PasswordField.getPassword("""");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_3() throws Exception {
		try {
			PasswordField.getPassword("""");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_4() throws Exception {
		try {
			PasswordField.getPassword("""");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_5() throws Exception {
		try {
			PasswordField.getPassword("""");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_6() throws Exception {
		try {
			PasswordField.getPassword("""");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_7() throws Exception {
		try {
			PasswordField.getPassword("""");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_8() throws Exception {
		try {
			PasswordField.getPassword("""");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_9() throws Exception {
		try {
			PasswordField.getPassword("""");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#getPassword(String)} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testGetPassword_10() throws Exception {
		try {
			PasswordField.getPassword("""");
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
}

// PasswordField_3Test.java
package org.quickserver.util.io;

import java.io.*;
import java.util.*;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PasswordField}.
* It contains ten unit test cases for the {@link PasswordField#main(String[])} method.
*/
class PasswordField_3Test {
		
	/**
	* Test case for {@link PasswordField#main(String[])} method.
	* Test data: null.
	* Expected result: NullPointerException.
	*/
	@Test
	public void testMain_1() throws Exception {
		try {
			PasswordField.main(null);
			fail(""NullPointerException expected"");
		} catch (NullPointerException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#main(String[])} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testMain_2() throws Exception {
		try {
			PasswordField.main(new String[0]);
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#main(String[])} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testMain_3() throws Exception {
		try {
			PasswordField.main(new String[0]);
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#main(String[])} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testMain_4() throws Exception {
		try {
			PasswordField.main(new String[0]);
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#main(String[])} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testMain_5() throws Exception {
		try {
			PasswordField.main(new String[0]);
			fail(""IllegalArgumentException expected"");
		} catch (IllegalArgumentException e) {
			// OK
		}
	}
	
	/**
	* Test case for {@link PasswordField#main(String[])} method.
	* Test data: empty string.
	* Expected result: IllegalArgumentException.
	*/
	@Test
	public void testMain_6() throws Exception {
		try {
			PasswordField.main(new String[0]);
			fail(""IllegalArgumentException expected"");
		}"
cmpl-6wgurxYCitNdxEaEDe8dyO5xc2nJm,/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/util/pool/thread/ClientPool.java,102.4542646408081,length,"// ClientPool.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.pool.thread;

import java.util.*;
import org.quickserver.util.pool.*;
import org.apache.commons.pool.*;
import org.quickserver.net.server.*;
import org.quickserver.util.xmlreader.PoolConfig;
import java.util.logging.*;

/**
 * This is a class for managing the pool of threads for
 * handling clients.
 * @author Akshathkumar Shetty
 * @since 1.3
 */
public class ClientPool {

    private static final Logger logger = Logger.getLogger(ClientPool.class.getName());

    protected List clients = new ArrayList(3);

    protected ObjectPool pool;

    protected PoolConfig poolConfig;

    //v1.4.6
    private int countNioWriteThreads;

    private int maxThreadsForNioWrite = 10;

    public ClientPool(QSObjectPool objectPool, PoolConfig poolConfig) {
        this.poolConfig = poolConfig;
        pool = objectPool;
    }

    public ObjectPool getObjectPool() {
        return pool;
    }

    public void addClient(Runnable r) throws NoSuchElementException {
        addClient(r, false);
    }

    public synchronized void addClient(Runnable r, boolean keepObjOnFail) throws NoSuchElementException {
        //logger.finest(""Adding Runnable: ""+r);
        clients.add(r);
        ClientThread ct = null;
        try {
            ct = (ClientThread) pool.borrowObject();
            if (ct.isReady() == false) {
                //ct.start();
                //timeout was just in case :-)
                wait(500);
                //Thread.yield();
            } else {
                synchronized (ct) {
                    ct.notify();
                }
            }
        } catch (NoSuchElementException e) {
            logger.info(""No free threads: "" + e);
            if (keepObjOnFail == false)
                clients.remove(r);
            throw e;
        } catch (Exception e) {
            logger.warning(""Error in addClient: "" + e + "", Closing client: "" + (ClientHandler) r);
            try {
                ((ClientHandler) r).forceClose();
            } catch (Exception er) {
                logger.warning(""Error closing client: "" + er);
            }
            try {
                if (ct != null)
                    pool.returnObject(ct);
            } catch (Exception er) {
                logger.warning(""Error in returning thread: "" + er);
            }
        }
    }

    public synchronized void returnObject(Object object) {
        try {
            pool.returnObject(object);
        } catch (Exception e) {
            logger.warning(""IGONRED: Error while returning object : "" + e);
            ((Thread) object).interrupt();
        }
    }

    public synchronized Runnable getClient() {
        if (clients.isEmpty()) {
            return null;
        }
        return (Runnable) clients.remove(0);
    }

    /**
     * @since 1.4.5
     */
    public boolean isClientAvailable() {
        if (clients.isEmpty()) {
            return false;
        } else {
            return true;
        }
    }

    protected void finalize() throws Throwable {
        try {
            close();
        } catch (Exception e) {
            logger.warning(""IGONRED:finalize in pool close : "" + e);
        }
        super.finalize();
    }

    public void close() throws Exception {
        pool.close();
    }

    public void clear() throws Exception {
        pool.clear();
    }

    /**
     * Return the number of instances currently borrowed from my pool.
     * @since 1.4.1
     */
    public int getNumActive() {
        return pool.getNumActive();
    }

    /**
     * Return the number of instances currently idle in my pool.
     * @since 1.4.1
     */
    public int getNumIdle() {
        return pool.getNumIdle();
    }

    /**
     * Returns iterator containing all the active
     * threads i.e ClientHandler handling connected clients.
     * @since 1.3.1
     */
    public final Iterator getAllClientThread() {
        return ((QSObjectPool) pool).getAllActiveObjects();
    }

    public Object getObjectToSynchronize() {
        return ((QSObjectPool) pool).getObjectToSynchronize();
    }

    /**
     * Returns PoolConfig object that configured this pool
     * @since 1.4.5
     */
    public PoolConfig getPoolConfig() {
        return poolConfig;
    }

    /**
     * Sets the maximum threads allowed for nio write. If set to 0 or less no limit is
     * imposed.
     * @since 1.4.6
     */
    public void setMaxThreadsForNioWrite(int count) {
        this.maxThreadsForNioWrite = count;
    }

    /**
     * Returns the maximum threads allowed for nio write
     * @since 1.4.6
     */
    public int getMaxThreadsForNioWrite() {
        return maxThreadsForNioWrite;
    }

    /**
     * Notifies when NIO write is complete.
     * @since 1.4.6
     */
    protected void nioWriteEnd() {
        countNioWriteThreads--;
        if (countNioWriteThreads < 0) {
            logger.warning(""countNioWriteThreads should not go less than 0"");
            countNioWriteThreads = 0;
        }
    }

    /**
     * Notifies when NIO write is about to start.
     * @since 1.4.6
     */
    protected void nioWriteStart() {
        countNioWriteThreads++;
    }

    /**
     * Method to suggest if nio write should be sent for processing.
     * @since 1.4.6
     */
    public boolean shouldNioWriteHappen() {
        if (maxThreadsForNioWrite <= 0 || countNioWriteThreads < maxThreadsForNioWrite) {
            return true;
        } else {
            return false;
        }
    }
}
","// ClientPoolTest.java
package org.quickserver.util.pool.thread;

import java.util.*;
import org.quickserver.util.pool.*;
import org.apache.commons.pool.*;
import org.quickserver.net.server.*;
import org.quickserver.util.xmlreader.PoolConfig;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientPool}.
* It contains ten unit test cases for the {@link ClientPool#shouldNioWriteHappen()} method.
*/
class ClientPoolTest {","// ClientPoolTest.java
package org.quickserver.util.pool.thread;

import java.util.*;
import org.quickserver.util.pool.*;
import org.apache.commons.pool.*;
import org.quickserver.net.server.*;
import org.quickserver.util.xmlreader.PoolConfig;
import java.util.logging.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClientPool}.
* It contains ten unit test cases for the {@link ClientPool#shouldNioWriteHappen()} method.
*/
class ClientPoolTest {

		private static final Logger logger = Logger.getLogger(ClientPoolTest.class.getName());
		
		private ClientPool clientPool;
		
		private PoolConfig poolConfig;
		
		private QSObjectPool objectPool;
		
		private ClientThread clientThread;
		
		private Runnable runnable;
		
		private int maxThreadsForNioWrite;
		
		private int countNioWriteThreads;
		
		private boolean shouldNioWriteHappen;
		
		private void setUp() {
				poolConfig = new PoolConfig();
				objectPool = new QSObjectPool(poolConfig);
				clientPool = new ClientPool(objectPool, poolConfig);
				clientThread = new ClientThread(clientPool);
				runnable = new Runnable() {
						public void run() {
								logger.info(""Runnable"");
						}
				};
		}
		
		@Test
		void testShouldNioWriteHappen() {
				setUp();
				maxThreadsForNioWrite = 10;
				countNioWriteThreads = 0;
				shouldNioWriteHappen = true;
				assertEquals(shouldNioWriteHappen, clientPool.shouldNioWriteHappen());
				
				setUp();
				maxThreadsForNioWrite = 10;
				countNioWriteThreads = 10;
				shouldNioWriteHappen = false;
				assertEquals(shouldNioWriteHappen, clientPool.shouldNioWriteHappen());
				
				setUp();
				maxThreadsForNioWrite = 10;
				countNioWriteThreads = 11;
				shouldNioWriteHappen = false;
				assertEquals(shouldNioWriteHappen, clientPool.shouldNioWriteHappen());
				
				setUp();
				maxThreadsForNioWrite = 0;
				countNioWriteThreads = 0;
				shouldNioWriteHappen = true;
				assertEquals(shouldNioWriteHappen, clientPool.shouldNioWriteHappen());
				
				setUp();
				maxThreadsForNioWrite = 0;
				countNioWriteThreads = 10;
				shouldNioWriteHappen = true;
				assertEquals(shouldNioWriteHappen, clientPool.shouldNioWriteHappen());
				
				setUp();
				maxThreadsForNioWrite = -1;
				countNioWriteThreads = 0;
				shouldNioWriteHappen = true;
				assertEquals(shouldNioWriteHappen, clientPool.shouldNioWriteHappen());
				
				setUp();
				maxThreadsForNioWrite = -1;
				countNioWriteThreads = 10;
				shouldNioWriteHappen = true;
				assertEquals(shouldNioWriteHappen, clientPool.shouldNioWriteHappen());
				
				setUp();
				maxThreadsForNioWrite = -10;
				countNioWriteThreads = 0;
				shouldNioWriteHappen = true;
				assertEquals(shouldNioWriteHappen, clientPool.shouldNioWriteHappen());
				
				setUp();
				maxThreadsForNioWrite = -10;
				countNioWriteThreads = 10;
				shouldNioWriteHappen = true;
				assertEquals(shouldNioWriteHappen, clientPool.shouldNioWriteHappen());
				
				setUp();
				maxThreadsForNioWrite = 10;
				countNioWriteThreads = -1;
				shouldNioWriteHappen = true;
				assertEquals(shouldNioWriteHappen, clientPool.shouldNioWriteHappen());
		}
}

// ClientThread.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.pool.thread;

import java.util.*;
import org.quickserver.util.pool.*;
import org.apache.commons.pool.*;
import org.quickserver.net.server.*;
import org.quickserver.util.xmlreader.PoolConfig;
import java.util.logging.*;

/**
 * This is a class for handling clients.
 * @author Akshathkumar Shetty
 * @since 1.3
 */
public class ClientThread extends Thread {

    private static final Logger logger = Logger.getLogger(ClientThread.class.getName());

    private ClientPool clientPool;

    private boolean ready = false;

    private boolean running = true;

    private Runnable client;

    public ClientThread(ClientPool clientPool) {
        this.clientPool = clientPool;
        setDaemon(true);
        start();
    }

    public void run() {
        while (running) {
            try {
                synchronized (this) {
                    ready = true;
                    wait();
                }
                client = clientPool.getClient();
                if (client != null) {
                    client.run();
                }
            } catch (InterruptedException e) {
                logger.warning(""Interrupted: "" + e);
            } catch (Exception e) {
                logger.warning(""Error in ClientThread: "" + e);
            } finally {
                clientPool.returnObject(this);
            }
        }
    }

    public boolean isReady() {
        return ready;
    }

    public void close() {
        running = false;
        interrupt();
    }
}

// QSObjectPool.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.pool;

import java.util.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.PoolConfig;
import java.util.logging.*;

/**
 * This is a class for managing the pool of objects.
 * @author Akshathkumar Shetty
 * @since 1.3
 */
public class QSObjectPool implements ObjectPool {

    private static final Logger logger = Logger.getLogger(QSObjectPool.class.getName());

    private ObjectPool pool;

    private PoolConfig poolConfig;

    private Object objectToSynchronize;

    public QSObjectPool(PoolConfig poolConfig) {
        this.poolConfig = poolConfig;
        pool = new StackObjectPool(new QSObjectPoolFactory(poolConfig), poolConfig.getMaxActive(), poolConfig.getWhenExhaustedAction(), poolConfig.getMaxWait(), poolConfig.getMaxIdle(), poolConfig.getMinIdle(), poolConfig.isTestOnBorrow(), poolConfig.isTestOnReturn(), poolConfig.getTimeBetweenEvictionRunsMillis(), poolConfig.getNumTestsPerEvictionRun(), poolConfig.getMinEvictableIdleTimeMillis(), poolConfig.isTestWhileIdle());
    }

    public ObjectPool getObjectPool() {
        return pool;
    }

    public Object borrowObject() throws Exception {
        return pool.borrowObject();
    }

    public void returnObject(Object object) throws Exception {
        pool.returnObject(object);
    }

    public void invalidateObject(Object object) throws Exception {
        pool.invalidateObject(object);
    }

    public void addObject() throws Exception {
        pool.addObject();
    }

    public int getNumIdle() throws UnsupportedOperationException {
        return pool.getNumIdle();
    }

    public int getNumActive() throws UnsupportedOperationException {
        return pool.getNumActive();
    }

    public void clear() throws Exception, UnsupportedOperationException {
        pool.clear();
    }

    public void close() throws Exception {
        pool.close();
    }

    /**
     * Returns iterator containing all the active
     * objects.
     * @since 1.3.1
     */
    public final Iterator getAllActiveObjects() {
        return ((StackObjectPool) pool).getAllObjects();
    }

    /**
     * Returns the object to synchronize on.
     * @since 1.4.1
     */
    public Object getObjectToSynchronize() {
        if (objectToSynchronize == null) {
            objectToSynchronize = new Object();
        }
        return objectToSynchronize;
    }
}

// QSObjectPoolFactory.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.pool;

import java.util.*;
import org.apache.commons.pool.*;
import org.quickserver.util.xmlreader.PoolConfig;
import java.util.logging.*;

/**
 * This is a class for creating objects for the pool.
 * @author Akshathkumar Shetty
 * @since 1.3
 */
public class QSObjectPoolFactory implements PoolableObjectFactory {

    private static final Logger logger = Logger.getLogger(QSObjectPoolFactory.class.getName());

    private PoolConfig poolConfig;

    public QSObjectPoolFactory(PoolConfig poolConfig) {
        this.poolConfig = poolConfig;
    }

    public Object makeObject() throws Exception {
        return new ClientThread(poolConfig.getClientPool());
    }

    public void destroyObject(Object object) throws Exception {
        ((ClientThread) object).close();
    }

    public boolean validateObject(Object object) {
        return true;
    }

    public void activateObject(Object object) throws Exception {
    }

    public void passivateObject(Object object) throws Exception {
    }
}

// PoolConfig.java
/*
 * This file is part of the QuickServer library 
 * Copyright (C) QuickServer.org
 *
 * Use, modification, copying and distribution of this software is subject to
 * the terms and conditions of the GNU Lesser General Public License. 
 * You should have received a copy of the GNU LGP License along with this 
 * library; if not, you can download a copy from <http://www.quickserver.org/>.
 *
 * For questions, suggestions, bug-reports, enhancement-requests etc.
 * visit http://www.quickserver.org
 *
 */
package org.quickserver.util.xmlreader;

import java.util.*;
import org.quickserver.util.pool.*;
import org.apache.commons.pool.*;
import org.quickserver.net.server.*;
import java.util.logging.*;

/**
 * This class holds the pool configuration.
 * @author Akshathkumar Shetty
 * @since 1.3
 */
public class PoolConfig {

    private static final Logger logger = Logger.getLogger(PoolConfig.class.getName());

    private int maxActive = 8;

    private byte whenExhaustedAction = GenericObjectPool.WHEN_EXHAUSTED_BLOCK;

    private long maxWait = -1;

    private int maxIdle = 8;

    private int minIdle = 0;

    private boolean testOnBorrow = false;

    private boolean testOnReturn = false;

    private long timeBetweenEvictionRunsMillis = -1;

    private int numTestsPerEvictionRun = 3;

    private long minEvictableIdleTimeMillis = 1000 * 60 * 30;

    private boolean testWhileIdle = false;

    private ClientPool clientPool;

    public PoolConfig() {
    }

    public int getMaxActive() {
        return maxActive;
    }

    public void setMaxActive(int maxActive) {
        this.maxActive = maxActive;
    }

    public byte getWhenExhaustedAction() {
        return whenExhaustedAction;
    }

    public void setWhenExhaustedAction(byte whenExhaustedAction) {
        this.whenExhaustedAction = whenExhaustedAction;
    }

    public long getMaxWait() {
        return maxWait;
    }

    public void setMaxWait(long maxWait) {
        this.maxWait = maxWait;
    }

    public int getMaxIdle() {
        return maxIdle;
    }

    public void setMaxIdle(int maxIdle) {
        this.maxIdle = maxIdle;
    }

    public int getMinIdle() {
        return minIdle;
    }

    public void setMinIdle(int minIdle) {
        this.minIdle = minIdle;
    }

    public boolean isTestOnBorrow() {
        return testOnBorrow;
    }

    public void setTestOnBorrow(boolean testOnBorrow) {
        this.testOnBorrow = testOnBorrow;
    }

    public boolean isTestOnReturn() {
        return testOnReturn;
    }

    public void setTestOnReturn(boolean testOnReturn) {
        this.testOnReturn = testOnReturn;
    }

    public long getTimeBetweenEvictionRunsMillis() {
        return timeBetweenEvictionRunsMillis;
    }

    public void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
        this.timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
    }

    public int getNumTestsPerEvictionRun() {
        return numTestsPerEvictionRun;
    }

    public void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
        this.numTestsPerEvictionRun = numTestsPerEvictionRun;
    }

    public long getMinEvictableIdleTimeMillis() {
        return minEvictableIdleTimeMillis;
    }

    public void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
        this.minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
    }

    public boolean isTestWhileIdle() {
        return testWhileIdle;
    }

    public void setTestWhileIdle(boolean testWhileIdle) {
        this.testWhileIdle = testWhile"
