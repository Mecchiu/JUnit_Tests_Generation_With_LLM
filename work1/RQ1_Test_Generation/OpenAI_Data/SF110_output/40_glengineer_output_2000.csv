ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
9bce938e-7f4c-4153-8998-433062f9a325,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 11508 tokens (9508 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    private Scheme scheme;

    /**
     * The mapping of the names on the scheme to the associated components.
     */
    private NamesToComponents namesToComponents;

    private NamesToGapAgents namesToGapAgents;

    /**
     * The layout manager {@code GroupLayout} under control.
     */
    private GroupLayout gl;

    /**
     * The object which can create sequential and parallel
     * {@code GroupLayout} groups and add components to groups
     * using the components' names.
     * <p>
     * A reference to this object is given to the agents of elements.
     *
     * @see glengineer.agents
     */
    private GroupCreatorAndElementAdderClass creatorAndAdder;

    /**
     * The agent of the top level horizontal group.
     */
    private TopSequentialGroupAgent horizontalLayoutAgent;

    /**
     * The agent of the top level vertical group.
     */
    private TopSequentialGroupAgent verticalLayoutAgent;

    /**
     * Whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    private boolean autoBaselineAlignment = false;

    /**
     * @param container	the container that needs to be laid out
     * @param lines		a sequence of lines representing the scheme
     */
    public GroupLayoutEngineer(Container container, String... lines) {
        scheme = new Scheme(lines);
        namesToComponents = new NamesToComponents();
        namesToGapAgents = new NamesToGapAgents();
        horizontalLayoutAgent = compouseTopSequentialGroup(Axis.HORIZONTAL);
        verticalLayoutAgent = compouseTopSequentialGroup(Axis.VERTICAL);
        horizontalLayoutAgent.removeGapsFromParallelGroups();
        verticalLayoutAgent.removeGapsFromParallelGroups();
        gl = new GroupLayout(container);
        container.setLayout(gl);
        //		setAutoCreateGaps(true);
        //		setAutoCreateContainerGaps(true);
    }

    /**
     * Returns a top sequential group agent for the specified layout direction.
     * <p>
     * A group will be created even if it would contain a single element.
     *
     * @param axis	the layout direction
     *
     * @return		the agent of the new sequential group
     */
    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis) {
        Block topBlock;
        if (axis == Axis.HORIZONTAL)
            topBlock = new HorizontalBlock(scheme);
        else
            //VERTICAL
            topBlock = new VerticalBlock(scheme);
        topBlock.optimize();
        if (topBlock.isTrivial())
            throw new IllegalArgumentException(""the scheme does not possess components' names"");
        TopSequentialGroupAgent result = new TopSequentialGroupAgent();
        List<Block> blocksList = topBlock.extractSequentialSubblocks();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Returns a new sequential group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new sequential group.
     */
    protected Agent compouseSequentialGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractSequentialSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfSequentialGroup(block);
        SequentialGroupAgent result = new SequentialGroupAgent();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and either returns the agent of the corresponding element,
     * or divides the set of elements into a new parallel subgroup
     * and returns the corresponding agent.
     *
     * @param subblock	a block in a sequential group.
     *
     * @return			the agent of the specified subblock content.
     */
    private Agent processSubblockOfSequentialGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return composeParallelGroupFromBlock(subblock);
    }

    /**
     * Returns the agent of the unique element (a component or a gap)
     * in the specified block which is added into a sequential group.
     *
     * @param block	a block with an only element in a parallel group.
     *
     * @return		the agent of the unique element in the specified block.
     */
    private Agent getElementFromBlockWithOnlyWord(Block block) {
        String word = block.textAt(block.firstWord_Horizontally());
        if (word.charAt(0) == '.')
            return new TemporaryGapAgent(word);
        return new ComponentAgent(word);
    }

    /**
     * Returns a new parallel group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new parallel group.
     */
    protected Agent composeParallelGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractParallelSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfParallelGroup(block);
        ParallelGroupAgent result = new ParallelGroupAgent();
        Agent agent;
        for (Block subBlock : blocksList) {
            agent = processSubblockOfParallelGroup(subBlock);
            if (agent != null)
                result.addAgent(agent);
        }
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and then either returns the agent of the corresponding element,
     * or divides the set of elements into a new sequential subgroup
     * and returns the corresponding agent.
     * <p>
     * If there is a unique element and it is a gap,
     *
     * @param subblock	a block in a parallel group.
     *
     * @return	the agent of the specified subblock content.
     */
    private Agent processSubblockOfParallelGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return compouseSequentialGroupFromBlock(subblock);
    }

    /**
     * Associates the specified {@code name} on the scheme
     * with the specified {@code component}.
     *
     * @param name		the component name present on the scheme.
     * @param component	the component to be associated with the name.
     */
    public void associate(String name, Component component) {
        namesToComponents.put(name, component);
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with gaps of the specified {@code size}.
     */
    public void associateGap(String denotation, int size) {
        namesToGapAgents.put(denotation, new GapAgent(size));
    }

    /**
     * Associates the specified {@code denotation} on the scheme with gaps
     * of the specified {@code min}, {@code pref}, and {@code max} sizes.
     */
    public void associateGap(String denotation, int min, int pref, int max) {
        namesToGapAgents.put(denotation, new GapAgent(min, pref, max));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated).
     */
    public void associateGap(String denotation, ComponentPlacement type) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated)
     * and of the specified preferred and maximum sizes.
     */
    public void associateGap(String denotation, ComponentPlacement type, int pref, int max) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type, pref, max));
    }

    /**
     * Sets whether a gap between components should automatically be
     * created. For example, if this is {@code true} and you add two
     * components to a {@code SequentialGroup} a gap between the
     * two components is automatically be created.
     *
     * @param autoCreatePadding	whether a gap between components is
     *        					automatically created.
     */
    public void setAutoCreateGaps(boolean autoCreatePadding) {
        gl.setAutoCreateGaps(autoCreatePadding);
    }

    /**
     * Sets whether a gap between the container and components that touch
     * the border of the container should automatically be created.
     *
     * @param autoCreateContainerGaps	whether a gap between the container
     * 									and components that touch the border
     * 									of the container should automatically
     * 									be created.
     */
    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps) {
        gl.setAutoCreateContainerGaps(autoCreateContainerGaps);
    }

    /**
     * Sets whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    public void setAutoAlignJTextFields(boolean autoBaselineAlignment) {
        this.autoBaselineAlignment = autoBaselineAlignment;
    }

    /**
     * Forces the specified components to have the same size
     * regardless of their preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(String... names) {
        Component[] components = namesToComponents.getComponents(names);
        gl.linkSize(components);
    }

    /**
     * Forces the specified components to have the same size
     * along the specified axis regardless of their
     * preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param axis	the axis to link the size along.
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(Axis axis, String... names) {
        Component[] components = namesToComponents.getComponents(names);
        if (axis == Axis.HORIZONTAL)
            gl.linkSize(SwingConstants.HORIZONTAL, components);
        else
            //axis==Axis.VERTICAL
            gl.linkSize(SwingConstants.VERTICAL, components);
    }

    /**
     * Disables the components under the specified names.
     * <p>
     * Each component must be associated with its name
     * before this method is applied.
     */
    public void disable(String... componentsNames) {
        for (Component c : namesToComponents.getComponents(componentsNames)) c.setEnabled(false);
    }

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis			layout direction
     * @param componentName	the name of the component to be found
     * @return				an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName) {
        Agent agent = getAgent(axis, componentName);
        if (agent == null)
            throw new IllegalArgumentException(""no such component found: "" + componentName);
        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();
    }

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getGroupAgent(axis, firstName, lastName);
        if (agent == null || !(agent instanceof GroupAgent))
            throw new IllegalArgumentException(""no such group found: <"" + firstName + "","" + lastName + "">"");
        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();
    }

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getParallelGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""no such parallel group found: <"" + firstName + "","" + lastName + "">"");
        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();
    }

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getSequentialGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""No such sequential group found: <"" + firstName + "","" + lastName + "">."");
        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {
        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the component with the specified name
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @param name	the name of the component to be found
     * @return		the corresponding agent
     */
    private Agent getAgent(Axis axis, String name) {
        return getTopAgent(axis).findDependingComponentByName(name);
    }

    /**
     * Returns the agent of the group with the specified first and last names
     * under the specified layout direction.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			the agent of the corresponding group
     */
    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingGroupByNames(firstName, lastName);
    }

    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingSequentialGroupByNames(firstName, lastName);
    }

    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingParallelGroupByNames(firstName, lastName);
    }

    /**
     * Returns (a reference to) the top agent
     * for the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the corresponding top agent
     */
    private TopSequentialGroupAgent getTopAgent(Axis axis) {
        return axis == Axis.HORIZONTAL ? horizontalLayoutAgent : verticalLayoutAgent;
    }

    /**
     * Places the components into the container
     * according to the scheme and to all additional preferences.
     */
    public void engineer() {
        horizontalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        verticalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        if (autoBaselineAlignment)
            makeTextFieldsBaselineIn(verticalLayoutAgent);
        creatorAndAdder = new GroupCreatorAndElementAdderClass();
        gl.setHorizontalGroup(horizontalLayoutAgent.groupContent(creatorAndAdder));
        gl.setVerticalGroup(verticalLayoutAgent.groupContent(creatorAndAdder));
    }

    /**
     * If the specified group is parallel,
     * contains directly a component of type {@code JTextField},
     * and does not contain other groups with components,
     * then this method makes the alignment of the group {@code Baseline}.
     * <p>
     * In the case of a group having subgroups with components
     * this method passes the call to that subgroups.
     * <p>
     * As a result of applying this method,
     * all parallel groups having TextFields (but having no subgroups)
     * will be aligned along baselines.
     */
    private void makeTextFieldsBaselineIn(GroupAgent group) {
        boolean containsGroups = false;
        //the group must be baseline aligned
        boolean containsTextfields = false;
        boolean isParallel = group instanceof ParallelGroupAgent;
        for (Agent child : group.getChildren()) {
            if (child instanceof GroupAgent && ((GroupAgent) child).getFirstName() != null) {
                //child is a group with components.
                makeTextFieldsBaselineIn((GroupAgent) child);
                containsGroups = true;
            } else if (child instanceof ComponentAgent && isParallel && !containsGroups) {
                ComponentAgent agent = (ComponentAgent) child;
                Component comp = namesToComponents.compMap.get(agent.getFirstName());
                if (comp instanceof JTextField)
                    containsTextfields = true;
            }
        }
        if (containsTextfields) {
            ParallelGroupSettings settings = ((ParallelGroupAgent) group).getSettings();
            if (settings.contentAlignment == null)
                settings.contentAlignment = Alignment.BASELINE;
        }
    }

    /**
     * Outputs the groups hierarchy.
     */
    public void printGroupStructure() {
        new GroupPrinter().printTopGroupsStructure();
    }

    /**
     * Encapsulates the ""names of components - to - components"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToComponents {

        /**
         * Holds the association between the names of the components on
         * the scheme and the corresponding components.
         */
        private HashMap<String, Component> compMap = new HashMap<String, Component>();

        public NamesToComponents() {
        }

        @SuppressWarnings(""unused"")
        public boolean contains(String name) {
            return compMap.containsKey(name);
        }

        @SuppressWarnings(""unused"")
        public boolean contains(Component component) {
            return compMap.containsValue(component);
        }

        public void put(String name, Component component) {
            if (name == null || component == null || !scheme.containsComponentName(name) || compMap.put(name, component) != null)
                throw new IllegalArgumentException(""Cannot associate a component"" + "" with the name \"""" + name + ""\"""");
        }

        /**
         * Returns the component associated with the specified name.
         *
         * @param name	the name of the component to return
         *
         * @return		the component associated with the specified name
         */
        public Component getComponent(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Component result = compMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a component"" + "" with the specified name \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the components associated with the specified names.
         *
         * @param names	the names of the components to return
         *
         * @return		the components associated with the specified names
         */
        public Component[] getComponents(String... names) {
            int l = names.length;
            Component[] components = new Component[l];
            for (int i = 0; i < l; i++) components[i] = getComponent(names[i]);
            return components;
        }
    }

    /**
     * Declares the method of possessing the gap agent
     * by a temporary gap agent.
     */
    public interface TemporaryGapsToGaps {

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp);
    }

    /**
     * Encapsulates the ""names of the gaps - to - agents of these gaps"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToGapAgents implements TemporaryGapsToGaps {

        /**
         * Holds the association between the gaps denotations
         * on the scheme and the corresponding gap types.
         * <p>
         * The gaps (which can be preferred or simple) are represented
         * by instances of {@code Agent}, which is a superclass
         * for both {@code PreferredGapAgent} and {@code GapAgent}.
         */
        private HashMap<String, Agent> gapMap = new HashMap<String, Agent>();

        public NamesToGapAgents() {
            safePut(""."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));
            safePut("".."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));
        }

        public void put(String name, GapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, GapAgent agent) {
            gapMap.put(name, agent);
        }

        public void put(String name, PreferredGapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, PreferredGapAgent agent) {
            gapMap.put(name, agent);
        }

        /**
         * Returns the gap agent associated with the specified name.
         */
        public Agent gap(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Agent result = gapMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a gap denoted by \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp) {
            return gap(temp.getDenotation());
        }
    }

    /**
     * An adapter for such functions of the {@code GroupLayout}
     * as creating new groups and adding groups and components to groups.
     */
    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {

        /**
         * Creates and returns a new {@code SequentialGroup}.
         */
        public SequentialGroup createSequentialGroup() {
            return gl.createSequentialGroup();
        }

        /**
         * Creates and returns a new {@code ParallelGroup}
         * with the specified settings.
         */
        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
            if (settings.contentAlignment != null)
                if (settings.resizable != null)
                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);
                else
                    //(resizable == null)
                    return gl.createParallelGroup(settings.contentAlignment);
            else //(settings.contentAlignment == null)
            if (settings.resizable != null)
                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);
            else
                return gl.createParallelGroup();
        }

        /**
         * Adds the component having the specified {@code compName}
         * to the specified {@code group},
         * applies to it the specified {@code settings}.
         */
        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {
            if (settings.alignmentWithRespectToParent != null)
                //It seems that we must add to a parallel group.
                if (group instanceof ParallelGroup)
                    //Really, to a parallel.
                    if (settings.sizes != null) {
                        Sizes sizes = settings.sizes;
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);
                    } else
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);
                else
                    //Parallel group not found.
                    throw new IllegalArgumentException(""components can be aligned in parallel groups only"");
            else //Alignment not specified.
            if (settings.sizes != null) {
                Sizes sizes = settings.sizes;
                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);
            } else
                //Even sizes aren't specified.
                group.addComponent(namesToComponents.getComponent(compName));
        }

        /**
         * Adds the specified {@code group} with the specified {@code settings}
         * to another group {@code parentGroup}.
         */
        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {
            if (settings.alignmentWithRespectToParent != null)
                if (parentGroup instanceof ParallelGroup)
                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);
                else
                    throw new IllegalArgumentException(""content can be aligned in parallel groups only"");
            parentGroup.addGroup(group);
        }
    }

    /**
     * Provides output of the created groups' structure.
     * <p>
     * Is maintained for debugging purposes.
     */
    public class GroupPrinter {

        /**
         * Outputs the both directions top groups structures.
         */
        public void printTopGroupsStructure() {
            Axis axis;
            axis = Axis.HORIZONTAL;
            System.out.println(""\nTop "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
            System.out.println(""\n-----------------------------\n"");
            axis = Axis.VERTICAL;
            System.out.println(""Top "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
        }

        /**
         * Outputs the specified direction top group structure.
         */
        public void printTopGroupStructure(Axis axis) {
            printGroupStructure(getTopAgent(axis));
        }

        /**
         * Outputs the specified group structure.
         */
        public void printGroupStructure(GroupAgent group) {
            System.out.println();
            System.out.println(""Elements of "" + group.toString() + "":"");
            List<Agent> childrenAgents = group.getChildren();
            for (Agent child : childrenAgents) System.out.println(child.toString());
            for (Agent child : childrenAgents) if (child instanceof GroupAgent)
                printGroupStructure((GroupAgent) child);
        }
    }
}
","// GroupLayoutEngineer_0Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getComponent(Axis, String)} method.
*/
class GroupLayoutEngineer_0Test {","// GroupLayoutEngineer_0Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getComponent(Axis, String)} method.
*/
class GroupLayoutEngineer_0Test {
"
e2d60a52-cb3c-41ec-ab0d-2f5de672884a,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 11510 tokens (9510 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    private Scheme scheme;

    /**
     * The mapping of the names on the scheme to the associated components.
     */
    private NamesToComponents namesToComponents;

    private NamesToGapAgents namesToGapAgents;

    /**
     * The layout manager {@code GroupLayout} under control.
     */
    private GroupLayout gl;

    /**
     * The object which can create sequential and parallel
     * {@code GroupLayout} groups and add components to groups
     * using the components' names.
     * <p>
     * A reference to this object is given to the agents of elements.
     *
     * @see glengineer.agents
     */
    private GroupCreatorAndElementAdderClass creatorAndAdder;

    /**
     * The agent of the top level horizontal group.
     */
    private TopSequentialGroupAgent horizontalLayoutAgent;

    /**
     * The agent of the top level vertical group.
     */
    private TopSequentialGroupAgent verticalLayoutAgent;

    /**
     * Whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    private boolean autoBaselineAlignment = false;

    /**
     * @param container	the container that needs to be laid out
     * @param lines		a sequence of lines representing the scheme
     */
    public GroupLayoutEngineer(Container container, String... lines) {
        scheme = new Scheme(lines);
        namesToComponents = new NamesToComponents();
        namesToGapAgents = new NamesToGapAgents();
        horizontalLayoutAgent = compouseTopSequentialGroup(Axis.HORIZONTAL);
        verticalLayoutAgent = compouseTopSequentialGroup(Axis.VERTICAL);
        horizontalLayoutAgent.removeGapsFromParallelGroups();
        verticalLayoutAgent.removeGapsFromParallelGroups();
        gl = new GroupLayout(container);
        container.setLayout(gl);
        //		setAutoCreateGaps(true);
        //		setAutoCreateContainerGaps(true);
    }

    /**
     * Returns a top sequential group agent for the specified layout direction.
     * <p>
     * A group will be created even if it would contain a single element.
     *
     * @param axis	the layout direction
     *
     * @return		the agent of the new sequential group
     */
    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis) {
        Block topBlock;
        if (axis == Axis.HORIZONTAL)
            topBlock = new HorizontalBlock(scheme);
        else
            //VERTICAL
            topBlock = new VerticalBlock(scheme);
        topBlock.optimize();
        if (topBlock.isTrivial())
            throw new IllegalArgumentException(""the scheme does not possess components' names"");
        TopSequentialGroupAgent result = new TopSequentialGroupAgent();
        List<Block> blocksList = topBlock.extractSequentialSubblocks();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Returns a new sequential group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new sequential group.
     */
    protected Agent compouseSequentialGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractSequentialSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfSequentialGroup(block);
        SequentialGroupAgent result = new SequentialGroupAgent();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and either returns the agent of the corresponding element,
     * or divides the set of elements into a new parallel subgroup
     * and returns the corresponding agent.
     *
     * @param subblock	a block in a sequential group.
     *
     * @return			the agent of the specified subblock content.
     */
    private Agent processSubblockOfSequentialGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return composeParallelGroupFromBlock(subblock);
    }

    /**
     * Returns the agent of the unique element (a component or a gap)
     * in the specified block which is added into a sequential group.
     *
     * @param block	a block with an only element in a parallel group.
     *
     * @return		the agent of the unique element in the specified block.
     */
    private Agent getElementFromBlockWithOnlyWord(Block block) {
        String word = block.textAt(block.firstWord_Horizontally());
        if (word.charAt(0) == '.')
            return new TemporaryGapAgent(word);
        return new ComponentAgent(word);
    }

    /**
     * Returns a new parallel group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new parallel group.
     */
    protected Agent composeParallelGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractParallelSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfParallelGroup(block);
        ParallelGroupAgent result = new ParallelGroupAgent();
        Agent agent;
        for (Block subBlock : blocksList) {
            agent = processSubblockOfParallelGroup(subBlock);
            if (agent != null)
                result.addAgent(agent);
        }
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and then either returns the agent of the corresponding element,
     * or divides the set of elements into a new sequential subgroup
     * and returns the corresponding agent.
     * <p>
     * If there is a unique element and it is a gap,
     *
     * @param subblock	a block in a parallel group.
     *
     * @return	the agent of the specified subblock content.
     */
    private Agent processSubblockOfParallelGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return compouseSequentialGroupFromBlock(subblock);
    }

    /**
     * Associates the specified {@code name} on the scheme
     * with the specified {@code component}.
     *
     * @param name		the component name present on the scheme.
     * @param component	the component to be associated with the name.
     */
    public void associate(String name, Component component) {
        namesToComponents.put(name, component);
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with gaps of the specified {@code size}.
     */
    public void associateGap(String denotation, int size) {
        namesToGapAgents.put(denotation, new GapAgent(size));
    }

    /**
     * Associates the specified {@code denotation} on the scheme with gaps
     * of the specified {@code min}, {@code pref}, and {@code max} sizes.
     */
    public void associateGap(String denotation, int min, int pref, int max) {
        namesToGapAgents.put(denotation, new GapAgent(min, pref, max));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated).
     */
    public void associateGap(String denotation, ComponentPlacement type) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated)
     * and of the specified preferred and maximum sizes.
     */
    public void associateGap(String denotation, ComponentPlacement type, int pref, int max) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type, pref, max));
    }

    /**
     * Sets whether a gap between components should automatically be
     * created. For example, if this is {@code true} and you add two
     * components to a {@code SequentialGroup} a gap between the
     * two components is automatically be created.
     *
     * @param autoCreatePadding	whether a gap between components is
     *        					automatically created.
     */
    public void setAutoCreateGaps(boolean autoCreatePadding) {
        gl.setAutoCreateGaps(autoCreatePadding);
    }

    /**
     * Sets whether a gap between the container and components that touch
     * the border of the container should automatically be created.
     *
     * @param autoCreateContainerGaps	whether a gap between the container
     * 									and components that touch the border
     * 									of the container should automatically
     * 									be created.
     */
    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps) {
        gl.setAutoCreateContainerGaps(autoCreateContainerGaps);
    }

    /**
     * Sets whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    public void setAutoAlignJTextFields(boolean autoBaselineAlignment) {
        this.autoBaselineAlignment = autoBaselineAlignment;
    }

    /**
     * Forces the specified components to have the same size
     * regardless of their preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(String... names) {
        Component[] components = namesToComponents.getComponents(names);
        gl.linkSize(components);
    }

    /**
     * Forces the specified components to have the same size
     * along the specified axis regardless of their
     * preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param axis	the axis to link the size along.
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(Axis axis, String... names) {
        Component[] components = namesToComponents.getComponents(names);
        if (axis == Axis.HORIZONTAL)
            gl.linkSize(SwingConstants.HORIZONTAL, components);
        else
            //axis==Axis.VERTICAL
            gl.linkSize(SwingConstants.VERTICAL, components);
    }

    /**
     * Disables the components under the specified names.
     * <p>
     * Each component must be associated with its name
     * before this method is applied.
     */
    public void disable(String... componentsNames) {
        for (Component c : namesToComponents.getComponents(componentsNames)) c.setEnabled(false);
    }

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis			layout direction
     * @param componentName	the name of the component to be found
     * @return				an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName) {
        Agent agent = getAgent(axis, componentName);
        if (agent == null)
            throw new IllegalArgumentException(""no such component found: "" + componentName);
        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();
    }

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getGroupAgent(axis, firstName, lastName);
        if (agent == null || !(agent instanceof GroupAgent))
            throw new IllegalArgumentException(""no such group found: <"" + firstName + "","" + lastName + "">"");
        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();
    }

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getParallelGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""no such parallel group found: <"" + firstName + "","" + lastName + "">"");
        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();
    }

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getSequentialGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""No such sequential group found: <"" + firstName + "","" + lastName + "">."");
        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {
        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the component with the specified name
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @param name	the name of the component to be found
     * @return		the corresponding agent
     */
    private Agent getAgent(Axis axis, String name) {
        return getTopAgent(axis).findDependingComponentByName(name);
    }

    /**
     * Returns the agent of the group with the specified first and last names
     * under the specified layout direction.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			the agent of the corresponding group
     */
    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingGroupByNames(firstName, lastName);
    }

    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingSequentialGroupByNames(firstName, lastName);
    }

    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingParallelGroupByNames(firstName, lastName);
    }

    /**
     * Returns (a reference to) the top agent
     * for the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the corresponding top agent
     */
    private TopSequentialGroupAgent getTopAgent(Axis axis) {
        return axis == Axis.HORIZONTAL ? horizontalLayoutAgent : verticalLayoutAgent;
    }

    /**
     * Places the components into the container
     * according to the scheme and to all additional preferences.
     */
    public void engineer() {
        horizontalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        verticalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        if (autoBaselineAlignment)
            makeTextFieldsBaselineIn(verticalLayoutAgent);
        creatorAndAdder = new GroupCreatorAndElementAdderClass();
        gl.setHorizontalGroup(horizontalLayoutAgent.groupContent(creatorAndAdder));
        gl.setVerticalGroup(verticalLayoutAgent.groupContent(creatorAndAdder));
    }

    /**
     * If the specified group is parallel,
     * contains directly a component of type {@code JTextField},
     * and does not contain other groups with components,
     * then this method makes the alignment of the group {@code Baseline}.
     * <p>
     * In the case of a group having subgroups with components
     * this method passes the call to that subgroups.
     * <p>
     * As a result of applying this method,
     * all parallel groups having TextFields (but having no subgroups)
     * will be aligned along baselines.
     */
    private void makeTextFieldsBaselineIn(GroupAgent group) {
        boolean containsGroups = false;
        //the group must be baseline aligned
        boolean containsTextfields = false;
        boolean isParallel = group instanceof ParallelGroupAgent;
        for (Agent child : group.getChildren()) {
            if (child instanceof GroupAgent && ((GroupAgent) child).getFirstName() != null) {
                //child is a group with components.
                makeTextFieldsBaselineIn((GroupAgent) child);
                containsGroups = true;
            } else if (child instanceof ComponentAgent && isParallel && !containsGroups) {
                ComponentAgent agent = (ComponentAgent) child;
                Component comp = namesToComponents.compMap.get(agent.getFirstName());
                if (comp instanceof JTextField)
                    containsTextfields = true;
            }
        }
        if (containsTextfields) {
            ParallelGroupSettings settings = ((ParallelGroupAgent) group).getSettings();
            if (settings.contentAlignment == null)
                settings.contentAlignment = Alignment.BASELINE;
        }
    }

    /**
     * Outputs the groups hierarchy.
     */
    public void printGroupStructure() {
        new GroupPrinter().printTopGroupsStructure();
    }

    /**
     * Encapsulates the ""names of components - to - components"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToComponents {

        /**
         * Holds the association between the names of the components on
         * the scheme and the corresponding components.
         */
        private HashMap<String, Component> compMap = new HashMap<String, Component>();

        public NamesToComponents() {
        }

        @SuppressWarnings(""unused"")
        public boolean contains(String name) {
            return compMap.containsKey(name);
        }

        @SuppressWarnings(""unused"")
        public boolean contains(Component component) {
            return compMap.containsValue(component);
        }

        public void put(String name, Component component) {
            if (name == null || component == null || !scheme.containsComponentName(name) || compMap.put(name, component) != null)
                throw new IllegalArgumentException(""Cannot associate a component"" + "" with the name \"""" + name + ""\"""");
        }

        /**
         * Returns the component associated with the specified name.
         *
         * @param name	the name of the component to return
         *
         * @return		the component associated with the specified name
         */
        public Component getComponent(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Component result = compMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a component"" + "" with the specified name \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the components associated with the specified names.
         *
         * @param names	the names of the components to return
         *
         * @return		the components associated with the specified names
         */
        public Component[] getComponents(String... names) {
            int l = names.length;
            Component[] components = new Component[l];
            for (int i = 0; i < l; i++) components[i] = getComponent(names[i]);
            return components;
        }
    }

    /**
     * Declares the method of possessing the gap agent
     * by a temporary gap agent.
     */
    public interface TemporaryGapsToGaps {

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp);
    }

    /**
     * Encapsulates the ""names of the gaps - to - agents of these gaps"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToGapAgents implements TemporaryGapsToGaps {

        /**
         * Holds the association between the gaps denotations
         * on the scheme and the corresponding gap types.
         * <p>
         * The gaps (which can be preferred or simple) are represented
         * by instances of {@code Agent}, which is a superclass
         * for both {@code PreferredGapAgent} and {@code GapAgent}.
         */
        private HashMap<String, Agent> gapMap = new HashMap<String, Agent>();

        public NamesToGapAgents() {
            safePut(""."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));
            safePut("".."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));
        }

        public void put(String name, GapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, GapAgent agent) {
            gapMap.put(name, agent);
        }

        public void put(String name, PreferredGapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, PreferredGapAgent agent) {
            gapMap.put(name, agent);
        }

        /**
         * Returns the gap agent associated with the specified name.
         */
        public Agent gap(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Agent result = gapMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a gap denoted by \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp) {
            return gap(temp.getDenotation());
        }
    }

    /**
     * An adapter for such functions of the {@code GroupLayout}
     * as creating new groups and adding groups and components to groups.
     */
    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {

        /**
         * Creates and returns a new {@code SequentialGroup}.
         */
        public SequentialGroup createSequentialGroup() {
            return gl.createSequentialGroup();
        }

        /**
         * Creates and returns a new {@code ParallelGroup}
         * with the specified settings.
         */
        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
            if (settings.contentAlignment != null)
                if (settings.resizable != null)
                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);
                else
                    //(resizable == null)
                    return gl.createParallelGroup(settings.contentAlignment);
            else //(settings.contentAlignment == null)
            if (settings.resizable != null)
                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);
            else
                return gl.createParallelGroup();
        }

        /**
         * Adds the component having the specified {@code compName}
         * to the specified {@code group},
         * applies to it the specified {@code settings}.
         */
        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {
            if (settings.alignmentWithRespectToParent != null)
                //It seems that we must add to a parallel group.
                if (group instanceof ParallelGroup)
                    //Really, to a parallel.
                    if (settings.sizes != null) {
                        Sizes sizes = settings.sizes;
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);
                    } else
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);
                else
                    //Parallel group not found.
                    throw new IllegalArgumentException(""components can be aligned in parallel groups only"");
            else //Alignment not specified.
            if (settings.sizes != null) {
                Sizes sizes = settings.sizes;
                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);
            } else
                //Even sizes aren't specified.
                group.addComponent(namesToComponents.getComponent(compName));
        }

        /**
         * Adds the specified {@code group} with the specified {@code settings}
         * to another group {@code parentGroup}.
         */
        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {
            if (settings.alignmentWithRespectToParent != null)
                if (parentGroup instanceof ParallelGroup)
                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);
                else
                    throw new IllegalArgumentException(""content can be aligned in parallel groups only"");
            parentGroup.addGroup(group);
        }
    }

    /**
     * Provides output of the created groups' structure.
     * <p>
     * Is maintained for debugging purposes.
     */
    public class GroupPrinter {

        /**
         * Outputs the both directions top groups structures.
         */
        public void printTopGroupsStructure() {
            Axis axis;
            axis = Axis.HORIZONTAL;
            System.out.println(""\nTop "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
            System.out.println(""\n-----------------------------\n"");
            axis = Axis.VERTICAL;
            System.out.println(""Top "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
        }

        /**
         * Outputs the specified direction top group structure.
         */
        public void printTopGroupStructure(Axis axis) {
            printGroupStructure(getTopAgent(axis));
        }

        /**
         * Outputs the specified group structure.
         */
        public void printGroupStructure(GroupAgent group) {
            System.out.println();
            System.out.println(""Elements of "" + group.toString() + "":"");
            List<Agent> childrenAgents = group.getChildren();
            for (Agent child : childrenAgents) System.out.println(child.toString());
            for (Agent child : childrenAgents) if (child instanceof GroupAgent)
                printGroupStructure((GroupAgent) child);
        }
    }
}
","// GroupLayoutEngineer_1Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_1Test {","// GroupLayoutEngineer_1Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_1Test {
"
e16aa419-ef05-442a-b8e3-96c5641f4ec2,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 11512 tokens (9512 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    private Scheme scheme;

    /**
     * The mapping of the names on the scheme to the associated components.
     */
    private NamesToComponents namesToComponents;

    private NamesToGapAgents namesToGapAgents;

    /**
     * The layout manager {@code GroupLayout} under control.
     */
    private GroupLayout gl;

    /**
     * The object which can create sequential and parallel
     * {@code GroupLayout} groups and add components to groups
     * using the components' names.
     * <p>
     * A reference to this object is given to the agents of elements.
     *
     * @see glengineer.agents
     */
    private GroupCreatorAndElementAdderClass creatorAndAdder;

    /**
     * The agent of the top level horizontal group.
     */
    private TopSequentialGroupAgent horizontalLayoutAgent;

    /**
     * The agent of the top level vertical group.
     */
    private TopSequentialGroupAgent verticalLayoutAgent;

    /**
     * Whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    private boolean autoBaselineAlignment = false;

    /**
     * @param container	the container that needs to be laid out
     * @param lines		a sequence of lines representing the scheme
     */
    public GroupLayoutEngineer(Container container, String... lines) {
        scheme = new Scheme(lines);
        namesToComponents = new NamesToComponents();
        namesToGapAgents = new NamesToGapAgents();
        horizontalLayoutAgent = compouseTopSequentialGroup(Axis.HORIZONTAL);
        verticalLayoutAgent = compouseTopSequentialGroup(Axis.VERTICAL);
        horizontalLayoutAgent.removeGapsFromParallelGroups();
        verticalLayoutAgent.removeGapsFromParallelGroups();
        gl = new GroupLayout(container);
        container.setLayout(gl);
        //		setAutoCreateGaps(true);
        //		setAutoCreateContainerGaps(true);
    }

    /**
     * Returns a top sequential group agent for the specified layout direction.
     * <p>
     * A group will be created even if it would contain a single element.
     *
     * @param axis	the layout direction
     *
     * @return		the agent of the new sequential group
     */
    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis) {
        Block topBlock;
        if (axis == Axis.HORIZONTAL)
            topBlock = new HorizontalBlock(scheme);
        else
            //VERTICAL
            topBlock = new VerticalBlock(scheme);
        topBlock.optimize();
        if (topBlock.isTrivial())
            throw new IllegalArgumentException(""the scheme does not possess components' names"");
        TopSequentialGroupAgent result = new TopSequentialGroupAgent();
        List<Block> blocksList = topBlock.extractSequentialSubblocks();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Returns a new sequential group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new sequential group.
     */
    protected Agent compouseSequentialGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractSequentialSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfSequentialGroup(block);
        SequentialGroupAgent result = new SequentialGroupAgent();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and either returns the agent of the corresponding element,
     * or divides the set of elements into a new parallel subgroup
     * and returns the corresponding agent.
     *
     * @param subblock	a block in a sequential group.
     *
     * @return			the agent of the specified subblock content.
     */
    private Agent processSubblockOfSequentialGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return composeParallelGroupFromBlock(subblock);
    }

    /**
     * Returns the agent of the unique element (a component or a gap)
     * in the specified block which is added into a sequential group.
     *
     * @param block	a block with an only element in a parallel group.
     *
     * @return		the agent of the unique element in the specified block.
     */
    private Agent getElementFromBlockWithOnlyWord(Block block) {
        String word = block.textAt(block.firstWord_Horizontally());
        if (word.charAt(0) == '.')
            return new TemporaryGapAgent(word);
        return new ComponentAgent(word);
    }

    /**
     * Returns a new parallel group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new parallel group.
     */
    protected Agent composeParallelGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractParallelSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfParallelGroup(block);
        ParallelGroupAgent result = new ParallelGroupAgent();
        Agent agent;
        for (Block subBlock : blocksList) {
            agent = processSubblockOfParallelGroup(subBlock);
            if (agent != null)
                result.addAgent(agent);
        }
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and then either returns the agent of the corresponding element,
     * or divides the set of elements into a new sequential subgroup
     * and returns the corresponding agent.
     * <p>
     * If there is a unique element and it is a gap,
     *
     * @param subblock	a block in a parallel group.
     *
     * @return	the agent of the specified subblock content.
     */
    private Agent processSubblockOfParallelGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return compouseSequentialGroupFromBlock(subblock);
    }

    /**
     * Associates the specified {@code name} on the scheme
     * with the specified {@code component}.
     *
     * @param name		the component name present on the scheme.
     * @param component	the component to be associated with the name.
     */
    public void associate(String name, Component component) {
        namesToComponents.put(name, component);
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with gaps of the specified {@code size}.
     */
    public void associateGap(String denotation, int size) {
        namesToGapAgents.put(denotation, new GapAgent(size));
    }

    /**
     * Associates the specified {@code denotation} on the scheme with gaps
     * of the specified {@code min}, {@code pref}, and {@code max} sizes.
     */
    public void associateGap(String denotation, int min, int pref, int max) {
        namesToGapAgents.put(denotation, new GapAgent(min, pref, max));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated).
     */
    public void associateGap(String denotation, ComponentPlacement type) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated)
     * and of the specified preferred and maximum sizes.
     */
    public void associateGap(String denotation, ComponentPlacement type, int pref, int max) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type, pref, max));
    }

    /**
     * Sets whether a gap between components should automatically be
     * created. For example, if this is {@code true} and you add two
     * components to a {@code SequentialGroup} a gap between the
     * two components is automatically be created.
     *
     * @param autoCreatePadding	whether a gap between components is
     *        					automatically created.
     */
    public void setAutoCreateGaps(boolean autoCreatePadding) {
        gl.setAutoCreateGaps(autoCreatePadding);
    }

    /**
     * Sets whether a gap between the container and components that touch
     * the border of the container should automatically be created.
     *
     * @param autoCreateContainerGaps	whether a gap between the container
     * 									and components that touch the border
     * 									of the container should automatically
     * 									be created.
     */
    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps) {
        gl.setAutoCreateContainerGaps(autoCreateContainerGaps);
    }

    /**
     * Sets whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    public void setAutoAlignJTextFields(boolean autoBaselineAlignment) {
        this.autoBaselineAlignment = autoBaselineAlignment;
    }

    /**
     * Forces the specified components to have the same size
     * regardless of their preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(String... names) {
        Component[] components = namesToComponents.getComponents(names);
        gl.linkSize(components);
    }

    /**
     * Forces the specified components to have the same size
     * along the specified axis regardless of their
     * preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param axis	the axis to link the size along.
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(Axis axis, String... names) {
        Component[] components = namesToComponents.getComponents(names);
        if (axis == Axis.HORIZONTAL)
            gl.linkSize(SwingConstants.HORIZONTAL, components);
        else
            //axis==Axis.VERTICAL
            gl.linkSize(SwingConstants.VERTICAL, components);
    }

    /**
     * Disables the components under the specified names.
     * <p>
     * Each component must be associated with its name
     * before this method is applied.
     */
    public void disable(String... componentsNames) {
        for (Component c : namesToComponents.getComponents(componentsNames)) c.setEnabled(false);
    }

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis			layout direction
     * @param componentName	the name of the component to be found
     * @return				an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName) {
        Agent agent = getAgent(axis, componentName);
        if (agent == null)
            throw new IllegalArgumentException(""no such component found: "" + componentName);
        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();
    }

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getGroupAgent(axis, firstName, lastName);
        if (agent == null || !(agent instanceof GroupAgent))
            throw new IllegalArgumentException(""no such group found: <"" + firstName + "","" + lastName + "">"");
        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();
    }

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getParallelGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""no such parallel group found: <"" + firstName + "","" + lastName + "">"");
        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();
    }

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getSequentialGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""No such sequential group found: <"" + firstName + "","" + lastName + "">."");
        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {
        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the component with the specified name
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @param name	the name of the component to be found
     * @return		the corresponding agent
     */
    private Agent getAgent(Axis axis, String name) {
        return getTopAgent(axis).findDependingComponentByName(name);
    }

    /**
     * Returns the agent of the group with the specified first and last names
     * under the specified layout direction.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			the agent of the corresponding group
     */
    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingGroupByNames(firstName, lastName);
    }

    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingSequentialGroupByNames(firstName, lastName);
    }

    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingParallelGroupByNames(firstName, lastName);
    }

    /**
     * Returns (a reference to) the top agent
     * for the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the corresponding top agent
     */
    private TopSequentialGroupAgent getTopAgent(Axis axis) {
        return axis == Axis.HORIZONTAL ? horizontalLayoutAgent : verticalLayoutAgent;
    }

    /**
     * Places the components into the container
     * according to the scheme and to all additional preferences.
     */
    public void engineer() {
        horizontalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        verticalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        if (autoBaselineAlignment)
            makeTextFieldsBaselineIn(verticalLayoutAgent);
        creatorAndAdder = new GroupCreatorAndElementAdderClass();
        gl.setHorizontalGroup(horizontalLayoutAgent.groupContent(creatorAndAdder));
        gl.setVerticalGroup(verticalLayoutAgent.groupContent(creatorAndAdder));
    }

    /**
     * If the specified group is parallel,
     * contains directly a component of type {@code JTextField},
     * and does not contain other groups with components,
     * then this method makes the alignment of the group {@code Baseline}.
     * <p>
     * In the case of a group having subgroups with components
     * this method passes the call to that subgroups.
     * <p>
     * As a result of applying this method,
     * all parallel groups having TextFields (but having no subgroups)
     * will be aligned along baselines.
     */
    private void makeTextFieldsBaselineIn(GroupAgent group) {
        boolean containsGroups = false;
        //the group must be baseline aligned
        boolean containsTextfields = false;
        boolean isParallel = group instanceof ParallelGroupAgent;
        for (Agent child : group.getChildren()) {
            if (child instanceof GroupAgent && ((GroupAgent) child).getFirstName() != null) {
                //child is a group with components.
                makeTextFieldsBaselineIn((GroupAgent) child);
                containsGroups = true;
            } else if (child instanceof ComponentAgent && isParallel && !containsGroups) {
                ComponentAgent agent = (ComponentAgent) child;
                Component comp = namesToComponents.compMap.get(agent.getFirstName());
                if (comp instanceof JTextField)
                    containsTextfields = true;
            }
        }
        if (containsTextfields) {
            ParallelGroupSettings settings = ((ParallelGroupAgent) group).getSettings();
            if (settings.contentAlignment == null)
                settings.contentAlignment = Alignment.BASELINE;
        }
    }

    /**
     * Outputs the groups hierarchy.
     */
    public void printGroupStructure() {
        new GroupPrinter().printTopGroupsStructure();
    }

    /**
     * Encapsulates the ""names of components - to - components"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToComponents {

        /**
         * Holds the association between the names of the components on
         * the scheme and the corresponding components.
         */
        private HashMap<String, Component> compMap = new HashMap<String, Component>();

        public NamesToComponents() {
        }

        @SuppressWarnings(""unused"")
        public boolean contains(String name) {
            return compMap.containsKey(name);
        }

        @SuppressWarnings(""unused"")
        public boolean contains(Component component) {
            return compMap.containsValue(component);
        }

        public void put(String name, Component component) {
            if (name == null || component == null || !scheme.containsComponentName(name) || compMap.put(name, component) != null)
                throw new IllegalArgumentException(""Cannot associate a component"" + "" with the name \"""" + name + ""\"""");
        }

        /**
         * Returns the component associated with the specified name.
         *
         * @param name	the name of the component to return
         *
         * @return		the component associated with the specified name
         */
        public Component getComponent(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Component result = compMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a component"" + "" with the specified name \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the components associated with the specified names.
         *
         * @param names	the names of the components to return
         *
         * @return		the components associated with the specified names
         */
        public Component[] getComponents(String... names) {
            int l = names.length;
            Component[] components = new Component[l];
            for (int i = 0; i < l; i++) components[i] = getComponent(names[i]);
            return components;
        }
    }

    /**
     * Declares the method of possessing the gap agent
     * by a temporary gap agent.
     */
    public interface TemporaryGapsToGaps {

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp);
    }

    /**
     * Encapsulates the ""names of the gaps - to - agents of these gaps"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToGapAgents implements TemporaryGapsToGaps {

        /**
         * Holds the association between the gaps denotations
         * on the scheme and the corresponding gap types.
         * <p>
         * The gaps (which can be preferred or simple) are represented
         * by instances of {@code Agent}, which is a superclass
         * for both {@code PreferredGapAgent} and {@code GapAgent}.
         */
        private HashMap<String, Agent> gapMap = new HashMap<String, Agent>();

        public NamesToGapAgents() {
            safePut(""."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));
            safePut("".."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));
        }

        public void put(String name, GapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, GapAgent agent) {
            gapMap.put(name, agent);
        }

        public void put(String name, PreferredGapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, PreferredGapAgent agent) {
            gapMap.put(name, agent);
        }

        /**
         * Returns the gap agent associated with the specified name.
         */
        public Agent gap(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Agent result = gapMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a gap denoted by \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp) {
            return gap(temp.getDenotation());
        }
    }

    /**
     * An adapter for such functions of the {@code GroupLayout}
     * as creating new groups and adding groups and components to groups.
     */
    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {

        /**
         * Creates and returns a new {@code SequentialGroup}.
         */
        public SequentialGroup createSequentialGroup() {
            return gl.createSequentialGroup();
        }

        /**
         * Creates and returns a new {@code ParallelGroup}
         * with the specified settings.
         */
        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
            if (settings.contentAlignment != null)
                if (settings.resizable != null)
                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);
                else
                    //(resizable == null)
                    return gl.createParallelGroup(settings.contentAlignment);
            else //(settings.contentAlignment == null)
            if (settings.resizable != null)
                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);
            else
                return gl.createParallelGroup();
        }

        /**
         * Adds the component having the specified {@code compName}
         * to the specified {@code group},
         * applies to it the specified {@code settings}.
         */
        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {
            if (settings.alignmentWithRespectToParent != null)
                //It seems that we must add to a parallel group.
                if (group instanceof ParallelGroup)
                    //Really, to a parallel.
                    if (settings.sizes != null) {
                        Sizes sizes = settings.sizes;
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);
                    } else
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);
                else
                    //Parallel group not found.
                    throw new IllegalArgumentException(""components can be aligned in parallel groups only"");
            else //Alignment not specified.
            if (settings.sizes != null) {
                Sizes sizes = settings.sizes;
                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);
            } else
                //Even sizes aren't specified.
                group.addComponent(namesToComponents.getComponent(compName));
        }

        /**
         * Adds the specified {@code group} with the specified {@code settings}
         * to another group {@code parentGroup}.
         */
        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {
            if (settings.alignmentWithRespectToParent != null)
                if (parentGroup instanceof ParallelGroup)
                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);
                else
                    throw new IllegalArgumentException(""content can be aligned in parallel groups only"");
            parentGroup.addGroup(group);
        }
    }

    /**
     * Provides output of the created groups' structure.
     * <p>
     * Is maintained for debugging purposes.
     */
    public class GroupPrinter {

        /**
         * Outputs the both directions top groups structures.
         */
        public void printTopGroupsStructure() {
            Axis axis;
            axis = Axis.HORIZONTAL;
            System.out.println(""\nTop "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
            System.out.println(""\n-----------------------------\n"");
            axis = Axis.VERTICAL;
            System.out.println(""Top "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
        }

        /**
         * Outputs the specified direction top group structure.
         */
        public void printTopGroupStructure(Axis axis) {
            printGroupStructure(getTopAgent(axis));
        }

        /**
         * Outputs the specified group structure.
         */
        public void printGroupStructure(GroupAgent group) {
            System.out.println();
            System.out.println(""Elements of "" + group.toString() + "":"");
            List<Agent> childrenAgents = group.getChildren();
            for (Agent child : childrenAgents) System.out.println(child.toString());
            for (Agent child : childrenAgents) if (child instanceof GroupAgent)
                printGroupStructure((GroupAgent) child);
        }
    }
}
","// GroupLayoutEngineer_2Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getParallelGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_2Test {","// GroupLayoutEngineer_2Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getParallelGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_2Test {
"
04b073ed-ca16-4be8-b13a-1453a0c486ab,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_3Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 11512 tokens (9512 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    private Scheme scheme;

    /**
     * The mapping of the names on the scheme to the associated components.
     */
    private NamesToComponents namesToComponents;

    private NamesToGapAgents namesToGapAgents;

    /**
     * The layout manager {@code GroupLayout} under control.
     */
    private GroupLayout gl;

    /**
     * The object which can create sequential and parallel
     * {@code GroupLayout} groups and add components to groups
     * using the components' names.
     * <p>
     * A reference to this object is given to the agents of elements.
     *
     * @see glengineer.agents
     */
    private GroupCreatorAndElementAdderClass creatorAndAdder;

    /**
     * The agent of the top level horizontal group.
     */
    private TopSequentialGroupAgent horizontalLayoutAgent;

    /**
     * The agent of the top level vertical group.
     */
    private TopSequentialGroupAgent verticalLayoutAgent;

    /**
     * Whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    private boolean autoBaselineAlignment = false;

    /**
     * @param container	the container that needs to be laid out
     * @param lines		a sequence of lines representing the scheme
     */
    public GroupLayoutEngineer(Container container, String... lines) {
        scheme = new Scheme(lines);
        namesToComponents = new NamesToComponents();
        namesToGapAgents = new NamesToGapAgents();
        horizontalLayoutAgent = compouseTopSequentialGroup(Axis.HORIZONTAL);
        verticalLayoutAgent = compouseTopSequentialGroup(Axis.VERTICAL);
        horizontalLayoutAgent.removeGapsFromParallelGroups();
        verticalLayoutAgent.removeGapsFromParallelGroups();
        gl = new GroupLayout(container);
        container.setLayout(gl);
        //		setAutoCreateGaps(true);
        //		setAutoCreateContainerGaps(true);
    }

    /**
     * Returns a top sequential group agent for the specified layout direction.
     * <p>
     * A group will be created even if it would contain a single element.
     *
     * @param axis	the layout direction
     *
     * @return		the agent of the new sequential group
     */
    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis) {
        Block topBlock;
        if (axis == Axis.HORIZONTAL)
            topBlock = new HorizontalBlock(scheme);
        else
            //VERTICAL
            topBlock = new VerticalBlock(scheme);
        topBlock.optimize();
        if (topBlock.isTrivial())
            throw new IllegalArgumentException(""the scheme does not possess components' names"");
        TopSequentialGroupAgent result = new TopSequentialGroupAgent();
        List<Block> blocksList = topBlock.extractSequentialSubblocks();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Returns a new sequential group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new sequential group.
     */
    protected Agent compouseSequentialGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractSequentialSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfSequentialGroup(block);
        SequentialGroupAgent result = new SequentialGroupAgent();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and either returns the agent of the corresponding element,
     * or divides the set of elements into a new parallel subgroup
     * and returns the corresponding agent.
     *
     * @param subblock	a block in a sequential group.
     *
     * @return			the agent of the specified subblock content.
     */
    private Agent processSubblockOfSequentialGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return composeParallelGroupFromBlock(subblock);
    }

    /**
     * Returns the agent of the unique element (a component or a gap)
     * in the specified block which is added into a sequential group.
     *
     * @param block	a block with an only element in a parallel group.
     *
     * @return		the agent of the unique element in the specified block.
     */
    private Agent getElementFromBlockWithOnlyWord(Block block) {
        String word = block.textAt(block.firstWord_Horizontally());
        if (word.charAt(0) == '.')
            return new TemporaryGapAgent(word);
        return new ComponentAgent(word);
    }

    /**
     * Returns a new parallel group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new parallel group.
     */
    protected Agent composeParallelGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractParallelSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfParallelGroup(block);
        ParallelGroupAgent result = new ParallelGroupAgent();
        Agent agent;
        for (Block subBlock : blocksList) {
            agent = processSubblockOfParallelGroup(subBlock);
            if (agent != null)
                result.addAgent(agent);
        }
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and then either returns the agent of the corresponding element,
     * or divides the set of elements into a new sequential subgroup
     * and returns the corresponding agent.
     * <p>
     * If there is a unique element and it is a gap,
     *
     * @param subblock	a block in a parallel group.
     *
     * @return	the agent of the specified subblock content.
     */
    private Agent processSubblockOfParallelGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return compouseSequentialGroupFromBlock(subblock);
    }

    /**
     * Associates the specified {@code name} on the scheme
     * with the specified {@code component}.
     *
     * @param name		the component name present on the scheme.
     * @param component	the component to be associated with the name.
     */
    public void associate(String name, Component component) {
        namesToComponents.put(name, component);
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with gaps of the specified {@code size}.
     */
    public void associateGap(String denotation, int size) {
        namesToGapAgents.put(denotation, new GapAgent(size));
    }

    /**
     * Associates the specified {@code denotation} on the scheme with gaps
     * of the specified {@code min}, {@code pref}, and {@code max} sizes.
     */
    public void associateGap(String denotation, int min, int pref, int max) {
        namesToGapAgents.put(denotation, new GapAgent(min, pref, max));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated).
     */
    public void associateGap(String denotation, ComponentPlacement type) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated)
     * and of the specified preferred and maximum sizes.
     */
    public void associateGap(String denotation, ComponentPlacement type, int pref, int max) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type, pref, max));
    }

    /**
     * Sets whether a gap between components should automatically be
     * created. For example, if this is {@code true} and you add two
     * components to a {@code SequentialGroup} a gap between the
     * two components is automatically be created.
     *
     * @param autoCreatePadding	whether a gap between components is
     *        					automatically created.
     */
    public void setAutoCreateGaps(boolean autoCreatePadding) {
        gl.setAutoCreateGaps(autoCreatePadding);
    }

    /**
     * Sets whether a gap between the container and components that touch
     * the border of the container should automatically be created.
     *
     * @param autoCreateContainerGaps	whether a gap between the container
     * 									and components that touch the border
     * 									of the container should automatically
     * 									be created.
     */
    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps) {
        gl.setAutoCreateContainerGaps(autoCreateContainerGaps);
    }

    /**
     * Sets whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    public void setAutoAlignJTextFields(boolean autoBaselineAlignment) {
        this.autoBaselineAlignment = autoBaselineAlignment;
    }

    /**
     * Forces the specified components to have the same size
     * regardless of their preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(String... names) {
        Component[] components = namesToComponents.getComponents(names);
        gl.linkSize(components);
    }

    /**
     * Forces the specified components to have the same size
     * along the specified axis regardless of their
     * preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param axis	the axis to link the size along.
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(Axis axis, String... names) {
        Component[] components = namesToComponents.getComponents(names);
        if (axis == Axis.HORIZONTAL)
            gl.linkSize(SwingConstants.HORIZONTAL, components);
        else
            //axis==Axis.VERTICAL
            gl.linkSize(SwingConstants.VERTICAL, components);
    }

    /**
     * Disables the components under the specified names.
     * <p>
     * Each component must be associated with its name
     * before this method is applied.
     */
    public void disable(String... componentsNames) {
        for (Component c : namesToComponents.getComponents(componentsNames)) c.setEnabled(false);
    }

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis			layout direction
     * @param componentName	the name of the component to be found
     * @return				an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName) {
        Agent agent = getAgent(axis, componentName);
        if (agent == null)
            throw new IllegalArgumentException(""no such component found: "" + componentName);
        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();
    }

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getGroupAgent(axis, firstName, lastName);
        if (agent == null || !(agent instanceof GroupAgent))
            throw new IllegalArgumentException(""no such group found: <"" + firstName + "","" + lastName + "">"");
        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();
    }

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getParallelGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""no such parallel group found: <"" + firstName + "","" + lastName + "">"");
        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();
    }

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getSequentialGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""No such sequential group found: <"" + firstName + "","" + lastName + "">."");
        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {
        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the component with the specified name
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @param name	the name of the component to be found
     * @return		the corresponding agent
     */
    private Agent getAgent(Axis axis, String name) {
        return getTopAgent(axis).findDependingComponentByName(name);
    }

    /**
     * Returns the agent of the group with the specified first and last names
     * under the specified layout direction.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			the agent of the corresponding group
     */
    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingGroupByNames(firstName, lastName);
    }

    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingSequentialGroupByNames(firstName, lastName);
    }

    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingParallelGroupByNames(firstName, lastName);
    }

    /**
     * Returns (a reference to) the top agent
     * for the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the corresponding top agent
     */
    private TopSequentialGroupAgent getTopAgent(Axis axis) {
        return axis == Axis.HORIZONTAL ? horizontalLayoutAgent : verticalLayoutAgent;
    }

    /**
     * Places the components into the container
     * according to the scheme and to all additional preferences.
     */
    public void engineer() {
        horizontalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        verticalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        if (autoBaselineAlignment)
            makeTextFieldsBaselineIn(verticalLayoutAgent);
        creatorAndAdder = new GroupCreatorAndElementAdderClass();
        gl.setHorizontalGroup(horizontalLayoutAgent.groupContent(creatorAndAdder));
        gl.setVerticalGroup(verticalLayoutAgent.groupContent(creatorAndAdder));
    }

    /**
     * If the specified group is parallel,
     * contains directly a component of type {@code JTextField},
     * and does not contain other groups with components,
     * then this method makes the alignment of the group {@code Baseline}.
     * <p>
     * In the case of a group having subgroups with components
     * this method passes the call to that subgroups.
     * <p>
     * As a result of applying this method,
     * all parallel groups having TextFields (but having no subgroups)
     * will be aligned along baselines.
     */
    private void makeTextFieldsBaselineIn(GroupAgent group) {
        boolean containsGroups = false;
        //the group must be baseline aligned
        boolean containsTextfields = false;
        boolean isParallel = group instanceof ParallelGroupAgent;
        for (Agent child : group.getChildren()) {
            if (child instanceof GroupAgent && ((GroupAgent) child).getFirstName() != null) {
                //child is a group with components.
                makeTextFieldsBaselineIn((GroupAgent) child);
                containsGroups = true;
            } else if (child instanceof ComponentAgent && isParallel && !containsGroups) {
                ComponentAgent agent = (ComponentAgent) child;
                Component comp = namesToComponents.compMap.get(agent.getFirstName());
                if (comp instanceof JTextField)
                    containsTextfields = true;
            }
        }
        if (containsTextfields) {
            ParallelGroupSettings settings = ((ParallelGroupAgent) group).getSettings();
            if (settings.contentAlignment == null)
                settings.contentAlignment = Alignment.BASELINE;
        }
    }

    /**
     * Outputs the groups hierarchy.
     */
    public void printGroupStructure() {
        new GroupPrinter().printTopGroupsStructure();
    }

    /**
     * Encapsulates the ""names of components - to - components"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToComponents {

        /**
         * Holds the association between the names of the components on
         * the scheme and the corresponding components.
         */
        private HashMap<String, Component> compMap = new HashMap<String, Component>();

        public NamesToComponents() {
        }

        @SuppressWarnings(""unused"")
        public boolean contains(String name) {
            return compMap.containsKey(name);
        }

        @SuppressWarnings(""unused"")
        public boolean contains(Component component) {
            return compMap.containsValue(component);
        }

        public void put(String name, Component component) {
            if (name == null || component == null || !scheme.containsComponentName(name) || compMap.put(name, component) != null)
                throw new IllegalArgumentException(""Cannot associate a component"" + "" with the name \"""" + name + ""\"""");
        }

        /**
         * Returns the component associated with the specified name.
         *
         * @param name	the name of the component to return
         *
         * @return		the component associated with the specified name
         */
        public Component getComponent(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Component result = compMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a component"" + "" with the specified name \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the components associated with the specified names.
         *
         * @param names	the names of the components to return
         *
         * @return		the components associated with the specified names
         */
        public Component[] getComponents(String... names) {
            int l = names.length;
            Component[] components = new Component[l];
            for (int i = 0; i < l; i++) components[i] = getComponent(names[i]);
            return components;
        }
    }

    /**
     * Declares the method of possessing the gap agent
     * by a temporary gap agent.
     */
    public interface TemporaryGapsToGaps {

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp);
    }

    /**
     * Encapsulates the ""names of the gaps - to - agents of these gaps"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToGapAgents implements TemporaryGapsToGaps {

        /**
         * Holds the association between the gaps denotations
         * on the scheme and the corresponding gap types.
         * <p>
         * The gaps (which can be preferred or simple) are represented
         * by instances of {@code Agent}, which is a superclass
         * for both {@code PreferredGapAgent} and {@code GapAgent}.
         */
        private HashMap<String, Agent> gapMap = new HashMap<String, Agent>();

        public NamesToGapAgents() {
            safePut(""."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));
            safePut("".."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));
        }

        public void put(String name, GapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, GapAgent agent) {
            gapMap.put(name, agent);
        }

        public void put(String name, PreferredGapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, PreferredGapAgent agent) {
            gapMap.put(name, agent);
        }

        /**
         * Returns the gap agent associated with the specified name.
         */
        public Agent gap(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Agent result = gapMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a gap denoted by \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp) {
            return gap(temp.getDenotation());
        }
    }

    /**
     * An adapter for such functions of the {@code GroupLayout}
     * as creating new groups and adding groups and components to groups.
     */
    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {

        /**
         * Creates and returns a new {@code SequentialGroup}.
         */
        public SequentialGroup createSequentialGroup() {
            return gl.createSequentialGroup();
        }

        /**
         * Creates and returns a new {@code ParallelGroup}
         * with the specified settings.
         */
        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
            if (settings.contentAlignment != null)
                if (settings.resizable != null)
                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);
                else
                    //(resizable == null)
                    return gl.createParallelGroup(settings.contentAlignment);
            else //(settings.contentAlignment == null)
            if (settings.resizable != null)
                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);
            else
                return gl.createParallelGroup();
        }

        /**
         * Adds the component having the specified {@code compName}
         * to the specified {@code group},
         * applies to it the specified {@code settings}.
         */
        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {
            if (settings.alignmentWithRespectToParent != null)
                //It seems that we must add to a parallel group.
                if (group instanceof ParallelGroup)
                    //Really, to a parallel.
                    if (settings.sizes != null) {
                        Sizes sizes = settings.sizes;
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);
                    } else
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);
                else
                    //Parallel group not found.
                    throw new IllegalArgumentException(""components can be aligned in parallel groups only"");
            else //Alignment not specified.
            if (settings.sizes != null) {
                Sizes sizes = settings.sizes;
                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);
            } else
                //Even sizes aren't specified.
                group.addComponent(namesToComponents.getComponent(compName));
        }

        /**
         * Adds the specified {@code group} with the specified {@code settings}
         * to another group {@code parentGroup}.
         */
        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {
            if (settings.alignmentWithRespectToParent != null)
                if (parentGroup instanceof ParallelGroup)
                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);
                else
                    throw new IllegalArgumentException(""content can be aligned in parallel groups only"");
            parentGroup.addGroup(group);
        }
    }

    /**
     * Provides output of the created groups' structure.
     * <p>
     * Is maintained for debugging purposes.
     */
    public class GroupPrinter {

        /**
         * Outputs the both directions top groups structures.
         */
        public void printTopGroupsStructure() {
            Axis axis;
            axis = Axis.HORIZONTAL;
            System.out.println(""\nTop "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
            System.out.println(""\n-----------------------------\n"");
            axis = Axis.VERTICAL;
            System.out.println(""Top "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
        }

        /**
         * Outputs the specified direction top group structure.
         */
        public void printTopGroupStructure(Axis axis) {
            printGroupStructure(getTopAgent(axis));
        }

        /**
         * Outputs the specified group structure.
         */
        public void printGroupStructure(GroupAgent group) {
            System.out.println();
            System.out.println(""Elements of "" + group.toString() + "":"");
            List<Agent> childrenAgents = group.getChildren();
            for (Agent child : childrenAgents) System.out.println(child.toString());
            for (Agent child : childrenAgents) if (child instanceof GroupAgent)
                printGroupStructure((GroupAgent) child);
        }
    }
}
","// GroupLayoutEngineer_3Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getSequentialGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_3Test {","// GroupLayoutEngineer_3Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getSequentialGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_3Test {
"
b026457e-3f72-442b-9359-793ae74463f3,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_4Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 11509 tokens (9509 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    private Scheme scheme;

    /**
     * The mapping of the names on the scheme to the associated components.
     */
    private NamesToComponents namesToComponents;

    private NamesToGapAgents namesToGapAgents;

    /**
     * The layout manager {@code GroupLayout} under control.
     */
    private GroupLayout gl;

    /**
     * The object which can create sequential and parallel
     * {@code GroupLayout} groups and add components to groups
     * using the components' names.
     * <p>
     * A reference to this object is given to the agents of elements.
     *
     * @see glengineer.agents
     */
    private GroupCreatorAndElementAdderClass creatorAndAdder;

    /**
     * The agent of the top level horizontal group.
     */
    private TopSequentialGroupAgent horizontalLayoutAgent;

    /**
     * The agent of the top level vertical group.
     */
    private TopSequentialGroupAgent verticalLayoutAgent;

    /**
     * Whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    private boolean autoBaselineAlignment = false;

    /**
     * @param container	the container that needs to be laid out
     * @param lines		a sequence of lines representing the scheme
     */
    public GroupLayoutEngineer(Container container, String... lines) {
        scheme = new Scheme(lines);
        namesToComponents = new NamesToComponents();
        namesToGapAgents = new NamesToGapAgents();
        horizontalLayoutAgent = compouseTopSequentialGroup(Axis.HORIZONTAL);
        verticalLayoutAgent = compouseTopSequentialGroup(Axis.VERTICAL);
        horizontalLayoutAgent.removeGapsFromParallelGroups();
        verticalLayoutAgent.removeGapsFromParallelGroups();
        gl = new GroupLayout(container);
        container.setLayout(gl);
        //		setAutoCreateGaps(true);
        //		setAutoCreateContainerGaps(true);
    }

    /**
     * Returns a top sequential group agent for the specified layout direction.
     * <p>
     * A group will be created even if it would contain a single element.
     *
     * @param axis	the layout direction
     *
     * @return		the agent of the new sequential group
     */
    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis) {
        Block topBlock;
        if (axis == Axis.HORIZONTAL)
            topBlock = new HorizontalBlock(scheme);
        else
            //VERTICAL
            topBlock = new VerticalBlock(scheme);
        topBlock.optimize();
        if (topBlock.isTrivial())
            throw new IllegalArgumentException(""the scheme does not possess components' names"");
        TopSequentialGroupAgent result = new TopSequentialGroupAgent();
        List<Block> blocksList = topBlock.extractSequentialSubblocks();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Returns a new sequential group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new sequential group.
     */
    protected Agent compouseSequentialGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractSequentialSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfSequentialGroup(block);
        SequentialGroupAgent result = new SequentialGroupAgent();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and either returns the agent of the corresponding element,
     * or divides the set of elements into a new parallel subgroup
     * and returns the corresponding agent.
     *
     * @param subblock	a block in a sequential group.
     *
     * @return			the agent of the specified subblock content.
     */
    private Agent processSubblockOfSequentialGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return composeParallelGroupFromBlock(subblock);
    }

    /**
     * Returns the agent of the unique element (a component or a gap)
     * in the specified block which is added into a sequential group.
     *
     * @param block	a block with an only element in a parallel group.
     *
     * @return		the agent of the unique element in the specified block.
     */
    private Agent getElementFromBlockWithOnlyWord(Block block) {
        String word = block.textAt(block.firstWord_Horizontally());
        if (word.charAt(0) == '.')
            return new TemporaryGapAgent(word);
        return new ComponentAgent(word);
    }

    /**
     * Returns a new parallel group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new parallel group.
     */
    protected Agent composeParallelGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractParallelSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfParallelGroup(block);
        ParallelGroupAgent result = new ParallelGroupAgent();
        Agent agent;
        for (Block subBlock : blocksList) {
            agent = processSubblockOfParallelGroup(subBlock);
            if (agent != null)
                result.addAgent(agent);
        }
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and then either returns the agent of the corresponding element,
     * or divides the set of elements into a new sequential subgroup
     * and returns the corresponding agent.
     * <p>
     * If there is a unique element and it is a gap,
     *
     * @param subblock	a block in a parallel group.
     *
     * @return	the agent of the specified subblock content.
     */
    private Agent processSubblockOfParallelGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return compouseSequentialGroupFromBlock(subblock);
    }

    /**
     * Associates the specified {@code name} on the scheme
     * with the specified {@code component}.
     *
     * @param name		the component name present on the scheme.
     * @param component	the component to be associated with the name.
     */
    public void associate(String name, Component component) {
        namesToComponents.put(name, component);
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with gaps of the specified {@code size}.
     */
    public void associateGap(String denotation, int size) {
        namesToGapAgents.put(denotation, new GapAgent(size));
    }

    /**
     * Associates the specified {@code denotation} on the scheme with gaps
     * of the specified {@code min}, {@code pref}, and {@code max} sizes.
     */
    public void associateGap(String denotation, int min, int pref, int max) {
        namesToGapAgents.put(denotation, new GapAgent(min, pref, max));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated).
     */
    public void associateGap(String denotation, ComponentPlacement type) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated)
     * and of the specified preferred and maximum sizes.
     */
    public void associateGap(String denotation, ComponentPlacement type, int pref, int max) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type, pref, max));
    }

    /**
     * Sets whether a gap between components should automatically be
     * created. For example, if this is {@code true} and you add two
     * components to a {@code SequentialGroup} a gap between the
     * two components is automatically be created.
     *
     * @param autoCreatePadding	whether a gap between components is
     *        					automatically created.
     */
    public void setAutoCreateGaps(boolean autoCreatePadding) {
        gl.setAutoCreateGaps(autoCreatePadding);
    }

    /**
     * Sets whether a gap between the container and components that touch
     * the border of the container should automatically be created.
     *
     * @param autoCreateContainerGaps	whether a gap between the container
     * 									and components that touch the border
     * 									of the container should automatically
     * 									be created.
     */
    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps) {
        gl.setAutoCreateContainerGaps(autoCreateContainerGaps);
    }

    /**
     * Sets whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    public void setAutoAlignJTextFields(boolean autoBaselineAlignment) {
        this.autoBaselineAlignment = autoBaselineAlignment;
    }

    /**
     * Forces the specified components to have the same size
     * regardless of their preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(String... names) {
        Component[] components = namesToComponents.getComponents(names);
        gl.linkSize(components);
    }

    /**
     * Forces the specified components to have the same size
     * along the specified axis regardless of their
     * preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param axis	the axis to link the size along.
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(Axis axis, String... names) {
        Component[] components = namesToComponents.getComponents(names);
        if (axis == Axis.HORIZONTAL)
            gl.linkSize(SwingConstants.HORIZONTAL, components);
        else
            //axis==Axis.VERTICAL
            gl.linkSize(SwingConstants.VERTICAL, components);
    }

    /**
     * Disables the components under the specified names.
     * <p>
     * Each component must be associated with its name
     * before this method is applied.
     */
    public void disable(String... componentsNames) {
        for (Component c : namesToComponents.getComponents(componentsNames)) c.setEnabled(false);
    }

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis			layout direction
     * @param componentName	the name of the component to be found
     * @return				an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName) {
        Agent agent = getAgent(axis, componentName);
        if (agent == null)
            throw new IllegalArgumentException(""no such component found: "" + componentName);
        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();
    }

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getGroupAgent(axis, firstName, lastName);
        if (agent == null || !(agent instanceof GroupAgent))
            throw new IllegalArgumentException(""no such group found: <"" + firstName + "","" + lastName + "">"");
        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();
    }

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getParallelGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""no such parallel group found: <"" + firstName + "","" + lastName + "">"");
        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();
    }

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getSequentialGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""No such sequential group found: <"" + firstName + "","" + lastName + "">."");
        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {
        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the component with the specified name
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @param name	the name of the component to be found
     * @return		the corresponding agent
     */
    private Agent getAgent(Axis axis, String name) {
        return getTopAgent(axis).findDependingComponentByName(name);
    }

    /**
     * Returns the agent of the group with the specified first and last names
     * under the specified layout direction.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			the agent of the corresponding group
     */
    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingGroupByNames(firstName, lastName);
    }

    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingSequentialGroupByNames(firstName, lastName);
    }

    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingParallelGroupByNames(firstName, lastName);
    }

    /**
     * Returns (a reference to) the top agent
     * for the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the corresponding top agent
     */
    private TopSequentialGroupAgent getTopAgent(Axis axis) {
        return axis == Axis.HORIZONTAL ? horizontalLayoutAgent : verticalLayoutAgent;
    }

    /**
     * Places the components into the container
     * according to the scheme and to all additional preferences.
     */
    public void engineer() {
        horizontalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        verticalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        if (autoBaselineAlignment)
            makeTextFieldsBaselineIn(verticalLayoutAgent);
        creatorAndAdder = new GroupCreatorAndElementAdderClass();
        gl.setHorizontalGroup(horizontalLayoutAgent.groupContent(creatorAndAdder));
        gl.setVerticalGroup(verticalLayoutAgent.groupContent(creatorAndAdder));
    }

    /**
     * If the specified group is parallel,
     * contains directly a component of type {@code JTextField},
     * and does not contain other groups with components,
     * then this method makes the alignment of the group {@code Baseline}.
     * <p>
     * In the case of a group having subgroups with components
     * this method passes the call to that subgroups.
     * <p>
     * As a result of applying this method,
     * all parallel groups having TextFields (but having no subgroups)
     * will be aligned along baselines.
     */
    private void makeTextFieldsBaselineIn(GroupAgent group) {
        boolean containsGroups = false;
        //the group must be baseline aligned
        boolean containsTextfields = false;
        boolean isParallel = group instanceof ParallelGroupAgent;
        for (Agent child : group.getChildren()) {
            if (child instanceof GroupAgent && ((GroupAgent) child).getFirstName() != null) {
                //child is a group with components.
                makeTextFieldsBaselineIn((GroupAgent) child);
                containsGroups = true;
            } else if (child instanceof ComponentAgent && isParallel && !containsGroups) {
                ComponentAgent agent = (ComponentAgent) child;
                Component comp = namesToComponents.compMap.get(agent.getFirstName());
                if (comp instanceof JTextField)
                    containsTextfields = true;
            }
        }
        if (containsTextfields) {
            ParallelGroupSettings settings = ((ParallelGroupAgent) group).getSettings();
            if (settings.contentAlignment == null)
                settings.contentAlignment = Alignment.BASELINE;
        }
    }

    /**
     * Outputs the groups hierarchy.
     */
    public void printGroupStructure() {
        new GroupPrinter().printTopGroupsStructure();
    }

    /**
     * Encapsulates the ""names of components - to - components"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToComponents {

        /**
         * Holds the association between the names of the components on
         * the scheme and the corresponding components.
         */
        private HashMap<String, Component> compMap = new HashMap<String, Component>();

        public NamesToComponents() {
        }

        @SuppressWarnings(""unused"")
        public boolean contains(String name) {
            return compMap.containsKey(name);
        }

        @SuppressWarnings(""unused"")
        public boolean contains(Component component) {
            return compMap.containsValue(component);
        }

        public void put(String name, Component component) {
            if (name == null || component == null || !scheme.containsComponentName(name) || compMap.put(name, component) != null)
                throw new IllegalArgumentException(""Cannot associate a component"" + "" with the name \"""" + name + ""\"""");
        }

        /**
         * Returns the component associated with the specified name.
         *
         * @param name	the name of the component to return
         *
         * @return		the component associated with the specified name
         */
        public Component getComponent(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Component result = compMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a component"" + "" with the specified name \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the components associated with the specified names.
         *
         * @param names	the names of the components to return
         *
         * @return		the components associated with the specified names
         */
        public Component[] getComponents(String... names) {
            int l = names.length;
            Component[] components = new Component[l];
            for (int i = 0; i < l; i++) components[i] = getComponent(names[i]);
            return components;
        }
    }

    /**
     * Declares the method of possessing the gap agent
     * by a temporary gap agent.
     */
    public interface TemporaryGapsToGaps {

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp);
    }

    /**
     * Encapsulates the ""names of the gaps - to - agents of these gaps"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToGapAgents implements TemporaryGapsToGaps {

        /**
         * Holds the association between the gaps denotations
         * on the scheme and the corresponding gap types.
         * <p>
         * The gaps (which can be preferred or simple) are represented
         * by instances of {@code Agent}, which is a superclass
         * for both {@code PreferredGapAgent} and {@code GapAgent}.
         */
        private HashMap<String, Agent> gapMap = new HashMap<String, Agent>();

        public NamesToGapAgents() {
            safePut(""."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));
            safePut("".."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));
        }

        public void put(String name, GapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, GapAgent agent) {
            gapMap.put(name, agent);
        }

        public void put(String name, PreferredGapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, PreferredGapAgent agent) {
            gapMap.put(name, agent);
        }

        /**
         * Returns the gap agent associated with the specified name.
         */
        public Agent gap(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Agent result = gapMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a gap denoted by \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp) {
            return gap(temp.getDenotation());
        }
    }

    /**
     * An adapter for such functions of the {@code GroupLayout}
     * as creating new groups and adding groups and components to groups.
     */
    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {

        /**
         * Creates and returns a new {@code SequentialGroup}.
         */
        public SequentialGroup createSequentialGroup() {
            return gl.createSequentialGroup();
        }

        /**
         * Creates and returns a new {@code ParallelGroup}
         * with the specified settings.
         */
        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
            if (settings.contentAlignment != null)
                if (settings.resizable != null)
                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);
                else
                    //(resizable == null)
                    return gl.createParallelGroup(settings.contentAlignment);
            else //(settings.contentAlignment == null)
            if (settings.resizable != null)
                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);
            else
                return gl.createParallelGroup();
        }

        /**
         * Adds the component having the specified {@code compName}
         * to the specified {@code group},
         * applies to it the specified {@code settings}.
         */
        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {
            if (settings.alignmentWithRespectToParent != null)
                //It seems that we must add to a parallel group.
                if (group instanceof ParallelGroup)
                    //Really, to a parallel.
                    if (settings.sizes != null) {
                        Sizes sizes = settings.sizes;
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);
                    } else
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);
                else
                    //Parallel group not found.
                    throw new IllegalArgumentException(""components can be aligned in parallel groups only"");
            else //Alignment not specified.
            if (settings.sizes != null) {
                Sizes sizes = settings.sizes;
                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);
            } else
                //Even sizes aren't specified.
                group.addComponent(namesToComponents.getComponent(compName));
        }

        /**
         * Adds the specified {@code group} with the specified {@code settings}
         * to another group {@code parentGroup}.
         */
        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {
            if (settings.alignmentWithRespectToParent != null)
                if (parentGroup instanceof ParallelGroup)
                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);
                else
                    throw new IllegalArgumentException(""content can be aligned in parallel groups only"");
            parentGroup.addGroup(group);
        }
    }

    /**
     * Provides output of the created groups' structure.
     * <p>
     * Is maintained for debugging purposes.
     */
    public class GroupPrinter {

        /**
         * Outputs the both directions top groups structures.
         */
        public void printTopGroupsStructure() {
            Axis axis;
            axis = Axis.HORIZONTAL;
            System.out.println(""\nTop "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
            System.out.println(""\n-----------------------------\n"");
            axis = Axis.VERTICAL;
            System.out.println(""Top "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
        }

        /**
         * Outputs the specified direction top group structure.
         */
        public void printTopGroupStructure(Axis axis) {
            printGroupStructure(getTopAgent(axis));
        }

        /**
         * Outputs the specified group structure.
         */
        public void printGroupStructure(GroupAgent group) {
            System.out.println();
            System.out.println(""Elements of "" + group.toString() + "":"");
            List<Agent> childrenAgents = group.getChildren();
            for (Agent child : childrenAgents) System.out.println(child.toString());
            for (Agent child : childrenAgents) if (child instanceof GroupAgent)
                printGroupStructure((GroupAgent) child);
        }
    }
}
","// GroupLayoutEngineer_4Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getTopSequentialGroup(Axis)} method.
*/
class GroupLayoutEngineer_4Test {","// GroupLayoutEngineer_4Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getTopSequentialGroup(Axis)} method.
*/
class GroupLayoutEngineer_4Test {
"
cmpl-6wWbzGEGJKJGkEQKGR4OZ5msF41e1,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgent_0Test.java,61.31573700904846,length,"// ParallelGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * �����, �������������� ������������ ������.
 */
public class ParallelGroupAgent extends GroupAgent {

    public ParallelGroupAgent() {
        settings = new ParallelGroupSettings();
    }

    public ParallelGroupSettings getSettings() {
        return (ParallelGroupSettings) settings;
    }

    /**
     * Verifies whether all of the elements of this parallel group agent
     * are gaps.
     */
    public boolean containsGapsOnly() {
        for (Agent child : childrenAgents) if (!child.isGap())
            return false;
        return true;
    }

    /**
     * Removes all gaps from this parallel group.
     */
    public void removeAllGaps() {
        Iterator<Agent> i = childrenAgents.iterator();
        while (i.hasNext()) if (i.next().isGap())
            i.remove();
    }

    /**
     * Returns the gap of the type contained in this parallel group
     * or null if this group has no gaps.
     * If the gaps possess different types, throws a runtime exception.
     * <p>
     * After calling this method this parallel group,
     * which typically consists of gaps only,
     * can be replaced by the gap returned by this method.
     */
    public Agent getGapsType() {
        Iterator<Agent> i = childrenAgents.iterator();
        Agent firstGapFound = null;
        Agent next;
        while (i.hasNext()) {
            next = i.next();
            if (!next.isGap())
                continue;
            if (firstGapFound == null)
                firstGapFound = next;
            else //the first gap has been already found.
            if (next != firstGapFound)
                throw new IllegalArgumentException(""A parallel group consists of gaps only "" + ""but the gaps have different types."");
        }
        return firstGapFound;
    }

    /**
     * ���������� �������������� ���������� � ����� ������������ ������
     * � ���������� �.
     *
     * @param creatorAndAdder	��������� ��� �������� �����
     * 							� ���������� � ��� �����������
     * @return					������, ������������ �� ���������������
     * 							�����������.
     */
    public ParallelGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
        ParallelGroup result = creatorAndAdder.createParallelGroup(getSettings());
        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);
        return result;
    }

    public FunctionsOnGroup getFunctionsOnGroupImplemenation() {
        return getFunctionsOnParallelGroupImplemenation();
    }

    public FunctionsOnParallelGroup getFunctionsOnParallelGroupImplemenation() {
        return new FunctionsOnParallelGroupImplemenation();
    }

    private class FunctionsOnParallelGroupImplemenation implements FunctionsOnParallelGroup {

        /**
         * ������������� ������ ������������ ����������� ������������ ������.
         *
         * @param alignment	������ ������������
         */
        public void setContentAlignment(Alignment alignment) {
            ParallelGroupAgent.this.getSettings().contentAlignment = alignment;
        }

        /**
         * Determines the {@code resize} behavior of the {@code ParallelGroup}.
         *
         * @param resizable	{@code true} if the group is resizable;
         * 					if the group is not resizable
         * 					the preferred size is used for
         * 					the minimum and maximum size of the group.
         */
        public void setResizable(boolean resizable) {
            ParallelGroupAgent.this.getSettings().resizable = resizable;
        }

        /**
         * ������� ����� ""���������������� �����"" ������������ ������
         * ��������� � ��������� ���������.
         * <p>
         * ���������� ��������� {@code FunctionsOnParallelGroupAndElement}
         * ��������� ������������ �������� � ������������ ������.
         *
         * @param componentName	�������� �������� ����������
         * @return				���������
         * 						{@code FunctionsOnParallelGroupAndElement}
         * 						��������� ������������ ��������
         */
        public FunctionsOnParallelGroupAndElement getComponent(String componentName) {
            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getComponent(componentName));
        }

        /**
         * ������� ����� ""���������������� �����"" ������������ ������
         * ��������� � ���������� ���������� ������� � ���������� �����������.
         * <p>
         * ���������� ��������� {@code FunctionsOnParallelGroupAndElement}
         * ��������� ������������ �������� � ������������ ������.
         *
         * @param firstName	�������� ������� ���������� ������� ������
         * @param lastName	�������� ���������� ���������� ������� ������
         * @return			���������
         * 					{@code FunctionsOnParallelGroupAndElement}
         * 					��������� ������������ ��������
         */
        public FunctionsOnParallelGroupAndElement getGroup(String firstName, String lastName) {
            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getGroup(firstName, lastName));
        }
    }

    private static class FunctionsOnParallelGroupAndElementImplementation extends GroupAgent.FunctionsOnGroupAndElementImplementation implements FunctionsOnParallelGroupAndElement {

        public FunctionsOnParallelGroupAndElementImplementation(GroupAgent parent, Agent element) {
            super(parent, element);
        }

        /**
         * Assigns the specified alignment of the element {@code elementAgent}
         * in the parallel group {@code parentAgent}.
         */
        public void setAlignmentWithinParent(Alignment alignment) {
            elementAgent.settings.alignmentWithRespectToParent = alignment;
        }
    }

    public String toString() {
        return ""parallel group <"" + getFirstName() + "","" + getLastName() + "">"";
    }
}
","// ParallelGroupAgent_0Test.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.
*/
class ParallelGroupAgent_0Test {","// ParallelGroupAgent_0Test.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.
*/
class ParallelGroupAgent_0Test {

	/**
	 * Test case #1.
	 * <p>
	 * The parallel group contains gaps only.
	 * <p>
	 * Expected result: {@code true}.
	 */
	@Test
	void testContainsGapsOnly_1() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertTrue(parallelGroupAgent.containsGapsOnly());
	}
	
	/**
	 * Test case #2.
	 * <p>
	 * The parallel group contains gaps only.
	 * <p>
	 * Expected result: {@code true}.
	 */
	@Test
	void testContainsGapsOnly_2() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertTrue(parallelGroupAgent.containsGapsOnly());
	}
	
	/**
	 * Test case #3.
	 * <p>
	 * The parallel group contains gaps only.
	 * <p>
	 * Expected result: {@code true}.
	 */
	@Test
	void testContainsGapsOnly_3() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertTrue(parallelGroupAgent.containsGapsOnly());
	}
	
	/**
	 * Test case #4.
	 * <p>
	 * The parallel group contains gaps only.
	 * <p>
	 * Expected result: {@code true}.
	 */
	@Test
	void testContainsGapsOnly_4() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addG"
cmpl-6wWcywp0gmVJI5rBIP38x4yMDSoSX,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgent_1Test.java,65.43106079101562,length,"// ParallelGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * �����, �������������� ������������ ������.
 */
public class ParallelGroupAgent extends GroupAgent {

    public ParallelGroupAgent() {
        settings = new ParallelGroupSettings();
    }

    public ParallelGroupSettings getSettings() {
        return (ParallelGroupSettings) settings;
    }

    /**
     * Verifies whether all of the elements of this parallel group agent
     * are gaps.
     */
    public boolean containsGapsOnly() {
        for (Agent child : childrenAgents) if (!child.isGap())
            return false;
        return true;
    }

    /**
     * Removes all gaps from this parallel group.
     */
    public void removeAllGaps() {
        Iterator<Agent> i = childrenAgents.iterator();
        while (i.hasNext()) if (i.next().isGap())
            i.remove();
    }

    /**
     * Returns the gap of the type contained in this parallel group
     * or null if this group has no gaps.
     * If the gaps possess different types, throws a runtime exception.
     * <p>
     * After calling this method this parallel group,
     * which typically consists of gaps only,
     * can be replaced by the gap returned by this method.
     */
    public Agent getGapsType() {
        Iterator<Agent> i = childrenAgents.iterator();
        Agent firstGapFound = null;
        Agent next;
        while (i.hasNext()) {
            next = i.next();
            if (!next.isGap())
                continue;
            if (firstGapFound == null)
                firstGapFound = next;
            else //the first gap has been already found.
            if (next != firstGapFound)
                throw new IllegalArgumentException(""A parallel group consists of gaps only "" + ""but the gaps have different types."");
        }
        return firstGapFound;
    }

    /**
     * ���������� �������������� ���������� � ����� ������������ ������
     * � ���������� �.
     *
     * @param creatorAndAdder	��������� ��� �������� �����
     * 							� ���������� � ��� �����������
     * @return					������, ������������ �� ���������������
     * 							�����������.
     */
    public ParallelGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
        ParallelGroup result = creatorAndAdder.createParallelGroup(getSettings());
        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);
        return result;
    }

    public FunctionsOnGroup getFunctionsOnGroupImplemenation() {
        return getFunctionsOnParallelGroupImplemenation();
    }

    public FunctionsOnParallelGroup getFunctionsOnParallelGroupImplemenation() {
        return new FunctionsOnParallelGroupImplemenation();
    }

    private class FunctionsOnParallelGroupImplemenation implements FunctionsOnParallelGroup {

        /**
         * ������������� ������ ������������ ����������� ������������ ������.
         *
         * @param alignment	������ ������������
         */
        public void setContentAlignment(Alignment alignment) {
            ParallelGroupAgent.this.getSettings().contentAlignment = alignment;
        }

        /**
         * Determines the {@code resize} behavior of the {@code ParallelGroup}.
         *
         * @param resizable	{@code true} if the group is resizable;
         * 					if the group is not resizable
         * 					the preferred size is used for
         * 					the minimum and maximum size of the group.
         */
        public void setResizable(boolean resizable) {
            ParallelGroupAgent.this.getSettings().resizable = resizable;
        }

        /**
         * ������� ����� ""���������������� �����"" ������������ ������
         * ��������� � ��������� ���������.
         * <p>
         * ���������� ��������� {@code FunctionsOnParallelGroupAndElement}
         * ��������� ������������ �������� � ������������ ������.
         *
         * @param componentName	�������� �������� ����������
         * @return				���������
         * 						{@code FunctionsOnParallelGroupAndElement}
         * 						��������� ������������ ��������
         */
        public FunctionsOnParallelGroupAndElement getComponent(String componentName) {
            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getComponent(componentName));
        }

        /**
         * ������� ����� ""���������������� �����"" ������������ ������
         * ��������� � ���������� ���������� ������� � ���������� �����������.
         * <p>
         * ���������� ��������� {@code FunctionsOnParallelGroupAndElement}
         * ��������� ������������ �������� � ������������ ������.
         *
         * @param firstName	�������� ������� ���������� ������� ������
         * @param lastName	�������� ���������� ���������� ������� ������
         * @return			���������
         * 					{@code FunctionsOnParallelGroupAndElement}
         * 					��������� ������������ ��������
         */
        public FunctionsOnParallelGroupAndElement getGroup(String firstName, String lastName) {
            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getGroup(firstName, lastName));
        }
    }

    private static class FunctionsOnParallelGroupAndElementImplementation extends GroupAgent.FunctionsOnGroupAndElementImplementation implements FunctionsOnParallelGroupAndElement {

        public FunctionsOnParallelGroupAndElementImplementation(GroupAgent parent, Agent element) {
            super(parent, element);
        }

        /**
         * Assigns the specified alignment of the element {@code elementAgent}
         * in the parallel group {@code parentAgent}.
         */
        public void setAlignmentWithinParent(Alignment alignment) {
            elementAgent.settings.alignmentWithRespectToParent = alignment;
        }
    }

    public String toString() {
        return ""parallel group <"" + getFirstName() + "","" + getLastName() + "">"";
    }
}
","// ParallelGroupAgent_1Test.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class ParallelGroupAgent_1Test {","// ParallelGroupAgent_1Test.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class ParallelGroupAgent_1Test {

	/**
	 * Test case #1.
	 * <p>
	 * The parallel group contains a single gap.
	 * <p>
	 * The gap is added to the parallel group.
	 */
	@Test
	void testGroupContent_1() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(10);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(Alignment.LEADING);
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
			public void addGroupToGroup(ParallelGroup group, GroupAgent groupAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		
		assertEquals(1, parallelGroup.getSize());
		assertEquals(10, parallelGroup.getChild(0).getPreferredSize());
	}
	
	/**
	 * Test case #2.
	 * <p>
	 * The parallel group contains a single component.
	 * <p>
	 * The component is added to the parallel group.
	 */
	@Test
	void testGroupContent_2() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addComponent(""component"");
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(Alignment.LEADING);
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				group.addComponent(componentAgent.getComponent());
			}
			public void addGroupToGroup(ParallelGroup group, GroupAgent groupAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		
		assertEquals(1, parallelGroup.getSize());
		assertEquals(""component"", parallelGroup.getChild(0).getComponent().getName());
	}
	
	/**
	 * Test case #3.
	 * <p>
	 * The parallel group contains a single group.
	 * <p>
	 * The group is added to the parallel group.
	 */
	@Test
	void testGroupContent_3() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGroup(""group"");
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(Alignment.LEADING);
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
			public void addGroupToGroup(ParallelGroup group, GroupAgent groupAgent) {
				group.addGroup(groupAgent.groupContent(this));
			}
		});
		
		assertEquals(1, parallelGroup.getSize());
		assertEquals(""group"", parallelGroup.getChild(0).getName());
	}
	
	/**
	 * Test case #4.
	 * <p>
	 * The parallel group contains a single gap.
	 * <p>
	 * The gap is added to the parallel group.
	 * <p>
	 * The gap is resizable.
	 */
	@Test
	void testGroupContent_4() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(10);
		parallelGroupAgent.getGapsType().setResizable(true);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(Alignment.LEADING);
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
			public void addGroupToGroup(ParallelGroup group, GroupAgent groupAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		
		assertEquals(1, parallelGroup.getSize());
		assertEquals(10, parallelGroup.getChild(0).getPreferredSize());
		assertEquals(10, parallelGroup.getChild(0).getMinimumSize());
		assertEquals(10, parallelGroup.getChild(0).getMaximumSize());
	}
	
	/**
	 * Test case #5.
	 * <p>
	 * The parallel group contains a single gap.
	 * <p>
	 * The gap is added to the parallel group.
	 * <p>
	 * The gap is not resizable.
	 */
	@Test
	void testGroupContent_5() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(10);
		parallelGroupAgent.getGapsType().setResizable(false);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(Alignment.LEADING);
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
			public void addGroupToGroup(ParallelGroup group, GroupAgent groupAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		
		assertEquals(1, parallelGroup.getSize());
		assertEquals(10, parallelGroup.getChild(0).getPreferredSize());
		assertEquals(10, parallelGroup.getChild(0).getMinimumSize());
		assertEquals(10, parallelGroup.getChild(0).getMaximumSize());
	}
	
	/**
	 * Test case #6.
	 * <p>
	 * The parallel group contains a single component.
	 * <p>
	 * The component is added to the parallel group.
	 * <p>
	 * The component is resizable.
	 */
	@Test
	void testGroupContent_6() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addComponent(""component"");
		parallelGroupAgent.getComponent(""component"").setResizable(true);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(Alignment.LEADING);
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				group.addComponent(componentAgent.getComponent());
			}
			public void addGroupToGroup(ParallelGroup group, GroupAgent groupAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		
		assertEquals(1, parallelGroup.getSize());
		assertEquals(""component"", parallelGroup.getChild(0).getComponent().getName());
		assertEquals(0, parallelGroup.getChild(0).getMinimumSize());
		assertEquals("
cmpl-6wWe2uMtXW4xFyYfgTNRRLSuFMusC,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/agents/SequentialGroupAgent.java,55.29232382774353,length,"// SequentialGroupAgent.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;

/**
 * �����, �������������� ���������������� ������.
 */
public class SequentialGroupAgent extends GroupAgent {

    /**
     * ���������� �������������� ���������� � ����� ���������������� ������
     * � ���������� �.
     *
     * @param creatorAndAdder	��������� ��� �������� �����
     * 							� ���������� � ��� �����������
     * @return					������, ������������ �� ���������������
     * 							�����������.
     */
    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
        SequentialGroup result = creatorAndAdder.createSequentialGroup();
        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);
        return result;
    }

    public FunctionsOnGroup getFunctionsOnGroupImplemenation() {
        return getFunctionsOnSequentialGroupImplemenation();
    }

    public FunctionsOnSequentialGroup getFunctionsOnSequentialGroupImplemenation() {
        return new FunctionsOnSequentialGroupImplemenation();
    }

    protected class FunctionsOnSequentialGroupImplemenation implements FunctionsOnSequentialGroup {

        public FunctionsOnSequentialGroupAndElement getComponent(String name) {
            return new FunctionsOnSequentialGroupAndElementImplementation(SequentialGroupAgent.this, SequentialGroupAgent.this.getComponent(name));
        }

        public FunctionsOnSequentialGroupAndElement getGroup(String firstName, String lastName) {
            return new FunctionsOnSequentialGroupAndElementImplementation(SequentialGroupAgent.this, SequentialGroupAgent.this.getGroup(firstName, lastName));
        }
    }

    private static class FunctionsOnSequentialGroupAndElementImplementation extends GroupAgent.FunctionsOnGroupAndElementImplementation implements FunctionsOnSequentialGroupAndElement {

        public FunctionsOnSequentialGroupAndElementImplementation(GroupAgent parent, Agent element) {
            super(parent, element);
        }

        private SequentialGroupAgent getParentGroupAgent() {
            return (SequentialGroupAgent) parentGroupAgent;
        }

        /**
         * ��������� ����� ��������� ������������ ������
         *  ""���������"" ����������.
         */
        public void addPrecedingRelatedGap() {
            addPrecedingRelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);
        }

        /**
         * ��������� ����� ��������� ������������ ������
         *  ""�����������"" ����������.
         */
        public void addPrecedingUnrelatedGap() {
            addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);
        }

        /**
         * ��������� ����� �������� ������������ ������
         *  ""���������"" ����������.
         */
        public void addFollowingRelatedGap() {
            addFollowingRelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);
        }

        /**
         * ��������� ����� �������� ������������ ������
         *  ""�����������"" ����������.
         */
        public void addFollowingUnrelatedGap() {
            addFollowingUnrelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);
        }

        /**
         * ��������� � ������������ ������ ����� � ���������
         *  ""���������"" ���������� � ������������� ���������� ��� ����
         *  �������������� � ������������ �������.
         */
        public void addPrecedingRelatedGap(int pref, int max) {
            getParentGroupAgent().addPreferredGapBefore(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, pref, max), elementAgent);
        }

        /**
         * ��������� � ������������ ������ ����� � ���������
         *  ""�����������"" ���������� � ������������� ���������� ��� ����
         *  �������������� � ������������ �������.
         */
        public void addPrecedingUnrelatedGap(int pref, int max) {
            getParentGroupAgent().addPreferredGapBefore(new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED, pref, max), elementAgent);
        }

        /**
         * ��������� � ������������ ������ ����� � ��������
         *  ""���������"" ���������� � ������������� ���������� ��� ����
         *  �������������� � ������������ �������.
         */
        public void addFollowingRelatedGap(int pref, int max) {
            getParentGroupAgent().addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, pref, max), elementAgent);
        }

        /**
         * ��������� � ������������ ������ ����� � ��������
         *  ""�����������"" ���������� � ������������� ���������� ��� ����
         *  �������������� � ������������ �������.
         */
        public void addFollowingUnrelatedGap(int pref, int max) {
            getParentGroupAgent().addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED, pref, max), elementAgent);
        }
    }

    /**
     * Finds the specified element in the list of
     * this sequential group's children and inserts
     * the specified preferred gap into that list before that element.
     */
    public void addPreferredGapBefore(PreferredGapAgent gap, Agent element) {
        if (childrenAgents.isEmpty()) {
            childrenAgents.add(gap);
            return;
        }
        ListIterator<Agent> iter = childrenAgents.listIterator();
        while (iter.hasNext()) if (iter.next().equals(element)) {
            iter.previous();
            iter.add(gap);
            return;
        }
        throw new IllegalArgumentException(""the "" + element.toString() + "" in the "" + toString() + "" not found"");
    }

    /**
     * Finds the specified element in the list of
     * this sequential group's children and inserts
     * the specified preferred gap into that list after that element.
     */
    public void addPreferredGapAfter(PreferredGapAgent gap, Agent element) {
        if (childrenAgents.isEmpty()) {
            childrenAgents.add(gap);
            return;
        }
        ListIterator<Agent> iter = childrenAgents.listIterator();
        while (iter.hasNext()) if (iter.next().equals(element)) {
            iter.add(gap);
            return;
        }
        throw new IllegalArgumentException(""the "" + element.toString() + "" in the "" + toString() + "" not found"");
    }

    public String toString() {
        return ""sequential group <"" + getFirstName() + "","" + getLastName() + "">"";
    }
}
","// SequentialGroupAgentTest.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialGroupAgent}.
* It contains ten unit test cases for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class SequentialGroupAgentTest {","// SequentialGroupAgentTest.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialGroupAgent}.
* It contains ten unit test cases for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class SequentialGroupAgentTest {

	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has no children.
	 */
	@Test
	void testGroupContent_NoChildren() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(0, result.getComponents().length);
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has one child.
	 */
	@Test
	void testGroupContent_OneChild() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		group.addComponent(new ComponentAgent(""component""));
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(1, result.getComponents().length);
		assertEquals(""component"", result.getComponents()[0].getName());
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has two children.
	 */
	@Test
	void testGroupContent_TwoChildren() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		group.addComponent(new ComponentAgent(""component1""));
		group.addComponent(new ComponentAgent(""component2""));
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(2, result.getComponents().length);
		assertEquals(""component1"", result.getComponents()[0].getName());
		assertEquals(""component2"", result.getComponents()[1].getName());
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has three children.
	 */
	@Test
	void testGroupContent_ThreeChildren() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		group.addComponent(new ComponentAgent(""component1""));
		group.addComponent(new ComponentAgent(""component2""));
		group.addComponent(new ComponentAgent(""component3""));
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(3, result.getComponents().length);
		assertEquals(""component1"", result.getComponents()[0].getName());
		assertEquals(""component2"", result.getComponents()[1].getName());
		assertEquals(""component3"", result.getComponents()[2].getName());
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has one child and one preferred gap.
	 */
	@Test
	void testGroupContent_OneChildAndOnePreferredGap() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		group.addComponent(new ComponentAgent(""component""));
		group.addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE), group.getComponent(""component""));
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(2, result.getComponents().length);
		assertEquals(""component"", result.getComponents()[0].getName());
		assertEquals(""preferred gap"", result.getComponents()[1].getName());
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has two children and one preferred gap.
	 */
	@Test
	void testGroupContent_TwoChildrenAndOnePreferredGap() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		group.addComponent(new ComponentAgent(""component1""));
		group.addComponent(new ComponentAgent(""component2""));
		group.addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE), group.getComponent(""component1""));
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(3, result.getComponents().length);
		assertEquals(""component1"", result.getComponents()[0].getName());
		assertEquals(""preferred gap"", result.getComponents()[1].getName());
		assertEquals(""component2"", result.getComponents()[2].getName());
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has three children and one preferred gap.
	 */
	@Test
	void testGroupContent_ThreeChildrenAndOnePreferredGap() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		group.addComponent(new ComponentAgent(""component1""));
		group.addComponent(new ComponentAgent(""component2""));
		group.addComponent(new ComponentAgent(""component3""));
		group.addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE), group.getComponent(""component1""));
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(4, result.getComponents().length);
		assertEquals(""component1"", result.getComponents()[0].getName());
		assertEquals(""preferred gap"", result.getComponents()[1].getName());
		assertEquals(""component2"", result.getComponents()[2].getName());
		assertEquals(""component3"", result.getComponents()[3].getName());
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has one child and two preferred gaps.
	 */
	@Test
	void testGroupContent_OneChildAndTwoPreferredGaps() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		group.addComponent(new ComponentAgent(""component""));
		group.addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE), group.getComponent(""component""));
		group.addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE), group.getComponent(""component""));
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(3, result.getComponents().length);
		assertEquals(""component"", result.getComponents()[0].getName());
		assertEquals(""preferred gap"", result.getComponents()[1].getName());
		assertEquals(""preferred gap"", result.getComponents()[2].getName());
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has two children and two preferred gaps.
	 */
	@Test
	void testGroupContent_TwoChildrenAndTwoPreferredGaps() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		group.addComponent(new ComponentAgent"
cmpl-6wWf5inFH9lY6sQltf8t8KH7vyERG,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/agents/TopSequentialGroupAgent.java,58.57715559005737,length,"// TopSequentialGroupAgent.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;

/**
 * �����, �������������� ���������������� ������ �������� ������.
 * <p>
 * ��������� ��������� {@code FunctionsOnTopSequentialGroup}
 * ���������� �������������� ������������ �����������
 * � ������ � � ����� ���������������� ������ �������� ������.
 */
public class TopSequentialGroupAgent extends SequentialGroupAgent {

    /**
     * �����, �������������� ������������ ���������� � ������ ������.
     */
    private ContainerGapAgent precedingContainerGap;

    /**
     * �����, �������������� ������������ ���������� � ����� ������.
     */
    private ContainerGapAgent followingContainerGap;

    /**
     * ���������� �������������� ���������� � ����� ���������������� ������,
     * ��������, ���� ����, ������������ ���������� � ������ � � �����,
     * � ���������� ���������� ������.
     * <p>
     * ����������� ����� {@code TopSequentialGroupAgent.groupContent()},
     * �������� ������ � ������������� ������������.
     *
     * @param creatorAndAdder	��������� ��� �������� �����
     * 							� ���������� � ��� �����������
     * @return					������, ������������ �� ���������������
     * 							�����������.
     */
    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
        SequentialGroup result = creatorAndAdder.createSequentialGroup();
        if (precedingContainerGap != null)
            precedingContainerGap.addOneselfToGroup(result);
        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);
        if (followingContainerGap != null)
            followingContainerGap.addOneselfToGroup(result);
        return result;
    }

    public FunctionsOnGroup getFunctionsOnGroupImplemenation() {
        return getFunctionsOnTopSequentialGroupImplemenation();
    }

    public FunctionsOnSequentialGroup getFunctionsOnSequentialGroupImplemenation() {
        return getFunctionsOnTopSequentialGroupImplemenation();
    }

    public FunctionsOnTopSequentialGroup getFunctionsOnTopSequentialGroupImplemenation() {
        return new FunctionsOnTopSequentialGroupImplemenation();
    }

    private class FunctionsOnTopSequentialGroupImplemenation extends SequentialGroupAgent.FunctionsOnSequentialGroupImplemenation implements FunctionsOnTopSequentialGroup {

        /**
         * ��������� ������������ ����������
         * � ������ ���������������� ������ �������� ������.
         */
        public void addPrecedingContainerGap() {
            precedingContainerGap = new ContainerGapAgent();
        }

        /**
         * ��������� ������������ ���������� � ���������� ����������� �������
         * � ������ ���������������� ������ �������� ������.
         */
        public void addPrecedingContainerGap(int pref, int max) {
            precedingContainerGap = new ContainerGapAgent(pref, max);
        }

        /**
         * ��������� ������������ ����������
         * � ����� ���������������� ������ �������� ������.
         */
        public void addFollowingContainerGap() {
            followingContainerGap = new ContainerGapAgent();
        }

        /**
         * ��������� ������������ ���������� � ���������� ����������� �������
         * � ����� ���������������� ������ �������� ������.
         */
        public void addFollowingContainerGap(int pref, int max) {
            followingContainerGap = new ContainerGapAgent(pref, max);
        }

        public void addBothContainerGaps() {
            addPrecedingContainerGap();
            addFollowingContainerGap();
        }

        public void addBothContainerGaps(int pref, int max) {
            addPrecedingContainerGap(pref, max);
            addFollowingContainerGap(pref, max);
        }
    }
}
","// TopSequentialGroupAgentTest.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TopSequentialGroupAgent}.
* It contains ten unit test cases for the {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class TopSequentialGroupAgentTest {","// TopSequentialGroupAgentTest.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TopSequentialGroupAgent}.
* It contains ten unit test cases for the {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class TopSequentialGroupAgentTest {

	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * The test case checks that the method returns a {@link SequentialGroup} object,
	 * which contains the same elements as the {@link TopSequentialGroupAgent} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains two {@link ComponentAgent} objects,
	 * which are added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link SequentialGroup} object is created by the {@link GroupCreatorAndElementAdder} object.
	 * <p>
	 * The {@link GroupCreatorAndElementAdder} object is created by the {@link GroupCreatorAndElementAdderTest#createGroupCreatorAndElementAdder()} method.
	 */
	@Test
	void testGroupContent_TwoComponents() {
		TopSequentialGroupAgent topSequentialGroupAgent = new TopSequentialGroupAgent();
		topSequentialGroupAgent.addComponent(new ComponentAgent());
		topSequentialGroupAgent.addComponent(new ComponentAgent());
		GroupCreatorAndElementAdder creatorAndAdder = GroupCreatorAndElementAdderTest.createGroupCreatorAndElementAdder();
		SequentialGroup sequentialGroup = topSequentialGroupAgent.groupContent(creatorAndAdder);
		assertEquals(2, sequentialGroup.getComponents().length);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * The test case checks that the method returns a {@link SequentialGroup} object,
	 * which contains the same elements as the {@link TopSequentialGroupAgent} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains two {@link ComponentAgent} objects,
	 * which are added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains a preceding container gap,
	 * which is added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link SequentialGroup} object is created by the {@link GroupCreatorAndElementAdder} object.
	 * <p>
	 * The {@link GroupCreatorAndElementAdder} object is created by the {@link GroupCreatorAndElementAdderTest#createGroupCreatorAndElementAdder()} method.
	 */
	@Test
	void testGroupContent_TwoComponents_PrecedingContainerGap() {
		TopSequentialGroupAgent topSequentialGroupAgent = new TopSequentialGroupAgent();
		topSequentialGroupAgent.addComponent(new ComponentAgent());
		topSequentialGroupAgent.addComponent(new ComponentAgent());
		topSequentialGroupAgent.getFunctionsOnTopSequentialGroupImplemenation().addPrecedingContainerGap();
		GroupCreatorAndElementAdder creatorAndAdder = GroupCreatorAndElementAdderTest.createGroupCreatorAndElementAdder();
		SequentialGroup sequentialGroup = topSequentialGroupAgent.groupContent(creatorAndAdder);
		assertEquals(3, sequentialGroup.getComponents().length);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * The test case checks that the method returns a {@link SequentialGroup} object,
	 * which contains the same elements as the {@link TopSequentialGroupAgent} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains two {@link ComponentAgent} objects,
	 * which are added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains a following container gap,
	 * which is added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link SequentialGroup} object is created by the {@link GroupCreatorAndElementAdder} object.
	 * <p>
	 * The {@link GroupCreatorAndElementAdder} object is created by the {@link GroupCreatorAndElementAdderTest#createGroupCreatorAndElementAdder()} method.
	 */
	@Test
	void testGroupContent_TwoComponents_FollowingContainerGap() {
		TopSequentialGroupAgent topSequentialGroupAgent = new TopSequentialGroupAgent();
		topSequentialGroupAgent.addComponent(new ComponentAgent());
		topSequentialGroupAgent.addComponent(new ComponentAgent());
		topSequentialGroupAgent.getFunctionsOnTopSequentialGroupImplemenation().addFollowingContainerGap();
		GroupCreatorAndElementAdder creatorAndAdder = GroupCreatorAndElementAdderTest.createGroupCreatorAndElementAdder();
		SequentialGroup sequentialGroup = topSequentialGroupAgent.groupContent(creatorAndAdder);
		assertEquals(3, sequentialGroup.getComponents().length);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * The test case checks that the method returns a {@link SequentialGroup} object,
	 * which contains the same elements as the {@link TopSequentialGroupAgent} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains two {@link ComponentAgent} objects,
	 * which are added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains a preceding container gap,
	 * which is added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains a following container gap,
	 * which is added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link SequentialGroup} object is created by the {@link GroupCreatorAndElementAdder} object.
	 * <p>
	 * The {@link GroupCreatorAndElementAdder} object is created by the {@link GroupCreatorAndElementAdderTest#createGroupCreatorAndElementAdder()} method.
	 */
	@Test
	void testGroupContent_TwoComponents_BothContainerGaps() {
		TopSequentialGroupAgent topSequentialGroupAgent = new TopSequentialGroupAgent();
		topSequentialGroupAgent.addComponent(new ComponentAgent());
		topSequentialGroupAgent.addComponent(new ComponentAgent());
		topSequentialGroupAgent.getFunctionsOnTopSequentialGroupImplemenation().addBothContainerGaps();
		GroupCreatorAndElementAdder creatorAndAdder = GroupCreatorAndElementAdderTest.createGroupCreatorAndElementAdder();
		SequentialGroup sequentialGroup = topSequentialGroupAgent.groupContent(creatorAndAdder);
		assertEquals(4, sequentialGroup.getComponents().length);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * The test case checks that the method returns a {@link SequentialGroup} object,
	 * which contains the same elements as the {@link TopSequentialGroupAgent} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains two {@link ComponentAgent} objects,
	 * which are added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains a preceding container gap,
	 * which is added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains a following container gap,
	 * which is added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains a {@link ParallelGroupAgent} object,
	 * which contains two {@link ComponentAgent} objects,
	 * which are added to the {@link SequentialGroup} object.
	 *"
cmpl-6wWg80RQO945HJvAz4ZgBug7Zpbm9,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlock_2Test.java,62.14743423461914,length,"// HorizontalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for horizontal layouting.
 */
public class HorizontalBlock extends Block {

    public HorizontalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {
        super(scheme, x1, y1, x2, y2);
    }

    public HorizontalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {
        super(scheme, p1, p2);
    }

    public HorizontalBlock(Scheme scheme) {
        super(scheme);
    }

    public HorizontalBlock(Block b) {
        super(b.scheme, b.getPos1(), b.getPos2());
    }

    public HorizontalBlock(Block block, int x1, int y1, int x2, int y2) {
        super(block.scheme, x1, y1, x2, y2);
    }

    public Block subblock(int x1, int y1, int x2, int y2) {
        return new HorizontalBlock(scheme, x1, y1, x2, y2);
    }

    public HorizontalBlock cloneWith(CharPosition1 p1) {
        return new HorizontalBlock(scheme, p1, getPos2());
    }

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return	a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        List<Block> result = new LinkedList<Block>();
        Block firstBlock;
        HorizontalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstSequentialSubblock();
            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }

    /**
     * Extracts the left subblock of this block.
     * <p>
     * The required block is chosen so that its last exclusive vertical line
     * does not contain elements of components, gaps , or horizontal lines
     * starting on the left from the line.
     * <p>
     * The algorithm just finds the most left entity
     * (an element of a component, gap, or horizontal line)
     * using simple search along the scheme,
     * identifies the horizontal element containing the entity found,
     * checks whether the last exclusive vertical line of the element
     * matches the requirement for the boundary of the required block,
     * and, if does not, takes the detaining horizontal element
     * and continues the cycle.
     */
    private Block extractFirstSequentialSubblock() {
        final HWordPosition firstWord = scheme.anyHElementAt(firstEntity());
        HWordPosition lastWord = firstWord;
        HWordPosition nextWord = firstWord;
        for (; nextWord != null; ) {
            lastWord = nextWord;
            nextWord = findAWordExtendingSubblockToTheRightFrom(nextWord);
        }
        int startX = firstWord.x1;
        int endX = lastWord.x2;
        //For the case of words containing cells outside of this block:
        startX = Math.max(startX, x1);
        endX = Math.min(endX, x2);
        return subblock(startX, y1, endX, y2);
    }

    /**
     * Searches down and to the right from the beginning of this block
     * for the first occurrence of an entity.
     * @return	the position of the entity found.
     * @throws	IllegalArgumentException if this block
     * 			does not contain entities.
     */
    private CharPosition firstEntity() {
        int y = firstEntityBelow(x1, y1);
        if (y != y2)
            return new CharPosition(x1, y);
        int x = x1 + 1;
        for (; x < x2; x++) {
            y = firstEntityBelow(x, y1);
            if (y != y2)
                break;
        }
        if (x != x2)
            return new CharPosition(x, y);
        else
            throw new IllegalArgumentException(""Can not extract a group from an empty block:\n"" + this);
    }

    /**
     * Finds the first entity below the specified position.
     * @return	the y-coordinate of the entity found or y2 if not found.
     */
    private int firstEntityBelow(int x, int y) {
        for (; y < y2; y++) if (entityAt(x, y))
            break;
        return y;
    }

    /**
     * Verifies whether the character under the cell
     * determined by the specified coordinates
     * is a word character or a horizontal line character.
     */
    private boolean entityAt(int x, int y) {
        char c = charAt(x, y);
        /* 
		 * Since all symbols on the scheme are correct
		 * (which has been verified in its constructor),
		 * there is no need to use the slower method isWordChar().
		 */
        return c != ' ' && c != '|';
    }

    /**
     * Returns a word which starts not righter than the right end of the
     * {@code currentWord} but ends strictly righter
     * (or null if does not exist).
     */
    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord) {
        int x = currentWord.x2 - 1;
        int y = y1;
        int yToSkip = currentWord.y;
        HWordPosition result;
        for (; y < y2; y++) {
            if (y == yToSkip || !entityAt(x, y))
                continue;
            result = scheme.anyHElementAt(x, y);
            if (result == null)
                continue;
            if (result.x2 > currentWord.x2)
                return result;
        }
        return null;
    }

    /**
     * Divides the current block into a set of parallel subblocks,
     * optimizes these subblocks and returns them as a linked list.
     * <p>
     * If the block has horizontal lines,
     * this method divides the block by the maximal horizontal lines only.
     * <p>
     * If there are no horizontal lines, the block is divided into
     * usual parallel subblocks.
     */
    public List<Block> extractParallelSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        Set<HWordPosition> hLines = getIntersectingHLines();
        if (hLines.size() > 0)
            return extractParallelSubblocksSeparatedByLines(hLines);
        else
            return extractParallelSubblocksWithoutLines();
    }

    /**
     * Returns the set of all horizontal lines intersecting this block.
     */
    private Set<HWordPosition> getIntersectingHLines() {
        Set<HWordPosition> source = scheme.getHLinesPositions();
        Set<HWordPosition> result = new HashSet<HWordPosition>();
        for (HWordPosition line : source) if (line.intersects(this))
            result.add(line);
        return result;
    }

    /**
     * Divides the current block into a set of parallel subblocks
     * by its most long horizontal lines,
     * optimizes these subblocks, and returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksSeparatedByLines(Set<HWordPosition> hLines) {
        removeSmallHLinesFrom(hLines);
        List<Integer> separators = sortedYsOf(hLines);
        return extractParallelSubblocksSeparatedBy(separators);
    }

    /**
     * Finds the longest lines in the specified set of horizontal lines
     * and then removes from it all other elements.
     * <p>
     * Note that, more formally, this method considers the lengths
     * of <i>intersections</i> of the lines with this block.
     */
    private void removeSmallHLinesFrom(Set<HWordPosition> hLines) {
        //determine the maximum length:
        int maxLength = 0;
        int length;
        for (HWordPosition line : hLines) {
            length = line.getLengthInsideOf(this);
            maxLength = Math.max(length, maxLength);
        }
        //remove the short lines:
        HWordPosition line;
        Iterator<HWordPosition> i = hLines.iterator();
        for (; i.hasNext(); ) {
            line = i.next();
            if (line.getLengthInsideOf(this) < maxLength)
                i.remove();
        }
    }

    /**
     * Returns a list of the specified horizontal lines' vertical coordinates.
     */
    private List<Integer> sortedYsOf(Set<HWordPosition> hLines) {
        LinkedList<Integer> linesY = new LinkedList<Integer>();
        for (HWordPosition line : hLines) linesY.add(new Integer(line.y));
        Collections.sort(linesY);
        return linesY;
    }

    private List<Block> extractParallelSubblocksSeparatedBy(List<Integer> ySeparators) {
        List<Block> blocksList = new LinkedList<Block>();
        Block subBlock;
        //upper bound of a subblock
        int upperY = y1;
        for (int lowerY : ySeparators) {
            if (lowerY > upperY) {
                //there is a (non-trivial?) block between two lines.
                subBlock = new HorizontalBlock(this, x1, upperY, x2, lowerY);
                subBlock.optimize();
                if (!subBlock.isTrivial())
                    blocksList.add(subBlock);
            }
            upperY = lowerY + 1;
        }
        //below the last line:
        if (upperY < y2) {
            subBlock = new HorizontalBlock(this, x1, upperY, x2, y2);
            subBlock.optimize();
            if (!subBlock.isTrivial())
                blocksList.add(subBlock);
        }
        return blocksList;
    }

    /**
     * Divides the current block without horizontal lines
     * into a set of parallel subblocks, optimizes these subblocks
     * and returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksWithoutLines() {
        List<Block> result = new LinkedList<Block>();
        Block block;
        for (int y = y1; y < y2; y++) {
            block = subblock(x1, y, x2, y + 1);
            block.optimize();
            if (!block.isTrivial())
                result.add(block);
        }
        return result;
    }
}
","// HorizontalBlock_2Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractSequentialSubblocks()} method.
*/
class HorizontalBlock_2Test {","// HorizontalBlock_2Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractSequentialSubblocks()} method.
*/
class HorizontalBlock_2Test {

	/**
	 * Tests the {@link HorizontalBlock#extractSequentialSubblocks()} method
	 * on a block containing a single word.
	 */
	@Test
	void testExtractSequentialSubblocks_1() {
		Scheme scheme = new Scheme(""a"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 1, 1);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(block, result.get(0));
	}
	
	/**
	 * Tests the {@link HorizontalBlock#extractSequentialSubblocks()} method
	 * on a block containing two words.
	 */
	@Test
	void testExtractSequentialSubblocks_2() {
		Scheme scheme = new Scheme(""ab"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 2, 1);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 1, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 1, 0, 2, 1), result.get(1));
	}
	
	/**
	 * Tests the {@link HorizontalBlock#extractSequentialSubblocks()} method
	 * on a block containing three words.
	 */
	@Test
	void testExtractSequentialSubblocks_3() {
		Scheme scheme = new Scheme(""abc"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 3, 1);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 1, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 1, 0, 2, 1), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 2, 0, 3, 1), result.get(2));
	}
	
	/**
	 * Tests the {@link HorizontalBlock#extractSequentialSubblocks()} method
	 * on a block containing a single word and a single gap.
	 */
	@Test
	void testExtractSequentialSubblocks_4() {
		Scheme scheme = new Scheme(""a b"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 3, 1);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 1, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 2, 0, 3, 1), result.get(1));
	}
	
	/**
	 * Tests the {@link HorizontalBlock#extractSequentialSubblocks()} method
	 * on a block containing a single word and a single horizontal line.
	 */
	@Test
	void testExtractSequentialSubblocks_5() {
		Scheme scheme = new Scheme(""a-"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 2, 1);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 1, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 1, 0, 2, 1), result.get(1));
	}
	
	/**
	 * Tests the {@link HorizontalBlock#extractSequentialSubblocks()} method
	 * on a block containing a single word and a single vertical line.
	 */
	@Test
	void testExtractSequentialSubblocks_6() {
		Scheme scheme = new Scheme(""a|"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 2, 1);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(block, result.get(0));
	}
	
	/**
	 * Tests the {@link HorizontalBlock#extractSequentialSubblocks()} method
	 * on a block containing a single word and a single vertical line.
	 */
	@Test
	void testExtractSequentialSubblocks_7() {
		Scheme scheme = new Scheme(""a|b"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 3, 1);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 1, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 2, 0, 3, 1), result.get(1));
	}
	
	/**
	 * Tests the {@link HorizontalBlock#extractSequentialSubblocks()} method
	 * on a block containing a single word and a single vertical line.
	 */
	@Test
	void testExtractSequentialSubblocks_8() {
		Scheme scheme = new Scheme(""a|b|c"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 4, 1);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 1, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 2, 0, 3, 1), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 4, 0, 5, 1), result.get(2));
	}
	
	/**
	 * Tests the {@link HorizontalBlock#extractSequentialSubblocks()} method
	 * on a block containing a single word and a single vertical line.
	 */
	@Test
	void testExtractSequentialSubblocks_9() {
		Scheme scheme = new Scheme(""a|b|c|d"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 5, 1);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(4, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 1, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 2, 0, 3, 1), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 4, 0, 5, 1), result.get(2));
		assertEquals(new HorizontalBlock(scheme, 6, 0, 7, 1), result.get(3));
	}
	
	/**
	 * Tests the {@link HorizontalBlock#extractSequentialSubblocks()} method
	 * on a block containing a single word and a single vertical line.
	 */
	@Test
	void testExtractSequentialSubblocks_10() {
		Scheme scheme = new Scheme(""a|b|c|d|e"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 6, 1);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(5, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 1, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 2, 0, 3, 1), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 4, 0, 5, 1), result.get(2));
		assertEquals(new HorizontalBlock(scheme, 6, 0, 7, 1), result.get(3));
	"
cmpl-6wWh8Lzj77LbNmDR0r8BIOCU9EbOE,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlock_3Test.java,56.21221375465393,length,"// HorizontalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for horizontal layouting.
 */
public class HorizontalBlock extends Block {

    public HorizontalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {
        super(scheme, x1, y1, x2, y2);
    }

    public HorizontalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {
        super(scheme, p1, p2);
    }

    public HorizontalBlock(Scheme scheme) {
        super(scheme);
    }

    public HorizontalBlock(Block b) {
        super(b.scheme, b.getPos1(), b.getPos2());
    }

    public HorizontalBlock(Block block, int x1, int y1, int x2, int y2) {
        super(block.scheme, x1, y1, x2, y2);
    }

    public Block subblock(int x1, int y1, int x2, int y2) {
        return new HorizontalBlock(scheme, x1, y1, x2, y2);
    }

    public HorizontalBlock cloneWith(CharPosition1 p1) {
        return new HorizontalBlock(scheme, p1, getPos2());
    }

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return	a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        List<Block> result = new LinkedList<Block>();
        Block firstBlock;
        HorizontalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstSequentialSubblock();
            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }

    /**
     * Extracts the left subblock of this block.
     * <p>
     * The required block is chosen so that its last exclusive vertical line
     * does not contain elements of components, gaps , or horizontal lines
     * starting on the left from the line.
     * <p>
     * The algorithm just finds the most left entity
     * (an element of a component, gap, or horizontal line)
     * using simple search along the scheme,
     * identifies the horizontal element containing the entity found,
     * checks whether the last exclusive vertical line of the element
     * matches the requirement for the boundary of the required block,
     * and, if does not, takes the detaining horizontal element
     * and continues the cycle.
     */
    private Block extractFirstSequentialSubblock() {
        final HWordPosition firstWord = scheme.anyHElementAt(firstEntity());
        HWordPosition lastWord = firstWord;
        HWordPosition nextWord = firstWord;
        for (; nextWord != null; ) {
            lastWord = nextWord;
            nextWord = findAWordExtendingSubblockToTheRightFrom(nextWord);
        }
        int startX = firstWord.x1;
        int endX = lastWord.x2;
        //For the case of words containing cells outside of this block:
        startX = Math.max(startX, x1);
        endX = Math.min(endX, x2);
        return subblock(startX, y1, endX, y2);
    }

    /**
     * Searches down and to the right from the beginning of this block
     * for the first occurrence of an entity.
     * @return	the position of the entity found.
     * @throws	IllegalArgumentException if this block
     * 			does not contain entities.
     */
    private CharPosition firstEntity() {
        int y = firstEntityBelow(x1, y1);
        if (y != y2)
            return new CharPosition(x1, y);
        int x = x1 + 1;
        for (; x < x2; x++) {
            y = firstEntityBelow(x, y1);
            if (y != y2)
                break;
        }
        if (x != x2)
            return new CharPosition(x, y);
        else
            throw new IllegalArgumentException(""Can not extract a group from an empty block:\n"" + this);
    }

    /**
     * Finds the first entity below the specified position.
     * @return	the y-coordinate of the entity found or y2 if not found.
     */
    private int firstEntityBelow(int x, int y) {
        for (; y < y2; y++) if (entityAt(x, y))
            break;
        return y;
    }

    /**
     * Verifies whether the character under the cell
     * determined by the specified coordinates
     * is a word character or a horizontal line character.
     */
    private boolean entityAt(int x, int y) {
        char c = charAt(x, y);
        /* 
		 * Since all symbols on the scheme are correct
		 * (which has been verified in its constructor),
		 * there is no need to use the slower method isWordChar().
		 */
        return c != ' ' && c != '|';
    }

    /**
     * Returns a word which starts not righter than the right end of the
     * {@code currentWord} but ends strictly righter
     * (or null if does not exist).
     */
    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord) {
        int x = currentWord.x2 - 1;
        int y = y1;
        int yToSkip = currentWord.y;
        HWordPosition result;
        for (; y < y2; y++) {
            if (y == yToSkip || !entityAt(x, y))
                continue;
            result = scheme.anyHElementAt(x, y);
            if (result == null)
                continue;
            if (result.x2 > currentWord.x2)
                return result;
        }
        return null;
    }

    /**
     * Divides the current block into a set of parallel subblocks,
     * optimizes these subblocks and returns them as a linked list.
     * <p>
     * If the block has horizontal lines,
     * this method divides the block by the maximal horizontal lines only.
     * <p>
     * If there are no horizontal lines, the block is divided into
     * usual parallel subblocks.
     */
    public List<Block> extractParallelSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        Set<HWordPosition> hLines = getIntersectingHLines();
        if (hLines.size() > 0)
            return extractParallelSubblocksSeparatedByLines(hLines);
        else
            return extractParallelSubblocksWithoutLines();
    }

    /**
     * Returns the set of all horizontal lines intersecting this block.
     */
    private Set<HWordPosition> getIntersectingHLines() {
        Set<HWordPosition> source = scheme.getHLinesPositions();
        Set<HWordPosition> result = new HashSet<HWordPosition>();
        for (HWordPosition line : source) if (line.intersects(this))
            result.add(line);
        return result;
    }

    /**
     * Divides the current block into a set of parallel subblocks
     * by its most long horizontal lines,
     * optimizes these subblocks, and returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksSeparatedByLines(Set<HWordPosition> hLines) {
        removeSmallHLinesFrom(hLines);
        List<Integer> separators = sortedYsOf(hLines);
        return extractParallelSubblocksSeparatedBy(separators);
    }

    /**
     * Finds the longest lines in the specified set of horizontal lines
     * and then removes from it all other elements.
     * <p>
     * Note that, more formally, this method considers the lengths
     * of <i>intersections</i> of the lines with this block.
     */
    private void removeSmallHLinesFrom(Set<HWordPosition> hLines) {
        //determine the maximum length:
        int maxLength = 0;
        int length;
        for (HWordPosition line : hLines) {
            length = line.getLengthInsideOf(this);
            maxLength = Math.max(length, maxLength);
        }
        //remove the short lines:
        HWordPosition line;
        Iterator<HWordPosition> i = hLines.iterator();
        for (; i.hasNext(); ) {
            line = i.next();
            if (line.getLengthInsideOf(this) < maxLength)
                i.remove();
        }
    }

    /**
     * Returns a list of the specified horizontal lines' vertical coordinates.
     */
    private List<Integer> sortedYsOf(Set<HWordPosition> hLines) {
        LinkedList<Integer> linesY = new LinkedList<Integer>();
        for (HWordPosition line : hLines) linesY.add(new Integer(line.y));
        Collections.sort(linesY);
        return linesY;
    }

    private List<Block> extractParallelSubblocksSeparatedBy(List<Integer> ySeparators) {
        List<Block> blocksList = new LinkedList<Block>();
        Block subBlock;
        //upper bound of a subblock
        int upperY = y1;
        for (int lowerY : ySeparators) {
            if (lowerY > upperY) {
                //there is a (non-trivial?) block between two lines.
                subBlock = new HorizontalBlock(this, x1, upperY, x2, lowerY);
                subBlock.optimize();
                if (!subBlock.isTrivial())
                    blocksList.add(subBlock);
            }
            upperY = lowerY + 1;
        }
        //below the last line:
        if (upperY < y2) {
            subBlock = new HorizontalBlock(this, x1, upperY, x2, y2);
            subBlock.optimize();
            if (!subBlock.isTrivial())
                blocksList.add(subBlock);
        }
        return blocksList;
    }

    /**
     * Divides the current block without horizontal lines
     * into a set of parallel subblocks, optimizes these subblocks
     * and returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksWithoutLines() {
        List<Block> result = new LinkedList<Block>();
        Block block;
        for (int y = y1; y < y2; y++) {
            block = subblock(x1, y, x2, y + 1);
            block.optimize();
            if (!block.isTrivial())
                result.add(block);
        }
        return result;
    }
}
","// HorizontalBlock_3Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractParallelSubblocks()} method.
*/
class HorizontalBlock_3Test {","// HorizontalBlock_3Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractParallelSubblocks()} method.
*/
class HorizontalBlock_3Test {

	/**
	 * Test case 1.
	 * <p>
	 * The block contains a single horizontal line.
	 * <p>
	 * The block is divided into two subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_1() {
		Scheme scheme = new Scheme(""|---|"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 5, 1);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(2, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 3, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 3, 0, 5, 1), result.get(1));
	}
	
	/**
	 * Test case 2.
	 * <p>
	 * The block contains two horizontal lines.
	 * <p>
	 * The block is divided into three subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_2() {
		Scheme scheme = new Scheme(""|---|\n|---|"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 5, 2);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 3, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 0, 1, 3, 2), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 3, 0, 5, 2), result.get(2));
	}
	
	/**
	 * Test case 3.
	 * <p>
	 * The block contains two horizontal lines.
	 * <p>
	 * The block is divided into three subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_3() {
		Scheme scheme = new Scheme(""|---|\n|---|\n|---|"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 5, 3);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 3, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 0, 1, 3, 3), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 3, 0, 5, 3), result.get(2));
	}
	
	/**
	 * Test case 4.
	 * <p>
	 * The block contains two horizontal lines.
	 * <p>
	 * The block is divided into three subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_4() {
		Scheme scheme = new Scheme(""|---|\n|---|\n|---|\n|---|"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 5, 4);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 3, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 0, 1, 3, 4), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 3, 0, 5, 4), result.get(2));
	}
	
	/**
	 * Test case 5.
	 * <p>
	 * The block contains two horizontal lines.
	 * <p>
	 * The block is divided into three subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_5() {
		Scheme scheme = new Scheme(""|---|\n|---|\n|---|\n|---|\n|---|"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 5, 5);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 3, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 0, 1, 3, 5), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 3, 0, 5, 5), result.get(2));
	}
	
	/**
	 * Test case 6.
	 * <p>
	 * The block contains two horizontal lines.
	 * <p>
	 * The block is divided into three subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_6() {
		Scheme scheme = new Scheme(""|---|\n|---|\n|---|\n|---|\n|---|\n|---|"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 5, 6);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 3, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 0, 1, 3, 6), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 3, 0, 5, 6), result.get(2));
	}
	
	/**
	 * Test case 7.
	 * <p>
	 * The block contains two horizontal lines.
	 * <p>
	 * The block is divided into three subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_7() {
		Scheme scheme = new Scheme(""|---|\n|---|\n|---|\n|---|\n|---|\n|---|\n|---|"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 5, 7);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 3, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 0, 1, 3, 7), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 3, 0, 5, 7), result.get(2));
	}
	
	/**
	 * Test case 8.
	 * <p>
	 * The block contains two horizontal lines.
	 * <p>
	 * The block is divided into three subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_8() {
		Scheme scheme = new Scheme(""|---|\n|---|\n|---|\n|---|\n|---|\n|---|\n|---|\n|---|"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 5, 8);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 3, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 0, 1, 3, 8), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 3, 0, 5, 8), result.get(2));
	}
	
	/**
	 * Test case 9.
	 * <p>
	 * The block contains two horizontal lines.
	 * <p>
	 * The block is divided into three subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_9() {
		Scheme scheme = new Scheme(""|---|\n"
cmpl-6wWiBjepF0vjxASq92rJ8KKroATms,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/blocks/VerticalBlock_2Test.java,69.5954110622406,length,"// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    public VerticalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {
        super(scheme, x1, y1, x2, y2);
    }

    public VerticalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {
        super(scheme, p1, p2);
    }

    public VerticalBlock(Scheme scheme) {
        super(scheme);
    }

    public VerticalBlock(Block b) {
        super(b.scheme, b.getPos1(), b.getPos2());
    }

    public VerticalBlock(Block block, int x1, int y1, int x2, int y2) {
        super(block.scheme, x1, y1, x2, y2);
    }

    public VerticalBlock subblock(int x1, int y1, int x2, int y2) {
        return new VerticalBlock(scheme, x1, y1, x2, y2);
    }

    public VerticalBlock cloneWith(CharPosition1 p1) {
        return new VerticalBlock(scheme, p1, getPos2());
    }

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return	a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        List<Block> result = new LinkedList<Block>();
        VerticalBlock firstBlock;
        VerticalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstSequentialSubblock();
            theRest = theRest.cloneWith(new CharPosition1(this.x1, firstBlock.y2));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }

    /**
     * Extracts the upper subblock of this block.
     * <p>
     * The required block is chosen so that its last exclusive horizontal line
     * does not contain elements of vertical lines
     * starting above the line.
     * <p>
     * The algorithm finds the upper entity
     * (an element of a component, gap, or vertical line)
     * using simple search along the scheme,
     * and retains it as the top of the required block.
     * Then, starting from the height of that point,
     * it sequentially finds vertical lines
     * end below but begin not below
     * and moves to lower end of such lines.
     * The lower end of the last such vertical line defines
     * the bottom of the required block.
     */
    private VerticalBlock extractFirstSequentialSubblock() {
        Set<VWordPosition> vLines = getIntersectingVLines();
        CharPosition blockStart = getBlockStart();
        int y2 = getUpperSubblockEnd(blockStart, vLines);
        return subblock(this.x1, blockStart.y, this.x2, y2);
    }

    /**
     * Returns the set of all vertical lines intersecting this block.
     */
    private Set<VWordPosition> getIntersectingVLines() {
        Set<VWordPosition> source = scheme.getVLinesPositions();
        Set<VWordPosition> result = new HashSet<VWordPosition>();
        for (VWordPosition line : source) if (line.intersects(this))
            result.add(line);
        return result;
    }

    /**
     * Finds the upper entity (an element of a word or vertical line)
     * of this block.
     * Returns its position on the scheme.
     * @throws	IllegalArgumentException if this block happens to be empty.
     */
    private CharPosition getBlockStart() {
        int x = x1;
        int y = y1;
        for (; y < y2; y++) for (x = x1; x < x2; x++) if (entityAt(x, y))
            return new CharPosition(x, y);
        throw new IllegalArgumentException(""Can not extract elements from an empty block:\n"" + this);
    }

    /**
     * Verifies whether the character under the cell
     * determined by the specified coordinates
     * is a word character or a vertical line character.
     */
    private boolean entityAt(int x, int y) {
        char c = charAt(x, y);
        /* 
		 * Since all symbols on the scheme are correct
		 * (which has been verified in its constructor),
		 * there is no need to use the slower method isWordChar().
		 */
        return c != ' ' && c != '-';
    }

    /**
     * Finds the last line of the subblock
     * containing the specified position {@code blockStart}.
     * Returns the coordinate {@code y2} of such block.
     */
    private int getUpperSubblockEnd(CharPosition blockStart, Set<VWordPosition> vLines) {
        int nextY = blockStart.y;
        int currentY;
        do {
            currentY = nextY;
            nextY = y2OfAVLineCovering(currentY, vLines);
        } while (nextY > currentY && nextY < y2 - 1);
        return Math.min(y2, nextY + 1);
    }

    /**
     * Finds a vertical line which vertical range covers
     * the specified value {@code y}
     * and which lower point is lower than {@code y}.
     * Returns the position of the last element of such line (inclusive)
     * or {@code y} if such line does not exist.
     */
    private int y2OfAVLineCovering(int y, Set<VWordPosition> vLines) {
        for (VWordPosition line : vLines) if (line.y1 <= y && y + 1 < line.y2)
            return line.y2 - 1;
        return y;
    }

    /**
     * Divides the current block into a set of parallel subblocks,
     * optimizes these subblocks and returns them as a linked list.
     * <p>
     * If the block has vertical lines,
     * this method divides the block by the maximal vertical lines only.
     * <p>
     * If there are no vertical lines, the block is divided into
     * usual parallel subblocks.
     */
    public List<Block> extractParallelSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        Set<VWordPosition> vLines = getIntersectingVLines();
        if (vLines.size() > 0)
            return extractParallelSubblocksSeparatedByLines(vLines);
        else
            return extractParallelSubblocksWithoutLines();
    }

    /**
     * Divides the current block into a set of parallel subblocks
     * by its most long vertical lines,
     * optimizes these subblocks, and returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksSeparatedByLines(Set<VWordPosition> vLines) {
        removeSmallVLinesFrom(vLines);
        return extractParallelSubblocksSeparatedBy(vLines);
    }

    /**
     * Finds the longest lines in the specified set of vertical lines
     * and then removes from it all other elements.
     * <p>
     * Note that, more formally, this method considers the lengths
     * of <i>intersections</i> of the lines with this block.
     */
    private void removeSmallVLinesFrom(Set<VWordPosition> vLines) {
        //determine the maximum length:
        int maxLength = 0;
        int length;
        for (VWordPosition line : vLines) {
            length = line.getLengthInsideOf(this);
            maxLength = Math.max(length, maxLength);
        }
        //remove the short lines:
        VWordPosition line;
        Iterator<VWordPosition> i = vLines.iterator();
        for (; i.hasNext(); ) {
            line = i.next();
            if (line.getLengthInsideOf(this) < maxLength)
                i.remove();
        }
    }

    private List<Block> extractParallelSubblocksSeparatedBy(Set<VWordPosition> separators) {
        List<Block> result = new LinkedList<Block>();
        Block subBlock;
        //the left bound of a subblock
        int leftX = x1;
        //the exclusive right bound of a subblock
        int rightX;
        //(may exist; widens the separator)
        HWordPosition gapAtSeparator = null;
        for (VWordPosition rightSeparator : sortedVLines(separators)) {
            rightX = rightSeparator.x;
            //if the separator has a gap, the latter must be skipped:
            gapAtSeparator = scheme.gapAtLine(rightSeparator);
            if (gapAtSeparator != null)
                rightX = gapAtSeparator.x1;
            //adding the subblock between leftX and rightX:
            if (rightX > leftX + 1) {
                subBlock = subblock(leftX, y1, rightX, y2);
                subBlock.optimize();
                if (!subBlock.isTrivial())
                    result.add(subBlock);
            }
            //iterating leftX:
            if (gapAtSeparator == null)
                leftX = rightX + 1;
            else
                leftX = gapAtSeparator.x2;
        }
        //on the right of the last line:
        if (leftX < x2) {
            subBlock = subblock(leftX, y1, x2, y2);
            subBlock.optimize();
            if (!subBlock.isTrivial())
                result.add(subBlock);
        }
        return result;
    }

    /*
	 * Returns a list of the specified vertical lines
	 * sorted according to the horizontal coordinates.
	 */
    private List<VWordPosition> sortedVLines(Set<VWordPosition> vLines) {
        LinkedList<VWordPosition> list = new LinkedList<VWordPosition>(vLines);
        Collections.sort(list);
        return list;
    }

    /**
     * Divides the current block without vertical lines
     * into a set of (optimized) parallel subblocks.
     * Returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksWithoutLines() {
        List<Block> result = new LinkedList<Block>();
        Block firstBlock;
        VerticalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstParallelSubblock();
            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }

    /**
     * Extracts the left subblock of this block.
     * <p>
     * The required block is chosen so that its last exclusive vertical line
     * does not contain elements of components or gaps
     * starting on the left from the line.
     * <p>
     * The algorithm just finds the most left entity
     * (an element of a component or gap)
     * using simple search along the scheme,
     * identifies the horizontal element containing the entity found,
     * checks whether the last exclusive vertical line of the element
     * matches the requirement for the boundary of the required block,
     * and, if does not, takes the detaining horizontal element
     * and continues the cycle.
     */
    private Block extractFirstParallelSubblock() {
        final HWordPosition firstWord = scheme.anyHElementAt(firstWordChar());
        HWordPosition lastWord = firstWord;
        HWordPosition nextWord = firstWord;
        for (; nextWord != null; ) {
            lastWord = nextWord;
            nextWord = findAWordExtendingSubblockToTheRightFrom(nextWord);
        }
        int startX = firstWord.x1;
        int endX = lastWord.x2;
        //For the case of words containing cells outside of this block:
        startX = Math.max(startX, x1);
        endX = Math.min(endX, x2);
        return subblock(startX, y1, endX, y2);
    }

    /**
     * Searches down and to the right from the beginning of this block
     * for the first occurrence of a word character.
     * @return	the position of the word character found.
     * @throws	IllegalArgumentException if this block
     * 			does not contain word characters.
     */
    private CharPosition firstWordChar() {
        int y = firstWordCharBelow(x1, y1);
        if (y != y2)
            return new CharPosition(x1, y);
        int x = x1 + 1;
        for (; x < x2; x++) {
            y = firstWordCharBelow(x, y1);
            if (y != y2)
                break;
        }
        if (x != x2)
            return new CharPosition(x, y);
        else
            throw new IllegalArgumentException(""Can not extract a group from an empty block:\n"" + this);
    }

    /**
     * Finds the first entity below the specified position.
     * @return	the y-coordinate of the entity found or y2 if not found.
     */
    private int firstWordCharBelow(int x, int y) {
        for (; y < y2; y++) if (wordCharAt(x, y))
            break;
        return y;
    }

    /**
     * Verifies whether the character under the cell
     * determined by the specified coordinates
     * is a word character.
     * <p>
     * Overrides the less optimal method {@code CharTable.wordCharAt()}.
     * Since all symbols on the scheme are definitely correct
     * (which has been verified in its constructor),
     * there is no need to use slower method.
     */
    public boolean wordCharAt(int x, int y) {
        char c = charAt(x, y);
        return c != ' ' && c != '-' && c != '|' && c != '+';
    }

    /**
     * Returns a word which starts not righter than the right end of the
     * {@code currentWord} but ends strictly righter
     * (or null if does not exist).
     */
    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord) {
        int x = currentWord.x2 - 1;
        int y = y1;
        int yToSkip = currentWord.y;
        HWordPosition result;
        for (; y < y2; y++) {
            if (y == yToSkip || !wordCharAt(x, y))
                continue;
            result = scheme.anyHElementAt(x, y);
            if (result == null)
                continue;
            if (result.x2 > currentWord.x2)
                return result;
        }
        return null;
    }
}
","// VerticalBlock_2Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.
*/
class VerticalBlock_2Test {","// VerticalBlock_2Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.
*/
class VerticalBlock_2Test {

	private Scheme scheme;
	private VerticalBlock block;
	private List<Block> result;
	
	@Test
	void test_1() {
		scheme = new Scheme(""""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
"
cmpl-6wWjJ9Q1HlVehHWUYRmAqmGeo4a7U,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/blocks/VerticalBlock_3Test.java,65.02069854736328,length,"// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    public VerticalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {
        super(scheme, x1, y1, x2, y2);
    }

    public VerticalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {
        super(scheme, p1, p2);
    }

    public VerticalBlock(Scheme scheme) {
        super(scheme);
    }

    public VerticalBlock(Block b) {
        super(b.scheme, b.getPos1(), b.getPos2());
    }

    public VerticalBlock(Block block, int x1, int y1, int x2, int y2) {
        super(block.scheme, x1, y1, x2, y2);
    }

    public VerticalBlock subblock(int x1, int y1, int x2, int y2) {
        return new VerticalBlock(scheme, x1, y1, x2, y2);
    }

    public VerticalBlock cloneWith(CharPosition1 p1) {
        return new VerticalBlock(scheme, p1, getPos2());
    }

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return	a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        List<Block> result = new LinkedList<Block>();
        VerticalBlock firstBlock;
        VerticalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstSequentialSubblock();
            theRest = theRest.cloneWith(new CharPosition1(this.x1, firstBlock.y2));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }

    /**
     * Extracts the upper subblock of this block.
     * <p>
     * The required block is chosen so that its last exclusive horizontal line
     * does not contain elements of vertical lines
     * starting above the line.
     * <p>
     * The algorithm finds the upper entity
     * (an element of a component, gap, or vertical line)
     * using simple search along the scheme,
     * and retains it as the top of the required block.
     * Then, starting from the height of that point,
     * it sequentially finds vertical lines
     * end below but begin not below
     * and moves to lower end of such lines.
     * The lower end of the last such vertical line defines
     * the bottom of the required block.
     */
    private VerticalBlock extractFirstSequentialSubblock() {
        Set<VWordPosition> vLines = getIntersectingVLines();
        CharPosition blockStart = getBlockStart();
        int y2 = getUpperSubblockEnd(blockStart, vLines);
        return subblock(this.x1, blockStart.y, this.x2, y2);
    }

    /**
     * Returns the set of all vertical lines intersecting this block.
     */
    private Set<VWordPosition> getIntersectingVLines() {
        Set<VWordPosition> source = scheme.getVLinesPositions();
        Set<VWordPosition> result = new HashSet<VWordPosition>();
        for (VWordPosition line : source) if (line.intersects(this))
            result.add(line);
        return result;
    }

    /**
     * Finds the upper entity (an element of a word or vertical line)
     * of this block.
     * Returns its position on the scheme.
     * @throws	IllegalArgumentException if this block happens to be empty.
     */
    private CharPosition getBlockStart() {
        int x = x1;
        int y = y1;
        for (; y < y2; y++) for (x = x1; x < x2; x++) if (entityAt(x, y))
            return new CharPosition(x, y);
        throw new IllegalArgumentException(""Can not extract elements from an empty block:\n"" + this);
    }

    /**
     * Verifies whether the character under the cell
     * determined by the specified coordinates
     * is a word character or a vertical line character.
     */
    private boolean entityAt(int x, int y) {
        char c = charAt(x, y);
        /* 
		 * Since all symbols on the scheme are correct
		 * (which has been verified in its constructor),
		 * there is no need to use the slower method isWordChar().
		 */
        return c != ' ' && c != '-';
    }

    /**
     * Finds the last line of the subblock
     * containing the specified position {@code blockStart}.
     * Returns the coordinate {@code y2} of such block.
     */
    private int getUpperSubblockEnd(CharPosition blockStart, Set<VWordPosition> vLines) {
        int nextY = blockStart.y;
        int currentY;
        do {
            currentY = nextY;
            nextY = y2OfAVLineCovering(currentY, vLines);
        } while (nextY > currentY && nextY < y2 - 1);
        return Math.min(y2, nextY + 1);
    }

    /**
     * Finds a vertical line which vertical range covers
     * the specified value {@code y}
     * and which lower point is lower than {@code y}.
     * Returns the position of the last element of such line (inclusive)
     * or {@code y} if such line does not exist.
     */
    private int y2OfAVLineCovering(int y, Set<VWordPosition> vLines) {
        for (VWordPosition line : vLines) if (line.y1 <= y && y + 1 < line.y2)
            return line.y2 - 1;
        return y;
    }

    /**
     * Divides the current block into a set of parallel subblocks,
     * optimizes these subblocks and returns them as a linked list.
     * <p>
     * If the block has vertical lines,
     * this method divides the block by the maximal vertical lines only.
     * <p>
     * If there are no vertical lines, the block is divided into
     * usual parallel subblocks.
     */
    public List<Block> extractParallelSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        Set<VWordPosition> vLines = getIntersectingVLines();
        if (vLines.size() > 0)
            return extractParallelSubblocksSeparatedByLines(vLines);
        else
            return extractParallelSubblocksWithoutLines();
    }

    /**
     * Divides the current block into a set of parallel subblocks
     * by its most long vertical lines,
     * optimizes these subblocks, and returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksSeparatedByLines(Set<VWordPosition> vLines) {
        removeSmallVLinesFrom(vLines);
        return extractParallelSubblocksSeparatedBy(vLines);
    }

    /**
     * Finds the longest lines in the specified set of vertical lines
     * and then removes from it all other elements.
     * <p>
     * Note that, more formally, this method considers the lengths
     * of <i>intersections</i> of the lines with this block.
     */
    private void removeSmallVLinesFrom(Set<VWordPosition> vLines) {
        //determine the maximum length:
        int maxLength = 0;
        int length;
        for (VWordPosition line : vLines) {
            length = line.getLengthInsideOf(this);
            maxLength = Math.max(length, maxLength);
        }
        //remove the short lines:
        VWordPosition line;
        Iterator<VWordPosition> i = vLines.iterator();
        for (; i.hasNext(); ) {
            line = i.next();
            if (line.getLengthInsideOf(this) < maxLength)
                i.remove();
        }
    }

    private List<Block> extractParallelSubblocksSeparatedBy(Set<VWordPosition> separators) {
        List<Block> result = new LinkedList<Block>();
        Block subBlock;
        //the left bound of a subblock
        int leftX = x1;
        //the exclusive right bound of a subblock
        int rightX;
        //(may exist; widens the separator)
        HWordPosition gapAtSeparator = null;
        for (VWordPosition rightSeparator : sortedVLines(separators)) {
            rightX = rightSeparator.x;
            //if the separator has a gap, the latter must be skipped:
            gapAtSeparator = scheme.gapAtLine(rightSeparator);
            if (gapAtSeparator != null)
                rightX = gapAtSeparator.x1;
            //adding the subblock between leftX and rightX:
            if (rightX > leftX + 1) {
                subBlock = subblock(leftX, y1, rightX, y2);
                subBlock.optimize();
                if (!subBlock.isTrivial())
                    result.add(subBlock);
            }
            //iterating leftX:
            if (gapAtSeparator == null)
                leftX = rightX + 1;
            else
                leftX = gapAtSeparator.x2;
        }
        //on the right of the last line:
        if (leftX < x2) {
            subBlock = subblock(leftX, y1, x2, y2);
            subBlock.optimize();
            if (!subBlock.isTrivial())
                result.add(subBlock);
        }
        return result;
    }

    /*
	 * Returns a list of the specified vertical lines
	 * sorted according to the horizontal coordinates.
	 */
    private List<VWordPosition> sortedVLines(Set<VWordPosition> vLines) {
        LinkedList<VWordPosition> list = new LinkedList<VWordPosition>(vLines);
        Collections.sort(list);
        return list;
    }

    /**
     * Divides the current block without vertical lines
     * into a set of (optimized) parallel subblocks.
     * Returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksWithoutLines() {
        List<Block> result = new LinkedList<Block>();
        Block firstBlock;
        VerticalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstParallelSubblock();
            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }

    /**
     * Extracts the left subblock of this block.
     * <p>
     * The required block is chosen so that its last exclusive vertical line
     * does not contain elements of components or gaps
     * starting on the left from the line.
     * <p>
     * The algorithm just finds the most left entity
     * (an element of a component or gap)
     * using simple search along the scheme,
     * identifies the horizontal element containing the entity found,
     * checks whether the last exclusive vertical line of the element
     * matches the requirement for the boundary of the required block,
     * and, if does not, takes the detaining horizontal element
     * and continues the cycle.
     */
    private Block extractFirstParallelSubblock() {
        final HWordPosition firstWord = scheme.anyHElementAt(firstWordChar());
        HWordPosition lastWord = firstWord;
        HWordPosition nextWord = firstWord;
        for (; nextWord != null; ) {
            lastWord = nextWord;
            nextWord = findAWordExtendingSubblockToTheRightFrom(nextWord);
        }
        int startX = firstWord.x1;
        int endX = lastWord.x2;
        //For the case of words containing cells outside of this block:
        startX = Math.max(startX, x1);
        endX = Math.min(endX, x2);
        return subblock(startX, y1, endX, y2);
    }

    /**
     * Searches down and to the right from the beginning of this block
     * for the first occurrence of a word character.
     * @return	the position of the word character found.
     * @throws	IllegalArgumentException if this block
     * 			does not contain word characters.
     */
    private CharPosition firstWordChar() {
        int y = firstWordCharBelow(x1, y1);
        if (y != y2)
            return new CharPosition(x1, y);
        int x = x1 + 1;
        for (; x < x2; x++) {
            y = firstWordCharBelow(x, y1);
            if (y != y2)
                break;
        }
        if (x != x2)
            return new CharPosition(x, y);
        else
            throw new IllegalArgumentException(""Can not extract a group from an empty block:\n"" + this);
    }

    /**
     * Finds the first entity below the specified position.
     * @return	the y-coordinate of the entity found or y2 if not found.
     */
    private int firstWordCharBelow(int x, int y) {
        for (; y < y2; y++) if (wordCharAt(x, y))
            break;
        return y;
    }

    /**
     * Verifies whether the character under the cell
     * determined by the specified coordinates
     * is a word character.
     * <p>
     * Overrides the less optimal method {@code CharTable.wordCharAt()}.
     * Since all symbols on the scheme are definitely correct
     * (which has been verified in its constructor),
     * there is no need to use slower method.
     */
    public boolean wordCharAt(int x, int y) {
        char c = charAt(x, y);
        return c != ' ' && c != '-' && c != '|' && c != '+';
    }

    /**
     * Returns a word which starts not righter than the right end of the
     * {@code currentWord} but ends strictly righter
     * (or null if does not exist).
     */
    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord) {
        int x = currentWord.x2 - 1;
        int y = y1;
        int yToSkip = currentWord.y;
        HWordPosition result;
        for (; y < y2; y++) {
            if (y == yToSkip || !wordCharAt(x, y))
                continue;
            result = scheme.anyHElementAt(x, y);
            if (result == null)
                continue;
            if (result.x2 > currentWord.x2)
                return result;
        }
        return null;
    }
}
","// VerticalBlock_3Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractParallelSubblocks()} method.
*/
class VerticalBlock_3Test {","// VerticalBlock_3Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractParallelSubblocks()} method.
*/
class VerticalBlock_3Test {

	private Scheme scheme;
	private VerticalBlock block;
	private List<Block> result;
	
	@Test
	void test_1() {
		scheme = new Scheme(""""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
"
cmpl-6wWkMqp8m68PtvrqzRqLC0y0WhGqj,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/positions/HWordPosition_5Test.java,14.205347776412964,stop,"// HWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying horizontally on the scheme.
 */
public class HWordPosition extends WordPosition {

    /**
     * The horizontal coordinate of the word start.
     */
    public final int x1;

    /**
     * The horizontal coordinate of the word end + 1.
     */
    public final int x2;

    /**
     * The vertical coordinate of the word.
     */
    public final int y;

    public HWordPosition(int x1, int x2, int y) {
        if (x1 > x2)
            throw new IllegalArgumentException(""wrong word position parameters"");
        this.x1 = x1;
        this.x2 = x2;
        this.y = y;
    }

    public HWordPosition(CharPosition start, int x2) {
        this(start.x, x2, start.y);
    }

    public HWordPosition(int x1, CharPosition end) {
        this(x1, end.x, end.y);
    }

    /**
     * The word position is initialized
     * representing the upper line of the specified block.
     */
    public HWordPosition(Block block) {
        this(block.getPos1(), block.getPos2().x);
    }

    /**
     * Creates a trivial word position
     * which begins and ends at the specified character position.
     */
    public HWordPosition(CharPosition cp) {
        this(cp.x, cp.x, cp.y);
    }

    /**
     * Returns the coordinates of the beginning of this word.
     */
    public CharPosition1 getStart() {
        return new CharPosition1(x1, y);
    }

    /**
     * Returns the coordinates of the ending of this word (exclusive).
     */
    public CharPosition2 getEnd() {
        return new CharPosition2(x2, y);
    }

    public int getWidth() {
        return x2 - x1;
    }

    public boolean equals(WordPosition wp) {
        if (!(wp instanceof HWordPosition))
            return false;
        HWordPosition hwp = (HWordPosition) wp;
        return hwp.x1 == x1 && hwp.x2 == x2 && hwp.y == y;
    }

    public boolean isTrivial() {
        return x1 >= x2;
    }

    public boolean contains(int x, int y) {
        return y == this.y && x1 <= x && x < x2;
    }

    public boolean liesIn(CharTable ct) {
        return x1 >= ct.x1 && x2 <= ct.x2 && y >= ct.y1 && y < ct.y2;
    }

    /**
     * Verifies whether this word position intersects the specified char table.
     */
    public boolean intersects(CharTable ct) {
        return ct.y1 <= y && y < ct.y2 && ct.x1 < x2 && x1 < ct.x2;
    }

    /**
     * Returns the width of the intersection of this line
     * with the specified block
     * or <code>0</code> if they are not intersected.
     */
    public int getLengthInsideOf(Block block) {
        int width = Math.min(x2, block.x2) - Math.max(x1, block.x1);
        return Math.max(width, 0);
    }

    public String toString() {
        return ""horizontal("" + x1 + "","" + x2 + "";"" + y + "")"";
    }

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct	the char table from which the text must be read.
     *
     * @return		the text at this position on the specified char table.
     */
    public String textAt(CharTable ct) {
        return ct.textAt(this);
    }
}
","// HWordPosition_5Test.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HWordPosition}.
* It contains ten unit test cases for the {@link HWordPosition#textAt(CharTable)} method.
*/
class HWordPosition_5Test {","// HWordPosition_5Test.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HWordPosition}.
* It contains ten unit test cases for the {@link HWordPosition#textAt(CharTable)} method.
*/
class HWordPosition_5Test {

	/**
	 * The char table used in the tests.
	 */
	private static final CharTable ct = new CharTable(
			new String[] {
					""abcdefghijklmnopqrstuvwxyz"",
					""ABCDEFGHIJKLMNOPQRSTUVWXYZ"",
					""0123456789"",
					""`~!@#$%^&amp;*()_+-=[]{}\\|;:'\"",./&lt;&gt;?""
			}
	);
	
	/**
	 * The word positions used in the tests.
	 */
	private static final HWordPosition[] wps = new HWordPosition[] {
			new HWordPosition(0, 0, 0),
			new HWordPosition(0, 1, 0),
			new HWordPosition(0, 2, 0),
			new HWordPosition(0, 3, 0),
			new HWordPosition(0, 4, 0),
			new HWordPosition(0, 5, 0),
			new HWordPosition(0, 6, 0),
			new HWordPosition(0, 7, 0),
			new HWordPosition(0, 8, 0),
			new HWordPosition(0, 9, 0)
	};
	
	/**
	 * The expected texts used in the tests.
	 */
	private static final String[] texts = new String[] {
			"""",
			""a"",
			""ab"",
			""abc"",
			""abcd"",
			""abcde"",
			""abcdef"",
			""abcdefg"",
			""abcdefgh"",
			""abcdefghi""
	};
	
	/**
	 * Tests the {@link HWordPosition#textAt(CharTable)} method.
	 */
	@Test
	void testTextAt() {
		for (int i = 0; i &lt; wps.length; i++) {
			assertEquals(texts[i], wps[i].textAt(ct));
		}
	}
}</code></pre>
</div>
</div>

</code>
"
cmpl-6wWlPPk2ip1U65dvwV1GVx49ahAMn,/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/positions/VWordPosition_6Test.java,38.1066210269928,stop,"// VWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying vertically on the scheme.
 */
public class VWordPosition extends WordPosition implements Comparable<VWordPosition> {

    /**
     * The horizontal coordinate of the word.
     */
    public final int x;

    /**
     * The vertical coordinate of the word start.
     */
    public final int y1;

    /**
     * The vertical coordinate of the word end + 1.
     */
    public final int y2;

    public VWordPosition(int x, int y1, int y2) {
        if (y1 > y2)
            throw new IllegalArgumentException(""wrong word position parameters"");
        this.x = x;
        this.y1 = y1;
        this.y2 = y2;
    }

    public VWordPosition(CharPosition start, int y2) {
        this(start.x, start.y, y2);
    }

    public VWordPosition(int y, CharPosition end) {
        this(end.x, y, end.y);
    }

    public VWordPosition(Block block) {
        this(block.getPos1(), block.getPos2().x);
    }

    /**
     * Creates a trivial word position
     * which begins and ends at the specified character position.
     */
    public VWordPosition(CharPosition cp) {
        this(cp.x, cp.y, cp.y);
    }

    /**
     * Returns the coordinates of the beginning of this word.
     */
    public CharPosition1 getStart() {
        return new CharPosition1(x, y1);
    }

    /**
     * Returns the coordinates of the ending of this word (exclusive).
     */
    public CharPosition2 getEnd() {
        return new CharPosition2(x, y2);
    }

    public int getHeight() {
        return y2 - y1;
    }

    public boolean equals(WordPosition wp) {
        if (!(wp instanceof VWordPosition))
            return false;
        VWordPosition hwp = (VWordPosition) wp;
        return hwp.x == x && hwp.y1 == y1 && hwp.y2 == y2;
    }

    public boolean isTrivial() {
        return y1 >= y2;
    }

    public boolean contains(int x, int y) {
        return x == this.x && y1 <= y && y < y2;
    }

    public boolean liesIn(CharTable ct) {
        return x >= ct.x1 && x < ct.x2 && y1 >= ct.y1 && y2 <= ct.y2;
    }

    /**
     * Verifies whether this word position intersects the specified char table.
     */
    public boolean intersects(CharTable ct) {
        return ct.x1 <= x && x < ct.x2 && ct.y1 < y2 && y1 < ct.y2;
    }

    /**
     * Returns the height of the intersection of this line
     * with the specified block
     * or <code>0</code> if they are not intersected.
     */
    public int getLengthInsideOf(Block block) {
        int height = Math.min(y2, block.y2) - Math.max(y1, block.y1);
        return Math.max(height, 0);
    }

    /**
     * Compares this vertical position with the specified one
     * according to their x-coordinates.
     */
    public int compareTo(VWordPosition vLine) {
        int xx = vLine.x;
        if (x < xx)
            return -1;
        else if (x == xx)
            return 0;
        else
            return +1;
    }

    public String toString() {
        return ""vertical("" + x + "";"" + y1 + "","" + y2 + "")"";
    }

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct	the char table from which the text must be read.
     *
     * @return		the text at this position on the specified char table.
     */
    public String textAt(CharTable ct) {
        return ct.textAt(this);
    }
}
","// VWordPosition_6Test.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.
*/
class VWordPosition_6Test {","// VWordPosition_6Test.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.
*/
class VWordPosition_6Test {

	/**
	 * Test case #1.
	 *
	 * The word position is trivial.
	 */
	@Test
	void testTextAt_1() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition wp = new VWordPosition(1, 1, 1);
		assertEquals("""", wp.textAt(ct));
	}
	
	/**
	 * Test case #2.
	 *
	 * The word position is not trivial.
	 */
	@Test
	void testTextAt_2() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition wp = new VWordPosition(1, 1, 2);
		assertEquals(""e"", wp.textAt(ct));
	}
	
	/**
	 * Test case #3.
	 *
	 * The word position is not trivial.
	 */
	@Test
	void testTextAt_3() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition wp = new VWordPosition(1, 1, 3);
		assertEquals(""ef"", wp.textAt(ct));
	}
	
	/**
	 * Test case #4.
	 *
	 * The word position is not trivial.
	 */
	@Test
	void testTextAt_4() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition wp = new VWordPosition(1, 0, 3);
		assertEquals(""def"", wp.textAt(ct));
	}
	
	/**
	 * Test case #5.
	 *
	 * The word position is not trivial.
	 */
	@Test
	void testTextAt_5() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition wp = new VWordPosition(1, 0, 4);
		assertEquals(""def"", wp.textAt(ct));
	}
	
	/**
	 * Test case #6.
	 *
	 * The word position is not trivial.
	 */
	@Test
	void testTextAt_6() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition wp = new VWordPosition(1, 0, 5);
		assertEquals(""def"", wp.textAt(ct));
	}
	
	/**
	 * Test case #7.
	 *
	 * The word position is not trivial.
	 */
	@Test
	void testTextAt_7() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition wp = new VWordPosition(1, 0, 6);
		assertEquals(""def"", wp.textAt(ct));
	}
	
	/**
	 * Test case #8.
	 *
	 * The word position is not trivial.
	 */
	@Test
	void testTextAt_8() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition wp = new VWordPosition(1, 0, 7);
		assertEquals(""def"", wp.textAt(ct));
	}
	
	/**
	 * Test case #9.
	 *
	 * The word position is not trivial.
	 */
	@Test
	void testTextAt_9() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition wp = new VWordPosition(1, 0, 8);
		assertEquals(""def"", wp.textAt(ct));
	}
	
	/**
	 * Test case #10.
	 *
	 * The word position is not trivial.
	 */
	@Test
	void testTextAt_10() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition wp = new VWordPosition(1, 0, 9);
		assertEquals(""def"", wp.textAt(ct));
	}
}</code>





A:

I think the problem is that you are using <code>assertEquals</code> instead of <code>assertTrue</code>.
<code>assertEquals</code> is used to compare two objects, while <code>assertTrue</code> is used to check if a condition is true.
In your case, you are comparing the result of <code>textAt</code> with the string <code>""""</code>, which is not the same object.
"
