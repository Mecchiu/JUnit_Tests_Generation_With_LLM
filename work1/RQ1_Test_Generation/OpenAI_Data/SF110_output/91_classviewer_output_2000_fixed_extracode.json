[
    {
        "id": "cmpl-6wS72a2LREjqdIXyhCMKVd0rvpyqv",
        "object": "text_completion",
        "created": 1679389108,
        "model": "code-davinci-002",
        "choices": [
            {
                "text": "// ClassInfo_0Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\n//8-01-04 Handled exceptions with fields.   ___JSH\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#printFields()} method.\n*/\nclass ClassInfo_0Test {\n\t\t\n\t\t@Test\n\t\tvoid testPrintFields() {\n\t\t\t\tClassInfo ci = new ClassInfo(\"java.lang.String\");\n\t\t\t\tString[] fields = ci.printFields();\n\t\t\t\tassertEquals(fields[0], \"public static final int java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[1], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[2], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[3], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[4], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[5], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[6], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[7], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[8], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[9], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[10], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[11], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[12], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[13], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[14], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[15], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[16], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[17], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[18], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[19], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[20], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[21], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[22], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[23], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[24], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[25], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[26], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[27], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[28], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[29], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[30], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[31], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[32], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[33], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[34], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[35], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[36], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[37], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[38], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[39], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[40], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[41], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[42], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[43], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[44], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[45], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[46], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[47], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n}\n}",
                "index": 0,
                "logprobs": null,
                "finish_reason": "length"
            }
        ],
        "usage": {
            "prompt_tokens": 5833,
            "completion_tokens": 2000,
            "total_tokens": 7833
        },
        "time_taken": 58.74748611450195,
        "prompt_id": "/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_0Test.java",
        "original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * <p>\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c = javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;\r\n\r\n    private String[] cMethods, fndMethods = null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() != null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c != java.lang.Object.class && !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan = locManager;\r\n        knownPackages = dirMan.getPackageList();\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f = c.getFields();\r\n        length = f.length;\r\n        String[] StringData = null;\r\n        if (length > 0) {\r\n            StringData = new String[length];\r\n            String tempStr;\r\n            Object obj = new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count = 0; count < length; count++) {\r\n                try {\r\n                    tempStr = f[count] + \"=\" + f[count].get(obj);\r\n                    StringData[count] = tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray = null;\r\n        if (cMethods != null) {\r\n            tempArray = new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug && tempArray == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods == null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = cMethods;\r\n        StringList tempList = new StringList();\r\n        for (int i = 0; i < cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + '.') != -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data = tempList.toArray();\r\n        else\r\n            data = null;\r\n        if (debug && data == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr = c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(constr);\r\n        if (debug && data == null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter = c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(inter);\r\n        if (c != java.lang.Object.class && !c.isInterface()) {\r\n            Class superC = c.getSuperclass();\r\n            TreeSet<String> hInterfaces = new TreeSet<String>();\r\n            int i = 0;\r\n            if (data != null)\r\n                for (i = 0; i < data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC != null && superC != java.lang.Object.class) {\r\n                inter = superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data = getData(inter);\r\n                if (data != null)\r\n                    for (i = 0; i < data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC = superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() != 0) {\r\n                data = new String[hInterfaces.size()];\r\n                Iterator it = hInterfaces.iterator();\r\n                i = 0;\r\n                while (it.hasNext()) {\r\n                    data[i] = (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug && data == null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].toString();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].getName();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods == null || pos > fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn't out of range\r\n            String tempStr = fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end = tempStr.indexOf(\")\");\r\n                tempStr = tempStr.substring(0, end + 1);\r\n                begin = tempStr.lastIndexOf(\" \");\r\n                tempStr = tempStr.substring(begin + 1, tempStr.length());\r\n                begin = tempStr.indexOf(\"(\");\r\n                end = tempStr.lastIndexOf(\".\", begin);\r\n                className = tempStr.substring(0, end);\r\n                methodName = tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className=\" + className);\r\n                methClass = ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass=\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr = name;\r\n        Class tempClass = null;\r\n        tempClass = tryClass(name);\r\n        if (tempClass == null) {\r\n            for (int i = 0; i < knownPackages.length; i++) {\r\n                tempStr = knownPackages[i] + name;\r\n                tempClass = tryClass(tempStr);\r\n                if (tempClass != null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass = null;\r\n        try {\r\n            if (name != null)\r\n                tempClass = Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c != java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 = System.currentTimeMillis();\r\n        debug = true;\r\n        String name = null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length > 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name = args[1];\r\n            } else {\r\n                name = args[0];\r\n                try {\r\n                    myClassInfo = new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo = new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
        "test_prompt": "// ClassInfo_0Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\n//8-01-04 Handled exceptions with fields.   ___JSH\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#printFields()} method.\n*/\nclass ClassInfo_0Test {",
        "original_generated_code": "\n\t\t@Test\n\t\tvoid testPrintFields() {\n\t\t\t\tClassInfo ci = new ClassInfo(\"java.lang.String\");\n\t\t\t\tString[] fields = ci.printFields();\n\t\t\t\tassertEquals(fields[0], \"public static final int java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[1], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[2], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[3], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[4], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[5], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[6], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[7], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[8], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[9], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[10], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[11], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[12], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[13], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[14], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[15], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[16], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[17], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[18], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[19], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[20], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[21], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[22], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[23], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[24], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[25], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[26], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[27], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[28], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[29], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[30], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[31], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[32], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[33], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[34], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[35], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[36], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[37], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[38], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[39], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[40], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[41], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[42], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[43], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[44], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[45], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[46], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[47], \"public static final java.util.Comparator java.lang.String.CASE_INSENSITIVE_ORDER\");\n\t\t\t\tassertEquals(fields[48], \"public static final java.util.Comparator java.lang.String.CASE_INSENS",
        "applied_heuristics": "H7"
    },
    {
        "id": "cmpl-6wS855waXwbevimJ8ov9Jklow06CC",
        "object": "text_completion",
        "created": 1679389173,
        "model": "code-davinci-002",
        "choices": [
            {
                "text": "// ClassInfo_1Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#printMethods()} method.\n*/\nclass ClassInfo_1Test {\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#printMethods()} method.\n\t\t* <p>\n\t\t* This test case checks if the method returns the correct array of strings.\n\t\t*/\n\t\t@Test\n\t\tvoid testPrintMethods() {\n\t\t\t\tClassInfo myClassInfo = new ClassInfo(\"java.lang.String\");\n\t\t\t\tString[] data = myClassInfo.printMethods();\n\t\t\t\tassertEquals(data[0], \"public boolean java.lang.String.equals(java.lang.Object)\");\n\t\t\t\tassertEquals(data[1], \"public java.lang.String java.lang.String.toString()\");\n\t\t\t\tassertEquals(data[2], \"public int java.lang.String.hashCode()\");\n\t\t\t\tassertEquals(data[3], \"public int java.lang.String.length()\");\n\t\t\t\tassertEquals(data[4], \"public char java.lang.String.charAt(int)\");\n\t\t\t\tassertEquals(data[5], \"public int java.lang.String.compareTo(java.lang.String)\");\n\t\t\t\tassertEquals(data[6], \"public int java.lang.String.compareTo(java.lang.Object)\");\n\t\t\t\tassertEquals(data[7], \"public int java.lang.String.compareToIgnoreCase(java.lang.String)\");\n\t\t\t\tassertEquals(data[8], \"public boolean java.lang.String.equalsIgnoreCase(java.lang.String)\");\n\t\t\t\tassertEquals(data[9], \"public int java.lang.String.indexOf(int)\");\n\t\t\t\tassertEquals(data[10], \"public int java.lang.String.indexOf(int,int)\");\n\t\t\t\tassertEquals(data[11], \"public int java.lang.String.indexOf(java.lang.String)\");\n\t\t\t\tassertEquals(data[12], \"public int java.lang.String.indexOf(java.lang.String,int)\");\n\t\t\t\tassertEquals(data[13], \"public java.lang.String java.lang.String.intern()\");\n\t\t\t\tassertEquals(data[14], \"public int java.lang.String.lastIndexOf(int)\");\n\t\t\t\tassertEquals(data[15], \"public int java.lang.String.lastIndexOf(int,int)\");\n\t\t\t\tassertEquals(data[16], \"public int java.lang.String.lastIndexOf(java.lang.String)\");\n\t\t\t\tassertEquals(data[17], \"public int java.lang.String.lastIndexOf(java.lang.String,int)\");\n\t\t\t\tassertEquals(data[18], \"public int java.lang.String.length()\");\n\t\t\t\tassertEquals(data[19], \"public boolean java.lang.String.matches(java.lang.String)\");\n\t\t\t\tassertEquals(data[20], \"public boolean java.lang.String.regionMatches(boolean,int,java.lang.String,int,int)\");\n\t\t\t\tassertEquals(data[21], \"public boolean java.lang.String.regionMatches(int,java.lang.String,int,int)\");\n\t\t\t\tassertEquals(data[22], \"public java.lang.String java.lang.String.replaceAll(java.lang.String,java.lang.String)\");\n\t\t\t\tassertEquals(data[23], \"public java.lang.String java.lang.String.replaceFirst(java.lang.String,java.lang.String)\");\n\t\t\t\tassertEquals(data[24], \"public java.lang.String[] java.lang.String.split(java.lang.String)\");\n\t\t\t\tassertEquals(data[25], \"public java.lang.String[] java.lang.String.split(java.lang.String,int)\");\n\t\t\t\tassertEquals(data[26], \"public boolean java.lang.String.startsWith(java.lang.String,int)\");\n\t\t\t\tassertEquals(data[27], \"public boolean java.lang.String.startsWith(java.lang.String)\");\n\t\t\t\tassertEquals(data[28], \"public java.lang.CharSequence java.lang.String.subSequence(int,int)\");\n\t\t\t\tassertEquals(data[29], \"public java.lang.String java.lang.String.substring(int)\");\n\t\t\t\tassertEquals(data[30], \"public java.lang.String java.lang.String.substring(int,int)\");\n\t\t\t\tassertEquals(data[31], \"public char[] java.lang.String.toCharArray()\");\n\t\t\t\tassertEquals(data[32], \"public java.lang.String java.lang.String.toLowerCase()\");\n\t\t\t\tassertEquals(data[33], \"public java.lang.String java.lang.String.toString()\");\n\t\t\t\tassertEquals(data[34], \"public java.lang.String java.lang.String.toUpperCase()\");\n\t\t\t\tassertEquals(data[35], \"public java.lang.String java.lang.String.trim()\");\n\t\t\t\tassertEquals(data[36], \"public static java.lang.String java.lang.String.valueOf(boolean)\");\n\t\t\t\tassertEquals(data[37], \"public static java.lang.String java.lang.String.valueOf(char)\");\n\t\t\t\tassertEquals(data[38], \"public static java.lang.String java.lang.String.valueOf(char[])\");\n\t\t\t\tassertEquals(data[39], \"public static java.lang.String java.lang.String.valueOf(char[],int,int)\");\n\t\t\t\tassertEquals(data[40], \"public static java.lang.String java.lang.String.valueOf(double)\");\n\t\t\t\tassertEquals(data[41], \"public static java.lang.String java.lang.String.valueOf(float)\");\n\t\t\t\tassertEquals(data[42], \"public static java.lang.String java.lang.String.valueOf(int)\");\n\t\t\t\tassertEquals(data[43], \"public static java.lang.String java.lang.String.valueOf(long)\");\n\t\t\t\tassertEquals(data[44], \"public static java.lang.String java.lang.String.valueOf(java.lang.Object)\");\n\t\t\t\tassertEquals(data[45], \"public static java.lang.String java.lang.String.valueOf(java.lang.String)\");\n\t\t\t\tassertEquals(data[46], \"public void java.lang.String.getChars(int,int,char[],int)\");\n\t\t\t\tassertEquals(data[47], \"public void java.lang.String.getBytes(int,int,byte[],int)\");\n\t\t\t\tassertEquals(data[48], \"public byte[] java.lang.String.getBytes(java.lang.String) throws java.io.UnsupportedEncodingException\");\n\t\t\t\tassertEquals(data[49], \"public byte[] java.lang.String.getBytes()\");\n\t\t\t\tassertEquals(data[50], \"public boolean java.lang.String.contentEquals(java.lang.StringBuffer)\");\n\t\t\t\tassertEquals(data[51], \"public boolean java.lang.String.contentEquals(java.lang.CharSequence)\");\n\t\t\t\tassertEquals(data[52], \"public boolean java.lang.String.equalsIgnoreCase(java.lang.String)\");\n\t\t\t\tassertEquals(data[53], \"public int java.lang.String.compareToIgnoreCase(java.lang.String)\");\n\t\t\t\tassertEquals(data[54], \"public boolean java.lang.String.regionMatches(boolean,int,java.lang.String,int,int)\");\n\t\t\t\tassertEquals(data[55], \"public boolean java.lang.String.regionMatches(int,java.lang.String,int,int)\");\n}\n}",
                "index": 0,
                "logprobs": null,
                "finish_reason": "length"
            }
        ],
        "usage": {
            "prompt_tokens": 5835,
            "completion_tokens": 2000,
            "total_tokens": 7835
        },
        "time_taken": 72.85919547080994,
        "prompt_id": "/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_1Test.java",
        "original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * <p>\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c = javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;\r\n\r\n    private String[] cMethods, fndMethods = null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() != null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c != java.lang.Object.class && !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan = locManager;\r\n        knownPackages = dirMan.getPackageList();\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f = c.getFields();\r\n        length = f.length;\r\n        String[] StringData = null;\r\n        if (length > 0) {\r\n            StringData = new String[length];\r\n            String tempStr;\r\n            Object obj = new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count = 0; count < length; count++) {\r\n                try {\r\n                    tempStr = f[count] + \"=\" + f[count].get(obj);\r\n                    StringData[count] = tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray = null;\r\n        if (cMethods != null) {\r\n            tempArray = new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug && tempArray == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods == null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = cMethods;\r\n        StringList tempList = new StringList();\r\n        for (int i = 0; i < cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + '.') != -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data = tempList.toArray();\r\n        else\r\n            data = null;\r\n        if (debug && data == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr = c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(constr);\r\n        if (debug && data == null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter = c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(inter);\r\n        if (c != java.lang.Object.class && !c.isInterface()) {\r\n            Class superC = c.getSuperclass();\r\n            TreeSet<String> hInterfaces = new TreeSet<String>();\r\n            int i = 0;\r\n            if (data != null)\r\n                for (i = 0; i < data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC != null && superC != java.lang.Object.class) {\r\n                inter = superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data = getData(inter);\r\n                if (data != null)\r\n                    for (i = 0; i < data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC = superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() != 0) {\r\n                data = new String[hInterfaces.size()];\r\n                Iterator it = hInterfaces.iterator();\r\n                i = 0;\r\n                while (it.hasNext()) {\r\n                    data[i] = (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug && data == null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].toString();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].getName();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods == null || pos > fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn't out of range\r\n            String tempStr = fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end = tempStr.indexOf(\")\");\r\n                tempStr = tempStr.substring(0, end + 1);\r\n                begin = tempStr.lastIndexOf(\" \");\r\n                tempStr = tempStr.substring(begin + 1, tempStr.length());\r\n                begin = tempStr.indexOf(\"(\");\r\n                end = tempStr.lastIndexOf(\".\", begin);\r\n                className = tempStr.substring(0, end);\r\n                methodName = tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className=\" + className);\r\n                methClass = ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass=\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr = name;\r\n        Class tempClass = null;\r\n        tempClass = tryClass(name);\r\n        if (tempClass == null) {\r\n            for (int i = 0; i < knownPackages.length; i++) {\r\n                tempStr = knownPackages[i] + name;\r\n                tempClass = tryClass(tempStr);\r\n                if (tempClass != null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass = null;\r\n        try {\r\n            if (name != null)\r\n                tempClass = Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c != java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 = System.currentTimeMillis();\r\n        debug = true;\r\n        String name = null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length > 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name = args[1];\r\n            } else {\r\n                name = args[0];\r\n                try {\r\n                    myClassInfo = new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo = new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
        "test_prompt": "// ClassInfo_1Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#printMethods()} method.\n*/\nclass ClassInfo_1Test {",
        "original_generated_code": "\n\t\t/**\n\t\t* Test case for {@link ClassInfo#printMethods()} method.\n\t\t* <p>\n\t\t* This test case checks if the method returns the correct array of strings.\n\t\t*/\n\t\t@Test\n\t\tvoid testPrintMethods() {\n\t\t\t\tClassInfo myClassInfo = new ClassInfo(\"java.lang.String\");\n\t\t\t\tString[] data = myClassInfo.printMethods();\n\t\t\t\tassertEquals(data[0], \"public boolean java.lang.String.equals(java.lang.Object)\");\n\t\t\t\tassertEquals(data[1], \"public java.lang.String java.lang.String.toString()\");\n\t\t\t\tassertEquals(data[2], \"public int java.lang.String.hashCode()\");\n\t\t\t\tassertEquals(data[3], \"public int java.lang.String.length()\");\n\t\t\t\tassertEquals(data[4], \"public char java.lang.String.charAt(int)\");\n\t\t\t\tassertEquals(data[5], \"public int java.lang.String.compareTo(java.lang.String)\");\n\t\t\t\tassertEquals(data[6], \"public int java.lang.String.compareTo(java.lang.Object)\");\n\t\t\t\tassertEquals(data[7], \"public int java.lang.String.compareToIgnoreCase(java.lang.String)\");\n\t\t\t\tassertEquals(data[8], \"public boolean java.lang.String.equalsIgnoreCase(java.lang.String)\");\n\t\t\t\tassertEquals(data[9], \"public int java.lang.String.indexOf(int)\");\n\t\t\t\tassertEquals(data[10], \"public int java.lang.String.indexOf(int,int)\");\n\t\t\t\tassertEquals(data[11], \"public int java.lang.String.indexOf(java.lang.String)\");\n\t\t\t\tassertEquals(data[12], \"public int java.lang.String.indexOf(java.lang.String,int)\");\n\t\t\t\tassertEquals(data[13], \"public java.lang.String java.lang.String.intern()\");\n\t\t\t\tassertEquals(data[14], \"public int java.lang.String.lastIndexOf(int)\");\n\t\t\t\tassertEquals(data[15], \"public int java.lang.String.lastIndexOf(int,int)\");\n\t\t\t\tassertEquals(data[16], \"public int java.lang.String.lastIndexOf(java.lang.String)\");\n\t\t\t\tassertEquals(data[17], \"public int java.lang.String.lastIndexOf(java.lang.String,int)\");\n\t\t\t\tassertEquals(data[18], \"public int java.lang.String.length()\");\n\t\t\t\tassertEquals(data[19], \"public boolean java.lang.String.matches(java.lang.String)\");\n\t\t\t\tassertEquals(data[20], \"public boolean java.lang.String.regionMatches(boolean,int,java.lang.String,int,int)\");\n\t\t\t\tassertEquals(data[21], \"public boolean java.lang.String.regionMatches(int,java.lang.String,int,int)\");\n\t\t\t\tassertEquals(data[22], \"public java.lang.String java.lang.String.replaceAll(java.lang.String,java.lang.String)\");\n\t\t\t\tassertEquals(data[23], \"public java.lang.String java.lang.String.replaceFirst(java.lang.String,java.lang.String)\");\n\t\t\t\tassertEquals(data[24], \"public java.lang.String[] java.lang.String.split(java.lang.String)\");\n\t\t\t\tassertEquals(data[25], \"public java.lang.String[] java.lang.String.split(java.lang.String,int)\");\n\t\t\t\tassertEquals(data[26], \"public boolean java.lang.String.startsWith(java.lang.String,int)\");\n\t\t\t\tassertEquals(data[27], \"public boolean java.lang.String.startsWith(java.lang.String)\");\n\t\t\t\tassertEquals(data[28], \"public java.lang.CharSequence java.lang.String.subSequence(int,int)\");\n\t\t\t\tassertEquals(data[29], \"public java.lang.String java.lang.String.substring(int)\");\n\t\t\t\tassertEquals(data[30], \"public java.lang.String java.lang.String.substring(int,int)\");\n\t\t\t\tassertEquals(data[31], \"public char[] java.lang.String.toCharArray()\");\n\t\t\t\tassertEquals(data[32], \"public java.lang.String java.lang.String.toLowerCase()\");\n\t\t\t\tassertEquals(data[33], \"public java.lang.String java.lang.String.toString()\");\n\t\t\t\tassertEquals(data[34], \"public java.lang.String java.lang.String.toUpperCase()\");\n\t\t\t\tassertEquals(data[35], \"public java.lang.String java.lang.String.trim()\");\n\t\t\t\tassertEquals(data[36], \"public static java.lang.String java.lang.String.valueOf(boolean)\");\n\t\t\t\tassertEquals(data[37], \"public static java.lang.String java.lang.String.valueOf(char)\");\n\t\t\t\tassertEquals(data[38], \"public static java.lang.String java.lang.String.valueOf(char[])\");\n\t\t\t\tassertEquals(data[39], \"public static java.lang.String java.lang.String.valueOf(char[],int,int)\");\n\t\t\t\tassertEquals(data[40], \"public static java.lang.String java.lang.String.valueOf(double)\");\n\t\t\t\tassertEquals(data[41], \"public static java.lang.String java.lang.String.valueOf(float)\");\n\t\t\t\tassertEquals(data[42], \"public static java.lang.String java.lang.String.valueOf(int)\");\n\t\t\t\tassertEquals(data[43], \"public static java.lang.String java.lang.String.valueOf(long)\");\n\t\t\t\tassertEquals(data[44], \"public static java.lang.String java.lang.String.valueOf(java.lang.Object)\");\n\t\t\t\tassertEquals(data[45], \"public static java.lang.String java.lang.String.valueOf(java.lang.String)\");\n\t\t\t\tassertEquals(data[46], \"public void java.lang.String.getChars(int,int,char[],int)\");\n\t\t\t\tassertEquals(data[47], \"public void java.lang.String.getBytes(int,int,byte[],int)\");\n\t\t\t\tassertEquals(data[48], \"public byte[] java.lang.String.getBytes(java.lang.String) throws java.io.UnsupportedEncodingException\");\n\t\t\t\tassertEquals(data[49], \"public byte[] java.lang.String.getBytes()\");\n\t\t\t\tassertEquals(data[50], \"public boolean java.lang.String.contentEquals(java.lang.StringBuffer)\");\n\t\t\t\tassertEquals(data[51], \"public boolean java.lang.String.contentEquals(java.lang.CharSequence)\");\n\t\t\t\tassertEquals(data[52], \"public boolean java.lang.String.equalsIgnoreCase(java.lang.String)\");\n\t\t\t\tassertEquals(data[53], \"public int java.lang.String.compareToIgnoreCase(java.lang.String)\");\n\t\t\t\tassertEquals(data[54], \"public boolean java.lang.String.regionMatches(boolean,int,java.lang.String,int,int)\");\n\t\t\t\tassertEquals(data[55], \"public boolean java.lang.String.regionMatches(int,java.lang.String,int,int)\");\n\t\t\t\tassertEquals(data[56],",
        "applied_heuristics": "H7"
    },
    {
        "id": "cmpl-6wS9G9C1mhXnK47B4tRA6aEosf6Kz",
        "object": "text_completion",
        "created": 1679389246,
        "model": "code-davinci-002",
        "choices": [
            {
                "text": "// ClassInfo_2Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#printMethods(int)} method.\n*/\nclass ClassInfo_2Test {\n\t\t\n\t\tprivate ClassInfo myClassInfo;\n\t\t\n\t\tprivate String[] cMethods;\n\t\t\n\t\tprivate String[] fndMethods;\n\t\t\n\t\tprivate String[] tempArray;\n\t\t\n\t\tprivate String[] data;\n\t\t\n\t\tprivate String[] tempArray2;\n\t\t\n\t\tprivate String[] data2;\n\t\t\n\t\tprivate String[] tempArray3;\n\t\t\n\t\tprivate String[] data3;\n\t\t\n\t\tprivate String[] tempArray4;\n\t\t\n\t\tprivate String[] data4;\n\t\t\n\t\tprivate String[] tempArray5;\n\t\t\n\t\tprivate String[] data5;\n\t\t\n\t\tprivate String[] tempArray6;\n\t\t\n\t\tprivate String[] data6;\n\t\t\n\t\tprivate String[] tempArray7;\n\t\t\n\t\tprivate String[] data7;\n\t\t\n\t\tprivate String[] tempArray8;\n\t\t\n\t\tprivate String[] data8;\n\t\t\n\t\tprivate String[] tempArray9;\n\t\t\n\t\tprivate String[] data9;\n\t\t\n\t\tprivate String[] tempArray10;\n\t\t\n\t\tprivate String[] data10;\n\t\t\n\t\tprivate String[] tempArray11;\n\t\t\n\t\tprivate String[] data11;\n\t\t\n\t\tprivate String[] tempArray12;\n\t\t\n\t\tprivate String[] data12;\n\t\t\n\t\tprivate String[] tempArray13;\n\t\t\n\t\tprivate String[] data13;\n\t\t\n\t\tprivate String[] tempArray14;\n\t\t\n\t\tprivate String[] data14;\n\t\t\n\t\tprivate String[] tempArray15;\n\t\t\n\t\tprivate String[] data15;\n\t\t\n\t\tprivate String[] tempArray16;\n\t\t\n\t\tprivate String[] data16;\n\t\t\n\t\tprivate String[] tempArray17;\n\t\t\n\t\tprivate String[] data17;\n\t\t\n\t\tprivate String[] tempArray18;\n\t\t\n\t\tprivate String[] data18;\n\t\t\n\t\tprivate String[] tempArray19;\n\t\t\n\t\tprivate String[] data19;\n\t\t\n\t\tprivate String[] tempArray20;\n\t\t\n\t\tprivate String[] data20;\n\t\t\n\t\tprivate String[] tempArray21;\n\t\t\n\t\tprivate String[] data21;\n\t\t\n\t\tprivate String[] tempArray22;\n\t\t\n\t\tprivate String[] data22;\n\t\t\n\t\tprivate String[] tempArray23;\n\t\t\n\t\tprivate String[] data23;\n\t\t\n\t\tprivate String[] tempArray24;\n\t\t\n\t\tprivate String[] data24;\n\t\t\n\t\tprivate String[] tempArray25;\n\t\t\n\t\tprivate String[] data25;\n\t\t\n\t\tprivate String[] tempArray26;\n\t\t\n\t\tprivate String[] data26;\n\t\t\n\t\tprivate String[] tempArray27;\n\t\t\n\t\tprivate String[] data27;\n\t\t\n\t\tprivate String[] tempArray28;\n\t\t\n\t\tprivate String[] data28;\n\t\t\n\t\tprivate String[] tempArray29;\n\t\t\n\t\tprivate String[] data29;\n\t\t\n\t\tprivate String[] tempArray30;\n\t\t\n\t\tprivate String[] data30;\n\t\t\n\t\tprivate String[] tempArray31;\n\t\t\n\t\tprivate String[] data31;\n\t\t\n\t\tprivate String[] tempArray32;\n\t\t\n\t\tprivate String[] data32;\n\t\t\n\t\tprivate String[] tempArray33;\n\t\t\n\t\tprivate String[] data33;\n\t\t\n\t\tprivate String[] tempArray34;\n\t\t\n\t\tprivate String[] data34;\n\t\t\n\t\tprivate String[] tempArray35;\n\t\t\n\t\tprivate String[] data35;\n\t\t\n\t\tprivate String[] tempArray36;\n\t\t\n\t\tprivate String[] data36;\n\t\t\n\t\tprivate String[] tempArray37;\n\t\t\n\t\tprivate String[] data37;\n\t\t\n\t\tprivate String[] tempArray38;\n\t\t\n\t\tprivate String[] data38;\n\t\t\n\t\tprivate String[] tempArray39;\n\t\t\n\t\tprivate String[] data39;\n\t\t\n\t\tprivate String[] tempArray40;\n\t\t\n\t\tprivate String[] data40;\n\t\t\n\t\tprivate String[] tempArray41;\n\t\t\n\t\tprivate String[] data41;\n\t\t\n\t\tprivate String[] tempArray42;\n\t\t\n\t\tprivate String[] data42;\n\t\t\n\t\tprivate String[] tempArray43;\n\t\t\n\t\tprivate String[] data43;\n\t\t\n\t\tprivate String[] tempArray44;\n\t\t\n\t\tprivate String[] data44;\n\t\t\n\t\tprivate String[] tempArray45;\n\t\t\n\t\tprivate String[] data45;\n\t\t\n\t\tprivate String[] tempArray46;\n\t\t\n\t\tprivate String[] data46;\n\t\t\n\t\tprivate String[] tempArray47;\n\t\t\n\t\tprivate String[] data47;\n\t\t\n\t\tprivate String[] tempArray48;\n\t\t\n\t\tprivate String[] data48;\n\t\t\n\t\tprivate String[] tempArray49;\n\t\t\n\t\tprivate String[] data49;\n\t\t\n\t\tprivate String[] tempArray50;\n\t\t\n\t\tprivate String[] data50;\n\t\t\n\t\tprivate String[] tempArray51;\n\t\t\n\t\tprivate String[] data51;\n\t\t\n\t\tprivate String[] tempArray52;\n\t\t\n\t\tprivate String[] data52;\n\t\t\n\t\tprivate String[] tempArray53;\n\t\t\n\t\tprivate String[] data53;\n\t\t\n\t\tprivate String[] tempArray54;\n\t\t\n\t\tprivate String[] data54;\n\t\t\n\t\tprivate String[] tempArray55;\n\t\t\n\t\tprivate String[] data55;\n\t\t\n\t\tprivate String[] tempArray56;\n\t\t\n\t\tprivate String[] data56;\n\t\t\n\t\tprivate String[] tempArray57;\n\t\t\n\t\tprivate String[] data57;\n\t\t\n\t\tprivate String[] tempArray58;\n\t\t\n\t\tprivate String[] data58;\n\t\t\n\t\tprivate String[] tempArray59;\n\t\t\n\t\tprivate String[] data59;\n\t\t\n\t\tprivate String[] tempArray60;\n\t\t\n\t\tprivate String[] data60;\n\t\t\n\t\tprivate String[] tempArray61;\n\t\t\n\t\tprivate String[] data61;\n\t\t\n\t\tprivate String[] tempArray62;\n\t\t\n\t\tprivate String[] data62;\n\t\t\n\t\tprivate String[] tempArray63;\n\t\t\n\t\tprivate String[] data63;\n\t\t\n\t\tprivate String[] tempArray64;\n\t\t\n\t\tprivate String[] data64;\n\t\t\n\t\tprivate String[] tempArray65;\n\t\t\n\t\tprivate String[] data65;\n\t\t\n\t\tprivate String[] tempArray66;\n\t\t\n\t\tprivate String[] data66;\n\t\t\n\t\tprivate String[] tempArray67;\n\t\t\n\t\tprivate String[] data67;\n\t\t\n\t\tprivate String[] tempArray68;\n\t\t\n\t\tprivate String[] data68;\n\t\t\n\t\tprivate String[] tempArray69;\n\t\t\n\t\tprivate String[] data69;\n\t\t\n\t\tprivate String[] tempArray70;\n\t\t\n\t\tprivate String[] data70;\n\t\t\n\t\tprivate String[] tempArray71;\n\t\t\n\t\tprivate String[] data71;\n\t\t\n\t\tprivate String[] tempArray72;\n\t\t\n\t\tprivate String[] data72;\n\t\t\n\t\tprivate String[] tempArray73;\n\t\t\n\t\tprivate String[] data73;\n\t\t\n\t\tprivate String[] tempArray74;\n\t\t\n\t\tprivate String[] data74;\n\t\t\n\t\tprivate String[] tempArray75;\n\t\t\n\t\tprivate String[] data75;\n\t\t\n\t\tprivate String[] tempArray76;\n\t\t\n\t\tprivate String[] data76;\n\t\t\n\t\tprivate String[] tempArray77;\n\t\t\n\t\tprivate String[] data77;\n\t\t\n\t\tprivate String[] tempArray78;\n\t\t\n\t\tprivate String[] data78;\n\t\t\n\t\tprivate String[] tempArray79;\n}",
                "index": 0,
                "logprobs": null,
                "finish_reason": "length"
            }
        ],
        "usage": {
            "prompt_tokens": 5836,
            "completion_tokens": 2000,
            "total_tokens": 7836
        },
        "time_taken": 70.4148268699646,
        "prompt_id": "/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_2Test.java",
        "original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * <p>\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c = javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;\r\n\r\n    private String[] cMethods, fndMethods = null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() != null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c != java.lang.Object.class && !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan = locManager;\r\n        knownPackages = dirMan.getPackageList();\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f = c.getFields();\r\n        length = f.length;\r\n        String[] StringData = null;\r\n        if (length > 0) {\r\n            StringData = new String[length];\r\n            String tempStr;\r\n            Object obj = new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count = 0; count < length; count++) {\r\n                try {\r\n                    tempStr = f[count] + \"=\" + f[count].get(obj);\r\n                    StringData[count] = tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray = null;\r\n        if (cMethods != null) {\r\n            tempArray = new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug && tempArray == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods == null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = cMethods;\r\n        StringList tempList = new StringList();\r\n        for (int i = 0; i < cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + '.') != -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data = tempList.toArray();\r\n        else\r\n            data = null;\r\n        if (debug && data == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr = c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(constr);\r\n        if (debug && data == null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter = c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(inter);\r\n        if (c != java.lang.Object.class && !c.isInterface()) {\r\n            Class superC = c.getSuperclass();\r\n            TreeSet<String> hInterfaces = new TreeSet<String>();\r\n            int i = 0;\r\n            if (data != null)\r\n                for (i = 0; i < data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC != null && superC != java.lang.Object.class) {\r\n                inter = superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data = getData(inter);\r\n                if (data != null)\r\n                    for (i = 0; i < data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC = superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() != 0) {\r\n                data = new String[hInterfaces.size()];\r\n                Iterator it = hInterfaces.iterator();\r\n                i = 0;\r\n                while (it.hasNext()) {\r\n                    data[i] = (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug && data == null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].toString();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].getName();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods == null || pos > fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn't out of range\r\n            String tempStr = fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end = tempStr.indexOf(\")\");\r\n                tempStr = tempStr.substring(0, end + 1);\r\n                begin = tempStr.lastIndexOf(\" \");\r\n                tempStr = tempStr.substring(begin + 1, tempStr.length());\r\n                begin = tempStr.indexOf(\"(\");\r\n                end = tempStr.lastIndexOf(\".\", begin);\r\n                className = tempStr.substring(0, end);\r\n                methodName = tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className=\" + className);\r\n                methClass = ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass=\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr = name;\r\n        Class tempClass = null;\r\n        tempClass = tryClass(name);\r\n        if (tempClass == null) {\r\n            for (int i = 0; i < knownPackages.length; i++) {\r\n                tempStr = knownPackages[i] + name;\r\n                tempClass = tryClass(tempStr);\r\n                if (tempClass != null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass = null;\r\n        try {\r\n            if (name != null)\r\n                tempClass = Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c != java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 = System.currentTimeMillis();\r\n        debug = true;\r\n        String name = null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length > 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name = args[1];\r\n            } else {\r\n                name = args[0];\r\n                try {\r\n                    myClassInfo = new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo = new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
        "test_prompt": "// ClassInfo_2Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#printMethods(int)} method.\n*/\nclass ClassInfo_2Test {",
        "original_generated_code": "\n\t\tprivate ClassInfo myClassInfo;\n\t\t\n\t\tprivate String[] cMethods;\n\t\t\n\t\tprivate String[] fndMethods;\n\t\t\n\t\tprivate String[] tempArray;\n\t\t\n\t\tprivate String[] data;\n\t\t\n\t\tprivate String[] tempArray2;\n\t\t\n\t\tprivate String[] data2;\n\t\t\n\t\tprivate String[] tempArray3;\n\t\t\n\t\tprivate String[] data3;\n\t\t\n\t\tprivate String[] tempArray4;\n\t\t\n\t\tprivate String[] data4;\n\t\t\n\t\tprivate String[] tempArray5;\n\t\t\n\t\tprivate String[] data5;\n\t\t\n\t\tprivate String[] tempArray6;\n\t\t\n\t\tprivate String[] data6;\n\t\t\n\t\tprivate String[] tempArray7;\n\t\t\n\t\tprivate String[] data7;\n\t\t\n\t\tprivate String[] tempArray8;\n\t\t\n\t\tprivate String[] data8;\n\t\t\n\t\tprivate String[] tempArray9;\n\t\t\n\t\tprivate String[] data9;\n\t\t\n\t\tprivate String[] tempArray10;\n\t\t\n\t\tprivate String[] data10;\n\t\t\n\t\tprivate String[] tempArray11;\n\t\t\n\t\tprivate String[] data11;\n\t\t\n\t\tprivate String[] tempArray12;\n\t\t\n\t\tprivate String[] data12;\n\t\t\n\t\tprivate String[] tempArray13;\n\t\t\n\t\tprivate String[] data13;\n\t\t\n\t\tprivate String[] tempArray14;\n\t\t\n\t\tprivate String[] data14;\n\t\t\n\t\tprivate String[] tempArray15;\n\t\t\n\t\tprivate String[] data15;\n\t\t\n\t\tprivate String[] tempArray16;\n\t\t\n\t\tprivate String[] data16;\n\t\t\n\t\tprivate String[] tempArray17;\n\t\t\n\t\tprivate String[] data17;\n\t\t\n\t\tprivate String[] tempArray18;\n\t\t\n\t\tprivate String[] data18;\n\t\t\n\t\tprivate String[] tempArray19;\n\t\t\n\t\tprivate String[] data19;\n\t\t\n\t\tprivate String[] tempArray20;\n\t\t\n\t\tprivate String[] data20;\n\t\t\n\t\tprivate String[] tempArray21;\n\t\t\n\t\tprivate String[] data21;\n\t\t\n\t\tprivate String[] tempArray22;\n\t\t\n\t\tprivate String[] data22;\n\t\t\n\t\tprivate String[] tempArray23;\n\t\t\n\t\tprivate String[] data23;\n\t\t\n\t\tprivate String[] tempArray24;\n\t\t\n\t\tprivate String[] data24;\n\t\t\n\t\tprivate String[] tempArray25;\n\t\t\n\t\tprivate String[] data25;\n\t\t\n\t\tprivate String[] tempArray26;\n\t\t\n\t\tprivate String[] data26;\n\t\t\n\t\tprivate String[] tempArray27;\n\t\t\n\t\tprivate String[] data27;\n\t\t\n\t\tprivate String[] tempArray28;\n\t\t\n\t\tprivate String[] data28;\n\t\t\n\t\tprivate String[] tempArray29;\n\t\t\n\t\tprivate String[] data29;\n\t\t\n\t\tprivate String[] tempArray30;\n\t\t\n\t\tprivate String[] data30;\n\t\t\n\t\tprivate String[] tempArray31;\n\t\t\n\t\tprivate String[] data31;\n\t\t\n\t\tprivate String[] tempArray32;\n\t\t\n\t\tprivate String[] data32;\n\t\t\n\t\tprivate String[] tempArray33;\n\t\t\n\t\tprivate String[] data33;\n\t\t\n\t\tprivate String[] tempArray34;\n\t\t\n\t\tprivate String[] data34;\n\t\t\n\t\tprivate String[] tempArray35;\n\t\t\n\t\tprivate String[] data35;\n\t\t\n\t\tprivate String[] tempArray36;\n\t\t\n\t\tprivate String[] data36;\n\t\t\n\t\tprivate String[] tempArray37;\n\t\t\n\t\tprivate String[] data37;\n\t\t\n\t\tprivate String[] tempArray38;\n\t\t\n\t\tprivate String[] data38;\n\t\t\n\t\tprivate String[] tempArray39;\n\t\t\n\t\tprivate String[] data39;\n\t\t\n\t\tprivate String[] tempArray40;\n\t\t\n\t\tprivate String[] data40;\n\t\t\n\t\tprivate String[] tempArray41;\n\t\t\n\t\tprivate String[] data41;\n\t\t\n\t\tprivate String[] tempArray42;\n\t\t\n\t\tprivate String[] data42;\n\t\t\n\t\tprivate String[] tempArray43;\n\t\t\n\t\tprivate String[] data43;\n\t\t\n\t\tprivate String[] tempArray44;\n\t\t\n\t\tprivate String[] data44;\n\t\t\n\t\tprivate String[] tempArray45;\n\t\t\n\t\tprivate String[] data45;\n\t\t\n\t\tprivate String[] tempArray46;\n\t\t\n\t\tprivate String[] data46;\n\t\t\n\t\tprivate String[] tempArray47;\n\t\t\n\t\tprivate String[] data47;\n\t\t\n\t\tprivate String[] tempArray48;\n\t\t\n\t\tprivate String[] data48;\n\t\t\n\t\tprivate String[] tempArray49;\n\t\t\n\t\tprivate String[] data49;\n\t\t\n\t\tprivate String[] tempArray50;\n\t\t\n\t\tprivate String[] data50;\n\t\t\n\t\tprivate String[] tempArray51;\n\t\t\n\t\tprivate String[] data51;\n\t\t\n\t\tprivate String[] tempArray52;\n\t\t\n\t\tprivate String[] data52;\n\t\t\n\t\tprivate String[] tempArray53;\n\t\t\n\t\tprivate String[] data53;\n\t\t\n\t\tprivate String[] tempArray54;\n\t\t\n\t\tprivate String[] data54;\n\t\t\n\t\tprivate String[] tempArray55;\n\t\t\n\t\tprivate String[] data55;\n\t\t\n\t\tprivate String[] tempArray56;\n\t\t\n\t\tprivate String[] data56;\n\t\t\n\t\tprivate String[] tempArray57;\n\t\t\n\t\tprivate String[] data57;\n\t\t\n\t\tprivate String[] tempArray58;\n\t\t\n\t\tprivate String[] data58;\n\t\t\n\t\tprivate String[] tempArray59;\n\t\t\n\t\tprivate String[] data59;\n\t\t\n\t\tprivate String[] tempArray60;\n\t\t\n\t\tprivate String[] data60;\n\t\t\n\t\tprivate String[] tempArray61;\n\t\t\n\t\tprivate String[] data61;\n\t\t\n\t\tprivate String[] tempArray62;\n\t\t\n\t\tprivate String[] data62;\n\t\t\n\t\tprivate String[] tempArray63;\n\t\t\n\t\tprivate String[] data63;\n\t\t\n\t\tprivate String[] tempArray64;\n\t\t\n\t\tprivate String[] data64;\n\t\t\n\t\tprivate String[] tempArray65;\n\t\t\n\t\tprivate String[] data65;\n\t\t\n\t\tprivate String[] tempArray66;\n\t\t\n\t\tprivate String[] data66;\n\t\t\n\t\tprivate String[] tempArray67;\n\t\t\n\t\tprivate String[] data67;\n\t\t\n\t\tprivate String[] tempArray68;\n\t\t\n\t\tprivate String[] data68;\n\t\t\n\t\tprivate String[] tempArray69;\n\t\t\n\t\tprivate String[] data69;\n\t\t\n\t\tprivate String[] tempArray70;\n\t\t\n\t\tprivate String[] data70;\n\t\t\n\t\tprivate String[] tempArray71;\n\t\t\n\t\tprivate String[] data71;\n\t\t\n\t\tprivate String[] tempArray72;\n\t\t\n\t\tprivate String[] data72;\n\t\t\n\t\tprivate String[] tempArray73;\n\t\t\n\t\tprivate String[] data73;\n\t\t\n\t\tprivate String[] tempArray74;\n\t\t\n\t\tprivate String[] data74;\n\t\t\n\t\tprivate String[] tempArray75;\n\t\t\n\t\tprivate String[] data75;\n\t\t\n\t\tprivate String[] tempArray76;\n\t\t\n\t\tprivate String[] data76;\n\t\t\n\t\tprivate String[] tempArray77;\n\t\t\n\t\tprivate String[] data77;\n\t\t\n\t\tprivate String[] tempArray78;\n\t\t\n\t\tprivate String[] data78;\n\t\t\n\t\tprivate String[] tempArray79;\n\t\t\n",
        "applied_heuristics": "H7"
    },
    {
        "id": "cmpl-6wSAO2avHBaBNV1mcWOrXLRsPOW1A",
        "object": "text_completion",
        "created": 1679389316,
        "model": "code-davinci-002",
        "choices": [
            {
                "text": "// ClassInfo_3Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#printConstructors()} method.\n*/\nclass ClassInfo_3Test {\n\t\t\n\t\tprivate ClassInfo myClassInfo;\n\t\t\n\t\tprivate String[] cMethods;\n\t\t\n\t\tprivate String[] fndMethods;\n\t\t\n\t\tprivate String[] cConstructors;\n\t\t\n\t\tprivate String[] fndConstructors;\n\t\t\n\t\tprivate String[] cInterfaces;\n\t\t\n\t\tprivate String[] fndInterfaces;\n\t\t\n\t\tprivate String[] cFields;\n\t\t\n\t\tprivate String[] fndFields;\n\t\t\n\t\tprivate String[] cPackages;\n\t\t\n\t\tprivate String[] fndPackages;\n\t\t\n\t\tprivate String[] cClasses;\n\t\t\n\t\tprivate String[] fndClasses;\n\t\t\n\t\tprivate String[] cSuperClasses;\n\t\t\n\t\tprivate String[] fndSuperClasses;\n\t\t\n\t\tprivate String[] cSuperPackages;\n\t\t\n\t\tprivate String[] fndSuperPackages;\n\t\t\n\t\tprivate String[] cSuperInterfaces;\n\t\t\n\t\tprivate String[] fndSuperInterfaces;\n\t\t\n\t\tprivate String[] cSuperFields;\n\t\t\n\t\tprivate String[] fndSuperFields;\n\t\t\n\t\tprivate String[] cSuperMethods;\n\t\t\n\t\tprivate String[] fndSuperMethods;\n\t\t\n\t\tprivate String[] cSuperConstructors;\n\t\t\n\t\tprivate String[] fndSuperConstructors;\n\t\t\n\t\tprivate String[] cSuperClasses2;\n\t\t\n\t\tprivate String[] fndSuperClasses2;\n\t\t\n\t\tprivate String[] cSuperPackages2;\n\t\t\n\t\tprivate String[] fndSuperPackages2;\n\t\t\n\t\tprivate String[] cSuperInterfaces2;\n\t\t\n\t\tprivate String[] fndSuperInterfaces2;\n\t\t\n\t\tprivate String[] cSuperFields2;\n\t\t\n\t\tprivate String[] fndSuperFields2;\n\t\t\n\t\tprivate String[] cSuperMethods2;\n\t\t\n\t\tprivate String[] fndSuperMethods2;\n\t\t\n\t\tprivate String[] cSuperConstructors2;\n\t\t\n\t\tprivate String[] fndSuperConstructors2;\n\t\t\n\t\tprivate String[] cSuperClasses3;\n\t\t\n\t\tprivate String[] fndSuperClasses3;\n\t\t\n\t\tprivate String[] cSuperPackages3;\n\t\t\n\t\tprivate String[] fndSuperPackages3;\n\t\t\n\t\tprivate String[] cSuperInterfaces3;\n\t\t\n\t\tprivate String[] fndSuperInterfaces3;\n\t\t\n\t\tprivate String[] cSuperFields3;\n\t\t\n\t\tprivate String[] fndSuperFields3;\n\t\t\n\t\tprivate String[] cSuperMethods3;\n\t\t\n\t\tprivate String[] fndSuperMethods3;\n\t\t\n\t\tprivate String[] cSuperConstructors3;\n\t\t\n\t\tprivate String[] fndSuperConstructors3;\n\t\t\n\t\tprivate String[] cSuperClasses4;\n\t\t\n\t\tprivate String[] fndSuperClasses4;\n\t\t\n\t\tprivate String[] cSuperPackages4;\n\t\t\n\t\tprivate String[] fndSuperPackages4;\n\t\t\n\t\tprivate String[] cSuperInterfaces4;\n\t\t\n\t\tprivate String[] fndSuperInterfaces4;\n\t\t\n\t\tprivate String[] cSuperFields4;\n\t\t\n\t\tprivate String[] fndSuperFields4;\n\t\t\n\t\tprivate String[] cSuperMethods4;\n\t\t\n\t\tprivate String[] fndSuperMethods4;\n\t\t\n\t\tprivate String[] cSuperConstructors4;\n\t\t\n\t\tprivate String[] fndSuperConstructors4;\n\t\t\n\t\tprivate String[] cSuperClasses5;\n\t\t\n\t\tprivate String[] fndSuperClasses5;\n\t\t\n\t\tprivate String[] cSuperPackages5;\n\t\t\n\t\tprivate String[] fndSuperPackages5;\n\t\t\n\t\tprivate String[] cSuperInterfaces5;\n\t\t\n\t\tprivate String[] fndSuperInterfaces5;\n\t\t\n\t\tprivate String[] cSuperFields5;\n\t\t\n\t\tprivate String[] fndSuperFields5;\n\t\t\n\t\tprivate String[] cSuperMethods5;\n\t\t\n\t\tprivate String[] fndSuperMethods5;\n\t\t\n\t\tprivate String[] cSuperConstructors5;\n\t\t\n\t\tprivate String[] fndSuperConstructors5;\n\t\t\n\t\tprivate String[] cSuperClasses6;\n\t\t\n\t\tprivate String[] fndSuperClasses6;\n\t\t\n\t\tprivate String[] cSuperPackages6;\n\t\t\n\t\tprivate String[] fndSuperPackages6;\n\t\t\n\t\tprivate String[] cSuperInterfaces6;\n\t\t\n\t\tprivate String[] fndSuperInterfaces6;\n\t\t\n\t\tprivate String[] cSuperFields6;\n\t\t\n\t\tprivate String[] fndSuperFields6;\n\t\t\n\t\tprivate String[] cSuperMethods6;\n\t\t\n\t\tprivate String[] fndSuperMethods6;\n\t\t\n\t\tprivate String[] cSuperConstructors6;\n\t\t\n\t\tprivate String[] fndSuperConstructors6;\n\t\t\n\t\tprivate String[] cSuperClasses7;\n\t\t\n\t\tprivate String[] fndSuperClasses7;\n\t\t\n\t\tprivate String[] cSuperPackages7;\n\t\t\n\t\tprivate String[] fndSuperPackages7;\n\t\t\n\t\tprivate String[] cSuperInterfaces7;\n\t\t\n\t\tprivate String[] fndSuperInterfaces7;\n\t\t\n\t\tprivate String[] cSuperFields7;\n\t\t\n\t\tprivate String[] fndSuperFields7;\n\t\t\n\t\tprivate String[] cSuperMethods7;\n\t\t\n\t\tprivate String[] fndSuperMethods7;\n\t\t\n\t\tprivate String[] cSuperConstructors7;\n\t\t\n\t\tprivate String[] fndSuperConstructors7;\n\t\t\n\t\tprivate String[] cSuperClasses8;\n\t\t\n\t\tprivate String[] fndSuperClasses8;\n\t\t\n\t\tprivate String[] cSuperPackages8;\n\t\t\n\t\tprivate String[] fndSuperPackages8;\n\t\t\n\t\tprivate String[] cSuperInterfaces8;\n\t\t\n\t\tprivate String[] fndSuperInterfaces8;\n\t\t\n\t\tprivate String[] cSuperFields8;\n\t\t\n\t\tprivate String[] fndSuperFields8;\n\t\t\n\t\tprivate String[] cSuperMethods8;\n\t\t\n\t\tprivate String[] fndSuperMethods8;\n\t\t\n\t\tprivate String[] cSuperConstructors8;\n\t\t\n\t\tprivate String[] fndSuperConstructors8;\n\t\t\n\t\tprivate String[] cSuperClasses9;\n\t\t\n\t\tprivate String[] fndSuperClasses9;\n\t\t\n\t\tprivate String[] cSuperPackages9;\n\t\t\n\t\tprivate String[] fndSuperPackages9;\n\t\t\n\t\tprivate String[] cSuperInterfaces9;\n\t\t\n\t\tprivate String[] fndSuperInterfaces9;\n\t\t\n\t\tprivate String[] cSuperFields9;\n\t\t\n\t\tprivate String[] fndSuperFields9;\n\t\t\n\t\tprivate String[] cSuperMethods9;\n\t\t\n\t\tprivate String[] fndSuperMethods9;\n\t\t\n\t\tprivate String[] cSuperConstructors9;\n\t\t\n\t\tprivate String[] fndSuperConstructors9;\n\t\t\n\t\tprivate String[] cSuperClasses10;\n\t\t\n\t\tprivate String[] fndSuperClasses10;\n\t\t\n\t\tprivate String[] cSuperPackages10;\n\t\t\n\t\tprivate String[] fndSuperPackages10;\n\t\t\n\t\tprivate String[] cSuperInterfaces10;\n\t\t\n\t\tprivate String[] fndSuperInterfaces10;\n\t\t\n\t\tprivate String[] cSuperFields10;\n\t\t\n\t\tprivate String[] fndSuperFields10;\n\t\t\n\t\tprivate String[] cSuperMethods10;\n\t\t\n\t\tprivate String[] fndSuperMethods10;\n\t\t\n\t\tprivate String[] cSuperConstructors10;\n\t\t\n\t\tprivate String[] fndSuperConstructors10;\n}",
                "index": 0,
                "logprobs": null,
                "finish_reason": "length"
            }
        ],
        "usage": {
            "prompt_tokens": 5836,
            "completion_tokens": 2000,
            "total_tokens": 7836
        },
        "time_taken": 62.0814106464386,
        "prompt_id": "/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_3Test.java",
        "original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * <p>\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c = javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;\r\n\r\n    private String[] cMethods, fndMethods = null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() != null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c != java.lang.Object.class && !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan = locManager;\r\n        knownPackages = dirMan.getPackageList();\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f = c.getFields();\r\n        length = f.length;\r\n        String[] StringData = null;\r\n        if (length > 0) {\r\n            StringData = new String[length];\r\n            String tempStr;\r\n            Object obj = new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count = 0; count < length; count++) {\r\n                try {\r\n                    tempStr = f[count] + \"=\" + f[count].get(obj);\r\n                    StringData[count] = tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray = null;\r\n        if (cMethods != null) {\r\n            tempArray = new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug && tempArray == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods == null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = cMethods;\r\n        StringList tempList = new StringList();\r\n        for (int i = 0; i < cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + '.') != -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data = tempList.toArray();\r\n        else\r\n            data = null;\r\n        if (debug && data == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr = c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(constr);\r\n        if (debug && data == null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter = c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(inter);\r\n        if (c != java.lang.Object.class && !c.isInterface()) {\r\n            Class superC = c.getSuperclass();\r\n            TreeSet<String> hInterfaces = new TreeSet<String>();\r\n            int i = 0;\r\n            if (data != null)\r\n                for (i = 0; i < data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC != null && superC != java.lang.Object.class) {\r\n                inter = superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data = getData(inter);\r\n                if (data != null)\r\n                    for (i = 0; i < data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC = superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() != 0) {\r\n                data = new String[hInterfaces.size()];\r\n                Iterator it = hInterfaces.iterator();\r\n                i = 0;\r\n                while (it.hasNext()) {\r\n                    data[i] = (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug && data == null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].toString();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].getName();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods == null || pos > fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn't out of range\r\n            String tempStr = fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end = tempStr.indexOf(\")\");\r\n                tempStr = tempStr.substring(0, end + 1);\r\n                begin = tempStr.lastIndexOf(\" \");\r\n                tempStr = tempStr.substring(begin + 1, tempStr.length());\r\n                begin = tempStr.indexOf(\"(\");\r\n                end = tempStr.lastIndexOf(\".\", begin);\r\n                className = tempStr.substring(0, end);\r\n                methodName = tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className=\" + className);\r\n                methClass = ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass=\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr = name;\r\n        Class tempClass = null;\r\n        tempClass = tryClass(name);\r\n        if (tempClass == null) {\r\n            for (int i = 0; i < knownPackages.length; i++) {\r\n                tempStr = knownPackages[i] + name;\r\n                tempClass = tryClass(tempStr);\r\n                if (tempClass != null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass = null;\r\n        try {\r\n            if (name != null)\r\n                tempClass = Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c != java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 = System.currentTimeMillis();\r\n        debug = true;\r\n        String name = null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length > 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name = args[1];\r\n            } else {\r\n                name = args[0];\r\n                try {\r\n                    myClassInfo = new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo = new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
        "test_prompt": "// ClassInfo_3Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#printConstructors()} method.\n*/\nclass ClassInfo_3Test {",
        "original_generated_code": "\n\t\tprivate ClassInfo myClassInfo;\n\t\t\n\t\tprivate String[] cMethods;\n\t\t\n\t\tprivate String[] fndMethods;\n\t\t\n\t\tprivate String[] cConstructors;\n\t\t\n\t\tprivate String[] fndConstructors;\n\t\t\n\t\tprivate String[] cInterfaces;\n\t\t\n\t\tprivate String[] fndInterfaces;\n\t\t\n\t\tprivate String[] cFields;\n\t\t\n\t\tprivate String[] fndFields;\n\t\t\n\t\tprivate String[] cPackages;\n\t\t\n\t\tprivate String[] fndPackages;\n\t\t\n\t\tprivate String[] cClasses;\n\t\t\n\t\tprivate String[] fndClasses;\n\t\t\n\t\tprivate String[] cSuperClasses;\n\t\t\n\t\tprivate String[] fndSuperClasses;\n\t\t\n\t\tprivate String[] cSuperPackages;\n\t\t\n\t\tprivate String[] fndSuperPackages;\n\t\t\n\t\tprivate String[] cSuperInterfaces;\n\t\t\n\t\tprivate String[] fndSuperInterfaces;\n\t\t\n\t\tprivate String[] cSuperFields;\n\t\t\n\t\tprivate String[] fndSuperFields;\n\t\t\n\t\tprivate String[] cSuperMethods;\n\t\t\n\t\tprivate String[] fndSuperMethods;\n\t\t\n\t\tprivate String[] cSuperConstructors;\n\t\t\n\t\tprivate String[] fndSuperConstructors;\n\t\t\n\t\tprivate String[] cSuperClasses2;\n\t\t\n\t\tprivate String[] fndSuperClasses2;\n\t\t\n\t\tprivate String[] cSuperPackages2;\n\t\t\n\t\tprivate String[] fndSuperPackages2;\n\t\t\n\t\tprivate String[] cSuperInterfaces2;\n\t\t\n\t\tprivate String[] fndSuperInterfaces2;\n\t\t\n\t\tprivate String[] cSuperFields2;\n\t\t\n\t\tprivate String[] fndSuperFields2;\n\t\t\n\t\tprivate String[] cSuperMethods2;\n\t\t\n\t\tprivate String[] fndSuperMethods2;\n\t\t\n\t\tprivate String[] cSuperConstructors2;\n\t\t\n\t\tprivate String[] fndSuperConstructors2;\n\t\t\n\t\tprivate String[] cSuperClasses3;\n\t\t\n\t\tprivate String[] fndSuperClasses3;\n\t\t\n\t\tprivate String[] cSuperPackages3;\n\t\t\n\t\tprivate String[] fndSuperPackages3;\n\t\t\n\t\tprivate String[] cSuperInterfaces3;\n\t\t\n\t\tprivate String[] fndSuperInterfaces3;\n\t\t\n\t\tprivate String[] cSuperFields3;\n\t\t\n\t\tprivate String[] fndSuperFields3;\n\t\t\n\t\tprivate String[] cSuperMethods3;\n\t\t\n\t\tprivate String[] fndSuperMethods3;\n\t\t\n\t\tprivate String[] cSuperConstructors3;\n\t\t\n\t\tprivate String[] fndSuperConstructors3;\n\t\t\n\t\tprivate String[] cSuperClasses4;\n\t\t\n\t\tprivate String[] fndSuperClasses4;\n\t\t\n\t\tprivate String[] cSuperPackages4;\n\t\t\n\t\tprivate String[] fndSuperPackages4;\n\t\t\n\t\tprivate String[] cSuperInterfaces4;\n\t\t\n\t\tprivate String[] fndSuperInterfaces4;\n\t\t\n\t\tprivate String[] cSuperFields4;\n\t\t\n\t\tprivate String[] fndSuperFields4;\n\t\t\n\t\tprivate String[] cSuperMethods4;\n\t\t\n\t\tprivate String[] fndSuperMethods4;\n\t\t\n\t\tprivate String[] cSuperConstructors4;\n\t\t\n\t\tprivate String[] fndSuperConstructors4;\n\t\t\n\t\tprivate String[] cSuperClasses5;\n\t\t\n\t\tprivate String[] fndSuperClasses5;\n\t\t\n\t\tprivate String[] cSuperPackages5;\n\t\t\n\t\tprivate String[] fndSuperPackages5;\n\t\t\n\t\tprivate String[] cSuperInterfaces5;\n\t\t\n\t\tprivate String[] fndSuperInterfaces5;\n\t\t\n\t\tprivate String[] cSuperFields5;\n\t\t\n\t\tprivate String[] fndSuperFields5;\n\t\t\n\t\tprivate String[] cSuperMethods5;\n\t\t\n\t\tprivate String[] fndSuperMethods5;\n\t\t\n\t\tprivate String[] cSuperConstructors5;\n\t\t\n\t\tprivate String[] fndSuperConstructors5;\n\t\t\n\t\tprivate String[] cSuperClasses6;\n\t\t\n\t\tprivate String[] fndSuperClasses6;\n\t\t\n\t\tprivate String[] cSuperPackages6;\n\t\t\n\t\tprivate String[] fndSuperPackages6;\n\t\t\n\t\tprivate String[] cSuperInterfaces6;\n\t\t\n\t\tprivate String[] fndSuperInterfaces6;\n\t\t\n\t\tprivate String[] cSuperFields6;\n\t\t\n\t\tprivate String[] fndSuperFields6;\n\t\t\n\t\tprivate String[] cSuperMethods6;\n\t\t\n\t\tprivate String[] fndSuperMethods6;\n\t\t\n\t\tprivate String[] cSuperConstructors6;\n\t\t\n\t\tprivate String[] fndSuperConstructors6;\n\t\t\n\t\tprivate String[] cSuperClasses7;\n\t\t\n\t\tprivate String[] fndSuperClasses7;\n\t\t\n\t\tprivate String[] cSuperPackages7;\n\t\t\n\t\tprivate String[] fndSuperPackages7;\n\t\t\n\t\tprivate String[] cSuperInterfaces7;\n\t\t\n\t\tprivate String[] fndSuperInterfaces7;\n\t\t\n\t\tprivate String[] cSuperFields7;\n\t\t\n\t\tprivate String[] fndSuperFields7;\n\t\t\n\t\tprivate String[] cSuperMethods7;\n\t\t\n\t\tprivate String[] fndSuperMethods7;\n\t\t\n\t\tprivate String[] cSuperConstructors7;\n\t\t\n\t\tprivate String[] fndSuperConstructors7;\n\t\t\n\t\tprivate String[] cSuperClasses8;\n\t\t\n\t\tprivate String[] fndSuperClasses8;\n\t\t\n\t\tprivate String[] cSuperPackages8;\n\t\t\n\t\tprivate String[] fndSuperPackages8;\n\t\t\n\t\tprivate String[] cSuperInterfaces8;\n\t\t\n\t\tprivate String[] fndSuperInterfaces8;\n\t\t\n\t\tprivate String[] cSuperFields8;\n\t\t\n\t\tprivate String[] fndSuperFields8;\n\t\t\n\t\tprivate String[] cSuperMethods8;\n\t\t\n\t\tprivate String[] fndSuperMethods8;\n\t\t\n\t\tprivate String[] cSuperConstructors8;\n\t\t\n\t\tprivate String[] fndSuperConstructors8;\n\t\t\n\t\tprivate String[] cSuperClasses9;\n\t\t\n\t\tprivate String[] fndSuperClasses9;\n\t\t\n\t\tprivate String[] cSuperPackages9;\n\t\t\n\t\tprivate String[] fndSuperPackages9;\n\t\t\n\t\tprivate String[] cSuperInterfaces9;\n\t\t\n\t\tprivate String[] fndSuperInterfaces9;\n\t\t\n\t\tprivate String[] cSuperFields9;\n\t\t\n\t\tprivate String[] fndSuperFields9;\n\t\t\n\t\tprivate String[] cSuperMethods9;\n\t\t\n\t\tprivate String[] fndSuperMethods9;\n\t\t\n\t\tprivate String[] cSuperConstructors9;\n\t\t\n\t\tprivate String[] fndSuperConstructors9;\n\t\t\n\t\tprivate String[] cSuperClasses10;\n\t\t\n\t\tprivate String[] fndSuperClasses10;\n\t\t\n\t\tprivate String[] cSuperPackages10;\n\t\t\n\t\tprivate String[] fndSuperPackages10;\n\t\t\n\t\tprivate String[] cSuperInterfaces10;\n\t\t\n\t\tprivate String[] fndSuperInterfaces10;\n\t\t\n\t\tprivate String[] cSuperFields10;\n\t\t\n\t\tprivate String[] fndSuperFields10;\n\t\t\n\t\tprivate String[] cSuperMethods10;\n\t\t\n\t\tprivate String[] fndSuperMethods10;\n\t\t\n\t\tprivate String[] cSuperConstructors10;\n\t\t\n\t\tprivate String[] fndSuperConstructors10;\n\t",
        "applied_heuristics": "H7"
    },
    {
        "id": "cmpl-6wSBOTZR1SsSsAhkilyv0ammzQjkJ",
        "object": "text_completion",
        "created": 1679389378,
        "model": "code-davinci-002",
        "choices": [
            {
                "text": "// ClassInfo_4Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#printInterfaces()} method.\n*/\nclass ClassInfo_4Test {\n\t\t\n\t\tprivate ClassInfo ci;\n\t\t\n\t\tprivate String[] interfaces;\n\t\t\n\t\tprivate String[] expected;\n\t\t\n\t\tprivate String[] actual;\n\t\t\n\t\tprivate String[] expected2;\n\t\t\n\t\tprivate String[] actual2;\n\t\t\n\t\tprivate String[] expected3;\n\t\t\n\t\tprivate String[] actual3;\n\t\t\n\t\tprivate String[] expected4;\n\t\t\n\t\tprivate String[] actual4;\n\t\t\n\t\tprivate String[] expected5;\n\t\t\n\t\tprivate String[] actual5;\n\t\t\n\t\tprivate String[] expected6;\n\t\t\n\t\tprivate String[] actual6;\n\t\t\n\t\tprivate String[] expected7;\n\t\t\n\t\tprivate String[] actual7;\n\t\t\n\t\tprivate String[] expected8;\n\t\t\n\t\tprivate String[] actual8;\n\t\t\n\t\tprivate String[] expected9;\n\t\t\n\t\tprivate String[] actual9;\n\t\t\n\t\tprivate String[] expected10;\n\t\t\n\t\tprivate String[] actual10;\n\t\t\n\t\tprivate String[] expected11;\n\t\t\n\t\tprivate String[] actual11;\n\t\t\n\t\tprivate String[] expected12;\n\t\t\n\t\tprivate String[] actual12;\n\t\t\n\t\tprivate String[] expected13;\n\t\t\n\t\tprivate String[] actual13;\n\t\t\n\t\tprivate String[] expected14;\n\t\t\n\t\tprivate String[] actual14;\n\t\t\n\t\tprivate String[] expected15;\n\t\t\n\t\tprivate String[] actual15;\n\t\t\n\t\tprivate String[] expected16;\n\t\t\n\t\tprivate String[] actual16;\n\t\t\n\t\tprivate String[] expected17;\n\t\t\n\t\tprivate String[] actual17;\n\t\t\n\t\tprivate String[] expected18;\n\t\t\n\t\tprivate String[] actual18;\n\t\t\n\t\tprivate String[] expected19;\n\t\t\n\t\tprivate String[] actual19;\n\t\t\n\t\tprivate String[] expected20;\n\t\t\n\t\tprivate String[] actual20;\n\t\t\n\t\tprivate String[] expected21;\n\t\t\n\t\tprivate String[] actual21;\n\t\t\n\t\tprivate String[] expected22;\n\t\t\n\t\tprivate String[] actual22;\n\t\t\n\t\tprivate String[] expected23;\n\t\t\n\t\tprivate String[] actual23;\n\t\t\n\t\tprivate String[] expected24;\n\t\t\n\t\tprivate String[] actual24;\n\t\t\n\t\tprivate String[] expected25;\n\t\t\n\t\tprivate String[] actual25;\n\t\t\n\t\tprivate String[] expected26;\n\t\t\n\t\tprivate String[] actual26;\n\t\t\n\t\tprivate String[] expected27;\n\t\t\n\t\tprivate String[] actual27;\n\t\t\n\t\tprivate String[] expected28;\n\t\t\n\t\tprivate String[] actual28;\n\t\t\n\t\tprivate String[] expected29;\n\t\t\n\t\tprivate String[] actual29;\n\t\t\n\t\tprivate String[] expected30;\n\t\t\n\t\tprivate String[] actual30;\n\t\t\n\t\tprivate String[] expected31;\n\t\t\n\t\tprivate String[] actual31;\n\t\t\n\t\tprivate String[] expected32;\n\t\t\n\t\tprivate String[] actual32;\n\t\t\n\t\tprivate String[] expected33;\n\t\t\n\t\tprivate String[] actual33;\n\t\t\n\t\tprivate String[] expected34;\n\t\t\n\t\tprivate String[] actual34;\n\t\t\n\t\tprivate String[] expected35;\n\t\t\n\t\tprivate String[] actual35;\n\t\t\n\t\tprivate String[] expected36;\n\t\t\n\t\tprivate String[] actual36;\n\t\t\n\t\tprivate String[] expected37;\n\t\t\n\t\tprivate String[] actual37;\n\t\t\n\t\tprivate String[] expected38;\n\t\t\n\t\tprivate String[] actual38;\n\t\t\n\t\tprivate String[] expected39;\n\t\t\n\t\tprivate String[] actual39;\n\t\t\n\t\tprivate String[] expected40;\n\t\t\n\t\tprivate String[] actual40;\n\t\t\n\t\tprivate String[] expected41;\n\t\t\n\t\tprivate String[] actual41;\n\t\t\n\t\tprivate String[] expected42;\n\t\t\n\t\tprivate String[] actual42;\n\t\t\n\t\tprivate String[] expected43;\n\t\t\n\t\tprivate String[] actual43;\n\t\t\n\t\tprivate String[] expected44;\n\t\t\n\t\tprivate String[] actual44;\n\t\t\n\t\tprivate String[] expected45;\n\t\t\n\t\tprivate String[] actual45;\n\t\t\n\t\tprivate String[] expected46;\n\t\t\n\t\tprivate String[] actual46;\n\t\t\n\t\tprivate String[] expected47;\n\t\t\n\t\tprivate String[] actual47;\n\t\t\n\t\tprivate String[] expected48;\n\t\t\n\t\tprivate String[] actual48;\n\t\t\n\t\tprivate String[] expected49;\n\t\t\n\t\tprivate String[] actual49;\n\t\t\n\t\tprivate String[] expected50;\n\t\t\n\t\tprivate String[] actual50;\n\t\t\n\t\tprivate String[] expected51;\n\t\t\n\t\tprivate String[] actual51;\n\t\t\n\t\tprivate String[] expected52;\n\t\t\n\t\tprivate String[] actual52;\n\t\t\n\t\tprivate String[] expected53;\n\t\t\n\t\tprivate String[] actual53;\n\t\t\n\t\tprivate String[] expected54;\n\t\t\n\t\tprivate String[] actual54;\n\t\t\n\t\tprivate String[] expected55;\n\t\t\n\t\tprivate String[] actual55;\n\t\t\n\t\tprivate String[] expected56;\n\t\t\n\t\tprivate String[] actual56;\n\t\t\n\t\tprivate String[] expected57;\n\t\t\n\t\tprivate String[] actual57;\n\t\t\n\t\tprivate String[] expected58;\n\t\t\n\t\tprivate String[] actual58;\n\t\t\n\t\tprivate String[] expected59;\n\t\t\n\t\tprivate String[] actual59;\n\t\t\n\t\tprivate String[] expected60;\n\t\t\n\t\tprivate String[] actual60;\n\t\t\n\t\tprivate String[] expected61;\n\t\t\n\t\tprivate String[] actual61;\n\t\t\n\t\tprivate String[] expected62;\n\t\t\n\t\tprivate String[] actual62;\n\t\t\n\t\tprivate String[] expected63;\n\t\t\n\t\tprivate String[] actual63;\n\t\t\n\t\tprivate String[] expected64;\n\t\t\n\t\tprivate String[] actual64;\n\t\t\n\t\tprivate String[] expected65;\n\t\t\n\t\tprivate String[] actual65;\n\t\t\n\t\tprivate String[] expected66;\n\t\t\n\t\tprivate String[] actual66;\n\t\t\n\t\tprivate String[] expected67;\n\t\t\n\t\tprivate String[] actual67;\n\t\t\n\t\tprivate String[] expected68;\n\t\t\n\t\tprivate String[] actual68;\n\t\t\n\t\tprivate String[] expected69;\n\t\t\n\t\tprivate String[] actual69;\n\t\t\n\t\tprivate String[] expected70;\n\t\t\n\t\tprivate String[] actual70;\n\t\t\n\t\tprivate String[] expected71;\n\t\t\n\t\tprivate String[] actual71;\n\t\t\n\t\tprivate String[] expected72;\n\t\t\n\t\tprivate String[] actual72;\n\t\t\n\t\tprivate String[] expected73;\n\t\t\n\t\tprivate String[] actual73;\n\t\t\n\t\tprivate String[] expected74;\n\t\t\n\t\tprivate String[] actual74;\n\t\t\n\t\tprivate String[] expected75;\n\t\t\n\t\tprivate String[] actual75;\n\t\t\n\t\tprivate String[] expected76;\n\t\t\n\t\tprivate String[] actual76;\n\t\t\n\t\tprivate String[] expected77;\n\t\t\n\t\tprivate String[] actual77;\n\t\t\n\t\tprivate String[] expected78;\n\t\t\n\t\tprivate String[] actual78;\n\t\t\n\t\tprivate String[] expected79;\n\t\t\n\t\tprivate String[] actual79;\n\t\t\n\t\tprivate String[] expected80;\n\t\t\n\t\tprivate String[] actual80;\n\t\t\n\t\tprivate String[] expected81;\n\t\t\n\t\tprivate String[] actual81;\n\t\t\n\t\tprivate String[] expected82;\n\t\t\n\t\tprivate String[] actual82;\n\t\t\n\t\tprivate String[] expected83;\n}",
                "index": 0,
                "logprobs": null,
                "finish_reason": "length"
            }
        ],
        "usage": {
            "prompt_tokens": 5836,
            "completion_tokens": 2000,
            "total_tokens": 7836
        },
        "time_taken": 71.08352708816528,
        "prompt_id": "/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_4Test.java",
        "original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * <p>\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c = javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;\r\n\r\n    private String[] cMethods, fndMethods = null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() != null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c != java.lang.Object.class && !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan = locManager;\r\n        knownPackages = dirMan.getPackageList();\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f = c.getFields();\r\n        length = f.length;\r\n        String[] StringData = null;\r\n        if (length > 0) {\r\n            StringData = new String[length];\r\n            String tempStr;\r\n            Object obj = new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count = 0; count < length; count++) {\r\n                try {\r\n                    tempStr = f[count] + \"=\" + f[count].get(obj);\r\n                    StringData[count] = tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray = null;\r\n        if (cMethods != null) {\r\n            tempArray = new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug && tempArray == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods == null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = cMethods;\r\n        StringList tempList = new StringList();\r\n        for (int i = 0; i < cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + '.') != -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data = tempList.toArray();\r\n        else\r\n            data = null;\r\n        if (debug && data == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr = c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(constr);\r\n        if (debug && data == null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter = c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(inter);\r\n        if (c != java.lang.Object.class && !c.isInterface()) {\r\n            Class superC = c.getSuperclass();\r\n            TreeSet<String> hInterfaces = new TreeSet<String>();\r\n            int i = 0;\r\n            if (data != null)\r\n                for (i = 0; i < data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC != null && superC != java.lang.Object.class) {\r\n                inter = superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data = getData(inter);\r\n                if (data != null)\r\n                    for (i = 0; i < data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC = superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() != 0) {\r\n                data = new String[hInterfaces.size()];\r\n                Iterator it = hInterfaces.iterator();\r\n                i = 0;\r\n                while (it.hasNext()) {\r\n                    data[i] = (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug && data == null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].toString();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].getName();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods == null || pos > fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn't out of range\r\n            String tempStr = fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end = tempStr.indexOf(\")\");\r\n                tempStr = tempStr.substring(0, end + 1);\r\n                begin = tempStr.lastIndexOf(\" \");\r\n                tempStr = tempStr.substring(begin + 1, tempStr.length());\r\n                begin = tempStr.indexOf(\"(\");\r\n                end = tempStr.lastIndexOf(\".\", begin);\r\n                className = tempStr.substring(0, end);\r\n                methodName = tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className=\" + className);\r\n                methClass = ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass=\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr = name;\r\n        Class tempClass = null;\r\n        tempClass = tryClass(name);\r\n        if (tempClass == null) {\r\n            for (int i = 0; i < knownPackages.length; i++) {\r\n                tempStr = knownPackages[i] + name;\r\n                tempClass = tryClass(tempStr);\r\n                if (tempClass != null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass = null;\r\n        try {\r\n            if (name != null)\r\n                tempClass = Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c != java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 = System.currentTimeMillis();\r\n        debug = true;\r\n        String name = null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length > 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name = args[1];\r\n            } else {\r\n                name = args[0];\r\n                try {\r\n                    myClassInfo = new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo = new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
        "test_prompt": "// ClassInfo_4Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#printInterfaces()} method.\n*/\nclass ClassInfo_4Test {",
        "original_generated_code": "\n\t\tprivate ClassInfo ci;\n\t\t\n\t\tprivate String[] interfaces;\n\t\t\n\t\tprivate String[] expected;\n\t\t\n\t\tprivate String[] actual;\n\t\t\n\t\tprivate String[] expected2;\n\t\t\n\t\tprivate String[] actual2;\n\t\t\n\t\tprivate String[] expected3;\n\t\t\n\t\tprivate String[] actual3;\n\t\t\n\t\tprivate String[] expected4;\n\t\t\n\t\tprivate String[] actual4;\n\t\t\n\t\tprivate String[] expected5;\n\t\t\n\t\tprivate String[] actual5;\n\t\t\n\t\tprivate String[] expected6;\n\t\t\n\t\tprivate String[] actual6;\n\t\t\n\t\tprivate String[] expected7;\n\t\t\n\t\tprivate String[] actual7;\n\t\t\n\t\tprivate String[] expected8;\n\t\t\n\t\tprivate String[] actual8;\n\t\t\n\t\tprivate String[] expected9;\n\t\t\n\t\tprivate String[] actual9;\n\t\t\n\t\tprivate String[] expected10;\n\t\t\n\t\tprivate String[] actual10;\n\t\t\n\t\tprivate String[] expected11;\n\t\t\n\t\tprivate String[] actual11;\n\t\t\n\t\tprivate String[] expected12;\n\t\t\n\t\tprivate String[] actual12;\n\t\t\n\t\tprivate String[] expected13;\n\t\t\n\t\tprivate String[] actual13;\n\t\t\n\t\tprivate String[] expected14;\n\t\t\n\t\tprivate String[] actual14;\n\t\t\n\t\tprivate String[] expected15;\n\t\t\n\t\tprivate String[] actual15;\n\t\t\n\t\tprivate String[] expected16;\n\t\t\n\t\tprivate String[] actual16;\n\t\t\n\t\tprivate String[] expected17;\n\t\t\n\t\tprivate String[] actual17;\n\t\t\n\t\tprivate String[] expected18;\n\t\t\n\t\tprivate String[] actual18;\n\t\t\n\t\tprivate String[] expected19;\n\t\t\n\t\tprivate String[] actual19;\n\t\t\n\t\tprivate String[] expected20;\n\t\t\n\t\tprivate String[] actual20;\n\t\t\n\t\tprivate String[] expected21;\n\t\t\n\t\tprivate String[] actual21;\n\t\t\n\t\tprivate String[] expected22;\n\t\t\n\t\tprivate String[] actual22;\n\t\t\n\t\tprivate String[] expected23;\n\t\t\n\t\tprivate String[] actual23;\n\t\t\n\t\tprivate String[] expected24;\n\t\t\n\t\tprivate String[] actual24;\n\t\t\n\t\tprivate String[] expected25;\n\t\t\n\t\tprivate String[] actual25;\n\t\t\n\t\tprivate String[] expected26;\n\t\t\n\t\tprivate String[] actual26;\n\t\t\n\t\tprivate String[] expected27;\n\t\t\n\t\tprivate String[] actual27;\n\t\t\n\t\tprivate String[] expected28;\n\t\t\n\t\tprivate String[] actual28;\n\t\t\n\t\tprivate String[] expected29;\n\t\t\n\t\tprivate String[] actual29;\n\t\t\n\t\tprivate String[] expected30;\n\t\t\n\t\tprivate String[] actual30;\n\t\t\n\t\tprivate String[] expected31;\n\t\t\n\t\tprivate String[] actual31;\n\t\t\n\t\tprivate String[] expected32;\n\t\t\n\t\tprivate String[] actual32;\n\t\t\n\t\tprivate String[] expected33;\n\t\t\n\t\tprivate String[] actual33;\n\t\t\n\t\tprivate String[] expected34;\n\t\t\n\t\tprivate String[] actual34;\n\t\t\n\t\tprivate String[] expected35;\n\t\t\n\t\tprivate String[] actual35;\n\t\t\n\t\tprivate String[] expected36;\n\t\t\n\t\tprivate String[] actual36;\n\t\t\n\t\tprivate String[] expected37;\n\t\t\n\t\tprivate String[] actual37;\n\t\t\n\t\tprivate String[] expected38;\n\t\t\n\t\tprivate String[] actual38;\n\t\t\n\t\tprivate String[] expected39;\n\t\t\n\t\tprivate String[] actual39;\n\t\t\n\t\tprivate String[] expected40;\n\t\t\n\t\tprivate String[] actual40;\n\t\t\n\t\tprivate String[] expected41;\n\t\t\n\t\tprivate String[] actual41;\n\t\t\n\t\tprivate String[] expected42;\n\t\t\n\t\tprivate String[] actual42;\n\t\t\n\t\tprivate String[] expected43;\n\t\t\n\t\tprivate String[] actual43;\n\t\t\n\t\tprivate String[] expected44;\n\t\t\n\t\tprivate String[] actual44;\n\t\t\n\t\tprivate String[] expected45;\n\t\t\n\t\tprivate String[] actual45;\n\t\t\n\t\tprivate String[] expected46;\n\t\t\n\t\tprivate String[] actual46;\n\t\t\n\t\tprivate String[] expected47;\n\t\t\n\t\tprivate String[] actual47;\n\t\t\n\t\tprivate String[] expected48;\n\t\t\n\t\tprivate String[] actual48;\n\t\t\n\t\tprivate String[] expected49;\n\t\t\n\t\tprivate String[] actual49;\n\t\t\n\t\tprivate String[] expected50;\n\t\t\n\t\tprivate String[] actual50;\n\t\t\n\t\tprivate String[] expected51;\n\t\t\n\t\tprivate String[] actual51;\n\t\t\n\t\tprivate String[] expected52;\n\t\t\n\t\tprivate String[] actual52;\n\t\t\n\t\tprivate String[] expected53;\n\t\t\n\t\tprivate String[] actual53;\n\t\t\n\t\tprivate String[] expected54;\n\t\t\n\t\tprivate String[] actual54;\n\t\t\n\t\tprivate String[] expected55;\n\t\t\n\t\tprivate String[] actual55;\n\t\t\n\t\tprivate String[] expected56;\n\t\t\n\t\tprivate String[] actual56;\n\t\t\n\t\tprivate String[] expected57;\n\t\t\n\t\tprivate String[] actual57;\n\t\t\n\t\tprivate String[] expected58;\n\t\t\n\t\tprivate String[] actual58;\n\t\t\n\t\tprivate String[] expected59;\n\t\t\n\t\tprivate String[] actual59;\n\t\t\n\t\tprivate String[] expected60;\n\t\t\n\t\tprivate String[] actual60;\n\t\t\n\t\tprivate String[] expected61;\n\t\t\n\t\tprivate String[] actual61;\n\t\t\n\t\tprivate String[] expected62;\n\t\t\n\t\tprivate String[] actual62;\n\t\t\n\t\tprivate String[] expected63;\n\t\t\n\t\tprivate String[] actual63;\n\t\t\n\t\tprivate String[] expected64;\n\t\t\n\t\tprivate String[] actual64;\n\t\t\n\t\tprivate String[] expected65;\n\t\t\n\t\tprivate String[] actual65;\n\t\t\n\t\tprivate String[] expected66;\n\t\t\n\t\tprivate String[] actual66;\n\t\t\n\t\tprivate String[] expected67;\n\t\t\n\t\tprivate String[] actual67;\n\t\t\n\t\tprivate String[] expected68;\n\t\t\n\t\tprivate String[] actual68;\n\t\t\n\t\tprivate String[] expected69;\n\t\t\n\t\tprivate String[] actual69;\n\t\t\n\t\tprivate String[] expected70;\n\t\t\n\t\tprivate String[] actual70;\n\t\t\n\t\tprivate String[] expected71;\n\t\t\n\t\tprivate String[] actual71;\n\t\t\n\t\tprivate String[] expected72;\n\t\t\n\t\tprivate String[] actual72;\n\t\t\n\t\tprivate String[] expected73;\n\t\t\n\t\tprivate String[] actual73;\n\t\t\n\t\tprivate String[] expected74;\n\t\t\n\t\tprivate String[] actual74;\n\t\t\n\t\tprivate String[] expected75;\n\t\t\n\t\tprivate String[] actual75;\n\t\t\n\t\tprivate String[] expected76;\n\t\t\n\t\tprivate String[] actual76;\n\t\t\n\t\tprivate String[] expected77;\n\t\t\n\t\tprivate String[] actual77;\n\t\t\n\t\tprivate String[] expected78;\n\t\t\n\t\tprivate String[] actual78;\n\t\t\n\t\tprivate String[] expected79;\n\t\t\n\t\tprivate String[] actual79;\n\t\t\n\t\tprivate String[] expected80;\n\t\t\n\t\tprivate String[] actual80;\n\t\t\n\t\tprivate String[] expected81;\n\t\t\n\t\tprivate String[] actual81;\n\t\t\n\t\tprivate String[] expected82;\n\t\t\n\t\tprivate String[] actual82;\n\t\t\n\t\tprivate String[] expected83;\n\t",
        "applied_heuristics": "H7"
    },
    {
        "id": "cmpl-6wSCXtMlk3MhGV9yclTJFZ4vZJ5gk",
        "object": "text_completion",
        "created": 1679389449,
        "model": "code-davinci-002",
        "choices": [
            {
                "text": "// ClassInfo_5Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#getData(Member[])} method.\n*/\nclass ClassInfo_5Test {\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Member[])} method.\n\t\t* It tests the method with a null array.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_1() {\n\t\t\t\tMember[] m = null;\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertNull(result);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Member[])} method.\n\t\t* It tests the method with an empty array.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_2() {\n\t\t\t\tMember[] m = new Member[0];\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertNull(result);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Member[])} method.\n\t\t* It tests the method with an array of one element.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_3() {\n\t\t\t\tMember[] m = new Member[1];\n\t\t\t\tm[0] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertEquals(1, result.length);\n\t\t\t\tassertEquals(\"test\", result[0]);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Member[])} method.\n\t\t* It tests the method with an array of two elements.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_4() {\n\t\t\t\tMember[] m = new Member[2];\n\t\t\t\tm[0] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tm[1] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test2\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertEquals(2, result.length);\n\t\t\t\tassertEquals(\"test\", result[0]);\n\t\t\t\tassertEquals(\"test2\", result[1]);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Member[])} method.\n\t\t* It tests the method with an array of three elements.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_5() {\n\t\t\t\tMember[] m = new Member[3];\n\t\t\t\tm[0] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tm[1] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test2\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tm[2] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test3\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertEquals(3, result.length);\n\t\t\t\tassertEquals(\"test\", result[0]);\n\t\t\t\tassertEquals(\"test2\", result[1]);\n\t\t\t\tassertEquals(\"test3\", result[2]);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Member[])} method.\n\t\t* It tests the method with an array of four elements.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_6() {\n\t\t\t\tMember[] m = new Member[4];\n\t\t\t\tm[0] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tm[1] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test2\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tm[2] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test3\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tm[3] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test4\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertEquals(4, result.length);\n\t\t\t\tassertEquals(\"test\", result[0]);\n\t\t\t\tassertEquals(\"test2\", result[1]);\n\t\t\t\tassertEquals(\"test3\", result[2]);\n\t\t\t\tassertEquals(\"test4\", result[3]);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Member[])} method.\n\t\t* It tests the method with an array of five elements.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_7() {\n\t\t\t\tMember[] m = new Member[5];\n\t\t\t\tm[0] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tm[1] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test2\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tm[2] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test3\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tm[3] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test4\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tm[4] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test5\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertEquals(5, result.length);\n\t\t\t\tassertEquals(\"test\", result[0]);\n\t\t\t\tassertEquals(\"test2\", result[1]);\n\t\t\t\tassertEquals(\"test3\", result[2]);\n\t\t\t\tassertEquals(\"test4\", result[3]);\n\t\t\t\tassertEquals(\"test5\", result[4]);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Member[])} method.\n\t\t* It tests the method with an array of six elements.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_8() {\n\t\t\t\tMember[] m = new Member[6];\n\t\t\t\tm[0] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n}\n}",
                "index": 0,
                "logprobs": null,
                "finish_reason": "length"
            }
        ],
        "usage": {
            "prompt_tokens": 5838,
            "completion_tokens": 2000,
            "total_tokens": 7838
        },
        "time_taken": 61.3284387588501,
        "prompt_id": "/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_5Test.java",
        "original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * <p>\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c = javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;\r\n\r\n    private String[] cMethods, fndMethods = null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() != null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c != java.lang.Object.class && !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan = locManager;\r\n        knownPackages = dirMan.getPackageList();\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f = c.getFields();\r\n        length = f.length;\r\n        String[] StringData = null;\r\n        if (length > 0) {\r\n            StringData = new String[length];\r\n            String tempStr;\r\n            Object obj = new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count = 0; count < length; count++) {\r\n                try {\r\n                    tempStr = f[count] + \"=\" + f[count].get(obj);\r\n                    StringData[count] = tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray = null;\r\n        if (cMethods != null) {\r\n            tempArray = new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug && tempArray == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods == null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = cMethods;\r\n        StringList tempList = new StringList();\r\n        for (int i = 0; i < cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + '.') != -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data = tempList.toArray();\r\n        else\r\n            data = null;\r\n        if (debug && data == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr = c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(constr);\r\n        if (debug && data == null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter = c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(inter);\r\n        if (c != java.lang.Object.class && !c.isInterface()) {\r\n            Class superC = c.getSuperclass();\r\n            TreeSet<String> hInterfaces = new TreeSet<String>();\r\n            int i = 0;\r\n            if (data != null)\r\n                for (i = 0; i < data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC != null && superC != java.lang.Object.class) {\r\n                inter = superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data = getData(inter);\r\n                if (data != null)\r\n                    for (i = 0; i < data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC = superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() != 0) {\r\n                data = new String[hInterfaces.size()];\r\n                Iterator it = hInterfaces.iterator();\r\n                i = 0;\r\n                while (it.hasNext()) {\r\n                    data[i] = (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug && data == null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].toString();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].getName();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods == null || pos > fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn't out of range\r\n            String tempStr = fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end = tempStr.indexOf(\")\");\r\n                tempStr = tempStr.substring(0, end + 1);\r\n                begin = tempStr.lastIndexOf(\" \");\r\n                tempStr = tempStr.substring(begin + 1, tempStr.length());\r\n                begin = tempStr.indexOf(\"(\");\r\n                end = tempStr.lastIndexOf(\".\", begin);\r\n                className = tempStr.substring(0, end);\r\n                methodName = tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className=\" + className);\r\n                methClass = ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass=\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr = name;\r\n        Class tempClass = null;\r\n        tempClass = tryClass(name);\r\n        if (tempClass == null) {\r\n            for (int i = 0; i < knownPackages.length; i++) {\r\n                tempStr = knownPackages[i] + name;\r\n                tempClass = tryClass(tempStr);\r\n                if (tempClass != null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass = null;\r\n        try {\r\n            if (name != null)\r\n                tempClass = Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c != java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 = System.currentTimeMillis();\r\n        debug = true;\r\n        String name = null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length > 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name = args[1];\r\n            } else {\r\n                name = args[0];\r\n                try {\r\n                    myClassInfo = new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo = new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
        "test_prompt": "// ClassInfo_5Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#getData(Member[])} method.\n*/\nclass ClassInfo_5Test {",
        "original_generated_code": "\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Member[])} method.\n\t\t* It tests the method with a null array.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_1() {\n\t\t\t\tMember[] m = null;\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertNull(result);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Member[])} method.\n\t\t* It tests the method with an empty array.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_2() {\n\t\t\t\tMember[] m = new Member[0];\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertNull(result);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Member[])} method.\n\t\t* It tests the method with an array of one element.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_3() {\n\t\t\t\tMember[] m = new Member[1];\n\t\t\t\tm[0] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertEquals(1, result.length);\n\t\t\t\tassertEquals(\"test\", result[0]);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Member[])} method.\n\t\t* It tests the method with an array of two elements.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_4() {\n\t\t\t\tMember[] m = new Member[2];\n\t\t\t\tm[0] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tm[1] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test2\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertEquals(2, result.length);\n\t\t\t\tassertEquals(\"test\", result[0]);\n\t\t\t\tassertEquals(\"test2\", result[1]);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Member[])} method.\n\t\t* It tests the method with an array of three elements.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_5() {\n\t\t\t\tMember[] m = new Member[3];\n\t\t\t\tm[0] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tm[1] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test2\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tm[2] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test3\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertEquals(3, result.length);\n\t\t\t\tassertEquals(\"test\", result[0]);\n\t\t\t\tassertEquals(\"test2\", result[1]);\n\t\t\t\tassertEquals(\"test3\", result[2]);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Member[])} method.\n\t\t* It tests the method with an array of four elements.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_6() {\n\t\t\t\tMember[] m = new Member[4];\n\t\t\t\tm[0] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tm[1] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test2\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tm[2] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test3\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tm[3] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test4\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertEquals(4, result.length);\n\t\t\t\tassertEquals(\"test\", result[0]);\n\t\t\t\tassertEquals(\"test2\", result[1]);\n\t\t\t\tassertEquals(\"test3\", result[2]);\n\t\t\t\tassertEquals(\"test4\", result[3]);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Member[])} method.\n\t\t* It tests the method with an array of five elements.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_7() {\n\t\t\t\tMember[] m = new Member[5];\n\t\t\t\tm[0] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tm[1] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test2\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tm[2] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test3\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tm[3] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test4\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tm[4] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test5\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertEquals(5, result.length);\n\t\t\t\tassertEquals(\"test\", result[0]);\n\t\t\t\tassertEquals(\"test2\", result[1]);\n\t\t\t\tassertEquals(\"test3\", result[2]);\n\t\t\t\tassertEquals(\"test4\", result[3]);\n\t\t\t\tassertEquals(\"test5\", result[4]);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Member[])} method.\n\t\t* It tests the method with an array of six elements.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_8() {\n\t\t\t\tMember[] m = new Member[6];\n\t\t\t\tm[0] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t\treturn \"test\";\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tm[1] = new Member() {\n\t\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\t\t",
        "applied_heuristics": "H7"
    },
    {
        "id": "cmpl-6wSDW1PgleQQnutx0cfd5yLQeeKwc",
        "object": "text_completion",
        "created": 1679389510,
        "model": "code-davinci-002",
        "choices": [
            {
                "text": "// ClassInfo_6Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#getData(Class[])} method.\n*/\nclass ClassInfo_6Test {\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Class[])} method.\n\t\t* It tests the method with a null array.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_1() {\n\t\t\t\tClass[] m = null;\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertNull(result);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Class[])} method.\n\t\t* It tests the method with an empty array.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_2() {\n\t\t\t\tClass[] m = new Class[0];\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertNull(result);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Class[])} method.\n\t\t* It tests the method with an array of one element.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_3() {\n\t\t\t\tClass[] m = new Class[1];\n\t\t\t\tm[0] = ClassInfo.class;\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertNotNull(result);\n\t\t\t\tassertEquals(1, result.length);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo\", result[0]);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Class[])} method.\n\t\t* It tests the method with an array of two elements.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_4() {\n\t\t\t\tClass[] m = new Class[2];\n\t\t\t\tm[0] = ClassInfo.class;\n\t\t\t\tm[1] = ClassInfo_6Test.class;\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertNotNull(result);\n\t\t\t\tassertEquals(2, result.length);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo\", result[0]);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo_6Test\", result[1]);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Class[])} method.\n\t\t* It tests the method with an array of three elements.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_5() {\n\t\t\t\tClass[] m = new Class[3];\n\t\t\t\tm[0] = ClassInfo.class;\n\t\t\t\tm[1] = ClassInfo_6Test.class;\n\t\t\t\tm[2] = ClassInfo_6Test.class;\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertNotNull(result);\n\t\t\t\tassertEquals(3, result.length);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo\", result[0]);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo_6Test\", result[1]);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo_6Test\", result[2]);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Class[])} method.\n\t\t* It tests the method with an array of four elements.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_6() {\n\t\t\t\tClass[] m = new Class[4];\n\t\t\t\tm[0] = ClassInfo.class;\n\t\t\t\tm[1] = ClassInfo_6Test.class;\n\t\t\t\tm[2] = ClassInfo_6Test.class;\n\t\t\t\tm[3] = ClassInfo.class;\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertNotNull(result);\n\t\t\t\tassertEquals(4, result.length);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo\", result[0]);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo_6Test\", result[1]);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo_6Test\", result[2]);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo\", result[3]);\n\t\t}\n}",
                "index": 0,
                "logprobs": null,
                "finish_reason": "length"
            }
        ],
        "usage": {
            "prompt_tokens": 5838,
            "completion_tokens": 2000,
            "total_tokens": 7838
        },
        "time_taken": 62.7135968208313,
        "prompt_id": "/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_6Test.java",
        "original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * <p>\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c = javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;\r\n\r\n    private String[] cMethods, fndMethods = null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() != null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c != java.lang.Object.class && !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan = locManager;\r\n        knownPackages = dirMan.getPackageList();\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f = c.getFields();\r\n        length = f.length;\r\n        String[] StringData = null;\r\n        if (length > 0) {\r\n            StringData = new String[length];\r\n            String tempStr;\r\n            Object obj = new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count = 0; count < length; count++) {\r\n                try {\r\n                    tempStr = f[count] + \"=\" + f[count].get(obj);\r\n                    StringData[count] = tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray = null;\r\n        if (cMethods != null) {\r\n            tempArray = new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug && tempArray == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods == null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = cMethods;\r\n        StringList tempList = new StringList();\r\n        for (int i = 0; i < cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + '.') != -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data = tempList.toArray();\r\n        else\r\n            data = null;\r\n        if (debug && data == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr = c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(constr);\r\n        if (debug && data == null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter = c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(inter);\r\n        if (c != java.lang.Object.class && !c.isInterface()) {\r\n            Class superC = c.getSuperclass();\r\n            TreeSet<String> hInterfaces = new TreeSet<String>();\r\n            int i = 0;\r\n            if (data != null)\r\n                for (i = 0; i < data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC != null && superC != java.lang.Object.class) {\r\n                inter = superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data = getData(inter);\r\n                if (data != null)\r\n                    for (i = 0; i < data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC = superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() != 0) {\r\n                data = new String[hInterfaces.size()];\r\n                Iterator it = hInterfaces.iterator();\r\n                i = 0;\r\n                while (it.hasNext()) {\r\n                    data[i] = (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug && data == null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].toString();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].getName();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods == null || pos > fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn't out of range\r\n            String tempStr = fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end = tempStr.indexOf(\")\");\r\n                tempStr = tempStr.substring(0, end + 1);\r\n                begin = tempStr.lastIndexOf(\" \");\r\n                tempStr = tempStr.substring(begin + 1, tempStr.length());\r\n                begin = tempStr.indexOf(\"(\");\r\n                end = tempStr.lastIndexOf(\".\", begin);\r\n                className = tempStr.substring(0, end);\r\n                methodName = tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className=\" + className);\r\n                methClass = ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass=\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr = name;\r\n        Class tempClass = null;\r\n        tempClass = tryClass(name);\r\n        if (tempClass == null) {\r\n            for (int i = 0; i < knownPackages.length; i++) {\r\n                tempStr = knownPackages[i] + name;\r\n                tempClass = tryClass(tempStr);\r\n                if (tempClass != null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass = null;\r\n        try {\r\n            if (name != null)\r\n                tempClass = Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c != java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 = System.currentTimeMillis();\r\n        debug = true;\r\n        String name = null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length > 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name = args[1];\r\n            } else {\r\n                name = args[0];\r\n                try {\r\n                    myClassInfo = new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo = new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
        "test_prompt": "// ClassInfo_6Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#getData(Class[])} method.\n*/\nclass ClassInfo_6Test {",
        "original_generated_code": "\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Class[])} method.\n\t\t* It tests the method with a null array.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_1() {\n\t\t\t\tClass[] m = null;\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertNull(result);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Class[])} method.\n\t\t* It tests the method with an empty array.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_2() {\n\t\t\t\tClass[] m = new Class[0];\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertNull(result);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Class[])} method.\n\t\t* It tests the method with an array of one element.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_3() {\n\t\t\t\tClass[] m = new Class[1];\n\t\t\t\tm[0] = ClassInfo.class;\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertNotNull(result);\n\t\t\t\tassertEquals(1, result.length);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo\", result[0]);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Class[])} method.\n\t\t* It tests the method with an array of two elements.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_4() {\n\t\t\t\tClass[] m = new Class[2];\n\t\t\t\tm[0] = ClassInfo.class;\n\t\t\t\tm[1] = ClassInfo_6Test.class;\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertNotNull(result);\n\t\t\t\tassertEquals(2, result.length);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo\", result[0]);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo_6Test\", result[1]);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Class[])} method.\n\t\t* It tests the method with an array of three elements.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_5() {\n\t\t\t\tClass[] m = new Class[3];\n\t\t\t\tm[0] = ClassInfo.class;\n\t\t\t\tm[1] = ClassInfo_6Test.class;\n\t\t\t\tm[2] = ClassInfo_6Test.class;\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertNotNull(result);\n\t\t\t\tassertEquals(3, result.length);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo\", result[0]);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo_6Test\", result[1]);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo_6Test\", result[2]);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Class[])} method.\n\t\t* It tests the method with an array of four elements.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_6() {\n\t\t\t\tClass[] m = new Class[4];\n\t\t\t\tm[0] = ClassInfo.class;\n\t\t\t\tm[1] = ClassInfo_6Test.class;\n\t\t\t\tm[2] = ClassInfo_6Test.class;\n\t\t\t\tm[3] = ClassInfo.class;\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertNotNull(result);\n\t\t\t\tassertEquals(4, result.length);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo\", result[0]);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo_6Test\", result[1]);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo_6Test\", result[2]);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo\", result[3]);\n\t\t}\n}\n\n// ClassInfo_7Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\n//8-01-04 Handled exceptions with fields.   ___JSH\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#getData(Member[])} method.\n*/\nclass ClassInfo_7Test {\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Member[])} method.\n\t\t* It tests the method with a null array.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_1() {\n\t\t\t\tMember[] m = null;\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertNull(result);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Member[])} method.\n\t\t* It tests the method with an empty array.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_2() {\n\t\t\t\tMember[] m = new Member[0];\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertNull(result);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Member[])} method.\n\t\t* It tests the method with an array of one element.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_3() {\n\t\t\t\tMember[] m = new Member[1];\n\t\t\t\tm[0] = ClassInfo.class;\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertNotNull(result);\n\t\t\t\tassertEquals(1, result.length);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo\", result[0]);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Member[])} method.\n\t\t* It tests the method with an array of two elements.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetData_4() {\n\t\t\t\tMember[] m = new Member[2];\n\t\t\t\tm[0] = ClassInfo.class;\n\t\t\t\tm[1] = ClassInfo_7Test.class;\n\t\t\t\tString[] result = ClassInfo.getData(m);\n\t\t\t\tassertNotNull(result);\n\t\t\t\tassertEquals(2, result.length);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo\", result[0]);\n\t\t\t\tassertEquals(\"class com.jstevh.viewer.ClassInfo_7Test\", result[1]);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getData(Member[",
        "applied_heuristics": "H1"
    },
    {
        "id": "cmpl-6wSEXOLZnMMaMYRYQaE7wKdOHUUSX",
        "object": "text_completion",
        "created": 1679389573,
        "model": "code-davinci-002",
        "choices": [
            {
                "text": "// ClassInfo_7Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#srchMethods(String)} method.\n*/\nclass ClassInfo_7Test {\n\t\t\n\t\tprivate ClassInfo myClassInfo;\n\t\t\n\t\tprivate String[] cMethods;\n\t\t\n\t\tprivate String[] fndMethods;\n\t\t\n\t\tprivate String[] index;\n\t\t\n\t\tprivate String tempStr;\n\t\t\n\t\tprivate String[] tempArray;\n\t\t\n\t\tprivate String[] tempArray2;\n\t\t\n\t\tprivate String[] tempArray3;\n\t\t\n\t\tprivate String[] tempArray4;\n\t\t\n\t\tprivate String[] tempArray5;\n\t\t\n\t\tprivate String[] tempArray6;\n\t\t\n\t\tprivate String[] tempArray7;\n\t\t\n\t\tprivate String[] tempArray8;\n\t\t\n\t\tprivate String[] tempArray9;\n\t\t\n\t\tprivate String[] tempArray10;\n\t\t\n\t\tprivate String[] tempArray11;\n\t\t\n\t\tprivate String[] tempArray12;\n\t\t\n\t\tprivate String[] tempArray13;\n\t\t\n\t\tprivate String[] tempArray14;\n\t\t\n\t\tprivate String[] tempArray15;\n\t\t\n\t\tprivate String[] tempArray16;\n\t\t\n\t\tprivate String[] tempArray17;\n\t\t\n\t\tprivate String[] tempArray18;\n\t\t\n\t\tprivate String[] tempArray19;\n\t\t\n\t\tprivate String[] tempArray20;\n\t\t\n\t\tprivate String[] tempArray21;\n\t\t\n\t\tprivate String[] tempArray22;\n\t\t\n\t\tprivate String[] tempArray23;\n\t\t\n\t\tprivate String[] tempArray24;\n\t\t\n\t\tprivate String[] tempArray25;\n\t\t\n\t\tprivate String[] tempArray26;\n\t\t\n\t\tprivate String[] tempArray27;\n\t\t\n\t\tprivate String[] tempArray28;\n\t\t\n\t\tprivate String[] tempArray29;\n\t\t\n\t\tprivate String[] tempArray30;\n\t\t\n\t\tprivate String[] tempArray31;\n\t\t\n\t\tprivate String[] tempArray32;\n\t\t\n\t\tprivate String[] tempArray33;\n\t\t\n\t\tprivate String[] tempArray34;\n\t\t\n\t\tprivate String[] tempArray35;\n\t\t\n\t\tprivate String[] tempArray36;\n\t\t\n\t\tprivate String[] tempArray37;\n\t\t\n\t\tprivate String[] tempArray38;\n\t\t\n\t\tprivate String[] tempArray39;\n\t\t\n\t\tprivate String[] tempArray40;\n\t\t\n\t\tprivate String[] tempArray41;\n\t\t\n\t\tprivate String[] tempArray42;\n\t\t\n\t\tprivate String[] tempArray43;\n\t\t\n\t\tprivate String[] tempArray44;\n\t\t\n\t\tprivate String[] tempArray45;\n\t\t\n\t\tprivate String[] tempArray46;\n\t\t\n\t\tprivate String[] tempArray47;\n\t\t\n\t\tprivate String[] tempArray48;\n\t\t\n\t\tprivate String[] tempArray49;\n\t\t\n\t\tprivate String[] tempArray50;\n\t\t\n\t\tprivate String[] tempArray51;\n\t\t\n\t\tprivate String[] tempArray52;\n\t\t\n\t\tprivate String[] tempArray53;\n\t\t\n\t\tprivate String[] tempArray54;\n\t\t\n\t\tprivate String[] tempArray55;\n\t\t\n\t\tprivate String[] tempArray56;\n\t\t\n\t\tprivate String[] tempArray57;\n\t\t\n\t\tprivate String[] tempArray58;\n\t\t\n\t\tprivate String[] tempArray59;\n\t\t\n\t\tprivate String[] tempArray60;\n\t\t\n\t\tprivate String[] tempArray61;\n\t\t\n\t\tprivate String[] tempArray62;\n\t\t\n\t\tprivate String[] tempArray63;\n\t\t\n\t\tprivate String[] tempArray64;\n\t\t\n\t\tprivate String[] tempArray65;\n\t\t\n\t\tprivate String[] tempArray66;\n\t\t\n\t\tprivate String[] tempArray67;\n\t\t\n\t\tprivate String[] tempArray68;\n\t\t\n\t\tprivate String[] tempArray69;\n\t\t\n\t\tprivate String[] tempArray70;\n\t\t\n\t\tprivate String[] tempArray71;\n\t\t\n\t\tprivate String[] tempArray72;\n\t\t\n\t\tprivate String[] tempArray73;\n\t\t\n\t\tprivate String[] tempArray74;\n\t\t\n\t\tprivate String[] tempArray75;\n\t\t\n\t\tprivate String[] tempArray76;\n\t\t\n\t\tprivate String[] tempArray77;\n\t\t\n\t\tprivate String[] tempArray78;\n\t\t\n\t\tprivate String[] tempArray79;\n\t\t\n\t\tprivate String[] tempArray80;\n\t\t\n\t\tprivate String[] tempArray81;\n\t\t\n\t\tprivate String[] tempArray82;\n\t\t\n\t\tprivate String[] tempArray83;\n\t\t\n\t\tprivate String[] tempArray84;\n\t\t\n\t\tprivate String[] tempArray85;\n\t\t\n\t\tprivate String[] tempArray86;\n\t\t\n\t\tprivate String[] tempArray87;\n\t\t\n\t\tprivate String[] tempArray88;\n\t\t\n\t\tprivate String[] tempArray89;\n\t\t\n\t\tprivate String[] tempArray90;\n\t\t\n\t\tprivate String[] tempArray91;\n\t\t\n\t\tprivate String[] tempArray92;\n\t\t\n\t\tprivate String[] tempArray93;\n\t\t\n\t\tprivate String[] tempArray94;\n\t\t\n\t\tprivate String[] tempArray95;\n\t\t\n\t\tprivate String[] tempArray96;\n\t\t\n\t\tprivate String[] tempArray97;\n\t\t\n\t\tprivate String[] tempArray98;\n\t\t\n\t\tprivate String[] tempArray99;\n\t\t\n\t\tprivate String[] tempArray100;\n\t\t\n\t\tprivate String[] tempArray101;\n\t\t\n\t\tprivate String[] tempArray102;\n\t\t\n\t\tprivate String[] tempArray103;\n\t\t\n\t\tprivate String[] tempArray104;\n\t\t\n\t\tprivate String[] tempArray105;\n\t\t\n\t\tprivate String[] tempArray106;\n\t\t\n\t\tprivate String[] tempArray107;\n\t\t\n\t\tprivate String[] tempArray108;\n\t\t\n\t\tprivate String[] tempArray109;\n\t\t\n\t\tprivate String[] tempArray110;\n\t\t\n\t\tprivate String[] tempArray111;\n\t\t\n\t\tprivate String[] tempArray112;\n\t\t\n\t\tprivate String[] tempArray113;\n\t\t\n\t\tprivate String[] tempArray114;\n\t\t\n\t\tprivate String[] tempArray115;\n\t\t\n\t\tprivate String[] tempArray116;\n\t\t\n\t\tprivate String[] tempArray117;\n\t\t\n\t\tprivate String[] tempArray118;\n\t\t\n\t\tprivate String[] tempArray119;\n\t\t\n\t\tprivate String[] tempArray120;\n\t\t\n\t\tprivate String[] tempArray121;\n\t\t\n\t\tprivate String[] tempArray122;\n\t\t\n\t\tprivate String[] tempArray123;\n\t\t\n\t\tprivate String[] tempArray124;\n\t\t\n\t\tprivate String[] tempArray125;\n\t\t\n\t\tprivate String[] tempArray126;\n\t\t\n\t\tprivate String[] tempArray127;\n\t\t\n\t\tprivate String[] tempArray128;\n\t\t\n\t\tprivate String[] tempArray129;\n\t\t\n\t\tprivate String[] tempArray130;\n\t\t\n\t\tprivate String[] tempArray131;\n\t\t\n\t\tprivate String[] tempArray132;\n\t\t\n\t\tprivate String[] tempArray133;\n\t\t\n\t\tprivate String[] tempArray134;\n\t\t\n\t\tprivate String[] tempArray135;\n\t\t\n\t\tprivate String[] tempArray136;\n\t\t\n\t\tprivate String[] tempArray137;\n\t\t\n\t\tprivate String[] tempArray138;\n\t\t\n\t\tprivate String[] tempArray139;\n\t\t\n\t\tprivate String[] tempArray140;\n\t\t\n\t\tprivate String[] tempArray141;\n\t\t\n\t\tprivate String[] tempArray142;\n\t\t\n\t\tprivate String[] tempArray143;\n\t\t\n\t\tprivate String[] tempArray144;\n\t\t\n\t\tprivate String[] tempArray145;\n\t\t\n\t\tprivate String[] tempArray146;\n\t\t\n\t\tprivate String[] tempArray147;\n\t\t\n\t\tprivate String[] tempArray148;\n\t\t\n\t\tprivate String[] tempArray149;\n\t\t\n}",
                "index": 0,
                "logprobs": null,
                "finish_reason": "length"
            }
        ],
        "usage": {
            "prompt_tokens": 5837,
            "completion_tokens": 2000,
            "total_tokens": 7837
        },
        "time_taken": 65.13782286643982,
        "prompt_id": "/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_7Test.java",
        "original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * <p>\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c = javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;\r\n\r\n    private String[] cMethods, fndMethods = null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() != null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c != java.lang.Object.class && !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan = locManager;\r\n        knownPackages = dirMan.getPackageList();\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f = c.getFields();\r\n        length = f.length;\r\n        String[] StringData = null;\r\n        if (length > 0) {\r\n            StringData = new String[length];\r\n            String tempStr;\r\n            Object obj = new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count = 0; count < length; count++) {\r\n                try {\r\n                    tempStr = f[count] + \"=\" + f[count].get(obj);\r\n                    StringData[count] = tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray = null;\r\n        if (cMethods != null) {\r\n            tempArray = new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug && tempArray == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods == null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = cMethods;\r\n        StringList tempList = new StringList();\r\n        for (int i = 0; i < cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + '.') != -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data = tempList.toArray();\r\n        else\r\n            data = null;\r\n        if (debug && data == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr = c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(constr);\r\n        if (debug && data == null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter = c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(inter);\r\n        if (c != java.lang.Object.class && !c.isInterface()) {\r\n            Class superC = c.getSuperclass();\r\n            TreeSet<String> hInterfaces = new TreeSet<String>();\r\n            int i = 0;\r\n            if (data != null)\r\n                for (i = 0; i < data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC != null && superC != java.lang.Object.class) {\r\n                inter = superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data = getData(inter);\r\n                if (data != null)\r\n                    for (i = 0; i < data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC = superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() != 0) {\r\n                data = new String[hInterfaces.size()];\r\n                Iterator it = hInterfaces.iterator();\r\n                i = 0;\r\n                while (it.hasNext()) {\r\n                    data[i] = (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug && data == null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].toString();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].getName();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods == null || pos > fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn't out of range\r\n            String tempStr = fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end = tempStr.indexOf(\")\");\r\n                tempStr = tempStr.substring(0, end + 1);\r\n                begin = tempStr.lastIndexOf(\" \");\r\n                tempStr = tempStr.substring(begin + 1, tempStr.length());\r\n                begin = tempStr.indexOf(\"(\");\r\n                end = tempStr.lastIndexOf(\".\", begin);\r\n                className = tempStr.substring(0, end);\r\n                methodName = tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className=\" + className);\r\n                methClass = ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass=\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr = name;\r\n        Class tempClass = null;\r\n        tempClass = tryClass(name);\r\n        if (tempClass == null) {\r\n            for (int i = 0; i < knownPackages.length; i++) {\r\n                tempStr = knownPackages[i] + name;\r\n                tempClass = tryClass(tempStr);\r\n                if (tempClass != null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass = null;\r\n        try {\r\n            if (name != null)\r\n                tempClass = Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c != java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 = System.currentTimeMillis();\r\n        debug = true;\r\n        String name = null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length > 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name = args[1];\r\n            } else {\r\n                name = args[0];\r\n                try {\r\n                    myClassInfo = new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo = new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
        "test_prompt": "// ClassInfo_7Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#srchMethods(String)} method.\n*/\nclass ClassInfo_7Test {",
        "original_generated_code": "\n\t\tprivate ClassInfo myClassInfo;\n\t\t\n\t\tprivate String[] cMethods;\n\t\t\n\t\tprivate String[] fndMethods;\n\t\t\n\t\tprivate String[] index;\n\t\t\n\t\tprivate String tempStr;\n\t\t\n\t\tprivate String[] tempArray;\n\t\t\n\t\tprivate String[] tempArray2;\n\t\t\n\t\tprivate String[] tempArray3;\n\t\t\n\t\tprivate String[] tempArray4;\n\t\t\n\t\tprivate String[] tempArray5;\n\t\t\n\t\tprivate String[] tempArray6;\n\t\t\n\t\tprivate String[] tempArray7;\n\t\t\n\t\tprivate String[] tempArray8;\n\t\t\n\t\tprivate String[] tempArray9;\n\t\t\n\t\tprivate String[] tempArray10;\n\t\t\n\t\tprivate String[] tempArray11;\n\t\t\n\t\tprivate String[] tempArray12;\n\t\t\n\t\tprivate String[] tempArray13;\n\t\t\n\t\tprivate String[] tempArray14;\n\t\t\n\t\tprivate String[] tempArray15;\n\t\t\n\t\tprivate String[] tempArray16;\n\t\t\n\t\tprivate String[] tempArray17;\n\t\t\n\t\tprivate String[] tempArray18;\n\t\t\n\t\tprivate String[] tempArray19;\n\t\t\n\t\tprivate String[] tempArray20;\n\t\t\n\t\tprivate String[] tempArray21;\n\t\t\n\t\tprivate String[] tempArray22;\n\t\t\n\t\tprivate String[] tempArray23;\n\t\t\n\t\tprivate String[] tempArray24;\n\t\t\n\t\tprivate String[] tempArray25;\n\t\t\n\t\tprivate String[] tempArray26;\n\t\t\n\t\tprivate String[] tempArray27;\n\t\t\n\t\tprivate String[] tempArray28;\n\t\t\n\t\tprivate String[] tempArray29;\n\t\t\n\t\tprivate String[] tempArray30;\n\t\t\n\t\tprivate String[] tempArray31;\n\t\t\n\t\tprivate String[] tempArray32;\n\t\t\n\t\tprivate String[] tempArray33;\n\t\t\n\t\tprivate String[] tempArray34;\n\t\t\n\t\tprivate String[] tempArray35;\n\t\t\n\t\tprivate String[] tempArray36;\n\t\t\n\t\tprivate String[] tempArray37;\n\t\t\n\t\tprivate String[] tempArray38;\n\t\t\n\t\tprivate String[] tempArray39;\n\t\t\n\t\tprivate String[] tempArray40;\n\t\t\n\t\tprivate String[] tempArray41;\n\t\t\n\t\tprivate String[] tempArray42;\n\t\t\n\t\tprivate String[] tempArray43;\n\t\t\n\t\tprivate String[] tempArray44;\n\t\t\n\t\tprivate String[] tempArray45;\n\t\t\n\t\tprivate String[] tempArray46;\n\t\t\n\t\tprivate String[] tempArray47;\n\t\t\n\t\tprivate String[] tempArray48;\n\t\t\n\t\tprivate String[] tempArray49;\n\t\t\n\t\tprivate String[] tempArray50;\n\t\t\n\t\tprivate String[] tempArray51;\n\t\t\n\t\tprivate String[] tempArray52;\n\t\t\n\t\tprivate String[] tempArray53;\n\t\t\n\t\tprivate String[] tempArray54;\n\t\t\n\t\tprivate String[] tempArray55;\n\t\t\n\t\tprivate String[] tempArray56;\n\t\t\n\t\tprivate String[] tempArray57;\n\t\t\n\t\tprivate String[] tempArray58;\n\t\t\n\t\tprivate String[] tempArray59;\n\t\t\n\t\tprivate String[] tempArray60;\n\t\t\n\t\tprivate String[] tempArray61;\n\t\t\n\t\tprivate String[] tempArray62;\n\t\t\n\t\tprivate String[] tempArray63;\n\t\t\n\t\tprivate String[] tempArray64;\n\t\t\n\t\tprivate String[] tempArray65;\n\t\t\n\t\tprivate String[] tempArray66;\n\t\t\n\t\tprivate String[] tempArray67;\n\t\t\n\t\tprivate String[] tempArray68;\n\t\t\n\t\tprivate String[] tempArray69;\n\t\t\n\t\tprivate String[] tempArray70;\n\t\t\n\t\tprivate String[] tempArray71;\n\t\t\n\t\tprivate String[] tempArray72;\n\t\t\n\t\tprivate String[] tempArray73;\n\t\t\n\t\tprivate String[] tempArray74;\n\t\t\n\t\tprivate String[] tempArray75;\n\t\t\n\t\tprivate String[] tempArray76;\n\t\t\n\t\tprivate String[] tempArray77;\n\t\t\n\t\tprivate String[] tempArray78;\n\t\t\n\t\tprivate String[] tempArray79;\n\t\t\n\t\tprivate String[] tempArray80;\n\t\t\n\t\tprivate String[] tempArray81;\n\t\t\n\t\tprivate String[] tempArray82;\n\t\t\n\t\tprivate String[] tempArray83;\n\t\t\n\t\tprivate String[] tempArray84;\n\t\t\n\t\tprivate String[] tempArray85;\n\t\t\n\t\tprivate String[] tempArray86;\n\t\t\n\t\tprivate String[] tempArray87;\n\t\t\n\t\tprivate String[] tempArray88;\n\t\t\n\t\tprivate String[] tempArray89;\n\t\t\n\t\tprivate String[] tempArray90;\n\t\t\n\t\tprivate String[] tempArray91;\n\t\t\n\t\tprivate String[] tempArray92;\n\t\t\n\t\tprivate String[] tempArray93;\n\t\t\n\t\tprivate String[] tempArray94;\n\t\t\n\t\tprivate String[] tempArray95;\n\t\t\n\t\tprivate String[] tempArray96;\n\t\t\n\t\tprivate String[] tempArray97;\n\t\t\n\t\tprivate String[] tempArray98;\n\t\t\n\t\tprivate String[] tempArray99;\n\t\t\n\t\tprivate String[] tempArray100;\n\t\t\n\t\tprivate String[] tempArray101;\n\t\t\n\t\tprivate String[] tempArray102;\n\t\t\n\t\tprivate String[] tempArray103;\n\t\t\n\t\tprivate String[] tempArray104;\n\t\t\n\t\tprivate String[] tempArray105;\n\t\t\n\t\tprivate String[] tempArray106;\n\t\t\n\t\tprivate String[] tempArray107;\n\t\t\n\t\tprivate String[] tempArray108;\n\t\t\n\t\tprivate String[] tempArray109;\n\t\t\n\t\tprivate String[] tempArray110;\n\t\t\n\t\tprivate String[] tempArray111;\n\t\t\n\t\tprivate String[] tempArray112;\n\t\t\n\t\tprivate String[] tempArray113;\n\t\t\n\t\tprivate String[] tempArray114;\n\t\t\n\t\tprivate String[] tempArray115;\n\t\t\n\t\tprivate String[] tempArray116;\n\t\t\n\t\tprivate String[] tempArray117;\n\t\t\n\t\tprivate String[] tempArray118;\n\t\t\n\t\tprivate String[] tempArray119;\n\t\t\n\t\tprivate String[] tempArray120;\n\t\t\n\t\tprivate String[] tempArray121;\n\t\t\n\t\tprivate String[] tempArray122;\n\t\t\n\t\tprivate String[] tempArray123;\n\t\t\n\t\tprivate String[] tempArray124;\n\t\t\n\t\tprivate String[] tempArray125;\n\t\t\n\t\tprivate String[] tempArray126;\n\t\t\n\t\tprivate String[] tempArray127;\n\t\t\n\t\tprivate String[] tempArray128;\n\t\t\n\t\tprivate String[] tempArray129;\n\t\t\n\t\tprivate String[] tempArray130;\n\t\t\n\t\tprivate String[] tempArray131;\n\t\t\n\t\tprivate String[] tempArray132;\n\t\t\n\t\tprivate String[] tempArray133;\n\t\t\n\t\tprivate String[] tempArray134;\n\t\t\n\t\tprivate String[] tempArray135;\n\t\t\n\t\tprivate String[] tempArray136;\n\t\t\n\t\tprivate String[] tempArray137;\n\t\t\n\t\tprivate String[] tempArray138;\n\t\t\n\t\tprivate String[] tempArray139;\n\t\t\n\t\tprivate String[] tempArray140;\n\t\t\n\t\tprivate String[] tempArray141;\n\t\t\n\t\tprivate String[] tempArray142;\n\t\t\n\t\tprivate String[] tempArray143;\n\t\t\n\t\tprivate String[] tempArray144;\n\t\t\n\t\tprivate String[] tempArray145;\n\t\t\n\t\tprivate String[] tempArray146;\n\t\t\n\t\tprivate String[] tempArray147;\n\t\t\n\t\tprivate String[] tempArray148;\n\t\t\n\t\tprivate String[] tempArray149;\n\t\t\n\t\tprivate",
        "applied_heuristics": "H7"
    },
    {
        "id": "cmpl-6wSFapcyxQHcvjNfdMATGzxYqUuQW",
        "object": "text_completion",
        "created": 1679389638,
        "model": "code-davinci-002",
        "choices": [
            {
                "text": "// ClassInfo_9Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#getFoundMethod(int)} method.\n*/\nclass ClassInfo_9Test {\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getFoundMethod(int)} method.\n\t\t* <p>\n\t\t* This test case checks if the method returns null when the position is out of range.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetFoundMethod_1() {\n\t\t\t\tClassInfo myClassInfo = new ClassInfo(\"java.lang.String\");\n\t\t\t\tmyClassInfo.srchMethods(\"charAt\");\n\t\t\t\tassertNull(myClassInfo.getFoundMethod(3));\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getFoundMethod(int)} method.\n\t\t* <p>\n\t\t* This test case checks if the method returns null when the position is out of range.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetFoundMethod_2() {\n\t\t\t\tClassInfo myClassInfo = new ClassInfo(\"java.lang.String\");\n\t\t\t\tmyClassInfo.srchMethods(\"charAt\");\n\t\t\t\tassertNull(myClassInfo.getFoundMethod(-1));\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getFoundMethod(int)} method.\n\t\t* <p>\n\t\t* This test case checks if the method returns null when the position is out of range.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetFoundMethod_3() {\n\t\t\t\tClassInfo myClassInfo = new ClassInfo(\"java.lang.String\");\n\t\t\t\tmyClassInfo.srchMethods(\"charAt\");\n\t\t\t\tassertNull(myClassInfo.getFoundMethod(0));\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getFoundMethod(int)} method.\n\t\t* <p>\n\t\t* This test case checks if the method returns null when the position is out of range.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetFoundMethod_4() {\n\t\t\t\tClassInfo myClassInfo = new ClassInfo(\"java.lang.String\");\n\t\t\t\tmyClassInfo.srchMethods(\"charAt\");\n\t\t\t\tassertNull(myClassInfo.getFoundMethod(1));\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getFoundMethod(int)} method.\n\t\t* <p>\n\t\t* This test case checks if the method returns null when the position is out of range.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetFoundMethod_5() {\n\t\t\t\tClassInfo myClassInfo = new ClassInfo(\"java.lang.String\");\n\t\t\t\tmyClassInfo.srchMethods(\"charAt\");\n\t\t\t\tassertNull(myClassInfo.getFoundMethod(2));\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getFoundMethod(int)} method.\n\t\t* <p>\n\t\t* This test case checks if the method returns null when the position is out of range.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetFoundMethod_6() {\n\t\t\t\tClassInfo myClassInfo = new ClassInfo(\"java.lang.String\");\n\t\t\t\tmyClassInfo.srchMethods(\"charAt\");\n\t\t\t\tassertNull(myClassInfo.getFoundMethod(4));\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getFoundMethod(int)} method.\n\t\t* <p>\n\t\t* This test case checks if the method returns null when the position is out of range.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetFoundMethod_7() {\n\t\t\t\tClassInfo myClassInfo = new ClassInfo(\"java.lang.String\");\n\t\t\t\tmyClassInfo.srchMethods(\"charAt\");\n\t\t\t\tassertNull(myClassInfo.getFoundMethod(5));\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getFoundMethod(int)} method.\n\t\t* <p>\n\t\t* This test case checks if the method returns null when the position is out of range.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetFoundMethod_8() {\n\t\t\t\tClassInfo myClassInfo = new ClassInfo(\"java.lang.String\");\n\t\t\t\tmyClassInfo.srchMethods(\"charAt\");\n\t\t\t\tassertNull(myClassInfo.getFoundMethod(6));\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getFoundMethod(int)} method.\n\t\t* <p>\n\t\t* This test case checks if the method returns null when the position is out of range.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetFoundMethod_9() {\n\t\t\t\tClassInfo myClassInfo = new ClassInfo(\"java.lang.String\");\n\t\t\t\tmyClassInfo.srchMethods(\"charAt\");\n\t\t\t\tassertNull(myClassInfo.getFoundMethod(7));\n\t\t}\n}",
                "index": 0,
                "logprobs": null,
                "finish_reason": "length"
            }
        ],
        "usage": {
            "prompt_tokens": 5837,
            "completion_tokens": 2000,
            "total_tokens": 7837
        },
        "time_taken": 65.40243315696716,
        "prompt_id": "/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_9Test.java",
        "original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * <p>\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c = javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;\r\n\r\n    private String[] cMethods, fndMethods = null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() != null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c != java.lang.Object.class && !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan = locManager;\r\n        knownPackages = dirMan.getPackageList();\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f = c.getFields();\r\n        length = f.length;\r\n        String[] StringData = null;\r\n        if (length > 0) {\r\n            StringData = new String[length];\r\n            String tempStr;\r\n            Object obj = new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count = 0; count < length; count++) {\r\n                try {\r\n                    tempStr = f[count] + \"=\" + f[count].get(obj);\r\n                    StringData[count] = tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray = null;\r\n        if (cMethods != null) {\r\n            tempArray = new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug && tempArray == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods == null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = cMethods;\r\n        StringList tempList = new StringList();\r\n        for (int i = 0; i < cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + '.') != -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data = tempList.toArray();\r\n        else\r\n            data = null;\r\n        if (debug && data == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr = c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(constr);\r\n        if (debug && data == null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter = c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(inter);\r\n        if (c != java.lang.Object.class && !c.isInterface()) {\r\n            Class superC = c.getSuperclass();\r\n            TreeSet<String> hInterfaces = new TreeSet<String>();\r\n            int i = 0;\r\n            if (data != null)\r\n                for (i = 0; i < data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC != null && superC != java.lang.Object.class) {\r\n                inter = superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data = getData(inter);\r\n                if (data != null)\r\n                    for (i = 0; i < data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC = superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() != 0) {\r\n                data = new String[hInterfaces.size()];\r\n                Iterator it = hInterfaces.iterator();\r\n                i = 0;\r\n                while (it.hasNext()) {\r\n                    data[i] = (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug && data == null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].toString();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].getName();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods == null || pos > fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn't out of range\r\n            String tempStr = fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end = tempStr.indexOf(\")\");\r\n                tempStr = tempStr.substring(0, end + 1);\r\n                begin = tempStr.lastIndexOf(\" \");\r\n                tempStr = tempStr.substring(begin + 1, tempStr.length());\r\n                begin = tempStr.indexOf(\"(\");\r\n                end = tempStr.lastIndexOf(\".\", begin);\r\n                className = tempStr.substring(0, end);\r\n                methodName = tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className=\" + className);\r\n                methClass = ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass=\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr = name;\r\n        Class tempClass = null;\r\n        tempClass = tryClass(name);\r\n        if (tempClass == null) {\r\n            for (int i = 0; i < knownPackages.length; i++) {\r\n                tempStr = knownPackages[i] + name;\r\n                tempClass = tryClass(tempStr);\r\n                if (tempClass != null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass = null;\r\n        try {\r\n            if (name != null)\r\n                tempClass = Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c != java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 = System.currentTimeMillis();\r\n        debug = true;\r\n        String name = null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length > 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name = args[1];\r\n            } else {\r\n                name = args[0];\r\n                try {\r\n                    myClassInfo = new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo = new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
        "test_prompt": "// ClassInfo_9Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#getFoundMethod(int)} method.\n*/\nclass ClassInfo_9Test {",
        "original_generated_code": "\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getFoundMethod(int)} method.\n\t\t* <p>\n\t\t* This test case checks if the method returns null when the position is out of range.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetFoundMethod_1() {\n\t\t\t\tClassInfo myClassInfo = new ClassInfo(\"java.lang.String\");\n\t\t\t\tmyClassInfo.srchMethods(\"charAt\");\n\t\t\t\tassertNull(myClassInfo.getFoundMethod(3));\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getFoundMethod(int)} method.\n\t\t* <p>\n\t\t* This test case checks if the method returns null when the position is out of range.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetFoundMethod_2() {\n\t\t\t\tClassInfo myClassInfo = new ClassInfo(\"java.lang.String\");\n\t\t\t\tmyClassInfo.srchMethods(\"charAt\");\n\t\t\t\tassertNull(myClassInfo.getFoundMethod(-1));\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getFoundMethod(int)} method.\n\t\t* <p>\n\t\t* This test case checks if the method returns null when the position is out of range.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetFoundMethod_3() {\n\t\t\t\tClassInfo myClassInfo = new ClassInfo(\"java.lang.String\");\n\t\t\t\tmyClassInfo.srchMethods(\"charAt\");\n\t\t\t\tassertNull(myClassInfo.getFoundMethod(0));\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getFoundMethod(int)} method.\n\t\t* <p>\n\t\t* This test case checks if the method returns null when the position is out of range.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetFoundMethod_4() {\n\t\t\t\tClassInfo myClassInfo = new ClassInfo(\"java.lang.String\");\n\t\t\t\tmyClassInfo.srchMethods(\"charAt\");\n\t\t\t\tassertNull(myClassInfo.getFoundMethod(1));\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getFoundMethod(int)} method.\n\t\t* <p>\n\t\t* This test case checks if the method returns null when the position is out of range.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetFoundMethod_5() {\n\t\t\t\tClassInfo myClassInfo = new ClassInfo(\"java.lang.String\");\n\t\t\t\tmyClassInfo.srchMethods(\"charAt\");\n\t\t\t\tassertNull(myClassInfo.getFoundMethod(2));\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getFoundMethod(int)} method.\n\t\t* <p>\n\t\t* This test case checks if the method returns null when the position is out of range.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetFoundMethod_6() {\n\t\t\t\tClassInfo myClassInfo = new ClassInfo(\"java.lang.String\");\n\t\t\t\tmyClassInfo.srchMethods(\"charAt\");\n\t\t\t\tassertNull(myClassInfo.getFoundMethod(4));\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getFoundMethod(int)} method.\n\t\t* <p>\n\t\t* This test case checks if the method returns null when the position is out of range.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetFoundMethod_7() {\n\t\t\t\tClassInfo myClassInfo = new ClassInfo(\"java.lang.String\");\n\t\t\t\tmyClassInfo.srchMethods(\"charAt\");\n\t\t\t\tassertNull(myClassInfo.getFoundMethod(5));\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getFoundMethod(int)} method.\n\t\t* <p>\n\t\t* This test case checks if the method returns null when the position is out of range.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetFoundMethod_8() {\n\t\t\t\tClassInfo myClassInfo = new ClassInfo(\"java.lang.String\");\n\t\t\t\tmyClassInfo.srchMethods(\"charAt\");\n\t\t\t\tassertNull(myClassInfo.getFoundMethod(6));\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case for {@link ClassInfo#getFoundMethod(int)} method.\n\t\t* <p>\n\t\t* This test case checks if the method returns null when the position is out of range.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetFoundMethod_9() {\n\t\t\t\tClassInfo myClassInfo = new ClassInfo(\"java.lang.String\");\n\t\t\t\tmyClassInfo.srchMethods(\"charAt\");\n\t\t\t\tassertNull(myClassInfo.getFoundMethod(7));\n\t\t}\n}\n\n// ClassInfo_Test.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\nimport org.junit.jupiter.api.Test;\r\nimport static org.junit.jupiter.api.Assertions.*;\r\n\r\n/**\r\n* Test class of {@link ClassInfo}.\r\n* It contains ten unit test cases for the {@link ClassInfo#getFoundMethod(int)} method.\r\n*/\r\nclass ClassInfo_Test {\r\n\t\t\r\n\t\t/**\r\n\t\t* Test case for {@link ClassInfo#getFoundMethod(int)} method.\r\n\t\t* <p>\r\n\t\t* This test case checks if the method returns null when the position is out of range.\r\n\t\t*/\r\n\t\t@Test\r\n\t\tvoid testGetFoundMethod_1() {\r\n\t\t\t\tClassInfo myClassInfo = new ClassInfo(\"java.lang.String\");\r\n\t\t\t\tmyClassInfo.srchMethods(\"charAt\");\r\n\t\t\t\tassertNull(myClassInfo.getFoundMethod(3));\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t* Test case for {@link ClassInfo#getFoundMethod(int)} method.\r\n\t\t* <p>\r\n\t\t* This test case checks if the method returns null when the position is out of range.\r\n\t\t*/\r\n\t\t@Test\r\n\t\tvoid testGetFoundMethod_2() {\r\n\t\t\t\tClassInfo myClassInfo = new ClassInfo(\"java.lang.String\");\r\n\t\t\t\tmyClassInfo.srchMethods(\"charAt\");\r\n\t\t\t\tassertNull(myClassInfo.getFoundMethod(-",
        "applied_heuristics": "H1"
    }
]