ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6wXRZeN8JG8MxEzWeawqOSUbFn3Wc,/EvoSuiteBenchmark/original/63_objectexplorer/src/main/java/de/paragon/explorer/model/ExplorerModelBuilder_2Test.java,55.99727272987366,length,"// ExplorerModelBuilder.java
/**
 * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren
 * Referenzen]
 *
 * Copyright (C) [2009] [PARAGON Systemhaus GmbH]
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, see <http://www.gnu.org/licenses/>.
 */
package de.paragon.explorer.model;

import de.paragon.explorer.figure.ExplorerFigure;
import de.paragon.explorer.figure.ExplorerFigureBuilder;
import de.paragon.explorer.figure.ListBoxFigure;
import de.paragon.explorer.figure.TextBoxFigure;
import de.paragon.explorer.gui.ExplorerDrawingPanel;
import de.paragon.explorer.util.ExplorerManager;

public final class ExplorerModelBuilder {

    private static ExplorerModelBuilder singleton;

    public static ExplorerModelBuilder getInstance() {
        return ExplorerModelBuilder.getSingleton();
    }

    private static ExplorerModelBuilder getSingleton() {
        if (ExplorerModelBuilder.singleton == null) {
            ExplorerModelBuilder.setSingleton(new ExplorerModelBuilder());
        }
        return ExplorerModelBuilder.singleton;
    }

    private static void setSingleton(ExplorerModelBuilder builder) {
        ExplorerModelBuilder.singleton = builder;
    }

    private ExplorerModelBuilder() {
        super();
    }

    /**
     * Kommentar: Als erstes wird ein neues ExplorerModel erzeugt. Danach wird
     * eine ExplorerFigure erzeugt. Diese wird dann mit dem ExplorerModel
     * verknuepft. Generell gilt: Der Builder, der eine Figur oder ein Model
     * frisch erzeugt hat, ist fuer die Verknuepfung der unmittelbar zuvor
     * erzeugten Figur bzw. dem unmittelbar zuvor erzeugten Model zustaendig.
     * Nach der Verknuepfung von ExplorerModel und ExplorerFigure wird ein neues
     * ObjectModel erzeugt. Anschliessend werden ObjectModel und ExplorerModel
     * verknuepft. Dann wird eine neue ListBoxFigure erzeugt. Diese wird dann
     * mit dem ObjectModel verknuepft. Schliesslich schliesst sich der Kreis mit
     * der Verknuepfung von ListBoxFigure und Explorer-Figure. Diese wird
     * vorgenommen von dem ExplorerFigureBuilder. Anschliessend wird das
     * ObjectModel weiter ausgebaut. Eine Beschreibung hierzu siehe im
     * ObjectModelBuilder in der Methode buildObjectModel(ObjectModel objModl,
     * Object object)! Ganz zum Schluss wird die fertige ListBoxFigure in der
     * ExplorerFigure plaziert, das heisst, ihre Position innerhalb der
     * ExplorerFigure wird festgelegt. Danach wird sie gezeichnet und ein neuer
     * EventConverter wird erzeugt, bei dem die ExplorerFigure eingetragen wird.
     */
    public ExplorerDrawingPanel add1stModel(Object object) {
        ExplorerModel explModl = this.createNewExplorerModelWithFigure();
        if (object != null) {
            ObjectModel objModl = this.createNewObjectModel(explModl);
            this.getObjectModelBuilder().buildObjectModel(objModl, object);
            this.getExplorerFigureBuilder().initialize1stList((ListBoxFigure) objModl.getFigure());
            explModl.setDrawingFrameEventConverter(this.createNewEventConverter((ExplorerFigure) explModl.getFigure()));
            ((ExplorerFigure) explModl.getFigure()).repaint();
            this.getExplorerManager().addExplorerModel(explModl);
        }
        return ((ExplorerFigure) explModl.getFigure()).getPanel();
    }

    /**
     * Kommentar: Als erstes wird ein neues ExplorerModel erzeugt. Danach wird
     * eine ExplorerFigure erzeugt. Diese wird dann mit dem ExplorerModel
     * verknuepft. Generell gilt: Der Builder, der eine Figur oder ein Model
     * frisch erzeugt hat, ist fuer die Verknuepfung der unmittelbar zuvor
     * erzeugten Figur bzw. dem unmittelbar zuvor erzeugten Model zustaendig.
     * Nach der Verknuepfung von ExplorerModel und ExplorerFigure wird ein neues
     * ObjectModel erzeugt. Anschliessend werden ObjectModel und ExplorerModel
     * verknuepft. Dann wird eine neue ListBoxFigure erzeugt. Diese wird dann
     * mit dem ObjectModel verknuepft. Schliesslich schliesst sich der Kreis mit
     * der Verknuepfung von ListBoxFigure und Explorer-Figure. Diese wird
     * vorgenommen von dem ExplorerFigureBuilder. Anschliessend wird das
     * ObjectModel weiter ausgebaut. Eine Be- schreibung hierzu siehe im
     * ObjectModelBuilder in der Methode buildObjectModel(ObjectModel objModl,
     * Object object)! Ganz zum Schluss wird die fertige ListBoxFigure in der
     * ExplorerFigure plaziert, das heisst, ihre Position innerhalb der
     * ExplorerFigure wird festgelegt. Danach wird sie gezeichnet und ein neuer
     * EventConverter wird erzeugt, bei dem die ExplorerFigure eingetragen wird.
     */
    public void addModel(ExplorerModel explModl, Object object) {
        ObjectModel objModl = this.createNewObjectModel(explModl);
        this.getObjectModelBuilder().buildObjectModel(objModl, object);
        this.getExplorerFigureBuilder().initializeCopyList((ListBoxFigure) objModl.getFigure());
        this.getExplorerFigureBuilder().draw((ListBoxFigure) objModl.getFigure());
    }

    private void addNewConnectedObjectModelFor(TextBoxFigure tbf) {
        AttributeModel attrModl = (AttributeModel) tbf.getModel();
        // ObjectModel objModl =
        // this.createNewObjectModel(attrModl.getObjectModel().getExplorerModel()
        // );
        ObjectModel objModl = this.createNewObjectModel(tbf);
        this.getObjectModelBuilder().buildObjectModel(objModl, attrModl.getValue());
        this.getExplorerFigureBuilder().initializeListFor(objModl, attrModl);
        this.getExplorerFigureBuilder().draw((ListBoxFigure) objModl.getFigure());
        this.getConnectionBuilder().addConnection(objModl.getHeaderModel(), attrModl);
    }

    /**
     * Kommentar: Diese Methode geht davon aus, dass lediglich die fertig
     * erstellte ListBoxFigure noch innerhalb der Explorer- Figure positioniert
     * werden muss.
     */
    private void connect(ExplorerModel explModl, ExplorerFigure explFig) {
        explModl.setFigure(explFig);
        explFig.setModel(explModl);
    }

    private de.paragon.explorer.event.ExplorerFrameEventConverter createNewEventConverter(ExplorerFigure explFig) {
        return de.paragon.explorer.Explorer.getEventConverter(explFig);
    }

    /**
     * Kommentar: Diese Methode erzeugt ein neues ExplorerModel, eine neue
     * ExplorerFigure und verknuepft diese beiden.
     */
    public ExplorerModel createNewExplorerModelWithFigure() {
        ExplorerModel explModl;
        ExplorerFigure explFig;
        explModl = new ExplorerModel();
        explFig = this.getExplorerFigureBuilder().createNewExplorerFigure();
        this.connect(explModl, explFig);
        return explModl;
    }

    private ObjectModel createNewObjectModel(ExplorerModel explModl) {
        return this.getObjectModelBuilder().createNewObjectModel(explModl);
    }

    private ObjectModel createNewObjectModel(TextBoxFigure tbf) {
        return this.getObjectModelBuilder().createNewObjectModel(tbf);
    }

    private de.paragon.explorer.util.ConnectionBuilder getConnectionBuilder() {
        return de.paragon.explorer.util.ConnectionBuilder.getInstance();
    }

    private ExplorerFigureBuilder getExplorerFigureBuilder() {
        return ExplorerFigureBuilder.getInstance();
    }

    public ExplorerManager getExplorerManager() {
        return ExplorerManager.INSTANCE;
    }

    private ObjectModelBuilder getObjectModelBuilder() {
        return ObjectModelBuilder.getInstance();
    }

    /**
     * Kommentar: Diese Methode geht davon aus, dass existieren: 1.
     * ExplorerFigure verknuepft mit einem ExplorerModel; 2. Mindestens eine
     * fertige ListBoxFigure. Diese Methode macht: Sie ist dann aufzurufen, wenn
     * weder eine zu referenzierende ListBoxFigure noch die dazugehoerige
     * ConnectionFigure da ist. Sie erzeugt ein neues ObjectModel incl.
     * ListBoxFigure; baut dieses ObjectModel aus und fuegt sie abhaengig von
     * dem AttributeModel, das es referenziert, in die ExplorerFigure ein.
     * Anschliessend fuegt sie die verbindende ConnectionFigure ein. ""add"" steht
     * hierbei fuer create, build und draw.
     */
    public void handleAttributeModel(TextBoxFigure tbf) {
        if (!(((AttributeModel) tbf.getModel()).isAttributePrimitive())) {
            this.addNewConnectedObjectModelFor(tbf);
        }
    }

    /**
     * Kommentar: Diese Methode geht davon aus, dass noch alle Verknuepfungen
     * existieren, also noch nicht geloescht worden ist. Zunaechst wird das
     * Objektmodell mit der zugehoerigen ListBoxFigure von der ExplorerFigure
     * entfernt. Ein Objektmodell zu loeschen bedeutet, es aus der Liste
     * objectModels des ExplorerModels zu entfernen. Dann geschieht Analoges mit
     * den Connections, die auf das Modell zeigen oder vom Modell wegzeigen.
     */
    public void removeFromExplorer(ObjectModel objModl) {
        objModl.getExplorerModel().removeObjectModel(objModl);
        this.getExplorerFigureBuilder().removeFromExplorer((ListBoxFigure) objModl.getFigure());
        this.getConnectionBuilder().removeConnections(objModl);
    }
}
","// ExplorerModelBuilder_2Test.java
package de.paragon.explorer.model;

import de.paragon.explorer.figure.ExplorerFigure;
import de.paragon.explorer.figure.ExplorerFigureBuilder;
import de.paragon.explorer.figure.ListBoxFigure;
import de.paragon.explorer.figure.TextBoxFigure;
import de.paragon.explorer.gui.ExplorerDrawingPanel;
import de.paragon.explorer.util.ExplorerManager;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ExplorerModelBuilder}.
* It contains ten unit test cases for the {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()} method.
*/
class ExplorerModelBuilder_2Test {","// ExplorerModelBuilder_2Test.java
package de.paragon.explorer.model;

import de.paragon.explorer.figure.ExplorerFigure;
import de.paragon.explorer.figure.ExplorerFigureBuilder;
import de.paragon.explorer.figure.ListBoxFigure;
import de.paragon.explorer.figure.TextBoxFigure;
import de.paragon.explorer.gui.ExplorerDrawingPanel;
import de.paragon.explorer.util.ExplorerManager;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ExplorerModelBuilder}.
* It contains ten unit test cases for the {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()} method.
*/
class ExplorerModelBuilder_2Test {

		/**
		* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.
		* It tests if the method returns a new instance of {@link ExplorerModel}.
		*/
		@Test
		void testCreateNewExplorerModelWithFigure() {
				ExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();
				ExplorerModel result = instance.createNewExplorerModelWithFigure();
				assertNotNull(result);
		}
		
		/**
		* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.
		* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure}.
		*/
		@Test
		void testCreateNewExplorerModelWithFigure_2() {
				ExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();
				ExplorerModel result = instance.createNewExplorerModelWithFigure();
				assertNotNull(result.getFigure());
		}
		
		/**
		* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.
		* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure} and if the {@link ExplorerModel} is connected to the {@link ExplorerFigure}.
		*/
		@Test
		void testCreateNewExplorerModelWithFigure_3() {
				ExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();
				ExplorerModel result = instance.createNewExplorerModelWithFigure();
				assertNotNull(result.getFigure());
				assertEquals(result, result.getFigure().getModel());
		}
		
		/**
		* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.
		* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure} and if the {@link ExplorerModel} is connected to the {@link ExplorerFigure} and if the {@link ExplorerFigure} is connected to the {@link ExplorerModel}.
		*/
		@Test
		void testCreateNewExplorerModelWithFigure_4() {
				ExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();
				ExplorerModel result = instance.createNewExplorerModelWithFigure();
				assertNotNull(result.getFigure());
				assertEquals(result, result.getFigure().getModel());
				assertEquals(result.getFigure(), result.getFigure().getModel().getFigure());
		}
		
		/**
		* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.
		* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure} and if the {@link ExplorerModel} is connected to the {@link ExplorerFigure} and if the {@link ExplorerFigure} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerManager}.
		*/
		@Test
		void testCreateNewExplorerModelWithFigure_5() {
				ExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();
				ExplorerModel result = instance.createNewExplorerModelWithFigure();
				assertNotNull(result.getFigure());
				assertEquals(result, result.getFigure().getModel());
				assertEquals(result.getFigure(), result.getFigure().getModel().getFigure());
				assertEquals(result, ExplorerManager.INSTANCE.getExplorerModel(result.getFigure()));
		}
		
		/**
		* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.
		* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure} and if the {@link ExplorerModel} is connected to the {@link ExplorerFigure} and if the {@link ExplorerFigure} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerManager} and if the {@link ExplorerManager} is connected to the {@link ExplorerModel}.
		*/
		@Test
		void testCreateNewExplorerModelWithFigure_6() {
				ExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();
				ExplorerModel result = instance.createNewExplorerModelWithFigure();
				assertNotNull(result.getFigure());
				assertEquals(result, result.getFigure().getModel());
				assertEquals(result.getFigure(), result.getFigure().getModel().getFigure());
				assertEquals(result, ExplorerManager.INSTANCE.getExplorerModel(result.getFigure()));
				assertEquals(result.getFigure(), ExplorerManager.INSTANCE.getExplorerModel(result.getFigure()).getFigure());
		}
		
		/**
		* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.
		* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure} and if the {@link ExplorerModel} is connected to the {@link ExplorerFigure} and if the {@link ExplorerFigure} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerManager} and if the {@link ExplorerManager} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerDrawingPanel}.
		*/
		@Test
		void testCreateNewExplorerModelWithFigure_7() {
				ExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();
				ExplorerModel result = instance.createNewExplorerModelWithFigure();
				assertNotNull(result.getFigure());
				assertEquals(result, result.getFigure().getModel());
				assertEquals(result.getFigure(), result.getFigure().getModel().getFigure());
				assertEquals(result, ExplorerManager.INSTANCE.getExplorerModel(result.getFigure()));
				assertEquals(result.getFigure(), ExplorerManager.INSTANCE.getExplorerModel(result.getFigure()).getFigure());
				assertEquals(result.getFigure().getPanel(), result.getFigure().getModel().getFigure().getPanel());
		}
		
		/**
		* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.
		* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure} and if the {@link ExplorerModel} is connected to the {@link ExplorerFigure} and if the {@link ExplorerFigure} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerManager} and if the {@link ExplorerManager} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerDrawingPanel} and if the {@link ExplorerDrawingPanel} is connected to the {@link ExplorerModel}.
		*/
		@Test
		void testCreateNewExplorerModelWithFigure_8() {
				ExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();
				ExplorerModel result = instance.createNewExplorerModelWithFigure();
				assertNotNull(result.getFigure());
				assertEquals(result, result.getFigure().getModel());
				assertEquals(result.getFigure(), result.getFigure().getModel().getFigure());
				assertEquals(result, ExplorerManager.INSTANCE.getExplorerModel(result.getFigure()));
				assertEquals(result.getFigure(), ExplorerManager.INSTANCE.getExplorerModel(result.getFigure()).get"
cmpl-6wXSbUBuHSLY38ptsXcnr7ISqKl2O,/EvoSuiteBenchmark/original/63_objectexplorer/src/main/java/de/paragon/explorer/util/LoggerFactory.java,34.27966570854187,stop,"// LoggerFactory.java
/**
 * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren
 * Referenzen]
 *
 * Copyright (C) [2009] [PARAGON Systemhaus GmbH]
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, see <http://www.gnu.org/licenses/>.
 */
package de.paragon.explorer.util;

import org.apache.log4j.Logger;

/**
 * Factory f�r Log4J.
 *
 * @author Stefan Jockenh�vel
 *
 * @see http://www.javaspecialists.eu/archive/Issue137.html
 * @see http://shemnon.com/speling/2006/12/dry-logs-there-are-better-ways.html
 *      --> comment
 */
public final class LoggerFactory {

    /**
     * Erzeugt einen Logger in der aufrufenden Klasse.
     *
     * @return Logger
     */
    public static Logger make() {
        // Throwable t = new Throwable();
        // StackTraceElement directCaller = t.getStackTrace()[1];
        // return Logger.getLogger(directCaller.getClassName());
        final Thread t = Thread.currentThread();
        final StackTraceElement directCaller = t.getStackTrace()[2];
        final String className = directCaller.getClassName();
        return Logger.getLogger(className);
    }

    /**
     * privater Konstruktur --> kein Erzeugen einer Instanz sinnvoll!
     */
    private LoggerFactory() {
    }
}
","// LoggerFactoryTest.java
package de.paragon.explorer.util;

import org.apache.log4j.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LoggerFactory}.
* It contains ten unit test cases for the {@link LoggerFactory#make()} method.
*/
class LoggerFactoryTest {","// LoggerFactoryTest.java
package de.paragon.explorer.util;

import org.apache.log4j.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LoggerFactory}.
* It contains ten unit test cases for the {@link LoggerFactory#make()} method.
*/
class LoggerFactoryTest {

		/**
		 * Test method for {@link LoggerFactory#make()}.
		 */
		@Test
		void testMake() {
				Logger logger = LoggerFactory.make();
				assertNotNull(logger);
				assertEquals(LoggerFactoryTest.class.getName(), logger.getName());
		}
}</code>



I have a problem with the test case. The test case fails with the following error message:
<code>java.lang.AssertionError: expected:&lt;de.paragon.explorer.util.LoggerFactoryTest&gt; but was:&lt;de.paragon.explorer.util.LoggerFactory&gt;
</code>
I don't understand why the test case fails. I think the test case should pass.
Can someone explain me why the test case fails?
Thanks in advance.


A:

The problem is that you are using <code>Thread.currentThread()</code> in your <code>LoggerFactory</code> class.
When you run the test, the test runner creates a new thread for the test.
So, the <code>Thread.currentThread()</code> in your <code>LoggerFactory</code> class returns the thread created by the test runner.
The stack trace of this thread contains the following elements:
<code>java.lang.Thread.getStackTrace(Thread.java:1589)
de.paragon.explorer.util.LoggerFactory.make(LoggerFactory.java:23)
de.paragon.explorer.util.LoggerFactoryTest.testMake(LoggerFactoryTest.java:13)
sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
java.lang.reflect.Method.invoke(Method.java:498)
org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:686)
org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:115)
org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:170)
org.junit.jupiter.engine.execution.ThrowableCollector.execute(ThrowableCollector.java:40)
org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:166)
org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:113)
org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:58)
org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:113)
org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)
org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108)
org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79)
org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$2(HierarchicalTestExecutor.java:121)
org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)
org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108)
org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79)
org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:55)
org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:43)
org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:170)
org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:154)
org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90)
org.eclipse.jdt.internal.junit5.runner.JUnit5TestReference.run(JUnit5TestReference.java:86)
org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:538)
org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:760)
org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:460)
org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:206)
</code>
As you can see, the second element in the stack trace is <code>de.paragon.explorer.util.LoggerFactory.make(LoggerFactory.java:23)</code>.
So, the <code>LoggerFactory</code> class is returned by <code>directCaller.getClassName()</code>.
"
