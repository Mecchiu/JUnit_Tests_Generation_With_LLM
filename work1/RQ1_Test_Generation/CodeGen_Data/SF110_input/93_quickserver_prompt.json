[
  {
    "numberTests": "ten",
    "original_code": "// NonBlockingClientHandler.java\n/*\n * This file is part of the QuickServer library \n * Copyright (C) QuickServer.org\n *\n * Use, modification, copying and distribution of this software is subject to\n * the terms and conditions of the GNU Lesser General Public License. \n * You should have received a copy of the GNU LGP License along with this \n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\n *\n * For questions, suggestions, bug-reports, enhancement-requests etc.\n * visit http://www.quickserver.org\n *\n */\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\n\npublic class NonBlockingClientHandler extends BasicClientHandler {\n\n    private static final Logger logger \u003d Logger.getLogger(NonBlockingClientHandler.class.getName());\n\n    //v1.4.5\n    protected ClientWriteHandler clientWriteHandler;\n\n    private SocketChannel socketChannel;\n\n    protected ArrayList readByteBuffer \u003d new ArrayList();\n\n    protected ArrayList writeByteBuffer \u003d new ArrayList();\n\n    protected SelectionKey selectionKey;\n\n    protected volatile int threadAccessCount \u003d 0;\n\n    protected volatile boolean willReturn;\n\n    protected volatile boolean waitingForFinalWrite;\n\n    //one for each event ACCEPT, WRITE, READ\n    private static int maxThreadAccessCount \u003d 5;\n\n    private static boolean wakeupSelectorAfterRegisterWrite \u003d true;\n\n    private static boolean wakeupSelectorAfterRegisterRead \u003d true;\n\n    //nio ssl\n    //private final SSLSession session;\n    private boolean initialHandshakeStatus \u003d false;\n\n    private SSLEngineResult.HandshakeStatus handshakeStatus;\n\n    private SSLEngineResult.Status status \u003d null;\n\n    private ByteBuffer dummyByteBuffer \u003d ByteBuffer.allocate(0);\n\n    private ByteBuffer peerNetData \u003d null;\n\n    private boolean sslShutdown \u003d false;\n\n    /**\n     * Sets the flag to wakeup Selector After RegisterForWrite is called.\n     * @since 1.4.7\n     */\n    public static void setWakeupSelectorAfterRegisterWrite(boolean flag) {\n        wakeupSelectorAfterRegisterWrite \u003d flag;\n    }\n\n    /**\n     * Returns wakeupSelectorAfterRegisterWrite the flag that controls if wakeup is called on Selector\n     * after RegisterForWrite is called.\n     * @since 1.4.7\n     */\n    public static boolean getWakeupSelectorAfterRegisterWrite() {\n        return wakeupSelectorAfterRegisterWrite;\n    }\n\n    /**\n     * Sets the flag to wakeup Selector After RegisterForRead is called.\n     * @since 1.4.7\n     */\n    public static void setWakeupSelectorAfterRegisterRead(boolean flag) {\n        wakeupSelectorAfterRegisterRead \u003d flag;\n    }\n\n    /**\n     * Returns wakeupSelectorAfterRegisterRead the flag that controls if wakeup is called on Selector\n     * after RegisterForRead is called.\n     * @since 1.4.7\n     */\n    public static boolean getWakeupSelectorAfterRegisterRead() {\n        return wakeupSelectorAfterRegisterRead;\n    }\n\n    /**\n     * Sets the maximum count of thread allowed to run objects of this class at a time.\n     * @since 1.4.7\n     */\n    public static void setMaxThreadAccessCount(int count) {\n        if (count \u003c 3 \u0026\u0026 count !\u003d -1)\n            throw new IllegalArgumentException(\"Value should be \u003e\u003d3 or -1\");\n        maxThreadAccessCount \u003d count;\n    }\n\n    /**\n     * Returns the maximum count of thread allowed to run objects of this class at a time.\n     * @since 1.4.7\n     */\n    public static int getMaxThreadAccessCount() {\n        return maxThreadAccessCount;\n    }\n\n    //v1.4.7\n    private ByteBufferOutputStream byteBufferOutputStream;\n\n    public NonBlockingClientHandler(int instanceCount) {\n        super(instanceCount);\n    }\n\n    public NonBlockingClientHandler() {\n        super();\n    }\n\n    public void clean() {\n        logger.finest(\"Starting clean - \" + getName());\n        if (threadAccessCount !\u003d 0) {\n            logger.warning(\"Thread Access Count was not 0!: \" + threadAccessCount);\n            if (Assertion.isEnabled()) {\n                assertionSystemExit();\n            }\n            threadAccessCount \u003d 0;\n        }\n        while (readByteBuffer.isEmpty() \u003d\u003d false) {\n            try {\n                getServer().getByteBufferPool().returnObject(readByteBuffer.remove(0));\n            } catch (Exception er) {\n                logger.warning(\"Error in returning read ByteBuffer to pool: \" + er);\n                break;\n            }\n        }\n        while (writeByteBuffer.isEmpty() \u003d\u003d false) {\n            try {\n                getServer().getByteBufferPool().returnObject(writeByteBuffer.remove(0));\n            } catch (Exception er) {\n                appLogger.warning(\"Error in returning write ByteBuffer to pool: \" + er);\n                break;\n            }\n        }\n        if (peerNetData !\u003d null) {\n            try {\n                getServer().getByteBufferPool().returnObject(peerNetData);\n            } catch (Exception er) {\n                appLogger.warning(\"Error in returning peerNetData to pool: \" + er);\n            }\n        }\n        if (selectionKey !\u003d null) {\n            selectionKey.cancel();\n            selectionKey.selector().wakeup();\n            selectionKey \u003d null;\n        }\n        willReturn \u003d false;\n        waitingForFinalWrite \u003d false;\n        socketChannel \u003d null;\n        if (byteBufferOutputStream !\u003d null) {\n            byteBufferOutputStream.close();\n        }\n        super.clean();\n        //1.4.5\n        clientWriteHandler \u003d null;\n        byteBufferOutputStream \u003d null;\n        sslShutdown \u003d false;\n        logger.finest(\"Finished clean - \" + getName());\n    }\n\n    protected void finalize() throws Throwable {\n        clean();\n        super.finalize();\n    }\n\n    public void handleClient(TheClient theClient) throws Exception {\n        super.handleClient(theClient);\n        //v1.4.5\n        setClientWriteHandler(theClient.getClientWriteHandler());\n        //1.4.5\n        setSocketChannel(theClient.getSocketChannel());\n    }\n\n    protected void setInputStream(InputStream in) throws IOException {\n        this.in \u003d in;\n        if (getDataMode(DataType.IN) \u003d\u003d DataMode.STRING) {\n            b_in \u003d null;\n            o_in \u003d null;\n            bufferedReader \u003d null;\n        } else if (getDataMode(DataType.IN) \u003d\u003d DataMode.OBJECT) {\n            b_in \u003d null;\n            bufferedReader \u003d null;\n            o_in \u003d new ObjectInputStream(in);\n        } else if (getDataMode(DataType.IN) \u003d\u003d DataMode.BYTE || getDataMode(DataType.IN) \u003d\u003d DataMode.BINARY) {\n            o_in \u003d null;\n            bufferedReader \u003d null;\n            b_in \u003d null;\n        }\n    }\n\n    public BufferedReader getBufferedReader() {\n        throw new IllegalStateException(\"Access to BufferedReader in not allowed in Non-Blocking mode!\");\n    }\n\n    public void closeConnection() {\n        logger.finest(\"inside\");\n        synchronized (this) {\n            if (connection \u003d\u003d false)\n                return;\n            if (waitingForFinalWrite)\n                return;\n            if (getSelectionKey() !\u003d null \u0026\u0026 getSelectionKey().isValid() \u0026\u0026 lost \u003d\u003d false) {\n                waitingForFinalWrite \u003d true;\n            } else {\n                connection \u003d false;\n            }\n        }\n        try {\n            if (getSocketChannel() !\u003d null \u0026\u0026 socket !\u003d null) {\n                if (waitingForFinalWrite) {\n                    try {\n                        waitTillFullyWritten();\n                    } catch (Exception error) {\n                        logger.warning(\"Error in waitingForFinalWrite : \" + error);\n                        if (logger.isLoggable(Level.FINE)) {\n                            logger.fine(\"StackTrace:\\n\" + MyString.getStackTrace(error));\n                        }\n                    }\n                }\n                //end of waitingForFinalWrite\n                if (isSecure() \u003d\u003d true) {\n                    sslShutdown \u003d true;\n                    if (lost \u003d\u003d false \u0026\u0026 sslEngine.isOutboundDone() \u003d\u003d false) {\n                        logger.finest(\"SSL isOutboundDone is false\");\n                        if (byteBufferOutputStream.doShutdown() \u003d\u003d false) {\n                            return;\n                        }\n                    } else if (sslEngine.isOutboundDone()) {\n                        logger.finest(\"SSL Outbound is done.\");\n                    }\n                }\n                doPostCloseActivity();\n            }\n            //if socket\n        } catch (IOException e) {\n            logger.warning(\"Error in closeConnection : \" + e);\n            if (logger.isLoggable(Level.FINE)) {\n                logger.fine(\"StackTrace:\\n\" + MyString.getStackTrace(e));\n            }\n        } catch (NullPointerException npe) {\n            logger.fine(\"NullPointerException: \" + npe);\n            if (logger.isLoggable(Level.FINE)) {\n                logger.fine(\"StackTrace:\\n\" + MyString.getStackTrace(npe));\n            }\n        }\n    }\n\n    private void doPostCloseActivity() throws IOException {\n        connection \u003d false;\n        byteBufferOutputStream.forceNotify();\n        getSelectionKey().cancel();\n        if (getServer() !\u003d null) {\n            getServer().getSelector().wakeup();\n        }\n        synchronized (this) {\n            if (hasEvent(ClientEvent.MAX_CON) \u003d\u003d false) {\n                notifyCloseOrLost();\n            }\n            if (getSocketChannel().isOpen()) {\n                logger.finest(\"Closing SocketChannel\");\n                getSocketChannel().close();\n            }\n        }\n    }\n\n    public boolean closeIfSSLOutboundDone() {\n        if (isSecure() \u003d\u003d false)\n            throw new IllegalStateException(\"Client is not in secure mode!\");\n        if (sslEngine.isOutboundDone()) {\n            logger.finest(\"SSL Outbound is done.\");\n            try {\n                if (getSocketChannel().isOpen()) {\n                    logger.finest(\"Closing SocketChannel\");\n                    getSocketChannel().close();\n                }\n            } catch (IOException e) {\n                logger.fine(\"IGNORE: Error in Closing SocketChannel: \" + e);\n            }\n            return true;\n        } else {\n            logger.finest(\"SSL Outbound is not done.\");\n            return false;\n        }\n    }\n\n    /**\n     * waitTillFullyWritten\n     * @since 1.4.7\n     */\n    public void waitTillFullyWritten() {\n        Object waitLock \u003d new Object();\n        if (byteBufferOutputStream.isDataAvailableForWrite(waitLock)) {\n            if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {\n                logger.finest(\"Waiting \" + getName());\n            }\n            try {\n                synchronized (waitLock) {\n                    //2 min max\n                    waitLock.wait(1000 * 60 * 2);\n                }\n            } catch (InterruptedException ie) {\n                logger.warning(\"Error: \" + ie);\n            }\n            if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {\n                logger.finest(\"Done. \" + getName());\n            }\n        }\n    }\n\n    public void run() {\n        if (unprocessedClientEvents.isEmpty()) {\n            logger.finest(\"No unprocessed ClientEvents!\");\n            return;\n        }\n        synchronized (this) {\n            if (willReturn) {\n                return;\n            } else {\n                threadAccessCount++;\n            }\n        }\n        ClientEvent currentEvent \u003d (ClientEvent) unprocessedClientEvents.poll();\n        if (currentEvent \u003d\u003d null) {\n            threadEvent.set(null);\n            logger.finest(\"No unprocessed ClientEvents! pool was null\");\n            return;\n        }\n        if (logger.isLoggable(Level.FINEST)) {\n            StringBuilder sb \u003d new StringBuilder();\n            sb.append(\"Running \").append(getName());\n            sb.append(\" using \");\n            sb.append(Thread.currentThread().getName());\n            sb.append(\" for \");\n            synchronized (clientEvents) {\n                if (clientEvents.size() \u003e 1) {\n                    sb.append(currentEvent + \", Current Events - \" + clientEvents);\n                } else {\n                    sb.append(currentEvent);\n                }\n            }\n            logger.finest(sb.toString());\n        }\n        logger.finest(\"threadAccessCount: \" + threadAccessCount);\n        threadEvent.set(currentEvent);\n        try {\n            if (maxThreadAccessCount !\u003d -1 \u0026\u0026 threadAccessCount \u003e maxThreadAccessCount) {\n                logger.warning(\"ThreadAccessCount can\u0027t go beyond \" + maxThreadAccessCount + \": \" + threadAccessCount);\n                if (Assertion.isEnabled()) {\n                    throw new AssertionError(\"ThreadAccessCount can\u0027t go beyond \" + maxThreadAccessCount + \": \" + threadAccessCount);\n                }\n                return;\n            }\n            if (socket \u003d\u003d null)\n                throw new SocketException(\"Socket was null!\");\n            if (getThreadEvent() \u003d\u003d ClientEvent.ACCEPT || getThreadEvent() \u003d\u003d ClientEvent.MAX_CON) {\n                prepareForRun();\n                Assertion.affirm(willReturn \u003d\u003d false, \"WillReturn has to be false!: \" + willReturn);\n            }\n            if (getThreadEvent() \u003d\u003d ClientEvent.MAX_CON) {\n                processMaxConnection(currentEvent);\n            }\n            try {\n                if (getThreadEvent() \u003d\u003d ClientEvent.ACCEPT) {\n                    registerForRead();\n                    clientEventHandler.gotConnected(this);\n                    if (authorised \u003d\u003d false) {\n                        if (clientAuthenticationHandler \u003d\u003d null \u0026\u0026 authenticator \u003d\u003d null) {\n                            authorised \u003d true;\n                            logger.finest(\"No Authenticator \" + getName() + \" so return thread.\");\n                        } else {\n                            if (clientAuthenticationHandler !\u003d null) {\n                                AuthStatus authStatus \u003d null;\n                                do {\n                                    authStatus \u003d processAuthorisation();\n                                } while (authStatus \u003d\u003d AuthStatus.FAILURE);\n                                if (authStatus \u003d\u003d AuthStatus.SUCCESS)\n                                    authorised \u003d true;\n                            } else {\n                                processAuthorisation();\n                            }\n                            if (authorised)\n                                logger.finest(\"Authentication done \" + getName() + \", so return thread.\");\n                            else\n                                logger.finest(\"askAuthentication() done \" + getName() + \", so return thread.\");\n                        }\n                    }\n                    //end authorised\n                    //return thread to pool\n                    returnThread();\n                    return;\n                }\n                if (connection \u0026\u0026 getThreadEvent() \u003d\u003d ClientEvent.READ) {\n                    if (processRead())\n                        return;\n                }\n                if (connection \u0026\u0026 getThreadEvent() \u003d\u003d ClientEvent.WRITE) {\n                    if (processWrite())\n                        return;\n                }\n            } catch (SocketException e) {\n                appLogger.finest(\"SocketException - Client [\" + getHostAddress() + \"]: \" + e.getMessage());\n                //e.printStackTrace();\n                lost \u003d true;\n            } catch (AppException e) {\n                //errors from Application\n                appLogger.finest(\"AppException \" + Thread.currentThread().getName() + \": \" + e.getMessage());\n            } catch (javax.net.ssl.SSLException e) {\n                lost \u003d true;\n                if (Assertion.isEnabled()) {\n                    appLogger.info(\"SSLException - Client [\" + getHostAddress() + \"] \" + Thread.currentThread().getName() + \": \" + e);\n                } else {\n                    appLogger.warning(\"SSLException - Client [\" + getHostAddress() + \"]: \" + e);\n                }\n            } catch (ConnectionLostException e) {\n                lost \u003d true;\n                if (e.getMessage() !\u003d null)\n                    appLogger.finest(\"Connection lost \" + Thread.currentThread().getName() + \": \" + e.getMessage());\n                else\n                    appLogger.finest(\"Connection lost \" + Thread.currentThread().getName());\n            } catch (ClosedChannelException e) {\n                lost \u003d true;\n                appLogger.finest(\"Channel closed \" + Thread.currentThread().getName() + \": \" + e);\n            } catch (IOException e) {\n                lost \u003d true;\n                appLogger.fine(\"IOError \" + Thread.currentThread().getName() + \": \" + e);\n            } catch (AssertionError er) {\n                logger.warning(\"[AssertionError] \" + getName() + \" \" + er);\n                if (logger.isLoggable(Level.FINEST)) {\n                    logger.finest(\"StackTrace \" + Thread.currentThread().getName() + \": \" + MyString.getStackTrace(er));\n                }\n                assertionSystemExit();\n            } catch (Error er) {\n                logger.warning(\"[Error] \" + er);\n                if (logger.isLoggable(Level.FINEST)) {\n                    logger.finest(\"StackTrace \" + Thread.currentThread().getName() + \": \" + MyString.getStackTrace(er));\n                }\n                if (Assertion.isEnabled()) {\n                    assertionSystemExit();\n                }\n                lost \u003d true;\n            } catch (RuntimeException re) {\n                logger.warning(\"[RuntimeException] \" + MyString.getStackTrace(re));\n                if (Assertion.isEnabled()) {\n                    assertionSystemExit();\n                }\n                lost \u003d true;\n            }\n            if (getThreadEvent() !\u003d ClientEvent.MAX_CON) {\n                notifyCloseOrLost();\n            }\n            if (connection) {\n                logger.finest(Thread.currentThread().getName() + \" calling closeConnection()\");\n                closeConnection();\n            }\n            if (connection \u003d\u003d true \u0026\u0026 lost \u003d\u003d true \u0026\u0026 waitingForFinalWrite) {\n                byteBufferOutputStream.forceNotify();\n            }\n        } catch (javax.net.ssl.SSLException se) {\n            logger.warning(\"SSLException \" + Thread.currentThread().getName() + \" - \" + se);\n        } catch (IOException ie) {\n            logger.warning(\"IOError \" + Thread.currentThread().getName() + \" - Closing Client : \" + ie);\n        } catch (RuntimeException re) {\n            logger.warning(\"[RuntimeException] \" + getName() + \" \" + Thread.currentThread().getName() + \" - \" + MyString.getStackTrace(re));\n            if (Assertion.isEnabled()) {\n                assertionSystemExit();\n            }\n        } catch (Exception e) {\n            logger.warning(\"Error \" + Thread.currentThread().getName() + \" - Event:\" + getThreadEvent() + \" - Socket:\" + socket + \" : \" + e);\n            logger.fine(\"StackTrace: \" + getName() + \"\\n\" + MyString.getStackTrace(e));\n            if (Assertion.isEnabled()) {\n                assertionSystemExit();\n            }\n        } catch (Error e) {\n            logger.warning(\"Error \" + Thread.currentThread().getName() + \" - Event:\" + getThreadEvent() + \" - Socket:\" + socket + \" : \" + e);\n            logger.fine(\"StackTrace: \" + getName() + \"\\n\" + MyString.getStackTrace(e));\n            if (Assertion.isEnabled()) {\n                assertionSystemExit();\n            }\n        }\n        synchronized (this) {\n            try {\n                if (getSelectionKey() !\u003d null \u0026\u0026 getSelectionKey().isValid()) {\n                    logger.finest(\"Canceling SelectionKey\");\n                    getSelectionKey().cancel();\n                }\n                if (socket !\u003d null \u0026\u0026 socket.isClosed() \u003d\u003d false) {\n                    logger.finest(\"Closing Socket\");\n                    socket.close();\n                }\n                if (getSocketChannel() !\u003d null \u0026\u0026 getSocketChannel().isOpen()) {\n                    logger.finest(\"Closing SocketChannel\");\n                    socketChannel.close();\n                }\n            } catch (Exception re) {\n                logger.warning(\"Error closing Socket/Channel: \" + re);\n            }\n        }\n        //end synchronized\n        willClean \u003d true;\n        returnClientData();\n        boolean returnClientHandler \u003d false;\n        synchronized (lockObj) {\n            returnThread();\n            returnClientHandler \u003d checkReturnClientHandler();\n        }\n        if (returnClientHandler) {\n            //return to pool\n            returnClientHandler();\n        }\n    }\n\n    protected boolean checkReturnClientHandler() {\n        if (willReturn \u003d\u003d false) {\n            willReturn \u003d true;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Process read\n     * @return value indicates if the thread should return form run()\n     */\n    private boolean processRead() throws Exception {\n        if (doRead()) {\n            //return to pool\n            returnThread();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    private boolean doRead() throws Exception {\n        int count \u003d 0;\n        int fullCount \u003d 0;\n        while (true) {\n            try {\n                if (peerNetData \u003d\u003d null) {\n                    peerNetData \u003d (ByteBuffer) getServer().getByteBufferPool().borrowObject();\n                }\n                count \u003d getSocketChannel().read(peerNetData);\n                if (count \u003c 0) {\n                    //logger.finest(\"SocketChannel read was \"+count+\"!\");\n                    getServer().getByteBufferPool().returnObject(peerNetData);\n                    peerNetData \u003d null;\n                    break;\n                } else {\n                    fullCount +\u003d count;\n                }\n                // Make readable\n                peerNetData.flip();\n                ByteBuffer peerAppData \u003d null;\n                //--\n                if (sslEngine !\u003d null) {\n                    SSLEngineResult res;\n                    peerAppData \u003d (ByteBuffer) getServer().getByteBufferPool().borrowObject();\n                    do {\n                        res \u003d sslEngine.unwrap(peerNetData, peerAppData);\n                        logger.info(\"Unwrapping:\\n\" + res);\n                    } while (res.getStatus() \u003d\u003d SSLEngineResult.Status.OK \u0026\u0026 res.getHandshakeStatus() \u003d\u003d SSLEngineResult.HandshakeStatus.NEED_UNWRAP \u0026\u0026 res.bytesProduced() \u003d\u003d 0);\n                    if (res.getHandshakeStatus() \u003d\u003d SSLEngineResult.HandshakeStatus.FINISHED) {\n                        logger.info(\"HandshakeStatus.FINISHED!\");\n                        finishInitialHandshake();\n                    }\n                    if (peerAppData.position() \u003d\u003d 0 \u0026\u0026 res.getStatus() \u003d\u003d SSLEngineResult.Status.OK \u0026\u0026 peerNetData.hasRemaining()) {\n                        logger.info(\"peerNetData hasRemaining and pos\u003d0!\");\n                        res \u003d sslEngine.unwrap(peerNetData, peerAppData);\n                        logger.info(\"Unwrapping:\\n\" + res);\n                    }\n                    /*\n\t\t\t\t\t * OK, OVERFLOW, UNDERFLOW, CLOSED\n\t\t\t\t\t */\n                    status \u003d res.getStatus();\n                    handshakeStatus \u003d res.getHandshakeStatus();\n                    if (status !\u003d SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                        logger.warning(\"Buffer overflow: \" + res.toString());\n                    } else if (status \u003d\u003d SSLEngineResult.Status.CLOSED) {\n                        logger.fine(\"Connection is being closed by peer.\");\n                        lost \u003d true;\n                        System.out.println(\"NEdd to code for shutdow of SSL\");\n                        break;\n                    }\n                    peerNetData.compact();\n                    peerAppData.flip();\n                    if (handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.NEED_TASK || handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.NEED_WRAP || handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.FINISHED) {\n                        doHandshake();\n                    }\n                    //return peerAppData.remaining();\n                    logger.fine(\"peerAppData.remaining(): \" + peerAppData.remaining());\n                } else {\n                    peerAppData \u003d peerNetData;\n                    peerNetData \u003d null;\n                }\n                //--\n                readByteBuffer.add(peerAppData);\n                peerAppData \u003d null;\n            } catch (Exception error) {\n                logger.finest(\"Error in data read: \" + error);\n                if (sslEngine !\u003d null)\n                    sslEngine.closeInbound();\n                lost \u003d true;\n                synchronized (getInputStream()) {\n                    getInputStream().notifyAll();\n                }\n                throw error;\n            }\n            if (count \u003d\u003d 0)\n                break;\n        }\n        //end while\n        if (count \u003c 0) {\n            logger.finest(\"SocketChannel read was \" + count + \"!\");\n            if (sslEngine !\u003d null)\n                sslEngine.closeInbound();\n            lost \u003d true;\n            synchronized (getInputStream()) {\n                getInputStream().notifyAll();\n            }\n        } else {\n            logger.finest(fullCount + \" bytes read\");\n            if (fullCount !\u003d 0) {\n                updateLastCommunicationTime();\n                synchronized (getInputStream()) {\n                    //if any are waiting\n                    getInputStream().notify();\n                }\n                if (hasEvent(ClientEvent.ACCEPT) \u003d\u003d false) {\n                    processGotDataInBuffers();\n                }\n            }\n            //check if any data was read but not yet processed\n            while (getInputStream().available() \u003e 0) {\n                logger.finest(\"Sending again for processing...\");\n                if (hasEvent(ClientEvent.ACCEPT) \u003d\u003d false) {\n                    processGotDataInBuffers();\n                    break;\n                } else {\n                    synchronized (getInputStream()) {\n                        getInputStream().notifyAll();\n                    }\n                    Thread.sleep(100);\n                }\n            }\n            if (connection) {\n                registerForRead();\n                //getSelectionKey().selector().wakeup();\n                return true;\n            }\n        }\n        //end of else\n        logger.finest(\"We don\u0027t have connection, lets return all resources.\");\n        return false;\n    }\n\n    /**\n     * Process write\n     * @return value indicates if the thread should return form run()\n     */\n    private boolean processWrite() throws IOException {\n        if (doWrite()) {\n            //return to pool\n            returnThread();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    private boolean doWrite() throws IOException {\n        if (sslShutdown) {\n            if (byteBufferOutputStream.doShutdown() \u003d\u003d false) {\n                return true;\n            }\n            doPostCloseActivity();\n            logger.finest(\"We don\u0027t have connection, lets return all resources.\");\n            return false;\n        }\n        updateLastCommunicationTime();\n        boolean flag \u003d byteBufferOutputStream.writeAllByteBuffer();\n        if (flag \u003d\u003d false) {\n            registerWrite();\n        } else if (/*flag\u003d\u003dtrue \u0026\u0026 */\n        clientWriteHandler !\u003d null) {\n            clientWriteHandler.handleWrite(this);\n        }\n        if (connection) {\n            return true;\n        } else {\n            logger.finest(\"We don\u0027t have connection, lets return all resources.\");\n            return false;\n        }\n    }\n\n    protected void returnThread() {\n        //System.out.println(\"returnThread..\");\n        //(new Exception()).printStackTrace();\n        threadAccessCount--;\n        Assertion.affirm(threadAccessCount \u003e\u003d 0, \"ThreadAccessCount went less the 0! Value: \" + threadAccessCount);\n        //return is done at ClientThread end\n        removeEvent((ClientEvent) threadEvent.get());\n    }\n\n    protected void returnClientHandler() {\n        logger.finest(getName());\n        try {\n            for (int i \u003d 0; threadAccessCount !\u003d 0; i++) {\n                if (i \u003d\u003d 100) {\n                    logger.warning(\"ClientHandler must have got into a loop waiting for thread to free up! ThreadAccessCount\u003d\" + threadAccessCount);\n                    threadAccessCount \u003d 0;\n                    if (Assertion.isEnabled()) {\n                        assertionSystemExit();\n                    } else {\n                        break;\n                    }\n                }\n                if (threadAccessCount \u003c\u003d 0)\n                    break;\n                logger.finest(\"Waiting for other thread of \" + getName() + \" to finish\");\n                Thread.sleep(60);\n            }\n        } catch (InterruptedException ie) {\n            appLogger.warning(\"InterruptedException: \" + ie);\n        }\n        super.returnClientHandler();\n    }\n\n    public void setDataMode(DataMode dataMode, DataType dataType) throws IOException {\n        if (getDataMode(dataType) \u003d\u003d dataMode)\n            return;\n        appLogger.fine(\"Setting Type:\" + dataType + \", Mode:\" + dataMode);\n        super.checkDataModeSet(dataMode, dataType);\n        setDataModeNonBlocking(dataMode, dataType);\n    }\n\n    private void setDataModeNonBlocking(DataMode dataMode, DataType dataType) throws IOException {\n        logger.finest(\"ENTER\");\n        if (dataMode \u003d\u003d DataMode.STRING) {\n            if (dataType \u003d\u003d DataType.OUT) {\n                if (dataModeOUT \u003d\u003d DataMode.BYTE || dataModeOUT \u003d\u003d DataMode.BINARY) {\n                    dataModeOUT \u003d dataMode;\n                } else if (dataModeOUT \u003d\u003d DataMode.OBJECT) {\n                    dataModeOUT \u003d dataMode;\n                    o_out.flush();\n                    o_out \u003d null;\n                    b_out \u003d new BufferedOutputStream(out);\n                } else {\n                    Assertion.affirm(false, \"Unknown DataType.OUT DataMode - \" + dataModeOUT);\n                }\n                Assertion.affirm(b_out !\u003d null, \"BufferedOutputStream is still null!\");\n                Assertion.affirm(o_out \u003d\u003d null, \"ObjectOutputStream is still not null!\");\n            } else if (dataType \u003d\u003d DataType.IN) {\n                dataModeIN \u003d dataMode;\n                if (o_in !\u003d null) {\n                    if (o_in.available() !\u003d 0)\n                        logger.warning(\"Data looks to be present in ObjectInputStream\");\n                    o_in \u003d null;\n                }\n                b_in \u003d null;\n                bufferedReader \u003d null;\n                //input stream will work\n                Assertion.affirm(in !\u003d null, \"InputStream is still null!\");\n                Assertion.affirm(b_in \u003d\u003d null, \"BufferedInputStream is still not null!\");\n                Assertion.affirm(bufferedReader \u003d\u003d null, \"BufferedReader is still not null!\");\n            }\n        } else if (dataMode \u003d\u003d DataMode.OBJECT) {\n            if (dataType \u003d\u003d DataType.IN) {\n                //we will disable this for now\n                throw new IllegalArgumentException(\"Can\u0027t set DataType.IN mode to OBJECT when blocking mode is set as false!\");\n            }\n            if (dataType \u003d\u003d DataType.OUT) {\n                dataModeOUT \u003d dataMode;\n                b_out \u003d null;\n                o_out \u003d new ObjectOutputStream(out);\n                Assertion.affirm(o_out !\u003d null, \"ObjectOutputStream is still null!\");\n                o_out.flush();\n            } else if (dataType \u003d\u003d DataType.IN) {\n                dataModeIN \u003d dataMode;\n                b_in \u003d null;\n                bufferedReader \u003d null;\n                registerForRead();\n                //will block\n                o_in \u003d new ObjectInputStream(in);\n                Assertion.affirm(o_in !\u003d null, \"ObjectInputStream is still null!\");\n            }\n        } else if (dataMode \u003d\u003d DataMode.BYTE || dataMode \u003d\u003d DataMode.BINARY) {\n            if (dataType \u003d\u003d DataType.OUT) {\n                if (dataModeOUT \u003d\u003d DataMode.STRING || dataModeOUT \u003d\u003d DataMode.BYTE || dataModeOUT \u003d\u003d DataMode.BINARY) {\n                    dataModeOUT \u003d dataMode;\n                } else if (dataModeOUT \u003d\u003d DataMode.OBJECT) {\n                    dataModeOUT \u003d dataMode;\n                    o_out \u003d null;\n                    b_out \u003d new BufferedOutputStream(out);\n                } else {\n                    Assertion.affirm(false, \"Unknown DataType.OUT - DataMode: \" + dataModeOUT);\n                }\n                Assertion.affirm(b_out !\u003d null, \"BufferedOutputStream is still null!\");\n            } else if (dataType \u003d\u003d DataType.IN) {\n                dataModeIN \u003d dataMode;\n                o_in \u003d null;\n                bufferedReader \u003d null;\n                b_in \u003d null;\n                //input stream will work\n                Assertion.affirm(in !\u003d null, \"InputStream is still null!\");\n            } else {\n                throw new IllegalArgumentException(\"Unknown DataType : \" + dataType);\n            }\n        } else {\n            throw new IllegalArgumentException(\"Unknown DataMode : \" + dataMode);\n        }\n    }\n\n    protected byte[] readInputStream() throws IOException {\n        return readInputStream(getInputStream());\n    }\n\n    public void updateInputOutputStreams() throws IOException {\n        byteBufferOutputStream \u003d new ByteBufferOutputStream(writeByteBuffer, this);\n        setInputStream(new ByteBufferInputStream(readByteBuffer, this, getCharset()));\n        setOutputStream(byteBufferOutputStream);\n        //logger.warning(\"updateInputOutputStreams: \"+sslEngine);\n        if (sslEngine !\u003d null) {\n            sslEngine.setUseClientMode(false);\n            sslEngine.beginHandshake();\n            handshakeStatus \u003d sslEngine.getHandshakeStatus();\n            initialHandshakeStatus \u003d true;\n            /*\n\t\t\ttry {\n\t\t\t\tdoHandshake();\n\t\t\t} catch(Exception e) {\n\t\t\t\tlogger.warning(\"Error: \"+e);\n\t\t\t\tthrow new IOException(e.toString());\n\t\t\t}\n\t\t\t*/\n        }\n    }\n\n    public boolean getBlockingMode() {\n        return false;\n    }\n\n    public void setSocketChannel(SocketChannel socketChannel) {\n        this.socketChannel \u003d socketChannel;\n    }\n\n    public SocketChannel getSocketChannel() {\n        return socketChannel;\n    }\n\n    public void setSelectionKey(SelectionKey selectionKey) {\n        this.selectionKey \u003d selectionKey;\n    }\n\n    public SelectionKey getSelectionKey() {\n        if (selectionKey \u003d\u003d null)\n            selectionKey \u003d getSocketChannel().keyFor(getServer().getSelector());\n        return selectionKey;\n    }\n\n    private void processGotDataInBuffers() throws AppException, ConnectionLostException, ClassNotFoundException, IOException {\n        if (getInputStream().available() \u003d\u003d 0)\n            return;\n        logger.finest(\"Trying to process got data.. DataMode.IN\u003d\" + dataModeIN);\n        AuthStatus authStatus \u003d null;\n        //--For debug\n        ((ByteBufferInputStream) getInputStream()).dumpContent();\n        String temp \u003d null;\n        String rec \u003d null;\n        Object recObject \u003d null;\n        byte[] recByte \u003d null;\n        boolean timeToCheckForNewLineMiss \u003d false;\n        do {\n            //updateLastCommunicationTime();\n            if (dataModeIN \u003d\u003d DataMode.STRING) {\n                ByteBufferInputStream bbin \u003d (ByteBufferInputStream) getInputStream();\n                timeToCheckForNewLineMiss \u003d true;\n                while (bbin.isLineReady()) {\n                    rec \u003d bbin.readLine();\n                    if (rec \u003d\u003d null) {\n                        lost \u003d true;\n                        return;\n                    }\n                    if (getCommunicationLogging() \u0026\u0026 authorised \u003d\u003d true) {\n                        appLogger.log(Level.FINE, \"Got STRING [{0}] : {1}\", new Object[] { getHostAddress(), rec });\n                    }\n                    totalReadBytes \u003d totalReadBytes + rec.length();\n                    if (authorised \u003d\u003d false)\n                        authStatus \u003d clientAuthenticationHandler.handleAuthentication(this, rec);\n                    else\n                        clientCommandHandler.handleCommand(this, rec);\n                    if (isClosed() \u003d\u003d true)\n                        return;\n                    while (authStatus \u003d\u003d AuthStatus.FAILURE) authStatus \u003d processAuthorisation();\n                    if (authStatus \u003d\u003d AuthStatus.SUCCESS)\n                        authorised \u003d true;\n                    if (dataModeIN !\u003d DataMode.STRING) {\n                        break;\n                    }\n                    timeToCheckForNewLineMiss \u003d false;\n                }\n                //end of while\n                if (timeToCheckForNewLineMiss \u0026\u0026 bbin.availableOnlyInByteBuffer() \u003d\u003d 0) {\n                    return;\n                } else {\n                    timeToCheckForNewLineMiss \u003d false;\n                }\n            }\n            //if(dataModeIN \u003d\u003d DataMode.OBJECT) {\n            while (dataModeIN \u003d\u003d DataMode.OBJECT \u0026\u0026 o_in !\u003d null) {\n                //not sure if all bytes are in buffer..~ may need more read.. will get stuck..\n                recObject \u003d o_in.readObject();\n                if (recObject \u003d\u003d null) {\n                    lost \u003d true;\n                    return;\n                }\n                if (getCommunicationLogging() \u0026\u0026 authorised \u003d\u003d true) {\n                    appLogger.log(Level.FINE, \"Got OBJECT [{0}] : {1}\", new Object[] { getHostAddress(), recObject.toString() });\n                }\n                totalReadBytes \u003d totalReadBytes + 1;\n                if (authorised \u003d\u003d false)\n                    authStatus \u003d clientAuthenticationHandler.handleAuthentication(this, recObject);\n                else\n                    clientObjectHandler.handleObject(this, recObject);\n                if (isClosed() \u003d\u003d true)\n                    return;\n                while (authStatus \u003d\u003d AuthStatus.FAILURE) authStatus \u003d processAuthorisation();\n                if (authStatus \u003d\u003d AuthStatus.SUCCESS)\n                    authorised \u003d true;\n            }\n            //}\n            //if(dataModeIN \u003d\u003d DataMode.BYTE) {\n            while (dataModeIN \u003d\u003d DataMode.BYTE \u0026\u0026 getInputStream().available() !\u003d 0) {\n                rec \u003d readBytes();\n                if (rec \u003d\u003d null) {\n                    lost \u003d true;\n                    return;\n                }\n                if (getCommunicationLogging() \u0026\u0026 authorised \u003d\u003d true) {\n                    appLogger.log(Level.FINE, \"Got BYTE [{0}] : {1}\", new Object[] { getHostAddress(), rec });\n                }\n                totalReadBytes \u003d totalReadBytes + rec.length();\n                if (authorised \u003d\u003d false)\n                    authStatus \u003d clientAuthenticationHandler.handleAuthentication(this, rec);\n                else\n                    clientCommandHandler.handleCommand(this, rec);\n                if (isClosed() \u003d\u003d true)\n                    return;\n                while (authStatus \u003d\u003d AuthStatus.FAILURE) authStatus \u003d processAuthorisation();\n                if (authStatus \u003d\u003d AuthStatus.SUCCESS)\n                    authorised \u003d true;\n            }\n            //} else if(dataModeIN \u003d\u003d DataMode.BINARY) {\n            while (dataModeIN \u003d\u003d DataMode.BINARY \u0026\u0026 getInputStream().available() !\u003d 0) {\n                recByte \u003d readBinary();\n                if (recByte \u003d\u003d null) {\n                    lost \u003d true;\n                    return;\n                }\n                if (getCommunicationLogging() \u0026\u0026 authorised \u003d\u003d true) {\n                    if (getServer().isRawCommunicationLogging()) {\n                        if (getServer().getRawCommunicationMaxLength() \u003e 0 \u0026\u0026 recByte.length \u003e getServer().getRawCommunicationMaxLength()) {\n                            appLogger.log(Level.FINE, \"Got BINARY [{0}] : {1}; RAW: {2}{3}\", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length), new String(recByte, 0, getServer().getRawCommunicationMaxLength(), charset), \"...\" });\n                        } else {\n                            appLogger.log(Level.FINE, \"Got BINARY [{0}] : {1}; RAW: {2}\", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length), new String(recByte, charset) });\n                        }\n                    } else {\n                        appLogger.log(Level.FINE, \"Got BINARY [{0}] : {1}\", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length) });\n                    }\n                } else if (getCommunicationLogging()) {\n                    appLogger.log(Level.FINE, \"Got BINARY [{0}] : {1}\", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length) });\n                }\n                totalReadBytes \u003d totalReadBytes + recByte.length;\n                if (authorised \u003d\u003d false)\n                    authStatus \u003d clientAuthenticationHandler.handleAuthentication(this, recByte);\n                else\n                    clientBinaryHandler.handleBinary(this, recByte);\n                if (isClosed() \u003d\u003d true)\n                    return;\n                while (authStatus \u003d\u003d AuthStatus.FAILURE) authStatus \u003d processAuthorisation();\n                if (authStatus \u003d\u003d AuthStatus.SUCCESS)\n                    authorised \u003d true;\n            }\n            //} else {\n            if (dataModeIN !\u003d DataMode.STRING \u0026\u0026 dataModeIN !\u003d DataMode.OBJECT \u0026\u0026 dataModeIN !\u003d DataMode.BYTE \u0026\u0026 dataModeIN !\u003d DataMode.BINARY) {\n                throw new IllegalStateException(\"Incoming DataMode is not supported : \" + dataModeIN);\n            }\n        } while (getInputStream().available() !\u003d 0);\n    }\n\n    public void registerForRead() throws IOException, ClosedChannelException {\n        //System.out.println(\"registerForRead..\");\n        //(new Exception()).printStackTrace();\n        try {\n            if (getSelectionKey() \u003d\u003d null) {\n                boolean flag \u003d getServer().registerChannel(getSocketChannel(), SelectionKey.OP_READ, this);\n                if (flag) {\n                    logger.finest(\"Adding OP_READ as interest Ops for \" + getName());\n                } else if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {\n                    logger.finest(\"OP_READ is already present in interest Ops for \" + getName());\n                }\n            } else if (getSelectionKey().isValid()) {\n                if ((getSelectionKey().interestOps() \u0026 SelectionKey.OP_READ) \u003d\u003d 0) {\n                    logger.finest(\"Adding OP_READ to interest Ops for \" + getName());\n                    removeEvent(ClientEvent.READ);\n                    getSelectionKey().interestOps(getSelectionKey().interestOps() | SelectionKey.OP_READ);\n                    if (wakeupSelectorAfterRegisterRead) {\n                        getServer().getSelector().wakeup();\n                    }\n                } else {\n                    if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {\n                        logger.finest(\"OP_READ is already present in interest Ops for \" + getName());\n                    }\n                }\n            } else {\n                throw new IOException(\"SelectionKey is invalid!\");\n            }\n        } catch (CancelledKeyException e) {\n            throw new IOException(\"SelectionKey is cancelled!\");\n        }\n    }\n\n    public void registerForWrite() throws IOException, ClosedChannelException {\n        if (hasEvent(ClientEvent.RUN_BLOCKING) || hasEvent(ClientEvent.MAX_CON_BLOCKING)) {\n            throw new IllegalStateException(\"This method is only allowed under Non-Blocking mode.\");\n        }\n        if (clientWriteHandler \u003d\u003d null) {\n            throw new IllegalStateException(\"ClientWriteHandler has not been set!\");\n        }\n        registerWrite();\n    }\n\n    public void registerWrite() throws IOException {\n        //System.out.println(\"registerWrite..\");\n        //(new Exception()).printStackTrace();\n        try {\n            if (getSelectionKey() \u003d\u003d null) {\n                boolean flag \u003d getServer().registerChannel(getSocketChannel(), SelectionKey.OP_WRITE, this);\n                if (flag) {\n                    logger.finest(\"Adding OP_WRITE as interest Ops for \" + getName());\n                } else if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {\n                    logger.finest(\"OP_WRITE is already present in interest Ops for \" + getName());\n                }\n            } else if (getSelectionKey().isValid()) {\n                if ((getSelectionKey().interestOps() \u0026 SelectionKey.OP_WRITE) \u003d\u003d 0) {\n                    logger.finest(\"Adding OP_WRITE to interest Ops for \" + getName());\n                    removeEvent(ClientEvent.WRITE);\n                    getSelectionKey().interestOps(getSelectionKey().interestOps() | SelectionKey.OP_WRITE);\n                    if (wakeupSelectorAfterRegisterWrite) {\n                        getServer().getSelector().wakeup();\n                    }\n                } else {\n                    if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {\n                        logger.finest(\"OP_WRITE is already present in interest Ops for \" + getName());\n                    }\n                }\n            } else {\n                throw new IOException(\"SelectionKey is invalid!\");\n            }\n        } catch (CancelledKeyException e) {\n            throw new IOException(\"SelectionKey is cancelled!\");\n        }\n    }\n\n    protected void setClientWriteHandler(ClientWriteHandler handler) {\n        clientWriteHandler \u003d handler;\n    }\n\n    /**\n     * Returns number of thread currently in this object.\n     * @since 1.4.6\n     */\n    public int getThreadAccessCount() {\n        return threadAccessCount;\n    }\n\n    private void doHandshake() throws Exception {\n        while (true) {\n            SSLEngineResult res;\n            logger.fine(\"handshakeStatus: \" + handshakeStatus);\n            if (handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.FINISHED) {\n                if (initialHandshakeStatus) {\n                    finishInitialHandshake();\n                }\n                return;\n            } else if (handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.NEED_TASK) {\n                doTasks();\n                continue;\n            } else if (handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n                /*\n\t\t\t\t\tdoRead();\n\n\t\t\t\t\tif(initialHandshakeStatus \u0026\u0026 \n\t\t\t\t\t\t\tstatus \u003d\u003d SSLEngineResult.Status.BUFFER_UNDERFLOW) {\n\t\t\t\t\t\tregisterForRead();\n\t\t\t\t\t}\n\t\t\t\t\t*/\n                return;\n            } else if (handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                ByteBuffer netData \u003d (ByteBuffer) getServer().getByteBufferPool().borrowObject();\n                //netData.clear();\n                res \u003d sslEngine.wrap(dummyByteBuffer, netData);\n                logger.info(\"Wrapping:\\n\" + res);\n                assert res.bytesProduced() !\u003d 0 : \"No net data produced during handshake wrap.\";\n                assert res.bytesConsumed() \u003d\u003d 0 : \"App data consumed during handshake wrap.\";\n                handshakeStatus \u003d res.getHandshakeStatus();\n                //netData.flip(); -- no need to flip will be done when writing to sc\n                byteBufferOutputStream.addEncryptedByteBuffer(netData);\n                if (!doWrite()) {\n                    return;\n                }\n                //back to loop\n                continue;\n            } else if (handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n                assert false : \"doHandshake() should never reach the NOT_HANDSHAKING state\";\n                return;\n            }\n            //if\n        }\n        //loop\n    }\n\n    private void doTasks() {\n        Runnable task;\n        while ((task \u003d sslEngine.getDelegatedTask()) !\u003d null) {\n            logger.fine(\"Running the task.. START \");\n            task.run();\n            logger.fine(\"Running the task.. END\");\n        }\n        handshakeStatus \u003d sslEngine.getHandshakeStatus();\n        logger.fine(\"handshakeStatus: \" + handshakeStatus);\n    }\n\n    private void finishInitialHandshake() throws IOException {\n        initialHandshakeStatus \u003d false;\n    }\n\n    public boolean getInitialHandshakeStatus() {\n        return initialHandshakeStatus;\n    }\n\n    public ByteBuffer encrypt(ByteBuffer src) throws IOException {\n        if (initialHandshakeStatus) {\n            logger.fine(\"Writing not possible during handshake!\");\n            //Exception e \u003d new Exception();\n            //e.printStackTrace();\n            return null;\n        }\n        ByteBuffer dest \u003d null;\n        boolean isException \u003d false;\n        try {\n            src.flip();\n            dest \u003d (ByteBuffer) getServer().getByteBufferPool().borrowObject();\n            //dest.clear();\n            SSLEngineResult res \u003d sslEngine.wrap(src, dest);\n            logger.info(\"Wrapping:\\n\" + res);\n            //dest.flip();\n            return dest;\n        } catch (IOException e) {\n            logger.warning(\"IOException:\" + e);\n            isException \u003d true;\n            throw e;\n        } catch (Exception e) {\n            logger.warning(\"Exception:\" + e);\n            isException \u003d true;\n            throw new IOException(e.getMessage());\n        } finally {\n            if (isException \u003d\u003d true \u0026\u0026 dest !\u003d null) {\n                try {\n                    getServer().getByteBufferPool().returnObject(dest);\n                } catch (Exception er) {\n                    logger.warning(\"Error in returning ByteBuffer to pool: \" + er);\n                }\n            }\n        }\n    }\n}\n",
    "package": "org.quickserver.net.server.impl",
    "classname": "NonBlockingClientHandler",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/impl/NonBlockingClientHandler_0Test.java",
    "test_prompt": "// NonBlockingClientHandler_0Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#getWakeupSelectorAfterRegisterWrite()} method.\n*/\nclass NonBlockingClientHandler_0Test {",
    "method_signature": "getWakeupSelectorAfterRegisterWrite()",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// NonBlockingClientHandler.java\n/*\n * This file is part of the QuickServer library \n * Copyright (C) QuickServer.org\n *\n * Use, modification, copying and distribution of this software is subject to\n * the terms and conditions of the GNU Lesser General Public License. \n * You should have received a copy of the GNU LGP License along with this \n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\n *\n * For questions, suggestions, bug-reports, enhancement-requests etc.\n * visit http://www.quickserver.org\n *\n */\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\n\npublic class NonBlockingClientHandler extends BasicClientHandler {\n\n    private static final Logger logger \u003d Logger.getLogger(NonBlockingClientHandler.class.getName());\n\n    //v1.4.5\n    protected ClientWriteHandler clientWriteHandler;\n\n    private SocketChannel socketChannel;\n\n    protected ArrayList readByteBuffer \u003d new ArrayList();\n\n    protected ArrayList writeByteBuffer \u003d new ArrayList();\n\n    protected SelectionKey selectionKey;\n\n    protected volatile int threadAccessCount \u003d 0;\n\n    protected volatile boolean willReturn;\n\n    protected volatile boolean waitingForFinalWrite;\n\n    //one for each event ACCEPT, WRITE, READ\n    private static int maxThreadAccessCount \u003d 5;\n\n    private static boolean wakeupSelectorAfterRegisterWrite \u003d true;\n\n    private static boolean wakeupSelectorAfterRegisterRead \u003d true;\n\n    //nio ssl\n    //private final SSLSession session;\n    private boolean initialHandshakeStatus \u003d false;\n\n    private SSLEngineResult.HandshakeStatus handshakeStatus;\n\n    private SSLEngineResult.Status status \u003d null;\n\n    private ByteBuffer dummyByteBuffer \u003d ByteBuffer.allocate(0);\n\n    private ByteBuffer peerNetData \u003d null;\n\n    private boolean sslShutdown \u003d false;\n\n    /**\n     * Sets the flag to wakeup Selector After RegisterForWrite is called.\n     * @since 1.4.7\n     */\n    public static void setWakeupSelectorAfterRegisterWrite(boolean flag) {\n        wakeupSelectorAfterRegisterWrite \u003d flag;\n    }\n\n    /**\n     * Returns wakeupSelectorAfterRegisterWrite the flag that controls if wakeup is called on Selector\n     * after RegisterForWrite is called.\n     * @since 1.4.7\n     */\n    public static boolean getWakeupSelectorAfterRegisterWrite() {\n        return wakeupSelectorAfterRegisterWrite;\n    }\n\n    /**\n     * Sets the flag to wakeup Selector After RegisterForRead is called.\n     * @since 1.4.7\n     */\n    public static void setWakeupSelectorAfterRegisterRead(boolean flag) {\n        wakeupSelectorAfterRegisterRead \u003d flag;\n    }\n\n    /**\n     * Returns wakeupSelectorAfterRegisterRead the flag that controls if wakeup is called on Selector\n     * after RegisterForRead is called.\n     * @since 1.4.7\n     */\n    public static boolean getWakeupSelectorAfterRegisterRead() {\n        return wakeupSelectorAfterRegisterRead;\n    }\n\n    /**\n     * Sets the maximum count of thread allowed to run objects of this class at a time.\n     * @since 1.4.7\n     */\n    public static void setMaxThreadAccessCount(int count) {\n        if (count \u003c 3 \u0026\u0026 count !\u003d -1)\n            throw new IllegalArgumentException(\"Value should be \u003e\u003d3 or -1\");\n        maxThreadAccessCount \u003d count;\n    }\n\n    /**\n     * Returns the maximum count of thread allowed to run objects of this class at a time.\n     * @since 1.4.7\n     */\n    public static int getMaxThreadAccessCount() {\n        return maxThreadAccessCount;\n    }\n\n    //v1.4.7\n    private ByteBufferOutputStream byteBufferOutputStream;\n\n    public NonBlockingClientHandler(int instanceCount) {\n        super(instanceCount);\n    }\n\n    public NonBlockingClientHandler() {\n        super();\n    }\n\n    public void clean() {\n        logger.finest(\"Starting clean - \" + getName());\n        if (threadAccessCount !\u003d 0) {\n            logger.warning(\"Thread Access Count was not 0!: \" + threadAccessCount);\n            if (Assertion.isEnabled()) {\n                assertionSystemExit();\n            }\n            threadAccessCount \u003d 0;\n        }\n        while (readByteBuffer.isEmpty() \u003d\u003d false) {\n            try {\n                getServer().getByteBufferPool().returnObject(readByteBuffer.remove(0));\n            } catch (Exception er) {\n                logger.warning(\"Error in returning read ByteBuffer to pool: \" + er);\n                break;\n            }\n        }\n        while (writeByteBuffer.isEmpty() \u003d\u003d false) {\n            try {\n                getServer().getByteBufferPool().returnObject(writeByteBuffer.remove(0));\n            } catch (Exception er) {\n                appLogger.warning(\"Error in returning write ByteBuffer to pool: \" + er);\n                break;\n            }\n        }\n        if (peerNetData !\u003d null) {\n            try {\n                getServer().getByteBufferPool().returnObject(peerNetData);\n            } catch (Exception er) {\n                appLogger.warning(\"Error in returning peerNetData to pool: \" + er);\n            }\n        }\n        if (selectionKey !\u003d null) {\n            selectionKey.cancel();\n            selectionKey.selector().wakeup();\n            selectionKey \u003d null;\n        }\n        willReturn \u003d false;\n        waitingForFinalWrite \u003d false;\n        socketChannel \u003d null;\n        if (byteBufferOutputStream !\u003d null) {\n            byteBufferOutputStream.close();\n        }\n        super.clean();\n        //1.4.5\n        clientWriteHandler \u003d null;\n        byteBufferOutputStream \u003d null;\n        sslShutdown \u003d false;\n        logger.finest(\"Finished clean - \" + getName());\n    }\n\n    protected void finalize() throws Throwable {\n        clean();\n        super.finalize();\n    }\n\n    public void handleClient(TheClient theClient) throws Exception {\n        super.handleClient(theClient);\n        //v1.4.5\n        setClientWriteHandler(theClient.getClientWriteHandler());\n        //1.4.5\n        setSocketChannel(theClient.getSocketChannel());\n    }\n\n    protected void setInputStream(InputStream in) throws IOException {\n        this.in \u003d in;\n        if (getDataMode(DataType.IN) \u003d\u003d DataMode.STRING) {\n            b_in \u003d null;\n            o_in \u003d null;\n            bufferedReader \u003d null;\n        } else if (getDataMode(DataType.IN) \u003d\u003d DataMode.OBJECT) {\n            b_in \u003d null;\n            bufferedReader \u003d null;\n            o_in \u003d new ObjectInputStream(in);\n        } else if (getDataMode(DataType.IN) \u003d\u003d DataMode.BYTE || getDataMode(DataType.IN) \u003d\u003d DataMode.BINARY) {\n            o_in \u003d null;\n            bufferedReader \u003d null;\n            b_in \u003d null;\n        }\n    }\n\n    public BufferedReader getBufferedReader() {\n        throw new IllegalStateException(\"Access to BufferedReader in not allowed in Non-Blocking mode!\");\n    }\n\n    public void closeConnection() {\n        logger.finest(\"inside\");\n        synchronized (this) {\n            if (connection \u003d\u003d false)\n                return;\n            if (waitingForFinalWrite)\n                return;\n            if (getSelectionKey() !\u003d null \u0026\u0026 getSelectionKey().isValid() \u0026\u0026 lost \u003d\u003d false) {\n                waitingForFinalWrite \u003d true;\n            } else {\n                connection \u003d false;\n            }\n        }\n        try {\n            if (getSocketChannel() !\u003d null \u0026\u0026 socket !\u003d null) {\n                if (waitingForFinalWrite) {\n                    try {\n                        waitTillFullyWritten();\n                    } catch (Exception error) {\n                        logger.warning(\"Error in waitingForFinalWrite : \" + error);\n                        if (logger.isLoggable(Level.FINE)) {\n                            logger.fine(\"StackTrace:\\n\" + MyString.getStackTrace(error));\n                        }\n                    }\n                }\n                //end of waitingForFinalWrite\n                if (isSecure() \u003d\u003d true) {\n                    sslShutdown \u003d true;\n                    if (lost \u003d\u003d false \u0026\u0026 sslEngine.isOutboundDone() \u003d\u003d false) {\n                        logger.finest(\"SSL isOutboundDone is false\");\n                        if (byteBufferOutputStream.doShutdown() \u003d\u003d false) {\n                            return;\n                        }\n                    } else if (sslEngine.isOutboundDone()) {\n                        logger.finest(\"SSL Outbound is done.\");\n                    }\n                }\n                doPostCloseActivity();\n            }\n            //if socket\n        } catch (IOException e) {\n            logger.warning(\"Error in closeConnection : \" + e);\n            if (logger.isLoggable(Level.FINE)) {\n                logger.fine(\"StackTrace:\\n\" + MyString.getStackTrace(e));\n            }\n        } catch (NullPointerException npe) {\n            logger.fine(\"NullPointerException: \" + npe);\n            if (logger.isLoggable(Level.FINE)) {\n                logger.fine(\"StackTrace:\\n\" + MyString.getStackTrace(npe));\n            }\n        }\n    }\n\n    private void doPostCloseActivity() throws IOException {\n        connection \u003d false;\n        byteBufferOutputStream.forceNotify();\n        getSelectionKey().cancel();\n        if (getServer() !\u003d null) {\n            getServer().getSelector().wakeup();\n        }\n        synchronized (this) {\n            if (hasEvent(ClientEvent.MAX_CON) \u003d\u003d false) {\n                notifyCloseOrLost();\n            }\n            if (getSocketChannel().isOpen()) {\n                logger.finest(\"Closing SocketChannel\");\n                getSocketChannel().close();\n            }\n        }\n    }\n\n    public boolean closeIfSSLOutboundDone() {\n        if (isSecure() \u003d\u003d false)\n            throw new IllegalStateException(\"Client is not in secure mode!\");\n        if (sslEngine.isOutboundDone()) {\n            logger.finest(\"SSL Outbound is done.\");\n            try {\n                if (getSocketChannel().isOpen()) {\n                    logger.finest(\"Closing SocketChannel\");\n                    getSocketChannel().close();\n                }\n            } catch (IOException e) {\n                logger.fine(\"IGNORE: Error in Closing SocketChannel: \" + e);\n            }\n            return true;\n        } else {\n            logger.finest(\"SSL Outbound is not done.\");\n            return false;\n        }\n    }\n\n    /**\n     * waitTillFullyWritten\n     * @since 1.4.7\n     */\n    public void waitTillFullyWritten() {\n        Object waitLock \u003d new Object();\n        if (byteBufferOutputStream.isDataAvailableForWrite(waitLock)) {\n            if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {\n                logger.finest(\"Waiting \" + getName());\n            }\n            try {\n                synchronized (waitLock) {\n                    //2 min max\n                    waitLock.wait(1000 * 60 * 2);\n                }\n            } catch (InterruptedException ie) {\n                logger.warning(\"Error: \" + ie);\n            }\n            if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {\n                logger.finest(\"Done. \" + getName());\n            }\n        }\n    }\n\n    public void run() {\n        if (unprocessedClientEvents.isEmpty()) {\n            logger.finest(\"No unprocessed ClientEvents!\");\n            return;\n        }\n        synchronized (this) {\n            if (willReturn) {\n                return;\n            } else {\n                threadAccessCount++;\n            }\n        }\n        ClientEvent currentEvent \u003d (ClientEvent) unprocessedClientEvents.poll();\n        if (currentEvent \u003d\u003d null) {\n            threadEvent.set(null);\n            logger.finest(\"No unprocessed ClientEvents! pool was null\");\n            return;\n        }\n        if (logger.isLoggable(Level.FINEST)) {\n            StringBuilder sb \u003d new StringBuilder();\n            sb.append(\"Running \").append(getName());\n            sb.append(\" using \");\n            sb.append(Thread.currentThread().getName());\n            sb.append(\" for \");\n            synchronized (clientEvents) {\n                if (clientEvents.size() \u003e 1) {\n                    sb.append(currentEvent + \", Current Events - \" + clientEvents);\n                } else {\n                    sb.append(currentEvent);\n                }\n            }\n            logger.finest(sb.toString());\n        }\n        logger.finest(\"threadAccessCount: \" + threadAccessCount);\n        threadEvent.set(currentEvent);\n        try {\n            if (maxThreadAccessCount !\u003d -1 \u0026\u0026 threadAccessCount \u003e maxThreadAccessCount) {\n                logger.warning(\"ThreadAccessCount can\u0027t go beyond \" + maxThreadAccessCount + \": \" + threadAccessCount);\n                if (Assertion.isEnabled()) {\n                    throw new AssertionError(\"ThreadAccessCount can\u0027t go beyond \" + maxThreadAccessCount + \": \" + threadAccessCount);\n                }\n                return;\n            }\n            if (socket \u003d\u003d null)\n                throw new SocketException(\"Socket was null!\");\n            if (getThreadEvent() \u003d\u003d ClientEvent.ACCEPT || getThreadEvent() \u003d\u003d ClientEvent.MAX_CON) {\n                prepareForRun();\n                Assertion.affirm(willReturn \u003d\u003d false, \"WillReturn has to be false!: \" + willReturn);\n            }\n            if (getThreadEvent() \u003d\u003d ClientEvent.MAX_CON) {\n                processMaxConnection(currentEvent);\n            }\n            try {\n                if (getThreadEvent() \u003d\u003d ClientEvent.ACCEPT) {\n                    registerForRead();\n                    clientEventHandler.gotConnected(this);\n                    if (authorised \u003d\u003d false) {\n                        if (clientAuthenticationHandler \u003d\u003d null \u0026\u0026 authenticator \u003d\u003d null) {\n                            authorised \u003d true;\n                            logger.finest(\"No Authenticator \" + getName() + \" so return thread.\");\n                        } else {\n                            if (clientAuthenticationHandler !\u003d null) {\n                                AuthStatus authStatus \u003d null;\n                                do {\n                                    authStatus \u003d processAuthorisation();\n                                } while (authStatus \u003d\u003d AuthStatus.FAILURE);\n                                if (authStatus \u003d\u003d AuthStatus.SUCCESS)\n                                    authorised \u003d true;\n                            } else {\n                                processAuthorisation();\n                            }\n                            if (authorised)\n                                logger.finest(\"Authentication done \" + getName() + \", so return thread.\");\n                            else\n                                logger.finest(\"askAuthentication() done \" + getName() + \", so return thread.\");\n                        }\n                    }\n                    //end authorised\n                    //return thread to pool\n                    returnThread();\n                    return;\n                }\n                if (connection \u0026\u0026 getThreadEvent() \u003d\u003d ClientEvent.READ) {\n                    if (processRead())\n                        return;\n                }\n                if (connection \u0026\u0026 getThreadEvent() \u003d\u003d ClientEvent.WRITE) {\n                    if (processWrite())\n                        return;\n                }\n            } catch (SocketException e) {\n                appLogger.finest(\"SocketException - Client [\" + getHostAddress() + \"]: \" + e.getMessage());\n                //e.printStackTrace();\n                lost \u003d true;\n            } catch (AppException e) {\n                //errors from Application\n                appLogger.finest(\"AppException \" + Thread.currentThread().getName() + \": \" + e.getMessage());\n            } catch (javax.net.ssl.SSLException e) {\n                lost \u003d true;\n                if (Assertion.isEnabled()) {\n                    appLogger.info(\"SSLException - Client [\" + getHostAddress() + \"] \" + Thread.currentThread().getName() + \": \" + e);\n                } else {\n                    appLogger.warning(\"SSLException - Client [\" + getHostAddress() + \"]: \" + e);\n                }\n            } catch (ConnectionLostException e) {\n                lost \u003d true;\n                if (e.getMessage() !\u003d null)\n                    appLogger.finest(\"Connection lost \" + Thread.currentThread().getName() + \": \" + e.getMessage());\n                else\n                    appLogger.finest(\"Connection lost \" + Thread.currentThread().getName());\n            } catch (ClosedChannelException e) {\n                lost \u003d true;\n                appLogger.finest(\"Channel closed \" + Thread.currentThread().getName() + \": \" + e);\n            } catch (IOException e) {\n                lost \u003d true;\n                appLogger.fine(\"IOError \" + Thread.currentThread().getName() + \": \" + e);\n            } catch (AssertionError er) {\n                logger.warning(\"[AssertionError] \" + getName() + \" \" + er);\n                if (logger.isLoggable(Level.FINEST)) {\n                    logger.finest(\"StackTrace \" + Thread.currentThread().getName() + \": \" + MyString.getStackTrace(er));\n                }\n                assertionSystemExit();\n            } catch (Error er) {\n                logger.warning(\"[Error] \" + er);\n                if (logger.isLoggable(Level.FINEST)) {\n                    logger.finest(\"StackTrace \" + Thread.currentThread().getName() + \": \" + MyString.getStackTrace(er));\n                }\n                if (Assertion.isEnabled()) {\n                    assertionSystemExit();\n                }\n                lost \u003d true;\n            } catch (RuntimeException re) {\n                logger.warning(\"[RuntimeException] \" + MyString.getStackTrace(re));\n                if (Assertion.isEnabled()) {\n                    assertionSystemExit();\n                }\n                lost \u003d true;\n            }\n            if (getThreadEvent() !\u003d ClientEvent.MAX_CON) {\n                notifyCloseOrLost();\n            }\n            if (connection) {\n                logger.finest(Thread.currentThread().getName() + \" calling closeConnection()\");\n                closeConnection();\n            }\n            if (connection \u003d\u003d true \u0026\u0026 lost \u003d\u003d true \u0026\u0026 waitingForFinalWrite) {\n                byteBufferOutputStream.forceNotify();\n            }\n        } catch (javax.net.ssl.SSLException se) {\n            logger.warning(\"SSLException \" + Thread.currentThread().getName() + \" - \" + se);\n        } catch (IOException ie) {\n            logger.warning(\"IOError \" + Thread.currentThread().getName() + \" - Closing Client : \" + ie);\n        } catch (RuntimeException re) {\n            logger.warning(\"[RuntimeException] \" + getName() + \" \" + Thread.currentThread().getName() + \" - \" + MyString.getStackTrace(re));\n            if (Assertion.isEnabled()) {\n                assertionSystemExit();\n            }\n        } catch (Exception e) {\n            logger.warning(\"Error \" + Thread.currentThread().getName() + \" - Event:\" + getThreadEvent() + \" - Socket:\" + socket + \" : \" + e);\n            logger.fine(\"StackTrace: \" + getName() + \"\\n\" + MyString.getStackTrace(e));\n            if (Assertion.isEnabled()) {\n                assertionSystemExit();\n            }\n        } catch (Error e) {\n            logger.warning(\"Error \" + Thread.currentThread().getName() + \" - Event:\" + getThreadEvent() + \" - Socket:\" + socket + \" : \" + e);\n            logger.fine(\"StackTrace: \" + getName() + \"\\n\" + MyString.getStackTrace(e));\n            if (Assertion.isEnabled()) {\n                assertionSystemExit();\n            }\n        }\n        synchronized (this) {\n            try {\n                if (getSelectionKey() !\u003d null \u0026\u0026 getSelectionKey().isValid()) {\n                    logger.finest(\"Canceling SelectionKey\");\n                    getSelectionKey().cancel();\n                }\n                if (socket !\u003d null \u0026\u0026 socket.isClosed() \u003d\u003d false) {\n                    logger.finest(\"Closing Socket\");\n                    socket.close();\n                }\n                if (getSocketChannel() !\u003d null \u0026\u0026 getSocketChannel().isOpen()) {\n                    logger.finest(\"Closing SocketChannel\");\n                    socketChannel.close();\n                }\n            } catch (Exception re) {\n                logger.warning(\"Error closing Socket/Channel: \" + re);\n            }\n        }\n        //end synchronized\n        willClean \u003d true;\n        returnClientData();\n        boolean returnClientHandler \u003d false;\n        synchronized (lockObj) {\n            returnThread();\n            returnClientHandler \u003d checkReturnClientHandler();\n        }\n        if (returnClientHandler) {\n            //return to pool\n            returnClientHandler();\n        }\n    }\n\n    protected boolean checkReturnClientHandler() {\n        if (willReturn \u003d\u003d false) {\n            willReturn \u003d true;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Process read\n     * @return value indicates if the thread should return form run()\n     */\n    private boolean processRead() throws Exception {\n        if (doRead()) {\n            //return to pool\n            returnThread();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    private boolean doRead() throws Exception {\n        int count \u003d 0;\n        int fullCount \u003d 0;\n        while (true) {\n            try {\n                if (peerNetData \u003d\u003d null) {\n                    peerNetData \u003d (ByteBuffer) getServer().getByteBufferPool().borrowObject();\n                }\n                count \u003d getSocketChannel().read(peerNetData);\n                if (count \u003c 0) {\n                    //logger.finest(\"SocketChannel read was \"+count+\"!\");\n                    getServer().getByteBufferPool().returnObject(peerNetData);\n                    peerNetData \u003d null;\n                    break;\n                } else {\n                    fullCount +\u003d count;\n                }\n                // Make readable\n                peerNetData.flip();\n                ByteBuffer peerAppData \u003d null;\n                //--\n                if (sslEngine !\u003d null) {\n                    SSLEngineResult res;\n                    peerAppData \u003d (ByteBuffer) getServer().getByteBufferPool().borrowObject();\n                    do {\n                        res \u003d sslEngine.unwrap(peerNetData, peerAppData);\n                        logger.info(\"Unwrapping:\\n\" + res);\n                    } while (res.getStatus() \u003d\u003d SSLEngineResult.Status.OK \u0026\u0026 res.getHandshakeStatus() \u003d\u003d SSLEngineResult.HandshakeStatus.NEED_UNWRAP \u0026\u0026 res.bytesProduced() \u003d\u003d 0);\n                    if (res.getHandshakeStatus() \u003d\u003d SSLEngineResult.HandshakeStatus.FINISHED) {\n                        logger.info(\"HandshakeStatus.FINISHED!\");\n                        finishInitialHandshake();\n                    }\n                    if (peerAppData.position() \u003d\u003d 0 \u0026\u0026 res.getStatus() \u003d\u003d SSLEngineResult.Status.OK \u0026\u0026 peerNetData.hasRemaining()) {\n                        logger.info(\"peerNetData hasRemaining and pos\u003d0!\");\n                        res \u003d sslEngine.unwrap(peerNetData, peerAppData);\n                        logger.info(\"Unwrapping:\\n\" + res);\n                    }\n                    /*\n\t\t\t\t\t * OK, OVERFLOW, UNDERFLOW, CLOSED\n\t\t\t\t\t */\n                    status \u003d res.getStatus();\n                    handshakeStatus \u003d res.getHandshakeStatus();\n                    if (status !\u003d SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                        logger.warning(\"Buffer overflow: \" + res.toString());\n                    } else if (status \u003d\u003d SSLEngineResult.Status.CLOSED) {\n                        logger.fine(\"Connection is being closed by peer.\");\n                        lost \u003d true;\n                        System.out.println(\"NEdd to code for shutdow of SSL\");\n                        break;\n                    }\n                    peerNetData.compact();\n                    peerAppData.flip();\n                    if (handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.NEED_TASK || handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.NEED_WRAP || handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.FINISHED) {\n                        doHandshake();\n                    }\n                    //return peerAppData.remaining();\n                    logger.fine(\"peerAppData.remaining(): \" + peerAppData.remaining());\n                } else {\n                    peerAppData \u003d peerNetData;\n                    peerNetData \u003d null;\n                }\n                //--\n                readByteBuffer.add(peerAppData);\n                peerAppData \u003d null;\n            } catch (Exception error) {\n                logger.finest(\"Error in data read: \" + error);\n                if (sslEngine !\u003d null)\n                    sslEngine.closeInbound();\n                lost \u003d true;\n                synchronized (getInputStream()) {\n                    getInputStream().notifyAll();\n                }\n                throw error;\n            }\n            if (count \u003d\u003d 0)\n                break;\n        }\n        //end while\n        if (count \u003c 0) {\n            logger.finest(\"SocketChannel read was \" + count + \"!\");\n            if (sslEngine !\u003d null)\n                sslEngine.closeInbound();\n            lost \u003d true;\n            synchronized (getInputStream()) {\n                getInputStream().notifyAll();\n            }\n        } else {\n            logger.finest(fullCount + \" bytes read\");\n            if (fullCount !\u003d 0) {\n                updateLastCommunicationTime();\n                synchronized (getInputStream()) {\n                    //if any are waiting\n                    getInputStream().notify();\n                }\n                if (hasEvent(ClientEvent.ACCEPT) \u003d\u003d false) {\n                    processGotDataInBuffers();\n                }\n            }\n            //check if any data was read but not yet processed\n            while (getInputStream().available() \u003e 0) {\n                logger.finest(\"Sending again for processing...\");\n                if (hasEvent(ClientEvent.ACCEPT) \u003d\u003d false) {\n                    processGotDataInBuffers();\n                    break;\n                } else {\n                    synchronized (getInputStream()) {\n                        getInputStream().notifyAll();\n                    }\n                    Thread.sleep(100);\n                }\n            }\n            if (connection) {\n                registerForRead();\n                //getSelectionKey().selector().wakeup();\n                return true;\n            }\n        }\n        //end of else\n        logger.finest(\"We don\u0027t have connection, lets return all resources.\");\n        return false;\n    }\n\n    /**\n     * Process write\n     * @return value indicates if the thread should return form run()\n     */\n    private boolean processWrite() throws IOException {\n        if (doWrite()) {\n            //return to pool\n            returnThread();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    private boolean doWrite() throws IOException {\n        if (sslShutdown) {\n            if (byteBufferOutputStream.doShutdown() \u003d\u003d false) {\n                return true;\n            }\n            doPostCloseActivity();\n            logger.finest(\"We don\u0027t have connection, lets return all resources.\");\n            return false;\n        }\n        updateLastCommunicationTime();\n        boolean flag \u003d byteBufferOutputStream.writeAllByteBuffer();\n        if (flag \u003d\u003d false) {\n            registerWrite();\n        } else if (/*flag\u003d\u003dtrue \u0026\u0026 */\n        clientWriteHandler !\u003d null) {\n            clientWriteHandler.handleWrite(this);\n        }\n        if (connection) {\n            return true;\n        } else {\n            logger.finest(\"We don\u0027t have connection, lets return all resources.\");\n            return false;\n        }\n    }\n\n    protected void returnThread() {\n        //System.out.println(\"returnThread..\");\n        //(new Exception()).printStackTrace();\n        threadAccessCount--;\n        Assertion.affirm(threadAccessCount \u003e\u003d 0, \"ThreadAccessCount went less the 0! Value: \" + threadAccessCount);\n        //return is done at ClientThread end\n        removeEvent((ClientEvent) threadEvent.get());\n    }\n\n    protected void returnClientHandler() {\n        logger.finest(getName());\n        try {\n            for (int i \u003d 0; threadAccessCount !\u003d 0; i++) {\n                if (i \u003d\u003d 100) {\n                    logger.warning(\"ClientHandler must have got into a loop waiting for thread to free up! ThreadAccessCount\u003d\" + threadAccessCount);\n                    threadAccessCount \u003d 0;\n                    if (Assertion.isEnabled()) {\n                        assertionSystemExit();\n                    } else {\n                        break;\n                    }\n                }\n                if (threadAccessCount \u003c\u003d 0)\n                    break;\n                logger.finest(\"Waiting for other thread of \" + getName() + \" to finish\");\n                Thread.sleep(60);\n            }\n        } catch (InterruptedException ie) {\n            appLogger.warning(\"InterruptedException: \" + ie);\n        }\n        super.returnClientHandler();\n    }\n\n    public void setDataMode(DataMode dataMode, DataType dataType) throws IOException {\n        if (getDataMode(dataType) \u003d\u003d dataMode)\n            return;\n        appLogger.fine(\"Setting Type:\" + dataType + \", Mode:\" + dataMode);\n        super.checkDataModeSet(dataMode, dataType);\n        setDataModeNonBlocking(dataMode, dataType);\n    }\n\n    private void setDataModeNonBlocking(DataMode dataMode, DataType dataType) throws IOException {\n        logger.finest(\"ENTER\");\n        if (dataMode \u003d\u003d DataMode.STRING) {\n            if (dataType \u003d\u003d DataType.OUT) {\n                if (dataModeOUT \u003d\u003d DataMode.BYTE || dataModeOUT \u003d\u003d DataMode.BINARY) {\n                    dataModeOUT \u003d dataMode;\n                } else if (dataModeOUT \u003d\u003d DataMode.OBJECT) {\n                    dataModeOUT \u003d dataMode;\n                    o_out.flush();\n                    o_out \u003d null;\n                    b_out \u003d new BufferedOutputStream(out);\n                } else {\n                    Assertion.affirm(false, \"Unknown DataType.OUT DataMode - \" + dataModeOUT);\n                }\n                Assertion.affirm(b_out !\u003d null, \"BufferedOutputStream is still null!\");\n                Assertion.affirm(o_out \u003d\u003d null, \"ObjectOutputStream is still not null!\");\n            } else if (dataType \u003d\u003d DataType.IN) {\n                dataModeIN \u003d dataMode;\n                if (o_in !\u003d null) {\n                    if (o_in.available() !\u003d 0)\n                        logger.warning(\"Data looks to be present in ObjectInputStream\");\n                    o_in \u003d null;\n                }\n                b_in \u003d null;\n                bufferedReader \u003d null;\n                //input stream will work\n                Assertion.affirm(in !\u003d null, \"InputStream is still null!\");\n                Assertion.affirm(b_in \u003d\u003d null, \"BufferedInputStream is still not null!\");\n                Assertion.affirm(bufferedReader \u003d\u003d null, \"BufferedReader is still not null!\");\n            }\n        } else if (dataMode \u003d\u003d DataMode.OBJECT) {\n            if (dataType \u003d\u003d DataType.IN) {\n                //we will disable this for now\n                throw new IllegalArgumentException(\"Can\u0027t set DataType.IN mode to OBJECT when blocking mode is set as false!\");\n            }\n            if (dataType \u003d\u003d DataType.OUT) {\n                dataModeOUT \u003d dataMode;\n                b_out \u003d null;\n                o_out \u003d new ObjectOutputStream(out);\n                Assertion.affirm(o_out !\u003d null, \"ObjectOutputStream is still null!\");\n                o_out.flush();\n            } else if (dataType \u003d\u003d DataType.IN) {\n                dataModeIN \u003d dataMode;\n                b_in \u003d null;\n                bufferedReader \u003d null;\n                registerForRead();\n                //will block\n                o_in \u003d new ObjectInputStream(in);\n                Assertion.affirm(o_in !\u003d null, \"ObjectInputStream is still null!\");\n            }\n        } else if (dataMode \u003d\u003d DataMode.BYTE || dataMode \u003d\u003d DataMode.BINARY) {\n            if (dataType \u003d\u003d DataType.OUT) {\n                if (dataModeOUT \u003d\u003d DataMode.STRING || dataModeOUT \u003d\u003d DataMode.BYTE || dataModeOUT \u003d\u003d DataMode.BINARY) {\n                    dataModeOUT \u003d dataMode;\n                } else if (dataModeOUT \u003d\u003d DataMode.OBJECT) {\n                    dataModeOUT \u003d dataMode;\n                    o_out \u003d null;\n                    b_out \u003d new BufferedOutputStream(out);\n                } else {\n                    Assertion.affirm(false, \"Unknown DataType.OUT - DataMode: \" + dataModeOUT);\n                }\n                Assertion.affirm(b_out !\u003d null, \"BufferedOutputStream is still null!\");\n            } else if (dataType \u003d\u003d DataType.IN) {\n                dataModeIN \u003d dataMode;\n                o_in \u003d null;\n                bufferedReader \u003d null;\n                b_in \u003d null;\n                //input stream will work\n                Assertion.affirm(in !\u003d null, \"InputStream is still null!\");\n            } else {\n                throw new IllegalArgumentException(\"Unknown DataType : \" + dataType);\n            }\n        } else {\n            throw new IllegalArgumentException(\"Unknown DataMode : \" + dataMode);\n        }\n    }\n\n    protected byte[] readInputStream() throws IOException {\n        return readInputStream(getInputStream());\n    }\n\n    public void updateInputOutputStreams() throws IOException {\n        byteBufferOutputStream \u003d new ByteBufferOutputStream(writeByteBuffer, this);\n        setInputStream(new ByteBufferInputStream(readByteBuffer, this, getCharset()));\n        setOutputStream(byteBufferOutputStream);\n        //logger.warning(\"updateInputOutputStreams: \"+sslEngine);\n        if (sslEngine !\u003d null) {\n            sslEngine.setUseClientMode(false);\n            sslEngine.beginHandshake();\n            handshakeStatus \u003d sslEngine.getHandshakeStatus();\n            initialHandshakeStatus \u003d true;\n            /*\n\t\t\ttry {\n\t\t\t\tdoHandshake();\n\t\t\t} catch(Exception e) {\n\t\t\t\tlogger.warning(\"Error: \"+e);\n\t\t\t\tthrow new IOException(e.toString());\n\t\t\t}\n\t\t\t*/\n        }\n    }\n\n    public boolean getBlockingMode() {\n        return false;\n    }\n\n    public void setSocketChannel(SocketChannel socketChannel) {\n        this.socketChannel \u003d socketChannel;\n    }\n\n    public SocketChannel getSocketChannel() {\n        return socketChannel;\n    }\n\n    public void setSelectionKey(SelectionKey selectionKey) {\n        this.selectionKey \u003d selectionKey;\n    }\n\n    public SelectionKey getSelectionKey() {\n        if (selectionKey \u003d\u003d null)\n            selectionKey \u003d getSocketChannel().keyFor(getServer().getSelector());\n        return selectionKey;\n    }\n\n    private void processGotDataInBuffers() throws AppException, ConnectionLostException, ClassNotFoundException, IOException {\n        if (getInputStream().available() \u003d\u003d 0)\n            return;\n        logger.finest(\"Trying to process got data.. DataMode.IN\u003d\" + dataModeIN);\n        AuthStatus authStatus \u003d null;\n        //--For debug\n        ((ByteBufferInputStream) getInputStream()).dumpContent();\n        String temp \u003d null;\n        String rec \u003d null;\n        Object recObject \u003d null;\n        byte[] recByte \u003d null;\n        boolean timeToCheckForNewLineMiss \u003d false;\n        do {\n            //updateLastCommunicationTime();\n            if (dataModeIN \u003d\u003d DataMode.STRING) {\n                ByteBufferInputStream bbin \u003d (ByteBufferInputStream) getInputStream();\n                timeToCheckForNewLineMiss \u003d true;\n                while (bbin.isLineReady()) {\n                    rec \u003d bbin.readLine();\n                    if (rec \u003d\u003d null) {\n                        lost \u003d true;\n                        return;\n                    }\n                    if (getCommunicationLogging() \u0026\u0026 authorised \u003d\u003d true) {\n                        appLogger.log(Level.FINE, \"Got STRING [{0}] : {1}\", new Object[] { getHostAddress(), rec });\n                    }\n                    totalReadBytes \u003d totalReadBytes + rec.length();\n                    if (authorised \u003d\u003d false)\n                        authStatus \u003d clientAuthenticationHandler.handleAuthentication(this, rec);\n                    else\n                        clientCommandHandler.handleCommand(this, rec);\n                    if (isClosed() \u003d\u003d true)\n                        return;\n                    while (authStatus \u003d\u003d AuthStatus.FAILURE) authStatus \u003d processAuthorisation();\n                    if (authStatus \u003d\u003d AuthStatus.SUCCESS)\n                        authorised \u003d true;\n                    if (dataModeIN !\u003d DataMode.STRING) {\n                        break;\n                    }\n                    timeToCheckForNewLineMiss \u003d false;\n                }\n                //end of while\n                if (timeToCheckForNewLineMiss \u0026\u0026 bbin.availableOnlyInByteBuffer() \u003d\u003d 0) {\n                    return;\n                } else {\n                    timeToCheckForNewLineMiss \u003d false;\n                }\n            }\n            //if(dataModeIN \u003d\u003d DataMode.OBJECT) {\n            while (dataModeIN \u003d\u003d DataMode.OBJECT \u0026\u0026 o_in !\u003d null) {\n                //not sure if all bytes are in buffer..~ may need more read.. will get stuck..\n                recObject \u003d o_in.readObject();\n                if (recObject \u003d\u003d null) {\n                    lost \u003d true;\n                    return;\n                }\n                if (getCommunicationLogging() \u0026\u0026 authorised \u003d\u003d true) {\n                    appLogger.log(Level.FINE, \"Got OBJECT [{0}] : {1}\", new Object[] { getHostAddress(), recObject.toString() });\n                }\n                totalReadBytes \u003d totalReadBytes + 1;\n                if (authorised \u003d\u003d false)\n                    authStatus \u003d clientAuthenticationHandler.handleAuthentication(this, recObject);\n                else\n                    clientObjectHandler.handleObject(this, recObject);\n                if (isClosed() \u003d\u003d true)\n                    return;\n                while (authStatus \u003d\u003d AuthStatus.FAILURE) authStatus \u003d processAuthorisation();\n                if (authStatus \u003d\u003d AuthStatus.SUCCESS)\n                    authorised \u003d true;\n            }\n            //}\n            //if(dataModeIN \u003d\u003d DataMode.BYTE) {\n            while (dataModeIN \u003d\u003d DataMode.BYTE \u0026\u0026 getInputStream().available() !\u003d 0) {\n                rec \u003d readBytes();\n                if (rec \u003d\u003d null) {\n                    lost \u003d true;\n                    return;\n                }\n                if (getCommunicationLogging() \u0026\u0026 authorised \u003d\u003d true) {\n                    appLogger.log(Level.FINE, \"Got BYTE [{0}] : {1}\", new Object[] { getHostAddress(), rec });\n                }\n                totalReadBytes \u003d totalReadBytes + rec.length();\n                if (authorised \u003d\u003d false)\n                    authStatus \u003d clientAuthenticationHandler.handleAuthentication(this, rec);\n                else\n                    clientCommandHandler.handleCommand(this, rec);\n                if (isClosed() \u003d\u003d true)\n                    return;\n                while (authStatus \u003d\u003d AuthStatus.FAILURE) authStatus \u003d processAuthorisation();\n                if (authStatus \u003d\u003d AuthStatus.SUCCESS)\n                    authorised \u003d true;\n            }\n            //} else if(dataModeIN \u003d\u003d DataMode.BINARY) {\n            while (dataModeIN \u003d\u003d DataMode.BINARY \u0026\u0026 getInputStream().available() !\u003d 0) {\n                recByte \u003d readBinary();\n                if (recByte \u003d\u003d null) {\n                    lost \u003d true;\n                    return;\n                }\n                if (getCommunicationLogging() \u0026\u0026 authorised \u003d\u003d true) {\n                    if (getServer().isRawCommunicationLogging()) {\n                        if (getServer().getRawCommunicationMaxLength() \u003e 0 \u0026\u0026 recByte.length \u003e getServer().getRawCommunicationMaxLength()) {\n                            appLogger.log(Level.FINE, \"Got BINARY [{0}] : {1}; RAW: {2}{3}\", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length), new String(recByte, 0, getServer().getRawCommunicationMaxLength(), charset), \"...\" });\n                        } else {\n                            appLogger.log(Level.FINE, \"Got BINARY [{0}] : {1}; RAW: {2}\", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length), new String(recByte, charset) });\n                        }\n                    } else {\n                        appLogger.log(Level.FINE, \"Got BINARY [{0}] : {1}\", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length) });\n                    }\n                } else if (getCommunicationLogging()) {\n                    appLogger.log(Level.FINE, \"Got BINARY [{0}] : {1}\", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length) });\n                }\n                totalReadBytes \u003d totalReadBytes + recByte.length;\n                if (authorised \u003d\u003d false)\n                    authStatus \u003d clientAuthenticationHandler.handleAuthentication(this, recByte);\n                else\n                    clientBinaryHandler.handleBinary(this, recByte);\n                if (isClosed() \u003d\u003d true)\n                    return;\n                while (authStatus \u003d\u003d AuthStatus.FAILURE) authStatus \u003d processAuthorisation();\n                if (authStatus \u003d\u003d AuthStatus.SUCCESS)\n                    authorised \u003d true;\n            }\n            //} else {\n            if (dataModeIN !\u003d DataMode.STRING \u0026\u0026 dataModeIN !\u003d DataMode.OBJECT \u0026\u0026 dataModeIN !\u003d DataMode.BYTE \u0026\u0026 dataModeIN !\u003d DataMode.BINARY) {\n                throw new IllegalStateException(\"Incoming DataMode is not supported : \" + dataModeIN);\n            }\n        } while (getInputStream().available() !\u003d 0);\n    }\n\n    public void registerForRead() throws IOException, ClosedChannelException {\n        //System.out.println(\"registerForRead..\");\n        //(new Exception()).printStackTrace();\n        try {\n            if (getSelectionKey() \u003d\u003d null) {\n                boolean flag \u003d getServer().registerChannel(getSocketChannel(), SelectionKey.OP_READ, this);\n                if (flag) {\n                    logger.finest(\"Adding OP_READ as interest Ops for \" + getName());\n                } else if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {\n                    logger.finest(\"OP_READ is already present in interest Ops for \" + getName());\n                }\n            } else if (getSelectionKey().isValid()) {\n                if ((getSelectionKey().interestOps() \u0026 SelectionKey.OP_READ) \u003d\u003d 0) {\n                    logger.finest(\"Adding OP_READ to interest Ops for \" + getName());\n                    removeEvent(ClientEvent.READ);\n                    getSelectionKey().interestOps(getSelectionKey().interestOps() | SelectionKey.OP_READ);\n                    if (wakeupSelectorAfterRegisterRead) {\n                        getServer().getSelector().wakeup();\n                    }\n                } else {\n                    if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {\n                        logger.finest(\"OP_READ is already present in interest Ops for \" + getName());\n                    }\n                }\n            } else {\n                throw new IOException(\"SelectionKey is invalid!\");\n            }\n        } catch (CancelledKeyException e) {\n            throw new IOException(\"SelectionKey is cancelled!\");\n        }\n    }\n\n    public void registerForWrite() throws IOException, ClosedChannelException {\n        if (hasEvent(ClientEvent.RUN_BLOCKING) || hasEvent(ClientEvent.MAX_CON_BLOCKING)) {\n            throw new IllegalStateException(\"This method is only allowed under Non-Blocking mode.\");\n        }\n        if (clientWriteHandler \u003d\u003d null) {\n            throw new IllegalStateException(\"ClientWriteHandler has not been set!\");\n        }\n        registerWrite();\n    }\n\n    public void registerWrite() throws IOException {\n        //System.out.println(\"registerWrite..\");\n        //(new Exception()).printStackTrace();\n        try {\n            if (getSelectionKey() \u003d\u003d null) {\n                boolean flag \u003d getServer().registerChannel(getSocketChannel(), SelectionKey.OP_WRITE, this);\n                if (flag) {\n                    logger.finest(\"Adding OP_WRITE as interest Ops for \" + getName());\n                } else if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {\n                    logger.finest(\"OP_WRITE is already present in interest Ops for \" + getName());\n                }\n            } else if (getSelectionKey().isValid()) {\n                if ((getSelectionKey().interestOps() \u0026 SelectionKey.OP_WRITE) \u003d\u003d 0) {\n                    logger.finest(\"Adding OP_WRITE to interest Ops for \" + getName());\n                    removeEvent(ClientEvent.WRITE);\n                    getSelectionKey().interestOps(getSelectionKey().interestOps() | SelectionKey.OP_WRITE);\n                    if (wakeupSelectorAfterRegisterWrite) {\n                        getServer().getSelector().wakeup();\n                    }\n                } else {\n                    if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {\n                        logger.finest(\"OP_WRITE is already present in interest Ops for \" + getName());\n                    }\n                }\n            } else {\n                throw new IOException(\"SelectionKey is invalid!\");\n            }\n        } catch (CancelledKeyException e) {\n            throw new IOException(\"SelectionKey is cancelled!\");\n        }\n    }\n\n    protected void setClientWriteHandler(ClientWriteHandler handler) {\n        clientWriteHandler \u003d handler;\n    }\n\n    /**\n     * Returns number of thread currently in this object.\n     * @since 1.4.6\n     */\n    public int getThreadAccessCount() {\n        return threadAccessCount;\n    }\n\n    private void doHandshake() throws Exception {\n        while (true) {\n            SSLEngineResult res;\n            logger.fine(\"handshakeStatus: \" + handshakeStatus);\n            if (handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.FINISHED) {\n                if (initialHandshakeStatus) {\n                    finishInitialHandshake();\n                }\n                return;\n            } else if (handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.NEED_TASK) {\n                doTasks();\n                continue;\n            } else if (handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n                /*\n\t\t\t\t\tdoRead();\n\n\t\t\t\t\tif(initialHandshakeStatus \u0026\u0026 \n\t\t\t\t\t\t\tstatus \u003d\u003d SSLEngineResult.Status.BUFFER_UNDERFLOW) {\n\t\t\t\t\t\tregisterForRead();\n\t\t\t\t\t}\n\t\t\t\t\t*/\n                return;\n            } else if (handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                ByteBuffer netData \u003d (ByteBuffer) getServer().getByteBufferPool().borrowObject();\n                //netData.clear();\n                res \u003d sslEngine.wrap(dummyByteBuffer, netData);\n                logger.info(\"Wrapping:\\n\" + res);\n                assert res.bytesProduced() !\u003d 0 : \"No net data produced during handshake wrap.\";\n                assert res.bytesConsumed() \u003d\u003d 0 : \"App data consumed during handshake wrap.\";\n                handshakeStatus \u003d res.getHandshakeStatus();\n                //netData.flip(); -- no need to flip will be done when writing to sc\n                byteBufferOutputStream.addEncryptedByteBuffer(netData);\n                if (!doWrite()) {\n                    return;\n                }\n                //back to loop\n                continue;\n            } else if (handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n                assert false : \"doHandshake() should never reach the NOT_HANDSHAKING state\";\n                return;\n            }\n            //if\n        }\n        //loop\n    }\n\n    private void doTasks() {\n        Runnable task;\n        while ((task \u003d sslEngine.getDelegatedTask()) !\u003d null) {\n            logger.fine(\"Running the task.. START \");\n            task.run();\n            logger.fine(\"Running the task.. END\");\n        }\n        handshakeStatus \u003d sslEngine.getHandshakeStatus();\n        logger.fine(\"handshakeStatus: \" + handshakeStatus);\n    }\n\n    private void finishInitialHandshake() throws IOException {\n        initialHandshakeStatus \u003d false;\n    }\n\n    public boolean getInitialHandshakeStatus() {\n        return initialHandshakeStatus;\n    }\n\n    public ByteBuffer encrypt(ByteBuffer src) throws IOException {\n        if (initialHandshakeStatus) {\n            logger.fine(\"Writing not possible during handshake!\");\n            //Exception e \u003d new Exception();\n            //e.printStackTrace();\n            return null;\n        }\n        ByteBuffer dest \u003d null;\n        boolean isException \u003d false;\n        try {\n            src.flip();\n            dest \u003d (ByteBuffer) getServer().getByteBufferPool().borrowObject();\n            //dest.clear();\n            SSLEngineResult res \u003d sslEngine.wrap(src, dest);\n            logger.info(\"Wrapping:\\n\" + res);\n            //dest.flip();\n            return dest;\n        } catch (IOException e) {\n            logger.warning(\"IOException:\" + e);\n            isException \u003d true;\n            throw e;\n        } catch (Exception e) {\n            logger.warning(\"Exception:\" + e);\n            isException \u003d true;\n            throw new IOException(e.getMessage());\n        } finally {\n            if (isException \u003d\u003d true \u0026\u0026 dest !\u003d null) {\n                try {\n                    getServer().getByteBufferPool().returnObject(dest);\n                } catch (Exception er) {\n                    logger.warning(\"Error in returning ByteBuffer to pool: \" + er);\n                }\n            }\n        }\n    }\n}\n",
    "package": "org.quickserver.net.server.impl",
    "classname": "NonBlockingClientHandler",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/impl/NonBlockingClientHandler_1Test.java",
    "test_prompt": "// NonBlockingClientHandler_1Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#getWakeupSelectorAfterRegisterRead()} method.\n*/\nclass NonBlockingClientHandler_1Test {",
    "method_signature": "getWakeupSelectorAfterRegisterRead()",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// NonBlockingClientHandler.java\n/*\n * This file is part of the QuickServer library \n * Copyright (C) QuickServer.org\n *\n * Use, modification, copying and distribution of this software is subject to\n * the terms and conditions of the GNU Lesser General Public License. \n * You should have received a copy of the GNU LGP License along with this \n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\n *\n * For questions, suggestions, bug-reports, enhancement-requests etc.\n * visit http://www.quickserver.org\n *\n */\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\n\npublic class NonBlockingClientHandler extends BasicClientHandler {\n\n    private static final Logger logger \u003d Logger.getLogger(NonBlockingClientHandler.class.getName());\n\n    //v1.4.5\n    protected ClientWriteHandler clientWriteHandler;\n\n    private SocketChannel socketChannel;\n\n    protected ArrayList readByteBuffer \u003d new ArrayList();\n\n    protected ArrayList writeByteBuffer \u003d new ArrayList();\n\n    protected SelectionKey selectionKey;\n\n    protected volatile int threadAccessCount \u003d 0;\n\n    protected volatile boolean willReturn;\n\n    protected volatile boolean waitingForFinalWrite;\n\n    //one for each event ACCEPT, WRITE, READ\n    private static int maxThreadAccessCount \u003d 5;\n\n    private static boolean wakeupSelectorAfterRegisterWrite \u003d true;\n\n    private static boolean wakeupSelectorAfterRegisterRead \u003d true;\n\n    //nio ssl\n    //private final SSLSession session;\n    private boolean initialHandshakeStatus \u003d false;\n\n    private SSLEngineResult.HandshakeStatus handshakeStatus;\n\n    private SSLEngineResult.Status status \u003d null;\n\n    private ByteBuffer dummyByteBuffer \u003d ByteBuffer.allocate(0);\n\n    private ByteBuffer peerNetData \u003d null;\n\n    private boolean sslShutdown \u003d false;\n\n    /**\n     * Sets the flag to wakeup Selector After RegisterForWrite is called.\n     * @since 1.4.7\n     */\n    public static void setWakeupSelectorAfterRegisterWrite(boolean flag) {\n        wakeupSelectorAfterRegisterWrite \u003d flag;\n    }\n\n    /**\n     * Returns wakeupSelectorAfterRegisterWrite the flag that controls if wakeup is called on Selector\n     * after RegisterForWrite is called.\n     * @since 1.4.7\n     */\n    public static boolean getWakeupSelectorAfterRegisterWrite() {\n        return wakeupSelectorAfterRegisterWrite;\n    }\n\n    /**\n     * Sets the flag to wakeup Selector After RegisterForRead is called.\n     * @since 1.4.7\n     */\n    public static void setWakeupSelectorAfterRegisterRead(boolean flag) {\n        wakeupSelectorAfterRegisterRead \u003d flag;\n    }\n\n    /**\n     * Returns wakeupSelectorAfterRegisterRead the flag that controls if wakeup is called on Selector\n     * after RegisterForRead is called.\n     * @since 1.4.7\n     */\n    public static boolean getWakeupSelectorAfterRegisterRead() {\n        return wakeupSelectorAfterRegisterRead;\n    }\n\n    /**\n     * Sets the maximum count of thread allowed to run objects of this class at a time.\n     * @since 1.4.7\n     */\n    public static void setMaxThreadAccessCount(int count) {\n        if (count \u003c 3 \u0026\u0026 count !\u003d -1)\n            throw new IllegalArgumentException(\"Value should be \u003e\u003d3 or -1\");\n        maxThreadAccessCount \u003d count;\n    }\n\n    /**\n     * Returns the maximum count of thread allowed to run objects of this class at a time.\n     * @since 1.4.7\n     */\n    public static int getMaxThreadAccessCount() {\n        return maxThreadAccessCount;\n    }\n\n    //v1.4.7\n    private ByteBufferOutputStream byteBufferOutputStream;\n\n    public NonBlockingClientHandler(int instanceCount) {\n        super(instanceCount);\n    }\n\n    public NonBlockingClientHandler() {\n        super();\n    }\n\n    public void clean() {\n        logger.finest(\"Starting clean - \" + getName());\n        if (threadAccessCount !\u003d 0) {\n            logger.warning(\"Thread Access Count was not 0!: \" + threadAccessCount);\n            if (Assertion.isEnabled()) {\n                assertionSystemExit();\n            }\n            threadAccessCount \u003d 0;\n        }\n        while (readByteBuffer.isEmpty() \u003d\u003d false) {\n            try {\n                getServer().getByteBufferPool().returnObject(readByteBuffer.remove(0));\n            } catch (Exception er) {\n                logger.warning(\"Error in returning read ByteBuffer to pool: \" + er);\n                break;\n            }\n        }\n        while (writeByteBuffer.isEmpty() \u003d\u003d false) {\n            try {\n                getServer().getByteBufferPool().returnObject(writeByteBuffer.remove(0));\n            } catch (Exception er) {\n                appLogger.warning(\"Error in returning write ByteBuffer to pool: \" + er);\n                break;\n            }\n        }\n        if (peerNetData !\u003d null) {\n            try {\n                getServer().getByteBufferPool().returnObject(peerNetData);\n            } catch (Exception er) {\n                appLogger.warning(\"Error in returning peerNetData to pool: \" + er);\n            }\n        }\n        if (selectionKey !\u003d null) {\n            selectionKey.cancel();\n            selectionKey.selector().wakeup();\n            selectionKey \u003d null;\n        }\n        willReturn \u003d false;\n        waitingForFinalWrite \u003d false;\n        socketChannel \u003d null;\n        if (byteBufferOutputStream !\u003d null) {\n            byteBufferOutputStream.close();\n        }\n        super.clean();\n        //1.4.5\n        clientWriteHandler \u003d null;\n        byteBufferOutputStream \u003d null;\n        sslShutdown \u003d false;\n        logger.finest(\"Finished clean - \" + getName());\n    }\n\n    protected void finalize() throws Throwable {\n        clean();\n        super.finalize();\n    }\n\n    public void handleClient(TheClient theClient) throws Exception {\n        super.handleClient(theClient);\n        //v1.4.5\n        setClientWriteHandler(theClient.getClientWriteHandler());\n        //1.4.5\n        setSocketChannel(theClient.getSocketChannel());\n    }\n\n    protected void setInputStream(InputStream in) throws IOException {\n        this.in \u003d in;\n        if (getDataMode(DataType.IN) \u003d\u003d DataMode.STRING) {\n            b_in \u003d null;\n            o_in \u003d null;\n            bufferedReader \u003d null;\n        } else if (getDataMode(DataType.IN) \u003d\u003d DataMode.OBJECT) {\n            b_in \u003d null;\n            bufferedReader \u003d null;\n            o_in \u003d new ObjectInputStream(in);\n        } else if (getDataMode(DataType.IN) \u003d\u003d DataMode.BYTE || getDataMode(DataType.IN) \u003d\u003d DataMode.BINARY) {\n            o_in \u003d null;\n            bufferedReader \u003d null;\n            b_in \u003d null;\n        }\n    }\n\n    public BufferedReader getBufferedReader() {\n        throw new IllegalStateException(\"Access to BufferedReader in not allowed in Non-Blocking mode!\");\n    }\n\n    public void closeConnection() {\n        logger.finest(\"inside\");\n        synchronized (this) {\n            if (connection \u003d\u003d false)\n                return;\n            if (waitingForFinalWrite)\n                return;\n            if (getSelectionKey() !\u003d null \u0026\u0026 getSelectionKey().isValid() \u0026\u0026 lost \u003d\u003d false) {\n                waitingForFinalWrite \u003d true;\n            } else {\n                connection \u003d false;\n            }\n        }\n        try {\n            if (getSocketChannel() !\u003d null \u0026\u0026 socket !\u003d null) {\n                if (waitingForFinalWrite) {\n                    try {\n                        waitTillFullyWritten();\n                    } catch (Exception error) {\n                        logger.warning(\"Error in waitingForFinalWrite : \" + error);\n                        if (logger.isLoggable(Level.FINE)) {\n                            logger.fine(\"StackTrace:\\n\" + MyString.getStackTrace(error));\n                        }\n                    }\n                }\n                //end of waitingForFinalWrite\n                if (isSecure() \u003d\u003d true) {\n                    sslShutdown \u003d true;\n                    if (lost \u003d\u003d false \u0026\u0026 sslEngine.isOutboundDone() \u003d\u003d false) {\n                        logger.finest(\"SSL isOutboundDone is false\");\n                        if (byteBufferOutputStream.doShutdown() \u003d\u003d false) {\n                            return;\n                        }\n                    } else if (sslEngine.isOutboundDone()) {\n                        logger.finest(\"SSL Outbound is done.\");\n                    }\n                }\n                doPostCloseActivity();\n            }\n            //if socket\n        } catch (IOException e) {\n            logger.warning(\"Error in closeConnection : \" + e);\n            if (logger.isLoggable(Level.FINE)) {\n                logger.fine(\"StackTrace:\\n\" + MyString.getStackTrace(e));\n            }\n        } catch (NullPointerException npe) {\n            logger.fine(\"NullPointerException: \" + npe);\n            if (logger.isLoggable(Level.FINE)) {\n                logger.fine(\"StackTrace:\\n\" + MyString.getStackTrace(npe));\n            }\n        }\n    }\n\n    private void doPostCloseActivity() throws IOException {\n        connection \u003d false;\n        byteBufferOutputStream.forceNotify();\n        getSelectionKey().cancel();\n        if (getServer() !\u003d null) {\n            getServer().getSelector().wakeup();\n        }\n        synchronized (this) {\n            if (hasEvent(ClientEvent.MAX_CON) \u003d\u003d false) {\n                notifyCloseOrLost();\n            }\n            if (getSocketChannel().isOpen()) {\n                logger.finest(\"Closing SocketChannel\");\n                getSocketChannel().close();\n            }\n        }\n    }\n\n    public boolean closeIfSSLOutboundDone() {\n        if (isSecure() \u003d\u003d false)\n            throw new IllegalStateException(\"Client is not in secure mode!\");\n        if (sslEngine.isOutboundDone()) {\n            logger.finest(\"SSL Outbound is done.\");\n            try {\n                if (getSocketChannel().isOpen()) {\n                    logger.finest(\"Closing SocketChannel\");\n                    getSocketChannel().close();\n                }\n            } catch (IOException e) {\n                logger.fine(\"IGNORE: Error in Closing SocketChannel: \" + e);\n            }\n            return true;\n        } else {\n            logger.finest(\"SSL Outbound is not done.\");\n            return false;\n        }\n    }\n\n    /**\n     * waitTillFullyWritten\n     * @since 1.4.7\n     */\n    public void waitTillFullyWritten() {\n        Object waitLock \u003d new Object();\n        if (byteBufferOutputStream.isDataAvailableForWrite(waitLock)) {\n            if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {\n                logger.finest(\"Waiting \" + getName());\n            }\n            try {\n                synchronized (waitLock) {\n                    //2 min max\n                    waitLock.wait(1000 * 60 * 2);\n                }\n            } catch (InterruptedException ie) {\n                logger.warning(\"Error: \" + ie);\n            }\n            if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {\n                logger.finest(\"Done. \" + getName());\n            }\n        }\n    }\n\n    public void run() {\n        if (unprocessedClientEvents.isEmpty()) {\n            logger.finest(\"No unprocessed ClientEvents!\");\n            return;\n        }\n        synchronized (this) {\n            if (willReturn) {\n                return;\n            } else {\n                threadAccessCount++;\n            }\n        }\n        ClientEvent currentEvent \u003d (ClientEvent) unprocessedClientEvents.poll();\n        if (currentEvent \u003d\u003d null) {\n            threadEvent.set(null);\n            logger.finest(\"No unprocessed ClientEvents! pool was null\");\n            return;\n        }\n        if (logger.isLoggable(Level.FINEST)) {\n            StringBuilder sb \u003d new StringBuilder();\n            sb.append(\"Running \").append(getName());\n            sb.append(\" using \");\n            sb.append(Thread.currentThread().getName());\n            sb.append(\" for \");\n            synchronized (clientEvents) {\n                if (clientEvents.size() \u003e 1) {\n                    sb.append(currentEvent + \", Current Events - \" + clientEvents);\n                } else {\n                    sb.append(currentEvent);\n                }\n            }\n            logger.finest(sb.toString());\n        }\n        logger.finest(\"threadAccessCount: \" + threadAccessCount);\n        threadEvent.set(currentEvent);\n        try {\n            if (maxThreadAccessCount !\u003d -1 \u0026\u0026 threadAccessCount \u003e maxThreadAccessCount) {\n                logger.warning(\"ThreadAccessCount can\u0027t go beyond \" + maxThreadAccessCount + \": \" + threadAccessCount);\n                if (Assertion.isEnabled()) {\n                    throw new AssertionError(\"ThreadAccessCount can\u0027t go beyond \" + maxThreadAccessCount + \": \" + threadAccessCount);\n                }\n                return;\n            }\n            if (socket \u003d\u003d null)\n                throw new SocketException(\"Socket was null!\");\n            if (getThreadEvent() \u003d\u003d ClientEvent.ACCEPT || getThreadEvent() \u003d\u003d ClientEvent.MAX_CON) {\n                prepareForRun();\n                Assertion.affirm(willReturn \u003d\u003d false, \"WillReturn has to be false!: \" + willReturn);\n            }\n            if (getThreadEvent() \u003d\u003d ClientEvent.MAX_CON) {\n                processMaxConnection(currentEvent);\n            }\n            try {\n                if (getThreadEvent() \u003d\u003d ClientEvent.ACCEPT) {\n                    registerForRead();\n                    clientEventHandler.gotConnected(this);\n                    if (authorised \u003d\u003d false) {\n                        if (clientAuthenticationHandler \u003d\u003d null \u0026\u0026 authenticator \u003d\u003d null) {\n                            authorised \u003d true;\n                            logger.finest(\"No Authenticator \" + getName() + \" so return thread.\");\n                        } else {\n                            if (clientAuthenticationHandler !\u003d null) {\n                                AuthStatus authStatus \u003d null;\n                                do {\n                                    authStatus \u003d processAuthorisation();\n                                } while (authStatus \u003d\u003d AuthStatus.FAILURE);\n                                if (authStatus \u003d\u003d AuthStatus.SUCCESS)\n                                    authorised \u003d true;\n                            } else {\n                                processAuthorisation();\n                            }\n                            if (authorised)\n                                logger.finest(\"Authentication done \" + getName() + \", so return thread.\");\n                            else\n                                logger.finest(\"askAuthentication() done \" + getName() + \", so return thread.\");\n                        }\n                    }\n                    //end authorised\n                    //return thread to pool\n                    returnThread();\n                    return;\n                }\n                if (connection \u0026\u0026 getThreadEvent() \u003d\u003d ClientEvent.READ) {\n                    if (processRead())\n                        return;\n                }\n                if (connection \u0026\u0026 getThreadEvent() \u003d\u003d ClientEvent.WRITE) {\n                    if (processWrite())\n                        return;\n                }\n            } catch (SocketException e) {\n                appLogger.finest(\"SocketException - Client [\" + getHostAddress() + \"]: \" + e.getMessage());\n                //e.printStackTrace();\n                lost \u003d true;\n            } catch (AppException e) {\n                //errors from Application\n                appLogger.finest(\"AppException \" + Thread.currentThread().getName() + \": \" + e.getMessage());\n            } catch (javax.net.ssl.SSLException e) {\n                lost \u003d true;\n                if (Assertion.isEnabled()) {\n                    appLogger.info(\"SSLException - Client [\" + getHostAddress() + \"] \" + Thread.currentThread().getName() + \": \" + e);\n                } else {\n                    appLogger.warning(\"SSLException - Client [\" + getHostAddress() + \"]: \" + e);\n                }\n            } catch (ConnectionLostException e) {\n                lost \u003d true;\n                if (e.getMessage() !\u003d null)\n                    appLogger.finest(\"Connection lost \" + Thread.currentThread().getName() + \": \" + e.getMessage());\n                else\n                    appLogger.finest(\"Connection lost \" + Thread.currentThread().getName());\n            } catch (ClosedChannelException e) {\n                lost \u003d true;\n                appLogger.finest(\"Channel closed \" + Thread.currentThread().getName() + \": \" + e);\n            } catch (IOException e) {\n                lost \u003d true;\n                appLogger.fine(\"IOError \" + Thread.currentThread().getName() + \": \" + e);\n            } catch (AssertionError er) {\n                logger.warning(\"[AssertionError] \" + getName() + \" \" + er);\n                if (logger.isLoggable(Level.FINEST)) {\n                    logger.finest(\"StackTrace \" + Thread.currentThread().getName() + \": \" + MyString.getStackTrace(er));\n                }\n                assertionSystemExit();\n            } catch (Error er) {\n                logger.warning(\"[Error] \" + er);\n                if (logger.isLoggable(Level.FINEST)) {\n                    logger.finest(\"StackTrace \" + Thread.currentThread().getName() + \": \" + MyString.getStackTrace(er));\n                }\n                if (Assertion.isEnabled()) {\n                    assertionSystemExit();\n                }\n                lost \u003d true;\n            } catch (RuntimeException re) {\n                logger.warning(\"[RuntimeException] \" + MyString.getStackTrace(re));\n                if (Assertion.isEnabled()) {\n                    assertionSystemExit();\n                }\n                lost \u003d true;\n            }\n            if (getThreadEvent() !\u003d ClientEvent.MAX_CON) {\n                notifyCloseOrLost();\n            }\n            if (connection) {\n                logger.finest(Thread.currentThread().getName() + \" calling closeConnection()\");\n                closeConnection();\n            }\n            if (connection \u003d\u003d true \u0026\u0026 lost \u003d\u003d true \u0026\u0026 waitingForFinalWrite) {\n                byteBufferOutputStream.forceNotify();\n            }\n        } catch (javax.net.ssl.SSLException se) {\n            logger.warning(\"SSLException \" + Thread.currentThread().getName() + \" - \" + se);\n        } catch (IOException ie) {\n            logger.warning(\"IOError \" + Thread.currentThread().getName() + \" - Closing Client : \" + ie);\n        } catch (RuntimeException re) {\n            logger.warning(\"[RuntimeException] \" + getName() + \" \" + Thread.currentThread().getName() + \" - \" + MyString.getStackTrace(re));\n            if (Assertion.isEnabled()) {\n                assertionSystemExit();\n            }\n        } catch (Exception e) {\n            logger.warning(\"Error \" + Thread.currentThread().getName() + \" - Event:\" + getThreadEvent() + \" - Socket:\" + socket + \" : \" + e);\n            logger.fine(\"StackTrace: \" + getName() + \"\\n\" + MyString.getStackTrace(e));\n            if (Assertion.isEnabled()) {\n                assertionSystemExit();\n            }\n        } catch (Error e) {\n            logger.warning(\"Error \" + Thread.currentThread().getName() + \" - Event:\" + getThreadEvent() + \" - Socket:\" + socket + \" : \" + e);\n            logger.fine(\"StackTrace: \" + getName() + \"\\n\" + MyString.getStackTrace(e));\n            if (Assertion.isEnabled()) {\n                assertionSystemExit();\n            }\n        }\n        synchronized (this) {\n            try {\n                if (getSelectionKey() !\u003d null \u0026\u0026 getSelectionKey().isValid()) {\n                    logger.finest(\"Canceling SelectionKey\");\n                    getSelectionKey().cancel();\n                }\n                if (socket !\u003d null \u0026\u0026 socket.isClosed() \u003d\u003d false) {\n                    logger.finest(\"Closing Socket\");\n                    socket.close();\n                }\n                if (getSocketChannel() !\u003d null \u0026\u0026 getSocketChannel().isOpen()) {\n                    logger.finest(\"Closing SocketChannel\");\n                    socketChannel.close();\n                }\n            } catch (Exception re) {\n                logger.warning(\"Error closing Socket/Channel: \" + re);\n            }\n        }\n        //end synchronized\n        willClean \u003d true;\n        returnClientData();\n        boolean returnClientHandler \u003d false;\n        synchronized (lockObj) {\n            returnThread();\n            returnClientHandler \u003d checkReturnClientHandler();\n        }\n        if (returnClientHandler) {\n            //return to pool\n            returnClientHandler();\n        }\n    }\n\n    protected boolean checkReturnClientHandler() {\n        if (willReturn \u003d\u003d false) {\n            willReturn \u003d true;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Process read\n     * @return value indicates if the thread should return form run()\n     */\n    private boolean processRead() throws Exception {\n        if (doRead()) {\n            //return to pool\n            returnThread();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    private boolean doRead() throws Exception {\n        int count \u003d 0;\n        int fullCount \u003d 0;\n        while (true) {\n            try {\n                if (peerNetData \u003d\u003d null) {\n                    peerNetData \u003d (ByteBuffer) getServer().getByteBufferPool().borrowObject();\n                }\n                count \u003d getSocketChannel().read(peerNetData);\n                if (count \u003c 0) {\n                    //logger.finest(\"SocketChannel read was \"+count+\"!\");\n                    getServer().getByteBufferPool().returnObject(peerNetData);\n                    peerNetData \u003d null;\n                    break;\n                } else {\n                    fullCount +\u003d count;\n                }\n                // Make readable\n                peerNetData.flip();\n                ByteBuffer peerAppData \u003d null;\n                //--\n                if (sslEngine !\u003d null) {\n                    SSLEngineResult res;\n                    peerAppData \u003d (ByteBuffer) getServer().getByteBufferPool().borrowObject();\n                    do {\n                        res \u003d sslEngine.unwrap(peerNetData, peerAppData);\n                        logger.info(\"Unwrapping:\\n\" + res);\n                    } while (res.getStatus() \u003d\u003d SSLEngineResult.Status.OK \u0026\u0026 res.getHandshakeStatus() \u003d\u003d SSLEngineResult.HandshakeStatus.NEED_UNWRAP \u0026\u0026 res.bytesProduced() \u003d\u003d 0);\n                    if (res.getHandshakeStatus() \u003d\u003d SSLEngineResult.HandshakeStatus.FINISHED) {\n                        logger.info(\"HandshakeStatus.FINISHED!\");\n                        finishInitialHandshake();\n                    }\n                    if (peerAppData.position() \u003d\u003d 0 \u0026\u0026 res.getStatus() \u003d\u003d SSLEngineResult.Status.OK \u0026\u0026 peerNetData.hasRemaining()) {\n                        logger.info(\"peerNetData hasRemaining and pos\u003d0!\");\n                        res \u003d sslEngine.unwrap(peerNetData, peerAppData);\n                        logger.info(\"Unwrapping:\\n\" + res);\n                    }\n                    /*\n\t\t\t\t\t * OK, OVERFLOW, UNDERFLOW, CLOSED\n\t\t\t\t\t */\n                    status \u003d res.getStatus();\n                    handshakeStatus \u003d res.getHandshakeStatus();\n                    if (status !\u003d SSLEngineResult.Status.BUFFER_OVERFLOW) {\n                        logger.warning(\"Buffer overflow: \" + res.toString());\n                    } else if (status \u003d\u003d SSLEngineResult.Status.CLOSED) {\n                        logger.fine(\"Connection is being closed by peer.\");\n                        lost \u003d true;\n                        System.out.println(\"NEdd to code for shutdow of SSL\");\n                        break;\n                    }\n                    peerNetData.compact();\n                    peerAppData.flip();\n                    if (handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.NEED_TASK || handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.NEED_WRAP || handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.FINISHED) {\n                        doHandshake();\n                    }\n                    //return peerAppData.remaining();\n                    logger.fine(\"peerAppData.remaining(): \" + peerAppData.remaining());\n                } else {\n                    peerAppData \u003d peerNetData;\n                    peerNetData \u003d null;\n                }\n                //--\n                readByteBuffer.add(peerAppData);\n                peerAppData \u003d null;\n            } catch (Exception error) {\n                logger.finest(\"Error in data read: \" + error);\n                if (sslEngine !\u003d null)\n                    sslEngine.closeInbound();\n                lost \u003d true;\n                synchronized (getInputStream()) {\n                    getInputStream().notifyAll();\n                }\n                throw error;\n            }\n            if (count \u003d\u003d 0)\n                break;\n        }\n        //end while\n        if (count \u003c 0) {\n            logger.finest(\"SocketChannel read was \" + count + \"!\");\n            if (sslEngine !\u003d null)\n                sslEngine.closeInbound();\n            lost \u003d true;\n            synchronized (getInputStream()) {\n                getInputStream().notifyAll();\n            }\n        } else {\n            logger.finest(fullCount + \" bytes read\");\n            if (fullCount !\u003d 0) {\n                updateLastCommunicationTime();\n                synchronized (getInputStream()) {\n                    //if any are waiting\n                    getInputStream().notify();\n                }\n                if (hasEvent(ClientEvent.ACCEPT) \u003d\u003d false) {\n                    processGotDataInBuffers();\n                }\n            }\n            //check if any data was read but not yet processed\n            while (getInputStream().available() \u003e 0) {\n                logger.finest(\"Sending again for processing...\");\n                if (hasEvent(ClientEvent.ACCEPT) \u003d\u003d false) {\n                    processGotDataInBuffers();\n                    break;\n                } else {\n                    synchronized (getInputStream()) {\n                        getInputStream().notifyAll();\n                    }\n                    Thread.sleep(100);\n                }\n            }\n            if (connection) {\n                registerForRead();\n                //getSelectionKey().selector().wakeup();\n                return true;\n            }\n        }\n        //end of else\n        logger.finest(\"We don\u0027t have connection, lets return all resources.\");\n        return false;\n    }\n\n    /**\n     * Process write\n     * @return value indicates if the thread should return form run()\n     */\n    private boolean processWrite() throws IOException {\n        if (doWrite()) {\n            //return to pool\n            returnThread();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    private boolean doWrite() throws IOException {\n        if (sslShutdown) {\n            if (byteBufferOutputStream.doShutdown() \u003d\u003d false) {\n                return true;\n            }\n            doPostCloseActivity();\n            logger.finest(\"We don\u0027t have connection, lets return all resources.\");\n            return false;\n        }\n        updateLastCommunicationTime();\n        boolean flag \u003d byteBufferOutputStream.writeAllByteBuffer();\n        if (flag \u003d\u003d false) {\n            registerWrite();\n        } else if (/*flag\u003d\u003dtrue \u0026\u0026 */\n        clientWriteHandler !\u003d null) {\n            clientWriteHandler.handleWrite(this);\n        }\n        if (connection) {\n            return true;\n        } else {\n            logger.finest(\"We don\u0027t have connection, lets return all resources.\");\n            return false;\n        }\n    }\n\n    protected void returnThread() {\n        //System.out.println(\"returnThread..\");\n        //(new Exception()).printStackTrace();\n        threadAccessCount--;\n        Assertion.affirm(threadAccessCount \u003e\u003d 0, \"ThreadAccessCount went less the 0! Value: \" + threadAccessCount);\n        //return is done at ClientThread end\n        removeEvent((ClientEvent) threadEvent.get());\n    }\n\n    protected void returnClientHandler() {\n        logger.finest(getName());\n        try {\n            for (int i \u003d 0; threadAccessCount !\u003d 0; i++) {\n                if (i \u003d\u003d 100) {\n                    logger.warning(\"ClientHandler must have got into a loop waiting for thread to free up! ThreadAccessCount\u003d\" + threadAccessCount);\n                    threadAccessCount \u003d 0;\n                    if (Assertion.isEnabled()) {\n                        assertionSystemExit();\n                    } else {\n                        break;\n                    }\n                }\n                if (threadAccessCount \u003c\u003d 0)\n                    break;\n                logger.finest(\"Waiting for other thread of \" + getName() + \" to finish\");\n                Thread.sleep(60);\n            }\n        } catch (InterruptedException ie) {\n            appLogger.warning(\"InterruptedException: \" + ie);\n        }\n        super.returnClientHandler();\n    }\n\n    public void setDataMode(DataMode dataMode, DataType dataType) throws IOException {\n        if (getDataMode(dataType) \u003d\u003d dataMode)\n            return;\n        appLogger.fine(\"Setting Type:\" + dataType + \", Mode:\" + dataMode);\n        super.checkDataModeSet(dataMode, dataType);\n        setDataModeNonBlocking(dataMode, dataType);\n    }\n\n    private void setDataModeNonBlocking(DataMode dataMode, DataType dataType) throws IOException {\n        logger.finest(\"ENTER\");\n        if (dataMode \u003d\u003d DataMode.STRING) {\n            if (dataType \u003d\u003d DataType.OUT) {\n                if (dataModeOUT \u003d\u003d DataMode.BYTE || dataModeOUT \u003d\u003d DataMode.BINARY) {\n                    dataModeOUT \u003d dataMode;\n                } else if (dataModeOUT \u003d\u003d DataMode.OBJECT) {\n                    dataModeOUT \u003d dataMode;\n                    o_out.flush();\n                    o_out \u003d null;\n                    b_out \u003d new BufferedOutputStream(out);\n                } else {\n                    Assertion.affirm(false, \"Unknown DataType.OUT DataMode - \" + dataModeOUT);\n                }\n                Assertion.affirm(b_out !\u003d null, \"BufferedOutputStream is still null!\");\n                Assertion.affirm(o_out \u003d\u003d null, \"ObjectOutputStream is still not null!\");\n            } else if (dataType \u003d\u003d DataType.IN) {\n                dataModeIN \u003d dataMode;\n                if (o_in !\u003d null) {\n                    if (o_in.available() !\u003d 0)\n                        logger.warning(\"Data looks to be present in ObjectInputStream\");\n                    o_in \u003d null;\n                }\n                b_in \u003d null;\n                bufferedReader \u003d null;\n                //input stream will work\n                Assertion.affirm(in !\u003d null, \"InputStream is still null!\");\n                Assertion.affirm(b_in \u003d\u003d null, \"BufferedInputStream is still not null!\");\n                Assertion.affirm(bufferedReader \u003d\u003d null, \"BufferedReader is still not null!\");\n            }\n        } else if (dataMode \u003d\u003d DataMode.OBJECT) {\n            if (dataType \u003d\u003d DataType.IN) {\n                //we will disable this for now\n                throw new IllegalArgumentException(\"Can\u0027t set DataType.IN mode to OBJECT when blocking mode is set as false!\");\n            }\n            if (dataType \u003d\u003d DataType.OUT) {\n                dataModeOUT \u003d dataMode;\n                b_out \u003d null;\n                o_out \u003d new ObjectOutputStream(out);\n                Assertion.affirm(o_out !\u003d null, \"ObjectOutputStream is still null!\");\n                o_out.flush();\n            } else if (dataType \u003d\u003d DataType.IN) {\n                dataModeIN \u003d dataMode;\n                b_in \u003d null;\n                bufferedReader \u003d null;\n                registerForRead();\n                //will block\n                o_in \u003d new ObjectInputStream(in);\n                Assertion.affirm(o_in !\u003d null, \"ObjectInputStream is still null!\");\n            }\n        } else if (dataMode \u003d\u003d DataMode.BYTE || dataMode \u003d\u003d DataMode.BINARY) {\n            if (dataType \u003d\u003d DataType.OUT) {\n                if (dataModeOUT \u003d\u003d DataMode.STRING || dataModeOUT \u003d\u003d DataMode.BYTE || dataModeOUT \u003d\u003d DataMode.BINARY) {\n                    dataModeOUT \u003d dataMode;\n                } else if (dataModeOUT \u003d\u003d DataMode.OBJECT) {\n                    dataModeOUT \u003d dataMode;\n                    o_out \u003d null;\n                    b_out \u003d new BufferedOutputStream(out);\n                } else {\n                    Assertion.affirm(false, \"Unknown DataType.OUT - DataMode: \" + dataModeOUT);\n                }\n                Assertion.affirm(b_out !\u003d null, \"BufferedOutputStream is still null!\");\n            } else if (dataType \u003d\u003d DataType.IN) {\n                dataModeIN \u003d dataMode;\n                o_in \u003d null;\n                bufferedReader \u003d null;\n                b_in \u003d null;\n                //input stream will work\n                Assertion.affirm(in !\u003d null, \"InputStream is still null!\");\n            } else {\n                throw new IllegalArgumentException(\"Unknown DataType : \" + dataType);\n            }\n        } else {\n            throw new IllegalArgumentException(\"Unknown DataMode : \" + dataMode);\n        }\n    }\n\n    protected byte[] readInputStream() throws IOException {\n        return readInputStream(getInputStream());\n    }\n\n    public void updateInputOutputStreams() throws IOException {\n        byteBufferOutputStream \u003d new ByteBufferOutputStream(writeByteBuffer, this);\n        setInputStream(new ByteBufferInputStream(readByteBuffer, this, getCharset()));\n        setOutputStream(byteBufferOutputStream);\n        //logger.warning(\"updateInputOutputStreams: \"+sslEngine);\n        if (sslEngine !\u003d null) {\n            sslEngine.setUseClientMode(false);\n            sslEngine.beginHandshake();\n            handshakeStatus \u003d sslEngine.getHandshakeStatus();\n            initialHandshakeStatus \u003d true;\n            /*\n\t\t\ttry {\n\t\t\t\tdoHandshake();\n\t\t\t} catch(Exception e) {\n\t\t\t\tlogger.warning(\"Error: \"+e);\n\t\t\t\tthrow new IOException(e.toString());\n\t\t\t}\n\t\t\t*/\n        }\n    }\n\n    public boolean getBlockingMode() {\n        return false;\n    }\n\n    public void setSocketChannel(SocketChannel socketChannel) {\n        this.socketChannel \u003d socketChannel;\n    }\n\n    public SocketChannel getSocketChannel() {\n        return socketChannel;\n    }\n\n    public void setSelectionKey(SelectionKey selectionKey) {\n        this.selectionKey \u003d selectionKey;\n    }\n\n    public SelectionKey getSelectionKey() {\n        if (selectionKey \u003d\u003d null)\n            selectionKey \u003d getSocketChannel().keyFor(getServer().getSelector());\n        return selectionKey;\n    }\n\n    private void processGotDataInBuffers() throws AppException, ConnectionLostException, ClassNotFoundException, IOException {\n        if (getInputStream().available() \u003d\u003d 0)\n            return;\n        logger.finest(\"Trying to process got data.. DataMode.IN\u003d\" + dataModeIN);\n        AuthStatus authStatus \u003d null;\n        //--For debug\n        ((ByteBufferInputStream) getInputStream()).dumpContent();\n        String temp \u003d null;\n        String rec \u003d null;\n        Object recObject \u003d null;\n        byte[] recByte \u003d null;\n        boolean timeToCheckForNewLineMiss \u003d false;\n        do {\n            //updateLastCommunicationTime();\n            if (dataModeIN \u003d\u003d DataMode.STRING) {\n                ByteBufferInputStream bbin \u003d (ByteBufferInputStream) getInputStream();\n                timeToCheckForNewLineMiss \u003d true;\n                while (bbin.isLineReady()) {\n                    rec \u003d bbin.readLine();\n                    if (rec \u003d\u003d null) {\n                        lost \u003d true;\n                        return;\n                    }\n                    if (getCommunicationLogging() \u0026\u0026 authorised \u003d\u003d true) {\n                        appLogger.log(Level.FINE, \"Got STRING [{0}] : {1}\", new Object[] { getHostAddress(), rec });\n                    }\n                    totalReadBytes \u003d totalReadBytes + rec.length();\n                    if (authorised \u003d\u003d false)\n                        authStatus \u003d clientAuthenticationHandler.handleAuthentication(this, rec);\n                    else\n                        clientCommandHandler.handleCommand(this, rec);\n                    if (isClosed() \u003d\u003d true)\n                        return;\n                    while (authStatus \u003d\u003d AuthStatus.FAILURE) authStatus \u003d processAuthorisation();\n                    if (authStatus \u003d\u003d AuthStatus.SUCCESS)\n                        authorised \u003d true;\n                    if (dataModeIN !\u003d DataMode.STRING) {\n                        break;\n                    }\n                    timeToCheckForNewLineMiss \u003d false;\n                }\n                //end of while\n                if (timeToCheckForNewLineMiss \u0026\u0026 bbin.availableOnlyInByteBuffer() \u003d\u003d 0) {\n                    return;\n                } else {\n                    timeToCheckForNewLineMiss \u003d false;\n                }\n            }\n            //if(dataModeIN \u003d\u003d DataMode.OBJECT) {\n            while (dataModeIN \u003d\u003d DataMode.OBJECT \u0026\u0026 o_in !\u003d null) {\n                //not sure if all bytes are in buffer..~ may need more read.. will get stuck..\n                recObject \u003d o_in.readObject();\n                if (recObject \u003d\u003d null) {\n                    lost \u003d true;\n                    return;\n                }\n                if (getCommunicationLogging() \u0026\u0026 authorised \u003d\u003d true) {\n                    appLogger.log(Level.FINE, \"Got OBJECT [{0}] : {1}\", new Object[] { getHostAddress(), recObject.toString() });\n                }\n                totalReadBytes \u003d totalReadBytes + 1;\n                if (authorised \u003d\u003d false)\n                    authStatus \u003d clientAuthenticationHandler.handleAuthentication(this, recObject);\n                else\n                    clientObjectHandler.handleObject(this, recObject);\n                if (isClosed() \u003d\u003d true)\n                    return;\n                while (authStatus \u003d\u003d AuthStatus.FAILURE) authStatus \u003d processAuthorisation();\n                if (authStatus \u003d\u003d AuthStatus.SUCCESS)\n                    authorised \u003d true;\n            }\n            //}\n            //if(dataModeIN \u003d\u003d DataMode.BYTE) {\n            while (dataModeIN \u003d\u003d DataMode.BYTE \u0026\u0026 getInputStream().available() !\u003d 0) {\n                rec \u003d readBytes();\n                if (rec \u003d\u003d null) {\n                    lost \u003d true;\n                    return;\n                }\n                if (getCommunicationLogging() \u0026\u0026 authorised \u003d\u003d true) {\n                    appLogger.log(Level.FINE, \"Got BYTE [{0}] : {1}\", new Object[] { getHostAddress(), rec });\n                }\n                totalReadBytes \u003d totalReadBytes + rec.length();\n                if (authorised \u003d\u003d false)\n                    authStatus \u003d clientAuthenticationHandler.handleAuthentication(this, rec);\n                else\n                    clientCommandHandler.handleCommand(this, rec);\n                if (isClosed() \u003d\u003d true)\n                    return;\n                while (authStatus \u003d\u003d AuthStatus.FAILURE) authStatus \u003d processAuthorisation();\n                if (authStatus \u003d\u003d AuthStatus.SUCCESS)\n                    authorised \u003d true;\n            }\n            //} else if(dataModeIN \u003d\u003d DataMode.BINARY) {\n            while (dataModeIN \u003d\u003d DataMode.BINARY \u0026\u0026 getInputStream().available() !\u003d 0) {\n                recByte \u003d readBinary();\n                if (recByte \u003d\u003d null) {\n                    lost \u003d true;\n                    return;\n                }\n                if (getCommunicationLogging() \u0026\u0026 authorised \u003d\u003d true) {\n                    if (getServer().isRawCommunicationLogging()) {\n                        if (getServer().getRawCommunicationMaxLength() \u003e 0 \u0026\u0026 recByte.length \u003e getServer().getRawCommunicationMaxLength()) {\n                            appLogger.log(Level.FINE, \"Got BINARY [{0}] : {1}; RAW: {2}{3}\", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length), new String(recByte, 0, getServer().getRawCommunicationMaxLength(), charset), \"...\" });\n                        } else {\n                            appLogger.log(Level.FINE, \"Got BINARY [{0}] : {1}; RAW: {2}\", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length), new String(recByte, charset) });\n                        }\n                    } else {\n                        appLogger.log(Level.FINE, \"Got BINARY [{0}] : {1}\", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length) });\n                    }\n                } else if (getCommunicationLogging()) {\n                    appLogger.log(Level.FINE, \"Got BINARY [{0}] : {1}\", new Object[] { getHostAddress(), MyString.getMemInfo(recByte.length) });\n                }\n                totalReadBytes \u003d totalReadBytes + recByte.length;\n                if (authorised \u003d\u003d false)\n                    authStatus \u003d clientAuthenticationHandler.handleAuthentication(this, recByte);\n                else\n                    clientBinaryHandler.handleBinary(this, recByte);\n                if (isClosed() \u003d\u003d true)\n                    return;\n                while (authStatus \u003d\u003d AuthStatus.FAILURE) authStatus \u003d processAuthorisation();\n                if (authStatus \u003d\u003d AuthStatus.SUCCESS)\n                    authorised \u003d true;\n            }\n            //} else {\n            if (dataModeIN !\u003d DataMode.STRING \u0026\u0026 dataModeIN !\u003d DataMode.OBJECT \u0026\u0026 dataModeIN !\u003d DataMode.BYTE \u0026\u0026 dataModeIN !\u003d DataMode.BINARY) {\n                throw new IllegalStateException(\"Incoming DataMode is not supported : \" + dataModeIN);\n            }\n        } while (getInputStream().available() !\u003d 0);\n    }\n\n    public void registerForRead() throws IOException, ClosedChannelException {\n        //System.out.println(\"registerForRead..\");\n        //(new Exception()).printStackTrace();\n        try {\n            if (getSelectionKey() \u003d\u003d null) {\n                boolean flag \u003d getServer().registerChannel(getSocketChannel(), SelectionKey.OP_READ, this);\n                if (flag) {\n                    logger.finest(\"Adding OP_READ as interest Ops for \" + getName());\n                } else if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {\n                    logger.finest(\"OP_READ is already present in interest Ops for \" + getName());\n                }\n            } else if (getSelectionKey().isValid()) {\n                if ((getSelectionKey().interestOps() \u0026 SelectionKey.OP_READ) \u003d\u003d 0) {\n                    logger.finest(\"Adding OP_READ to interest Ops for \" + getName());\n                    removeEvent(ClientEvent.READ);\n                    getSelectionKey().interestOps(getSelectionKey().interestOps() | SelectionKey.OP_READ);\n                    if (wakeupSelectorAfterRegisterRead) {\n                        getServer().getSelector().wakeup();\n                    }\n                } else {\n                    if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {\n                        logger.finest(\"OP_READ is already present in interest Ops for \" + getName());\n                    }\n                }\n            } else {\n                throw new IOException(\"SelectionKey is invalid!\");\n            }\n        } catch (CancelledKeyException e) {\n            throw new IOException(\"SelectionKey is cancelled!\");\n        }\n    }\n\n    public void registerForWrite() throws IOException, ClosedChannelException {\n        if (hasEvent(ClientEvent.RUN_BLOCKING) || hasEvent(ClientEvent.MAX_CON_BLOCKING)) {\n            throw new IllegalStateException(\"This method is only allowed under Non-Blocking mode.\");\n        }\n        if (clientWriteHandler \u003d\u003d null) {\n            throw new IllegalStateException(\"ClientWriteHandler has not been set!\");\n        }\n        registerWrite();\n    }\n\n    public void registerWrite() throws IOException {\n        //System.out.println(\"registerWrite..\");\n        //(new Exception()).printStackTrace();\n        try {\n            if (getSelectionKey() \u003d\u003d null) {\n                boolean flag \u003d getServer().registerChannel(getSocketChannel(), SelectionKey.OP_WRITE, this);\n                if (flag) {\n                    logger.finest(\"Adding OP_WRITE as interest Ops for \" + getName());\n                } else if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {\n                    logger.finest(\"OP_WRITE is already present in interest Ops for \" + getName());\n                }\n            } else if (getSelectionKey().isValid()) {\n                if ((getSelectionKey().interestOps() \u0026 SelectionKey.OP_WRITE) \u003d\u003d 0) {\n                    logger.finest(\"Adding OP_WRITE to interest Ops for \" + getName());\n                    removeEvent(ClientEvent.WRITE);\n                    getSelectionKey().interestOps(getSelectionKey().interestOps() | SelectionKey.OP_WRITE);\n                    if (wakeupSelectorAfterRegisterWrite) {\n                        getServer().getSelector().wakeup();\n                    }\n                } else {\n                    if (ByteBufferOutputStream.isLoggable(Level.FINEST)) {\n                        logger.finest(\"OP_WRITE is already present in interest Ops for \" + getName());\n                    }\n                }\n            } else {\n                throw new IOException(\"SelectionKey is invalid!\");\n            }\n        } catch (CancelledKeyException e) {\n            throw new IOException(\"SelectionKey is cancelled!\");\n        }\n    }\n\n    protected void setClientWriteHandler(ClientWriteHandler handler) {\n        clientWriteHandler \u003d handler;\n    }\n\n    /**\n     * Returns number of thread currently in this object.\n     * @since 1.4.6\n     */\n    public int getThreadAccessCount() {\n        return threadAccessCount;\n    }\n\n    private void doHandshake() throws Exception {\n        while (true) {\n            SSLEngineResult res;\n            logger.fine(\"handshakeStatus: \" + handshakeStatus);\n            if (handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.FINISHED) {\n                if (initialHandshakeStatus) {\n                    finishInitialHandshake();\n                }\n                return;\n            } else if (handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.NEED_TASK) {\n                doTasks();\n                continue;\n            } else if (handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n                /*\n\t\t\t\t\tdoRead();\n\n\t\t\t\t\tif(initialHandshakeStatus \u0026\u0026 \n\t\t\t\t\t\t\tstatus \u003d\u003d SSLEngineResult.Status.BUFFER_UNDERFLOW) {\n\t\t\t\t\t\tregisterForRead();\n\t\t\t\t\t}\n\t\t\t\t\t*/\n                return;\n            } else if (handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                ByteBuffer netData \u003d (ByteBuffer) getServer().getByteBufferPool().borrowObject();\n                //netData.clear();\n                res \u003d sslEngine.wrap(dummyByteBuffer, netData);\n                logger.info(\"Wrapping:\\n\" + res);\n                assert res.bytesProduced() !\u003d 0 : \"No net data produced during handshake wrap.\";\n                assert res.bytesConsumed() \u003d\u003d 0 : \"App data consumed during handshake wrap.\";\n                handshakeStatus \u003d res.getHandshakeStatus();\n                //netData.flip(); -- no need to flip will be done when writing to sc\n                byteBufferOutputStream.addEncryptedByteBuffer(netData);\n                if (!doWrite()) {\n                    return;\n                }\n                //back to loop\n                continue;\n            } else if (handshakeStatus \u003d\u003d SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n                assert false : \"doHandshake() should never reach the NOT_HANDSHAKING state\";\n                return;\n            }\n            //if\n        }\n        //loop\n    }\n\n    private void doTasks() {\n        Runnable task;\n        while ((task \u003d sslEngine.getDelegatedTask()) !\u003d null) {\n            logger.fine(\"Running the task.. START \");\n            task.run();\n            logger.fine(\"Running the task.. END\");\n        }\n        handshakeStatus \u003d sslEngine.getHandshakeStatus();\n        logger.fine(\"handshakeStatus: \" + handshakeStatus);\n    }\n\n    private void finishInitialHandshake() throws IOException {\n        initialHandshakeStatus \u003d false;\n    }\n\n    public boolean getInitialHandshakeStatus() {\n        return initialHandshakeStatus;\n    }\n\n    public ByteBuffer encrypt(ByteBuffer src) throws IOException {\n        if (initialHandshakeStatus) {\n            logger.fine(\"Writing not possible during handshake!\");\n            //Exception e \u003d new Exception();\n            //e.printStackTrace();\n            return null;\n        }\n        ByteBuffer dest \u003d null;\n        boolean isException \u003d false;\n        try {\n            src.flip();\n            dest \u003d (ByteBuffer) getServer().getByteBufferPool().borrowObject();\n            //dest.clear();\n            SSLEngineResult res \u003d sslEngine.wrap(src, dest);\n            logger.info(\"Wrapping:\\n\" + res);\n            //dest.flip();\n            return dest;\n        } catch (IOException e) {\n            logger.warning(\"IOException:\" + e);\n            isException \u003d true;\n            throw e;\n        } catch (Exception e) {\n            logger.warning(\"Exception:\" + e);\n            isException \u003d true;\n            throw new IOException(e.getMessage());\n        } finally {\n            if (isException \u003d\u003d true \u0026\u0026 dest !\u003d null) {\n                try {\n                    getServer().getByteBufferPool().returnObject(dest);\n                } catch (Exception er) {\n                    logger.warning(\"Error in returning ByteBuffer to pool: \" + er);\n                }\n            }\n        }\n    }\n}\n",
    "package": "org.quickserver.net.server.impl",
    "classname": "NonBlockingClientHandler",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/impl/NonBlockingClientHandler_2Test.java",
    "test_prompt": "// NonBlockingClientHandler_2Test.java\npackage org.quickserver.net.server.impl;\n\nimport org.quickserver.net.server.*;\nimport org.quickserver.net.*;\nimport org.quickserver.util.*;\nimport org.quickserver.util.io.*;\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.net.ssl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonBlockingClientHandler}.\n* It contains ten unit test cases for the {@link NonBlockingClientHandler#getMaxThreadAccessCount()} method.\n*/\nclass NonBlockingClientHandler_2Test {",
    "method_signature": "getMaxThreadAccessCount()",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// QuickServer.java\n/*\n * This file is part of the QuickServer library \n * Copyright (C) QuickServer.org\n *\n * Use, modification, copying and distribution of this software is subject to\n * the terms and conditions of the GNU Lesser General Public License. \n * You should have received a copy of the GNU LGP License along with this \n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\n *\n * For questions, suggestions, bug-reports, enhancement-requests etc.\n * visit http://www.quickserver.org\n *\n */\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n *  Main class of QuickServer library. This class is used to create\n *  multi client servers quickly.\n *  \u003cp\u003e\n *  Ones a client is connected, it creates {@link ClientHandler} object,\n *  which is run using any thread available from the pool of threads\n *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n *  handles the client. \u003cbr/\u003e\n *  QuickServer divides the application logic of its developer over eight\n *  class, \u003cbr\u003e\n *  \t\u003cul\u003e\n * \t\t\u003cli\u003eClientEventHandler\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client events [Optional Class].\n *  \t\t\u003cli\u003eClientCommandHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client character/string commands.\n *  \t\t\u003cli\u003eClientObjectHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - Object commands.\n * \t\t\u003cli\u003eClientBinaryHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - binary data.\n * \t\t\u003cli\u003eClientWriteHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n *  \t\t\u003cli\u003eClientAuthenticationHandler [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Used to Authencatet a client.\n *  \t\t\u003cli\u003eClientData [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Client data carrier (support class)\n * \t\t\u003cli\u003eClientExtendedEventHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles extended client events.\n *  \t\u003c/ul\u003e\n *\n *  [#] \u003d Any one of these have to be set based on default DataMode for input.\n *  The default DataMode for input is String so if not changes you will\n *  have to set ClientCommandHandler.\n *  \u003c/p\u003e\n *  \u003cp\u003e\n *   Eg:\n *  \u003ccode\u003e\u003cBLOCKQUOTE\u003e\u003cpre\u003e\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle \u003d \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer \u003d new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * \u003c/pre\u003e\u003c/BLOCKQUOTE\u003e\u003c/code\u003e\u003c/p\u003e\n *\n *  @version 1.4.8\n *  @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //Some variable are not initialised to any value because the\n    //default java value was desired initial value.\n    //\u0027dev \u0027 \u003d development build not yet final\n    //\u0027beta\u0027 \u003d test build all features\n    //change also in QSAdminMain\n    private final static String VER \u003d \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n        if (System.getProperty(\"org.quickserver.useOSLineSeparator\") !\u003d null \u0026\u0026 System.getProperty(\"org.quickserver.useOSLineSeparator\").equals(\"true\")) {\n            NEW_LINE \u003d System.getProperty(\"line.separator\");\n        } else {\n            NEW_LINE \u003d \"\\r\\n\";\n        }\n        String _pid \u003d ManagementFactory.getRuntimeMXBean().getName();\n        int i \u003d _pid.indexOf(\"@\");\n        pid \u003d _pid.substring(0, i);\n        System.out.print(\"Loading QuickServer v\" + getVersion() + \" [PID:\" + pid + \"]\");\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort \u003d 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName \u003d \"QuickServer\";\n\n    private long maxConnection \u003d -1;\n\n    //1 min socket timeout\n    private int socketTimeout \u003d 60 * 1000;\n\n    private String maxConnectionMsg \u003d \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg \u003d \"-ERR Timeout\";\n\n    private String maxAuthTryMsg \u003d \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry \u003d 5;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //--v1.2\n    //Logger for QuickServer\n    private static final Logger logger \u003d Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //for Service interface\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState \u003d Service.UNKNOWN;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.3\n    private QuickServerConfig config \u003d new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel \u003d \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel \u003d \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation \u003d false;\n\n    private boolean communicationLogging \u003d true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig \u003d config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km \u003d null;\n\n    private TrustManager[] tm \u003d null;\n\n    private boolean runningSecure \u003d false;\n\n    private SecureStoreManager secureStoreManager \u003d null;\n\n    private Exception exceptionInRun \u003d null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode \u003d true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN \u003d DataMode.STRING;\n\n    private DataMode defaultDataModeOUT \u003d DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging \u003d false;\n\n    private int rawCommunicationMaxLength \u003d 100;\n\n    static {\n        System.out.println(\" Done\");\n        //should be commented if not a patch release\n        //System.out.println(\"[Includes patch(#): t\u003d152\u0026p\u003d532]\");\n        //should be commented if not a dev release\n        //System.out.println(\"[Dev Build Date: Saturday, October 29, 2005]\");\n        logger.log(Level.FINE, \"PID: {0}\", pid);\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion() {\n        return VER;\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo() {\n        return getVersionNo(VER);\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver) {\n        //String ver \u003d getVersion();\n        float version \u003d 0;\n        //check if beta\n        int i \u003d ver.indexOf(\" \");\n        if (i \u003d\u003d -1)\n            i \u003d ver.length();\n        ver \u003d ver.substring(0, i);\n        //check for sub version\n        i \u003d ver.indexOf(\".\");\n        if (i !\u003d -1) {\n            int j \u003d ver.indexOf(\".\", i);\n            if (j !\u003d -1) {\n                ver \u003d ver.substring(0, i) + \".\" + MyString.replaceAll(ver.substring(i + 1), \".\", \"\");\n            }\n        }\n        try {\n            version \u003d Float.parseFloat(ver);\n        } catch (NumberFormatException e) {\n            throw new RuntimeException(\"Corrupt QuickServer\");\n        }\n        return version;\n    }\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine() {\n        return NEW_LINE;\n    }\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString() {\n        return serverName + \" : \" + getPort();\n    }\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n        setClientCommandHandler(commandHandler);\n    }\n\n    /**\n     * Creates a new server at \u003ccode\u003eport\u003c/code\u003e with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n        //send to another constructor\n        this(commandHandler);\n        setPort(port);\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException {\n        logger.log(Level.FINE, \"Starting {0}\", getName());\n        if (isClosed() \u003d\u003d false) {\n            logger.log(Level.WARNING, \"Server {0} already running.\", getName());\n            throw new AppException(\"Server \" + getName() + \" already running.\");\n        }\n        blockingMode \u003d getBasicConfig().getServerMode().getBlocking();\n        if (getSecure().isEnable() \u0026\u0026 blockingMode \u003d\u003d false) {\n            //TODO we need to fix this..\n            logger.warning(\"QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode.\");\n            blockingMode \u003d true;\n            getBasicConfig().getServerMode().setBlocking(blockingMode);\n        }\n        if (serverBanner \u003d\u003d null) {\n            serverBanner \u003d \"\\n-------------------------------\" + \"\\n Name : \" + getName() + \"\\n Port : \" + getPort() + \"\\n-------------------------------\\n\";\n            logger.finest(\"Default Server Banner Generated\");\n        }\n        try {\n            loadApplicationClasses();\n            //load class from Advanced Settings\n            Class clientIdentifierClass \u003d getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);\n            clientIdentifier \u003d (ClientIdentifier) clientIdentifierClass.newInstance();\n            clientIdentifier.setQuickServer(QuickServer.this);\n            //load class from ObjectPoolConfig\n            Class poolManagerClass \u003d getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);\n            poolManager \u003d (PoolManager) poolManagerClass.newInstance();\n            //load class QSObjectPoolMaker\n            Class qsObjectPoolMakerClass \u003d getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);\n            qsObjectPoolMaker \u003d (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();\n            loadServerHooksClasses();\n            processServerHooks(ServerHook.PRE_STARTUP);\n            if (getSecure().isLoad() \u003d\u003d true)\n                //v1.4.0\n                loadSSLContext();\n            loadBusinessLogic();\n        } catch (ClassNotFoundException e) {\n            logger.log(Level.SEVERE, \"Could not load class/s: \" + e, e);\n            throw new AppException(\"Could not load class/s : \" + e);\n        } catch (InstantiationException e) {\n            logger.log(Level.SEVERE, \"Could not instantiate class/s: \" + e, e);\n            throw new AppException(\"Could not instantiate class/s: \" + e);\n        } catch (IllegalAccessException e) {\n            logger.log(Level.SEVERE, \"Illegal access to class/s: \" + e, e);\n            throw new AppException(\"Illegal access to class/s: \" + e);\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"IOException: \" + e, e);\n            throw new AppException(\"IOException: \" + e);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Exception: \" + e, e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Exception : \" + e);\n        }\n        //v1.3.3\n        if (getSecurityManagerClass() !\u003d null) {\n            System.setSecurityManager(getSecurityManager());\n        }\n        setServiceState(Service.INIT);\n        t \u003d new Thread(this, \"QuickServer - \" + getName());\n        t.start();\n        do {\n            Thread.yield();\n        } while (getServiceState() \u003d\u003d Service.INIT);\n        if (getServiceState() !\u003d Service.RUNNING) {\n            if (exceptionInRun !\u003d null)\n                throw new AppException(\"Could not start server \" + getName() + \"! Details: \" + exceptionInRun);\n            else\n                throw new AppException(\"Could not start server \" + getName());\n        }\n        lastStartTime \u003d new java.util.Date();\n        logger.log(Level.FINE, \"Started {0}, Date: {1}\", new Object[] { getName(), lastStartTime });\n    }\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException {\n        processServerHooks(ServerHook.PRE_SHUTDOWN);\n        logger.log(Level.WARNING, \"Stopping {0}\", getName());\n        stopServer \u003d true;\n        Socket death \u003d null;\n        if (isClosed() \u003d\u003d true) {\n            logger.log(Level.WARNING, \"Server {0} is not running!\", getName());\n            throw new AppException(\"Server \" + getName() + \" is not running!\");\n        }\n        try {\n            if (getBlockingMode() \u003d\u003d true) {\n                if (getSecure().isEnable() \u003d\u003d false) {\n                    death \u003d new Socket(server.getInetAddress(), server.getLocalPort());\n                    death.getInputStream().read();\n                    death.close();\n                } else {\n                    death \u003d getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());\n                    Thread.sleep(100);\n                    death.close();\n                }\n            }\n            if (serverSocketChannel !\u003d null) {\n                serverSocketChannel.close();\n            }\n        } catch (IOException e) {\n            logger.log(Level.FINE, \"IOError stopping {0}: {1}\", new Object[] { getName(), e });\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error stopping {0}: {1}\", new Object[] { getName(), e });\n            throw new AppException(\"Error in stopServer \" + getName() + \": \" + e);\n        }\n        for (int i \u003d 0; getServiceState() !\u003d Service.STOPPED; i++) {\n            try {\n                Thread.sleep(60);\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error waiting for {0} to fully stop. Error: {1}\", new Object[] { getName(), e });\n            }\n            if (i \u003e 1000) {\n                logger.severe(\"Server was not stopped even after 10sec.. will terminate now.\");\n                System.exit(-1);\n            }\n        }\n        if (adminServer \u003d\u003d null || getQSAdminServer().getServer() !\u003d this) {\n            //so this is not qsadmin\n            setClassLoader(null);\n        }\n        logger.log(Level.INFO, \"Stopped {0}\", getName());\n    }\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException {\n        stopServer();\n        startServer();\n    }\n\n    /**\n     * Returns the name of the QuickServer. Default is \u0027QuickServer\u0027.\n     * @see #setName\n     */\n    public String getName() {\n        return serverName;\n    }\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name) {\n        serverName \u003d name;\n        logger.log(Level.FINEST, \"Set to : {0}\", name);\n    }\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner() {\n        return serverBanner;\n    }\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. \u003cbr\u003e\u0026nbsp;\u003cbr\u003e\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner) {\n        serverBanner \u003d banner;\n        logger.log(Level.FINEST, \"Set to : {0}\", banner);\n    }\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port) {\n        if (port \u003c 0) {\n            throw new IllegalArgumentException(\"Port number can not be less than 0!\");\n        }\n        serverPort \u003d port;\n        logger.log(Level.FINEST, \"Set to {0}\", port);\n    }\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort() {\n        if (isClosed() \u003d\u003d false) {\n            return server.getLocalPort();\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            return serverPort;\n        } else {\n            int _port \u003d getSecure().getPort();\n            if (_port \u003d\u003d -1)\n                return serverPort;\n            else\n                return _port;\n        }\n    }\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler) {\n        clientCommandHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler() {\n        return clientCommandHandlerString;\n    }\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data) {\n        this.clientDataString \u003d data;\n        logger.log(Level.FINEST, \"Set to {0}\", data);\n    }\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData() {\n        return clientDataString;\n    }\n\n    /**\n     * Sets the client socket\u0027s timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time) {\n        if (time \u003e 0)\n            socketTimeout \u003d time;\n        else\n            socketTimeout \u003d 0;\n        logger.log(Level.FINEST, \"Set to {0}\", socketTimeout);\n    }\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout() {\n        return socketTimeout;\n    }\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry) {\n        maxAuthTry \u003d authTry;\n        logger.log(Level.FINEST, \"Set to {0}\", authTry);\n    }\n\n    /**\n     * Returns max allowed login attempts. Default is \u003ccode\u003e5\u003c/code\u003e.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry() {\n        return maxAuthTry;\n    }\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg) {\n        maxAuthTryMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg() {\n        return maxAuthTryMsg;\n    }\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg) {\n        timeoutMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg() {\n        return timeoutMsg;\n    }\n\n    private TheClient initTheClient() {\n        TheClient theClient \u003d new TheClient();\n        theClient.setServer(QuickServer.this);\n        theClient.setTimeoutMsg(getTimeoutMsg());\n        //v1.2\n        theClient.setMaxAuthTry(getMaxAuthTry());\n        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());\n        theClient.setClientEventHandler(clientEventHandler);\n        //v1.4.6\n        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);\n        theClient.setClientCommandHandler(clientCommandHandler);\n        //v1.2\n        theClient.setClientObjectHandler(clientObjectHandler);\n        //v1.4\n        theClient.setClientBinaryHandler(clientBinaryHandler);\n        //v1.4.5\n        theClient.setClientWriteHandler(clientWriteHandler);\n        //v1.3\n        theClient.setAuthenticator(authenticator);\n        //v1.4.6\n        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);\n        theClient.setTimeout(socketTimeout);\n        theClient.setMaxConnectionMsg(maxConnectionMsg);\n        //v1.3.2\n        theClient.setCommunicationLogging(getCommunicationLogging());\n        return theClient;\n    }\n\n    public void run() {\n        exceptionInRun \u003d null;\n        TheClient theClient \u003d initTheClient();\n        try {\n            stopServer \u003d false;\n            closeAllPools();\n            initAllPools();\n            makeServerSocket();\n            //print banner\n            System.out.println(serverBanner);\n            //v1.2\n            setServiceState(Service.RUNNING);\n            //v1.3.3\n            processServerHooks(ServerHook.POST_STARTUP);\n            if (getBlockingMode() \u003d\u003d false) {\n                runNonBlocking(theClient);\n                if (stopServer \u003d\u003d true) {\n                    logger.log(Level.FINEST, \"Closing selector for {0}\", getName());\n                    selector.close();\n                }\n                return;\n            } else {\n                runBlocking(theClient);\n            }\n        } catch (BindException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"{0} BindException for Port {1} @ {2} : {3}\", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });\n        } catch (javax.net.ssl.SSLException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"SSLException {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (IOException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"IOError {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (Exception e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"Error {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } finally {\n            if (getBlockingMode() \u003d\u003d true) {\n                logger.log(Level.WARNING, \"Closing {0}\", getName());\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            } else if (getBlockingMode() \u003d\u003d false \u0026\u0026 exceptionInRun !\u003d null) {\n                logger.log(Level.WARNING, \"Closing {0} - Had Error: {1}\", new Object[] { getName(), exceptionInRun });\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        if (serverSocketChannel !\u003d null)\n                            serverSocketChannel.close();\n                        if (server !\u003d null)\n                            server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n        }\n    }\n\n    //end of run\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnection \u003d maxConnection;\n        else\n            this.maxConnection \u003d maxConnection;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnection);\n    }\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection() {\n        return maxConnection;\n    }\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount() {\n        if (clientHandlerPool !\u003d null) {\n            try {\n                return getClientHandlerPool().getNumActive();\n            } catch (Exception e) {\n                return 0;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : \u003ccode\u003e-ERR Server Busy. Max Connection Reached\u003c/code\u003e\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n        else\n            this.maxConnectionMsg \u003d maxConnectionMsg;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnectionMsg);\n    }\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg() {\n        return maxConnectionMsg;\n    }\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException {\n        ipAddr \u003d InetAddress.getByName(bindAddr);\n        logger.log(Level.FINEST, \"Set to {0}\", bindAddr);\n    }\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr() {\n        if (ipAddr \u003d\u003d null) {\n            try {\n                ipAddr \u003d InetAddress.getByName(\"0.0.0.0\");\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Unable to create default ip(0.0.0.0) : {0}\", e);\n                throw new RuntimeException(\"Error: Unable to find servers own ip : \" + e);\n            }\n        }\n        return ipAddr;\n    }\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects) {\n        this.storeObjects \u003d storeObjects;\n    }\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return \u003ccode\u003enull\u003c/code\u003e.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects() {\n        return storeObjects;\n    }\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port) {\n        getQSAdminServer().getServer().setPort(port);\n    }\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort() {\n        return getQSAdminServer().getServer().getPort();\n    }\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator) {\n        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);\n    }\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator() {\n        return getQSAdminServer().getServer().getAuthenticator();\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException {\n        getQSAdminServer().setClientAuthenticationHandler(authenticator);\n        getQSAdminServer().startServer(port);\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException {\n        getQSAdminServer().startServer();\n    }\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer() {\n        if (adminServer \u003d\u003d null)\n            adminServer \u003d new QSAdminServer(QuickServer.this);\n        return adminServer;\n    }\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer) {\n        if (adminServer \u003d\u003d null)\n            this.adminServer \u003d adminServer;\n    }\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed() {\n        if (server \u003d\u003d null)\n            return true;\n        return server.isClosed();\n    }\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer\u0027s own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger() {\n        if (appLogger !\u003d null)\n            return appLogger;\n        return logger;\n    }\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger) {\n        this.appLogger \u003d appLogger;\n    }\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler) {\n        clientObjectHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler() {\n        return clientObjectHandlerString;\n    }\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n        if (formatter \u003d\u003d null)\n            return;\n        consoleLoggingformatter \u003d formatter;\n        java.util.logging.Formatter conformatter \u003d (java.util.logging.Formatter) getClass(formatter, true).newInstance();\n        Logger jdkLogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d jdkLogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                handlers[index].setFormatter(conformatter);\n            }\n        }\n        logger.log(Level.FINEST, \"Set to {0}\", formatter);\n    }\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter() {\n        return consoleLoggingformatter;\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MiniFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to logging.MiniFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MicroFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to MicroFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        boolean isConsole \u003d true;\n        try {\n            if (System.console() \u003d\u003d null) {\n                isConsole \u003d false;\n            }\n        } catch (Throwable e) {\n            //ignore\n        }\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                if (isConsole \u003d\u003d false \u0026\u0026 level !\u003d Level.OFF) {\n                    System.out.println(\"QuickServer: You do not have a console.. so turning console logger off..\");\n                    level \u003d Level.OFF;\n                }\n                if (level \u003d\u003d Level.OFF) {\n                    logger.info(\"QuickServer: Removing console handler.. \");\n                    rlogger.removeHandler(handlers[index]);\n                    handlers[index].setLevel(level);\n                    handlers[index].close();\n                } else {\n                    handlers[index].setLevel(level);\n                }\n            }\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            consoleLoggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            consoleLoggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            consoleLoggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            consoleLoggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            consoleLoggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            consoleLoggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            consoleLoggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            consoleLoggingLevel \u003d \"OFF\";\n        else\n            consoleLoggingLevel \u003d \"UNKNOWN\";\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel() {\n        return consoleLoggingLevel;\n    }\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            handlers[index].setLevel(level);\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            loggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            loggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            loggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            loggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            loggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            loggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            loggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            loggingLevel \u003d \"OFF\";\n        else\n            loggingLevel \u003d \"UNKNOWN\";\n        consoleLoggingLevel \u003d loggingLevel;\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    //*** Start of Service interface methods\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError() {\n        return serviceError;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param) {\n        serviceError \u003d null;\n        try {\n            initServer(param);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig) {\n        serviceError \u003d null;\n        try {\n            initServer(qsConfig);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING)\n            return false;\n        try {\n            startServer();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.STOPPED)\n            return false;\n        try {\n            stopServer();\n            clearAllPools();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING) {\n            suspendMaxConnection \u003d maxConnection;\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n            maxConnection \u003d 0;\n            maxConnectionMsg \u003d \"Service is suspended.\";\n            setServiceState(Service.SUSPENDED);\n            logger.log(Level.INFO, \"Service {0} is suspended.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.SUSPENDED) {\n            maxConnection \u003d suspendMaxConnection;\n            maxConnectionMsg \u003d suspendMaxConnectionMsg;\n            setServiceState(Service.RUNNING);\n            logger.log(Level.INFO, \"Service {0} resumed.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info() {\n        serviceError \u003d null;\n        StringBuilder buf \u003d new StringBuilder();\n        buf.append(getName()).append(\"\\n\");\n        buf.append(getBindAddr().getHostAddress()).append(\" \");\n        buf.append(getPort()).append(\"\\n\");\n        return buf.toString();\n    }\n\n    // *** End of Service interface methods\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException {\n        QuickServerConfig qsConfig \u003d null;\n        try {\n            qsConfig \u003d ConfigReader.read((String) param[0]);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not init server from xml file {0} : {1}\", new Object[] { new File((String) param[0]).getAbsolutePath(), e });\n            throw new AppException(\"Could not init server from xml file\", e);\n        }\n        initServer(qsConfig);\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {\n        setConfig(qsConfig);\n        try {\n            configQuickServer();\n            loadApplicationClasses();\n            //start InitServerHooks\n            InitServerHooks ish \u003d getConfig().getInitServerHooks();\n            if (ish !\u003d null) {\n                Iterator iterator \u003d ish.iterator();\n                String initServerHookClassName \u003d null;\n                Class initServerHookClass \u003d null;\n                InitServerHook initServerHook \u003d null;\n                while (iterator.hasNext()) {\n                    initServerHookClassName \u003d (String) iterator.next();\n                    initServerHookClass \u003d getClass(initServerHookClassName, true);\n                    initServerHook \u003d (InitServerHook) initServerHookClass.newInstance();\n                    logger.log(Level.INFO, \"Loaded init server hook: {0}\", initServerHookClassName);\n                    logger.log(Level.FINE, \"Init server hook info: {0}\", initServerHook.info());\n                    initServerHook.handleInit(QuickServer.this);\n                }\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not load init server hook: {0}\", e);\n            logger.log(Level.WARNING, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Could not load init server hook\", e);\n        }\n        setServiceState(Service.INIT);\n        logger.log(Level.FINEST, \"\\r\\n{0}\", MyString.getSystemInfo(getVersion()));\n    }\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState() {\n        return serviceState;\n    }\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state) {\n        serviceState \u003d state;\n    }\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp) {\n        if (temp.equals(\"SEVERE\"))\n            qs.setConsoleLoggingLevel(Level.SEVERE);\n        else if (temp.equals(\"WARNING\"))\n            qs.setConsoleLoggingLevel(Level.WARNING);\n        else if (temp.equals(\"INFO\"))\n            qs.setConsoleLoggingLevel(Level.INFO);\n        else if (temp.equals(\"CONFIG\"))\n            qs.setConsoleLoggingLevel(Level.CONFIG);\n        else if (temp.equals(\"FINE\"))\n            qs.setConsoleLoggingLevel(Level.FINE);\n        else if (temp.equals(\"FINER\"))\n            qs.setConsoleLoggingLevel(Level.FINER);\n        else if (temp.equals(\"FINEST\"))\n            qs.setConsoleLoggingLevel(Level.FINEST);\n        else if (temp.equals(\"OFF\"))\n            qs.setConsoleLoggingLevel(Level.OFF);\n        else\n            logger.log(Level.WARNING, \"unknown level {0}\", temp);\n    }\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception {\n        QuickServer qs \u003d QuickServer.this;\n        //v1.3\n        qs.setConfig(config);\n        qs.setBasicConfig(config);\n        String temp \u003d config.getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        temp \u003d null;\n        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        //v1.3.3\n        qs.setSecurityManagerClass(config.getSecurityManagerClass());\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        temp \u003d config.getApplicationJarPath();\n        if (temp !\u003d null) {\n            File ajp \u003d new File(temp);\n            if (ajp.isAbsolute() \u003d\u003d false) {\n                temp \u003d config.getConfigFile();\n                ajp \u003d new File(temp);\n                temp \u003d ajp.getParent() + File.separatorChar + config.getApplicationJarPath();\n                config.setApplicationJarPath(temp);\n                temp \u003d null;\n            }\n            qs.setApplicationJarPath(config.getApplicationJarPath());\n            //set path also to QSAdmin\n            if (config.getQSAdminServerConfig() !\u003d null) {\n                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());\n            }\n        }\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception {\n        QuickServer qs \u003d getQSAdminServer().getServer();\n        qs.setBasicConfig(config);\n        //set the Logging Level to same as main QS\n        //config.getConsoleLoggingLevel();\n        String temp \u003d getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        //set the Logging Formatter to same as main QS\n        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());\n        //v1.4.6\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        //v1.4.6\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());\n        //v1.3.2\n        if (config.getCommandShellEnable().equals(\"true\"))\n            getQSAdminServer().setShellEnable(true);\n        getQSAdminServer().setPromptName(config.getCommandShellPromptName());\n        //v1.3.3\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception {\n        configQuickServer(getConfig());\n        if (getConfig().getQSAdminServerConfig() !\u003d null) {\n            configQuickServer(getConfig().getQSAdminServerConfig());\n        }\n    }\n\n    /**\n     * Usage: QuickServer [-options]\u003cbr/\u003e\n     * Where options include:\u003cbr/\u003e\n     *   -about\t\tOpens About Dialogbox\u003cbr/\u003e\n     *   -load \u003cxml_config_file\u003e [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File \u003cnew_file_name\u003e\n     */\n    public static void main(String[] args) {\n        try {\n            if (args.length \u003e\u003d 1) {\n                if (args[0].equals(\"-about\")) {\n                    org.quickserver.net.server.gui.About.main(null);\n                } else if (args[0].equals(\"-load\") \u0026\u0026 args.length \u003e\u003d 2) {\n                    QuickServer qs \u003d QuickServer.load(args[1]);\n                    if (qs !\u003d null)\n                        handleOptions(args, qs);\n                } else {\n                    System.out.println(printUsage());\n                }\n            } else {\n                System.out.println(printUsage());\n                org.quickserver.net.server.gui.About.showAbout();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException {\n        QuickServer qs \u003d new QuickServer();\n        Object[] config \u003d new Object[] { xml };\n        qs.initServer(config);\n        qs.startServer();\n        if (qs.getConfig().getQSAdminServerConfig() !\u003d null) {\n            qs.startQSAdminServer();\n        }\n        return qs;\n    }\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage() {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"QuickServer - Java library/framework for creating robust multi-client TCP servers.\\n\");\n        sb.append(\"Copyright (C) QuickServer.org\\n\\n\");\n        sb.append(\"Usage: QuickServer [-options]\\n\");\n        sb.append(\"Where options include:\\n\");\n        sb.append(\"  -about\\t\" + \"Opens About Dialog box\\n\");\n        sb.append(\"  -load \u003cxml_config_file\u003e [load-options]\\t\" + \"Loads the server from xml file.\\n\");\n        sb.append(\"  Where load-options include:\\n\");\n        sb.append(\"     -fullXML2File \u003cfile_name\u003e\\t\" + \"Dumps the Full XML configuration of the QuickServer loaded.\\n\");\n        return sb.toString();\n    }\n\n    private static void handleOptions(String[] args, QuickServer quickserver) {\n        if (args.length \u003c 3)\n            return;\n        if (args[2].equals(\"-fullXML2File\") \u0026\u0026 args.length \u003e\u003d 4) {\n            File file \u003d new File(args[3]);\n            logger.log(Level.INFO, \"Writing full xml configuration to file: {0}\", file.getAbsolutePath());\n            try {\n                TextFile.write(file, quickserver.getConfig().toXML(null));\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error writing full xml configuration: {0}\", e);\n            }\n        }\n    }\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception {\n        try {\n            if (pool !\u003d null)\n                getClientPool().clear();\n            if (clientHandlerPool !\u003d null)\n                getClientHandlerPool().clear();\n            if (getClientDataPool() !\u003d null)\n                getClientDataPool().clear();\n            if (getDBPoolUtil() !\u003d null)\n                getDBPoolUtil().clean();\n            if (byteBufferPool !\u003d null)\n                getByteBufferPool().clear();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error: {0}\", e);\n            throw e;\n        }\n    }\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception {\n        if (pool \u003d\u003d null \u0026\u0026 clientHandlerPool \u003d\u003d null \u0026\u0026 getClientDataPool() \u003d\u003d null \u0026\u0026 getDBPoolUtil() \u003d\u003d null \u0026\u0026 byteBufferPool \u003d\u003d null) {\n            return;\n        }\n        logger.log(Level.FINE, \"Closing pools for {0}\", getName());\n        try {\n            if (pool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {\n                logger.finer(\"Closing ClientThread pool.\");\n                getClientPool().close();\n            }\n            if (clientHandlerPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientHandlerPool())) {\n                logger.finer(\"Closing ClientHandler pool.\");\n                getClientHandlerPool().close();\n            }\n            if (getClientDataPool() !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientDataPool())) {\n                logger.finer(\"Closing ClientData pool.\");\n                getClientDataPool().close();\n            }\n            if (getDBPoolUtil() !\u003d null) {\n                logger.finer(\"Closing DB pool.\");\n                getDBPoolUtil().clean();\n            }\n            if (byteBufferPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getByteBufferPool())) {\n                logger.finer(\"Closing ByteBuffer pool.\");\n                getByteBufferPool().close();\n            }\n            logger.log(Level.FINE, \"Closed pools for {0}\", getName());\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error closing pools for {0}: {1}\", new Object[] { getName(), e });\n            throw e;\n        }\n    }\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception {\n        logger.fine(\"Creating pools\");\n        if (getBlockingMode() \u003d\u003d false) {\n            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());\n        }\n        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());\n        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());\n        //check if client data is poolable\n        if (clientDataClass !\u003d null) {\n            try {\n                clientData \u003d (ClientData) clientDataClass.newInstance();\n                if (PoolableObject.class.isInstance(clientData) \u003d\u003d true) {\n                    PoolableObject po \u003d (PoolableObject) clientData;\n                    if (po.isPoolable() \u003d\u003d true) {\n                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());\n                    } else {\n                        clientDataPool \u003d null;\n                        logger.fine(\"ClientData is not poolable!\");\n                    }\n                }\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error: {0}\", e);\n                throw e;\n            }\n        }\n        try {\n            makeDBObjectPool();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error in makeDBObjectPool() : {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw e;\n        }\n        logger.fine(\"Created pools\");\n    }\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool() {\n        if (pool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientPool available yet!\");\n        return pool;\n    }\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientHandler pool\");\n        PoolableObjectFactory factory \u003d new ClientHandlerObjectFactory(getBlockingMode());\n        clientHandlerPool \u003d poolManager.makeClientHandlerPool(factory, opConfig);\n        poolManager.initPool(clientHandlerPool, opConfig);\n        clientHandlerPool \u003d makeQSObjectPool(clientHandlerPool);\n        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool() {\n        if (clientHandlerPool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientHandler Pool available yet!\");\n        return clientHandlerPool;\n    }\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config) {\n        this.config \u003d config;\n    }\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig() {\n        return config;\n    }\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientData pool\");\n        clientDataPool \u003d poolManager.makeClientDataPool(factory, opConfig);\n        poolManager.initPool(clientDataPool, opConfig);\n        clientDataPool \u003d makeQSObjectPool(clientDataPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool() {\n        return clientDataPool;\n    }\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return \u003ccode\u003enull\u003c/code\u003e\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil() {\n        return dBPoolUtil;\n    }\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {\n        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);\n    }\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception {\n        if (getConfig().getDBObjectPoolConfig() !\u003d null) {\n            logger.fine(\"Creating DBObject Pool\");\n            //logger.finest(\"Got:\\n\"+getConfig().getDBObjectPoolConfig().toXML(null));\n            Class dbPoolUtilClass \u003d getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);\n            dBPoolUtil \u003d (DBPoolUtil) dbPoolUtilClass.newInstance();\n            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());\n            dBPoolUtil.initPool();\n        }\n    }\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id) {\n        return clientIdentifier.findFirstClientById(id);\n    }\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  \u003ccode\u003e\u003cpre\u003e\n     *    Eg:\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tObject syncObj \u003d quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator \u003d quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tClientIdentifier clientIdentifier \u003d quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator \u003d clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    \u003c/code\u003e\u003c/pre\u003e\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient() {\n        return clientIdentifier.findAllClient();\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern) {\n        return clientIdentifier.findAllClientById(pattern);\n    }\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key) {\n        return clientIdentifier.findClientByKey(key);\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern) {\n        return clientIdentifier.findAllClientByKey(pattern);\n    }\n\n    /**\n     * Sets next client has a trusted client.\n     * \u003cp\u003eThis will skip any authentication and will not set any timeout.\u003c/p\u003e\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted() {\n        setSkipValidation(true);\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation() {\n        return skipValidation;\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation) {\n        skipValidation \u003d validation;\n    }\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging) {\n        this.communicationLogging \u003d communicationLogging;\n    }\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging() {\n        return communicationLogging;\n    }\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass) {\n        if (securityManagerClass !\u003d null)\n            this.securityManagerClass \u003d securityManagerClass;\n    }\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass() {\n        return securityManagerClass;\n    }\n\n    public SecurityManager getSecurityManager() throws AppException {\n        if (getSecurityManagerClass() \u003d\u003d null)\n            return null;\n        SecurityManager sm \u003d null;\n        try {\n            sm \u003d (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();\n        } catch (ClassNotFoundException e) {\n            throw new AppException(e.getMessage());\n        } catch (InstantiationException e) {\n            throw new AppException(e.getMessage());\n        } catch (IllegalAccessException e) {\n            throw new AppException(e.getMessage());\n        }\n        return sm;\n    }\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {\n        this.accessConstraintConfig \u003d accessConstraintConfig;\n    }\n\n    /**\n     * Returns Access constraints if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig() {\n        return accessConstraintConfig;\n    }\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader) {\n        this.classLoader \u003d classLoader;\n        Thread.currentThread().setContextClassLoader(classLoader);\n    }\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader() {\n        return classLoader;\n    }\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException {\n        if (name \u003d\u003d null)\n            throw new IllegalArgumentException(\"Class name can\u0027t be null!\");\n        logger.log(Level.FINEST, \"Class: {0}, reload: {1}\", new Object[] { name, reload });\n        if (reload \u003d\u003d true \u0026\u0026 classLoader !\u003d null) {\n            return classLoader.loadClass(name);\n        } else if (reload \u003d\u003d true \u0026\u0026 classLoader \u003d\u003d null \u0026\u0026 this.getClass().getClassLoader() !\u003d null) {\n            return this.getClass().getClassLoader().loadClass(name);\n        } else if (reload \u003d\u003d false \u0026\u0026 classLoader !\u003d null) {\n            return Class.forName(name, true, classLoader);\n        } else /*if(reload\u003d\u003dfalse \u0026\u0026 classLoader\u003d\u003dnull)*/\n        {\n            return Class.forName(name, true, this.getClass().getClassLoader());\n        }\n    }\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath) {\n        this.applicationJarPath \u003d applicationJarPath;\n    }\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath() {\n        return applicationJarPath;\n    }\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks) {\n        this.serverHooks \u003d serverHooks;\n    }\n\n    /**\n     * Returns ServerHooks if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks() {\n        if (serverHooks \u003d\u003d null)\n            serverHooks \u003d new ServerHooks();\n        return serverHooks;\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses() {\n        if (getServerHooks() \u003d\u003d null)\n            return;\n        listOfServerHooks \u003d new ArrayList();\n        ServerHook serverHook \u003d null;\n        String serverHookClassName \u003d null;\n        Class serverHookClass \u003d null;\n        //add system hooks\n        serverHook \u003d new GhostSocketReaper();\n        serverHook.initHook(QuickServer.this);\n        listOfServerHooks.add(serverHook);\n        ghostSocketReaper \u003d (GhostSocketReaper) serverHook;\n        //add user hooks if any\n        Iterator iterator \u003d getServerHooks().iterator();\n        while (iterator.hasNext()) {\n            serverHookClassName \u003d (String) iterator.next();\n            try {\n                serverHookClass \u003d getClass(serverHookClassName, true);\n                serverHook \u003d (ServerHook) serverHookClass.newInstance();\n                serverHook.initHook(QuickServer.this);\n                listOfServerHooks.add(serverHook);\n                logger.log(Level.INFO, \"Loaded server hook: {0}\", serverHookClassName);\n                logger.log(Level.FINE, \"Server hook info: {0}\", serverHook.info());\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Could not load server hook [{0}]: {1}\", new Object[] { serverHookClassName, e });\n                logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            }\n        }\n        //end of while\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event) {\n        if (listOfServerHooks \u003d\u003d null) {\n            logger.warning(\"listOfServerHooks was null!\");\n            return;\n        }\n        ServerHook serverHook \u003d null;\n        boolean result \u003d false;\n        Iterator iterator \u003d listOfServerHooks.iterator();\n        String hooktype \u003d \"UNKNOWN\";\n        switch(event) {\n            case ServerHook.PRE_STARTUP:\n                hooktype \u003d \"PRE_STARTUP\";\n                break;\n            case ServerHook.POST_STARTUP:\n                hooktype \u003d \"POST_STARTUP\";\n                break;\n            case ServerHook.PRE_SHUTDOWN:\n                hooktype \u003d \"PRE_SHUTDOWN\";\n                break;\n            case ServerHook.POST_SHUTDOWN:\n                hooktype \u003d \"POST_SHUTDOWN\";\n                break;\n        }\n        while (iterator.hasNext()) {\n            serverHook \u003d (ServerHook) iterator.next();\n            try {\n                result \u003d serverHook.handleEvent(event);\n            } catch (Exception e) {\n                result \u003d false;\n                logger.log(Level.WARNING, \"Error invoking {0} hook [{1}]: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });\n            }\n            logger.log(Level.FINE, \"Invoked {0} hook [{1}] was: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), result });\n        }\n    }\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone() {\n        Object object \u003d null;\n        try {\n            object \u003d super.clone();\n            QuickServer _qs \u003d (QuickServer) object;\n            _qs.setQSAdminServer(new QSAdminServer(_qs));\n        } catch (CloneNotSupportedException e) {\n            //should not happ\n            logger.log(Level.WARNING, \"Error cloning : {0}\", e);\n        }\n        return object;\n    }\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure) {\n        this.secure \u003d secure;\n    }\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure() {\n        if (secure \u003d\u003d null)\n            secure \u003d new Secure();\n        return secure;\n    }\n\n    /**\n     * \u003cp\u003eReturns if the server is running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure() {\n        return runningSecure;\n    }\n\n    /**\n     * \u003cp\u003eSets the server mode if its running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure) {\n        this.runningSecure \u003d runningSecure;\n    }\n\n    private File makeAbsoluteToConfig(String fileName) {\n        Assertion.affirm(fileName !\u003d null, \"FileName can\u0027t be null\");\n        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());\n    }\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException {\n        server \u003d null;\n        logger.log(Level.FINEST, \"Binding {0} to IP: {1}\", new Object[] { getName(), getBindAddr() });\n        InetSocketAddress bindAddress \u003d new InetSocketAddress(getBindAddr(), getPort());\n        try {\n            NetworkInterface ni \u003d NetworkInterface.getByInetAddress(getBindAddr());\n            if (ni !\u003d null) {\n                logger.fine(\"NetworkInterface: \" + ni);\n            }\n        } catch (Exception igrnore) {\n            /*ignore*/\n        } catch (Error igrnore) {\n            /*ignore*/\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Making a normal ServerSocket for {0}\", getName());\n            setRunningSecure(false);\n            if (getBlockingMode() \u003d\u003d false) {\n                //for non-blocking\n                serverSocketChannel \u003d ServerSocketChannel.open();\n                server \u003d serverSocketChannel.socket();\n                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n            } else {\n                //for blocking\n                server \u003d new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n            }\n        } else {\n            try {\n                logger.log(Level.FINE, \"Making a secure ServerSocket for {0}\", getName());\n                getSSLContext();\n                setRunningSecure(true);\n                if (getBlockingMode() \u003d\u003d false) {\n                    logger.log(Level.FINE, \"Making a secure ServerSocketChannel for {0}\", getName());\n                    //for non-blocking\n                    serverSocketChannel \u003d ServerSocketChannel.open();\n                    server \u003d serverSocketChannel.socket();\n                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n                } else {\n                    ServerSocketFactory ssf \u003d getSSLContext().getServerSocketFactory();\n                    SSLServerSocket serversocket \u003d (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());\n                    setRunningSecure(true);\n                    secureStoreManager.logSSLServerSocketInfo(serversocket);\n                    server \u003d serversocket;\n                    serverSocketChannel \u003d server.getChannel();\n                    if (serverSocketChannel \u003d\u003d null \u0026\u0026 getBlockingMode() \u003d\u003d false) {\n                        logger.warning(\"Secure Server does not support Channel! So will run in blocking mode.\");\n                        blockingMode \u003d false;\n                    }\n                }\n                //blocking\n            } catch (NoSuchAlgorithmException e) {\n                logger.log(Level.WARNING, \"NoSuchAlgorithmException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            } catch (KeyManagementException e) {\n                logger.log(Level.WARNING, \"KeyManagementException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            }\n        }\n        server.setReuseAddress(true);\n        int connectionTime \u003d 0;\n        int latency \u003d 0;\n        int bandwidth \u003d 0;\n        connectionTime \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();\n        latency \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();\n        bandwidth \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();\n        logger.log(Level.FINE, \"getPerformancePreferencesConnectionTime : {0}\", connectionTime);\n        logger.log(Level.FINE, \"getPerformancePreferencesLatency : {0}\", latency);\n        logger.log(Level.FINE, \"getPerformancePreferencesBandwidth : {0}\", bandwidth);\n        server.setPerformancePreferences(connectionTime, latency, bandwidth);\n        int clientSocketReceiveBufferSize \u003d getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();\n        if (clientSocketReceiveBufferSize \u003e 0) {\n            logger.log(Level.FINE, \"clientSocketReceiveBufferSize: {0}\", clientSocketReceiveBufferSize);\n            server.setReceiveBufferSize(clientSocketReceiveBufferSize);\n        }\n        if (getBlockingMode() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Server Mode {0} - Non Blocking\", getName());\n            if (selector \u003d\u003d null || selector.isOpen() \u003d\u003d false) {\n                logger.finest(\"Opening new selector\");\n                selector \u003d Selector.open();\n            } else {\n                logger.log(Level.FINEST, \"Reusing selector: {0}\", selector);\n            }\n            serverSocketChannel.configureBlocking(false);\n            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n            selector.wakeup();\n        } else {\n            logger.log(Level.FINE, \"Server Mode {0} - Blocking\", getName());\n        }\n    }\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {\n        Assertion.affirm(basicConfig !\u003d null, \"BasicServerConfig can\u0027t be null\");\n        this.basicConfig \u003d basicConfig;\n    }\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig() {\n        return basicConfig;\n    }\n\n    /**\n     * Loads the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException {\n        if (getSecure().isLoad() \u003d\u003d false) {\n            throw new IllegalStateException(\"Secure setting is not yet enabled for loading!\");\n        }\n        logger.info(\"Loading Secure Context..\");\n        km \u003d null;\n        tm \u003d null;\n        try {\n            String ssManager \u003d \"org.quickserver.security.SecureStoreManager\";\n            if (getSecure().getSecureStore() !\u003d null)\n                ssManager \u003d getSecure().getSecureStore().getSecureStoreManager();\n            Class secureStoreManagerClass \u003d getClass(ssManager, true);\n            secureStoreManager \u003d (SecureStoreManager) secureStoreManagerClass.newInstance();\n            km \u003d secureStoreManager.loadKeyManagers(getConfig());\n            logger.fine(\"KeyManager got\");\n            tm \u003d secureStoreManager.loadTrustManagers(getConfig());\n            logger.fine(\"TrustManager got\");\n            sslc \u003d secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());\n            sslc.init(km, tm, null);\n            logger.fine(\"SSLContext loaded\");\n        } catch (KeyStoreException e) {\n            logger.warning(\"KeyStoreException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchAlgorithmException e) {\n            logger.warning(\"NoSuchAlgorithmException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchProviderException e) {\n            logger.warning(\"NoSuchProviderException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (UnrecoverableKeyException e) {\n            logger.warning(\"UnrecoverableKeyException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (CertificateException e) {\n            logger.warning(\"CertificateException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (KeyManagementException e) {\n            logger.warning(\"KeyManagementException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (GeneralSecurityException e) {\n            logger.warning(\"GeneralSecurityException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (ClassNotFoundException e) {\n            logger.warning(\"ClassNotFoundException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (InstantiationException e) {\n            logger.warning(\"InstantiationException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (IllegalAccessException e) {\n            logger.warning(\"IllegalAccessException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        return getSSLContext(null);\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        if (protocol !\u003d null \u0026\u0026 secureStoreManager !\u003d null) {\n            SSLContext _sslc \u003d secureStoreManager.getSSLContext(protocol);\n            _sslc.init(km, tm, null);\n            return _sslc;\n        }\n        return sslc;\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext());\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext(protocol));\n    }\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler) {\n        clientBinaryHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler() {\n        return clientBinaryHandlerString;\n    }\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector) {\n        this.selector \u003d selector;\n    }\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector() {\n        return selector;\n    }\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception {\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        //long stime \u003d System.currentTimeMillis();\n        //long etime \u003d System.currentTimeMillis();\n        while (true) {\n            //etime \u003d System.currentTimeMillis();\n            //System.out.println(\"Time Taken: \"+(etime-stime));\n            client \u003d server.accept();\n            //stime \u003d System.currentTimeMillis();\n            if (linger \u003c 0) {\n                client.setSoLinger(false, 0);\n            } else {\n                client.setSoLinger(true, linger);\n            }\n            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                //low delay\u003d10\n                client.setTrafficClass(socketTrafficClass);\n            }\n            logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n            }\n            if (stopServer) {\n                //Client connected when server was about to be shutdown.\n                try {\n                    client.close();\n                } catch (Exception e) {\n                }\n                break;\n            }\n            if (checkAccessConstraint(client) \u003d\u003d false) {\n                continue;\n            }\n            //Check if max connection has reached\n            if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);\n            } else {\n                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);\n            }\n            theClient.setTrusted(getSkipValidation());\n            theClient.setSocket(client);\n            //mostly null\n            theClient.setSocketChannel(client.getChannel());\n            if (clientDataClass !\u003d null) {\n                if (getClientDataPool() \u003d\u003d null) {\n                    clientData \u003d (ClientData) clientDataClass.newInstance();\n                } else {\n                    clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                }\n                theClient.setClientData(clientData);\n            }\n            try {\n                _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                _chPolled.handleClient(theClient);\n            } catch (java.util.NoSuchElementException nsee) {\n                logger.warning(\"Could not borrow ClientHandler from pool. Error: \" + nsee);\n                logger.warning(\"Closing Socket [\" + client + \"] since no ClientHandler available.\");\n                client.close();\n            }\n            if (_chPolled !\u003d null) {\n                try {\n                    getClientPool().addClient(_chPolled, true);\n                } catch (java.util.NoSuchElementException nsee) {\n                    logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                    //logger.warning(\"Closing Socket [\"+client+\"] since no Thread available.\");\n                    //client.close();\n                    //returnClientHandlerToPool(_chPolled);\n                }\n                _chPolled \u003d null;\n            }\n            client \u003d null;\n            //reset it back\n            setSkipValidation(false);\n        }\n        //end of loop\n    }\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception {\n        int selectCount \u003d 0;\n        Iterator iterator \u003d null;\n        SelectionKey key \u003d null;\n        ServerSocketChannel serverChannel \u003d null;\n        SocketChannel socketChannel \u003d null;\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        boolean stopServerProcessed \u003d false;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        registerChannelRequestMap \u003d new HashMap();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        while (true) {\n            selectCount \u003d selector.select(500);\n            //selectCount \u003d selector.select();//for testing\n            //check for any pending registerChannel req.\n            synchronized (registerChannelRequestMap) {\n                if (registerChannelRequestMap.size() \u003e 0) {\n                    RegisterChannelRequest req \u003d null;\n                    Object hashkey \u003d null;\n                    iterator \u003d registerChannelRequestMap.keySet().iterator();\n                    while (iterator.hasNext()) {\n                        hashkey \u003d iterator.next();\n                        req \u003d (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);\n                        req.register(getSelector());\n                    }\n                    iterator \u003d null;\n                    registerChannelRequestMap.clear();\n                }\n                //if\n            }\n            //sync\n            if (stopServer \u003d\u003d true \u0026\u0026 stopServerProcessed \u003d\u003d false) {\n                logger.warning(\"Closing \" + getName());\n                serverSocketChannel.close();\n                stopServerProcessed \u003d true;\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.warning(\"Closed \" + getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n            if (stopServer \u003d\u003d false \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                logger.finest(\"Server must have re-started.. will break\");\n                break;\n            }\n            if (selectCount \u003d\u003d 0 \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                java.util.Set keyset \u003d selector.keys();\n                if (keyset.isEmpty() \u003d\u003d true \u0026\u0026 getClientCount() \u003c\u003d 0) {\n                    break;\n                } else {\n                    continue;\n                }\n            } else if (selectCount \u003d\u003d 0) {\n                continue;\n            }\n            iterator \u003d selector.selectedKeys().iterator();\n            while (iterator.hasNext()) {\n                key \u003d (SelectionKey) iterator.next();\n                if (key.isValid() \u003d\u003d false) {\n                    iterator.remove();\n                    continue;\n                }\n                if (key.isAcceptable() \u0026\u0026 stopServer \u003d\u003d false) {\n                    logger.finest(\"Key is Acceptable\");\n                    serverChannel \u003d (ServerSocketChannel) key.channel();\n                    socketChannel \u003d serverChannel.accept();\n                    if (socketChannel \u003d\u003d null) {\n                        iterator.remove();\n                        continue;\n                    }\n                    client \u003d socketChannel.socket();\n                    if (linger \u003c 0) {\n                        client.setSoLinger(false, 0);\n                    } else {\n                        client.setSoLinger(true, linger);\n                    }\n                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                        //low delay\u003d10\n                        client.setTrafficClass(socketTrafficClass);\n                    }\n                    logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                        logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n                    }\n                    if (checkAccessConstraint(client) \u003d\u003d false) {\n                        iterator.remove();\n                        continue;\n                    }\n                    socketChannel.configureBlocking(false);\n                    theClient.setTrusted(getSkipValidation());\n                    theClient.setSocket(socketChannel.socket());\n                    theClient.setSocketChannel(socketChannel);\n                    if (clientDataClass !\u003d null) {\n                        if (getClientDataPool() \u003d\u003d null) {\n                            clientData \u003d (ClientData) clientDataClass.newInstance();\n                        } else {\n                            //borrow a object from pool\n                            clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                        }\n                        theClient.setClientData(clientData);\n                    }\n                    //Check if max connection has reached\n                    if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                        theClient.setClientEvent(ClientEvent.MAX_CON);\n                    } else {\n                        theClient.setClientEvent(ClientEvent.ACCEPT);\n                    }\n                    try {\n                        _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                        logger.finest(\"Asking \" + _chPolled.getName() + \" to handle.\");\n                        _chPolled.handleClient(theClient);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.warning(\"Could not borrow ClientHandler Object from pool. Error: \" + nsee);\n                        logger.warning(\"Closing SocketChannel [\" + serverChannel.socket() + \"] since no ClientHandler available.\");\n                        socketChannel.close();\n                    }\n                    if (_chPolled !\u003d null) {\n                        try {\n                            getClientPool().addClient(_chPolled, true);\n                        } catch (java.util.NoSuchElementException nsee) {\n                            logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                            //logger.warning(\"Closing SocketChannel [\"+serverChannel.socket()+\"] since no Thread available.\");\n                            //socketChannel.close();\n                            //returnClientHandlerToPool(_chPolled);\n                        }\n                        _chPolled \u003d null;\n                    }\n                    socketChannel \u003d null;\n                    client \u003d null;\n                    //reset it back\n                    setSkipValidation(false);\n                } else if (key.isValid() \u0026\u0026 key.isReadable()) {\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Readable, removing OP_READ from interestOps for \" + _ch.getName());\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_READ));\n                        _ch.addEvent(ClientEvent.READ);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.READ);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (key.isValid() \u0026\u0026 key.isWritable()) {\n                    if (getClientPool().shouldNioWriteHappen() \u003d\u003d false) {\n                        //no need to remove the key\n                        continue;\n                    }\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Writable, removing OP_WRITE from interestOps for \" + _ch.getName());\n                        //remove OP_WRITE from interest set\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_WRITE));\n                        _ch.addEvent(ClientEvent.WRITE);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.WRITE);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (stopServer \u003d\u003d true \u0026\u0026 key.isAcceptable()) {\n                    //we will not accept this key\n                    //reset it back\n                    setSkipValidation(false);\n                } else {\n                    logger.warning(\"Unknown key got in SelectionKey: \" + key);\n                }\n                //Remove key\n                iterator.remove();\n                Thread.yield();\n            }\n            //end of iterator\n            iterator \u003d null;\n        }\n        //end of loop\n    }\n\n    private boolean checkAccessConstraint(Socket socket) {\n        try {\n            if (getAccessConstraintConfig() !\u003d null) {\n                getAccessConstraintConfig().checkAccept(socket);\n            }\n            return true;\n        } catch (SecurityException se) {\n            logger.warning(\"SecurityException occurred accepting connection : \" + se.getMessage());\n            return false;\n        }\n    }\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {\n        if (getSelector() \u003d\u003d null) {\n            throw new IllegalStateException(\"Selector is not open!\");\n        }\n        if (channel \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Can\u0027t register a null channel!\");\n        }\n        if (channel.isConnected() \u003d\u003d false) {\n            throw new ClosedChannelException();\n        }\n        RegisterChannelRequest req \u003d new RegisterChannelRequest(channel, ops, att);\n        RegisterChannelRequest reqOld \u003d null;\n        synchronized (registerChannelRequestMap) {\n            reqOld \u003d (RegisterChannelRequest) registerChannelRequestMap.get(channel);\n            if (reqOld \u003d\u003d null) {\n                registerChannelRequestMap.put(channel, req);\n                getSelector().wakeup();\n                return true;\n            } else {\n                if (reqOld.equals(req) \u003d\u003d false) {\n                    reqOld.setOps(reqOld.getOps() | req.getOps());\n                    reqOld.setAtt(req.getAtt());\n                    return true;\n                }\n                return false;\n            }\n        }\n        /*\n\t\tlogger.warning(\"Before register...\");\n\t\tchannel.register(getSelector(), ops, att);\n\t\tlogger.warning(\"Before wakeup and after register...\");\n\t\tgetSelector().wakeup();\n\t\tlogger.warning(\"After wakeup...\");\n\t\t*/\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig) {\n        logger.finer(\"Creating ByteBufferPool pool\");\n        int bufferSize \u003d getBasicConfig().getAdvancedSettings().getByteBufferSize();\n        boolean useDirectByteBuffer \u003d getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();\n        PoolableObjectFactory factory \u003d new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);\n        byteBufferPool \u003d poolManager.makeByteBufferPool(factory, opConfig);\n        poolManager.initPool(byteBufferPool, opConfig);\n    }\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool() {\n        return byteBufferPool;\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientThread pool\");\n        ThreadObjectFactory factory \u003d new ThreadObjectFactory();\n        ObjectPool objectPool \u003d poolManager.makeClientPool(factory, opConfig);\n        pool \u003d new ClientPool(makeQSObjectPool(objectPool), opConfig);\n        factory.setClientPool(pool);\n        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());\n        poolManager.initPool(objectPool, opConfig);\n    }\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler) {\n        clientWriteHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler() {\n        return clientWriteHandlerString;\n    }\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be \u003ccode\u003enull\u003c/code\u003e if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime() {\n        return lastStartTime;\n    }\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag) {\n        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);\n        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);\n    }\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier() {\n        return clientIdentifier;\n    }\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {\n        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);\n    }\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode() {\n        return blockingMode;\n    }\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception {\n        if (clientCommandHandlerString \u003d\u003d null \u0026\u0026 clientEventHandlerString \u003d\u003d null) {\n            logger.severe(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n            throw new AppException(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n        }\n        clientCommandHandler \u003d null;\n        if (clientCommandHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientCommandHandler class..\");\n            Class clientCommandHandlerClass \u003d getClass(clientCommandHandlerString, true);\n            clientCommandHandler \u003d (ClientCommandHandler) clientCommandHandlerClass.newInstance();\n        }\n        boolean setClientCommandHandlerLookup \u003d false;\n        clientEventHandler \u003d null;\n        if (clientEventHandlerString \u003d\u003d null) {\n            clientEventHandlerString \u003d \"org.quickserver.net.server.impl.DefaultClientEventHandler\";\n            setClientCommandHandlerLookup \u003d true;\n        }\n        logger.finest(\"Loading ClientEventHandler class..\");\n        if (clientEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientEventHandler.class.isInstance(clientCommandHandler)) {\n            clientEventHandler \u003d (ClientEventHandler) clientCommandHandler;\n        } else {\n            clientEventHandler \u003d (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();\n            if (setClientCommandHandlerLookup) {\n                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);\n            }\n        }\n        clientExtendedEventHandler \u003d null;\n        if (clientExtendedEventHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientExtendedEventHandler class..\");\n            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientCommandHandler;\n            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientEventHandler;\n            } else {\n                Class clientExtendedEventHandlerClass \u003d getClass(clientExtendedEventHandlerString, true);\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();\n            }\n        }\n        clientObjectHandler \u003d null;\n        if (clientObjectHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientObjectHandler class..\");\n            if (clientObjectHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientCommandHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientCommandHandler;\n            } else if (clientObjectHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientEventHandler;\n            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientExtendedEventHandler;\n            } else {\n                clientObjectHandler \u003d (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientBinaryHandler \u003d null;\n        if (clientBinaryHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientBinaryHandler class..\");\n            if (clientBinaryHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientCommandHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientCommandHandler;\n            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientExtendedEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientObjectHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientObjectHandler;\n            } else {\n                clientBinaryHandler \u003d (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientWriteHandler \u003d null;\n        if (clientWriteHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientWriteHandler class..\");\n            if (clientWriteHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientCommandHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientCommandHandler;\n            } else if (clientWriteHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientEventHandler;\n            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientExtendedEventHandler;\n            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientObjectHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientObjectHandler;\n            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientBinaryHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientBinaryHandler;\n            } else {\n                clientWriteHandler \u003d (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        Class authenticatorClass \u003d null;\n        if (clientAuthenticationHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientAuthenticationHandler class..\");\n            authenticatorClass \u003d getClass(clientAuthenticationHandlerString, true);\n        }\n        if (authenticatorClass !\u003d null) {\n            Object obj \u003d authenticatorClass.newInstance();\n            if (ClientAuthenticationHandler.class.isInstance(obj))\n                clientAuthenticationHandler \u003d (ClientAuthenticationHandler) obj;\n            else\n                authenticator \u003d (Authenticator) obj;\n        }\n        clientDataClass \u003d null;\n        if (clientDataString !\u003d null) {\n            logger.finest(\"Loading ClientData class..\");\n            clientDataClass \u003d getClass(clientDataString, true);\n        }\n        Assertion.affirm(clientEventHandler !\u003d null, \"ClientEventHandler was not loaded!\");\n    }\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler) {\n        clientEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler() {\n        return clientEventHandlerString;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {\n        if (dataType \u003d\u003d DataType.IN)\n            this.defaultDataModeIN \u003d dataMode;\n        if (dataType \u003d\u003d DataType.OUT)\n            this.defaultDataModeOUT \u003d dataMode;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {\n        defaultDataModeIN \u003d defaultDataMode.getDataMode(DataType.IN);\n        defaultDataModeOUT \u003d defaultDataMode.getDataMode(DataType.OUT);\n        ;\n    }\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType) {\n        if (dataType \u003d\u003d DataType.IN)\n            return defaultDataModeIN;\n        if (dataType \u003d\u003d DataType.OUT)\n            return defaultDataModeOUT;\n        else\n            throw new IllegalArgumentException(\"Unknown DataType: \" + dataType);\n    }\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler) {\n        clientExtendedEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler() {\n        return clientExtendedEventHandlerString;\n    }\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception {\n        if (getApplicationJarPath() !\u003d null \u0026\u0026 getClassLoader() \u003d\u003d null) {\n            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));\n            //update qsadmin to use the same\n            if (adminServer !\u003d null) {\n                adminServer.getServer().setClassLoader(getClassLoader());\n            }\n        }\n    }\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID() {\n        return pid;\n    }\n\n    public boolean isRawCommunicationLogging() {\n        return rawCommunicationLogging;\n    }\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {\n        this.rawCommunicationLogging \u003d rawCommunicationLogging;\n    }\n\n    public int getRawCommunicationMaxLength() {\n        return rawCommunicationMaxLength;\n    }\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {\n        this.rawCommunicationMaxLength \u003d rawCommunicationMaxLength;\n    }\n}\n",
    "package": "org.quickserver.net.server",
    "classname": "QuickServer",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_0Test.java",
    "test_prompt": "// QuickServer_0Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#getVersion()} method.\n*/\nclass QuickServer_0Test {",
    "method_signature": "getVersion()",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// QuickServer.java\n/*\n * This file is part of the QuickServer library \n * Copyright (C) QuickServer.org\n *\n * Use, modification, copying and distribution of this software is subject to\n * the terms and conditions of the GNU Lesser General Public License. \n * You should have received a copy of the GNU LGP License along with this \n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\n *\n * For questions, suggestions, bug-reports, enhancement-requests etc.\n * visit http://www.quickserver.org\n *\n */\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n *  Main class of QuickServer library. This class is used to create\n *  multi client servers quickly.\n *  \u003cp\u003e\n *  Ones a client is connected, it creates {@link ClientHandler} object,\n *  which is run using any thread available from the pool of threads\n *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n *  handles the client. \u003cbr/\u003e\n *  QuickServer divides the application logic of its developer over eight\n *  class, \u003cbr\u003e\n *  \t\u003cul\u003e\n * \t\t\u003cli\u003eClientEventHandler\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client events [Optional Class].\n *  \t\t\u003cli\u003eClientCommandHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client character/string commands.\n *  \t\t\u003cli\u003eClientObjectHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - Object commands.\n * \t\t\u003cli\u003eClientBinaryHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - binary data.\n * \t\t\u003cli\u003eClientWriteHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n *  \t\t\u003cli\u003eClientAuthenticationHandler [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Used to Authencatet a client.\n *  \t\t\u003cli\u003eClientData [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Client data carrier (support class)\n * \t\t\u003cli\u003eClientExtendedEventHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles extended client events.\n *  \t\u003c/ul\u003e\n *\n *  [#] \u003d Any one of these have to be set based on default DataMode for input.\n *  The default DataMode for input is String so if not changes you will\n *  have to set ClientCommandHandler.\n *  \u003c/p\u003e\n *  \u003cp\u003e\n *   Eg:\n *  \u003ccode\u003e\u003cBLOCKQUOTE\u003e\u003cpre\u003e\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle \u003d \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer \u003d new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * \u003c/pre\u003e\u003c/BLOCKQUOTE\u003e\u003c/code\u003e\u003c/p\u003e\n *\n *  @version 1.4.8\n *  @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //Some variable are not initialised to any value because the\n    //default java value was desired initial value.\n    //\u0027dev \u0027 \u003d development build not yet final\n    //\u0027beta\u0027 \u003d test build all features\n    //change also in QSAdminMain\n    private final static String VER \u003d \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n        if (System.getProperty(\"org.quickserver.useOSLineSeparator\") !\u003d null \u0026\u0026 System.getProperty(\"org.quickserver.useOSLineSeparator\").equals(\"true\")) {\n            NEW_LINE \u003d System.getProperty(\"line.separator\");\n        } else {\n            NEW_LINE \u003d \"\\r\\n\";\n        }\n        String _pid \u003d ManagementFactory.getRuntimeMXBean().getName();\n        int i \u003d _pid.indexOf(\"@\");\n        pid \u003d _pid.substring(0, i);\n        System.out.print(\"Loading QuickServer v\" + getVersion() + \" [PID:\" + pid + \"]\");\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort \u003d 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName \u003d \"QuickServer\";\n\n    private long maxConnection \u003d -1;\n\n    //1 min socket timeout\n    private int socketTimeout \u003d 60 * 1000;\n\n    private String maxConnectionMsg \u003d \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg \u003d \"-ERR Timeout\";\n\n    private String maxAuthTryMsg \u003d \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry \u003d 5;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //--v1.2\n    //Logger for QuickServer\n    private static final Logger logger \u003d Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //for Service interface\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState \u003d Service.UNKNOWN;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.3\n    private QuickServerConfig config \u003d new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel \u003d \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel \u003d \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation \u003d false;\n\n    private boolean communicationLogging \u003d true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig \u003d config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km \u003d null;\n\n    private TrustManager[] tm \u003d null;\n\n    private boolean runningSecure \u003d false;\n\n    private SecureStoreManager secureStoreManager \u003d null;\n\n    private Exception exceptionInRun \u003d null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode \u003d true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN \u003d DataMode.STRING;\n\n    private DataMode defaultDataModeOUT \u003d DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging \u003d false;\n\n    private int rawCommunicationMaxLength \u003d 100;\n\n    static {\n        System.out.println(\" Done\");\n        //should be commented if not a patch release\n        //System.out.println(\"[Includes patch(#): t\u003d152\u0026p\u003d532]\");\n        //should be commented if not a dev release\n        //System.out.println(\"[Dev Build Date: Saturday, October 29, 2005]\");\n        logger.log(Level.FINE, \"PID: {0}\", pid);\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion() {\n        return VER;\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo() {\n        return getVersionNo(VER);\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver) {\n        //String ver \u003d getVersion();\n        float version \u003d 0;\n        //check if beta\n        int i \u003d ver.indexOf(\" \");\n        if (i \u003d\u003d -1)\n            i \u003d ver.length();\n        ver \u003d ver.substring(0, i);\n        //check for sub version\n        i \u003d ver.indexOf(\".\");\n        if (i !\u003d -1) {\n            int j \u003d ver.indexOf(\".\", i);\n            if (j !\u003d -1) {\n                ver \u003d ver.substring(0, i) + \".\" + MyString.replaceAll(ver.substring(i + 1), \".\", \"\");\n            }\n        }\n        try {\n            version \u003d Float.parseFloat(ver);\n        } catch (NumberFormatException e) {\n            throw new RuntimeException(\"Corrupt QuickServer\");\n        }\n        return version;\n    }\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine() {\n        return NEW_LINE;\n    }\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString() {\n        return serverName + \" : \" + getPort();\n    }\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n        setClientCommandHandler(commandHandler);\n    }\n\n    /**\n     * Creates a new server at \u003ccode\u003eport\u003c/code\u003e with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n        //send to another constructor\n        this(commandHandler);\n        setPort(port);\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException {\n        logger.log(Level.FINE, \"Starting {0}\", getName());\n        if (isClosed() \u003d\u003d false) {\n            logger.log(Level.WARNING, \"Server {0} already running.\", getName());\n            throw new AppException(\"Server \" + getName() + \" already running.\");\n        }\n        blockingMode \u003d getBasicConfig().getServerMode().getBlocking();\n        if (getSecure().isEnable() \u0026\u0026 blockingMode \u003d\u003d false) {\n            //TODO we need to fix this..\n            logger.warning(\"QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode.\");\n            blockingMode \u003d true;\n            getBasicConfig().getServerMode().setBlocking(blockingMode);\n        }\n        if (serverBanner \u003d\u003d null) {\n            serverBanner \u003d \"\\n-------------------------------\" + \"\\n Name : \" + getName() + \"\\n Port : \" + getPort() + \"\\n-------------------------------\\n\";\n            logger.finest(\"Default Server Banner Generated\");\n        }\n        try {\n            loadApplicationClasses();\n            //load class from Advanced Settings\n            Class clientIdentifierClass \u003d getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);\n            clientIdentifier \u003d (ClientIdentifier) clientIdentifierClass.newInstance();\n            clientIdentifier.setQuickServer(QuickServer.this);\n            //load class from ObjectPoolConfig\n            Class poolManagerClass \u003d getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);\n            poolManager \u003d (PoolManager) poolManagerClass.newInstance();\n            //load class QSObjectPoolMaker\n            Class qsObjectPoolMakerClass \u003d getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);\n            qsObjectPoolMaker \u003d (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();\n            loadServerHooksClasses();\n            processServerHooks(ServerHook.PRE_STARTUP);\n            if (getSecure().isLoad() \u003d\u003d true)\n                //v1.4.0\n                loadSSLContext();\n            loadBusinessLogic();\n        } catch (ClassNotFoundException e) {\n            logger.log(Level.SEVERE, \"Could not load class/s: \" + e, e);\n            throw new AppException(\"Could not load class/s : \" + e);\n        } catch (InstantiationException e) {\n            logger.log(Level.SEVERE, \"Could not instantiate class/s: \" + e, e);\n            throw new AppException(\"Could not instantiate class/s: \" + e);\n        } catch (IllegalAccessException e) {\n            logger.log(Level.SEVERE, \"Illegal access to class/s: \" + e, e);\n            throw new AppException(\"Illegal access to class/s: \" + e);\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"IOException: \" + e, e);\n            throw new AppException(\"IOException: \" + e);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Exception: \" + e, e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Exception : \" + e);\n        }\n        //v1.3.3\n        if (getSecurityManagerClass() !\u003d null) {\n            System.setSecurityManager(getSecurityManager());\n        }\n        setServiceState(Service.INIT);\n        t \u003d new Thread(this, \"QuickServer - \" + getName());\n        t.start();\n        do {\n            Thread.yield();\n        } while (getServiceState() \u003d\u003d Service.INIT);\n        if (getServiceState() !\u003d Service.RUNNING) {\n            if (exceptionInRun !\u003d null)\n                throw new AppException(\"Could not start server \" + getName() + \"! Details: \" + exceptionInRun);\n            else\n                throw new AppException(\"Could not start server \" + getName());\n        }\n        lastStartTime \u003d new java.util.Date();\n        logger.log(Level.FINE, \"Started {0}, Date: {1}\", new Object[] { getName(), lastStartTime });\n    }\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException {\n        processServerHooks(ServerHook.PRE_SHUTDOWN);\n        logger.log(Level.WARNING, \"Stopping {0}\", getName());\n        stopServer \u003d true;\n        Socket death \u003d null;\n        if (isClosed() \u003d\u003d true) {\n            logger.log(Level.WARNING, \"Server {0} is not running!\", getName());\n            throw new AppException(\"Server \" + getName() + \" is not running!\");\n        }\n        try {\n            if (getBlockingMode() \u003d\u003d true) {\n                if (getSecure().isEnable() \u003d\u003d false) {\n                    death \u003d new Socket(server.getInetAddress(), server.getLocalPort());\n                    death.getInputStream().read();\n                    death.close();\n                } else {\n                    death \u003d getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());\n                    Thread.sleep(100);\n                    death.close();\n                }\n            }\n            if (serverSocketChannel !\u003d null) {\n                serverSocketChannel.close();\n            }\n        } catch (IOException e) {\n            logger.log(Level.FINE, \"IOError stopping {0}: {1}\", new Object[] { getName(), e });\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error stopping {0}: {1}\", new Object[] { getName(), e });\n            throw new AppException(\"Error in stopServer \" + getName() + \": \" + e);\n        }\n        for (int i \u003d 0; getServiceState() !\u003d Service.STOPPED; i++) {\n            try {\n                Thread.sleep(60);\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error waiting for {0} to fully stop. Error: {1}\", new Object[] { getName(), e });\n            }\n            if (i \u003e 1000) {\n                logger.severe(\"Server was not stopped even after 10sec.. will terminate now.\");\n                System.exit(-1);\n            }\n        }\n        if (adminServer \u003d\u003d null || getQSAdminServer().getServer() !\u003d this) {\n            //so this is not qsadmin\n            setClassLoader(null);\n        }\n        logger.log(Level.INFO, \"Stopped {0}\", getName());\n    }\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException {\n        stopServer();\n        startServer();\n    }\n\n    /**\n     * Returns the name of the QuickServer. Default is \u0027QuickServer\u0027.\n     * @see #setName\n     */\n    public String getName() {\n        return serverName;\n    }\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name) {\n        serverName \u003d name;\n        logger.log(Level.FINEST, \"Set to : {0}\", name);\n    }\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner() {\n        return serverBanner;\n    }\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. \u003cbr\u003e\u0026nbsp;\u003cbr\u003e\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner) {\n        serverBanner \u003d banner;\n        logger.log(Level.FINEST, \"Set to : {0}\", banner);\n    }\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port) {\n        if (port \u003c 0) {\n            throw new IllegalArgumentException(\"Port number can not be less than 0!\");\n        }\n        serverPort \u003d port;\n        logger.log(Level.FINEST, \"Set to {0}\", port);\n    }\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort() {\n        if (isClosed() \u003d\u003d false) {\n            return server.getLocalPort();\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            return serverPort;\n        } else {\n            int _port \u003d getSecure().getPort();\n            if (_port \u003d\u003d -1)\n                return serverPort;\n            else\n                return _port;\n        }\n    }\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler) {\n        clientCommandHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler() {\n        return clientCommandHandlerString;\n    }\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data) {\n        this.clientDataString \u003d data;\n        logger.log(Level.FINEST, \"Set to {0}\", data);\n    }\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData() {\n        return clientDataString;\n    }\n\n    /**\n     * Sets the client socket\u0027s timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time) {\n        if (time \u003e 0)\n            socketTimeout \u003d time;\n        else\n            socketTimeout \u003d 0;\n        logger.log(Level.FINEST, \"Set to {0}\", socketTimeout);\n    }\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout() {\n        return socketTimeout;\n    }\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry) {\n        maxAuthTry \u003d authTry;\n        logger.log(Level.FINEST, \"Set to {0}\", authTry);\n    }\n\n    /**\n     * Returns max allowed login attempts. Default is \u003ccode\u003e5\u003c/code\u003e.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry() {\n        return maxAuthTry;\n    }\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg) {\n        maxAuthTryMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg() {\n        return maxAuthTryMsg;\n    }\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg) {\n        timeoutMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg() {\n        return timeoutMsg;\n    }\n\n    private TheClient initTheClient() {\n        TheClient theClient \u003d new TheClient();\n        theClient.setServer(QuickServer.this);\n        theClient.setTimeoutMsg(getTimeoutMsg());\n        //v1.2\n        theClient.setMaxAuthTry(getMaxAuthTry());\n        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());\n        theClient.setClientEventHandler(clientEventHandler);\n        //v1.4.6\n        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);\n        theClient.setClientCommandHandler(clientCommandHandler);\n        //v1.2\n        theClient.setClientObjectHandler(clientObjectHandler);\n        //v1.4\n        theClient.setClientBinaryHandler(clientBinaryHandler);\n        //v1.4.5\n        theClient.setClientWriteHandler(clientWriteHandler);\n        //v1.3\n        theClient.setAuthenticator(authenticator);\n        //v1.4.6\n        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);\n        theClient.setTimeout(socketTimeout);\n        theClient.setMaxConnectionMsg(maxConnectionMsg);\n        //v1.3.2\n        theClient.setCommunicationLogging(getCommunicationLogging());\n        return theClient;\n    }\n\n    public void run() {\n        exceptionInRun \u003d null;\n        TheClient theClient \u003d initTheClient();\n        try {\n            stopServer \u003d false;\n            closeAllPools();\n            initAllPools();\n            makeServerSocket();\n            //print banner\n            System.out.println(serverBanner);\n            //v1.2\n            setServiceState(Service.RUNNING);\n            //v1.3.3\n            processServerHooks(ServerHook.POST_STARTUP);\n            if (getBlockingMode() \u003d\u003d false) {\n                runNonBlocking(theClient);\n                if (stopServer \u003d\u003d true) {\n                    logger.log(Level.FINEST, \"Closing selector for {0}\", getName());\n                    selector.close();\n                }\n                return;\n            } else {\n                runBlocking(theClient);\n            }\n        } catch (BindException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"{0} BindException for Port {1} @ {2} : {3}\", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });\n        } catch (javax.net.ssl.SSLException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"SSLException {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (IOException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"IOError {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (Exception e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"Error {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } finally {\n            if (getBlockingMode() \u003d\u003d true) {\n                logger.log(Level.WARNING, \"Closing {0}\", getName());\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            } else if (getBlockingMode() \u003d\u003d false \u0026\u0026 exceptionInRun !\u003d null) {\n                logger.log(Level.WARNING, \"Closing {0} - Had Error: {1}\", new Object[] { getName(), exceptionInRun });\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        if (serverSocketChannel !\u003d null)\n                            serverSocketChannel.close();\n                        if (server !\u003d null)\n                            server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n        }\n    }\n\n    //end of run\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnection \u003d maxConnection;\n        else\n            this.maxConnection \u003d maxConnection;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnection);\n    }\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection() {\n        return maxConnection;\n    }\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount() {\n        if (clientHandlerPool !\u003d null) {\n            try {\n                return getClientHandlerPool().getNumActive();\n            } catch (Exception e) {\n                return 0;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : \u003ccode\u003e-ERR Server Busy. Max Connection Reached\u003c/code\u003e\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n        else\n            this.maxConnectionMsg \u003d maxConnectionMsg;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnectionMsg);\n    }\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg() {\n        return maxConnectionMsg;\n    }\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException {\n        ipAddr \u003d InetAddress.getByName(bindAddr);\n        logger.log(Level.FINEST, \"Set to {0}\", bindAddr);\n    }\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr() {\n        if (ipAddr \u003d\u003d null) {\n            try {\n                ipAddr \u003d InetAddress.getByName(\"0.0.0.0\");\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Unable to create default ip(0.0.0.0) : {0}\", e);\n                throw new RuntimeException(\"Error: Unable to find servers own ip : \" + e);\n            }\n        }\n        return ipAddr;\n    }\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects) {\n        this.storeObjects \u003d storeObjects;\n    }\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return \u003ccode\u003enull\u003c/code\u003e.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects() {\n        return storeObjects;\n    }\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port) {\n        getQSAdminServer().getServer().setPort(port);\n    }\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort() {\n        return getQSAdminServer().getServer().getPort();\n    }\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator) {\n        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);\n    }\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator() {\n        return getQSAdminServer().getServer().getAuthenticator();\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException {\n        getQSAdminServer().setClientAuthenticationHandler(authenticator);\n        getQSAdminServer().startServer(port);\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException {\n        getQSAdminServer().startServer();\n    }\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer() {\n        if (adminServer \u003d\u003d null)\n            adminServer \u003d new QSAdminServer(QuickServer.this);\n        return adminServer;\n    }\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer) {\n        if (adminServer \u003d\u003d null)\n            this.adminServer \u003d adminServer;\n    }\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed() {\n        if (server \u003d\u003d null)\n            return true;\n        return server.isClosed();\n    }\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer\u0027s own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger() {\n        if (appLogger !\u003d null)\n            return appLogger;\n        return logger;\n    }\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger) {\n        this.appLogger \u003d appLogger;\n    }\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler) {\n        clientObjectHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler() {\n        return clientObjectHandlerString;\n    }\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n        if (formatter \u003d\u003d null)\n            return;\n        consoleLoggingformatter \u003d formatter;\n        java.util.logging.Formatter conformatter \u003d (java.util.logging.Formatter) getClass(formatter, true).newInstance();\n        Logger jdkLogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d jdkLogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                handlers[index].setFormatter(conformatter);\n            }\n        }\n        logger.log(Level.FINEST, \"Set to {0}\", formatter);\n    }\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter() {\n        return consoleLoggingformatter;\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MiniFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to logging.MiniFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MicroFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to MicroFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        boolean isConsole \u003d true;\n        try {\n            if (System.console() \u003d\u003d null) {\n                isConsole \u003d false;\n            }\n        } catch (Throwable e) {\n            //ignore\n        }\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                if (isConsole \u003d\u003d false \u0026\u0026 level !\u003d Level.OFF) {\n                    System.out.println(\"QuickServer: You do not have a console.. so turning console logger off..\");\n                    level \u003d Level.OFF;\n                }\n                if (level \u003d\u003d Level.OFF) {\n                    logger.info(\"QuickServer: Removing console handler.. \");\n                    rlogger.removeHandler(handlers[index]);\n                    handlers[index].setLevel(level);\n                    handlers[index].close();\n                } else {\n                    handlers[index].setLevel(level);\n                }\n            }\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            consoleLoggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            consoleLoggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            consoleLoggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            consoleLoggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            consoleLoggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            consoleLoggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            consoleLoggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            consoleLoggingLevel \u003d \"OFF\";\n        else\n            consoleLoggingLevel \u003d \"UNKNOWN\";\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel() {\n        return consoleLoggingLevel;\n    }\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            handlers[index].setLevel(level);\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            loggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            loggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            loggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            loggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            loggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            loggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            loggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            loggingLevel \u003d \"OFF\";\n        else\n            loggingLevel \u003d \"UNKNOWN\";\n        consoleLoggingLevel \u003d loggingLevel;\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    //*** Start of Service interface methods\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError() {\n        return serviceError;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param) {\n        serviceError \u003d null;\n        try {\n            initServer(param);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig) {\n        serviceError \u003d null;\n        try {\n            initServer(qsConfig);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING)\n            return false;\n        try {\n            startServer();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.STOPPED)\n            return false;\n        try {\n            stopServer();\n            clearAllPools();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING) {\n            suspendMaxConnection \u003d maxConnection;\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n            maxConnection \u003d 0;\n            maxConnectionMsg \u003d \"Service is suspended.\";\n            setServiceState(Service.SUSPENDED);\n            logger.log(Level.INFO, \"Service {0} is suspended.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.SUSPENDED) {\n            maxConnection \u003d suspendMaxConnection;\n            maxConnectionMsg \u003d suspendMaxConnectionMsg;\n            setServiceState(Service.RUNNING);\n            logger.log(Level.INFO, \"Service {0} resumed.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info() {\n        serviceError \u003d null;\n        StringBuilder buf \u003d new StringBuilder();\n        buf.append(getName()).append(\"\\n\");\n        buf.append(getBindAddr().getHostAddress()).append(\" \");\n        buf.append(getPort()).append(\"\\n\");\n        return buf.toString();\n    }\n\n    // *** End of Service interface methods\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException {\n        QuickServerConfig qsConfig \u003d null;\n        try {\n            qsConfig \u003d ConfigReader.read((String) param[0]);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not init server from xml file {0} : {1}\", new Object[] { new File((String) param[0]).getAbsolutePath(), e });\n            throw new AppException(\"Could not init server from xml file\", e);\n        }\n        initServer(qsConfig);\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {\n        setConfig(qsConfig);\n        try {\n            configQuickServer();\n            loadApplicationClasses();\n            //start InitServerHooks\n            InitServerHooks ish \u003d getConfig().getInitServerHooks();\n            if (ish !\u003d null) {\n                Iterator iterator \u003d ish.iterator();\n                String initServerHookClassName \u003d null;\n                Class initServerHookClass \u003d null;\n                InitServerHook initServerHook \u003d null;\n                while (iterator.hasNext()) {\n                    initServerHookClassName \u003d (String) iterator.next();\n                    initServerHookClass \u003d getClass(initServerHookClassName, true);\n                    initServerHook \u003d (InitServerHook) initServerHookClass.newInstance();\n                    logger.log(Level.INFO, \"Loaded init server hook: {0}\", initServerHookClassName);\n                    logger.log(Level.FINE, \"Init server hook info: {0}\", initServerHook.info());\n                    initServerHook.handleInit(QuickServer.this);\n                }\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not load init server hook: {0}\", e);\n            logger.log(Level.WARNING, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Could not load init server hook\", e);\n        }\n        setServiceState(Service.INIT);\n        logger.log(Level.FINEST, \"\\r\\n{0}\", MyString.getSystemInfo(getVersion()));\n    }\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState() {\n        return serviceState;\n    }\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state) {\n        serviceState \u003d state;\n    }\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp) {\n        if (temp.equals(\"SEVERE\"))\n            qs.setConsoleLoggingLevel(Level.SEVERE);\n        else if (temp.equals(\"WARNING\"))\n            qs.setConsoleLoggingLevel(Level.WARNING);\n        else if (temp.equals(\"INFO\"))\n            qs.setConsoleLoggingLevel(Level.INFO);\n        else if (temp.equals(\"CONFIG\"))\n            qs.setConsoleLoggingLevel(Level.CONFIG);\n        else if (temp.equals(\"FINE\"))\n            qs.setConsoleLoggingLevel(Level.FINE);\n        else if (temp.equals(\"FINER\"))\n            qs.setConsoleLoggingLevel(Level.FINER);\n        else if (temp.equals(\"FINEST\"))\n            qs.setConsoleLoggingLevel(Level.FINEST);\n        else if (temp.equals(\"OFF\"))\n            qs.setConsoleLoggingLevel(Level.OFF);\n        else\n            logger.log(Level.WARNING, \"unknown level {0}\", temp);\n    }\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception {\n        QuickServer qs \u003d QuickServer.this;\n        //v1.3\n        qs.setConfig(config);\n        qs.setBasicConfig(config);\n        String temp \u003d config.getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        temp \u003d null;\n        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        //v1.3.3\n        qs.setSecurityManagerClass(config.getSecurityManagerClass());\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        temp \u003d config.getApplicationJarPath();\n        if (temp !\u003d null) {\n            File ajp \u003d new File(temp);\n            if (ajp.isAbsolute() \u003d\u003d false) {\n                temp \u003d config.getConfigFile();\n                ajp \u003d new File(temp);\n                temp \u003d ajp.getParent() + File.separatorChar + config.getApplicationJarPath();\n                config.setApplicationJarPath(temp);\n                temp \u003d null;\n            }\n            qs.setApplicationJarPath(config.getApplicationJarPath());\n            //set path also to QSAdmin\n            if (config.getQSAdminServerConfig() !\u003d null) {\n                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());\n            }\n        }\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception {\n        QuickServer qs \u003d getQSAdminServer().getServer();\n        qs.setBasicConfig(config);\n        //set the Logging Level to same as main QS\n        //config.getConsoleLoggingLevel();\n        String temp \u003d getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        //set the Logging Formatter to same as main QS\n        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());\n        //v1.4.6\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        //v1.4.6\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());\n        //v1.3.2\n        if (config.getCommandShellEnable().equals(\"true\"))\n            getQSAdminServer().setShellEnable(true);\n        getQSAdminServer().setPromptName(config.getCommandShellPromptName());\n        //v1.3.3\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception {\n        configQuickServer(getConfig());\n        if (getConfig().getQSAdminServerConfig() !\u003d null) {\n            configQuickServer(getConfig().getQSAdminServerConfig());\n        }\n    }\n\n    /**\n     * Usage: QuickServer [-options]\u003cbr/\u003e\n     * Where options include:\u003cbr/\u003e\n     *   -about\t\tOpens About Dialogbox\u003cbr/\u003e\n     *   -load \u003cxml_config_file\u003e [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File \u003cnew_file_name\u003e\n     */\n    public static void main(String[] args) {\n        try {\n            if (args.length \u003e\u003d 1) {\n                if (args[0].equals(\"-about\")) {\n                    org.quickserver.net.server.gui.About.main(null);\n                } else if (args[0].equals(\"-load\") \u0026\u0026 args.length \u003e\u003d 2) {\n                    QuickServer qs \u003d QuickServer.load(args[1]);\n                    if (qs !\u003d null)\n                        handleOptions(args, qs);\n                } else {\n                    System.out.println(printUsage());\n                }\n            } else {\n                System.out.println(printUsage());\n                org.quickserver.net.server.gui.About.showAbout();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException {\n        QuickServer qs \u003d new QuickServer();\n        Object[] config \u003d new Object[] { xml };\n        qs.initServer(config);\n        qs.startServer();\n        if (qs.getConfig().getQSAdminServerConfig() !\u003d null) {\n            qs.startQSAdminServer();\n        }\n        return qs;\n    }\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage() {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"QuickServer - Java library/framework for creating robust multi-client TCP servers.\\n\");\n        sb.append(\"Copyright (C) QuickServer.org\\n\\n\");\n        sb.append(\"Usage: QuickServer [-options]\\n\");\n        sb.append(\"Where options include:\\n\");\n        sb.append(\"  -about\\t\" + \"Opens About Dialog box\\n\");\n        sb.append(\"  -load \u003cxml_config_file\u003e [load-options]\\t\" + \"Loads the server from xml file.\\n\");\n        sb.append(\"  Where load-options include:\\n\");\n        sb.append(\"     -fullXML2File \u003cfile_name\u003e\\t\" + \"Dumps the Full XML configuration of the QuickServer loaded.\\n\");\n        return sb.toString();\n    }\n\n    private static void handleOptions(String[] args, QuickServer quickserver) {\n        if (args.length \u003c 3)\n            return;\n        if (args[2].equals(\"-fullXML2File\") \u0026\u0026 args.length \u003e\u003d 4) {\n            File file \u003d new File(args[3]);\n            logger.log(Level.INFO, \"Writing full xml configuration to file: {0}\", file.getAbsolutePath());\n            try {\n                TextFile.write(file, quickserver.getConfig().toXML(null));\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error writing full xml configuration: {0}\", e);\n            }\n        }\n    }\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception {\n        try {\n            if (pool !\u003d null)\n                getClientPool().clear();\n            if (clientHandlerPool !\u003d null)\n                getClientHandlerPool().clear();\n            if (getClientDataPool() !\u003d null)\n                getClientDataPool().clear();\n            if (getDBPoolUtil() !\u003d null)\n                getDBPoolUtil().clean();\n            if (byteBufferPool !\u003d null)\n                getByteBufferPool().clear();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error: {0}\", e);\n            throw e;\n        }\n    }\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception {\n        if (pool \u003d\u003d null \u0026\u0026 clientHandlerPool \u003d\u003d null \u0026\u0026 getClientDataPool() \u003d\u003d null \u0026\u0026 getDBPoolUtil() \u003d\u003d null \u0026\u0026 byteBufferPool \u003d\u003d null) {\n            return;\n        }\n        logger.log(Level.FINE, \"Closing pools for {0}\", getName());\n        try {\n            if (pool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {\n                logger.finer(\"Closing ClientThread pool.\");\n                getClientPool().close();\n            }\n            if (clientHandlerPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientHandlerPool())) {\n                logger.finer(\"Closing ClientHandler pool.\");\n                getClientHandlerPool().close();\n            }\n            if (getClientDataPool() !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientDataPool())) {\n                logger.finer(\"Closing ClientData pool.\");\n                getClientDataPool().close();\n            }\n            if (getDBPoolUtil() !\u003d null) {\n                logger.finer(\"Closing DB pool.\");\n                getDBPoolUtil().clean();\n            }\n            if (byteBufferPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getByteBufferPool())) {\n                logger.finer(\"Closing ByteBuffer pool.\");\n                getByteBufferPool().close();\n            }\n            logger.log(Level.FINE, \"Closed pools for {0}\", getName());\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error closing pools for {0}: {1}\", new Object[] { getName(), e });\n            throw e;\n        }\n    }\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception {\n        logger.fine(\"Creating pools\");\n        if (getBlockingMode() \u003d\u003d false) {\n            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());\n        }\n        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());\n        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());\n        //check if client data is poolable\n        if (clientDataClass !\u003d null) {\n            try {\n                clientData \u003d (ClientData) clientDataClass.newInstance();\n                if (PoolableObject.class.isInstance(clientData) \u003d\u003d true) {\n                    PoolableObject po \u003d (PoolableObject) clientData;\n                    if (po.isPoolable() \u003d\u003d true) {\n                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());\n                    } else {\n                        clientDataPool \u003d null;\n                        logger.fine(\"ClientData is not poolable!\");\n                    }\n                }\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error: {0}\", e);\n                throw e;\n            }\n        }\n        try {\n            makeDBObjectPool();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error in makeDBObjectPool() : {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw e;\n        }\n        logger.fine(\"Created pools\");\n    }\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool() {\n        if (pool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientPool available yet!\");\n        return pool;\n    }\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientHandler pool\");\n        PoolableObjectFactory factory \u003d new ClientHandlerObjectFactory(getBlockingMode());\n        clientHandlerPool \u003d poolManager.makeClientHandlerPool(factory, opConfig);\n        poolManager.initPool(clientHandlerPool, opConfig);\n        clientHandlerPool \u003d makeQSObjectPool(clientHandlerPool);\n        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool() {\n        if (clientHandlerPool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientHandler Pool available yet!\");\n        return clientHandlerPool;\n    }\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config) {\n        this.config \u003d config;\n    }\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig() {\n        return config;\n    }\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientData pool\");\n        clientDataPool \u003d poolManager.makeClientDataPool(factory, opConfig);\n        poolManager.initPool(clientDataPool, opConfig);\n        clientDataPool \u003d makeQSObjectPool(clientDataPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool() {\n        return clientDataPool;\n    }\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return \u003ccode\u003enull\u003c/code\u003e\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil() {\n        return dBPoolUtil;\n    }\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {\n        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);\n    }\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception {\n        if (getConfig().getDBObjectPoolConfig() !\u003d null) {\n            logger.fine(\"Creating DBObject Pool\");\n            //logger.finest(\"Got:\\n\"+getConfig().getDBObjectPoolConfig().toXML(null));\n            Class dbPoolUtilClass \u003d getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);\n            dBPoolUtil \u003d (DBPoolUtil) dbPoolUtilClass.newInstance();\n            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());\n            dBPoolUtil.initPool();\n        }\n    }\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id) {\n        return clientIdentifier.findFirstClientById(id);\n    }\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  \u003ccode\u003e\u003cpre\u003e\n     *    Eg:\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tObject syncObj \u003d quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator \u003d quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tClientIdentifier clientIdentifier \u003d quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator \u003d clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    \u003c/code\u003e\u003c/pre\u003e\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient() {\n        return clientIdentifier.findAllClient();\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern) {\n        return clientIdentifier.findAllClientById(pattern);\n    }\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key) {\n        return clientIdentifier.findClientByKey(key);\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern) {\n        return clientIdentifier.findAllClientByKey(pattern);\n    }\n\n    /**\n     * Sets next client has a trusted client.\n     * \u003cp\u003eThis will skip any authentication and will not set any timeout.\u003c/p\u003e\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted() {\n        setSkipValidation(true);\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation() {\n        return skipValidation;\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation) {\n        skipValidation \u003d validation;\n    }\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging) {\n        this.communicationLogging \u003d communicationLogging;\n    }\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging() {\n        return communicationLogging;\n    }\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass) {\n        if (securityManagerClass !\u003d null)\n            this.securityManagerClass \u003d securityManagerClass;\n    }\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass() {\n        return securityManagerClass;\n    }\n\n    public SecurityManager getSecurityManager() throws AppException {\n        if (getSecurityManagerClass() \u003d\u003d null)\n            return null;\n        SecurityManager sm \u003d null;\n        try {\n            sm \u003d (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();\n        } catch (ClassNotFoundException e) {\n            throw new AppException(e.getMessage());\n        } catch (InstantiationException e) {\n            throw new AppException(e.getMessage());\n        } catch (IllegalAccessException e) {\n            throw new AppException(e.getMessage());\n        }\n        return sm;\n    }\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {\n        this.accessConstraintConfig \u003d accessConstraintConfig;\n    }\n\n    /**\n     * Returns Access constraints if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig() {\n        return accessConstraintConfig;\n    }\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader) {\n        this.classLoader \u003d classLoader;\n        Thread.currentThread().setContextClassLoader(classLoader);\n    }\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader() {\n        return classLoader;\n    }\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException {\n        if (name \u003d\u003d null)\n            throw new IllegalArgumentException(\"Class name can\u0027t be null!\");\n        logger.log(Level.FINEST, \"Class: {0}, reload: {1}\", new Object[] { name, reload });\n        if (reload \u003d\u003d true \u0026\u0026 classLoader !\u003d null) {\n            return classLoader.loadClass(name);\n        } else if (reload \u003d\u003d true \u0026\u0026 classLoader \u003d\u003d null \u0026\u0026 this.getClass().getClassLoader() !\u003d null) {\n            return this.getClass().getClassLoader().loadClass(name);\n        } else if (reload \u003d\u003d false \u0026\u0026 classLoader !\u003d null) {\n            return Class.forName(name, true, classLoader);\n        } else /*if(reload\u003d\u003dfalse \u0026\u0026 classLoader\u003d\u003dnull)*/\n        {\n            return Class.forName(name, true, this.getClass().getClassLoader());\n        }\n    }\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath) {\n        this.applicationJarPath \u003d applicationJarPath;\n    }\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath() {\n        return applicationJarPath;\n    }\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks) {\n        this.serverHooks \u003d serverHooks;\n    }\n\n    /**\n     * Returns ServerHooks if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks() {\n        if (serverHooks \u003d\u003d null)\n            serverHooks \u003d new ServerHooks();\n        return serverHooks;\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses() {\n        if (getServerHooks() \u003d\u003d null)\n            return;\n        listOfServerHooks \u003d new ArrayList();\n        ServerHook serverHook \u003d null;\n        String serverHookClassName \u003d null;\n        Class serverHookClass \u003d null;\n        //add system hooks\n        serverHook \u003d new GhostSocketReaper();\n        serverHook.initHook(QuickServer.this);\n        listOfServerHooks.add(serverHook);\n        ghostSocketReaper \u003d (GhostSocketReaper) serverHook;\n        //add user hooks if any\n        Iterator iterator \u003d getServerHooks().iterator();\n        while (iterator.hasNext()) {\n            serverHookClassName \u003d (String) iterator.next();\n            try {\n                serverHookClass \u003d getClass(serverHookClassName, true);\n                serverHook \u003d (ServerHook) serverHookClass.newInstance();\n                serverHook.initHook(QuickServer.this);\n                listOfServerHooks.add(serverHook);\n                logger.log(Level.INFO, \"Loaded server hook: {0}\", serverHookClassName);\n                logger.log(Level.FINE, \"Server hook info: {0}\", serverHook.info());\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Could not load server hook [{0}]: {1}\", new Object[] { serverHookClassName, e });\n                logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            }\n        }\n        //end of while\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event) {\n        if (listOfServerHooks \u003d\u003d null) {\n            logger.warning(\"listOfServerHooks was null!\");\n            return;\n        }\n        ServerHook serverHook \u003d null;\n        boolean result \u003d false;\n        Iterator iterator \u003d listOfServerHooks.iterator();\n        String hooktype \u003d \"UNKNOWN\";\n        switch(event) {\n            case ServerHook.PRE_STARTUP:\n                hooktype \u003d \"PRE_STARTUP\";\n                break;\n            case ServerHook.POST_STARTUP:\n                hooktype \u003d \"POST_STARTUP\";\n                break;\n            case ServerHook.PRE_SHUTDOWN:\n                hooktype \u003d \"PRE_SHUTDOWN\";\n                break;\n            case ServerHook.POST_SHUTDOWN:\n                hooktype \u003d \"POST_SHUTDOWN\";\n                break;\n        }\n        while (iterator.hasNext()) {\n            serverHook \u003d (ServerHook) iterator.next();\n            try {\n                result \u003d serverHook.handleEvent(event);\n            } catch (Exception e) {\n                result \u003d false;\n                logger.log(Level.WARNING, \"Error invoking {0} hook [{1}]: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });\n            }\n            logger.log(Level.FINE, \"Invoked {0} hook [{1}] was: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), result });\n        }\n    }\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone() {\n        Object object \u003d null;\n        try {\n            object \u003d super.clone();\n            QuickServer _qs \u003d (QuickServer) object;\n            _qs.setQSAdminServer(new QSAdminServer(_qs));\n        } catch (CloneNotSupportedException e) {\n            //should not happ\n            logger.log(Level.WARNING, \"Error cloning : {0}\", e);\n        }\n        return object;\n    }\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure) {\n        this.secure \u003d secure;\n    }\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure() {\n        if (secure \u003d\u003d null)\n            secure \u003d new Secure();\n        return secure;\n    }\n\n    /**\n     * \u003cp\u003eReturns if the server is running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure() {\n        return runningSecure;\n    }\n\n    /**\n     * \u003cp\u003eSets the server mode if its running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure) {\n        this.runningSecure \u003d runningSecure;\n    }\n\n    private File makeAbsoluteToConfig(String fileName) {\n        Assertion.affirm(fileName !\u003d null, \"FileName can\u0027t be null\");\n        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());\n    }\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException {\n        server \u003d null;\n        logger.log(Level.FINEST, \"Binding {0} to IP: {1}\", new Object[] { getName(), getBindAddr() });\n        InetSocketAddress bindAddress \u003d new InetSocketAddress(getBindAddr(), getPort());\n        try {\n            NetworkInterface ni \u003d NetworkInterface.getByInetAddress(getBindAddr());\n            if (ni !\u003d null) {\n                logger.fine(\"NetworkInterface: \" + ni);\n            }\n        } catch (Exception igrnore) {\n            /*ignore*/\n        } catch (Error igrnore) {\n            /*ignore*/\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Making a normal ServerSocket for {0}\", getName());\n            setRunningSecure(false);\n            if (getBlockingMode() \u003d\u003d false) {\n                //for non-blocking\n                serverSocketChannel \u003d ServerSocketChannel.open();\n                server \u003d serverSocketChannel.socket();\n                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n            } else {\n                //for blocking\n                server \u003d new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n            }\n        } else {\n            try {\n                logger.log(Level.FINE, \"Making a secure ServerSocket for {0}\", getName());\n                getSSLContext();\n                setRunningSecure(true);\n                if (getBlockingMode() \u003d\u003d false) {\n                    logger.log(Level.FINE, \"Making a secure ServerSocketChannel for {0}\", getName());\n                    //for non-blocking\n                    serverSocketChannel \u003d ServerSocketChannel.open();\n                    server \u003d serverSocketChannel.socket();\n                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n                } else {\n                    ServerSocketFactory ssf \u003d getSSLContext().getServerSocketFactory();\n                    SSLServerSocket serversocket \u003d (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());\n                    setRunningSecure(true);\n                    secureStoreManager.logSSLServerSocketInfo(serversocket);\n                    server \u003d serversocket;\n                    serverSocketChannel \u003d server.getChannel();\n                    if (serverSocketChannel \u003d\u003d null \u0026\u0026 getBlockingMode() \u003d\u003d false) {\n                        logger.warning(\"Secure Server does not support Channel! So will run in blocking mode.\");\n                        blockingMode \u003d false;\n                    }\n                }\n                //blocking\n            } catch (NoSuchAlgorithmException e) {\n                logger.log(Level.WARNING, \"NoSuchAlgorithmException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            } catch (KeyManagementException e) {\n                logger.log(Level.WARNING, \"KeyManagementException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            }\n        }\n        server.setReuseAddress(true);\n        int connectionTime \u003d 0;\n        int latency \u003d 0;\n        int bandwidth \u003d 0;\n        connectionTime \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();\n        latency \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();\n        bandwidth \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();\n        logger.log(Level.FINE, \"getPerformancePreferencesConnectionTime : {0}\", connectionTime);\n        logger.log(Level.FINE, \"getPerformancePreferencesLatency : {0}\", latency);\n        logger.log(Level.FINE, \"getPerformancePreferencesBandwidth : {0}\", bandwidth);\n        server.setPerformancePreferences(connectionTime, latency, bandwidth);\n        int clientSocketReceiveBufferSize \u003d getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();\n        if (clientSocketReceiveBufferSize \u003e 0) {\n            logger.log(Level.FINE, \"clientSocketReceiveBufferSize: {0}\", clientSocketReceiveBufferSize);\n            server.setReceiveBufferSize(clientSocketReceiveBufferSize);\n        }\n        if (getBlockingMode() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Server Mode {0} - Non Blocking\", getName());\n            if (selector \u003d\u003d null || selector.isOpen() \u003d\u003d false) {\n                logger.finest(\"Opening new selector\");\n                selector \u003d Selector.open();\n            } else {\n                logger.log(Level.FINEST, \"Reusing selector: {0}\", selector);\n            }\n            serverSocketChannel.configureBlocking(false);\n            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n            selector.wakeup();\n        } else {\n            logger.log(Level.FINE, \"Server Mode {0} - Blocking\", getName());\n        }\n    }\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {\n        Assertion.affirm(basicConfig !\u003d null, \"BasicServerConfig can\u0027t be null\");\n        this.basicConfig \u003d basicConfig;\n    }\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig() {\n        return basicConfig;\n    }\n\n    /**\n     * Loads the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException {\n        if (getSecure().isLoad() \u003d\u003d false) {\n            throw new IllegalStateException(\"Secure setting is not yet enabled for loading!\");\n        }\n        logger.info(\"Loading Secure Context..\");\n        km \u003d null;\n        tm \u003d null;\n        try {\n            String ssManager \u003d \"org.quickserver.security.SecureStoreManager\";\n            if (getSecure().getSecureStore() !\u003d null)\n                ssManager \u003d getSecure().getSecureStore().getSecureStoreManager();\n            Class secureStoreManagerClass \u003d getClass(ssManager, true);\n            secureStoreManager \u003d (SecureStoreManager) secureStoreManagerClass.newInstance();\n            km \u003d secureStoreManager.loadKeyManagers(getConfig());\n            logger.fine(\"KeyManager got\");\n            tm \u003d secureStoreManager.loadTrustManagers(getConfig());\n            logger.fine(\"TrustManager got\");\n            sslc \u003d secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());\n            sslc.init(km, tm, null);\n            logger.fine(\"SSLContext loaded\");\n        } catch (KeyStoreException e) {\n            logger.warning(\"KeyStoreException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchAlgorithmException e) {\n            logger.warning(\"NoSuchAlgorithmException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchProviderException e) {\n            logger.warning(\"NoSuchProviderException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (UnrecoverableKeyException e) {\n            logger.warning(\"UnrecoverableKeyException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (CertificateException e) {\n            logger.warning(\"CertificateException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (KeyManagementException e) {\n            logger.warning(\"KeyManagementException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (GeneralSecurityException e) {\n            logger.warning(\"GeneralSecurityException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (ClassNotFoundException e) {\n            logger.warning(\"ClassNotFoundException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (InstantiationException e) {\n            logger.warning(\"InstantiationException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (IllegalAccessException e) {\n            logger.warning(\"IllegalAccessException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        return getSSLContext(null);\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        if (protocol !\u003d null \u0026\u0026 secureStoreManager !\u003d null) {\n            SSLContext _sslc \u003d secureStoreManager.getSSLContext(protocol);\n            _sslc.init(km, tm, null);\n            return _sslc;\n        }\n        return sslc;\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext());\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext(protocol));\n    }\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler) {\n        clientBinaryHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler() {\n        return clientBinaryHandlerString;\n    }\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector) {\n        this.selector \u003d selector;\n    }\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector() {\n        return selector;\n    }\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception {\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        //long stime \u003d System.currentTimeMillis();\n        //long etime \u003d System.currentTimeMillis();\n        while (true) {\n            //etime \u003d System.currentTimeMillis();\n            //System.out.println(\"Time Taken: \"+(etime-stime));\n            client \u003d server.accept();\n            //stime \u003d System.currentTimeMillis();\n            if (linger \u003c 0) {\n                client.setSoLinger(false, 0);\n            } else {\n                client.setSoLinger(true, linger);\n            }\n            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                //low delay\u003d10\n                client.setTrafficClass(socketTrafficClass);\n            }\n            logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n            }\n            if (stopServer) {\n                //Client connected when server was about to be shutdown.\n                try {\n                    client.close();\n                } catch (Exception e) {\n                }\n                break;\n            }\n            if (checkAccessConstraint(client) \u003d\u003d false) {\n                continue;\n            }\n            //Check if max connection has reached\n            if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);\n            } else {\n                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);\n            }\n            theClient.setTrusted(getSkipValidation());\n            theClient.setSocket(client);\n            //mostly null\n            theClient.setSocketChannel(client.getChannel());\n            if (clientDataClass !\u003d null) {\n                if (getClientDataPool() \u003d\u003d null) {\n                    clientData \u003d (ClientData) clientDataClass.newInstance();\n                } else {\n                    clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                }\n                theClient.setClientData(clientData);\n            }\n            try {\n                _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                _chPolled.handleClient(theClient);\n            } catch (java.util.NoSuchElementException nsee) {\n                logger.warning(\"Could not borrow ClientHandler from pool. Error: \" + nsee);\n                logger.warning(\"Closing Socket [\" + client + \"] since no ClientHandler available.\");\n                client.close();\n            }\n            if (_chPolled !\u003d null) {\n                try {\n                    getClientPool().addClient(_chPolled, true);\n                } catch (java.util.NoSuchElementException nsee) {\n                    logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                    //logger.warning(\"Closing Socket [\"+client+\"] since no Thread available.\");\n                    //client.close();\n                    //returnClientHandlerToPool(_chPolled);\n                }\n                _chPolled \u003d null;\n            }\n            client \u003d null;\n            //reset it back\n            setSkipValidation(false);\n        }\n        //end of loop\n    }\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception {\n        int selectCount \u003d 0;\n        Iterator iterator \u003d null;\n        SelectionKey key \u003d null;\n        ServerSocketChannel serverChannel \u003d null;\n        SocketChannel socketChannel \u003d null;\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        boolean stopServerProcessed \u003d false;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        registerChannelRequestMap \u003d new HashMap();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        while (true) {\n            selectCount \u003d selector.select(500);\n            //selectCount \u003d selector.select();//for testing\n            //check for any pending registerChannel req.\n            synchronized (registerChannelRequestMap) {\n                if (registerChannelRequestMap.size() \u003e 0) {\n                    RegisterChannelRequest req \u003d null;\n                    Object hashkey \u003d null;\n                    iterator \u003d registerChannelRequestMap.keySet().iterator();\n                    while (iterator.hasNext()) {\n                        hashkey \u003d iterator.next();\n                        req \u003d (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);\n                        req.register(getSelector());\n                    }\n                    iterator \u003d null;\n                    registerChannelRequestMap.clear();\n                }\n                //if\n            }\n            //sync\n            if (stopServer \u003d\u003d true \u0026\u0026 stopServerProcessed \u003d\u003d false) {\n                logger.warning(\"Closing \" + getName());\n                serverSocketChannel.close();\n                stopServerProcessed \u003d true;\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.warning(\"Closed \" + getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n            if (stopServer \u003d\u003d false \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                logger.finest(\"Server must have re-started.. will break\");\n                break;\n            }\n            if (selectCount \u003d\u003d 0 \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                java.util.Set keyset \u003d selector.keys();\n                if (keyset.isEmpty() \u003d\u003d true \u0026\u0026 getClientCount() \u003c\u003d 0) {\n                    break;\n                } else {\n                    continue;\n                }\n            } else if (selectCount \u003d\u003d 0) {\n                continue;\n            }\n            iterator \u003d selector.selectedKeys().iterator();\n            while (iterator.hasNext()) {\n                key \u003d (SelectionKey) iterator.next();\n                if (key.isValid() \u003d\u003d false) {\n                    iterator.remove();\n                    continue;\n                }\n                if (key.isAcceptable() \u0026\u0026 stopServer \u003d\u003d false) {\n                    logger.finest(\"Key is Acceptable\");\n                    serverChannel \u003d (ServerSocketChannel) key.channel();\n                    socketChannel \u003d serverChannel.accept();\n                    if (socketChannel \u003d\u003d null) {\n                        iterator.remove();\n                        continue;\n                    }\n                    client \u003d socketChannel.socket();\n                    if (linger \u003c 0) {\n                        client.setSoLinger(false, 0);\n                    } else {\n                        client.setSoLinger(true, linger);\n                    }\n                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                        //low delay\u003d10\n                        client.setTrafficClass(socketTrafficClass);\n                    }\n                    logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                        logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n                    }\n                    if (checkAccessConstraint(client) \u003d\u003d false) {\n                        iterator.remove();\n                        continue;\n                    }\n                    socketChannel.configureBlocking(false);\n                    theClient.setTrusted(getSkipValidation());\n                    theClient.setSocket(socketChannel.socket());\n                    theClient.setSocketChannel(socketChannel);\n                    if (clientDataClass !\u003d null) {\n                        if (getClientDataPool() \u003d\u003d null) {\n                            clientData \u003d (ClientData) clientDataClass.newInstance();\n                        } else {\n                            //borrow a object from pool\n                            clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                        }\n                        theClient.setClientData(clientData);\n                    }\n                    //Check if max connection has reached\n                    if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                        theClient.setClientEvent(ClientEvent.MAX_CON);\n                    } else {\n                        theClient.setClientEvent(ClientEvent.ACCEPT);\n                    }\n                    try {\n                        _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                        logger.finest(\"Asking \" + _chPolled.getName() + \" to handle.\");\n                        _chPolled.handleClient(theClient);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.warning(\"Could not borrow ClientHandler Object from pool. Error: \" + nsee);\n                        logger.warning(\"Closing SocketChannel [\" + serverChannel.socket() + \"] since no ClientHandler available.\");\n                        socketChannel.close();\n                    }\n                    if (_chPolled !\u003d null) {\n                        try {\n                            getClientPool().addClient(_chPolled, true);\n                        } catch (java.util.NoSuchElementException nsee) {\n                            logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                            //logger.warning(\"Closing SocketChannel [\"+serverChannel.socket()+\"] since no Thread available.\");\n                            //socketChannel.close();\n                            //returnClientHandlerToPool(_chPolled);\n                        }\n                        _chPolled \u003d null;\n                    }\n                    socketChannel \u003d null;\n                    client \u003d null;\n                    //reset it back\n                    setSkipValidation(false);\n                } else if (key.isValid() \u0026\u0026 key.isReadable()) {\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Readable, removing OP_READ from interestOps for \" + _ch.getName());\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_READ));\n                        _ch.addEvent(ClientEvent.READ);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.READ);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (key.isValid() \u0026\u0026 key.isWritable()) {\n                    if (getClientPool().shouldNioWriteHappen() \u003d\u003d false) {\n                        //no need to remove the key\n                        continue;\n                    }\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Writable, removing OP_WRITE from interestOps for \" + _ch.getName());\n                        //remove OP_WRITE from interest set\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_WRITE));\n                        _ch.addEvent(ClientEvent.WRITE);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.WRITE);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (stopServer \u003d\u003d true \u0026\u0026 key.isAcceptable()) {\n                    //we will not accept this key\n                    //reset it back\n                    setSkipValidation(false);\n                } else {\n                    logger.warning(\"Unknown key got in SelectionKey: \" + key);\n                }\n                //Remove key\n                iterator.remove();\n                Thread.yield();\n            }\n            //end of iterator\n            iterator \u003d null;\n        }\n        //end of loop\n    }\n\n    private boolean checkAccessConstraint(Socket socket) {\n        try {\n            if (getAccessConstraintConfig() !\u003d null) {\n                getAccessConstraintConfig().checkAccept(socket);\n            }\n            return true;\n        } catch (SecurityException se) {\n            logger.warning(\"SecurityException occurred accepting connection : \" + se.getMessage());\n            return false;\n        }\n    }\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {\n        if (getSelector() \u003d\u003d null) {\n            throw new IllegalStateException(\"Selector is not open!\");\n        }\n        if (channel \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Can\u0027t register a null channel!\");\n        }\n        if (channel.isConnected() \u003d\u003d false) {\n            throw new ClosedChannelException();\n        }\n        RegisterChannelRequest req \u003d new RegisterChannelRequest(channel, ops, att);\n        RegisterChannelRequest reqOld \u003d null;\n        synchronized (registerChannelRequestMap) {\n            reqOld \u003d (RegisterChannelRequest) registerChannelRequestMap.get(channel);\n            if (reqOld \u003d\u003d null) {\n                registerChannelRequestMap.put(channel, req);\n                getSelector().wakeup();\n                return true;\n            } else {\n                if (reqOld.equals(req) \u003d\u003d false) {\n                    reqOld.setOps(reqOld.getOps() | req.getOps());\n                    reqOld.setAtt(req.getAtt());\n                    return true;\n                }\n                return false;\n            }\n        }\n        /*\n\t\tlogger.warning(\"Before register...\");\n\t\tchannel.register(getSelector(), ops, att);\n\t\tlogger.warning(\"Before wakeup and after register...\");\n\t\tgetSelector().wakeup();\n\t\tlogger.warning(\"After wakeup...\");\n\t\t*/\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig) {\n        logger.finer(\"Creating ByteBufferPool pool\");\n        int bufferSize \u003d getBasicConfig().getAdvancedSettings().getByteBufferSize();\n        boolean useDirectByteBuffer \u003d getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();\n        PoolableObjectFactory factory \u003d new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);\n        byteBufferPool \u003d poolManager.makeByteBufferPool(factory, opConfig);\n        poolManager.initPool(byteBufferPool, opConfig);\n    }\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool() {\n        return byteBufferPool;\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientThread pool\");\n        ThreadObjectFactory factory \u003d new ThreadObjectFactory();\n        ObjectPool objectPool \u003d poolManager.makeClientPool(factory, opConfig);\n        pool \u003d new ClientPool(makeQSObjectPool(objectPool), opConfig);\n        factory.setClientPool(pool);\n        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());\n        poolManager.initPool(objectPool, opConfig);\n    }\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler) {\n        clientWriteHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler() {\n        return clientWriteHandlerString;\n    }\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be \u003ccode\u003enull\u003c/code\u003e if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime() {\n        return lastStartTime;\n    }\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag) {\n        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);\n        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);\n    }\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier() {\n        return clientIdentifier;\n    }\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {\n        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);\n    }\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode() {\n        return blockingMode;\n    }\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception {\n        if (clientCommandHandlerString \u003d\u003d null \u0026\u0026 clientEventHandlerString \u003d\u003d null) {\n            logger.severe(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n            throw new AppException(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n        }\n        clientCommandHandler \u003d null;\n        if (clientCommandHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientCommandHandler class..\");\n            Class clientCommandHandlerClass \u003d getClass(clientCommandHandlerString, true);\n            clientCommandHandler \u003d (ClientCommandHandler) clientCommandHandlerClass.newInstance();\n        }\n        boolean setClientCommandHandlerLookup \u003d false;\n        clientEventHandler \u003d null;\n        if (clientEventHandlerString \u003d\u003d null) {\n            clientEventHandlerString \u003d \"org.quickserver.net.server.impl.DefaultClientEventHandler\";\n            setClientCommandHandlerLookup \u003d true;\n        }\n        logger.finest(\"Loading ClientEventHandler class..\");\n        if (clientEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientEventHandler.class.isInstance(clientCommandHandler)) {\n            clientEventHandler \u003d (ClientEventHandler) clientCommandHandler;\n        } else {\n            clientEventHandler \u003d (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();\n            if (setClientCommandHandlerLookup) {\n                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);\n            }\n        }\n        clientExtendedEventHandler \u003d null;\n        if (clientExtendedEventHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientExtendedEventHandler class..\");\n            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientCommandHandler;\n            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientEventHandler;\n            } else {\n                Class clientExtendedEventHandlerClass \u003d getClass(clientExtendedEventHandlerString, true);\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();\n            }\n        }\n        clientObjectHandler \u003d null;\n        if (clientObjectHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientObjectHandler class..\");\n            if (clientObjectHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientCommandHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientCommandHandler;\n            } else if (clientObjectHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientEventHandler;\n            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientExtendedEventHandler;\n            } else {\n                clientObjectHandler \u003d (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientBinaryHandler \u003d null;\n        if (clientBinaryHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientBinaryHandler class..\");\n            if (clientBinaryHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientCommandHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientCommandHandler;\n            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientExtendedEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientObjectHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientObjectHandler;\n            } else {\n                clientBinaryHandler \u003d (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientWriteHandler \u003d null;\n        if (clientWriteHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientWriteHandler class..\");\n            if (clientWriteHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientCommandHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientCommandHandler;\n            } else if (clientWriteHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientEventHandler;\n            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientExtendedEventHandler;\n            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientObjectHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientObjectHandler;\n            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientBinaryHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientBinaryHandler;\n            } else {\n                clientWriteHandler \u003d (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        Class authenticatorClass \u003d null;\n        if (clientAuthenticationHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientAuthenticationHandler class..\");\n            authenticatorClass \u003d getClass(clientAuthenticationHandlerString, true);\n        }\n        if (authenticatorClass !\u003d null) {\n            Object obj \u003d authenticatorClass.newInstance();\n            if (ClientAuthenticationHandler.class.isInstance(obj))\n                clientAuthenticationHandler \u003d (ClientAuthenticationHandler) obj;\n            else\n                authenticator \u003d (Authenticator) obj;\n        }\n        clientDataClass \u003d null;\n        if (clientDataString !\u003d null) {\n            logger.finest(\"Loading ClientData class..\");\n            clientDataClass \u003d getClass(clientDataString, true);\n        }\n        Assertion.affirm(clientEventHandler !\u003d null, \"ClientEventHandler was not loaded!\");\n    }\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler) {\n        clientEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler() {\n        return clientEventHandlerString;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {\n        if (dataType \u003d\u003d DataType.IN)\n            this.defaultDataModeIN \u003d dataMode;\n        if (dataType \u003d\u003d DataType.OUT)\n            this.defaultDataModeOUT \u003d dataMode;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {\n        defaultDataModeIN \u003d defaultDataMode.getDataMode(DataType.IN);\n        defaultDataModeOUT \u003d defaultDataMode.getDataMode(DataType.OUT);\n        ;\n    }\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType) {\n        if (dataType \u003d\u003d DataType.IN)\n            return defaultDataModeIN;\n        if (dataType \u003d\u003d DataType.OUT)\n            return defaultDataModeOUT;\n        else\n            throw new IllegalArgumentException(\"Unknown DataType: \" + dataType);\n    }\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler) {\n        clientExtendedEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler() {\n        return clientExtendedEventHandlerString;\n    }\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception {\n        if (getApplicationJarPath() !\u003d null \u0026\u0026 getClassLoader() \u003d\u003d null) {\n            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));\n            //update qsadmin to use the same\n            if (adminServer !\u003d null) {\n                adminServer.getServer().setClassLoader(getClassLoader());\n            }\n        }\n    }\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID() {\n        return pid;\n    }\n\n    public boolean isRawCommunicationLogging() {\n        return rawCommunicationLogging;\n    }\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {\n        this.rawCommunicationLogging \u003d rawCommunicationLogging;\n    }\n\n    public int getRawCommunicationMaxLength() {\n        return rawCommunicationMaxLength;\n    }\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {\n        this.rawCommunicationMaxLength \u003d rawCommunicationMaxLength;\n    }\n}\n",
    "package": "org.quickserver.net.server",
    "classname": "QuickServer",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_1Test.java",
    "test_prompt": "// QuickServer_1Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#getVersionNo()} method.\n*/\nclass QuickServer_1Test {",
    "method_signature": "getVersionNo()",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// QuickServer.java\n/*\n * This file is part of the QuickServer library \n * Copyright (C) QuickServer.org\n *\n * Use, modification, copying and distribution of this software is subject to\n * the terms and conditions of the GNU Lesser General Public License. \n * You should have received a copy of the GNU LGP License along with this \n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\n *\n * For questions, suggestions, bug-reports, enhancement-requests etc.\n * visit http://www.quickserver.org\n *\n */\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n *  Main class of QuickServer library. This class is used to create\n *  multi client servers quickly.\n *  \u003cp\u003e\n *  Ones a client is connected, it creates {@link ClientHandler} object,\n *  which is run using any thread available from the pool of threads\n *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n *  handles the client. \u003cbr/\u003e\n *  QuickServer divides the application logic of its developer over eight\n *  class, \u003cbr\u003e\n *  \t\u003cul\u003e\n * \t\t\u003cli\u003eClientEventHandler\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client events [Optional Class].\n *  \t\t\u003cli\u003eClientCommandHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client character/string commands.\n *  \t\t\u003cli\u003eClientObjectHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - Object commands.\n * \t\t\u003cli\u003eClientBinaryHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - binary data.\n * \t\t\u003cli\u003eClientWriteHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n *  \t\t\u003cli\u003eClientAuthenticationHandler [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Used to Authencatet a client.\n *  \t\t\u003cli\u003eClientData [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Client data carrier (support class)\n * \t\t\u003cli\u003eClientExtendedEventHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles extended client events.\n *  \t\u003c/ul\u003e\n *\n *  [#] \u003d Any one of these have to be set based on default DataMode for input.\n *  The default DataMode for input is String so if not changes you will\n *  have to set ClientCommandHandler.\n *  \u003c/p\u003e\n *  \u003cp\u003e\n *   Eg:\n *  \u003ccode\u003e\u003cBLOCKQUOTE\u003e\u003cpre\u003e\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle \u003d \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer \u003d new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * \u003c/pre\u003e\u003c/BLOCKQUOTE\u003e\u003c/code\u003e\u003c/p\u003e\n *\n *  @version 1.4.8\n *  @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //Some variable are not initialised to any value because the\n    //default java value was desired initial value.\n    //\u0027dev \u0027 \u003d development build not yet final\n    //\u0027beta\u0027 \u003d test build all features\n    //change also in QSAdminMain\n    private final static String VER \u003d \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n        if (System.getProperty(\"org.quickserver.useOSLineSeparator\") !\u003d null \u0026\u0026 System.getProperty(\"org.quickserver.useOSLineSeparator\").equals(\"true\")) {\n            NEW_LINE \u003d System.getProperty(\"line.separator\");\n        } else {\n            NEW_LINE \u003d \"\\r\\n\";\n        }\n        String _pid \u003d ManagementFactory.getRuntimeMXBean().getName();\n        int i \u003d _pid.indexOf(\"@\");\n        pid \u003d _pid.substring(0, i);\n        System.out.print(\"Loading QuickServer v\" + getVersion() + \" [PID:\" + pid + \"]\");\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort \u003d 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName \u003d \"QuickServer\";\n\n    private long maxConnection \u003d -1;\n\n    //1 min socket timeout\n    private int socketTimeout \u003d 60 * 1000;\n\n    private String maxConnectionMsg \u003d \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg \u003d \"-ERR Timeout\";\n\n    private String maxAuthTryMsg \u003d \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry \u003d 5;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //--v1.2\n    //Logger for QuickServer\n    private static final Logger logger \u003d Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //for Service interface\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState \u003d Service.UNKNOWN;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.3\n    private QuickServerConfig config \u003d new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel \u003d \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel \u003d \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation \u003d false;\n\n    private boolean communicationLogging \u003d true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig \u003d config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km \u003d null;\n\n    private TrustManager[] tm \u003d null;\n\n    private boolean runningSecure \u003d false;\n\n    private SecureStoreManager secureStoreManager \u003d null;\n\n    private Exception exceptionInRun \u003d null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode \u003d true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN \u003d DataMode.STRING;\n\n    private DataMode defaultDataModeOUT \u003d DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging \u003d false;\n\n    private int rawCommunicationMaxLength \u003d 100;\n\n    static {\n        System.out.println(\" Done\");\n        //should be commented if not a patch release\n        //System.out.println(\"[Includes patch(#): t\u003d152\u0026p\u003d532]\");\n        //should be commented if not a dev release\n        //System.out.println(\"[Dev Build Date: Saturday, October 29, 2005]\");\n        logger.log(Level.FINE, \"PID: {0}\", pid);\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion() {\n        return VER;\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo() {\n        return getVersionNo(VER);\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver) {\n        //String ver \u003d getVersion();\n        float version \u003d 0;\n        //check if beta\n        int i \u003d ver.indexOf(\" \");\n        if (i \u003d\u003d -1)\n            i \u003d ver.length();\n        ver \u003d ver.substring(0, i);\n        //check for sub version\n        i \u003d ver.indexOf(\".\");\n        if (i !\u003d -1) {\n            int j \u003d ver.indexOf(\".\", i);\n            if (j !\u003d -1) {\n                ver \u003d ver.substring(0, i) + \".\" + MyString.replaceAll(ver.substring(i + 1), \".\", \"\");\n            }\n        }\n        try {\n            version \u003d Float.parseFloat(ver);\n        } catch (NumberFormatException e) {\n            throw new RuntimeException(\"Corrupt QuickServer\");\n        }\n        return version;\n    }\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine() {\n        return NEW_LINE;\n    }\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString() {\n        return serverName + \" : \" + getPort();\n    }\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n        setClientCommandHandler(commandHandler);\n    }\n\n    /**\n     * Creates a new server at \u003ccode\u003eport\u003c/code\u003e with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n        //send to another constructor\n        this(commandHandler);\n        setPort(port);\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException {\n        logger.log(Level.FINE, \"Starting {0}\", getName());\n        if (isClosed() \u003d\u003d false) {\n            logger.log(Level.WARNING, \"Server {0} already running.\", getName());\n            throw new AppException(\"Server \" + getName() + \" already running.\");\n        }\n        blockingMode \u003d getBasicConfig().getServerMode().getBlocking();\n        if (getSecure().isEnable() \u0026\u0026 blockingMode \u003d\u003d false) {\n            //TODO we need to fix this..\n            logger.warning(\"QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode.\");\n            blockingMode \u003d true;\n            getBasicConfig().getServerMode().setBlocking(blockingMode);\n        }\n        if (serverBanner \u003d\u003d null) {\n            serverBanner \u003d \"\\n-------------------------------\" + \"\\n Name : \" + getName() + \"\\n Port : \" + getPort() + \"\\n-------------------------------\\n\";\n            logger.finest(\"Default Server Banner Generated\");\n        }\n        try {\n            loadApplicationClasses();\n            //load class from Advanced Settings\n            Class clientIdentifierClass \u003d getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);\n            clientIdentifier \u003d (ClientIdentifier) clientIdentifierClass.newInstance();\n            clientIdentifier.setQuickServer(QuickServer.this);\n            //load class from ObjectPoolConfig\n            Class poolManagerClass \u003d getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);\n            poolManager \u003d (PoolManager) poolManagerClass.newInstance();\n            //load class QSObjectPoolMaker\n            Class qsObjectPoolMakerClass \u003d getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);\n            qsObjectPoolMaker \u003d (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();\n            loadServerHooksClasses();\n            processServerHooks(ServerHook.PRE_STARTUP);\n            if (getSecure().isLoad() \u003d\u003d true)\n                //v1.4.0\n                loadSSLContext();\n            loadBusinessLogic();\n        } catch (ClassNotFoundException e) {\n            logger.log(Level.SEVERE, \"Could not load class/s: \" + e, e);\n            throw new AppException(\"Could not load class/s : \" + e);\n        } catch (InstantiationException e) {\n            logger.log(Level.SEVERE, \"Could not instantiate class/s: \" + e, e);\n            throw new AppException(\"Could not instantiate class/s: \" + e);\n        } catch (IllegalAccessException e) {\n            logger.log(Level.SEVERE, \"Illegal access to class/s: \" + e, e);\n            throw new AppException(\"Illegal access to class/s: \" + e);\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"IOException: \" + e, e);\n            throw new AppException(\"IOException: \" + e);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Exception: \" + e, e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Exception : \" + e);\n        }\n        //v1.3.3\n        if (getSecurityManagerClass() !\u003d null) {\n            System.setSecurityManager(getSecurityManager());\n        }\n        setServiceState(Service.INIT);\n        t \u003d new Thread(this, \"QuickServer - \" + getName());\n        t.start();\n        do {\n            Thread.yield();\n        } while (getServiceState() \u003d\u003d Service.INIT);\n        if (getServiceState() !\u003d Service.RUNNING) {\n            if (exceptionInRun !\u003d null)\n                throw new AppException(\"Could not start server \" + getName() + \"! Details: \" + exceptionInRun);\n            else\n                throw new AppException(\"Could not start server \" + getName());\n        }\n        lastStartTime \u003d new java.util.Date();\n        logger.log(Level.FINE, \"Started {0}, Date: {1}\", new Object[] { getName(), lastStartTime });\n    }\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException {\n        processServerHooks(ServerHook.PRE_SHUTDOWN);\n        logger.log(Level.WARNING, \"Stopping {0}\", getName());\n        stopServer \u003d true;\n        Socket death \u003d null;\n        if (isClosed() \u003d\u003d true) {\n            logger.log(Level.WARNING, \"Server {0} is not running!\", getName());\n            throw new AppException(\"Server \" + getName() + \" is not running!\");\n        }\n        try {\n            if (getBlockingMode() \u003d\u003d true) {\n                if (getSecure().isEnable() \u003d\u003d false) {\n                    death \u003d new Socket(server.getInetAddress(), server.getLocalPort());\n                    death.getInputStream().read();\n                    death.close();\n                } else {\n                    death \u003d getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());\n                    Thread.sleep(100);\n                    death.close();\n                }\n            }\n            if (serverSocketChannel !\u003d null) {\n                serverSocketChannel.close();\n            }\n        } catch (IOException e) {\n            logger.log(Level.FINE, \"IOError stopping {0}: {1}\", new Object[] { getName(), e });\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error stopping {0}: {1}\", new Object[] { getName(), e });\n            throw new AppException(\"Error in stopServer \" + getName() + \": \" + e);\n        }\n        for (int i \u003d 0; getServiceState() !\u003d Service.STOPPED; i++) {\n            try {\n                Thread.sleep(60);\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error waiting for {0} to fully stop. Error: {1}\", new Object[] { getName(), e });\n            }\n            if (i \u003e 1000) {\n                logger.severe(\"Server was not stopped even after 10sec.. will terminate now.\");\n                System.exit(-1);\n            }\n        }\n        if (adminServer \u003d\u003d null || getQSAdminServer().getServer() !\u003d this) {\n            //so this is not qsadmin\n            setClassLoader(null);\n        }\n        logger.log(Level.INFO, \"Stopped {0}\", getName());\n    }\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException {\n        stopServer();\n        startServer();\n    }\n\n    /**\n     * Returns the name of the QuickServer. Default is \u0027QuickServer\u0027.\n     * @see #setName\n     */\n    public String getName() {\n        return serverName;\n    }\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name) {\n        serverName \u003d name;\n        logger.log(Level.FINEST, \"Set to : {0}\", name);\n    }\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner() {\n        return serverBanner;\n    }\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. \u003cbr\u003e\u0026nbsp;\u003cbr\u003e\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner) {\n        serverBanner \u003d banner;\n        logger.log(Level.FINEST, \"Set to : {0}\", banner);\n    }\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port) {\n        if (port \u003c 0) {\n            throw new IllegalArgumentException(\"Port number can not be less than 0!\");\n        }\n        serverPort \u003d port;\n        logger.log(Level.FINEST, \"Set to {0}\", port);\n    }\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort() {\n        if (isClosed() \u003d\u003d false) {\n            return server.getLocalPort();\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            return serverPort;\n        } else {\n            int _port \u003d getSecure().getPort();\n            if (_port \u003d\u003d -1)\n                return serverPort;\n            else\n                return _port;\n        }\n    }\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler) {\n        clientCommandHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler() {\n        return clientCommandHandlerString;\n    }\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data) {\n        this.clientDataString \u003d data;\n        logger.log(Level.FINEST, \"Set to {0}\", data);\n    }\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData() {\n        return clientDataString;\n    }\n\n    /**\n     * Sets the client socket\u0027s timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time) {\n        if (time \u003e 0)\n            socketTimeout \u003d time;\n        else\n            socketTimeout \u003d 0;\n        logger.log(Level.FINEST, \"Set to {0}\", socketTimeout);\n    }\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout() {\n        return socketTimeout;\n    }\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry) {\n        maxAuthTry \u003d authTry;\n        logger.log(Level.FINEST, \"Set to {0}\", authTry);\n    }\n\n    /**\n     * Returns max allowed login attempts. Default is \u003ccode\u003e5\u003c/code\u003e.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry() {\n        return maxAuthTry;\n    }\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg) {\n        maxAuthTryMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg() {\n        return maxAuthTryMsg;\n    }\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg) {\n        timeoutMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg() {\n        return timeoutMsg;\n    }\n\n    private TheClient initTheClient() {\n        TheClient theClient \u003d new TheClient();\n        theClient.setServer(QuickServer.this);\n        theClient.setTimeoutMsg(getTimeoutMsg());\n        //v1.2\n        theClient.setMaxAuthTry(getMaxAuthTry());\n        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());\n        theClient.setClientEventHandler(clientEventHandler);\n        //v1.4.6\n        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);\n        theClient.setClientCommandHandler(clientCommandHandler);\n        //v1.2\n        theClient.setClientObjectHandler(clientObjectHandler);\n        //v1.4\n        theClient.setClientBinaryHandler(clientBinaryHandler);\n        //v1.4.5\n        theClient.setClientWriteHandler(clientWriteHandler);\n        //v1.3\n        theClient.setAuthenticator(authenticator);\n        //v1.4.6\n        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);\n        theClient.setTimeout(socketTimeout);\n        theClient.setMaxConnectionMsg(maxConnectionMsg);\n        //v1.3.2\n        theClient.setCommunicationLogging(getCommunicationLogging());\n        return theClient;\n    }\n\n    public void run() {\n        exceptionInRun \u003d null;\n        TheClient theClient \u003d initTheClient();\n        try {\n            stopServer \u003d false;\n            closeAllPools();\n            initAllPools();\n            makeServerSocket();\n            //print banner\n            System.out.println(serverBanner);\n            //v1.2\n            setServiceState(Service.RUNNING);\n            //v1.3.3\n            processServerHooks(ServerHook.POST_STARTUP);\n            if (getBlockingMode() \u003d\u003d false) {\n                runNonBlocking(theClient);\n                if (stopServer \u003d\u003d true) {\n                    logger.log(Level.FINEST, \"Closing selector for {0}\", getName());\n                    selector.close();\n                }\n                return;\n            } else {\n                runBlocking(theClient);\n            }\n        } catch (BindException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"{0} BindException for Port {1} @ {2} : {3}\", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });\n        } catch (javax.net.ssl.SSLException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"SSLException {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (IOException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"IOError {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (Exception e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"Error {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } finally {\n            if (getBlockingMode() \u003d\u003d true) {\n                logger.log(Level.WARNING, \"Closing {0}\", getName());\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            } else if (getBlockingMode() \u003d\u003d false \u0026\u0026 exceptionInRun !\u003d null) {\n                logger.log(Level.WARNING, \"Closing {0} - Had Error: {1}\", new Object[] { getName(), exceptionInRun });\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        if (serverSocketChannel !\u003d null)\n                            serverSocketChannel.close();\n                        if (server !\u003d null)\n                            server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n        }\n    }\n\n    //end of run\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnection \u003d maxConnection;\n        else\n            this.maxConnection \u003d maxConnection;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnection);\n    }\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection() {\n        return maxConnection;\n    }\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount() {\n        if (clientHandlerPool !\u003d null) {\n            try {\n                return getClientHandlerPool().getNumActive();\n            } catch (Exception e) {\n                return 0;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : \u003ccode\u003e-ERR Server Busy. Max Connection Reached\u003c/code\u003e\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n        else\n            this.maxConnectionMsg \u003d maxConnectionMsg;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnectionMsg);\n    }\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg() {\n        return maxConnectionMsg;\n    }\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException {\n        ipAddr \u003d InetAddress.getByName(bindAddr);\n        logger.log(Level.FINEST, \"Set to {0}\", bindAddr);\n    }\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr() {\n        if (ipAddr \u003d\u003d null) {\n            try {\n                ipAddr \u003d InetAddress.getByName(\"0.0.0.0\");\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Unable to create default ip(0.0.0.0) : {0}\", e);\n                throw new RuntimeException(\"Error: Unable to find servers own ip : \" + e);\n            }\n        }\n        return ipAddr;\n    }\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects) {\n        this.storeObjects \u003d storeObjects;\n    }\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return \u003ccode\u003enull\u003c/code\u003e.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects() {\n        return storeObjects;\n    }\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port) {\n        getQSAdminServer().getServer().setPort(port);\n    }\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort() {\n        return getQSAdminServer().getServer().getPort();\n    }\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator) {\n        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);\n    }\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator() {\n        return getQSAdminServer().getServer().getAuthenticator();\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException {\n        getQSAdminServer().setClientAuthenticationHandler(authenticator);\n        getQSAdminServer().startServer(port);\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException {\n        getQSAdminServer().startServer();\n    }\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer() {\n        if (adminServer \u003d\u003d null)\n            adminServer \u003d new QSAdminServer(QuickServer.this);\n        return adminServer;\n    }\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer) {\n        if (adminServer \u003d\u003d null)\n            this.adminServer \u003d adminServer;\n    }\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed() {\n        if (server \u003d\u003d null)\n            return true;\n        return server.isClosed();\n    }\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer\u0027s own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger() {\n        if (appLogger !\u003d null)\n            return appLogger;\n        return logger;\n    }\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger) {\n        this.appLogger \u003d appLogger;\n    }\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler) {\n        clientObjectHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler() {\n        return clientObjectHandlerString;\n    }\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n        if (formatter \u003d\u003d null)\n            return;\n        consoleLoggingformatter \u003d formatter;\n        java.util.logging.Formatter conformatter \u003d (java.util.logging.Formatter) getClass(formatter, true).newInstance();\n        Logger jdkLogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d jdkLogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                handlers[index].setFormatter(conformatter);\n            }\n        }\n        logger.log(Level.FINEST, \"Set to {0}\", formatter);\n    }\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter() {\n        return consoleLoggingformatter;\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MiniFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to logging.MiniFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MicroFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to MicroFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        boolean isConsole \u003d true;\n        try {\n            if (System.console() \u003d\u003d null) {\n                isConsole \u003d false;\n            }\n        } catch (Throwable e) {\n            //ignore\n        }\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                if (isConsole \u003d\u003d false \u0026\u0026 level !\u003d Level.OFF) {\n                    System.out.println(\"QuickServer: You do not have a console.. so turning console logger off..\");\n                    level \u003d Level.OFF;\n                }\n                if (level \u003d\u003d Level.OFF) {\n                    logger.info(\"QuickServer: Removing console handler.. \");\n                    rlogger.removeHandler(handlers[index]);\n                    handlers[index].setLevel(level);\n                    handlers[index].close();\n                } else {\n                    handlers[index].setLevel(level);\n                }\n            }\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            consoleLoggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            consoleLoggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            consoleLoggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            consoleLoggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            consoleLoggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            consoleLoggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            consoleLoggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            consoleLoggingLevel \u003d \"OFF\";\n        else\n            consoleLoggingLevel \u003d \"UNKNOWN\";\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel() {\n        return consoleLoggingLevel;\n    }\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            handlers[index].setLevel(level);\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            loggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            loggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            loggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            loggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            loggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            loggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            loggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            loggingLevel \u003d \"OFF\";\n        else\n            loggingLevel \u003d \"UNKNOWN\";\n        consoleLoggingLevel \u003d loggingLevel;\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    //*** Start of Service interface methods\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError() {\n        return serviceError;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param) {\n        serviceError \u003d null;\n        try {\n            initServer(param);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig) {\n        serviceError \u003d null;\n        try {\n            initServer(qsConfig);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING)\n            return false;\n        try {\n            startServer();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.STOPPED)\n            return false;\n        try {\n            stopServer();\n            clearAllPools();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING) {\n            suspendMaxConnection \u003d maxConnection;\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n            maxConnection \u003d 0;\n            maxConnectionMsg \u003d \"Service is suspended.\";\n            setServiceState(Service.SUSPENDED);\n            logger.log(Level.INFO, \"Service {0} is suspended.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.SUSPENDED) {\n            maxConnection \u003d suspendMaxConnection;\n            maxConnectionMsg \u003d suspendMaxConnectionMsg;\n            setServiceState(Service.RUNNING);\n            logger.log(Level.INFO, \"Service {0} resumed.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info() {\n        serviceError \u003d null;\n        StringBuilder buf \u003d new StringBuilder();\n        buf.append(getName()).append(\"\\n\");\n        buf.append(getBindAddr().getHostAddress()).append(\" \");\n        buf.append(getPort()).append(\"\\n\");\n        return buf.toString();\n    }\n\n    // *** End of Service interface methods\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException {\n        QuickServerConfig qsConfig \u003d null;\n        try {\n            qsConfig \u003d ConfigReader.read((String) param[0]);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not init server from xml file {0} : {1}\", new Object[] { new File((String) param[0]).getAbsolutePath(), e });\n            throw new AppException(\"Could not init server from xml file\", e);\n        }\n        initServer(qsConfig);\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {\n        setConfig(qsConfig);\n        try {\n            configQuickServer();\n            loadApplicationClasses();\n            //start InitServerHooks\n            InitServerHooks ish \u003d getConfig().getInitServerHooks();\n            if (ish !\u003d null) {\n                Iterator iterator \u003d ish.iterator();\n                String initServerHookClassName \u003d null;\n                Class initServerHookClass \u003d null;\n                InitServerHook initServerHook \u003d null;\n                while (iterator.hasNext()) {\n                    initServerHookClassName \u003d (String) iterator.next();\n                    initServerHookClass \u003d getClass(initServerHookClassName, true);\n                    initServerHook \u003d (InitServerHook) initServerHookClass.newInstance();\n                    logger.log(Level.INFO, \"Loaded init server hook: {0}\", initServerHookClassName);\n                    logger.log(Level.FINE, \"Init server hook info: {0}\", initServerHook.info());\n                    initServerHook.handleInit(QuickServer.this);\n                }\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not load init server hook: {0}\", e);\n            logger.log(Level.WARNING, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Could not load init server hook\", e);\n        }\n        setServiceState(Service.INIT);\n        logger.log(Level.FINEST, \"\\r\\n{0}\", MyString.getSystemInfo(getVersion()));\n    }\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState() {\n        return serviceState;\n    }\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state) {\n        serviceState \u003d state;\n    }\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp) {\n        if (temp.equals(\"SEVERE\"))\n            qs.setConsoleLoggingLevel(Level.SEVERE);\n        else if (temp.equals(\"WARNING\"))\n            qs.setConsoleLoggingLevel(Level.WARNING);\n        else if (temp.equals(\"INFO\"))\n            qs.setConsoleLoggingLevel(Level.INFO);\n        else if (temp.equals(\"CONFIG\"))\n            qs.setConsoleLoggingLevel(Level.CONFIG);\n        else if (temp.equals(\"FINE\"))\n            qs.setConsoleLoggingLevel(Level.FINE);\n        else if (temp.equals(\"FINER\"))\n            qs.setConsoleLoggingLevel(Level.FINER);\n        else if (temp.equals(\"FINEST\"))\n            qs.setConsoleLoggingLevel(Level.FINEST);\n        else if (temp.equals(\"OFF\"))\n            qs.setConsoleLoggingLevel(Level.OFF);\n        else\n            logger.log(Level.WARNING, \"unknown level {0}\", temp);\n    }\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception {\n        QuickServer qs \u003d QuickServer.this;\n        //v1.3\n        qs.setConfig(config);\n        qs.setBasicConfig(config);\n        String temp \u003d config.getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        temp \u003d null;\n        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        //v1.3.3\n        qs.setSecurityManagerClass(config.getSecurityManagerClass());\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        temp \u003d config.getApplicationJarPath();\n        if (temp !\u003d null) {\n            File ajp \u003d new File(temp);\n            if (ajp.isAbsolute() \u003d\u003d false) {\n                temp \u003d config.getConfigFile();\n                ajp \u003d new File(temp);\n                temp \u003d ajp.getParent() + File.separatorChar + config.getApplicationJarPath();\n                config.setApplicationJarPath(temp);\n                temp \u003d null;\n            }\n            qs.setApplicationJarPath(config.getApplicationJarPath());\n            //set path also to QSAdmin\n            if (config.getQSAdminServerConfig() !\u003d null) {\n                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());\n            }\n        }\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception {\n        QuickServer qs \u003d getQSAdminServer().getServer();\n        qs.setBasicConfig(config);\n        //set the Logging Level to same as main QS\n        //config.getConsoleLoggingLevel();\n        String temp \u003d getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        //set the Logging Formatter to same as main QS\n        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());\n        //v1.4.6\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        //v1.4.6\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());\n        //v1.3.2\n        if (config.getCommandShellEnable().equals(\"true\"))\n            getQSAdminServer().setShellEnable(true);\n        getQSAdminServer().setPromptName(config.getCommandShellPromptName());\n        //v1.3.3\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception {\n        configQuickServer(getConfig());\n        if (getConfig().getQSAdminServerConfig() !\u003d null) {\n            configQuickServer(getConfig().getQSAdminServerConfig());\n        }\n    }\n\n    /**\n     * Usage: QuickServer [-options]\u003cbr/\u003e\n     * Where options include:\u003cbr/\u003e\n     *   -about\t\tOpens About Dialogbox\u003cbr/\u003e\n     *   -load \u003cxml_config_file\u003e [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File \u003cnew_file_name\u003e\n     */\n    public static void main(String[] args) {\n        try {\n            if (args.length \u003e\u003d 1) {\n                if (args[0].equals(\"-about\")) {\n                    org.quickserver.net.server.gui.About.main(null);\n                } else if (args[0].equals(\"-load\") \u0026\u0026 args.length \u003e\u003d 2) {\n                    QuickServer qs \u003d QuickServer.load(args[1]);\n                    if (qs !\u003d null)\n                        handleOptions(args, qs);\n                } else {\n                    System.out.println(printUsage());\n                }\n            } else {\n                System.out.println(printUsage());\n                org.quickserver.net.server.gui.About.showAbout();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException {\n        QuickServer qs \u003d new QuickServer();\n        Object[] config \u003d new Object[] { xml };\n        qs.initServer(config);\n        qs.startServer();\n        if (qs.getConfig().getQSAdminServerConfig() !\u003d null) {\n            qs.startQSAdminServer();\n        }\n        return qs;\n    }\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage() {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"QuickServer - Java library/framework for creating robust multi-client TCP servers.\\n\");\n        sb.append(\"Copyright (C) QuickServer.org\\n\\n\");\n        sb.append(\"Usage: QuickServer [-options]\\n\");\n        sb.append(\"Where options include:\\n\");\n        sb.append(\"  -about\\t\" + \"Opens About Dialog box\\n\");\n        sb.append(\"  -load \u003cxml_config_file\u003e [load-options]\\t\" + \"Loads the server from xml file.\\n\");\n        sb.append(\"  Where load-options include:\\n\");\n        sb.append(\"     -fullXML2File \u003cfile_name\u003e\\t\" + \"Dumps the Full XML configuration of the QuickServer loaded.\\n\");\n        return sb.toString();\n    }\n\n    private static void handleOptions(String[] args, QuickServer quickserver) {\n        if (args.length \u003c 3)\n            return;\n        if (args[2].equals(\"-fullXML2File\") \u0026\u0026 args.length \u003e\u003d 4) {\n            File file \u003d new File(args[3]);\n            logger.log(Level.INFO, \"Writing full xml configuration to file: {0}\", file.getAbsolutePath());\n            try {\n                TextFile.write(file, quickserver.getConfig().toXML(null));\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error writing full xml configuration: {0}\", e);\n            }\n        }\n    }\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception {\n        try {\n            if (pool !\u003d null)\n                getClientPool().clear();\n            if (clientHandlerPool !\u003d null)\n                getClientHandlerPool().clear();\n            if (getClientDataPool() !\u003d null)\n                getClientDataPool().clear();\n            if (getDBPoolUtil() !\u003d null)\n                getDBPoolUtil().clean();\n            if (byteBufferPool !\u003d null)\n                getByteBufferPool().clear();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error: {0}\", e);\n            throw e;\n        }\n    }\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception {\n        if (pool \u003d\u003d null \u0026\u0026 clientHandlerPool \u003d\u003d null \u0026\u0026 getClientDataPool() \u003d\u003d null \u0026\u0026 getDBPoolUtil() \u003d\u003d null \u0026\u0026 byteBufferPool \u003d\u003d null) {\n            return;\n        }\n        logger.log(Level.FINE, \"Closing pools for {0}\", getName());\n        try {\n            if (pool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {\n                logger.finer(\"Closing ClientThread pool.\");\n                getClientPool().close();\n            }\n            if (clientHandlerPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientHandlerPool())) {\n                logger.finer(\"Closing ClientHandler pool.\");\n                getClientHandlerPool().close();\n            }\n            if (getClientDataPool() !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientDataPool())) {\n                logger.finer(\"Closing ClientData pool.\");\n                getClientDataPool().close();\n            }\n            if (getDBPoolUtil() !\u003d null) {\n                logger.finer(\"Closing DB pool.\");\n                getDBPoolUtil().clean();\n            }\n            if (byteBufferPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getByteBufferPool())) {\n                logger.finer(\"Closing ByteBuffer pool.\");\n                getByteBufferPool().close();\n            }\n            logger.log(Level.FINE, \"Closed pools for {0}\", getName());\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error closing pools for {0}: {1}\", new Object[] { getName(), e });\n            throw e;\n        }\n    }\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception {\n        logger.fine(\"Creating pools\");\n        if (getBlockingMode() \u003d\u003d false) {\n            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());\n        }\n        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());\n        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());\n        //check if client data is poolable\n        if (clientDataClass !\u003d null) {\n            try {\n                clientData \u003d (ClientData) clientDataClass.newInstance();\n                if (PoolableObject.class.isInstance(clientData) \u003d\u003d true) {\n                    PoolableObject po \u003d (PoolableObject) clientData;\n                    if (po.isPoolable() \u003d\u003d true) {\n                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());\n                    } else {\n                        clientDataPool \u003d null;\n                        logger.fine(\"ClientData is not poolable!\");\n                    }\n                }\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error: {0}\", e);\n                throw e;\n            }\n        }\n        try {\n            makeDBObjectPool();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error in makeDBObjectPool() : {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw e;\n        }\n        logger.fine(\"Created pools\");\n    }\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool() {\n        if (pool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientPool available yet!\");\n        return pool;\n    }\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientHandler pool\");\n        PoolableObjectFactory factory \u003d new ClientHandlerObjectFactory(getBlockingMode());\n        clientHandlerPool \u003d poolManager.makeClientHandlerPool(factory, opConfig);\n        poolManager.initPool(clientHandlerPool, opConfig);\n        clientHandlerPool \u003d makeQSObjectPool(clientHandlerPool);\n        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool() {\n        if (clientHandlerPool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientHandler Pool available yet!\");\n        return clientHandlerPool;\n    }\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config) {\n        this.config \u003d config;\n    }\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig() {\n        return config;\n    }\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientData pool\");\n        clientDataPool \u003d poolManager.makeClientDataPool(factory, opConfig);\n        poolManager.initPool(clientDataPool, opConfig);\n        clientDataPool \u003d makeQSObjectPool(clientDataPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool() {\n        return clientDataPool;\n    }\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return \u003ccode\u003enull\u003c/code\u003e\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil() {\n        return dBPoolUtil;\n    }\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {\n        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);\n    }\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception {\n        if (getConfig().getDBObjectPoolConfig() !\u003d null) {\n            logger.fine(\"Creating DBObject Pool\");\n            //logger.finest(\"Got:\\n\"+getConfig().getDBObjectPoolConfig().toXML(null));\n            Class dbPoolUtilClass \u003d getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);\n            dBPoolUtil \u003d (DBPoolUtil) dbPoolUtilClass.newInstance();\n            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());\n            dBPoolUtil.initPool();\n        }\n    }\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id) {\n        return clientIdentifier.findFirstClientById(id);\n    }\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  \u003ccode\u003e\u003cpre\u003e\n     *    Eg:\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tObject syncObj \u003d quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator \u003d quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tClientIdentifier clientIdentifier \u003d quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator \u003d clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    \u003c/code\u003e\u003c/pre\u003e\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient() {\n        return clientIdentifier.findAllClient();\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern) {\n        return clientIdentifier.findAllClientById(pattern);\n    }\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key) {\n        return clientIdentifier.findClientByKey(key);\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern) {\n        return clientIdentifier.findAllClientByKey(pattern);\n    }\n\n    /**\n     * Sets next client has a trusted client.\n     * \u003cp\u003eThis will skip any authentication and will not set any timeout.\u003c/p\u003e\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted() {\n        setSkipValidation(true);\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation() {\n        return skipValidation;\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation) {\n        skipValidation \u003d validation;\n    }\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging) {\n        this.communicationLogging \u003d communicationLogging;\n    }\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging() {\n        return communicationLogging;\n    }\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass) {\n        if (securityManagerClass !\u003d null)\n            this.securityManagerClass \u003d securityManagerClass;\n    }\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass() {\n        return securityManagerClass;\n    }\n\n    public SecurityManager getSecurityManager() throws AppException {\n        if (getSecurityManagerClass() \u003d\u003d null)\n            return null;\n        SecurityManager sm \u003d null;\n        try {\n            sm \u003d (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();\n        } catch (ClassNotFoundException e) {\n            throw new AppException(e.getMessage());\n        } catch (InstantiationException e) {\n            throw new AppException(e.getMessage());\n        } catch (IllegalAccessException e) {\n            throw new AppException(e.getMessage());\n        }\n        return sm;\n    }\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {\n        this.accessConstraintConfig \u003d accessConstraintConfig;\n    }\n\n    /**\n     * Returns Access constraints if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig() {\n        return accessConstraintConfig;\n    }\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader) {\n        this.classLoader \u003d classLoader;\n        Thread.currentThread().setContextClassLoader(classLoader);\n    }\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader() {\n        return classLoader;\n    }\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException {\n        if (name \u003d\u003d null)\n            throw new IllegalArgumentException(\"Class name can\u0027t be null!\");\n        logger.log(Level.FINEST, \"Class: {0}, reload: {1}\", new Object[] { name, reload });\n        if (reload \u003d\u003d true \u0026\u0026 classLoader !\u003d null) {\n            return classLoader.loadClass(name);\n        } else if (reload \u003d\u003d true \u0026\u0026 classLoader \u003d\u003d null \u0026\u0026 this.getClass().getClassLoader() !\u003d null) {\n            return this.getClass().getClassLoader().loadClass(name);\n        } else if (reload \u003d\u003d false \u0026\u0026 classLoader !\u003d null) {\n            return Class.forName(name, true, classLoader);\n        } else /*if(reload\u003d\u003dfalse \u0026\u0026 classLoader\u003d\u003dnull)*/\n        {\n            return Class.forName(name, true, this.getClass().getClassLoader());\n        }\n    }\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath) {\n        this.applicationJarPath \u003d applicationJarPath;\n    }\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath() {\n        return applicationJarPath;\n    }\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks) {\n        this.serverHooks \u003d serverHooks;\n    }\n\n    /**\n     * Returns ServerHooks if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks() {\n        if (serverHooks \u003d\u003d null)\n            serverHooks \u003d new ServerHooks();\n        return serverHooks;\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses() {\n        if (getServerHooks() \u003d\u003d null)\n            return;\n        listOfServerHooks \u003d new ArrayList();\n        ServerHook serverHook \u003d null;\n        String serverHookClassName \u003d null;\n        Class serverHookClass \u003d null;\n        //add system hooks\n        serverHook \u003d new GhostSocketReaper();\n        serverHook.initHook(QuickServer.this);\n        listOfServerHooks.add(serverHook);\n        ghostSocketReaper \u003d (GhostSocketReaper) serverHook;\n        //add user hooks if any\n        Iterator iterator \u003d getServerHooks().iterator();\n        while (iterator.hasNext()) {\n            serverHookClassName \u003d (String) iterator.next();\n            try {\n                serverHookClass \u003d getClass(serverHookClassName, true);\n                serverHook \u003d (ServerHook) serverHookClass.newInstance();\n                serverHook.initHook(QuickServer.this);\n                listOfServerHooks.add(serverHook);\n                logger.log(Level.INFO, \"Loaded server hook: {0}\", serverHookClassName);\n                logger.log(Level.FINE, \"Server hook info: {0}\", serverHook.info());\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Could not load server hook [{0}]: {1}\", new Object[] { serverHookClassName, e });\n                logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            }\n        }\n        //end of while\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event) {\n        if (listOfServerHooks \u003d\u003d null) {\n            logger.warning(\"listOfServerHooks was null!\");\n            return;\n        }\n        ServerHook serverHook \u003d null;\n        boolean result \u003d false;\n        Iterator iterator \u003d listOfServerHooks.iterator();\n        String hooktype \u003d \"UNKNOWN\";\n        switch(event) {\n            case ServerHook.PRE_STARTUP:\n                hooktype \u003d \"PRE_STARTUP\";\n                break;\n            case ServerHook.POST_STARTUP:\n                hooktype \u003d \"POST_STARTUP\";\n                break;\n            case ServerHook.PRE_SHUTDOWN:\n                hooktype \u003d \"PRE_SHUTDOWN\";\n                break;\n            case ServerHook.POST_SHUTDOWN:\n                hooktype \u003d \"POST_SHUTDOWN\";\n                break;\n        }\n        while (iterator.hasNext()) {\n            serverHook \u003d (ServerHook) iterator.next();\n            try {\n                result \u003d serverHook.handleEvent(event);\n            } catch (Exception e) {\n                result \u003d false;\n                logger.log(Level.WARNING, \"Error invoking {0} hook [{1}]: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });\n            }\n            logger.log(Level.FINE, \"Invoked {0} hook [{1}] was: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), result });\n        }\n    }\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone() {\n        Object object \u003d null;\n        try {\n            object \u003d super.clone();\n            QuickServer _qs \u003d (QuickServer) object;\n            _qs.setQSAdminServer(new QSAdminServer(_qs));\n        } catch (CloneNotSupportedException e) {\n            //should not happ\n            logger.log(Level.WARNING, \"Error cloning : {0}\", e);\n        }\n        return object;\n    }\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure) {\n        this.secure \u003d secure;\n    }\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure() {\n        if (secure \u003d\u003d null)\n            secure \u003d new Secure();\n        return secure;\n    }\n\n    /**\n     * \u003cp\u003eReturns if the server is running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure() {\n        return runningSecure;\n    }\n\n    /**\n     * \u003cp\u003eSets the server mode if its running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure) {\n        this.runningSecure \u003d runningSecure;\n    }\n\n    private File makeAbsoluteToConfig(String fileName) {\n        Assertion.affirm(fileName !\u003d null, \"FileName can\u0027t be null\");\n        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());\n    }\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException {\n        server \u003d null;\n        logger.log(Level.FINEST, \"Binding {0} to IP: {1}\", new Object[] { getName(), getBindAddr() });\n        InetSocketAddress bindAddress \u003d new InetSocketAddress(getBindAddr(), getPort());\n        try {\n            NetworkInterface ni \u003d NetworkInterface.getByInetAddress(getBindAddr());\n            if (ni !\u003d null) {\n                logger.fine(\"NetworkInterface: \" + ni);\n            }\n        } catch (Exception igrnore) {\n            /*ignore*/\n        } catch (Error igrnore) {\n            /*ignore*/\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Making a normal ServerSocket for {0}\", getName());\n            setRunningSecure(false);\n            if (getBlockingMode() \u003d\u003d false) {\n                //for non-blocking\n                serverSocketChannel \u003d ServerSocketChannel.open();\n                server \u003d serverSocketChannel.socket();\n                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n            } else {\n                //for blocking\n                server \u003d new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n            }\n        } else {\n            try {\n                logger.log(Level.FINE, \"Making a secure ServerSocket for {0}\", getName());\n                getSSLContext();\n                setRunningSecure(true);\n                if (getBlockingMode() \u003d\u003d false) {\n                    logger.log(Level.FINE, \"Making a secure ServerSocketChannel for {0}\", getName());\n                    //for non-blocking\n                    serverSocketChannel \u003d ServerSocketChannel.open();\n                    server \u003d serverSocketChannel.socket();\n                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n                } else {\n                    ServerSocketFactory ssf \u003d getSSLContext().getServerSocketFactory();\n                    SSLServerSocket serversocket \u003d (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());\n                    setRunningSecure(true);\n                    secureStoreManager.logSSLServerSocketInfo(serversocket);\n                    server \u003d serversocket;\n                    serverSocketChannel \u003d server.getChannel();\n                    if (serverSocketChannel \u003d\u003d null \u0026\u0026 getBlockingMode() \u003d\u003d false) {\n                        logger.warning(\"Secure Server does not support Channel! So will run in blocking mode.\");\n                        blockingMode \u003d false;\n                    }\n                }\n                //blocking\n            } catch (NoSuchAlgorithmException e) {\n                logger.log(Level.WARNING, \"NoSuchAlgorithmException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            } catch (KeyManagementException e) {\n                logger.log(Level.WARNING, \"KeyManagementException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            }\n        }\n        server.setReuseAddress(true);\n        int connectionTime \u003d 0;\n        int latency \u003d 0;\n        int bandwidth \u003d 0;\n        connectionTime \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();\n        latency \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();\n        bandwidth \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();\n        logger.log(Level.FINE, \"getPerformancePreferencesConnectionTime : {0}\", connectionTime);\n        logger.log(Level.FINE, \"getPerformancePreferencesLatency : {0}\", latency);\n        logger.log(Level.FINE, \"getPerformancePreferencesBandwidth : {0}\", bandwidth);\n        server.setPerformancePreferences(connectionTime, latency, bandwidth);\n        int clientSocketReceiveBufferSize \u003d getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();\n        if (clientSocketReceiveBufferSize \u003e 0) {\n            logger.log(Level.FINE, \"clientSocketReceiveBufferSize: {0}\", clientSocketReceiveBufferSize);\n            server.setReceiveBufferSize(clientSocketReceiveBufferSize);\n        }\n        if (getBlockingMode() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Server Mode {0} - Non Blocking\", getName());\n            if (selector \u003d\u003d null || selector.isOpen() \u003d\u003d false) {\n                logger.finest(\"Opening new selector\");\n                selector \u003d Selector.open();\n            } else {\n                logger.log(Level.FINEST, \"Reusing selector: {0}\", selector);\n            }\n            serverSocketChannel.configureBlocking(false);\n            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n            selector.wakeup();\n        } else {\n            logger.log(Level.FINE, \"Server Mode {0} - Blocking\", getName());\n        }\n    }\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {\n        Assertion.affirm(basicConfig !\u003d null, \"BasicServerConfig can\u0027t be null\");\n        this.basicConfig \u003d basicConfig;\n    }\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig() {\n        return basicConfig;\n    }\n\n    /**\n     * Loads the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException {\n        if (getSecure().isLoad() \u003d\u003d false) {\n            throw new IllegalStateException(\"Secure setting is not yet enabled for loading!\");\n        }\n        logger.info(\"Loading Secure Context..\");\n        km \u003d null;\n        tm \u003d null;\n        try {\n            String ssManager \u003d \"org.quickserver.security.SecureStoreManager\";\n            if (getSecure().getSecureStore() !\u003d null)\n                ssManager \u003d getSecure().getSecureStore().getSecureStoreManager();\n            Class secureStoreManagerClass \u003d getClass(ssManager, true);\n            secureStoreManager \u003d (SecureStoreManager) secureStoreManagerClass.newInstance();\n            km \u003d secureStoreManager.loadKeyManagers(getConfig());\n            logger.fine(\"KeyManager got\");\n            tm \u003d secureStoreManager.loadTrustManagers(getConfig());\n            logger.fine(\"TrustManager got\");\n            sslc \u003d secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());\n            sslc.init(km, tm, null);\n            logger.fine(\"SSLContext loaded\");\n        } catch (KeyStoreException e) {\n            logger.warning(\"KeyStoreException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchAlgorithmException e) {\n            logger.warning(\"NoSuchAlgorithmException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchProviderException e) {\n            logger.warning(\"NoSuchProviderException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (UnrecoverableKeyException e) {\n            logger.warning(\"UnrecoverableKeyException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (CertificateException e) {\n            logger.warning(\"CertificateException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (KeyManagementException e) {\n            logger.warning(\"KeyManagementException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (GeneralSecurityException e) {\n            logger.warning(\"GeneralSecurityException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (ClassNotFoundException e) {\n            logger.warning(\"ClassNotFoundException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (InstantiationException e) {\n            logger.warning(\"InstantiationException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (IllegalAccessException e) {\n            logger.warning(\"IllegalAccessException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        return getSSLContext(null);\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        if (protocol !\u003d null \u0026\u0026 secureStoreManager !\u003d null) {\n            SSLContext _sslc \u003d secureStoreManager.getSSLContext(protocol);\n            _sslc.init(km, tm, null);\n            return _sslc;\n        }\n        return sslc;\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext());\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext(protocol));\n    }\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler) {\n        clientBinaryHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler() {\n        return clientBinaryHandlerString;\n    }\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector) {\n        this.selector \u003d selector;\n    }\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector() {\n        return selector;\n    }\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception {\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        //long stime \u003d System.currentTimeMillis();\n        //long etime \u003d System.currentTimeMillis();\n        while (true) {\n            //etime \u003d System.currentTimeMillis();\n            //System.out.println(\"Time Taken: \"+(etime-stime));\n            client \u003d server.accept();\n            //stime \u003d System.currentTimeMillis();\n            if (linger \u003c 0) {\n                client.setSoLinger(false, 0);\n            } else {\n                client.setSoLinger(true, linger);\n            }\n            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                //low delay\u003d10\n                client.setTrafficClass(socketTrafficClass);\n            }\n            logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n            }\n            if (stopServer) {\n                //Client connected when server was about to be shutdown.\n                try {\n                    client.close();\n                } catch (Exception e) {\n                }\n                break;\n            }\n            if (checkAccessConstraint(client) \u003d\u003d false) {\n                continue;\n            }\n            //Check if max connection has reached\n            if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);\n            } else {\n                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);\n            }\n            theClient.setTrusted(getSkipValidation());\n            theClient.setSocket(client);\n            //mostly null\n            theClient.setSocketChannel(client.getChannel());\n            if (clientDataClass !\u003d null) {\n                if (getClientDataPool() \u003d\u003d null) {\n                    clientData \u003d (ClientData) clientDataClass.newInstance();\n                } else {\n                    clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                }\n                theClient.setClientData(clientData);\n            }\n            try {\n                _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                _chPolled.handleClient(theClient);\n            } catch (java.util.NoSuchElementException nsee) {\n                logger.warning(\"Could not borrow ClientHandler from pool. Error: \" + nsee);\n                logger.warning(\"Closing Socket [\" + client + \"] since no ClientHandler available.\");\n                client.close();\n            }\n            if (_chPolled !\u003d null) {\n                try {\n                    getClientPool().addClient(_chPolled, true);\n                } catch (java.util.NoSuchElementException nsee) {\n                    logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                    //logger.warning(\"Closing Socket [\"+client+\"] since no Thread available.\");\n                    //client.close();\n                    //returnClientHandlerToPool(_chPolled);\n                }\n                _chPolled \u003d null;\n            }\n            client \u003d null;\n            //reset it back\n            setSkipValidation(false);\n        }\n        //end of loop\n    }\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception {\n        int selectCount \u003d 0;\n        Iterator iterator \u003d null;\n        SelectionKey key \u003d null;\n        ServerSocketChannel serverChannel \u003d null;\n        SocketChannel socketChannel \u003d null;\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        boolean stopServerProcessed \u003d false;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        registerChannelRequestMap \u003d new HashMap();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        while (true) {\n            selectCount \u003d selector.select(500);\n            //selectCount \u003d selector.select();//for testing\n            //check for any pending registerChannel req.\n            synchronized (registerChannelRequestMap) {\n                if (registerChannelRequestMap.size() \u003e 0) {\n                    RegisterChannelRequest req \u003d null;\n                    Object hashkey \u003d null;\n                    iterator \u003d registerChannelRequestMap.keySet().iterator();\n                    while (iterator.hasNext()) {\n                        hashkey \u003d iterator.next();\n                        req \u003d (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);\n                        req.register(getSelector());\n                    }\n                    iterator \u003d null;\n                    registerChannelRequestMap.clear();\n                }\n                //if\n            }\n            //sync\n            if (stopServer \u003d\u003d true \u0026\u0026 stopServerProcessed \u003d\u003d false) {\n                logger.warning(\"Closing \" + getName());\n                serverSocketChannel.close();\n                stopServerProcessed \u003d true;\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.warning(\"Closed \" + getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n            if (stopServer \u003d\u003d false \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                logger.finest(\"Server must have re-started.. will break\");\n                break;\n            }\n            if (selectCount \u003d\u003d 0 \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                java.util.Set keyset \u003d selector.keys();\n                if (keyset.isEmpty() \u003d\u003d true \u0026\u0026 getClientCount() \u003c\u003d 0) {\n                    break;\n                } else {\n                    continue;\n                }\n            } else if (selectCount \u003d\u003d 0) {\n                continue;\n            }\n            iterator \u003d selector.selectedKeys().iterator();\n            while (iterator.hasNext()) {\n                key \u003d (SelectionKey) iterator.next();\n                if (key.isValid() \u003d\u003d false) {\n                    iterator.remove();\n                    continue;\n                }\n                if (key.isAcceptable() \u0026\u0026 stopServer \u003d\u003d false) {\n                    logger.finest(\"Key is Acceptable\");\n                    serverChannel \u003d (ServerSocketChannel) key.channel();\n                    socketChannel \u003d serverChannel.accept();\n                    if (socketChannel \u003d\u003d null) {\n                        iterator.remove();\n                        continue;\n                    }\n                    client \u003d socketChannel.socket();\n                    if (linger \u003c 0) {\n                        client.setSoLinger(false, 0);\n                    } else {\n                        client.setSoLinger(true, linger);\n                    }\n                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                        //low delay\u003d10\n                        client.setTrafficClass(socketTrafficClass);\n                    }\n                    logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                        logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n                    }\n                    if (checkAccessConstraint(client) \u003d\u003d false) {\n                        iterator.remove();\n                        continue;\n                    }\n                    socketChannel.configureBlocking(false);\n                    theClient.setTrusted(getSkipValidation());\n                    theClient.setSocket(socketChannel.socket());\n                    theClient.setSocketChannel(socketChannel);\n                    if (clientDataClass !\u003d null) {\n                        if (getClientDataPool() \u003d\u003d null) {\n                            clientData \u003d (ClientData) clientDataClass.newInstance();\n                        } else {\n                            //borrow a object from pool\n                            clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                        }\n                        theClient.setClientData(clientData);\n                    }\n                    //Check if max connection has reached\n                    if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                        theClient.setClientEvent(ClientEvent.MAX_CON);\n                    } else {\n                        theClient.setClientEvent(ClientEvent.ACCEPT);\n                    }\n                    try {\n                        _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                        logger.finest(\"Asking \" + _chPolled.getName() + \" to handle.\");\n                        _chPolled.handleClient(theClient);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.warning(\"Could not borrow ClientHandler Object from pool. Error: \" + nsee);\n                        logger.warning(\"Closing SocketChannel [\" + serverChannel.socket() + \"] since no ClientHandler available.\");\n                        socketChannel.close();\n                    }\n                    if (_chPolled !\u003d null) {\n                        try {\n                            getClientPool().addClient(_chPolled, true);\n                        } catch (java.util.NoSuchElementException nsee) {\n                            logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                            //logger.warning(\"Closing SocketChannel [\"+serverChannel.socket()+\"] since no Thread available.\");\n                            //socketChannel.close();\n                            //returnClientHandlerToPool(_chPolled);\n                        }\n                        _chPolled \u003d null;\n                    }\n                    socketChannel \u003d null;\n                    client \u003d null;\n                    //reset it back\n                    setSkipValidation(false);\n                } else if (key.isValid() \u0026\u0026 key.isReadable()) {\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Readable, removing OP_READ from interestOps for \" + _ch.getName());\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_READ));\n                        _ch.addEvent(ClientEvent.READ);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.READ);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (key.isValid() \u0026\u0026 key.isWritable()) {\n                    if (getClientPool().shouldNioWriteHappen() \u003d\u003d false) {\n                        //no need to remove the key\n                        continue;\n                    }\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Writable, removing OP_WRITE from interestOps for \" + _ch.getName());\n                        //remove OP_WRITE from interest set\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_WRITE));\n                        _ch.addEvent(ClientEvent.WRITE);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.WRITE);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (stopServer \u003d\u003d true \u0026\u0026 key.isAcceptable()) {\n                    //we will not accept this key\n                    //reset it back\n                    setSkipValidation(false);\n                } else {\n                    logger.warning(\"Unknown key got in SelectionKey: \" + key);\n                }\n                //Remove key\n                iterator.remove();\n                Thread.yield();\n            }\n            //end of iterator\n            iterator \u003d null;\n        }\n        //end of loop\n    }\n\n    private boolean checkAccessConstraint(Socket socket) {\n        try {\n            if (getAccessConstraintConfig() !\u003d null) {\n                getAccessConstraintConfig().checkAccept(socket);\n            }\n            return true;\n        } catch (SecurityException se) {\n            logger.warning(\"SecurityException occurred accepting connection : \" + se.getMessage());\n            return false;\n        }\n    }\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {\n        if (getSelector() \u003d\u003d null) {\n            throw new IllegalStateException(\"Selector is not open!\");\n        }\n        if (channel \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Can\u0027t register a null channel!\");\n        }\n        if (channel.isConnected() \u003d\u003d false) {\n            throw new ClosedChannelException();\n        }\n        RegisterChannelRequest req \u003d new RegisterChannelRequest(channel, ops, att);\n        RegisterChannelRequest reqOld \u003d null;\n        synchronized (registerChannelRequestMap) {\n            reqOld \u003d (RegisterChannelRequest) registerChannelRequestMap.get(channel);\n            if (reqOld \u003d\u003d null) {\n                registerChannelRequestMap.put(channel, req);\n                getSelector().wakeup();\n                return true;\n            } else {\n                if (reqOld.equals(req) \u003d\u003d false) {\n                    reqOld.setOps(reqOld.getOps() | req.getOps());\n                    reqOld.setAtt(req.getAtt());\n                    return true;\n                }\n                return false;\n            }\n        }\n        /*\n\t\tlogger.warning(\"Before register...\");\n\t\tchannel.register(getSelector(), ops, att);\n\t\tlogger.warning(\"Before wakeup and after register...\");\n\t\tgetSelector().wakeup();\n\t\tlogger.warning(\"After wakeup...\");\n\t\t*/\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig) {\n        logger.finer(\"Creating ByteBufferPool pool\");\n        int bufferSize \u003d getBasicConfig().getAdvancedSettings().getByteBufferSize();\n        boolean useDirectByteBuffer \u003d getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();\n        PoolableObjectFactory factory \u003d new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);\n        byteBufferPool \u003d poolManager.makeByteBufferPool(factory, opConfig);\n        poolManager.initPool(byteBufferPool, opConfig);\n    }\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool() {\n        return byteBufferPool;\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientThread pool\");\n        ThreadObjectFactory factory \u003d new ThreadObjectFactory();\n        ObjectPool objectPool \u003d poolManager.makeClientPool(factory, opConfig);\n        pool \u003d new ClientPool(makeQSObjectPool(objectPool), opConfig);\n        factory.setClientPool(pool);\n        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());\n        poolManager.initPool(objectPool, opConfig);\n    }\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler) {\n        clientWriteHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler() {\n        return clientWriteHandlerString;\n    }\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be \u003ccode\u003enull\u003c/code\u003e if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime() {\n        return lastStartTime;\n    }\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag) {\n        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);\n        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);\n    }\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier() {\n        return clientIdentifier;\n    }\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {\n        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);\n    }\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode() {\n        return blockingMode;\n    }\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception {\n        if (clientCommandHandlerString \u003d\u003d null \u0026\u0026 clientEventHandlerString \u003d\u003d null) {\n            logger.severe(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n            throw new AppException(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n        }\n        clientCommandHandler \u003d null;\n        if (clientCommandHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientCommandHandler class..\");\n            Class clientCommandHandlerClass \u003d getClass(clientCommandHandlerString, true);\n            clientCommandHandler \u003d (ClientCommandHandler) clientCommandHandlerClass.newInstance();\n        }\n        boolean setClientCommandHandlerLookup \u003d false;\n        clientEventHandler \u003d null;\n        if (clientEventHandlerString \u003d\u003d null) {\n            clientEventHandlerString \u003d \"org.quickserver.net.server.impl.DefaultClientEventHandler\";\n            setClientCommandHandlerLookup \u003d true;\n        }\n        logger.finest(\"Loading ClientEventHandler class..\");\n        if (clientEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientEventHandler.class.isInstance(clientCommandHandler)) {\n            clientEventHandler \u003d (ClientEventHandler) clientCommandHandler;\n        } else {\n            clientEventHandler \u003d (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();\n            if (setClientCommandHandlerLookup) {\n                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);\n            }\n        }\n        clientExtendedEventHandler \u003d null;\n        if (clientExtendedEventHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientExtendedEventHandler class..\");\n            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientCommandHandler;\n            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientEventHandler;\n            } else {\n                Class clientExtendedEventHandlerClass \u003d getClass(clientExtendedEventHandlerString, true);\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();\n            }\n        }\n        clientObjectHandler \u003d null;\n        if (clientObjectHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientObjectHandler class..\");\n            if (clientObjectHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientCommandHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientCommandHandler;\n            } else if (clientObjectHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientEventHandler;\n            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientExtendedEventHandler;\n            } else {\n                clientObjectHandler \u003d (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientBinaryHandler \u003d null;\n        if (clientBinaryHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientBinaryHandler class..\");\n            if (clientBinaryHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientCommandHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientCommandHandler;\n            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientExtendedEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientObjectHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientObjectHandler;\n            } else {\n                clientBinaryHandler \u003d (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientWriteHandler \u003d null;\n        if (clientWriteHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientWriteHandler class..\");\n            if (clientWriteHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientCommandHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientCommandHandler;\n            } else if (clientWriteHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientEventHandler;\n            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientExtendedEventHandler;\n            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientObjectHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientObjectHandler;\n            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientBinaryHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientBinaryHandler;\n            } else {\n                clientWriteHandler \u003d (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        Class authenticatorClass \u003d null;\n        if (clientAuthenticationHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientAuthenticationHandler class..\");\n            authenticatorClass \u003d getClass(clientAuthenticationHandlerString, true);\n        }\n        if (authenticatorClass !\u003d null) {\n            Object obj \u003d authenticatorClass.newInstance();\n            if (ClientAuthenticationHandler.class.isInstance(obj))\n                clientAuthenticationHandler \u003d (ClientAuthenticationHandler) obj;\n            else\n                authenticator \u003d (Authenticator) obj;\n        }\n        clientDataClass \u003d null;\n        if (clientDataString !\u003d null) {\n            logger.finest(\"Loading ClientData class..\");\n            clientDataClass \u003d getClass(clientDataString, true);\n        }\n        Assertion.affirm(clientEventHandler !\u003d null, \"ClientEventHandler was not loaded!\");\n    }\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler) {\n        clientEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler() {\n        return clientEventHandlerString;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {\n        if (dataType \u003d\u003d DataType.IN)\n            this.defaultDataModeIN \u003d dataMode;\n        if (dataType \u003d\u003d DataType.OUT)\n            this.defaultDataModeOUT \u003d dataMode;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {\n        defaultDataModeIN \u003d defaultDataMode.getDataMode(DataType.IN);\n        defaultDataModeOUT \u003d defaultDataMode.getDataMode(DataType.OUT);\n        ;\n    }\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType) {\n        if (dataType \u003d\u003d DataType.IN)\n            return defaultDataModeIN;\n        if (dataType \u003d\u003d DataType.OUT)\n            return defaultDataModeOUT;\n        else\n            throw new IllegalArgumentException(\"Unknown DataType: \" + dataType);\n    }\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler) {\n        clientExtendedEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler() {\n        return clientExtendedEventHandlerString;\n    }\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception {\n        if (getApplicationJarPath() !\u003d null \u0026\u0026 getClassLoader() \u003d\u003d null) {\n            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));\n            //update qsadmin to use the same\n            if (adminServer !\u003d null) {\n                adminServer.getServer().setClassLoader(getClassLoader());\n            }\n        }\n    }\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID() {\n        return pid;\n    }\n\n    public boolean isRawCommunicationLogging() {\n        return rawCommunicationLogging;\n    }\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {\n        this.rawCommunicationLogging \u003d rawCommunicationLogging;\n    }\n\n    public int getRawCommunicationMaxLength() {\n        return rawCommunicationMaxLength;\n    }\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {\n        this.rawCommunicationMaxLength \u003d rawCommunicationMaxLength;\n    }\n}\n",
    "package": "org.quickserver.net.server",
    "classname": "QuickServer",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_3Test.java",
    "test_prompt": "// QuickServer_3Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#getNewLine()} method.\n*/\nclass QuickServer_3Test {",
    "method_signature": "getNewLine()",
    "suffix": "3"
  },
  {
    "numberTests": "ten",
    "original_code": "// QuickServer.java\n/*\n * This file is part of the QuickServer library \n * Copyright (C) QuickServer.org\n *\n * Use, modification, copying and distribution of this software is subject to\n * the terms and conditions of the GNU Lesser General Public License. \n * You should have received a copy of the GNU LGP License along with this \n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\n *\n * For questions, suggestions, bug-reports, enhancement-requests etc.\n * visit http://www.quickserver.org\n *\n */\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n *  Main class of QuickServer library. This class is used to create\n *  multi client servers quickly.\n *  \u003cp\u003e\n *  Ones a client is connected, it creates {@link ClientHandler} object,\n *  which is run using any thread available from the pool of threads\n *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n *  handles the client. \u003cbr/\u003e\n *  QuickServer divides the application logic of its developer over eight\n *  class, \u003cbr\u003e\n *  \t\u003cul\u003e\n * \t\t\u003cli\u003eClientEventHandler\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client events [Optional Class].\n *  \t\t\u003cli\u003eClientCommandHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client character/string commands.\n *  \t\t\u003cli\u003eClientObjectHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - Object commands.\n * \t\t\u003cli\u003eClientBinaryHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - binary data.\n * \t\t\u003cli\u003eClientWriteHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n *  \t\t\u003cli\u003eClientAuthenticationHandler [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Used to Authencatet a client.\n *  \t\t\u003cli\u003eClientData [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Client data carrier (support class)\n * \t\t\u003cli\u003eClientExtendedEventHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles extended client events.\n *  \t\u003c/ul\u003e\n *\n *  [#] \u003d Any one of these have to be set based on default DataMode for input.\n *  The default DataMode for input is String so if not changes you will\n *  have to set ClientCommandHandler.\n *  \u003c/p\u003e\n *  \u003cp\u003e\n *   Eg:\n *  \u003ccode\u003e\u003cBLOCKQUOTE\u003e\u003cpre\u003e\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle \u003d \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer \u003d new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * \u003c/pre\u003e\u003c/BLOCKQUOTE\u003e\u003c/code\u003e\u003c/p\u003e\n *\n *  @version 1.4.8\n *  @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //Some variable are not initialised to any value because the\n    //default java value was desired initial value.\n    //\u0027dev \u0027 \u003d development build not yet final\n    //\u0027beta\u0027 \u003d test build all features\n    //change also in QSAdminMain\n    private final static String VER \u003d \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n        if (System.getProperty(\"org.quickserver.useOSLineSeparator\") !\u003d null \u0026\u0026 System.getProperty(\"org.quickserver.useOSLineSeparator\").equals(\"true\")) {\n            NEW_LINE \u003d System.getProperty(\"line.separator\");\n        } else {\n            NEW_LINE \u003d \"\\r\\n\";\n        }\n        String _pid \u003d ManagementFactory.getRuntimeMXBean().getName();\n        int i \u003d _pid.indexOf(\"@\");\n        pid \u003d _pid.substring(0, i);\n        System.out.print(\"Loading QuickServer v\" + getVersion() + \" [PID:\" + pid + \"]\");\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort \u003d 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName \u003d \"QuickServer\";\n\n    private long maxConnection \u003d -1;\n\n    //1 min socket timeout\n    private int socketTimeout \u003d 60 * 1000;\n\n    private String maxConnectionMsg \u003d \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg \u003d \"-ERR Timeout\";\n\n    private String maxAuthTryMsg \u003d \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry \u003d 5;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //--v1.2\n    //Logger for QuickServer\n    private static final Logger logger \u003d Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //for Service interface\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState \u003d Service.UNKNOWN;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.3\n    private QuickServerConfig config \u003d new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel \u003d \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel \u003d \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation \u003d false;\n\n    private boolean communicationLogging \u003d true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig \u003d config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km \u003d null;\n\n    private TrustManager[] tm \u003d null;\n\n    private boolean runningSecure \u003d false;\n\n    private SecureStoreManager secureStoreManager \u003d null;\n\n    private Exception exceptionInRun \u003d null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode \u003d true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN \u003d DataMode.STRING;\n\n    private DataMode defaultDataModeOUT \u003d DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging \u003d false;\n\n    private int rawCommunicationMaxLength \u003d 100;\n\n    static {\n        System.out.println(\" Done\");\n        //should be commented if not a patch release\n        //System.out.println(\"[Includes patch(#): t\u003d152\u0026p\u003d532]\");\n        //should be commented if not a dev release\n        //System.out.println(\"[Dev Build Date: Saturday, October 29, 2005]\");\n        logger.log(Level.FINE, \"PID: {0}\", pid);\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion() {\n        return VER;\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo() {\n        return getVersionNo(VER);\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver) {\n        //String ver \u003d getVersion();\n        float version \u003d 0;\n        //check if beta\n        int i \u003d ver.indexOf(\" \");\n        if (i \u003d\u003d -1)\n            i \u003d ver.length();\n        ver \u003d ver.substring(0, i);\n        //check for sub version\n        i \u003d ver.indexOf(\".\");\n        if (i !\u003d -1) {\n            int j \u003d ver.indexOf(\".\", i);\n            if (j !\u003d -1) {\n                ver \u003d ver.substring(0, i) + \".\" + MyString.replaceAll(ver.substring(i + 1), \".\", \"\");\n            }\n        }\n        try {\n            version \u003d Float.parseFloat(ver);\n        } catch (NumberFormatException e) {\n            throw new RuntimeException(\"Corrupt QuickServer\");\n        }\n        return version;\n    }\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine() {\n        return NEW_LINE;\n    }\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString() {\n        return serverName + \" : \" + getPort();\n    }\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n        setClientCommandHandler(commandHandler);\n    }\n\n    /**\n     * Creates a new server at \u003ccode\u003eport\u003c/code\u003e with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n        //send to another constructor\n        this(commandHandler);\n        setPort(port);\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException {\n        logger.log(Level.FINE, \"Starting {0}\", getName());\n        if (isClosed() \u003d\u003d false) {\n            logger.log(Level.WARNING, \"Server {0} already running.\", getName());\n            throw new AppException(\"Server \" + getName() + \" already running.\");\n        }\n        blockingMode \u003d getBasicConfig().getServerMode().getBlocking();\n        if (getSecure().isEnable() \u0026\u0026 blockingMode \u003d\u003d false) {\n            //TODO we need to fix this..\n            logger.warning(\"QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode.\");\n            blockingMode \u003d true;\n            getBasicConfig().getServerMode().setBlocking(blockingMode);\n        }\n        if (serverBanner \u003d\u003d null) {\n            serverBanner \u003d \"\\n-------------------------------\" + \"\\n Name : \" + getName() + \"\\n Port : \" + getPort() + \"\\n-------------------------------\\n\";\n            logger.finest(\"Default Server Banner Generated\");\n        }\n        try {\n            loadApplicationClasses();\n            //load class from Advanced Settings\n            Class clientIdentifierClass \u003d getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);\n            clientIdentifier \u003d (ClientIdentifier) clientIdentifierClass.newInstance();\n            clientIdentifier.setQuickServer(QuickServer.this);\n            //load class from ObjectPoolConfig\n            Class poolManagerClass \u003d getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);\n            poolManager \u003d (PoolManager) poolManagerClass.newInstance();\n            //load class QSObjectPoolMaker\n            Class qsObjectPoolMakerClass \u003d getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);\n            qsObjectPoolMaker \u003d (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();\n            loadServerHooksClasses();\n            processServerHooks(ServerHook.PRE_STARTUP);\n            if (getSecure().isLoad() \u003d\u003d true)\n                //v1.4.0\n                loadSSLContext();\n            loadBusinessLogic();\n        } catch (ClassNotFoundException e) {\n            logger.log(Level.SEVERE, \"Could not load class/s: \" + e, e);\n            throw new AppException(\"Could not load class/s : \" + e);\n        } catch (InstantiationException e) {\n            logger.log(Level.SEVERE, \"Could not instantiate class/s: \" + e, e);\n            throw new AppException(\"Could not instantiate class/s: \" + e);\n        } catch (IllegalAccessException e) {\n            logger.log(Level.SEVERE, \"Illegal access to class/s: \" + e, e);\n            throw new AppException(\"Illegal access to class/s: \" + e);\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"IOException: \" + e, e);\n            throw new AppException(\"IOException: \" + e);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Exception: \" + e, e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Exception : \" + e);\n        }\n        //v1.3.3\n        if (getSecurityManagerClass() !\u003d null) {\n            System.setSecurityManager(getSecurityManager());\n        }\n        setServiceState(Service.INIT);\n        t \u003d new Thread(this, \"QuickServer - \" + getName());\n        t.start();\n        do {\n            Thread.yield();\n        } while (getServiceState() \u003d\u003d Service.INIT);\n        if (getServiceState() !\u003d Service.RUNNING) {\n            if (exceptionInRun !\u003d null)\n                throw new AppException(\"Could not start server \" + getName() + \"! Details: \" + exceptionInRun);\n            else\n                throw new AppException(\"Could not start server \" + getName());\n        }\n        lastStartTime \u003d new java.util.Date();\n        logger.log(Level.FINE, \"Started {0}, Date: {1}\", new Object[] { getName(), lastStartTime });\n    }\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException {\n        processServerHooks(ServerHook.PRE_SHUTDOWN);\n        logger.log(Level.WARNING, \"Stopping {0}\", getName());\n        stopServer \u003d true;\n        Socket death \u003d null;\n        if (isClosed() \u003d\u003d true) {\n            logger.log(Level.WARNING, \"Server {0} is not running!\", getName());\n            throw new AppException(\"Server \" + getName() + \" is not running!\");\n        }\n        try {\n            if (getBlockingMode() \u003d\u003d true) {\n                if (getSecure().isEnable() \u003d\u003d false) {\n                    death \u003d new Socket(server.getInetAddress(), server.getLocalPort());\n                    death.getInputStream().read();\n                    death.close();\n                } else {\n                    death \u003d getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());\n                    Thread.sleep(100);\n                    death.close();\n                }\n            }\n            if (serverSocketChannel !\u003d null) {\n                serverSocketChannel.close();\n            }\n        } catch (IOException e) {\n            logger.log(Level.FINE, \"IOError stopping {0}: {1}\", new Object[] { getName(), e });\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error stopping {0}: {1}\", new Object[] { getName(), e });\n            throw new AppException(\"Error in stopServer \" + getName() + \": \" + e);\n        }\n        for (int i \u003d 0; getServiceState() !\u003d Service.STOPPED; i++) {\n            try {\n                Thread.sleep(60);\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error waiting for {0} to fully stop. Error: {1}\", new Object[] { getName(), e });\n            }\n            if (i \u003e 1000) {\n                logger.severe(\"Server was not stopped even after 10sec.. will terminate now.\");\n                System.exit(-1);\n            }\n        }\n        if (adminServer \u003d\u003d null || getQSAdminServer().getServer() !\u003d this) {\n            //so this is not qsadmin\n            setClassLoader(null);\n        }\n        logger.log(Level.INFO, \"Stopped {0}\", getName());\n    }\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException {\n        stopServer();\n        startServer();\n    }\n\n    /**\n     * Returns the name of the QuickServer. Default is \u0027QuickServer\u0027.\n     * @see #setName\n     */\n    public String getName() {\n        return serverName;\n    }\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name) {\n        serverName \u003d name;\n        logger.log(Level.FINEST, \"Set to : {0}\", name);\n    }\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner() {\n        return serverBanner;\n    }\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. \u003cbr\u003e\u0026nbsp;\u003cbr\u003e\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner) {\n        serverBanner \u003d banner;\n        logger.log(Level.FINEST, \"Set to : {0}\", banner);\n    }\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port) {\n        if (port \u003c 0) {\n            throw new IllegalArgumentException(\"Port number can not be less than 0!\");\n        }\n        serverPort \u003d port;\n        logger.log(Level.FINEST, \"Set to {0}\", port);\n    }\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort() {\n        if (isClosed() \u003d\u003d false) {\n            return server.getLocalPort();\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            return serverPort;\n        } else {\n            int _port \u003d getSecure().getPort();\n            if (_port \u003d\u003d -1)\n                return serverPort;\n            else\n                return _port;\n        }\n    }\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler) {\n        clientCommandHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler() {\n        return clientCommandHandlerString;\n    }\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data) {\n        this.clientDataString \u003d data;\n        logger.log(Level.FINEST, \"Set to {0}\", data);\n    }\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData() {\n        return clientDataString;\n    }\n\n    /**\n     * Sets the client socket\u0027s timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time) {\n        if (time \u003e 0)\n            socketTimeout \u003d time;\n        else\n            socketTimeout \u003d 0;\n        logger.log(Level.FINEST, \"Set to {0}\", socketTimeout);\n    }\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout() {\n        return socketTimeout;\n    }\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry) {\n        maxAuthTry \u003d authTry;\n        logger.log(Level.FINEST, \"Set to {0}\", authTry);\n    }\n\n    /**\n     * Returns max allowed login attempts. Default is \u003ccode\u003e5\u003c/code\u003e.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry() {\n        return maxAuthTry;\n    }\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg) {\n        maxAuthTryMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg() {\n        return maxAuthTryMsg;\n    }\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg) {\n        timeoutMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg() {\n        return timeoutMsg;\n    }\n\n    private TheClient initTheClient() {\n        TheClient theClient \u003d new TheClient();\n        theClient.setServer(QuickServer.this);\n        theClient.setTimeoutMsg(getTimeoutMsg());\n        //v1.2\n        theClient.setMaxAuthTry(getMaxAuthTry());\n        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());\n        theClient.setClientEventHandler(clientEventHandler);\n        //v1.4.6\n        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);\n        theClient.setClientCommandHandler(clientCommandHandler);\n        //v1.2\n        theClient.setClientObjectHandler(clientObjectHandler);\n        //v1.4\n        theClient.setClientBinaryHandler(clientBinaryHandler);\n        //v1.4.5\n        theClient.setClientWriteHandler(clientWriteHandler);\n        //v1.3\n        theClient.setAuthenticator(authenticator);\n        //v1.4.6\n        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);\n        theClient.setTimeout(socketTimeout);\n        theClient.setMaxConnectionMsg(maxConnectionMsg);\n        //v1.3.2\n        theClient.setCommunicationLogging(getCommunicationLogging());\n        return theClient;\n    }\n\n    public void run() {\n        exceptionInRun \u003d null;\n        TheClient theClient \u003d initTheClient();\n        try {\n            stopServer \u003d false;\n            closeAllPools();\n            initAllPools();\n            makeServerSocket();\n            //print banner\n            System.out.println(serverBanner);\n            //v1.2\n            setServiceState(Service.RUNNING);\n            //v1.3.3\n            processServerHooks(ServerHook.POST_STARTUP);\n            if (getBlockingMode() \u003d\u003d false) {\n                runNonBlocking(theClient);\n                if (stopServer \u003d\u003d true) {\n                    logger.log(Level.FINEST, \"Closing selector for {0}\", getName());\n                    selector.close();\n                }\n                return;\n            } else {\n                runBlocking(theClient);\n            }\n        } catch (BindException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"{0} BindException for Port {1} @ {2} : {3}\", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });\n        } catch (javax.net.ssl.SSLException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"SSLException {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (IOException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"IOError {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (Exception e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"Error {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } finally {\n            if (getBlockingMode() \u003d\u003d true) {\n                logger.log(Level.WARNING, \"Closing {0}\", getName());\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            } else if (getBlockingMode() \u003d\u003d false \u0026\u0026 exceptionInRun !\u003d null) {\n                logger.log(Level.WARNING, \"Closing {0} - Had Error: {1}\", new Object[] { getName(), exceptionInRun });\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        if (serverSocketChannel !\u003d null)\n                            serverSocketChannel.close();\n                        if (server !\u003d null)\n                            server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n        }\n    }\n\n    //end of run\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnection \u003d maxConnection;\n        else\n            this.maxConnection \u003d maxConnection;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnection);\n    }\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection() {\n        return maxConnection;\n    }\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount() {\n        if (clientHandlerPool !\u003d null) {\n            try {\n                return getClientHandlerPool().getNumActive();\n            } catch (Exception e) {\n                return 0;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : \u003ccode\u003e-ERR Server Busy. Max Connection Reached\u003c/code\u003e\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n        else\n            this.maxConnectionMsg \u003d maxConnectionMsg;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnectionMsg);\n    }\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg() {\n        return maxConnectionMsg;\n    }\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException {\n        ipAddr \u003d InetAddress.getByName(bindAddr);\n        logger.log(Level.FINEST, \"Set to {0}\", bindAddr);\n    }\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr() {\n        if (ipAddr \u003d\u003d null) {\n            try {\n                ipAddr \u003d InetAddress.getByName(\"0.0.0.0\");\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Unable to create default ip(0.0.0.0) : {0}\", e);\n                throw new RuntimeException(\"Error: Unable to find servers own ip : \" + e);\n            }\n        }\n        return ipAddr;\n    }\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects) {\n        this.storeObjects \u003d storeObjects;\n    }\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return \u003ccode\u003enull\u003c/code\u003e.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects() {\n        return storeObjects;\n    }\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port) {\n        getQSAdminServer().getServer().setPort(port);\n    }\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort() {\n        return getQSAdminServer().getServer().getPort();\n    }\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator) {\n        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);\n    }\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator() {\n        return getQSAdminServer().getServer().getAuthenticator();\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException {\n        getQSAdminServer().setClientAuthenticationHandler(authenticator);\n        getQSAdminServer().startServer(port);\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException {\n        getQSAdminServer().startServer();\n    }\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer() {\n        if (adminServer \u003d\u003d null)\n            adminServer \u003d new QSAdminServer(QuickServer.this);\n        return adminServer;\n    }\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer) {\n        if (adminServer \u003d\u003d null)\n            this.adminServer \u003d adminServer;\n    }\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed() {\n        if (server \u003d\u003d null)\n            return true;\n        return server.isClosed();\n    }\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer\u0027s own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger() {\n        if (appLogger !\u003d null)\n            return appLogger;\n        return logger;\n    }\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger) {\n        this.appLogger \u003d appLogger;\n    }\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler) {\n        clientObjectHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler() {\n        return clientObjectHandlerString;\n    }\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n        if (formatter \u003d\u003d null)\n            return;\n        consoleLoggingformatter \u003d formatter;\n        java.util.logging.Formatter conformatter \u003d (java.util.logging.Formatter) getClass(formatter, true).newInstance();\n        Logger jdkLogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d jdkLogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                handlers[index].setFormatter(conformatter);\n            }\n        }\n        logger.log(Level.FINEST, \"Set to {0}\", formatter);\n    }\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter() {\n        return consoleLoggingformatter;\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MiniFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to logging.MiniFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MicroFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to MicroFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        boolean isConsole \u003d true;\n        try {\n            if (System.console() \u003d\u003d null) {\n                isConsole \u003d false;\n            }\n        } catch (Throwable e) {\n            //ignore\n        }\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                if (isConsole \u003d\u003d false \u0026\u0026 level !\u003d Level.OFF) {\n                    System.out.println(\"QuickServer: You do not have a console.. so turning console logger off..\");\n                    level \u003d Level.OFF;\n                }\n                if (level \u003d\u003d Level.OFF) {\n                    logger.info(\"QuickServer: Removing console handler.. \");\n                    rlogger.removeHandler(handlers[index]);\n                    handlers[index].setLevel(level);\n                    handlers[index].close();\n                } else {\n                    handlers[index].setLevel(level);\n                }\n            }\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            consoleLoggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            consoleLoggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            consoleLoggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            consoleLoggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            consoleLoggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            consoleLoggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            consoleLoggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            consoleLoggingLevel \u003d \"OFF\";\n        else\n            consoleLoggingLevel \u003d \"UNKNOWN\";\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel() {\n        return consoleLoggingLevel;\n    }\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            handlers[index].setLevel(level);\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            loggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            loggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            loggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            loggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            loggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            loggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            loggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            loggingLevel \u003d \"OFF\";\n        else\n            loggingLevel \u003d \"UNKNOWN\";\n        consoleLoggingLevel \u003d loggingLevel;\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    //*** Start of Service interface methods\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError() {\n        return serviceError;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param) {\n        serviceError \u003d null;\n        try {\n            initServer(param);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig) {\n        serviceError \u003d null;\n        try {\n            initServer(qsConfig);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING)\n            return false;\n        try {\n            startServer();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.STOPPED)\n            return false;\n        try {\n            stopServer();\n            clearAllPools();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING) {\n            suspendMaxConnection \u003d maxConnection;\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n            maxConnection \u003d 0;\n            maxConnectionMsg \u003d \"Service is suspended.\";\n            setServiceState(Service.SUSPENDED);\n            logger.log(Level.INFO, \"Service {0} is suspended.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.SUSPENDED) {\n            maxConnection \u003d suspendMaxConnection;\n            maxConnectionMsg \u003d suspendMaxConnectionMsg;\n            setServiceState(Service.RUNNING);\n            logger.log(Level.INFO, \"Service {0} resumed.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info() {\n        serviceError \u003d null;\n        StringBuilder buf \u003d new StringBuilder();\n        buf.append(getName()).append(\"\\n\");\n        buf.append(getBindAddr().getHostAddress()).append(\" \");\n        buf.append(getPort()).append(\"\\n\");\n        return buf.toString();\n    }\n\n    // *** End of Service interface methods\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException {\n        QuickServerConfig qsConfig \u003d null;\n        try {\n            qsConfig \u003d ConfigReader.read((String) param[0]);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not init server from xml file {0} : {1}\", new Object[] { new File((String) param[0]).getAbsolutePath(), e });\n            throw new AppException(\"Could not init server from xml file\", e);\n        }\n        initServer(qsConfig);\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {\n        setConfig(qsConfig);\n        try {\n            configQuickServer();\n            loadApplicationClasses();\n            //start InitServerHooks\n            InitServerHooks ish \u003d getConfig().getInitServerHooks();\n            if (ish !\u003d null) {\n                Iterator iterator \u003d ish.iterator();\n                String initServerHookClassName \u003d null;\n                Class initServerHookClass \u003d null;\n                InitServerHook initServerHook \u003d null;\n                while (iterator.hasNext()) {\n                    initServerHookClassName \u003d (String) iterator.next();\n                    initServerHookClass \u003d getClass(initServerHookClassName, true);\n                    initServerHook \u003d (InitServerHook) initServerHookClass.newInstance();\n                    logger.log(Level.INFO, \"Loaded init server hook: {0}\", initServerHookClassName);\n                    logger.log(Level.FINE, \"Init server hook info: {0}\", initServerHook.info());\n                    initServerHook.handleInit(QuickServer.this);\n                }\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not load init server hook: {0}\", e);\n            logger.log(Level.WARNING, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Could not load init server hook\", e);\n        }\n        setServiceState(Service.INIT);\n        logger.log(Level.FINEST, \"\\r\\n{0}\", MyString.getSystemInfo(getVersion()));\n    }\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState() {\n        return serviceState;\n    }\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state) {\n        serviceState \u003d state;\n    }\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp) {\n        if (temp.equals(\"SEVERE\"))\n            qs.setConsoleLoggingLevel(Level.SEVERE);\n        else if (temp.equals(\"WARNING\"))\n            qs.setConsoleLoggingLevel(Level.WARNING);\n        else if (temp.equals(\"INFO\"))\n            qs.setConsoleLoggingLevel(Level.INFO);\n        else if (temp.equals(\"CONFIG\"))\n            qs.setConsoleLoggingLevel(Level.CONFIG);\n        else if (temp.equals(\"FINE\"))\n            qs.setConsoleLoggingLevel(Level.FINE);\n        else if (temp.equals(\"FINER\"))\n            qs.setConsoleLoggingLevel(Level.FINER);\n        else if (temp.equals(\"FINEST\"))\n            qs.setConsoleLoggingLevel(Level.FINEST);\n        else if (temp.equals(\"OFF\"))\n            qs.setConsoleLoggingLevel(Level.OFF);\n        else\n            logger.log(Level.WARNING, \"unknown level {0}\", temp);\n    }\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception {\n        QuickServer qs \u003d QuickServer.this;\n        //v1.3\n        qs.setConfig(config);\n        qs.setBasicConfig(config);\n        String temp \u003d config.getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        temp \u003d null;\n        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        //v1.3.3\n        qs.setSecurityManagerClass(config.getSecurityManagerClass());\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        temp \u003d config.getApplicationJarPath();\n        if (temp !\u003d null) {\n            File ajp \u003d new File(temp);\n            if (ajp.isAbsolute() \u003d\u003d false) {\n                temp \u003d config.getConfigFile();\n                ajp \u003d new File(temp);\n                temp \u003d ajp.getParent() + File.separatorChar + config.getApplicationJarPath();\n                config.setApplicationJarPath(temp);\n                temp \u003d null;\n            }\n            qs.setApplicationJarPath(config.getApplicationJarPath());\n            //set path also to QSAdmin\n            if (config.getQSAdminServerConfig() !\u003d null) {\n                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());\n            }\n        }\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception {\n        QuickServer qs \u003d getQSAdminServer().getServer();\n        qs.setBasicConfig(config);\n        //set the Logging Level to same as main QS\n        //config.getConsoleLoggingLevel();\n        String temp \u003d getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        //set the Logging Formatter to same as main QS\n        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());\n        //v1.4.6\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        //v1.4.6\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());\n        //v1.3.2\n        if (config.getCommandShellEnable().equals(\"true\"))\n            getQSAdminServer().setShellEnable(true);\n        getQSAdminServer().setPromptName(config.getCommandShellPromptName());\n        //v1.3.3\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception {\n        configQuickServer(getConfig());\n        if (getConfig().getQSAdminServerConfig() !\u003d null) {\n            configQuickServer(getConfig().getQSAdminServerConfig());\n        }\n    }\n\n    /**\n     * Usage: QuickServer [-options]\u003cbr/\u003e\n     * Where options include:\u003cbr/\u003e\n     *   -about\t\tOpens About Dialogbox\u003cbr/\u003e\n     *   -load \u003cxml_config_file\u003e [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File \u003cnew_file_name\u003e\n     */\n    public static void main(String[] args) {\n        try {\n            if (args.length \u003e\u003d 1) {\n                if (args[0].equals(\"-about\")) {\n                    org.quickserver.net.server.gui.About.main(null);\n                } else if (args[0].equals(\"-load\") \u0026\u0026 args.length \u003e\u003d 2) {\n                    QuickServer qs \u003d QuickServer.load(args[1]);\n                    if (qs !\u003d null)\n                        handleOptions(args, qs);\n                } else {\n                    System.out.println(printUsage());\n                }\n            } else {\n                System.out.println(printUsage());\n                org.quickserver.net.server.gui.About.showAbout();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException {\n        QuickServer qs \u003d new QuickServer();\n        Object[] config \u003d new Object[] { xml };\n        qs.initServer(config);\n        qs.startServer();\n        if (qs.getConfig().getQSAdminServerConfig() !\u003d null) {\n            qs.startQSAdminServer();\n        }\n        return qs;\n    }\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage() {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"QuickServer - Java library/framework for creating robust multi-client TCP servers.\\n\");\n        sb.append(\"Copyright (C) QuickServer.org\\n\\n\");\n        sb.append(\"Usage: QuickServer [-options]\\n\");\n        sb.append(\"Where options include:\\n\");\n        sb.append(\"  -about\\t\" + \"Opens About Dialog box\\n\");\n        sb.append(\"  -load \u003cxml_config_file\u003e [load-options]\\t\" + \"Loads the server from xml file.\\n\");\n        sb.append(\"  Where load-options include:\\n\");\n        sb.append(\"     -fullXML2File \u003cfile_name\u003e\\t\" + \"Dumps the Full XML configuration of the QuickServer loaded.\\n\");\n        return sb.toString();\n    }\n\n    private static void handleOptions(String[] args, QuickServer quickserver) {\n        if (args.length \u003c 3)\n            return;\n        if (args[2].equals(\"-fullXML2File\") \u0026\u0026 args.length \u003e\u003d 4) {\n            File file \u003d new File(args[3]);\n            logger.log(Level.INFO, \"Writing full xml configuration to file: {0}\", file.getAbsolutePath());\n            try {\n                TextFile.write(file, quickserver.getConfig().toXML(null));\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error writing full xml configuration: {0}\", e);\n            }\n        }\n    }\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception {\n        try {\n            if (pool !\u003d null)\n                getClientPool().clear();\n            if (clientHandlerPool !\u003d null)\n                getClientHandlerPool().clear();\n            if (getClientDataPool() !\u003d null)\n                getClientDataPool().clear();\n            if (getDBPoolUtil() !\u003d null)\n                getDBPoolUtil().clean();\n            if (byteBufferPool !\u003d null)\n                getByteBufferPool().clear();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error: {0}\", e);\n            throw e;\n        }\n    }\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception {\n        if (pool \u003d\u003d null \u0026\u0026 clientHandlerPool \u003d\u003d null \u0026\u0026 getClientDataPool() \u003d\u003d null \u0026\u0026 getDBPoolUtil() \u003d\u003d null \u0026\u0026 byteBufferPool \u003d\u003d null) {\n            return;\n        }\n        logger.log(Level.FINE, \"Closing pools for {0}\", getName());\n        try {\n            if (pool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {\n                logger.finer(\"Closing ClientThread pool.\");\n                getClientPool().close();\n            }\n            if (clientHandlerPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientHandlerPool())) {\n                logger.finer(\"Closing ClientHandler pool.\");\n                getClientHandlerPool().close();\n            }\n            if (getClientDataPool() !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientDataPool())) {\n                logger.finer(\"Closing ClientData pool.\");\n                getClientDataPool().close();\n            }\n            if (getDBPoolUtil() !\u003d null) {\n                logger.finer(\"Closing DB pool.\");\n                getDBPoolUtil().clean();\n            }\n            if (byteBufferPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getByteBufferPool())) {\n                logger.finer(\"Closing ByteBuffer pool.\");\n                getByteBufferPool().close();\n            }\n            logger.log(Level.FINE, \"Closed pools for {0}\", getName());\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error closing pools for {0}: {1}\", new Object[] { getName(), e });\n            throw e;\n        }\n    }\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception {\n        logger.fine(\"Creating pools\");\n        if (getBlockingMode() \u003d\u003d false) {\n            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());\n        }\n        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());\n        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());\n        //check if client data is poolable\n        if (clientDataClass !\u003d null) {\n            try {\n                clientData \u003d (ClientData) clientDataClass.newInstance();\n                if (PoolableObject.class.isInstance(clientData) \u003d\u003d true) {\n                    PoolableObject po \u003d (PoolableObject) clientData;\n                    if (po.isPoolable() \u003d\u003d true) {\n                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());\n                    } else {\n                        clientDataPool \u003d null;\n                        logger.fine(\"ClientData is not poolable!\");\n                    }\n                }\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error: {0}\", e);\n                throw e;\n            }\n        }\n        try {\n            makeDBObjectPool();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error in makeDBObjectPool() : {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw e;\n        }\n        logger.fine(\"Created pools\");\n    }\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool() {\n        if (pool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientPool available yet!\");\n        return pool;\n    }\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientHandler pool\");\n        PoolableObjectFactory factory \u003d new ClientHandlerObjectFactory(getBlockingMode());\n        clientHandlerPool \u003d poolManager.makeClientHandlerPool(factory, opConfig);\n        poolManager.initPool(clientHandlerPool, opConfig);\n        clientHandlerPool \u003d makeQSObjectPool(clientHandlerPool);\n        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool() {\n        if (clientHandlerPool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientHandler Pool available yet!\");\n        return clientHandlerPool;\n    }\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config) {\n        this.config \u003d config;\n    }\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig() {\n        return config;\n    }\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientData pool\");\n        clientDataPool \u003d poolManager.makeClientDataPool(factory, opConfig);\n        poolManager.initPool(clientDataPool, opConfig);\n        clientDataPool \u003d makeQSObjectPool(clientDataPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool() {\n        return clientDataPool;\n    }\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return \u003ccode\u003enull\u003c/code\u003e\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil() {\n        return dBPoolUtil;\n    }\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {\n        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);\n    }\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception {\n        if (getConfig().getDBObjectPoolConfig() !\u003d null) {\n            logger.fine(\"Creating DBObject Pool\");\n            //logger.finest(\"Got:\\n\"+getConfig().getDBObjectPoolConfig().toXML(null));\n            Class dbPoolUtilClass \u003d getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);\n            dBPoolUtil \u003d (DBPoolUtil) dbPoolUtilClass.newInstance();\n            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());\n            dBPoolUtil.initPool();\n        }\n    }\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id) {\n        return clientIdentifier.findFirstClientById(id);\n    }\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  \u003ccode\u003e\u003cpre\u003e\n     *    Eg:\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tObject syncObj \u003d quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator \u003d quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tClientIdentifier clientIdentifier \u003d quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator \u003d clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    \u003c/code\u003e\u003c/pre\u003e\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient() {\n        return clientIdentifier.findAllClient();\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern) {\n        return clientIdentifier.findAllClientById(pattern);\n    }\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key) {\n        return clientIdentifier.findClientByKey(key);\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern) {\n        return clientIdentifier.findAllClientByKey(pattern);\n    }\n\n    /**\n     * Sets next client has a trusted client.\n     * \u003cp\u003eThis will skip any authentication and will not set any timeout.\u003c/p\u003e\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted() {\n        setSkipValidation(true);\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation() {\n        return skipValidation;\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation) {\n        skipValidation \u003d validation;\n    }\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging) {\n        this.communicationLogging \u003d communicationLogging;\n    }\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging() {\n        return communicationLogging;\n    }\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass) {\n        if (securityManagerClass !\u003d null)\n            this.securityManagerClass \u003d securityManagerClass;\n    }\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass() {\n        return securityManagerClass;\n    }\n\n    public SecurityManager getSecurityManager() throws AppException {\n        if (getSecurityManagerClass() \u003d\u003d null)\n            return null;\n        SecurityManager sm \u003d null;\n        try {\n            sm \u003d (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();\n        } catch (ClassNotFoundException e) {\n            throw new AppException(e.getMessage());\n        } catch (InstantiationException e) {\n            throw new AppException(e.getMessage());\n        } catch (IllegalAccessException e) {\n            throw new AppException(e.getMessage());\n        }\n        return sm;\n    }\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {\n        this.accessConstraintConfig \u003d accessConstraintConfig;\n    }\n\n    /**\n     * Returns Access constraints if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig() {\n        return accessConstraintConfig;\n    }\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader) {\n        this.classLoader \u003d classLoader;\n        Thread.currentThread().setContextClassLoader(classLoader);\n    }\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader() {\n        return classLoader;\n    }\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException {\n        if (name \u003d\u003d null)\n            throw new IllegalArgumentException(\"Class name can\u0027t be null!\");\n        logger.log(Level.FINEST, \"Class: {0}, reload: {1}\", new Object[] { name, reload });\n        if (reload \u003d\u003d true \u0026\u0026 classLoader !\u003d null) {\n            return classLoader.loadClass(name);\n        } else if (reload \u003d\u003d true \u0026\u0026 classLoader \u003d\u003d null \u0026\u0026 this.getClass().getClassLoader() !\u003d null) {\n            return this.getClass().getClassLoader().loadClass(name);\n        } else if (reload \u003d\u003d false \u0026\u0026 classLoader !\u003d null) {\n            return Class.forName(name, true, classLoader);\n        } else /*if(reload\u003d\u003dfalse \u0026\u0026 classLoader\u003d\u003dnull)*/\n        {\n            return Class.forName(name, true, this.getClass().getClassLoader());\n        }\n    }\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath) {\n        this.applicationJarPath \u003d applicationJarPath;\n    }\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath() {\n        return applicationJarPath;\n    }\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks) {\n        this.serverHooks \u003d serverHooks;\n    }\n\n    /**\n     * Returns ServerHooks if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks() {\n        if (serverHooks \u003d\u003d null)\n            serverHooks \u003d new ServerHooks();\n        return serverHooks;\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses() {\n        if (getServerHooks() \u003d\u003d null)\n            return;\n        listOfServerHooks \u003d new ArrayList();\n        ServerHook serverHook \u003d null;\n        String serverHookClassName \u003d null;\n        Class serverHookClass \u003d null;\n        //add system hooks\n        serverHook \u003d new GhostSocketReaper();\n        serverHook.initHook(QuickServer.this);\n        listOfServerHooks.add(serverHook);\n        ghostSocketReaper \u003d (GhostSocketReaper) serverHook;\n        //add user hooks if any\n        Iterator iterator \u003d getServerHooks().iterator();\n        while (iterator.hasNext()) {\n            serverHookClassName \u003d (String) iterator.next();\n            try {\n                serverHookClass \u003d getClass(serverHookClassName, true);\n                serverHook \u003d (ServerHook) serverHookClass.newInstance();\n                serverHook.initHook(QuickServer.this);\n                listOfServerHooks.add(serverHook);\n                logger.log(Level.INFO, \"Loaded server hook: {0}\", serverHookClassName);\n                logger.log(Level.FINE, \"Server hook info: {0}\", serverHook.info());\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Could not load server hook [{0}]: {1}\", new Object[] { serverHookClassName, e });\n                logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            }\n        }\n        //end of while\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event) {\n        if (listOfServerHooks \u003d\u003d null) {\n            logger.warning(\"listOfServerHooks was null!\");\n            return;\n        }\n        ServerHook serverHook \u003d null;\n        boolean result \u003d false;\n        Iterator iterator \u003d listOfServerHooks.iterator();\n        String hooktype \u003d \"UNKNOWN\";\n        switch(event) {\n            case ServerHook.PRE_STARTUP:\n                hooktype \u003d \"PRE_STARTUP\";\n                break;\n            case ServerHook.POST_STARTUP:\n                hooktype \u003d \"POST_STARTUP\";\n                break;\n            case ServerHook.PRE_SHUTDOWN:\n                hooktype \u003d \"PRE_SHUTDOWN\";\n                break;\n            case ServerHook.POST_SHUTDOWN:\n                hooktype \u003d \"POST_SHUTDOWN\";\n                break;\n        }\n        while (iterator.hasNext()) {\n            serverHook \u003d (ServerHook) iterator.next();\n            try {\n                result \u003d serverHook.handleEvent(event);\n            } catch (Exception e) {\n                result \u003d false;\n                logger.log(Level.WARNING, \"Error invoking {0} hook [{1}]: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });\n            }\n            logger.log(Level.FINE, \"Invoked {0} hook [{1}] was: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), result });\n        }\n    }\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone() {\n        Object object \u003d null;\n        try {\n            object \u003d super.clone();\n            QuickServer _qs \u003d (QuickServer) object;\n            _qs.setQSAdminServer(new QSAdminServer(_qs));\n        } catch (CloneNotSupportedException e) {\n            //should not happ\n            logger.log(Level.WARNING, \"Error cloning : {0}\", e);\n        }\n        return object;\n    }\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure) {\n        this.secure \u003d secure;\n    }\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure() {\n        if (secure \u003d\u003d null)\n            secure \u003d new Secure();\n        return secure;\n    }\n\n    /**\n     * \u003cp\u003eReturns if the server is running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure() {\n        return runningSecure;\n    }\n\n    /**\n     * \u003cp\u003eSets the server mode if its running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure) {\n        this.runningSecure \u003d runningSecure;\n    }\n\n    private File makeAbsoluteToConfig(String fileName) {\n        Assertion.affirm(fileName !\u003d null, \"FileName can\u0027t be null\");\n        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());\n    }\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException {\n        server \u003d null;\n        logger.log(Level.FINEST, \"Binding {0} to IP: {1}\", new Object[] { getName(), getBindAddr() });\n        InetSocketAddress bindAddress \u003d new InetSocketAddress(getBindAddr(), getPort());\n        try {\n            NetworkInterface ni \u003d NetworkInterface.getByInetAddress(getBindAddr());\n            if (ni !\u003d null) {\n                logger.fine(\"NetworkInterface: \" + ni);\n            }\n        } catch (Exception igrnore) {\n            /*ignore*/\n        } catch (Error igrnore) {\n            /*ignore*/\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Making a normal ServerSocket for {0}\", getName());\n            setRunningSecure(false);\n            if (getBlockingMode() \u003d\u003d false) {\n                //for non-blocking\n                serverSocketChannel \u003d ServerSocketChannel.open();\n                server \u003d serverSocketChannel.socket();\n                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n            } else {\n                //for blocking\n                server \u003d new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n            }\n        } else {\n            try {\n                logger.log(Level.FINE, \"Making a secure ServerSocket for {0}\", getName());\n                getSSLContext();\n                setRunningSecure(true);\n                if (getBlockingMode() \u003d\u003d false) {\n                    logger.log(Level.FINE, \"Making a secure ServerSocketChannel for {0}\", getName());\n                    //for non-blocking\n                    serverSocketChannel \u003d ServerSocketChannel.open();\n                    server \u003d serverSocketChannel.socket();\n                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n                } else {\n                    ServerSocketFactory ssf \u003d getSSLContext().getServerSocketFactory();\n                    SSLServerSocket serversocket \u003d (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());\n                    setRunningSecure(true);\n                    secureStoreManager.logSSLServerSocketInfo(serversocket);\n                    server \u003d serversocket;\n                    serverSocketChannel \u003d server.getChannel();\n                    if (serverSocketChannel \u003d\u003d null \u0026\u0026 getBlockingMode() \u003d\u003d false) {\n                        logger.warning(\"Secure Server does not support Channel! So will run in blocking mode.\");\n                        blockingMode \u003d false;\n                    }\n                }\n                //blocking\n            } catch (NoSuchAlgorithmException e) {\n                logger.log(Level.WARNING, \"NoSuchAlgorithmException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            } catch (KeyManagementException e) {\n                logger.log(Level.WARNING, \"KeyManagementException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            }\n        }\n        server.setReuseAddress(true);\n        int connectionTime \u003d 0;\n        int latency \u003d 0;\n        int bandwidth \u003d 0;\n        connectionTime \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();\n        latency \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();\n        bandwidth \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();\n        logger.log(Level.FINE, \"getPerformancePreferencesConnectionTime : {0}\", connectionTime);\n        logger.log(Level.FINE, \"getPerformancePreferencesLatency : {0}\", latency);\n        logger.log(Level.FINE, \"getPerformancePreferencesBandwidth : {0}\", bandwidth);\n        server.setPerformancePreferences(connectionTime, latency, bandwidth);\n        int clientSocketReceiveBufferSize \u003d getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();\n        if (clientSocketReceiveBufferSize \u003e 0) {\n            logger.log(Level.FINE, \"clientSocketReceiveBufferSize: {0}\", clientSocketReceiveBufferSize);\n            server.setReceiveBufferSize(clientSocketReceiveBufferSize);\n        }\n        if (getBlockingMode() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Server Mode {0} - Non Blocking\", getName());\n            if (selector \u003d\u003d null || selector.isOpen() \u003d\u003d false) {\n                logger.finest(\"Opening new selector\");\n                selector \u003d Selector.open();\n            } else {\n                logger.log(Level.FINEST, \"Reusing selector: {0}\", selector);\n            }\n            serverSocketChannel.configureBlocking(false);\n            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n            selector.wakeup();\n        } else {\n            logger.log(Level.FINE, \"Server Mode {0} - Blocking\", getName());\n        }\n    }\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {\n        Assertion.affirm(basicConfig !\u003d null, \"BasicServerConfig can\u0027t be null\");\n        this.basicConfig \u003d basicConfig;\n    }\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig() {\n        return basicConfig;\n    }\n\n    /**\n     * Loads the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException {\n        if (getSecure().isLoad() \u003d\u003d false) {\n            throw new IllegalStateException(\"Secure setting is not yet enabled for loading!\");\n        }\n        logger.info(\"Loading Secure Context..\");\n        km \u003d null;\n        tm \u003d null;\n        try {\n            String ssManager \u003d \"org.quickserver.security.SecureStoreManager\";\n            if (getSecure().getSecureStore() !\u003d null)\n                ssManager \u003d getSecure().getSecureStore().getSecureStoreManager();\n            Class secureStoreManagerClass \u003d getClass(ssManager, true);\n            secureStoreManager \u003d (SecureStoreManager) secureStoreManagerClass.newInstance();\n            km \u003d secureStoreManager.loadKeyManagers(getConfig());\n            logger.fine(\"KeyManager got\");\n            tm \u003d secureStoreManager.loadTrustManagers(getConfig());\n            logger.fine(\"TrustManager got\");\n            sslc \u003d secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());\n            sslc.init(km, tm, null);\n            logger.fine(\"SSLContext loaded\");\n        } catch (KeyStoreException e) {\n            logger.warning(\"KeyStoreException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchAlgorithmException e) {\n            logger.warning(\"NoSuchAlgorithmException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchProviderException e) {\n            logger.warning(\"NoSuchProviderException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (UnrecoverableKeyException e) {\n            logger.warning(\"UnrecoverableKeyException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (CertificateException e) {\n            logger.warning(\"CertificateException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (KeyManagementException e) {\n            logger.warning(\"KeyManagementException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (GeneralSecurityException e) {\n            logger.warning(\"GeneralSecurityException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (ClassNotFoundException e) {\n            logger.warning(\"ClassNotFoundException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (InstantiationException e) {\n            logger.warning(\"InstantiationException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (IllegalAccessException e) {\n            logger.warning(\"IllegalAccessException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        return getSSLContext(null);\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        if (protocol !\u003d null \u0026\u0026 secureStoreManager !\u003d null) {\n            SSLContext _sslc \u003d secureStoreManager.getSSLContext(protocol);\n            _sslc.init(km, tm, null);\n            return _sslc;\n        }\n        return sslc;\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext());\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext(protocol));\n    }\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler) {\n        clientBinaryHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler() {\n        return clientBinaryHandlerString;\n    }\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector) {\n        this.selector \u003d selector;\n    }\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector() {\n        return selector;\n    }\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception {\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        //long stime \u003d System.currentTimeMillis();\n        //long etime \u003d System.currentTimeMillis();\n        while (true) {\n            //etime \u003d System.currentTimeMillis();\n            //System.out.println(\"Time Taken: \"+(etime-stime));\n            client \u003d server.accept();\n            //stime \u003d System.currentTimeMillis();\n            if (linger \u003c 0) {\n                client.setSoLinger(false, 0);\n            } else {\n                client.setSoLinger(true, linger);\n            }\n            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                //low delay\u003d10\n                client.setTrafficClass(socketTrafficClass);\n            }\n            logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n            }\n            if (stopServer) {\n                //Client connected when server was about to be shutdown.\n                try {\n                    client.close();\n                } catch (Exception e) {\n                }\n                break;\n            }\n            if (checkAccessConstraint(client) \u003d\u003d false) {\n                continue;\n            }\n            //Check if max connection has reached\n            if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);\n            } else {\n                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);\n            }\n            theClient.setTrusted(getSkipValidation());\n            theClient.setSocket(client);\n            //mostly null\n            theClient.setSocketChannel(client.getChannel());\n            if (clientDataClass !\u003d null) {\n                if (getClientDataPool() \u003d\u003d null) {\n                    clientData \u003d (ClientData) clientDataClass.newInstance();\n                } else {\n                    clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                }\n                theClient.setClientData(clientData);\n            }\n            try {\n                _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                _chPolled.handleClient(theClient);\n            } catch (java.util.NoSuchElementException nsee) {\n                logger.warning(\"Could not borrow ClientHandler from pool. Error: \" + nsee);\n                logger.warning(\"Closing Socket [\" + client + \"] since no ClientHandler available.\");\n                client.close();\n            }\n            if (_chPolled !\u003d null) {\n                try {\n                    getClientPool().addClient(_chPolled, true);\n                } catch (java.util.NoSuchElementException nsee) {\n                    logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                    //logger.warning(\"Closing Socket [\"+client+\"] since no Thread available.\");\n                    //client.close();\n                    //returnClientHandlerToPool(_chPolled);\n                }\n                _chPolled \u003d null;\n            }\n            client \u003d null;\n            //reset it back\n            setSkipValidation(false);\n        }\n        //end of loop\n    }\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception {\n        int selectCount \u003d 0;\n        Iterator iterator \u003d null;\n        SelectionKey key \u003d null;\n        ServerSocketChannel serverChannel \u003d null;\n        SocketChannel socketChannel \u003d null;\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        boolean stopServerProcessed \u003d false;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        registerChannelRequestMap \u003d new HashMap();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        while (true) {\n            selectCount \u003d selector.select(500);\n            //selectCount \u003d selector.select();//for testing\n            //check for any pending registerChannel req.\n            synchronized (registerChannelRequestMap) {\n                if (registerChannelRequestMap.size() \u003e 0) {\n                    RegisterChannelRequest req \u003d null;\n                    Object hashkey \u003d null;\n                    iterator \u003d registerChannelRequestMap.keySet().iterator();\n                    while (iterator.hasNext()) {\n                        hashkey \u003d iterator.next();\n                        req \u003d (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);\n                        req.register(getSelector());\n                    }\n                    iterator \u003d null;\n                    registerChannelRequestMap.clear();\n                }\n                //if\n            }\n            //sync\n            if (stopServer \u003d\u003d true \u0026\u0026 stopServerProcessed \u003d\u003d false) {\n                logger.warning(\"Closing \" + getName());\n                serverSocketChannel.close();\n                stopServerProcessed \u003d true;\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.warning(\"Closed \" + getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n            if (stopServer \u003d\u003d false \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                logger.finest(\"Server must have re-started.. will break\");\n                break;\n            }\n            if (selectCount \u003d\u003d 0 \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                java.util.Set keyset \u003d selector.keys();\n                if (keyset.isEmpty() \u003d\u003d true \u0026\u0026 getClientCount() \u003c\u003d 0) {\n                    break;\n                } else {\n                    continue;\n                }\n            } else if (selectCount \u003d\u003d 0) {\n                continue;\n            }\n            iterator \u003d selector.selectedKeys().iterator();\n            while (iterator.hasNext()) {\n                key \u003d (SelectionKey) iterator.next();\n                if (key.isValid() \u003d\u003d false) {\n                    iterator.remove();\n                    continue;\n                }\n                if (key.isAcceptable() \u0026\u0026 stopServer \u003d\u003d false) {\n                    logger.finest(\"Key is Acceptable\");\n                    serverChannel \u003d (ServerSocketChannel) key.channel();\n                    socketChannel \u003d serverChannel.accept();\n                    if (socketChannel \u003d\u003d null) {\n                        iterator.remove();\n                        continue;\n                    }\n                    client \u003d socketChannel.socket();\n                    if (linger \u003c 0) {\n                        client.setSoLinger(false, 0);\n                    } else {\n                        client.setSoLinger(true, linger);\n                    }\n                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                        //low delay\u003d10\n                        client.setTrafficClass(socketTrafficClass);\n                    }\n                    logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                        logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n                    }\n                    if (checkAccessConstraint(client) \u003d\u003d false) {\n                        iterator.remove();\n                        continue;\n                    }\n                    socketChannel.configureBlocking(false);\n                    theClient.setTrusted(getSkipValidation());\n                    theClient.setSocket(socketChannel.socket());\n                    theClient.setSocketChannel(socketChannel);\n                    if (clientDataClass !\u003d null) {\n                        if (getClientDataPool() \u003d\u003d null) {\n                            clientData \u003d (ClientData) clientDataClass.newInstance();\n                        } else {\n                            //borrow a object from pool\n                            clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                        }\n                        theClient.setClientData(clientData);\n                    }\n                    //Check if max connection has reached\n                    if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                        theClient.setClientEvent(ClientEvent.MAX_CON);\n                    } else {\n                        theClient.setClientEvent(ClientEvent.ACCEPT);\n                    }\n                    try {\n                        _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                        logger.finest(\"Asking \" + _chPolled.getName() + \" to handle.\");\n                        _chPolled.handleClient(theClient);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.warning(\"Could not borrow ClientHandler Object from pool. Error: \" + nsee);\n                        logger.warning(\"Closing SocketChannel [\" + serverChannel.socket() + \"] since no ClientHandler available.\");\n                        socketChannel.close();\n                    }\n                    if (_chPolled !\u003d null) {\n                        try {\n                            getClientPool().addClient(_chPolled, true);\n                        } catch (java.util.NoSuchElementException nsee) {\n                            logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                            //logger.warning(\"Closing SocketChannel [\"+serverChannel.socket()+\"] since no Thread available.\");\n                            //socketChannel.close();\n                            //returnClientHandlerToPool(_chPolled);\n                        }\n                        _chPolled \u003d null;\n                    }\n                    socketChannel \u003d null;\n                    client \u003d null;\n                    //reset it back\n                    setSkipValidation(false);\n                } else if (key.isValid() \u0026\u0026 key.isReadable()) {\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Readable, removing OP_READ from interestOps for \" + _ch.getName());\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_READ));\n                        _ch.addEvent(ClientEvent.READ);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.READ);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (key.isValid() \u0026\u0026 key.isWritable()) {\n                    if (getClientPool().shouldNioWriteHappen() \u003d\u003d false) {\n                        //no need to remove the key\n                        continue;\n                    }\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Writable, removing OP_WRITE from interestOps for \" + _ch.getName());\n                        //remove OP_WRITE from interest set\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_WRITE));\n                        _ch.addEvent(ClientEvent.WRITE);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.WRITE);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (stopServer \u003d\u003d true \u0026\u0026 key.isAcceptable()) {\n                    //we will not accept this key\n                    //reset it back\n                    setSkipValidation(false);\n                } else {\n                    logger.warning(\"Unknown key got in SelectionKey: \" + key);\n                }\n                //Remove key\n                iterator.remove();\n                Thread.yield();\n            }\n            //end of iterator\n            iterator \u003d null;\n        }\n        //end of loop\n    }\n\n    private boolean checkAccessConstraint(Socket socket) {\n        try {\n            if (getAccessConstraintConfig() !\u003d null) {\n                getAccessConstraintConfig().checkAccept(socket);\n            }\n            return true;\n        } catch (SecurityException se) {\n            logger.warning(\"SecurityException occurred accepting connection : \" + se.getMessage());\n            return false;\n        }\n    }\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {\n        if (getSelector() \u003d\u003d null) {\n            throw new IllegalStateException(\"Selector is not open!\");\n        }\n        if (channel \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Can\u0027t register a null channel!\");\n        }\n        if (channel.isConnected() \u003d\u003d false) {\n            throw new ClosedChannelException();\n        }\n        RegisterChannelRequest req \u003d new RegisterChannelRequest(channel, ops, att);\n        RegisterChannelRequest reqOld \u003d null;\n        synchronized (registerChannelRequestMap) {\n            reqOld \u003d (RegisterChannelRequest) registerChannelRequestMap.get(channel);\n            if (reqOld \u003d\u003d null) {\n                registerChannelRequestMap.put(channel, req);\n                getSelector().wakeup();\n                return true;\n            } else {\n                if (reqOld.equals(req) \u003d\u003d false) {\n                    reqOld.setOps(reqOld.getOps() | req.getOps());\n                    reqOld.setAtt(req.getAtt());\n                    return true;\n                }\n                return false;\n            }\n        }\n        /*\n\t\tlogger.warning(\"Before register...\");\n\t\tchannel.register(getSelector(), ops, att);\n\t\tlogger.warning(\"Before wakeup and after register...\");\n\t\tgetSelector().wakeup();\n\t\tlogger.warning(\"After wakeup...\");\n\t\t*/\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig) {\n        logger.finer(\"Creating ByteBufferPool pool\");\n        int bufferSize \u003d getBasicConfig().getAdvancedSettings().getByteBufferSize();\n        boolean useDirectByteBuffer \u003d getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();\n        PoolableObjectFactory factory \u003d new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);\n        byteBufferPool \u003d poolManager.makeByteBufferPool(factory, opConfig);\n        poolManager.initPool(byteBufferPool, opConfig);\n    }\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool() {\n        return byteBufferPool;\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientThread pool\");\n        ThreadObjectFactory factory \u003d new ThreadObjectFactory();\n        ObjectPool objectPool \u003d poolManager.makeClientPool(factory, opConfig);\n        pool \u003d new ClientPool(makeQSObjectPool(objectPool), opConfig);\n        factory.setClientPool(pool);\n        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());\n        poolManager.initPool(objectPool, opConfig);\n    }\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler) {\n        clientWriteHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler() {\n        return clientWriteHandlerString;\n    }\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be \u003ccode\u003enull\u003c/code\u003e if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime() {\n        return lastStartTime;\n    }\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag) {\n        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);\n        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);\n    }\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier() {\n        return clientIdentifier;\n    }\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {\n        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);\n    }\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode() {\n        return blockingMode;\n    }\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception {\n        if (clientCommandHandlerString \u003d\u003d null \u0026\u0026 clientEventHandlerString \u003d\u003d null) {\n            logger.severe(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n            throw new AppException(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n        }\n        clientCommandHandler \u003d null;\n        if (clientCommandHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientCommandHandler class..\");\n            Class clientCommandHandlerClass \u003d getClass(clientCommandHandlerString, true);\n            clientCommandHandler \u003d (ClientCommandHandler) clientCommandHandlerClass.newInstance();\n        }\n        boolean setClientCommandHandlerLookup \u003d false;\n        clientEventHandler \u003d null;\n        if (clientEventHandlerString \u003d\u003d null) {\n            clientEventHandlerString \u003d \"org.quickserver.net.server.impl.DefaultClientEventHandler\";\n            setClientCommandHandlerLookup \u003d true;\n        }\n        logger.finest(\"Loading ClientEventHandler class..\");\n        if (clientEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientEventHandler.class.isInstance(clientCommandHandler)) {\n            clientEventHandler \u003d (ClientEventHandler) clientCommandHandler;\n        } else {\n            clientEventHandler \u003d (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();\n            if (setClientCommandHandlerLookup) {\n                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);\n            }\n        }\n        clientExtendedEventHandler \u003d null;\n        if (clientExtendedEventHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientExtendedEventHandler class..\");\n            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientCommandHandler;\n            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientEventHandler;\n            } else {\n                Class clientExtendedEventHandlerClass \u003d getClass(clientExtendedEventHandlerString, true);\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();\n            }\n        }\n        clientObjectHandler \u003d null;\n        if (clientObjectHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientObjectHandler class..\");\n            if (clientObjectHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientCommandHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientCommandHandler;\n            } else if (clientObjectHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientEventHandler;\n            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientExtendedEventHandler;\n            } else {\n                clientObjectHandler \u003d (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientBinaryHandler \u003d null;\n        if (clientBinaryHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientBinaryHandler class..\");\n            if (clientBinaryHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientCommandHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientCommandHandler;\n            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientExtendedEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientObjectHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientObjectHandler;\n            } else {\n                clientBinaryHandler \u003d (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientWriteHandler \u003d null;\n        if (clientWriteHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientWriteHandler class..\");\n            if (clientWriteHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientCommandHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientCommandHandler;\n            } else if (clientWriteHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientEventHandler;\n            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientExtendedEventHandler;\n            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientObjectHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientObjectHandler;\n            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientBinaryHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientBinaryHandler;\n            } else {\n                clientWriteHandler \u003d (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        Class authenticatorClass \u003d null;\n        if (clientAuthenticationHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientAuthenticationHandler class..\");\n            authenticatorClass \u003d getClass(clientAuthenticationHandlerString, true);\n        }\n        if (authenticatorClass !\u003d null) {\n            Object obj \u003d authenticatorClass.newInstance();\n            if (ClientAuthenticationHandler.class.isInstance(obj))\n                clientAuthenticationHandler \u003d (ClientAuthenticationHandler) obj;\n            else\n                authenticator \u003d (Authenticator) obj;\n        }\n        clientDataClass \u003d null;\n        if (clientDataString !\u003d null) {\n            logger.finest(\"Loading ClientData class..\");\n            clientDataClass \u003d getClass(clientDataString, true);\n        }\n        Assertion.affirm(clientEventHandler !\u003d null, \"ClientEventHandler was not loaded!\");\n    }\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler) {\n        clientEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler() {\n        return clientEventHandlerString;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {\n        if (dataType \u003d\u003d DataType.IN)\n            this.defaultDataModeIN \u003d dataMode;\n        if (dataType \u003d\u003d DataType.OUT)\n            this.defaultDataModeOUT \u003d dataMode;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {\n        defaultDataModeIN \u003d defaultDataMode.getDataMode(DataType.IN);\n        defaultDataModeOUT \u003d defaultDataMode.getDataMode(DataType.OUT);\n        ;\n    }\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType) {\n        if (dataType \u003d\u003d DataType.IN)\n            return defaultDataModeIN;\n        if (dataType \u003d\u003d DataType.OUT)\n            return defaultDataModeOUT;\n        else\n            throw new IllegalArgumentException(\"Unknown DataType: \" + dataType);\n    }\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler) {\n        clientExtendedEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler() {\n        return clientExtendedEventHandlerString;\n    }\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception {\n        if (getApplicationJarPath() !\u003d null \u0026\u0026 getClassLoader() \u003d\u003d null) {\n            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));\n            //update qsadmin to use the same\n            if (adminServer !\u003d null) {\n                adminServer.getServer().setClassLoader(getClassLoader());\n            }\n        }\n    }\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID() {\n        return pid;\n    }\n\n    public boolean isRawCommunicationLogging() {\n        return rawCommunicationLogging;\n    }\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {\n        this.rawCommunicationLogging \u003d rawCommunicationLogging;\n    }\n\n    public int getRawCommunicationMaxLength() {\n        return rawCommunicationMaxLength;\n    }\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {\n        this.rawCommunicationMaxLength \u003d rawCommunicationMaxLength;\n    }\n}\n",
    "package": "org.quickserver.net.server",
    "classname": "QuickServer",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_4Test.java",
    "test_prompt": "// QuickServer_4Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#initService(Object[])} method.\n*/\nclass QuickServer_4Test {",
    "method_signature": "initService(Object[])",
    "suffix": "4"
  },
  {
    "numberTests": "ten",
    "original_code": "// QuickServer.java\n/*\n * This file is part of the QuickServer library \n * Copyright (C) QuickServer.org\n *\n * Use, modification, copying and distribution of this software is subject to\n * the terms and conditions of the GNU Lesser General Public License. \n * You should have received a copy of the GNU LGP License along with this \n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\n *\n * For questions, suggestions, bug-reports, enhancement-requests etc.\n * visit http://www.quickserver.org\n *\n */\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n *  Main class of QuickServer library. This class is used to create\n *  multi client servers quickly.\n *  \u003cp\u003e\n *  Ones a client is connected, it creates {@link ClientHandler} object,\n *  which is run using any thread available from the pool of threads\n *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n *  handles the client. \u003cbr/\u003e\n *  QuickServer divides the application logic of its developer over eight\n *  class, \u003cbr\u003e\n *  \t\u003cul\u003e\n * \t\t\u003cli\u003eClientEventHandler\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client events [Optional Class].\n *  \t\t\u003cli\u003eClientCommandHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client character/string commands.\n *  \t\t\u003cli\u003eClientObjectHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - Object commands.\n * \t\t\u003cli\u003eClientBinaryHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - binary data.\n * \t\t\u003cli\u003eClientWriteHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n *  \t\t\u003cli\u003eClientAuthenticationHandler [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Used to Authencatet a client.\n *  \t\t\u003cli\u003eClientData [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Client data carrier (support class)\n * \t\t\u003cli\u003eClientExtendedEventHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles extended client events.\n *  \t\u003c/ul\u003e\n *\n *  [#] \u003d Any one of these have to be set based on default DataMode for input.\n *  The default DataMode for input is String so if not changes you will\n *  have to set ClientCommandHandler.\n *  \u003c/p\u003e\n *  \u003cp\u003e\n *   Eg:\n *  \u003ccode\u003e\u003cBLOCKQUOTE\u003e\u003cpre\u003e\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle \u003d \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer \u003d new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * \u003c/pre\u003e\u003c/BLOCKQUOTE\u003e\u003c/code\u003e\u003c/p\u003e\n *\n *  @version 1.4.8\n *  @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //Some variable are not initialised to any value because the\n    //default java value was desired initial value.\n    //\u0027dev \u0027 \u003d development build not yet final\n    //\u0027beta\u0027 \u003d test build all features\n    //change also in QSAdminMain\n    private final static String VER \u003d \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n        if (System.getProperty(\"org.quickserver.useOSLineSeparator\") !\u003d null \u0026\u0026 System.getProperty(\"org.quickserver.useOSLineSeparator\").equals(\"true\")) {\n            NEW_LINE \u003d System.getProperty(\"line.separator\");\n        } else {\n            NEW_LINE \u003d \"\\r\\n\";\n        }\n        String _pid \u003d ManagementFactory.getRuntimeMXBean().getName();\n        int i \u003d _pid.indexOf(\"@\");\n        pid \u003d _pid.substring(0, i);\n        System.out.print(\"Loading QuickServer v\" + getVersion() + \" [PID:\" + pid + \"]\");\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort \u003d 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName \u003d \"QuickServer\";\n\n    private long maxConnection \u003d -1;\n\n    //1 min socket timeout\n    private int socketTimeout \u003d 60 * 1000;\n\n    private String maxConnectionMsg \u003d \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg \u003d \"-ERR Timeout\";\n\n    private String maxAuthTryMsg \u003d \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry \u003d 5;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //--v1.2\n    //Logger for QuickServer\n    private static final Logger logger \u003d Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //for Service interface\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState \u003d Service.UNKNOWN;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.3\n    private QuickServerConfig config \u003d new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel \u003d \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel \u003d \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation \u003d false;\n\n    private boolean communicationLogging \u003d true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig \u003d config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km \u003d null;\n\n    private TrustManager[] tm \u003d null;\n\n    private boolean runningSecure \u003d false;\n\n    private SecureStoreManager secureStoreManager \u003d null;\n\n    private Exception exceptionInRun \u003d null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode \u003d true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN \u003d DataMode.STRING;\n\n    private DataMode defaultDataModeOUT \u003d DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging \u003d false;\n\n    private int rawCommunicationMaxLength \u003d 100;\n\n    static {\n        System.out.println(\" Done\");\n        //should be commented if not a patch release\n        //System.out.println(\"[Includes patch(#): t\u003d152\u0026p\u003d532]\");\n        //should be commented if not a dev release\n        //System.out.println(\"[Dev Build Date: Saturday, October 29, 2005]\");\n        logger.log(Level.FINE, \"PID: {0}\", pid);\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion() {\n        return VER;\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo() {\n        return getVersionNo(VER);\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver) {\n        //String ver \u003d getVersion();\n        float version \u003d 0;\n        //check if beta\n        int i \u003d ver.indexOf(\" \");\n        if (i \u003d\u003d -1)\n            i \u003d ver.length();\n        ver \u003d ver.substring(0, i);\n        //check for sub version\n        i \u003d ver.indexOf(\".\");\n        if (i !\u003d -1) {\n            int j \u003d ver.indexOf(\".\", i);\n            if (j !\u003d -1) {\n                ver \u003d ver.substring(0, i) + \".\" + MyString.replaceAll(ver.substring(i + 1), \".\", \"\");\n            }\n        }\n        try {\n            version \u003d Float.parseFloat(ver);\n        } catch (NumberFormatException e) {\n            throw new RuntimeException(\"Corrupt QuickServer\");\n        }\n        return version;\n    }\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine() {\n        return NEW_LINE;\n    }\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString() {\n        return serverName + \" : \" + getPort();\n    }\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n        setClientCommandHandler(commandHandler);\n    }\n\n    /**\n     * Creates a new server at \u003ccode\u003eport\u003c/code\u003e with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n        //send to another constructor\n        this(commandHandler);\n        setPort(port);\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException {\n        logger.log(Level.FINE, \"Starting {0}\", getName());\n        if (isClosed() \u003d\u003d false) {\n            logger.log(Level.WARNING, \"Server {0} already running.\", getName());\n            throw new AppException(\"Server \" + getName() + \" already running.\");\n        }\n        blockingMode \u003d getBasicConfig().getServerMode().getBlocking();\n        if (getSecure().isEnable() \u0026\u0026 blockingMode \u003d\u003d false) {\n            //TODO we need to fix this..\n            logger.warning(\"QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode.\");\n            blockingMode \u003d true;\n            getBasicConfig().getServerMode().setBlocking(blockingMode);\n        }\n        if (serverBanner \u003d\u003d null) {\n            serverBanner \u003d \"\\n-------------------------------\" + \"\\n Name : \" + getName() + \"\\n Port : \" + getPort() + \"\\n-------------------------------\\n\";\n            logger.finest(\"Default Server Banner Generated\");\n        }\n        try {\n            loadApplicationClasses();\n            //load class from Advanced Settings\n            Class clientIdentifierClass \u003d getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);\n            clientIdentifier \u003d (ClientIdentifier) clientIdentifierClass.newInstance();\n            clientIdentifier.setQuickServer(QuickServer.this);\n            //load class from ObjectPoolConfig\n            Class poolManagerClass \u003d getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);\n            poolManager \u003d (PoolManager) poolManagerClass.newInstance();\n            //load class QSObjectPoolMaker\n            Class qsObjectPoolMakerClass \u003d getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);\n            qsObjectPoolMaker \u003d (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();\n            loadServerHooksClasses();\n            processServerHooks(ServerHook.PRE_STARTUP);\n            if (getSecure().isLoad() \u003d\u003d true)\n                //v1.4.0\n                loadSSLContext();\n            loadBusinessLogic();\n        } catch (ClassNotFoundException e) {\n            logger.log(Level.SEVERE, \"Could not load class/s: \" + e, e);\n            throw new AppException(\"Could not load class/s : \" + e);\n        } catch (InstantiationException e) {\n            logger.log(Level.SEVERE, \"Could not instantiate class/s: \" + e, e);\n            throw new AppException(\"Could not instantiate class/s: \" + e);\n        } catch (IllegalAccessException e) {\n            logger.log(Level.SEVERE, \"Illegal access to class/s: \" + e, e);\n            throw new AppException(\"Illegal access to class/s: \" + e);\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"IOException: \" + e, e);\n            throw new AppException(\"IOException: \" + e);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Exception: \" + e, e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Exception : \" + e);\n        }\n        //v1.3.3\n        if (getSecurityManagerClass() !\u003d null) {\n            System.setSecurityManager(getSecurityManager());\n        }\n        setServiceState(Service.INIT);\n        t \u003d new Thread(this, \"QuickServer - \" + getName());\n        t.start();\n        do {\n            Thread.yield();\n        } while (getServiceState() \u003d\u003d Service.INIT);\n        if (getServiceState() !\u003d Service.RUNNING) {\n            if (exceptionInRun !\u003d null)\n                throw new AppException(\"Could not start server \" + getName() + \"! Details: \" + exceptionInRun);\n            else\n                throw new AppException(\"Could not start server \" + getName());\n        }\n        lastStartTime \u003d new java.util.Date();\n        logger.log(Level.FINE, \"Started {0}, Date: {1}\", new Object[] { getName(), lastStartTime });\n    }\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException {\n        processServerHooks(ServerHook.PRE_SHUTDOWN);\n        logger.log(Level.WARNING, \"Stopping {0}\", getName());\n        stopServer \u003d true;\n        Socket death \u003d null;\n        if (isClosed() \u003d\u003d true) {\n            logger.log(Level.WARNING, \"Server {0} is not running!\", getName());\n            throw new AppException(\"Server \" + getName() + \" is not running!\");\n        }\n        try {\n            if (getBlockingMode() \u003d\u003d true) {\n                if (getSecure().isEnable() \u003d\u003d false) {\n                    death \u003d new Socket(server.getInetAddress(), server.getLocalPort());\n                    death.getInputStream().read();\n                    death.close();\n                } else {\n                    death \u003d getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());\n                    Thread.sleep(100);\n                    death.close();\n                }\n            }\n            if (serverSocketChannel !\u003d null) {\n                serverSocketChannel.close();\n            }\n        } catch (IOException e) {\n            logger.log(Level.FINE, \"IOError stopping {0}: {1}\", new Object[] { getName(), e });\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error stopping {0}: {1}\", new Object[] { getName(), e });\n            throw new AppException(\"Error in stopServer \" + getName() + \": \" + e);\n        }\n        for (int i \u003d 0; getServiceState() !\u003d Service.STOPPED; i++) {\n            try {\n                Thread.sleep(60);\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error waiting for {0} to fully stop. Error: {1}\", new Object[] { getName(), e });\n            }\n            if (i \u003e 1000) {\n                logger.severe(\"Server was not stopped even after 10sec.. will terminate now.\");\n                System.exit(-1);\n            }\n        }\n        if (adminServer \u003d\u003d null || getQSAdminServer().getServer() !\u003d this) {\n            //so this is not qsadmin\n            setClassLoader(null);\n        }\n        logger.log(Level.INFO, \"Stopped {0}\", getName());\n    }\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException {\n        stopServer();\n        startServer();\n    }\n\n    /**\n     * Returns the name of the QuickServer. Default is \u0027QuickServer\u0027.\n     * @see #setName\n     */\n    public String getName() {\n        return serverName;\n    }\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name) {\n        serverName \u003d name;\n        logger.log(Level.FINEST, \"Set to : {0}\", name);\n    }\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner() {\n        return serverBanner;\n    }\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. \u003cbr\u003e\u0026nbsp;\u003cbr\u003e\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner) {\n        serverBanner \u003d banner;\n        logger.log(Level.FINEST, \"Set to : {0}\", banner);\n    }\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port) {\n        if (port \u003c 0) {\n            throw new IllegalArgumentException(\"Port number can not be less than 0!\");\n        }\n        serverPort \u003d port;\n        logger.log(Level.FINEST, \"Set to {0}\", port);\n    }\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort() {\n        if (isClosed() \u003d\u003d false) {\n            return server.getLocalPort();\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            return serverPort;\n        } else {\n            int _port \u003d getSecure().getPort();\n            if (_port \u003d\u003d -1)\n                return serverPort;\n            else\n                return _port;\n        }\n    }\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler) {\n        clientCommandHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler() {\n        return clientCommandHandlerString;\n    }\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data) {\n        this.clientDataString \u003d data;\n        logger.log(Level.FINEST, \"Set to {0}\", data);\n    }\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData() {\n        return clientDataString;\n    }\n\n    /**\n     * Sets the client socket\u0027s timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time) {\n        if (time \u003e 0)\n            socketTimeout \u003d time;\n        else\n            socketTimeout \u003d 0;\n        logger.log(Level.FINEST, \"Set to {0}\", socketTimeout);\n    }\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout() {\n        return socketTimeout;\n    }\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry) {\n        maxAuthTry \u003d authTry;\n        logger.log(Level.FINEST, \"Set to {0}\", authTry);\n    }\n\n    /**\n     * Returns max allowed login attempts. Default is \u003ccode\u003e5\u003c/code\u003e.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry() {\n        return maxAuthTry;\n    }\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg) {\n        maxAuthTryMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg() {\n        return maxAuthTryMsg;\n    }\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg) {\n        timeoutMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg() {\n        return timeoutMsg;\n    }\n\n    private TheClient initTheClient() {\n        TheClient theClient \u003d new TheClient();\n        theClient.setServer(QuickServer.this);\n        theClient.setTimeoutMsg(getTimeoutMsg());\n        //v1.2\n        theClient.setMaxAuthTry(getMaxAuthTry());\n        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());\n        theClient.setClientEventHandler(clientEventHandler);\n        //v1.4.6\n        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);\n        theClient.setClientCommandHandler(clientCommandHandler);\n        //v1.2\n        theClient.setClientObjectHandler(clientObjectHandler);\n        //v1.4\n        theClient.setClientBinaryHandler(clientBinaryHandler);\n        //v1.4.5\n        theClient.setClientWriteHandler(clientWriteHandler);\n        //v1.3\n        theClient.setAuthenticator(authenticator);\n        //v1.4.6\n        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);\n        theClient.setTimeout(socketTimeout);\n        theClient.setMaxConnectionMsg(maxConnectionMsg);\n        //v1.3.2\n        theClient.setCommunicationLogging(getCommunicationLogging());\n        return theClient;\n    }\n\n    public void run() {\n        exceptionInRun \u003d null;\n        TheClient theClient \u003d initTheClient();\n        try {\n            stopServer \u003d false;\n            closeAllPools();\n            initAllPools();\n            makeServerSocket();\n            //print banner\n            System.out.println(serverBanner);\n            //v1.2\n            setServiceState(Service.RUNNING);\n            //v1.3.3\n            processServerHooks(ServerHook.POST_STARTUP);\n            if (getBlockingMode() \u003d\u003d false) {\n                runNonBlocking(theClient);\n                if (stopServer \u003d\u003d true) {\n                    logger.log(Level.FINEST, \"Closing selector for {0}\", getName());\n                    selector.close();\n                }\n                return;\n            } else {\n                runBlocking(theClient);\n            }\n        } catch (BindException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"{0} BindException for Port {1} @ {2} : {3}\", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });\n        } catch (javax.net.ssl.SSLException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"SSLException {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (IOException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"IOError {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (Exception e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"Error {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } finally {\n            if (getBlockingMode() \u003d\u003d true) {\n                logger.log(Level.WARNING, \"Closing {0}\", getName());\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            } else if (getBlockingMode() \u003d\u003d false \u0026\u0026 exceptionInRun !\u003d null) {\n                logger.log(Level.WARNING, \"Closing {0} - Had Error: {1}\", new Object[] { getName(), exceptionInRun });\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        if (serverSocketChannel !\u003d null)\n                            serverSocketChannel.close();\n                        if (server !\u003d null)\n                            server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n        }\n    }\n\n    //end of run\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnection \u003d maxConnection;\n        else\n            this.maxConnection \u003d maxConnection;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnection);\n    }\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection() {\n        return maxConnection;\n    }\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount() {\n        if (clientHandlerPool !\u003d null) {\n            try {\n                return getClientHandlerPool().getNumActive();\n            } catch (Exception e) {\n                return 0;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : \u003ccode\u003e-ERR Server Busy. Max Connection Reached\u003c/code\u003e\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n        else\n            this.maxConnectionMsg \u003d maxConnectionMsg;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnectionMsg);\n    }\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg() {\n        return maxConnectionMsg;\n    }\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException {\n        ipAddr \u003d InetAddress.getByName(bindAddr);\n        logger.log(Level.FINEST, \"Set to {0}\", bindAddr);\n    }\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr() {\n        if (ipAddr \u003d\u003d null) {\n            try {\n                ipAddr \u003d InetAddress.getByName(\"0.0.0.0\");\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Unable to create default ip(0.0.0.0) : {0}\", e);\n                throw new RuntimeException(\"Error: Unable to find servers own ip : \" + e);\n            }\n        }\n        return ipAddr;\n    }\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects) {\n        this.storeObjects \u003d storeObjects;\n    }\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return \u003ccode\u003enull\u003c/code\u003e.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects() {\n        return storeObjects;\n    }\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port) {\n        getQSAdminServer().getServer().setPort(port);\n    }\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort() {\n        return getQSAdminServer().getServer().getPort();\n    }\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator) {\n        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);\n    }\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator() {\n        return getQSAdminServer().getServer().getAuthenticator();\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException {\n        getQSAdminServer().setClientAuthenticationHandler(authenticator);\n        getQSAdminServer().startServer(port);\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException {\n        getQSAdminServer().startServer();\n    }\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer() {\n        if (adminServer \u003d\u003d null)\n            adminServer \u003d new QSAdminServer(QuickServer.this);\n        return adminServer;\n    }\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer) {\n        if (adminServer \u003d\u003d null)\n            this.adminServer \u003d adminServer;\n    }\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed() {\n        if (server \u003d\u003d null)\n            return true;\n        return server.isClosed();\n    }\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer\u0027s own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger() {\n        if (appLogger !\u003d null)\n            return appLogger;\n        return logger;\n    }\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger) {\n        this.appLogger \u003d appLogger;\n    }\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler) {\n        clientObjectHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler() {\n        return clientObjectHandlerString;\n    }\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n        if (formatter \u003d\u003d null)\n            return;\n        consoleLoggingformatter \u003d formatter;\n        java.util.logging.Formatter conformatter \u003d (java.util.logging.Formatter) getClass(formatter, true).newInstance();\n        Logger jdkLogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d jdkLogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                handlers[index].setFormatter(conformatter);\n            }\n        }\n        logger.log(Level.FINEST, \"Set to {0}\", formatter);\n    }\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter() {\n        return consoleLoggingformatter;\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MiniFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to logging.MiniFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MicroFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to MicroFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        boolean isConsole \u003d true;\n        try {\n            if (System.console() \u003d\u003d null) {\n                isConsole \u003d false;\n            }\n        } catch (Throwable e) {\n            //ignore\n        }\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                if (isConsole \u003d\u003d false \u0026\u0026 level !\u003d Level.OFF) {\n                    System.out.println(\"QuickServer: You do not have a console.. so turning console logger off..\");\n                    level \u003d Level.OFF;\n                }\n                if (level \u003d\u003d Level.OFF) {\n                    logger.info(\"QuickServer: Removing console handler.. \");\n                    rlogger.removeHandler(handlers[index]);\n                    handlers[index].setLevel(level);\n                    handlers[index].close();\n                } else {\n                    handlers[index].setLevel(level);\n                }\n            }\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            consoleLoggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            consoleLoggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            consoleLoggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            consoleLoggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            consoleLoggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            consoleLoggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            consoleLoggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            consoleLoggingLevel \u003d \"OFF\";\n        else\n            consoleLoggingLevel \u003d \"UNKNOWN\";\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel() {\n        return consoleLoggingLevel;\n    }\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            handlers[index].setLevel(level);\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            loggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            loggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            loggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            loggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            loggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            loggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            loggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            loggingLevel \u003d \"OFF\";\n        else\n            loggingLevel \u003d \"UNKNOWN\";\n        consoleLoggingLevel \u003d loggingLevel;\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    //*** Start of Service interface methods\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError() {\n        return serviceError;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param) {\n        serviceError \u003d null;\n        try {\n            initServer(param);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig) {\n        serviceError \u003d null;\n        try {\n            initServer(qsConfig);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING)\n            return false;\n        try {\n            startServer();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.STOPPED)\n            return false;\n        try {\n            stopServer();\n            clearAllPools();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING) {\n            suspendMaxConnection \u003d maxConnection;\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n            maxConnection \u003d 0;\n            maxConnectionMsg \u003d \"Service is suspended.\";\n            setServiceState(Service.SUSPENDED);\n            logger.log(Level.INFO, \"Service {0} is suspended.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.SUSPENDED) {\n            maxConnection \u003d suspendMaxConnection;\n            maxConnectionMsg \u003d suspendMaxConnectionMsg;\n            setServiceState(Service.RUNNING);\n            logger.log(Level.INFO, \"Service {0} resumed.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info() {\n        serviceError \u003d null;\n        StringBuilder buf \u003d new StringBuilder();\n        buf.append(getName()).append(\"\\n\");\n        buf.append(getBindAddr().getHostAddress()).append(\" \");\n        buf.append(getPort()).append(\"\\n\");\n        return buf.toString();\n    }\n\n    // *** End of Service interface methods\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException {\n        QuickServerConfig qsConfig \u003d null;\n        try {\n            qsConfig \u003d ConfigReader.read((String) param[0]);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not init server from xml file {0} : {1}\", new Object[] { new File((String) param[0]).getAbsolutePath(), e });\n            throw new AppException(\"Could not init server from xml file\", e);\n        }\n        initServer(qsConfig);\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {\n        setConfig(qsConfig);\n        try {\n            configQuickServer();\n            loadApplicationClasses();\n            //start InitServerHooks\n            InitServerHooks ish \u003d getConfig().getInitServerHooks();\n            if (ish !\u003d null) {\n                Iterator iterator \u003d ish.iterator();\n                String initServerHookClassName \u003d null;\n                Class initServerHookClass \u003d null;\n                InitServerHook initServerHook \u003d null;\n                while (iterator.hasNext()) {\n                    initServerHookClassName \u003d (String) iterator.next();\n                    initServerHookClass \u003d getClass(initServerHookClassName, true);\n                    initServerHook \u003d (InitServerHook) initServerHookClass.newInstance();\n                    logger.log(Level.INFO, \"Loaded init server hook: {0}\", initServerHookClassName);\n                    logger.log(Level.FINE, \"Init server hook info: {0}\", initServerHook.info());\n                    initServerHook.handleInit(QuickServer.this);\n                }\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not load init server hook: {0}\", e);\n            logger.log(Level.WARNING, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Could not load init server hook\", e);\n        }\n        setServiceState(Service.INIT);\n        logger.log(Level.FINEST, \"\\r\\n{0}\", MyString.getSystemInfo(getVersion()));\n    }\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState() {\n        return serviceState;\n    }\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state) {\n        serviceState \u003d state;\n    }\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp) {\n        if (temp.equals(\"SEVERE\"))\n            qs.setConsoleLoggingLevel(Level.SEVERE);\n        else if (temp.equals(\"WARNING\"))\n            qs.setConsoleLoggingLevel(Level.WARNING);\n        else if (temp.equals(\"INFO\"))\n            qs.setConsoleLoggingLevel(Level.INFO);\n        else if (temp.equals(\"CONFIG\"))\n            qs.setConsoleLoggingLevel(Level.CONFIG);\n        else if (temp.equals(\"FINE\"))\n            qs.setConsoleLoggingLevel(Level.FINE);\n        else if (temp.equals(\"FINER\"))\n            qs.setConsoleLoggingLevel(Level.FINER);\n        else if (temp.equals(\"FINEST\"))\n            qs.setConsoleLoggingLevel(Level.FINEST);\n        else if (temp.equals(\"OFF\"))\n            qs.setConsoleLoggingLevel(Level.OFF);\n        else\n            logger.log(Level.WARNING, \"unknown level {0}\", temp);\n    }\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception {\n        QuickServer qs \u003d QuickServer.this;\n        //v1.3\n        qs.setConfig(config);\n        qs.setBasicConfig(config);\n        String temp \u003d config.getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        temp \u003d null;\n        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        //v1.3.3\n        qs.setSecurityManagerClass(config.getSecurityManagerClass());\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        temp \u003d config.getApplicationJarPath();\n        if (temp !\u003d null) {\n            File ajp \u003d new File(temp);\n            if (ajp.isAbsolute() \u003d\u003d false) {\n                temp \u003d config.getConfigFile();\n                ajp \u003d new File(temp);\n                temp \u003d ajp.getParent() + File.separatorChar + config.getApplicationJarPath();\n                config.setApplicationJarPath(temp);\n                temp \u003d null;\n            }\n            qs.setApplicationJarPath(config.getApplicationJarPath());\n            //set path also to QSAdmin\n            if (config.getQSAdminServerConfig() !\u003d null) {\n                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());\n            }\n        }\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception {\n        QuickServer qs \u003d getQSAdminServer().getServer();\n        qs.setBasicConfig(config);\n        //set the Logging Level to same as main QS\n        //config.getConsoleLoggingLevel();\n        String temp \u003d getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        //set the Logging Formatter to same as main QS\n        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());\n        //v1.4.6\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        //v1.4.6\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());\n        //v1.3.2\n        if (config.getCommandShellEnable().equals(\"true\"))\n            getQSAdminServer().setShellEnable(true);\n        getQSAdminServer().setPromptName(config.getCommandShellPromptName());\n        //v1.3.3\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception {\n        configQuickServer(getConfig());\n        if (getConfig().getQSAdminServerConfig() !\u003d null) {\n            configQuickServer(getConfig().getQSAdminServerConfig());\n        }\n    }\n\n    /**\n     * Usage: QuickServer [-options]\u003cbr/\u003e\n     * Where options include:\u003cbr/\u003e\n     *   -about\t\tOpens About Dialogbox\u003cbr/\u003e\n     *   -load \u003cxml_config_file\u003e [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File \u003cnew_file_name\u003e\n     */\n    public static void main(String[] args) {\n        try {\n            if (args.length \u003e\u003d 1) {\n                if (args[0].equals(\"-about\")) {\n                    org.quickserver.net.server.gui.About.main(null);\n                } else if (args[0].equals(\"-load\") \u0026\u0026 args.length \u003e\u003d 2) {\n                    QuickServer qs \u003d QuickServer.load(args[1]);\n                    if (qs !\u003d null)\n                        handleOptions(args, qs);\n                } else {\n                    System.out.println(printUsage());\n                }\n            } else {\n                System.out.println(printUsage());\n                org.quickserver.net.server.gui.About.showAbout();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException {\n        QuickServer qs \u003d new QuickServer();\n        Object[] config \u003d new Object[] { xml };\n        qs.initServer(config);\n        qs.startServer();\n        if (qs.getConfig().getQSAdminServerConfig() !\u003d null) {\n            qs.startQSAdminServer();\n        }\n        return qs;\n    }\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage() {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"QuickServer - Java library/framework for creating robust multi-client TCP servers.\\n\");\n        sb.append(\"Copyright (C) QuickServer.org\\n\\n\");\n        sb.append(\"Usage: QuickServer [-options]\\n\");\n        sb.append(\"Where options include:\\n\");\n        sb.append(\"  -about\\t\" + \"Opens About Dialog box\\n\");\n        sb.append(\"  -load \u003cxml_config_file\u003e [load-options]\\t\" + \"Loads the server from xml file.\\n\");\n        sb.append(\"  Where load-options include:\\n\");\n        sb.append(\"     -fullXML2File \u003cfile_name\u003e\\t\" + \"Dumps the Full XML configuration of the QuickServer loaded.\\n\");\n        return sb.toString();\n    }\n\n    private static void handleOptions(String[] args, QuickServer quickserver) {\n        if (args.length \u003c 3)\n            return;\n        if (args[2].equals(\"-fullXML2File\") \u0026\u0026 args.length \u003e\u003d 4) {\n            File file \u003d new File(args[3]);\n            logger.log(Level.INFO, \"Writing full xml configuration to file: {0}\", file.getAbsolutePath());\n            try {\n                TextFile.write(file, quickserver.getConfig().toXML(null));\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error writing full xml configuration: {0}\", e);\n            }\n        }\n    }\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception {\n        try {\n            if (pool !\u003d null)\n                getClientPool().clear();\n            if (clientHandlerPool !\u003d null)\n                getClientHandlerPool().clear();\n            if (getClientDataPool() !\u003d null)\n                getClientDataPool().clear();\n            if (getDBPoolUtil() !\u003d null)\n                getDBPoolUtil().clean();\n            if (byteBufferPool !\u003d null)\n                getByteBufferPool().clear();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error: {0}\", e);\n            throw e;\n        }\n    }\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception {\n        if (pool \u003d\u003d null \u0026\u0026 clientHandlerPool \u003d\u003d null \u0026\u0026 getClientDataPool() \u003d\u003d null \u0026\u0026 getDBPoolUtil() \u003d\u003d null \u0026\u0026 byteBufferPool \u003d\u003d null) {\n            return;\n        }\n        logger.log(Level.FINE, \"Closing pools for {0}\", getName());\n        try {\n            if (pool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {\n                logger.finer(\"Closing ClientThread pool.\");\n                getClientPool().close();\n            }\n            if (clientHandlerPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientHandlerPool())) {\n                logger.finer(\"Closing ClientHandler pool.\");\n                getClientHandlerPool().close();\n            }\n            if (getClientDataPool() !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientDataPool())) {\n                logger.finer(\"Closing ClientData pool.\");\n                getClientDataPool().close();\n            }\n            if (getDBPoolUtil() !\u003d null) {\n                logger.finer(\"Closing DB pool.\");\n                getDBPoolUtil().clean();\n            }\n            if (byteBufferPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getByteBufferPool())) {\n                logger.finer(\"Closing ByteBuffer pool.\");\n                getByteBufferPool().close();\n            }\n            logger.log(Level.FINE, \"Closed pools for {0}\", getName());\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error closing pools for {0}: {1}\", new Object[] { getName(), e });\n            throw e;\n        }\n    }\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception {\n        logger.fine(\"Creating pools\");\n        if (getBlockingMode() \u003d\u003d false) {\n            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());\n        }\n        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());\n        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());\n        //check if client data is poolable\n        if (clientDataClass !\u003d null) {\n            try {\n                clientData \u003d (ClientData) clientDataClass.newInstance();\n                if (PoolableObject.class.isInstance(clientData) \u003d\u003d true) {\n                    PoolableObject po \u003d (PoolableObject) clientData;\n                    if (po.isPoolable() \u003d\u003d true) {\n                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());\n                    } else {\n                        clientDataPool \u003d null;\n                        logger.fine(\"ClientData is not poolable!\");\n                    }\n                }\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error: {0}\", e);\n                throw e;\n            }\n        }\n        try {\n            makeDBObjectPool();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error in makeDBObjectPool() : {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw e;\n        }\n        logger.fine(\"Created pools\");\n    }\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool() {\n        if (pool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientPool available yet!\");\n        return pool;\n    }\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientHandler pool\");\n        PoolableObjectFactory factory \u003d new ClientHandlerObjectFactory(getBlockingMode());\n        clientHandlerPool \u003d poolManager.makeClientHandlerPool(factory, opConfig);\n        poolManager.initPool(clientHandlerPool, opConfig);\n        clientHandlerPool \u003d makeQSObjectPool(clientHandlerPool);\n        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool() {\n        if (clientHandlerPool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientHandler Pool available yet!\");\n        return clientHandlerPool;\n    }\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config) {\n        this.config \u003d config;\n    }\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig() {\n        return config;\n    }\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientData pool\");\n        clientDataPool \u003d poolManager.makeClientDataPool(factory, opConfig);\n        poolManager.initPool(clientDataPool, opConfig);\n        clientDataPool \u003d makeQSObjectPool(clientDataPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool() {\n        return clientDataPool;\n    }\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return \u003ccode\u003enull\u003c/code\u003e\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil() {\n        return dBPoolUtil;\n    }\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {\n        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);\n    }\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception {\n        if (getConfig().getDBObjectPoolConfig() !\u003d null) {\n            logger.fine(\"Creating DBObject Pool\");\n            //logger.finest(\"Got:\\n\"+getConfig().getDBObjectPoolConfig().toXML(null));\n            Class dbPoolUtilClass \u003d getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);\n            dBPoolUtil \u003d (DBPoolUtil) dbPoolUtilClass.newInstance();\n            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());\n            dBPoolUtil.initPool();\n        }\n    }\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id) {\n        return clientIdentifier.findFirstClientById(id);\n    }\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  \u003ccode\u003e\u003cpre\u003e\n     *    Eg:\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tObject syncObj \u003d quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator \u003d quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tClientIdentifier clientIdentifier \u003d quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator \u003d clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    \u003c/code\u003e\u003c/pre\u003e\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient() {\n        return clientIdentifier.findAllClient();\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern) {\n        return clientIdentifier.findAllClientById(pattern);\n    }\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key) {\n        return clientIdentifier.findClientByKey(key);\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern) {\n        return clientIdentifier.findAllClientByKey(pattern);\n    }\n\n    /**\n     * Sets next client has a trusted client.\n     * \u003cp\u003eThis will skip any authentication and will not set any timeout.\u003c/p\u003e\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted() {\n        setSkipValidation(true);\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation() {\n        return skipValidation;\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation) {\n        skipValidation \u003d validation;\n    }\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging) {\n        this.communicationLogging \u003d communicationLogging;\n    }\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging() {\n        return communicationLogging;\n    }\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass) {\n        if (securityManagerClass !\u003d null)\n            this.securityManagerClass \u003d securityManagerClass;\n    }\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass() {\n        return securityManagerClass;\n    }\n\n    public SecurityManager getSecurityManager() throws AppException {\n        if (getSecurityManagerClass() \u003d\u003d null)\n            return null;\n        SecurityManager sm \u003d null;\n        try {\n            sm \u003d (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();\n        } catch (ClassNotFoundException e) {\n            throw new AppException(e.getMessage());\n        } catch (InstantiationException e) {\n            throw new AppException(e.getMessage());\n        } catch (IllegalAccessException e) {\n            throw new AppException(e.getMessage());\n        }\n        return sm;\n    }\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {\n        this.accessConstraintConfig \u003d accessConstraintConfig;\n    }\n\n    /**\n     * Returns Access constraints if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig() {\n        return accessConstraintConfig;\n    }\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader) {\n        this.classLoader \u003d classLoader;\n        Thread.currentThread().setContextClassLoader(classLoader);\n    }\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader() {\n        return classLoader;\n    }\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException {\n        if (name \u003d\u003d null)\n            throw new IllegalArgumentException(\"Class name can\u0027t be null!\");\n        logger.log(Level.FINEST, \"Class: {0}, reload: {1}\", new Object[] { name, reload });\n        if (reload \u003d\u003d true \u0026\u0026 classLoader !\u003d null) {\n            return classLoader.loadClass(name);\n        } else if (reload \u003d\u003d true \u0026\u0026 classLoader \u003d\u003d null \u0026\u0026 this.getClass().getClassLoader() !\u003d null) {\n            return this.getClass().getClassLoader().loadClass(name);\n        } else if (reload \u003d\u003d false \u0026\u0026 classLoader !\u003d null) {\n            return Class.forName(name, true, classLoader);\n        } else /*if(reload\u003d\u003dfalse \u0026\u0026 classLoader\u003d\u003dnull)*/\n        {\n            return Class.forName(name, true, this.getClass().getClassLoader());\n        }\n    }\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath) {\n        this.applicationJarPath \u003d applicationJarPath;\n    }\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath() {\n        return applicationJarPath;\n    }\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks) {\n        this.serverHooks \u003d serverHooks;\n    }\n\n    /**\n     * Returns ServerHooks if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks() {\n        if (serverHooks \u003d\u003d null)\n            serverHooks \u003d new ServerHooks();\n        return serverHooks;\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses() {\n        if (getServerHooks() \u003d\u003d null)\n            return;\n        listOfServerHooks \u003d new ArrayList();\n        ServerHook serverHook \u003d null;\n        String serverHookClassName \u003d null;\n        Class serverHookClass \u003d null;\n        //add system hooks\n        serverHook \u003d new GhostSocketReaper();\n        serverHook.initHook(QuickServer.this);\n        listOfServerHooks.add(serverHook);\n        ghostSocketReaper \u003d (GhostSocketReaper) serverHook;\n        //add user hooks if any\n        Iterator iterator \u003d getServerHooks().iterator();\n        while (iterator.hasNext()) {\n            serverHookClassName \u003d (String) iterator.next();\n            try {\n                serverHookClass \u003d getClass(serverHookClassName, true);\n                serverHook \u003d (ServerHook) serverHookClass.newInstance();\n                serverHook.initHook(QuickServer.this);\n                listOfServerHooks.add(serverHook);\n                logger.log(Level.INFO, \"Loaded server hook: {0}\", serverHookClassName);\n                logger.log(Level.FINE, \"Server hook info: {0}\", serverHook.info());\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Could not load server hook [{0}]: {1}\", new Object[] { serverHookClassName, e });\n                logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            }\n        }\n        //end of while\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event) {\n        if (listOfServerHooks \u003d\u003d null) {\n            logger.warning(\"listOfServerHooks was null!\");\n            return;\n        }\n        ServerHook serverHook \u003d null;\n        boolean result \u003d false;\n        Iterator iterator \u003d listOfServerHooks.iterator();\n        String hooktype \u003d \"UNKNOWN\";\n        switch(event) {\n            case ServerHook.PRE_STARTUP:\n                hooktype \u003d \"PRE_STARTUP\";\n                break;\n            case ServerHook.POST_STARTUP:\n                hooktype \u003d \"POST_STARTUP\";\n                break;\n            case ServerHook.PRE_SHUTDOWN:\n                hooktype \u003d \"PRE_SHUTDOWN\";\n                break;\n            case ServerHook.POST_SHUTDOWN:\n                hooktype \u003d \"POST_SHUTDOWN\";\n                break;\n        }\n        while (iterator.hasNext()) {\n            serverHook \u003d (ServerHook) iterator.next();\n            try {\n                result \u003d serverHook.handleEvent(event);\n            } catch (Exception e) {\n                result \u003d false;\n                logger.log(Level.WARNING, \"Error invoking {0} hook [{1}]: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });\n            }\n            logger.log(Level.FINE, \"Invoked {0} hook [{1}] was: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), result });\n        }\n    }\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone() {\n        Object object \u003d null;\n        try {\n            object \u003d super.clone();\n            QuickServer _qs \u003d (QuickServer) object;\n            _qs.setQSAdminServer(new QSAdminServer(_qs));\n        } catch (CloneNotSupportedException e) {\n            //should not happ\n            logger.log(Level.WARNING, \"Error cloning : {0}\", e);\n        }\n        return object;\n    }\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure) {\n        this.secure \u003d secure;\n    }\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure() {\n        if (secure \u003d\u003d null)\n            secure \u003d new Secure();\n        return secure;\n    }\n\n    /**\n     * \u003cp\u003eReturns if the server is running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure() {\n        return runningSecure;\n    }\n\n    /**\n     * \u003cp\u003eSets the server mode if its running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure) {\n        this.runningSecure \u003d runningSecure;\n    }\n\n    private File makeAbsoluteToConfig(String fileName) {\n        Assertion.affirm(fileName !\u003d null, \"FileName can\u0027t be null\");\n        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());\n    }\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException {\n        server \u003d null;\n        logger.log(Level.FINEST, \"Binding {0} to IP: {1}\", new Object[] { getName(), getBindAddr() });\n        InetSocketAddress bindAddress \u003d new InetSocketAddress(getBindAddr(), getPort());\n        try {\n            NetworkInterface ni \u003d NetworkInterface.getByInetAddress(getBindAddr());\n            if (ni !\u003d null) {\n                logger.fine(\"NetworkInterface: \" + ni);\n            }\n        } catch (Exception igrnore) {\n            /*ignore*/\n        } catch (Error igrnore) {\n            /*ignore*/\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Making a normal ServerSocket for {0}\", getName());\n            setRunningSecure(false);\n            if (getBlockingMode() \u003d\u003d false) {\n                //for non-blocking\n                serverSocketChannel \u003d ServerSocketChannel.open();\n                server \u003d serverSocketChannel.socket();\n                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n            } else {\n                //for blocking\n                server \u003d new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n            }\n        } else {\n            try {\n                logger.log(Level.FINE, \"Making a secure ServerSocket for {0}\", getName());\n                getSSLContext();\n                setRunningSecure(true);\n                if (getBlockingMode() \u003d\u003d false) {\n                    logger.log(Level.FINE, \"Making a secure ServerSocketChannel for {0}\", getName());\n                    //for non-blocking\n                    serverSocketChannel \u003d ServerSocketChannel.open();\n                    server \u003d serverSocketChannel.socket();\n                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n                } else {\n                    ServerSocketFactory ssf \u003d getSSLContext().getServerSocketFactory();\n                    SSLServerSocket serversocket \u003d (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());\n                    setRunningSecure(true);\n                    secureStoreManager.logSSLServerSocketInfo(serversocket);\n                    server \u003d serversocket;\n                    serverSocketChannel \u003d server.getChannel();\n                    if (serverSocketChannel \u003d\u003d null \u0026\u0026 getBlockingMode() \u003d\u003d false) {\n                        logger.warning(\"Secure Server does not support Channel! So will run in blocking mode.\");\n                        blockingMode \u003d false;\n                    }\n                }\n                //blocking\n            } catch (NoSuchAlgorithmException e) {\n                logger.log(Level.WARNING, \"NoSuchAlgorithmException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            } catch (KeyManagementException e) {\n                logger.log(Level.WARNING, \"KeyManagementException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            }\n        }\n        server.setReuseAddress(true);\n        int connectionTime \u003d 0;\n        int latency \u003d 0;\n        int bandwidth \u003d 0;\n        connectionTime \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();\n        latency \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();\n        bandwidth \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();\n        logger.log(Level.FINE, \"getPerformancePreferencesConnectionTime : {0}\", connectionTime);\n        logger.log(Level.FINE, \"getPerformancePreferencesLatency : {0}\", latency);\n        logger.log(Level.FINE, \"getPerformancePreferencesBandwidth : {0}\", bandwidth);\n        server.setPerformancePreferences(connectionTime, latency, bandwidth);\n        int clientSocketReceiveBufferSize \u003d getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();\n        if (clientSocketReceiveBufferSize \u003e 0) {\n            logger.log(Level.FINE, \"clientSocketReceiveBufferSize: {0}\", clientSocketReceiveBufferSize);\n            server.setReceiveBufferSize(clientSocketReceiveBufferSize);\n        }\n        if (getBlockingMode() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Server Mode {0} - Non Blocking\", getName());\n            if (selector \u003d\u003d null || selector.isOpen() \u003d\u003d false) {\n                logger.finest(\"Opening new selector\");\n                selector \u003d Selector.open();\n            } else {\n                logger.log(Level.FINEST, \"Reusing selector: {0}\", selector);\n            }\n            serverSocketChannel.configureBlocking(false);\n            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n            selector.wakeup();\n        } else {\n            logger.log(Level.FINE, \"Server Mode {0} - Blocking\", getName());\n        }\n    }\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {\n        Assertion.affirm(basicConfig !\u003d null, \"BasicServerConfig can\u0027t be null\");\n        this.basicConfig \u003d basicConfig;\n    }\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig() {\n        return basicConfig;\n    }\n\n    /**\n     * Loads the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException {\n        if (getSecure().isLoad() \u003d\u003d false) {\n            throw new IllegalStateException(\"Secure setting is not yet enabled for loading!\");\n        }\n        logger.info(\"Loading Secure Context..\");\n        km \u003d null;\n        tm \u003d null;\n        try {\n            String ssManager \u003d \"org.quickserver.security.SecureStoreManager\";\n            if (getSecure().getSecureStore() !\u003d null)\n                ssManager \u003d getSecure().getSecureStore().getSecureStoreManager();\n            Class secureStoreManagerClass \u003d getClass(ssManager, true);\n            secureStoreManager \u003d (SecureStoreManager) secureStoreManagerClass.newInstance();\n            km \u003d secureStoreManager.loadKeyManagers(getConfig());\n            logger.fine(\"KeyManager got\");\n            tm \u003d secureStoreManager.loadTrustManagers(getConfig());\n            logger.fine(\"TrustManager got\");\n            sslc \u003d secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());\n            sslc.init(km, tm, null);\n            logger.fine(\"SSLContext loaded\");\n        } catch (KeyStoreException e) {\n            logger.warning(\"KeyStoreException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchAlgorithmException e) {\n            logger.warning(\"NoSuchAlgorithmException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchProviderException e) {\n            logger.warning(\"NoSuchProviderException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (UnrecoverableKeyException e) {\n            logger.warning(\"UnrecoverableKeyException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (CertificateException e) {\n            logger.warning(\"CertificateException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (KeyManagementException e) {\n            logger.warning(\"KeyManagementException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (GeneralSecurityException e) {\n            logger.warning(\"GeneralSecurityException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (ClassNotFoundException e) {\n            logger.warning(\"ClassNotFoundException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (InstantiationException e) {\n            logger.warning(\"InstantiationException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (IllegalAccessException e) {\n            logger.warning(\"IllegalAccessException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        return getSSLContext(null);\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        if (protocol !\u003d null \u0026\u0026 secureStoreManager !\u003d null) {\n            SSLContext _sslc \u003d secureStoreManager.getSSLContext(protocol);\n            _sslc.init(km, tm, null);\n            return _sslc;\n        }\n        return sslc;\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext());\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext(protocol));\n    }\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler) {\n        clientBinaryHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler() {\n        return clientBinaryHandlerString;\n    }\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector) {\n        this.selector \u003d selector;\n    }\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector() {\n        return selector;\n    }\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception {\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        //long stime \u003d System.currentTimeMillis();\n        //long etime \u003d System.currentTimeMillis();\n        while (true) {\n            //etime \u003d System.currentTimeMillis();\n            //System.out.println(\"Time Taken: \"+(etime-stime));\n            client \u003d server.accept();\n            //stime \u003d System.currentTimeMillis();\n            if (linger \u003c 0) {\n                client.setSoLinger(false, 0);\n            } else {\n                client.setSoLinger(true, linger);\n            }\n            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                //low delay\u003d10\n                client.setTrafficClass(socketTrafficClass);\n            }\n            logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n            }\n            if (stopServer) {\n                //Client connected when server was about to be shutdown.\n                try {\n                    client.close();\n                } catch (Exception e) {\n                }\n                break;\n            }\n            if (checkAccessConstraint(client) \u003d\u003d false) {\n                continue;\n            }\n            //Check if max connection has reached\n            if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);\n            } else {\n                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);\n            }\n            theClient.setTrusted(getSkipValidation());\n            theClient.setSocket(client);\n            //mostly null\n            theClient.setSocketChannel(client.getChannel());\n            if (clientDataClass !\u003d null) {\n                if (getClientDataPool() \u003d\u003d null) {\n                    clientData \u003d (ClientData) clientDataClass.newInstance();\n                } else {\n                    clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                }\n                theClient.setClientData(clientData);\n            }\n            try {\n                _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                _chPolled.handleClient(theClient);\n            } catch (java.util.NoSuchElementException nsee) {\n                logger.warning(\"Could not borrow ClientHandler from pool. Error: \" + nsee);\n                logger.warning(\"Closing Socket [\" + client + \"] since no ClientHandler available.\");\n                client.close();\n            }\n            if (_chPolled !\u003d null) {\n                try {\n                    getClientPool().addClient(_chPolled, true);\n                } catch (java.util.NoSuchElementException nsee) {\n                    logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                    //logger.warning(\"Closing Socket [\"+client+\"] since no Thread available.\");\n                    //client.close();\n                    //returnClientHandlerToPool(_chPolled);\n                }\n                _chPolled \u003d null;\n            }\n            client \u003d null;\n            //reset it back\n            setSkipValidation(false);\n        }\n        //end of loop\n    }\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception {\n        int selectCount \u003d 0;\n        Iterator iterator \u003d null;\n        SelectionKey key \u003d null;\n        ServerSocketChannel serverChannel \u003d null;\n        SocketChannel socketChannel \u003d null;\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        boolean stopServerProcessed \u003d false;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        registerChannelRequestMap \u003d new HashMap();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        while (true) {\n            selectCount \u003d selector.select(500);\n            //selectCount \u003d selector.select();//for testing\n            //check for any pending registerChannel req.\n            synchronized (registerChannelRequestMap) {\n                if (registerChannelRequestMap.size() \u003e 0) {\n                    RegisterChannelRequest req \u003d null;\n                    Object hashkey \u003d null;\n                    iterator \u003d registerChannelRequestMap.keySet().iterator();\n                    while (iterator.hasNext()) {\n                        hashkey \u003d iterator.next();\n                        req \u003d (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);\n                        req.register(getSelector());\n                    }\n                    iterator \u003d null;\n                    registerChannelRequestMap.clear();\n                }\n                //if\n            }\n            //sync\n            if (stopServer \u003d\u003d true \u0026\u0026 stopServerProcessed \u003d\u003d false) {\n                logger.warning(\"Closing \" + getName());\n                serverSocketChannel.close();\n                stopServerProcessed \u003d true;\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.warning(\"Closed \" + getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n            if (stopServer \u003d\u003d false \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                logger.finest(\"Server must have re-started.. will break\");\n                break;\n            }\n            if (selectCount \u003d\u003d 0 \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                java.util.Set keyset \u003d selector.keys();\n                if (keyset.isEmpty() \u003d\u003d true \u0026\u0026 getClientCount() \u003c\u003d 0) {\n                    break;\n                } else {\n                    continue;\n                }\n            } else if (selectCount \u003d\u003d 0) {\n                continue;\n            }\n            iterator \u003d selector.selectedKeys().iterator();\n            while (iterator.hasNext()) {\n                key \u003d (SelectionKey) iterator.next();\n                if (key.isValid() \u003d\u003d false) {\n                    iterator.remove();\n                    continue;\n                }\n                if (key.isAcceptable() \u0026\u0026 stopServer \u003d\u003d false) {\n                    logger.finest(\"Key is Acceptable\");\n                    serverChannel \u003d (ServerSocketChannel) key.channel();\n                    socketChannel \u003d serverChannel.accept();\n                    if (socketChannel \u003d\u003d null) {\n                        iterator.remove();\n                        continue;\n                    }\n                    client \u003d socketChannel.socket();\n                    if (linger \u003c 0) {\n                        client.setSoLinger(false, 0);\n                    } else {\n                        client.setSoLinger(true, linger);\n                    }\n                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                        //low delay\u003d10\n                        client.setTrafficClass(socketTrafficClass);\n                    }\n                    logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                        logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n                    }\n                    if (checkAccessConstraint(client) \u003d\u003d false) {\n                        iterator.remove();\n                        continue;\n                    }\n                    socketChannel.configureBlocking(false);\n                    theClient.setTrusted(getSkipValidation());\n                    theClient.setSocket(socketChannel.socket());\n                    theClient.setSocketChannel(socketChannel);\n                    if (clientDataClass !\u003d null) {\n                        if (getClientDataPool() \u003d\u003d null) {\n                            clientData \u003d (ClientData) clientDataClass.newInstance();\n                        } else {\n                            //borrow a object from pool\n                            clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                        }\n                        theClient.setClientData(clientData);\n                    }\n                    //Check if max connection has reached\n                    if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                        theClient.setClientEvent(ClientEvent.MAX_CON);\n                    } else {\n                        theClient.setClientEvent(ClientEvent.ACCEPT);\n                    }\n                    try {\n                        _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                        logger.finest(\"Asking \" + _chPolled.getName() + \" to handle.\");\n                        _chPolled.handleClient(theClient);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.warning(\"Could not borrow ClientHandler Object from pool. Error: \" + nsee);\n                        logger.warning(\"Closing SocketChannel [\" + serverChannel.socket() + \"] since no ClientHandler available.\");\n                        socketChannel.close();\n                    }\n                    if (_chPolled !\u003d null) {\n                        try {\n                            getClientPool().addClient(_chPolled, true);\n                        } catch (java.util.NoSuchElementException nsee) {\n                            logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                            //logger.warning(\"Closing SocketChannel [\"+serverChannel.socket()+\"] since no Thread available.\");\n                            //socketChannel.close();\n                            //returnClientHandlerToPool(_chPolled);\n                        }\n                        _chPolled \u003d null;\n                    }\n                    socketChannel \u003d null;\n                    client \u003d null;\n                    //reset it back\n                    setSkipValidation(false);\n                } else if (key.isValid() \u0026\u0026 key.isReadable()) {\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Readable, removing OP_READ from interestOps for \" + _ch.getName());\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_READ));\n                        _ch.addEvent(ClientEvent.READ);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.READ);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (key.isValid() \u0026\u0026 key.isWritable()) {\n                    if (getClientPool().shouldNioWriteHappen() \u003d\u003d false) {\n                        //no need to remove the key\n                        continue;\n                    }\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Writable, removing OP_WRITE from interestOps for \" + _ch.getName());\n                        //remove OP_WRITE from interest set\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_WRITE));\n                        _ch.addEvent(ClientEvent.WRITE);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.WRITE);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (stopServer \u003d\u003d true \u0026\u0026 key.isAcceptable()) {\n                    //we will not accept this key\n                    //reset it back\n                    setSkipValidation(false);\n                } else {\n                    logger.warning(\"Unknown key got in SelectionKey: \" + key);\n                }\n                //Remove key\n                iterator.remove();\n                Thread.yield();\n            }\n            //end of iterator\n            iterator \u003d null;\n        }\n        //end of loop\n    }\n\n    private boolean checkAccessConstraint(Socket socket) {\n        try {\n            if (getAccessConstraintConfig() !\u003d null) {\n                getAccessConstraintConfig().checkAccept(socket);\n            }\n            return true;\n        } catch (SecurityException se) {\n            logger.warning(\"SecurityException occurred accepting connection : \" + se.getMessage());\n            return false;\n        }\n    }\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {\n        if (getSelector() \u003d\u003d null) {\n            throw new IllegalStateException(\"Selector is not open!\");\n        }\n        if (channel \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Can\u0027t register a null channel!\");\n        }\n        if (channel.isConnected() \u003d\u003d false) {\n            throw new ClosedChannelException();\n        }\n        RegisterChannelRequest req \u003d new RegisterChannelRequest(channel, ops, att);\n        RegisterChannelRequest reqOld \u003d null;\n        synchronized (registerChannelRequestMap) {\n            reqOld \u003d (RegisterChannelRequest) registerChannelRequestMap.get(channel);\n            if (reqOld \u003d\u003d null) {\n                registerChannelRequestMap.put(channel, req);\n                getSelector().wakeup();\n                return true;\n            } else {\n                if (reqOld.equals(req) \u003d\u003d false) {\n                    reqOld.setOps(reqOld.getOps() | req.getOps());\n                    reqOld.setAtt(req.getAtt());\n                    return true;\n                }\n                return false;\n            }\n        }\n        /*\n\t\tlogger.warning(\"Before register...\");\n\t\tchannel.register(getSelector(), ops, att);\n\t\tlogger.warning(\"Before wakeup and after register...\");\n\t\tgetSelector().wakeup();\n\t\tlogger.warning(\"After wakeup...\");\n\t\t*/\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig) {\n        logger.finer(\"Creating ByteBufferPool pool\");\n        int bufferSize \u003d getBasicConfig().getAdvancedSettings().getByteBufferSize();\n        boolean useDirectByteBuffer \u003d getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();\n        PoolableObjectFactory factory \u003d new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);\n        byteBufferPool \u003d poolManager.makeByteBufferPool(factory, opConfig);\n        poolManager.initPool(byteBufferPool, opConfig);\n    }\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool() {\n        return byteBufferPool;\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientThread pool\");\n        ThreadObjectFactory factory \u003d new ThreadObjectFactory();\n        ObjectPool objectPool \u003d poolManager.makeClientPool(factory, opConfig);\n        pool \u003d new ClientPool(makeQSObjectPool(objectPool), opConfig);\n        factory.setClientPool(pool);\n        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());\n        poolManager.initPool(objectPool, opConfig);\n    }\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler) {\n        clientWriteHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler() {\n        return clientWriteHandlerString;\n    }\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be \u003ccode\u003enull\u003c/code\u003e if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime() {\n        return lastStartTime;\n    }\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag) {\n        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);\n        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);\n    }\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier() {\n        return clientIdentifier;\n    }\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {\n        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);\n    }\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode() {\n        return blockingMode;\n    }\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception {\n        if (clientCommandHandlerString \u003d\u003d null \u0026\u0026 clientEventHandlerString \u003d\u003d null) {\n            logger.severe(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n            throw new AppException(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n        }\n        clientCommandHandler \u003d null;\n        if (clientCommandHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientCommandHandler class..\");\n            Class clientCommandHandlerClass \u003d getClass(clientCommandHandlerString, true);\n            clientCommandHandler \u003d (ClientCommandHandler) clientCommandHandlerClass.newInstance();\n        }\n        boolean setClientCommandHandlerLookup \u003d false;\n        clientEventHandler \u003d null;\n        if (clientEventHandlerString \u003d\u003d null) {\n            clientEventHandlerString \u003d \"org.quickserver.net.server.impl.DefaultClientEventHandler\";\n            setClientCommandHandlerLookup \u003d true;\n        }\n        logger.finest(\"Loading ClientEventHandler class..\");\n        if (clientEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientEventHandler.class.isInstance(clientCommandHandler)) {\n            clientEventHandler \u003d (ClientEventHandler) clientCommandHandler;\n        } else {\n            clientEventHandler \u003d (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();\n            if (setClientCommandHandlerLookup) {\n                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);\n            }\n        }\n        clientExtendedEventHandler \u003d null;\n        if (clientExtendedEventHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientExtendedEventHandler class..\");\n            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientCommandHandler;\n            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientEventHandler;\n            } else {\n                Class clientExtendedEventHandlerClass \u003d getClass(clientExtendedEventHandlerString, true);\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();\n            }\n        }\n        clientObjectHandler \u003d null;\n        if (clientObjectHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientObjectHandler class..\");\n            if (clientObjectHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientCommandHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientCommandHandler;\n            } else if (clientObjectHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientEventHandler;\n            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientExtendedEventHandler;\n            } else {\n                clientObjectHandler \u003d (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientBinaryHandler \u003d null;\n        if (clientBinaryHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientBinaryHandler class..\");\n            if (clientBinaryHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientCommandHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientCommandHandler;\n            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientExtendedEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientObjectHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientObjectHandler;\n            } else {\n                clientBinaryHandler \u003d (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientWriteHandler \u003d null;\n        if (clientWriteHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientWriteHandler class..\");\n            if (clientWriteHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientCommandHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientCommandHandler;\n            } else if (clientWriteHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientEventHandler;\n            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientExtendedEventHandler;\n            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientObjectHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientObjectHandler;\n            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientBinaryHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientBinaryHandler;\n            } else {\n                clientWriteHandler \u003d (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        Class authenticatorClass \u003d null;\n        if (clientAuthenticationHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientAuthenticationHandler class..\");\n            authenticatorClass \u003d getClass(clientAuthenticationHandlerString, true);\n        }\n        if (authenticatorClass !\u003d null) {\n            Object obj \u003d authenticatorClass.newInstance();\n            if (ClientAuthenticationHandler.class.isInstance(obj))\n                clientAuthenticationHandler \u003d (ClientAuthenticationHandler) obj;\n            else\n                authenticator \u003d (Authenticator) obj;\n        }\n        clientDataClass \u003d null;\n        if (clientDataString !\u003d null) {\n            logger.finest(\"Loading ClientData class..\");\n            clientDataClass \u003d getClass(clientDataString, true);\n        }\n        Assertion.affirm(clientEventHandler !\u003d null, \"ClientEventHandler was not loaded!\");\n    }\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler) {\n        clientEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler() {\n        return clientEventHandlerString;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {\n        if (dataType \u003d\u003d DataType.IN)\n            this.defaultDataModeIN \u003d dataMode;\n        if (dataType \u003d\u003d DataType.OUT)\n            this.defaultDataModeOUT \u003d dataMode;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {\n        defaultDataModeIN \u003d defaultDataMode.getDataMode(DataType.IN);\n        defaultDataModeOUT \u003d defaultDataMode.getDataMode(DataType.OUT);\n        ;\n    }\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType) {\n        if (dataType \u003d\u003d DataType.IN)\n            return defaultDataModeIN;\n        if (dataType \u003d\u003d DataType.OUT)\n            return defaultDataModeOUT;\n        else\n            throw new IllegalArgumentException(\"Unknown DataType: \" + dataType);\n    }\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler) {\n        clientExtendedEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler() {\n        return clientExtendedEventHandlerString;\n    }\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception {\n        if (getApplicationJarPath() !\u003d null \u0026\u0026 getClassLoader() \u003d\u003d null) {\n            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));\n            //update qsadmin to use the same\n            if (adminServer !\u003d null) {\n                adminServer.getServer().setClassLoader(getClassLoader());\n            }\n        }\n    }\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID() {\n        return pid;\n    }\n\n    public boolean isRawCommunicationLogging() {\n        return rawCommunicationLogging;\n    }\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {\n        this.rawCommunicationLogging \u003d rawCommunicationLogging;\n    }\n\n    public int getRawCommunicationMaxLength() {\n        return rawCommunicationMaxLength;\n    }\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {\n        this.rawCommunicationMaxLength \u003d rawCommunicationMaxLength;\n    }\n}\n",
    "package": "org.quickserver.net.server",
    "classname": "QuickServer",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_5Test.java",
    "test_prompt": "// QuickServer_5Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#initService(QuickServerConfig)} method.\n*/\nclass QuickServer_5Test {",
    "method_signature": "initService(QuickServerConfig)",
    "suffix": "5"
  },
  {
    "numberTests": "ten",
    "original_code": "// QuickServer.java\n/*\n * This file is part of the QuickServer library \n * Copyright (C) QuickServer.org\n *\n * Use, modification, copying and distribution of this software is subject to\n * the terms and conditions of the GNU Lesser General Public License. \n * You should have received a copy of the GNU LGP License along with this \n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\n *\n * For questions, suggestions, bug-reports, enhancement-requests etc.\n * visit http://www.quickserver.org\n *\n */\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n *  Main class of QuickServer library. This class is used to create\n *  multi client servers quickly.\n *  \u003cp\u003e\n *  Ones a client is connected, it creates {@link ClientHandler} object,\n *  which is run using any thread available from the pool of threads\n *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n *  handles the client. \u003cbr/\u003e\n *  QuickServer divides the application logic of its developer over eight\n *  class, \u003cbr\u003e\n *  \t\u003cul\u003e\n * \t\t\u003cli\u003eClientEventHandler\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client events [Optional Class].\n *  \t\t\u003cli\u003eClientCommandHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client character/string commands.\n *  \t\t\u003cli\u003eClientObjectHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - Object commands.\n * \t\t\u003cli\u003eClientBinaryHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - binary data.\n * \t\t\u003cli\u003eClientWriteHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n *  \t\t\u003cli\u003eClientAuthenticationHandler [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Used to Authencatet a client.\n *  \t\t\u003cli\u003eClientData [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Client data carrier (support class)\n * \t\t\u003cli\u003eClientExtendedEventHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles extended client events.\n *  \t\u003c/ul\u003e\n *\n *  [#] \u003d Any one of these have to be set based on default DataMode for input.\n *  The default DataMode for input is String so if not changes you will\n *  have to set ClientCommandHandler.\n *  \u003c/p\u003e\n *  \u003cp\u003e\n *   Eg:\n *  \u003ccode\u003e\u003cBLOCKQUOTE\u003e\u003cpre\u003e\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle \u003d \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer \u003d new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * \u003c/pre\u003e\u003c/BLOCKQUOTE\u003e\u003c/code\u003e\u003c/p\u003e\n *\n *  @version 1.4.8\n *  @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //Some variable are not initialised to any value because the\n    //default java value was desired initial value.\n    //\u0027dev \u0027 \u003d development build not yet final\n    //\u0027beta\u0027 \u003d test build all features\n    //change also in QSAdminMain\n    private final static String VER \u003d \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n        if (System.getProperty(\"org.quickserver.useOSLineSeparator\") !\u003d null \u0026\u0026 System.getProperty(\"org.quickserver.useOSLineSeparator\").equals(\"true\")) {\n            NEW_LINE \u003d System.getProperty(\"line.separator\");\n        } else {\n            NEW_LINE \u003d \"\\r\\n\";\n        }\n        String _pid \u003d ManagementFactory.getRuntimeMXBean().getName();\n        int i \u003d _pid.indexOf(\"@\");\n        pid \u003d _pid.substring(0, i);\n        System.out.print(\"Loading QuickServer v\" + getVersion() + \" [PID:\" + pid + \"]\");\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort \u003d 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName \u003d \"QuickServer\";\n\n    private long maxConnection \u003d -1;\n\n    //1 min socket timeout\n    private int socketTimeout \u003d 60 * 1000;\n\n    private String maxConnectionMsg \u003d \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg \u003d \"-ERR Timeout\";\n\n    private String maxAuthTryMsg \u003d \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry \u003d 5;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //--v1.2\n    //Logger for QuickServer\n    private static final Logger logger \u003d Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //for Service interface\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState \u003d Service.UNKNOWN;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.3\n    private QuickServerConfig config \u003d new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel \u003d \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel \u003d \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation \u003d false;\n\n    private boolean communicationLogging \u003d true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig \u003d config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km \u003d null;\n\n    private TrustManager[] tm \u003d null;\n\n    private boolean runningSecure \u003d false;\n\n    private SecureStoreManager secureStoreManager \u003d null;\n\n    private Exception exceptionInRun \u003d null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode \u003d true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN \u003d DataMode.STRING;\n\n    private DataMode defaultDataModeOUT \u003d DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging \u003d false;\n\n    private int rawCommunicationMaxLength \u003d 100;\n\n    static {\n        System.out.println(\" Done\");\n        //should be commented if not a patch release\n        //System.out.println(\"[Includes patch(#): t\u003d152\u0026p\u003d532]\");\n        //should be commented if not a dev release\n        //System.out.println(\"[Dev Build Date: Saturday, October 29, 2005]\");\n        logger.log(Level.FINE, \"PID: {0}\", pid);\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion() {\n        return VER;\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo() {\n        return getVersionNo(VER);\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver) {\n        //String ver \u003d getVersion();\n        float version \u003d 0;\n        //check if beta\n        int i \u003d ver.indexOf(\" \");\n        if (i \u003d\u003d -1)\n            i \u003d ver.length();\n        ver \u003d ver.substring(0, i);\n        //check for sub version\n        i \u003d ver.indexOf(\".\");\n        if (i !\u003d -1) {\n            int j \u003d ver.indexOf(\".\", i);\n            if (j !\u003d -1) {\n                ver \u003d ver.substring(0, i) + \".\" + MyString.replaceAll(ver.substring(i + 1), \".\", \"\");\n            }\n        }\n        try {\n            version \u003d Float.parseFloat(ver);\n        } catch (NumberFormatException e) {\n            throw new RuntimeException(\"Corrupt QuickServer\");\n        }\n        return version;\n    }\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine() {\n        return NEW_LINE;\n    }\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString() {\n        return serverName + \" : \" + getPort();\n    }\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n        setClientCommandHandler(commandHandler);\n    }\n\n    /**\n     * Creates a new server at \u003ccode\u003eport\u003c/code\u003e with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n        //send to another constructor\n        this(commandHandler);\n        setPort(port);\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException {\n        logger.log(Level.FINE, \"Starting {0}\", getName());\n        if (isClosed() \u003d\u003d false) {\n            logger.log(Level.WARNING, \"Server {0} already running.\", getName());\n            throw new AppException(\"Server \" + getName() + \" already running.\");\n        }\n        blockingMode \u003d getBasicConfig().getServerMode().getBlocking();\n        if (getSecure().isEnable() \u0026\u0026 blockingMode \u003d\u003d false) {\n            //TODO we need to fix this..\n            logger.warning(\"QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode.\");\n            blockingMode \u003d true;\n            getBasicConfig().getServerMode().setBlocking(blockingMode);\n        }\n        if (serverBanner \u003d\u003d null) {\n            serverBanner \u003d \"\\n-------------------------------\" + \"\\n Name : \" + getName() + \"\\n Port : \" + getPort() + \"\\n-------------------------------\\n\";\n            logger.finest(\"Default Server Banner Generated\");\n        }\n        try {\n            loadApplicationClasses();\n            //load class from Advanced Settings\n            Class clientIdentifierClass \u003d getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);\n            clientIdentifier \u003d (ClientIdentifier) clientIdentifierClass.newInstance();\n            clientIdentifier.setQuickServer(QuickServer.this);\n            //load class from ObjectPoolConfig\n            Class poolManagerClass \u003d getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);\n            poolManager \u003d (PoolManager) poolManagerClass.newInstance();\n            //load class QSObjectPoolMaker\n            Class qsObjectPoolMakerClass \u003d getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);\n            qsObjectPoolMaker \u003d (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();\n            loadServerHooksClasses();\n            processServerHooks(ServerHook.PRE_STARTUP);\n            if (getSecure().isLoad() \u003d\u003d true)\n                //v1.4.0\n                loadSSLContext();\n            loadBusinessLogic();\n        } catch (ClassNotFoundException e) {\n            logger.log(Level.SEVERE, \"Could not load class/s: \" + e, e);\n            throw new AppException(\"Could not load class/s : \" + e);\n        } catch (InstantiationException e) {\n            logger.log(Level.SEVERE, \"Could not instantiate class/s: \" + e, e);\n            throw new AppException(\"Could not instantiate class/s: \" + e);\n        } catch (IllegalAccessException e) {\n            logger.log(Level.SEVERE, \"Illegal access to class/s: \" + e, e);\n            throw new AppException(\"Illegal access to class/s: \" + e);\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"IOException: \" + e, e);\n            throw new AppException(\"IOException: \" + e);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Exception: \" + e, e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Exception : \" + e);\n        }\n        //v1.3.3\n        if (getSecurityManagerClass() !\u003d null) {\n            System.setSecurityManager(getSecurityManager());\n        }\n        setServiceState(Service.INIT);\n        t \u003d new Thread(this, \"QuickServer - \" + getName());\n        t.start();\n        do {\n            Thread.yield();\n        } while (getServiceState() \u003d\u003d Service.INIT);\n        if (getServiceState() !\u003d Service.RUNNING) {\n            if (exceptionInRun !\u003d null)\n                throw new AppException(\"Could not start server \" + getName() + \"! Details: \" + exceptionInRun);\n            else\n                throw new AppException(\"Could not start server \" + getName());\n        }\n        lastStartTime \u003d new java.util.Date();\n        logger.log(Level.FINE, \"Started {0}, Date: {1}\", new Object[] { getName(), lastStartTime });\n    }\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException {\n        processServerHooks(ServerHook.PRE_SHUTDOWN);\n        logger.log(Level.WARNING, \"Stopping {0}\", getName());\n        stopServer \u003d true;\n        Socket death \u003d null;\n        if (isClosed() \u003d\u003d true) {\n            logger.log(Level.WARNING, \"Server {0} is not running!\", getName());\n            throw new AppException(\"Server \" + getName() + \" is not running!\");\n        }\n        try {\n            if (getBlockingMode() \u003d\u003d true) {\n                if (getSecure().isEnable() \u003d\u003d false) {\n                    death \u003d new Socket(server.getInetAddress(), server.getLocalPort());\n                    death.getInputStream().read();\n                    death.close();\n                } else {\n                    death \u003d getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());\n                    Thread.sleep(100);\n                    death.close();\n                }\n            }\n            if (serverSocketChannel !\u003d null) {\n                serverSocketChannel.close();\n            }\n        } catch (IOException e) {\n            logger.log(Level.FINE, \"IOError stopping {0}: {1}\", new Object[] { getName(), e });\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error stopping {0}: {1}\", new Object[] { getName(), e });\n            throw new AppException(\"Error in stopServer \" + getName() + \": \" + e);\n        }\n        for (int i \u003d 0; getServiceState() !\u003d Service.STOPPED; i++) {\n            try {\n                Thread.sleep(60);\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error waiting for {0} to fully stop. Error: {1}\", new Object[] { getName(), e });\n            }\n            if (i \u003e 1000) {\n                logger.severe(\"Server was not stopped even after 10sec.. will terminate now.\");\n                System.exit(-1);\n            }\n        }\n        if (adminServer \u003d\u003d null || getQSAdminServer().getServer() !\u003d this) {\n            //so this is not qsadmin\n            setClassLoader(null);\n        }\n        logger.log(Level.INFO, \"Stopped {0}\", getName());\n    }\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException {\n        stopServer();\n        startServer();\n    }\n\n    /**\n     * Returns the name of the QuickServer. Default is \u0027QuickServer\u0027.\n     * @see #setName\n     */\n    public String getName() {\n        return serverName;\n    }\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name) {\n        serverName \u003d name;\n        logger.log(Level.FINEST, \"Set to : {0}\", name);\n    }\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner() {\n        return serverBanner;\n    }\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. \u003cbr\u003e\u0026nbsp;\u003cbr\u003e\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner) {\n        serverBanner \u003d banner;\n        logger.log(Level.FINEST, \"Set to : {0}\", banner);\n    }\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port) {\n        if (port \u003c 0) {\n            throw new IllegalArgumentException(\"Port number can not be less than 0!\");\n        }\n        serverPort \u003d port;\n        logger.log(Level.FINEST, \"Set to {0}\", port);\n    }\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort() {\n        if (isClosed() \u003d\u003d false) {\n            return server.getLocalPort();\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            return serverPort;\n        } else {\n            int _port \u003d getSecure().getPort();\n            if (_port \u003d\u003d -1)\n                return serverPort;\n            else\n                return _port;\n        }\n    }\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler) {\n        clientCommandHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler() {\n        return clientCommandHandlerString;\n    }\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data) {\n        this.clientDataString \u003d data;\n        logger.log(Level.FINEST, \"Set to {0}\", data);\n    }\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData() {\n        return clientDataString;\n    }\n\n    /**\n     * Sets the client socket\u0027s timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time) {\n        if (time \u003e 0)\n            socketTimeout \u003d time;\n        else\n            socketTimeout \u003d 0;\n        logger.log(Level.FINEST, \"Set to {0}\", socketTimeout);\n    }\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout() {\n        return socketTimeout;\n    }\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry) {\n        maxAuthTry \u003d authTry;\n        logger.log(Level.FINEST, \"Set to {0}\", authTry);\n    }\n\n    /**\n     * Returns max allowed login attempts. Default is \u003ccode\u003e5\u003c/code\u003e.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry() {\n        return maxAuthTry;\n    }\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg) {\n        maxAuthTryMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg() {\n        return maxAuthTryMsg;\n    }\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg) {\n        timeoutMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg() {\n        return timeoutMsg;\n    }\n\n    private TheClient initTheClient() {\n        TheClient theClient \u003d new TheClient();\n        theClient.setServer(QuickServer.this);\n        theClient.setTimeoutMsg(getTimeoutMsg());\n        //v1.2\n        theClient.setMaxAuthTry(getMaxAuthTry());\n        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());\n        theClient.setClientEventHandler(clientEventHandler);\n        //v1.4.6\n        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);\n        theClient.setClientCommandHandler(clientCommandHandler);\n        //v1.2\n        theClient.setClientObjectHandler(clientObjectHandler);\n        //v1.4\n        theClient.setClientBinaryHandler(clientBinaryHandler);\n        //v1.4.5\n        theClient.setClientWriteHandler(clientWriteHandler);\n        //v1.3\n        theClient.setAuthenticator(authenticator);\n        //v1.4.6\n        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);\n        theClient.setTimeout(socketTimeout);\n        theClient.setMaxConnectionMsg(maxConnectionMsg);\n        //v1.3.2\n        theClient.setCommunicationLogging(getCommunicationLogging());\n        return theClient;\n    }\n\n    public void run() {\n        exceptionInRun \u003d null;\n        TheClient theClient \u003d initTheClient();\n        try {\n            stopServer \u003d false;\n            closeAllPools();\n            initAllPools();\n            makeServerSocket();\n            //print banner\n            System.out.println(serverBanner);\n            //v1.2\n            setServiceState(Service.RUNNING);\n            //v1.3.3\n            processServerHooks(ServerHook.POST_STARTUP);\n            if (getBlockingMode() \u003d\u003d false) {\n                runNonBlocking(theClient);\n                if (stopServer \u003d\u003d true) {\n                    logger.log(Level.FINEST, \"Closing selector for {0}\", getName());\n                    selector.close();\n                }\n                return;\n            } else {\n                runBlocking(theClient);\n            }\n        } catch (BindException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"{0} BindException for Port {1} @ {2} : {3}\", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });\n        } catch (javax.net.ssl.SSLException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"SSLException {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (IOException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"IOError {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (Exception e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"Error {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } finally {\n            if (getBlockingMode() \u003d\u003d true) {\n                logger.log(Level.WARNING, \"Closing {0}\", getName());\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            } else if (getBlockingMode() \u003d\u003d false \u0026\u0026 exceptionInRun !\u003d null) {\n                logger.log(Level.WARNING, \"Closing {0} - Had Error: {1}\", new Object[] { getName(), exceptionInRun });\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        if (serverSocketChannel !\u003d null)\n                            serverSocketChannel.close();\n                        if (server !\u003d null)\n                            server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n        }\n    }\n\n    //end of run\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnection \u003d maxConnection;\n        else\n            this.maxConnection \u003d maxConnection;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnection);\n    }\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection() {\n        return maxConnection;\n    }\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount() {\n        if (clientHandlerPool !\u003d null) {\n            try {\n                return getClientHandlerPool().getNumActive();\n            } catch (Exception e) {\n                return 0;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : \u003ccode\u003e-ERR Server Busy. Max Connection Reached\u003c/code\u003e\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n        else\n            this.maxConnectionMsg \u003d maxConnectionMsg;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnectionMsg);\n    }\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg() {\n        return maxConnectionMsg;\n    }\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException {\n        ipAddr \u003d InetAddress.getByName(bindAddr);\n        logger.log(Level.FINEST, \"Set to {0}\", bindAddr);\n    }\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr() {\n        if (ipAddr \u003d\u003d null) {\n            try {\n                ipAddr \u003d InetAddress.getByName(\"0.0.0.0\");\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Unable to create default ip(0.0.0.0) : {0}\", e);\n                throw new RuntimeException(\"Error: Unable to find servers own ip : \" + e);\n            }\n        }\n        return ipAddr;\n    }\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects) {\n        this.storeObjects \u003d storeObjects;\n    }\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return \u003ccode\u003enull\u003c/code\u003e.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects() {\n        return storeObjects;\n    }\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port) {\n        getQSAdminServer().getServer().setPort(port);\n    }\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort() {\n        return getQSAdminServer().getServer().getPort();\n    }\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator) {\n        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);\n    }\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator() {\n        return getQSAdminServer().getServer().getAuthenticator();\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException {\n        getQSAdminServer().setClientAuthenticationHandler(authenticator);\n        getQSAdminServer().startServer(port);\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException {\n        getQSAdminServer().startServer();\n    }\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer() {\n        if (adminServer \u003d\u003d null)\n            adminServer \u003d new QSAdminServer(QuickServer.this);\n        return adminServer;\n    }\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer) {\n        if (adminServer \u003d\u003d null)\n            this.adminServer \u003d adminServer;\n    }\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed() {\n        if (server \u003d\u003d null)\n            return true;\n        return server.isClosed();\n    }\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer\u0027s own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger() {\n        if (appLogger !\u003d null)\n            return appLogger;\n        return logger;\n    }\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger) {\n        this.appLogger \u003d appLogger;\n    }\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler) {\n        clientObjectHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler() {\n        return clientObjectHandlerString;\n    }\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n        if (formatter \u003d\u003d null)\n            return;\n        consoleLoggingformatter \u003d formatter;\n        java.util.logging.Formatter conformatter \u003d (java.util.logging.Formatter) getClass(formatter, true).newInstance();\n        Logger jdkLogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d jdkLogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                handlers[index].setFormatter(conformatter);\n            }\n        }\n        logger.log(Level.FINEST, \"Set to {0}\", formatter);\n    }\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter() {\n        return consoleLoggingformatter;\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MiniFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to logging.MiniFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MicroFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to MicroFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        boolean isConsole \u003d true;\n        try {\n            if (System.console() \u003d\u003d null) {\n                isConsole \u003d false;\n            }\n        } catch (Throwable e) {\n            //ignore\n        }\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                if (isConsole \u003d\u003d false \u0026\u0026 level !\u003d Level.OFF) {\n                    System.out.println(\"QuickServer: You do not have a console.. so turning console logger off..\");\n                    level \u003d Level.OFF;\n                }\n                if (level \u003d\u003d Level.OFF) {\n                    logger.info(\"QuickServer: Removing console handler.. \");\n                    rlogger.removeHandler(handlers[index]);\n                    handlers[index].setLevel(level);\n                    handlers[index].close();\n                } else {\n                    handlers[index].setLevel(level);\n                }\n            }\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            consoleLoggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            consoleLoggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            consoleLoggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            consoleLoggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            consoleLoggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            consoleLoggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            consoleLoggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            consoleLoggingLevel \u003d \"OFF\";\n        else\n            consoleLoggingLevel \u003d \"UNKNOWN\";\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel() {\n        return consoleLoggingLevel;\n    }\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            handlers[index].setLevel(level);\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            loggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            loggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            loggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            loggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            loggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            loggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            loggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            loggingLevel \u003d \"OFF\";\n        else\n            loggingLevel \u003d \"UNKNOWN\";\n        consoleLoggingLevel \u003d loggingLevel;\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    //*** Start of Service interface methods\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError() {\n        return serviceError;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param) {\n        serviceError \u003d null;\n        try {\n            initServer(param);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig) {\n        serviceError \u003d null;\n        try {\n            initServer(qsConfig);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING)\n            return false;\n        try {\n            startServer();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.STOPPED)\n            return false;\n        try {\n            stopServer();\n            clearAllPools();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING) {\n            suspendMaxConnection \u003d maxConnection;\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n            maxConnection \u003d 0;\n            maxConnectionMsg \u003d \"Service is suspended.\";\n            setServiceState(Service.SUSPENDED);\n            logger.log(Level.INFO, \"Service {0} is suspended.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.SUSPENDED) {\n            maxConnection \u003d suspendMaxConnection;\n            maxConnectionMsg \u003d suspendMaxConnectionMsg;\n            setServiceState(Service.RUNNING);\n            logger.log(Level.INFO, \"Service {0} resumed.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info() {\n        serviceError \u003d null;\n        StringBuilder buf \u003d new StringBuilder();\n        buf.append(getName()).append(\"\\n\");\n        buf.append(getBindAddr().getHostAddress()).append(\" \");\n        buf.append(getPort()).append(\"\\n\");\n        return buf.toString();\n    }\n\n    // *** End of Service interface methods\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException {\n        QuickServerConfig qsConfig \u003d null;\n        try {\n            qsConfig \u003d ConfigReader.read((String) param[0]);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not init server from xml file {0} : {1}\", new Object[] { new File((String) param[0]).getAbsolutePath(), e });\n            throw new AppException(\"Could not init server from xml file\", e);\n        }\n        initServer(qsConfig);\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {\n        setConfig(qsConfig);\n        try {\n            configQuickServer();\n            loadApplicationClasses();\n            //start InitServerHooks\n            InitServerHooks ish \u003d getConfig().getInitServerHooks();\n            if (ish !\u003d null) {\n                Iterator iterator \u003d ish.iterator();\n                String initServerHookClassName \u003d null;\n                Class initServerHookClass \u003d null;\n                InitServerHook initServerHook \u003d null;\n                while (iterator.hasNext()) {\n                    initServerHookClassName \u003d (String) iterator.next();\n                    initServerHookClass \u003d getClass(initServerHookClassName, true);\n                    initServerHook \u003d (InitServerHook) initServerHookClass.newInstance();\n                    logger.log(Level.INFO, \"Loaded init server hook: {0}\", initServerHookClassName);\n                    logger.log(Level.FINE, \"Init server hook info: {0}\", initServerHook.info());\n                    initServerHook.handleInit(QuickServer.this);\n                }\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not load init server hook: {0}\", e);\n            logger.log(Level.WARNING, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Could not load init server hook\", e);\n        }\n        setServiceState(Service.INIT);\n        logger.log(Level.FINEST, \"\\r\\n{0}\", MyString.getSystemInfo(getVersion()));\n    }\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState() {\n        return serviceState;\n    }\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state) {\n        serviceState \u003d state;\n    }\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp) {\n        if (temp.equals(\"SEVERE\"))\n            qs.setConsoleLoggingLevel(Level.SEVERE);\n        else if (temp.equals(\"WARNING\"))\n            qs.setConsoleLoggingLevel(Level.WARNING);\n        else if (temp.equals(\"INFO\"))\n            qs.setConsoleLoggingLevel(Level.INFO);\n        else if (temp.equals(\"CONFIG\"))\n            qs.setConsoleLoggingLevel(Level.CONFIG);\n        else if (temp.equals(\"FINE\"))\n            qs.setConsoleLoggingLevel(Level.FINE);\n        else if (temp.equals(\"FINER\"))\n            qs.setConsoleLoggingLevel(Level.FINER);\n        else if (temp.equals(\"FINEST\"))\n            qs.setConsoleLoggingLevel(Level.FINEST);\n        else if (temp.equals(\"OFF\"))\n            qs.setConsoleLoggingLevel(Level.OFF);\n        else\n            logger.log(Level.WARNING, \"unknown level {0}\", temp);\n    }\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception {\n        QuickServer qs \u003d QuickServer.this;\n        //v1.3\n        qs.setConfig(config);\n        qs.setBasicConfig(config);\n        String temp \u003d config.getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        temp \u003d null;\n        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        //v1.3.3\n        qs.setSecurityManagerClass(config.getSecurityManagerClass());\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        temp \u003d config.getApplicationJarPath();\n        if (temp !\u003d null) {\n            File ajp \u003d new File(temp);\n            if (ajp.isAbsolute() \u003d\u003d false) {\n                temp \u003d config.getConfigFile();\n                ajp \u003d new File(temp);\n                temp \u003d ajp.getParent() + File.separatorChar + config.getApplicationJarPath();\n                config.setApplicationJarPath(temp);\n                temp \u003d null;\n            }\n            qs.setApplicationJarPath(config.getApplicationJarPath());\n            //set path also to QSAdmin\n            if (config.getQSAdminServerConfig() !\u003d null) {\n                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());\n            }\n        }\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception {\n        QuickServer qs \u003d getQSAdminServer().getServer();\n        qs.setBasicConfig(config);\n        //set the Logging Level to same as main QS\n        //config.getConsoleLoggingLevel();\n        String temp \u003d getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        //set the Logging Formatter to same as main QS\n        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());\n        //v1.4.6\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        //v1.4.6\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());\n        //v1.3.2\n        if (config.getCommandShellEnable().equals(\"true\"))\n            getQSAdminServer().setShellEnable(true);\n        getQSAdminServer().setPromptName(config.getCommandShellPromptName());\n        //v1.3.3\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception {\n        configQuickServer(getConfig());\n        if (getConfig().getQSAdminServerConfig() !\u003d null) {\n            configQuickServer(getConfig().getQSAdminServerConfig());\n        }\n    }\n\n    /**\n     * Usage: QuickServer [-options]\u003cbr/\u003e\n     * Where options include:\u003cbr/\u003e\n     *   -about\t\tOpens About Dialogbox\u003cbr/\u003e\n     *   -load \u003cxml_config_file\u003e [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File \u003cnew_file_name\u003e\n     */\n    public static void main(String[] args) {\n        try {\n            if (args.length \u003e\u003d 1) {\n                if (args[0].equals(\"-about\")) {\n                    org.quickserver.net.server.gui.About.main(null);\n                } else if (args[0].equals(\"-load\") \u0026\u0026 args.length \u003e\u003d 2) {\n                    QuickServer qs \u003d QuickServer.load(args[1]);\n                    if (qs !\u003d null)\n                        handleOptions(args, qs);\n                } else {\n                    System.out.println(printUsage());\n                }\n            } else {\n                System.out.println(printUsage());\n                org.quickserver.net.server.gui.About.showAbout();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException {\n        QuickServer qs \u003d new QuickServer();\n        Object[] config \u003d new Object[] { xml };\n        qs.initServer(config);\n        qs.startServer();\n        if (qs.getConfig().getQSAdminServerConfig() !\u003d null) {\n            qs.startQSAdminServer();\n        }\n        return qs;\n    }\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage() {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"QuickServer - Java library/framework for creating robust multi-client TCP servers.\\n\");\n        sb.append(\"Copyright (C) QuickServer.org\\n\\n\");\n        sb.append(\"Usage: QuickServer [-options]\\n\");\n        sb.append(\"Where options include:\\n\");\n        sb.append(\"  -about\\t\" + \"Opens About Dialog box\\n\");\n        sb.append(\"  -load \u003cxml_config_file\u003e [load-options]\\t\" + \"Loads the server from xml file.\\n\");\n        sb.append(\"  Where load-options include:\\n\");\n        sb.append(\"     -fullXML2File \u003cfile_name\u003e\\t\" + \"Dumps the Full XML configuration of the QuickServer loaded.\\n\");\n        return sb.toString();\n    }\n\n    private static void handleOptions(String[] args, QuickServer quickserver) {\n        if (args.length \u003c 3)\n            return;\n        if (args[2].equals(\"-fullXML2File\") \u0026\u0026 args.length \u003e\u003d 4) {\n            File file \u003d new File(args[3]);\n            logger.log(Level.INFO, \"Writing full xml configuration to file: {0}\", file.getAbsolutePath());\n            try {\n                TextFile.write(file, quickserver.getConfig().toXML(null));\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error writing full xml configuration: {0}\", e);\n            }\n        }\n    }\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception {\n        try {\n            if (pool !\u003d null)\n                getClientPool().clear();\n            if (clientHandlerPool !\u003d null)\n                getClientHandlerPool().clear();\n            if (getClientDataPool() !\u003d null)\n                getClientDataPool().clear();\n            if (getDBPoolUtil() !\u003d null)\n                getDBPoolUtil().clean();\n            if (byteBufferPool !\u003d null)\n                getByteBufferPool().clear();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error: {0}\", e);\n            throw e;\n        }\n    }\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception {\n        if (pool \u003d\u003d null \u0026\u0026 clientHandlerPool \u003d\u003d null \u0026\u0026 getClientDataPool() \u003d\u003d null \u0026\u0026 getDBPoolUtil() \u003d\u003d null \u0026\u0026 byteBufferPool \u003d\u003d null) {\n            return;\n        }\n        logger.log(Level.FINE, \"Closing pools for {0}\", getName());\n        try {\n            if (pool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {\n                logger.finer(\"Closing ClientThread pool.\");\n                getClientPool().close();\n            }\n            if (clientHandlerPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientHandlerPool())) {\n                logger.finer(\"Closing ClientHandler pool.\");\n                getClientHandlerPool().close();\n            }\n            if (getClientDataPool() !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientDataPool())) {\n                logger.finer(\"Closing ClientData pool.\");\n                getClientDataPool().close();\n            }\n            if (getDBPoolUtil() !\u003d null) {\n                logger.finer(\"Closing DB pool.\");\n                getDBPoolUtil().clean();\n            }\n            if (byteBufferPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getByteBufferPool())) {\n                logger.finer(\"Closing ByteBuffer pool.\");\n                getByteBufferPool().close();\n            }\n            logger.log(Level.FINE, \"Closed pools for {0}\", getName());\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error closing pools for {0}: {1}\", new Object[] { getName(), e });\n            throw e;\n        }\n    }\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception {\n        logger.fine(\"Creating pools\");\n        if (getBlockingMode() \u003d\u003d false) {\n            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());\n        }\n        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());\n        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());\n        //check if client data is poolable\n        if (clientDataClass !\u003d null) {\n            try {\n                clientData \u003d (ClientData) clientDataClass.newInstance();\n                if (PoolableObject.class.isInstance(clientData) \u003d\u003d true) {\n                    PoolableObject po \u003d (PoolableObject) clientData;\n                    if (po.isPoolable() \u003d\u003d true) {\n                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());\n                    } else {\n                        clientDataPool \u003d null;\n                        logger.fine(\"ClientData is not poolable!\");\n                    }\n                }\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error: {0}\", e);\n                throw e;\n            }\n        }\n        try {\n            makeDBObjectPool();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error in makeDBObjectPool() : {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw e;\n        }\n        logger.fine(\"Created pools\");\n    }\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool() {\n        if (pool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientPool available yet!\");\n        return pool;\n    }\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientHandler pool\");\n        PoolableObjectFactory factory \u003d new ClientHandlerObjectFactory(getBlockingMode());\n        clientHandlerPool \u003d poolManager.makeClientHandlerPool(factory, opConfig);\n        poolManager.initPool(clientHandlerPool, opConfig);\n        clientHandlerPool \u003d makeQSObjectPool(clientHandlerPool);\n        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool() {\n        if (clientHandlerPool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientHandler Pool available yet!\");\n        return clientHandlerPool;\n    }\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config) {\n        this.config \u003d config;\n    }\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig() {\n        return config;\n    }\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientData pool\");\n        clientDataPool \u003d poolManager.makeClientDataPool(factory, opConfig);\n        poolManager.initPool(clientDataPool, opConfig);\n        clientDataPool \u003d makeQSObjectPool(clientDataPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool() {\n        return clientDataPool;\n    }\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return \u003ccode\u003enull\u003c/code\u003e\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil() {\n        return dBPoolUtil;\n    }\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {\n        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);\n    }\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception {\n        if (getConfig().getDBObjectPoolConfig() !\u003d null) {\n            logger.fine(\"Creating DBObject Pool\");\n            //logger.finest(\"Got:\\n\"+getConfig().getDBObjectPoolConfig().toXML(null));\n            Class dbPoolUtilClass \u003d getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);\n            dBPoolUtil \u003d (DBPoolUtil) dbPoolUtilClass.newInstance();\n            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());\n            dBPoolUtil.initPool();\n        }\n    }\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id) {\n        return clientIdentifier.findFirstClientById(id);\n    }\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  \u003ccode\u003e\u003cpre\u003e\n     *    Eg:\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tObject syncObj \u003d quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator \u003d quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tClientIdentifier clientIdentifier \u003d quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator \u003d clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    \u003c/code\u003e\u003c/pre\u003e\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient() {\n        return clientIdentifier.findAllClient();\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern) {\n        return clientIdentifier.findAllClientById(pattern);\n    }\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key) {\n        return clientIdentifier.findClientByKey(key);\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern) {\n        return clientIdentifier.findAllClientByKey(pattern);\n    }\n\n    /**\n     * Sets next client has a trusted client.\n     * \u003cp\u003eThis will skip any authentication and will not set any timeout.\u003c/p\u003e\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted() {\n        setSkipValidation(true);\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation() {\n        return skipValidation;\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation) {\n        skipValidation \u003d validation;\n    }\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging) {\n        this.communicationLogging \u003d communicationLogging;\n    }\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging() {\n        return communicationLogging;\n    }\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass) {\n        if (securityManagerClass !\u003d null)\n            this.securityManagerClass \u003d securityManagerClass;\n    }\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass() {\n        return securityManagerClass;\n    }\n\n    public SecurityManager getSecurityManager() throws AppException {\n        if (getSecurityManagerClass() \u003d\u003d null)\n            return null;\n        SecurityManager sm \u003d null;\n        try {\n            sm \u003d (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();\n        } catch (ClassNotFoundException e) {\n            throw new AppException(e.getMessage());\n        } catch (InstantiationException e) {\n            throw new AppException(e.getMessage());\n        } catch (IllegalAccessException e) {\n            throw new AppException(e.getMessage());\n        }\n        return sm;\n    }\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {\n        this.accessConstraintConfig \u003d accessConstraintConfig;\n    }\n\n    /**\n     * Returns Access constraints if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig() {\n        return accessConstraintConfig;\n    }\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader) {\n        this.classLoader \u003d classLoader;\n        Thread.currentThread().setContextClassLoader(classLoader);\n    }\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader() {\n        return classLoader;\n    }\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException {\n        if (name \u003d\u003d null)\n            throw new IllegalArgumentException(\"Class name can\u0027t be null!\");\n        logger.log(Level.FINEST, \"Class: {0}, reload: {1}\", new Object[] { name, reload });\n        if (reload \u003d\u003d true \u0026\u0026 classLoader !\u003d null) {\n            return classLoader.loadClass(name);\n        } else if (reload \u003d\u003d true \u0026\u0026 classLoader \u003d\u003d null \u0026\u0026 this.getClass().getClassLoader() !\u003d null) {\n            return this.getClass().getClassLoader().loadClass(name);\n        } else if (reload \u003d\u003d false \u0026\u0026 classLoader !\u003d null) {\n            return Class.forName(name, true, classLoader);\n        } else /*if(reload\u003d\u003dfalse \u0026\u0026 classLoader\u003d\u003dnull)*/\n        {\n            return Class.forName(name, true, this.getClass().getClassLoader());\n        }\n    }\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath) {\n        this.applicationJarPath \u003d applicationJarPath;\n    }\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath() {\n        return applicationJarPath;\n    }\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks) {\n        this.serverHooks \u003d serverHooks;\n    }\n\n    /**\n     * Returns ServerHooks if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks() {\n        if (serverHooks \u003d\u003d null)\n            serverHooks \u003d new ServerHooks();\n        return serverHooks;\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses() {\n        if (getServerHooks() \u003d\u003d null)\n            return;\n        listOfServerHooks \u003d new ArrayList();\n        ServerHook serverHook \u003d null;\n        String serverHookClassName \u003d null;\n        Class serverHookClass \u003d null;\n        //add system hooks\n        serverHook \u003d new GhostSocketReaper();\n        serverHook.initHook(QuickServer.this);\n        listOfServerHooks.add(serverHook);\n        ghostSocketReaper \u003d (GhostSocketReaper) serverHook;\n        //add user hooks if any\n        Iterator iterator \u003d getServerHooks().iterator();\n        while (iterator.hasNext()) {\n            serverHookClassName \u003d (String) iterator.next();\n            try {\n                serverHookClass \u003d getClass(serverHookClassName, true);\n                serverHook \u003d (ServerHook) serverHookClass.newInstance();\n                serverHook.initHook(QuickServer.this);\n                listOfServerHooks.add(serverHook);\n                logger.log(Level.INFO, \"Loaded server hook: {0}\", serverHookClassName);\n                logger.log(Level.FINE, \"Server hook info: {0}\", serverHook.info());\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Could not load server hook [{0}]: {1}\", new Object[] { serverHookClassName, e });\n                logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            }\n        }\n        //end of while\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event) {\n        if (listOfServerHooks \u003d\u003d null) {\n            logger.warning(\"listOfServerHooks was null!\");\n            return;\n        }\n        ServerHook serverHook \u003d null;\n        boolean result \u003d false;\n        Iterator iterator \u003d listOfServerHooks.iterator();\n        String hooktype \u003d \"UNKNOWN\";\n        switch(event) {\n            case ServerHook.PRE_STARTUP:\n                hooktype \u003d \"PRE_STARTUP\";\n                break;\n            case ServerHook.POST_STARTUP:\n                hooktype \u003d \"POST_STARTUP\";\n                break;\n            case ServerHook.PRE_SHUTDOWN:\n                hooktype \u003d \"PRE_SHUTDOWN\";\n                break;\n            case ServerHook.POST_SHUTDOWN:\n                hooktype \u003d \"POST_SHUTDOWN\";\n                break;\n        }\n        while (iterator.hasNext()) {\n            serverHook \u003d (ServerHook) iterator.next();\n            try {\n                result \u003d serverHook.handleEvent(event);\n            } catch (Exception e) {\n                result \u003d false;\n                logger.log(Level.WARNING, \"Error invoking {0} hook [{1}]: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });\n            }\n            logger.log(Level.FINE, \"Invoked {0} hook [{1}] was: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), result });\n        }\n    }\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone() {\n        Object object \u003d null;\n        try {\n            object \u003d super.clone();\n            QuickServer _qs \u003d (QuickServer) object;\n            _qs.setQSAdminServer(new QSAdminServer(_qs));\n        } catch (CloneNotSupportedException e) {\n            //should not happ\n            logger.log(Level.WARNING, \"Error cloning : {0}\", e);\n        }\n        return object;\n    }\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure) {\n        this.secure \u003d secure;\n    }\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure() {\n        if (secure \u003d\u003d null)\n            secure \u003d new Secure();\n        return secure;\n    }\n\n    /**\n     * \u003cp\u003eReturns if the server is running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure() {\n        return runningSecure;\n    }\n\n    /**\n     * \u003cp\u003eSets the server mode if its running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure) {\n        this.runningSecure \u003d runningSecure;\n    }\n\n    private File makeAbsoluteToConfig(String fileName) {\n        Assertion.affirm(fileName !\u003d null, \"FileName can\u0027t be null\");\n        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());\n    }\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException {\n        server \u003d null;\n        logger.log(Level.FINEST, \"Binding {0} to IP: {1}\", new Object[] { getName(), getBindAddr() });\n        InetSocketAddress bindAddress \u003d new InetSocketAddress(getBindAddr(), getPort());\n        try {\n            NetworkInterface ni \u003d NetworkInterface.getByInetAddress(getBindAddr());\n            if (ni !\u003d null) {\n                logger.fine(\"NetworkInterface: \" + ni);\n            }\n        } catch (Exception igrnore) {\n            /*ignore*/\n        } catch (Error igrnore) {\n            /*ignore*/\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Making a normal ServerSocket for {0}\", getName());\n            setRunningSecure(false);\n            if (getBlockingMode() \u003d\u003d false) {\n                //for non-blocking\n                serverSocketChannel \u003d ServerSocketChannel.open();\n                server \u003d serverSocketChannel.socket();\n                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n            } else {\n                //for blocking\n                server \u003d new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n            }\n        } else {\n            try {\n                logger.log(Level.FINE, \"Making a secure ServerSocket for {0}\", getName());\n                getSSLContext();\n                setRunningSecure(true);\n                if (getBlockingMode() \u003d\u003d false) {\n                    logger.log(Level.FINE, \"Making a secure ServerSocketChannel for {0}\", getName());\n                    //for non-blocking\n                    serverSocketChannel \u003d ServerSocketChannel.open();\n                    server \u003d serverSocketChannel.socket();\n                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n                } else {\n                    ServerSocketFactory ssf \u003d getSSLContext().getServerSocketFactory();\n                    SSLServerSocket serversocket \u003d (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());\n                    setRunningSecure(true);\n                    secureStoreManager.logSSLServerSocketInfo(serversocket);\n                    server \u003d serversocket;\n                    serverSocketChannel \u003d server.getChannel();\n                    if (serverSocketChannel \u003d\u003d null \u0026\u0026 getBlockingMode() \u003d\u003d false) {\n                        logger.warning(\"Secure Server does not support Channel! So will run in blocking mode.\");\n                        blockingMode \u003d false;\n                    }\n                }\n                //blocking\n            } catch (NoSuchAlgorithmException e) {\n                logger.log(Level.WARNING, \"NoSuchAlgorithmException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            } catch (KeyManagementException e) {\n                logger.log(Level.WARNING, \"KeyManagementException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            }\n        }\n        server.setReuseAddress(true);\n        int connectionTime \u003d 0;\n        int latency \u003d 0;\n        int bandwidth \u003d 0;\n        connectionTime \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();\n        latency \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();\n        bandwidth \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();\n        logger.log(Level.FINE, \"getPerformancePreferencesConnectionTime : {0}\", connectionTime);\n        logger.log(Level.FINE, \"getPerformancePreferencesLatency : {0}\", latency);\n        logger.log(Level.FINE, \"getPerformancePreferencesBandwidth : {0}\", bandwidth);\n        server.setPerformancePreferences(connectionTime, latency, bandwidth);\n        int clientSocketReceiveBufferSize \u003d getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();\n        if (clientSocketReceiveBufferSize \u003e 0) {\n            logger.log(Level.FINE, \"clientSocketReceiveBufferSize: {0}\", clientSocketReceiveBufferSize);\n            server.setReceiveBufferSize(clientSocketReceiveBufferSize);\n        }\n        if (getBlockingMode() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Server Mode {0} - Non Blocking\", getName());\n            if (selector \u003d\u003d null || selector.isOpen() \u003d\u003d false) {\n                logger.finest(\"Opening new selector\");\n                selector \u003d Selector.open();\n            } else {\n                logger.log(Level.FINEST, \"Reusing selector: {0}\", selector);\n            }\n            serverSocketChannel.configureBlocking(false);\n            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n            selector.wakeup();\n        } else {\n            logger.log(Level.FINE, \"Server Mode {0} - Blocking\", getName());\n        }\n    }\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {\n        Assertion.affirm(basicConfig !\u003d null, \"BasicServerConfig can\u0027t be null\");\n        this.basicConfig \u003d basicConfig;\n    }\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig() {\n        return basicConfig;\n    }\n\n    /**\n     * Loads the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException {\n        if (getSecure().isLoad() \u003d\u003d false) {\n            throw new IllegalStateException(\"Secure setting is not yet enabled for loading!\");\n        }\n        logger.info(\"Loading Secure Context..\");\n        km \u003d null;\n        tm \u003d null;\n        try {\n            String ssManager \u003d \"org.quickserver.security.SecureStoreManager\";\n            if (getSecure().getSecureStore() !\u003d null)\n                ssManager \u003d getSecure().getSecureStore().getSecureStoreManager();\n            Class secureStoreManagerClass \u003d getClass(ssManager, true);\n            secureStoreManager \u003d (SecureStoreManager) secureStoreManagerClass.newInstance();\n            km \u003d secureStoreManager.loadKeyManagers(getConfig());\n            logger.fine(\"KeyManager got\");\n            tm \u003d secureStoreManager.loadTrustManagers(getConfig());\n            logger.fine(\"TrustManager got\");\n            sslc \u003d secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());\n            sslc.init(km, tm, null);\n            logger.fine(\"SSLContext loaded\");\n        } catch (KeyStoreException e) {\n            logger.warning(\"KeyStoreException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchAlgorithmException e) {\n            logger.warning(\"NoSuchAlgorithmException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchProviderException e) {\n            logger.warning(\"NoSuchProviderException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (UnrecoverableKeyException e) {\n            logger.warning(\"UnrecoverableKeyException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (CertificateException e) {\n            logger.warning(\"CertificateException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (KeyManagementException e) {\n            logger.warning(\"KeyManagementException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (GeneralSecurityException e) {\n            logger.warning(\"GeneralSecurityException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (ClassNotFoundException e) {\n            logger.warning(\"ClassNotFoundException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (InstantiationException e) {\n            logger.warning(\"InstantiationException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (IllegalAccessException e) {\n            logger.warning(\"IllegalAccessException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        return getSSLContext(null);\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        if (protocol !\u003d null \u0026\u0026 secureStoreManager !\u003d null) {\n            SSLContext _sslc \u003d secureStoreManager.getSSLContext(protocol);\n            _sslc.init(km, tm, null);\n            return _sslc;\n        }\n        return sslc;\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext());\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext(protocol));\n    }\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler) {\n        clientBinaryHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler() {\n        return clientBinaryHandlerString;\n    }\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector) {\n        this.selector \u003d selector;\n    }\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector() {\n        return selector;\n    }\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception {\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        //long stime \u003d System.currentTimeMillis();\n        //long etime \u003d System.currentTimeMillis();\n        while (true) {\n            //etime \u003d System.currentTimeMillis();\n            //System.out.println(\"Time Taken: \"+(etime-stime));\n            client \u003d server.accept();\n            //stime \u003d System.currentTimeMillis();\n            if (linger \u003c 0) {\n                client.setSoLinger(false, 0);\n            } else {\n                client.setSoLinger(true, linger);\n            }\n            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                //low delay\u003d10\n                client.setTrafficClass(socketTrafficClass);\n            }\n            logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n            }\n            if (stopServer) {\n                //Client connected when server was about to be shutdown.\n                try {\n                    client.close();\n                } catch (Exception e) {\n                }\n                break;\n            }\n            if (checkAccessConstraint(client) \u003d\u003d false) {\n                continue;\n            }\n            //Check if max connection has reached\n            if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);\n            } else {\n                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);\n            }\n            theClient.setTrusted(getSkipValidation());\n            theClient.setSocket(client);\n            //mostly null\n            theClient.setSocketChannel(client.getChannel());\n            if (clientDataClass !\u003d null) {\n                if (getClientDataPool() \u003d\u003d null) {\n                    clientData \u003d (ClientData) clientDataClass.newInstance();\n                } else {\n                    clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                }\n                theClient.setClientData(clientData);\n            }\n            try {\n                _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                _chPolled.handleClient(theClient);\n            } catch (java.util.NoSuchElementException nsee) {\n                logger.warning(\"Could not borrow ClientHandler from pool. Error: \" + nsee);\n                logger.warning(\"Closing Socket [\" + client + \"] since no ClientHandler available.\");\n                client.close();\n            }\n            if (_chPolled !\u003d null) {\n                try {\n                    getClientPool().addClient(_chPolled, true);\n                } catch (java.util.NoSuchElementException nsee) {\n                    logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                    //logger.warning(\"Closing Socket [\"+client+\"] since no Thread available.\");\n                    //client.close();\n                    //returnClientHandlerToPool(_chPolled);\n                }\n                _chPolled \u003d null;\n            }\n            client \u003d null;\n            //reset it back\n            setSkipValidation(false);\n        }\n        //end of loop\n    }\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception {\n        int selectCount \u003d 0;\n        Iterator iterator \u003d null;\n        SelectionKey key \u003d null;\n        ServerSocketChannel serverChannel \u003d null;\n        SocketChannel socketChannel \u003d null;\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        boolean stopServerProcessed \u003d false;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        registerChannelRequestMap \u003d new HashMap();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        while (true) {\n            selectCount \u003d selector.select(500);\n            //selectCount \u003d selector.select();//for testing\n            //check for any pending registerChannel req.\n            synchronized (registerChannelRequestMap) {\n                if (registerChannelRequestMap.size() \u003e 0) {\n                    RegisterChannelRequest req \u003d null;\n                    Object hashkey \u003d null;\n                    iterator \u003d registerChannelRequestMap.keySet().iterator();\n                    while (iterator.hasNext()) {\n                        hashkey \u003d iterator.next();\n                        req \u003d (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);\n                        req.register(getSelector());\n                    }\n                    iterator \u003d null;\n                    registerChannelRequestMap.clear();\n                }\n                //if\n            }\n            //sync\n            if (stopServer \u003d\u003d true \u0026\u0026 stopServerProcessed \u003d\u003d false) {\n                logger.warning(\"Closing \" + getName());\n                serverSocketChannel.close();\n                stopServerProcessed \u003d true;\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.warning(\"Closed \" + getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n            if (stopServer \u003d\u003d false \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                logger.finest(\"Server must have re-started.. will break\");\n                break;\n            }\n            if (selectCount \u003d\u003d 0 \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                java.util.Set keyset \u003d selector.keys();\n                if (keyset.isEmpty() \u003d\u003d true \u0026\u0026 getClientCount() \u003c\u003d 0) {\n                    break;\n                } else {\n                    continue;\n                }\n            } else if (selectCount \u003d\u003d 0) {\n                continue;\n            }\n            iterator \u003d selector.selectedKeys().iterator();\n            while (iterator.hasNext()) {\n                key \u003d (SelectionKey) iterator.next();\n                if (key.isValid() \u003d\u003d false) {\n                    iterator.remove();\n                    continue;\n                }\n                if (key.isAcceptable() \u0026\u0026 stopServer \u003d\u003d false) {\n                    logger.finest(\"Key is Acceptable\");\n                    serverChannel \u003d (ServerSocketChannel) key.channel();\n                    socketChannel \u003d serverChannel.accept();\n                    if (socketChannel \u003d\u003d null) {\n                        iterator.remove();\n                        continue;\n                    }\n                    client \u003d socketChannel.socket();\n                    if (linger \u003c 0) {\n                        client.setSoLinger(false, 0);\n                    } else {\n                        client.setSoLinger(true, linger);\n                    }\n                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                        //low delay\u003d10\n                        client.setTrafficClass(socketTrafficClass);\n                    }\n                    logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                        logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n                    }\n                    if (checkAccessConstraint(client) \u003d\u003d false) {\n                        iterator.remove();\n                        continue;\n                    }\n                    socketChannel.configureBlocking(false);\n                    theClient.setTrusted(getSkipValidation());\n                    theClient.setSocket(socketChannel.socket());\n                    theClient.setSocketChannel(socketChannel);\n                    if (clientDataClass !\u003d null) {\n                        if (getClientDataPool() \u003d\u003d null) {\n                            clientData \u003d (ClientData) clientDataClass.newInstance();\n                        } else {\n                            //borrow a object from pool\n                            clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                        }\n                        theClient.setClientData(clientData);\n                    }\n                    //Check if max connection has reached\n                    if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                        theClient.setClientEvent(ClientEvent.MAX_CON);\n                    } else {\n                        theClient.setClientEvent(ClientEvent.ACCEPT);\n                    }\n                    try {\n                        _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                        logger.finest(\"Asking \" + _chPolled.getName() + \" to handle.\");\n                        _chPolled.handleClient(theClient);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.warning(\"Could not borrow ClientHandler Object from pool. Error: \" + nsee);\n                        logger.warning(\"Closing SocketChannel [\" + serverChannel.socket() + \"] since no ClientHandler available.\");\n                        socketChannel.close();\n                    }\n                    if (_chPolled !\u003d null) {\n                        try {\n                            getClientPool().addClient(_chPolled, true);\n                        } catch (java.util.NoSuchElementException nsee) {\n                            logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                            //logger.warning(\"Closing SocketChannel [\"+serverChannel.socket()+\"] since no Thread available.\");\n                            //socketChannel.close();\n                            //returnClientHandlerToPool(_chPolled);\n                        }\n                        _chPolled \u003d null;\n                    }\n                    socketChannel \u003d null;\n                    client \u003d null;\n                    //reset it back\n                    setSkipValidation(false);\n                } else if (key.isValid() \u0026\u0026 key.isReadable()) {\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Readable, removing OP_READ from interestOps for \" + _ch.getName());\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_READ));\n                        _ch.addEvent(ClientEvent.READ);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.READ);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (key.isValid() \u0026\u0026 key.isWritable()) {\n                    if (getClientPool().shouldNioWriteHappen() \u003d\u003d false) {\n                        //no need to remove the key\n                        continue;\n                    }\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Writable, removing OP_WRITE from interestOps for \" + _ch.getName());\n                        //remove OP_WRITE from interest set\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_WRITE));\n                        _ch.addEvent(ClientEvent.WRITE);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.WRITE);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (stopServer \u003d\u003d true \u0026\u0026 key.isAcceptable()) {\n                    //we will not accept this key\n                    //reset it back\n                    setSkipValidation(false);\n                } else {\n                    logger.warning(\"Unknown key got in SelectionKey: \" + key);\n                }\n                //Remove key\n                iterator.remove();\n                Thread.yield();\n            }\n            //end of iterator\n            iterator \u003d null;\n        }\n        //end of loop\n    }\n\n    private boolean checkAccessConstraint(Socket socket) {\n        try {\n            if (getAccessConstraintConfig() !\u003d null) {\n                getAccessConstraintConfig().checkAccept(socket);\n            }\n            return true;\n        } catch (SecurityException se) {\n            logger.warning(\"SecurityException occurred accepting connection : \" + se.getMessage());\n            return false;\n        }\n    }\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {\n        if (getSelector() \u003d\u003d null) {\n            throw new IllegalStateException(\"Selector is not open!\");\n        }\n        if (channel \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Can\u0027t register a null channel!\");\n        }\n        if (channel.isConnected() \u003d\u003d false) {\n            throw new ClosedChannelException();\n        }\n        RegisterChannelRequest req \u003d new RegisterChannelRequest(channel, ops, att);\n        RegisterChannelRequest reqOld \u003d null;\n        synchronized (registerChannelRequestMap) {\n            reqOld \u003d (RegisterChannelRequest) registerChannelRequestMap.get(channel);\n            if (reqOld \u003d\u003d null) {\n                registerChannelRequestMap.put(channel, req);\n                getSelector().wakeup();\n                return true;\n            } else {\n                if (reqOld.equals(req) \u003d\u003d false) {\n                    reqOld.setOps(reqOld.getOps() | req.getOps());\n                    reqOld.setAtt(req.getAtt());\n                    return true;\n                }\n                return false;\n            }\n        }\n        /*\n\t\tlogger.warning(\"Before register...\");\n\t\tchannel.register(getSelector(), ops, att);\n\t\tlogger.warning(\"Before wakeup and after register...\");\n\t\tgetSelector().wakeup();\n\t\tlogger.warning(\"After wakeup...\");\n\t\t*/\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig) {\n        logger.finer(\"Creating ByteBufferPool pool\");\n        int bufferSize \u003d getBasicConfig().getAdvancedSettings().getByteBufferSize();\n        boolean useDirectByteBuffer \u003d getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();\n        PoolableObjectFactory factory \u003d new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);\n        byteBufferPool \u003d poolManager.makeByteBufferPool(factory, opConfig);\n        poolManager.initPool(byteBufferPool, opConfig);\n    }\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool() {\n        return byteBufferPool;\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientThread pool\");\n        ThreadObjectFactory factory \u003d new ThreadObjectFactory();\n        ObjectPool objectPool \u003d poolManager.makeClientPool(factory, opConfig);\n        pool \u003d new ClientPool(makeQSObjectPool(objectPool), opConfig);\n        factory.setClientPool(pool);\n        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());\n        poolManager.initPool(objectPool, opConfig);\n    }\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler) {\n        clientWriteHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler() {\n        return clientWriteHandlerString;\n    }\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be \u003ccode\u003enull\u003c/code\u003e if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime() {\n        return lastStartTime;\n    }\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag) {\n        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);\n        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);\n    }\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier() {\n        return clientIdentifier;\n    }\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {\n        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);\n    }\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode() {\n        return blockingMode;\n    }\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception {\n        if (clientCommandHandlerString \u003d\u003d null \u0026\u0026 clientEventHandlerString \u003d\u003d null) {\n            logger.severe(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n            throw new AppException(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n        }\n        clientCommandHandler \u003d null;\n        if (clientCommandHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientCommandHandler class..\");\n            Class clientCommandHandlerClass \u003d getClass(clientCommandHandlerString, true);\n            clientCommandHandler \u003d (ClientCommandHandler) clientCommandHandlerClass.newInstance();\n        }\n        boolean setClientCommandHandlerLookup \u003d false;\n        clientEventHandler \u003d null;\n        if (clientEventHandlerString \u003d\u003d null) {\n            clientEventHandlerString \u003d \"org.quickserver.net.server.impl.DefaultClientEventHandler\";\n            setClientCommandHandlerLookup \u003d true;\n        }\n        logger.finest(\"Loading ClientEventHandler class..\");\n        if (clientEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientEventHandler.class.isInstance(clientCommandHandler)) {\n            clientEventHandler \u003d (ClientEventHandler) clientCommandHandler;\n        } else {\n            clientEventHandler \u003d (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();\n            if (setClientCommandHandlerLookup) {\n                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);\n            }\n        }\n        clientExtendedEventHandler \u003d null;\n        if (clientExtendedEventHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientExtendedEventHandler class..\");\n            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientCommandHandler;\n            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientEventHandler;\n            } else {\n                Class clientExtendedEventHandlerClass \u003d getClass(clientExtendedEventHandlerString, true);\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();\n            }\n        }\n        clientObjectHandler \u003d null;\n        if (clientObjectHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientObjectHandler class..\");\n            if (clientObjectHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientCommandHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientCommandHandler;\n            } else if (clientObjectHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientEventHandler;\n            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientExtendedEventHandler;\n            } else {\n                clientObjectHandler \u003d (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientBinaryHandler \u003d null;\n        if (clientBinaryHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientBinaryHandler class..\");\n            if (clientBinaryHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientCommandHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientCommandHandler;\n            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientExtendedEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientObjectHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientObjectHandler;\n            } else {\n                clientBinaryHandler \u003d (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientWriteHandler \u003d null;\n        if (clientWriteHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientWriteHandler class..\");\n            if (clientWriteHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientCommandHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientCommandHandler;\n            } else if (clientWriteHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientEventHandler;\n            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientExtendedEventHandler;\n            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientObjectHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientObjectHandler;\n            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientBinaryHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientBinaryHandler;\n            } else {\n                clientWriteHandler \u003d (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        Class authenticatorClass \u003d null;\n        if (clientAuthenticationHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientAuthenticationHandler class..\");\n            authenticatorClass \u003d getClass(clientAuthenticationHandlerString, true);\n        }\n        if (authenticatorClass !\u003d null) {\n            Object obj \u003d authenticatorClass.newInstance();\n            if (ClientAuthenticationHandler.class.isInstance(obj))\n                clientAuthenticationHandler \u003d (ClientAuthenticationHandler) obj;\n            else\n                authenticator \u003d (Authenticator) obj;\n        }\n        clientDataClass \u003d null;\n        if (clientDataString !\u003d null) {\n            logger.finest(\"Loading ClientData class..\");\n            clientDataClass \u003d getClass(clientDataString, true);\n        }\n        Assertion.affirm(clientEventHandler !\u003d null, \"ClientEventHandler was not loaded!\");\n    }\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler) {\n        clientEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler() {\n        return clientEventHandlerString;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {\n        if (dataType \u003d\u003d DataType.IN)\n            this.defaultDataModeIN \u003d dataMode;\n        if (dataType \u003d\u003d DataType.OUT)\n            this.defaultDataModeOUT \u003d dataMode;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {\n        defaultDataModeIN \u003d defaultDataMode.getDataMode(DataType.IN);\n        defaultDataModeOUT \u003d defaultDataMode.getDataMode(DataType.OUT);\n        ;\n    }\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType) {\n        if (dataType \u003d\u003d DataType.IN)\n            return defaultDataModeIN;\n        if (dataType \u003d\u003d DataType.OUT)\n            return defaultDataModeOUT;\n        else\n            throw new IllegalArgumentException(\"Unknown DataType: \" + dataType);\n    }\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler) {\n        clientExtendedEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler() {\n        return clientExtendedEventHandlerString;\n    }\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception {\n        if (getApplicationJarPath() !\u003d null \u0026\u0026 getClassLoader() \u003d\u003d null) {\n            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));\n            //update qsadmin to use the same\n            if (adminServer !\u003d null) {\n                adminServer.getServer().setClassLoader(getClassLoader());\n            }\n        }\n    }\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID() {\n        return pid;\n    }\n\n    public boolean isRawCommunicationLogging() {\n        return rawCommunicationLogging;\n    }\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {\n        this.rawCommunicationLogging \u003d rawCommunicationLogging;\n    }\n\n    public int getRawCommunicationMaxLength() {\n        return rawCommunicationMaxLength;\n    }\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {\n        this.rawCommunicationMaxLength \u003d rawCommunicationMaxLength;\n    }\n}\n",
    "package": "org.quickserver.net.server",
    "classname": "QuickServer",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_6Test.java",
    "test_prompt": "// QuickServer_6Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#startService()} method.\n*/\nclass QuickServer_6Test {",
    "method_signature": "startService()",
    "suffix": "6"
  },
  {
    "numberTests": "ten",
    "original_code": "// QuickServer.java\n/*\n * This file is part of the QuickServer library \n * Copyright (C) QuickServer.org\n *\n * Use, modification, copying and distribution of this software is subject to\n * the terms and conditions of the GNU Lesser General Public License. \n * You should have received a copy of the GNU LGP License along with this \n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\n *\n * For questions, suggestions, bug-reports, enhancement-requests etc.\n * visit http://www.quickserver.org\n *\n */\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n *  Main class of QuickServer library. This class is used to create\n *  multi client servers quickly.\n *  \u003cp\u003e\n *  Ones a client is connected, it creates {@link ClientHandler} object,\n *  which is run using any thread available from the pool of threads\n *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n *  handles the client. \u003cbr/\u003e\n *  QuickServer divides the application logic of its developer over eight\n *  class, \u003cbr\u003e\n *  \t\u003cul\u003e\n * \t\t\u003cli\u003eClientEventHandler\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client events [Optional Class].\n *  \t\t\u003cli\u003eClientCommandHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client character/string commands.\n *  \t\t\u003cli\u003eClientObjectHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - Object commands.\n * \t\t\u003cli\u003eClientBinaryHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - binary data.\n * \t\t\u003cli\u003eClientWriteHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n *  \t\t\u003cli\u003eClientAuthenticationHandler [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Used to Authencatet a client.\n *  \t\t\u003cli\u003eClientData [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Client data carrier (support class)\n * \t\t\u003cli\u003eClientExtendedEventHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles extended client events.\n *  \t\u003c/ul\u003e\n *\n *  [#] \u003d Any one of these have to be set based on default DataMode for input.\n *  The default DataMode for input is String so if not changes you will\n *  have to set ClientCommandHandler.\n *  \u003c/p\u003e\n *  \u003cp\u003e\n *   Eg:\n *  \u003ccode\u003e\u003cBLOCKQUOTE\u003e\u003cpre\u003e\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle \u003d \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer \u003d new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * \u003c/pre\u003e\u003c/BLOCKQUOTE\u003e\u003c/code\u003e\u003c/p\u003e\n *\n *  @version 1.4.8\n *  @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //Some variable are not initialised to any value because the\n    //default java value was desired initial value.\n    //\u0027dev \u0027 \u003d development build not yet final\n    //\u0027beta\u0027 \u003d test build all features\n    //change also in QSAdminMain\n    private final static String VER \u003d \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n        if (System.getProperty(\"org.quickserver.useOSLineSeparator\") !\u003d null \u0026\u0026 System.getProperty(\"org.quickserver.useOSLineSeparator\").equals(\"true\")) {\n            NEW_LINE \u003d System.getProperty(\"line.separator\");\n        } else {\n            NEW_LINE \u003d \"\\r\\n\";\n        }\n        String _pid \u003d ManagementFactory.getRuntimeMXBean().getName();\n        int i \u003d _pid.indexOf(\"@\");\n        pid \u003d _pid.substring(0, i);\n        System.out.print(\"Loading QuickServer v\" + getVersion() + \" [PID:\" + pid + \"]\");\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort \u003d 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName \u003d \"QuickServer\";\n\n    private long maxConnection \u003d -1;\n\n    //1 min socket timeout\n    private int socketTimeout \u003d 60 * 1000;\n\n    private String maxConnectionMsg \u003d \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg \u003d \"-ERR Timeout\";\n\n    private String maxAuthTryMsg \u003d \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry \u003d 5;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //--v1.2\n    //Logger for QuickServer\n    private static final Logger logger \u003d Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //for Service interface\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState \u003d Service.UNKNOWN;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.3\n    private QuickServerConfig config \u003d new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel \u003d \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel \u003d \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation \u003d false;\n\n    private boolean communicationLogging \u003d true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig \u003d config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km \u003d null;\n\n    private TrustManager[] tm \u003d null;\n\n    private boolean runningSecure \u003d false;\n\n    private SecureStoreManager secureStoreManager \u003d null;\n\n    private Exception exceptionInRun \u003d null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode \u003d true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN \u003d DataMode.STRING;\n\n    private DataMode defaultDataModeOUT \u003d DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging \u003d false;\n\n    private int rawCommunicationMaxLength \u003d 100;\n\n    static {\n        System.out.println(\" Done\");\n        //should be commented if not a patch release\n        //System.out.println(\"[Includes patch(#): t\u003d152\u0026p\u003d532]\");\n        //should be commented if not a dev release\n        //System.out.println(\"[Dev Build Date: Saturday, October 29, 2005]\");\n        logger.log(Level.FINE, \"PID: {0}\", pid);\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion() {\n        return VER;\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo() {\n        return getVersionNo(VER);\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver) {\n        //String ver \u003d getVersion();\n        float version \u003d 0;\n        //check if beta\n        int i \u003d ver.indexOf(\" \");\n        if (i \u003d\u003d -1)\n            i \u003d ver.length();\n        ver \u003d ver.substring(0, i);\n        //check for sub version\n        i \u003d ver.indexOf(\".\");\n        if (i !\u003d -1) {\n            int j \u003d ver.indexOf(\".\", i);\n            if (j !\u003d -1) {\n                ver \u003d ver.substring(0, i) + \".\" + MyString.replaceAll(ver.substring(i + 1), \".\", \"\");\n            }\n        }\n        try {\n            version \u003d Float.parseFloat(ver);\n        } catch (NumberFormatException e) {\n            throw new RuntimeException(\"Corrupt QuickServer\");\n        }\n        return version;\n    }\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine() {\n        return NEW_LINE;\n    }\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString() {\n        return serverName + \" : \" + getPort();\n    }\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n        setClientCommandHandler(commandHandler);\n    }\n\n    /**\n     * Creates a new server at \u003ccode\u003eport\u003c/code\u003e with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n        //send to another constructor\n        this(commandHandler);\n        setPort(port);\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException {\n        logger.log(Level.FINE, \"Starting {0}\", getName());\n        if (isClosed() \u003d\u003d false) {\n            logger.log(Level.WARNING, \"Server {0} already running.\", getName());\n            throw new AppException(\"Server \" + getName() + \" already running.\");\n        }\n        blockingMode \u003d getBasicConfig().getServerMode().getBlocking();\n        if (getSecure().isEnable() \u0026\u0026 blockingMode \u003d\u003d false) {\n            //TODO we need to fix this..\n            logger.warning(\"QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode.\");\n            blockingMode \u003d true;\n            getBasicConfig().getServerMode().setBlocking(blockingMode);\n        }\n        if (serverBanner \u003d\u003d null) {\n            serverBanner \u003d \"\\n-------------------------------\" + \"\\n Name : \" + getName() + \"\\n Port : \" + getPort() + \"\\n-------------------------------\\n\";\n            logger.finest(\"Default Server Banner Generated\");\n        }\n        try {\n            loadApplicationClasses();\n            //load class from Advanced Settings\n            Class clientIdentifierClass \u003d getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);\n            clientIdentifier \u003d (ClientIdentifier) clientIdentifierClass.newInstance();\n            clientIdentifier.setQuickServer(QuickServer.this);\n            //load class from ObjectPoolConfig\n            Class poolManagerClass \u003d getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);\n            poolManager \u003d (PoolManager) poolManagerClass.newInstance();\n            //load class QSObjectPoolMaker\n            Class qsObjectPoolMakerClass \u003d getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);\n            qsObjectPoolMaker \u003d (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();\n            loadServerHooksClasses();\n            processServerHooks(ServerHook.PRE_STARTUP);\n            if (getSecure().isLoad() \u003d\u003d true)\n                //v1.4.0\n                loadSSLContext();\n            loadBusinessLogic();\n        } catch (ClassNotFoundException e) {\n            logger.log(Level.SEVERE, \"Could not load class/s: \" + e, e);\n            throw new AppException(\"Could not load class/s : \" + e);\n        } catch (InstantiationException e) {\n            logger.log(Level.SEVERE, \"Could not instantiate class/s: \" + e, e);\n            throw new AppException(\"Could not instantiate class/s: \" + e);\n        } catch (IllegalAccessException e) {\n            logger.log(Level.SEVERE, \"Illegal access to class/s: \" + e, e);\n            throw new AppException(\"Illegal access to class/s: \" + e);\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"IOException: \" + e, e);\n            throw new AppException(\"IOException: \" + e);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Exception: \" + e, e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Exception : \" + e);\n        }\n        //v1.3.3\n        if (getSecurityManagerClass() !\u003d null) {\n            System.setSecurityManager(getSecurityManager());\n        }\n        setServiceState(Service.INIT);\n        t \u003d new Thread(this, \"QuickServer - \" + getName());\n        t.start();\n        do {\n            Thread.yield();\n        } while (getServiceState() \u003d\u003d Service.INIT);\n        if (getServiceState() !\u003d Service.RUNNING) {\n            if (exceptionInRun !\u003d null)\n                throw new AppException(\"Could not start server \" + getName() + \"! Details: \" + exceptionInRun);\n            else\n                throw new AppException(\"Could not start server \" + getName());\n        }\n        lastStartTime \u003d new java.util.Date();\n        logger.log(Level.FINE, \"Started {0}, Date: {1}\", new Object[] { getName(), lastStartTime });\n    }\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException {\n        processServerHooks(ServerHook.PRE_SHUTDOWN);\n        logger.log(Level.WARNING, \"Stopping {0}\", getName());\n        stopServer \u003d true;\n        Socket death \u003d null;\n        if (isClosed() \u003d\u003d true) {\n            logger.log(Level.WARNING, \"Server {0} is not running!\", getName());\n            throw new AppException(\"Server \" + getName() + \" is not running!\");\n        }\n        try {\n            if (getBlockingMode() \u003d\u003d true) {\n                if (getSecure().isEnable() \u003d\u003d false) {\n                    death \u003d new Socket(server.getInetAddress(), server.getLocalPort());\n                    death.getInputStream().read();\n                    death.close();\n                } else {\n                    death \u003d getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());\n                    Thread.sleep(100);\n                    death.close();\n                }\n            }\n            if (serverSocketChannel !\u003d null) {\n                serverSocketChannel.close();\n            }\n        } catch (IOException e) {\n            logger.log(Level.FINE, \"IOError stopping {0}: {1}\", new Object[] { getName(), e });\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error stopping {0}: {1}\", new Object[] { getName(), e });\n            throw new AppException(\"Error in stopServer \" + getName() + \": \" + e);\n        }\n        for (int i \u003d 0; getServiceState() !\u003d Service.STOPPED; i++) {\n            try {\n                Thread.sleep(60);\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error waiting for {0} to fully stop. Error: {1}\", new Object[] { getName(), e });\n            }\n            if (i \u003e 1000) {\n                logger.severe(\"Server was not stopped even after 10sec.. will terminate now.\");\n                System.exit(-1);\n            }\n        }\n        if (adminServer \u003d\u003d null || getQSAdminServer().getServer() !\u003d this) {\n            //so this is not qsadmin\n            setClassLoader(null);\n        }\n        logger.log(Level.INFO, \"Stopped {0}\", getName());\n    }\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException {\n        stopServer();\n        startServer();\n    }\n\n    /**\n     * Returns the name of the QuickServer. Default is \u0027QuickServer\u0027.\n     * @see #setName\n     */\n    public String getName() {\n        return serverName;\n    }\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name) {\n        serverName \u003d name;\n        logger.log(Level.FINEST, \"Set to : {0}\", name);\n    }\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner() {\n        return serverBanner;\n    }\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. \u003cbr\u003e\u0026nbsp;\u003cbr\u003e\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner) {\n        serverBanner \u003d banner;\n        logger.log(Level.FINEST, \"Set to : {0}\", banner);\n    }\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port) {\n        if (port \u003c 0) {\n            throw new IllegalArgumentException(\"Port number can not be less than 0!\");\n        }\n        serverPort \u003d port;\n        logger.log(Level.FINEST, \"Set to {0}\", port);\n    }\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort() {\n        if (isClosed() \u003d\u003d false) {\n            return server.getLocalPort();\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            return serverPort;\n        } else {\n            int _port \u003d getSecure().getPort();\n            if (_port \u003d\u003d -1)\n                return serverPort;\n            else\n                return _port;\n        }\n    }\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler) {\n        clientCommandHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler() {\n        return clientCommandHandlerString;\n    }\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data) {\n        this.clientDataString \u003d data;\n        logger.log(Level.FINEST, \"Set to {0}\", data);\n    }\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData() {\n        return clientDataString;\n    }\n\n    /**\n     * Sets the client socket\u0027s timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time) {\n        if (time \u003e 0)\n            socketTimeout \u003d time;\n        else\n            socketTimeout \u003d 0;\n        logger.log(Level.FINEST, \"Set to {0}\", socketTimeout);\n    }\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout() {\n        return socketTimeout;\n    }\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry) {\n        maxAuthTry \u003d authTry;\n        logger.log(Level.FINEST, \"Set to {0}\", authTry);\n    }\n\n    /**\n     * Returns max allowed login attempts. Default is \u003ccode\u003e5\u003c/code\u003e.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry() {\n        return maxAuthTry;\n    }\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg) {\n        maxAuthTryMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg() {\n        return maxAuthTryMsg;\n    }\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg) {\n        timeoutMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg() {\n        return timeoutMsg;\n    }\n\n    private TheClient initTheClient() {\n        TheClient theClient \u003d new TheClient();\n        theClient.setServer(QuickServer.this);\n        theClient.setTimeoutMsg(getTimeoutMsg());\n        //v1.2\n        theClient.setMaxAuthTry(getMaxAuthTry());\n        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());\n        theClient.setClientEventHandler(clientEventHandler);\n        //v1.4.6\n        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);\n        theClient.setClientCommandHandler(clientCommandHandler);\n        //v1.2\n        theClient.setClientObjectHandler(clientObjectHandler);\n        //v1.4\n        theClient.setClientBinaryHandler(clientBinaryHandler);\n        //v1.4.5\n        theClient.setClientWriteHandler(clientWriteHandler);\n        //v1.3\n        theClient.setAuthenticator(authenticator);\n        //v1.4.6\n        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);\n        theClient.setTimeout(socketTimeout);\n        theClient.setMaxConnectionMsg(maxConnectionMsg);\n        //v1.3.2\n        theClient.setCommunicationLogging(getCommunicationLogging());\n        return theClient;\n    }\n\n    public void run() {\n        exceptionInRun \u003d null;\n        TheClient theClient \u003d initTheClient();\n        try {\n            stopServer \u003d false;\n            closeAllPools();\n            initAllPools();\n            makeServerSocket();\n            //print banner\n            System.out.println(serverBanner);\n            //v1.2\n            setServiceState(Service.RUNNING);\n            //v1.3.3\n            processServerHooks(ServerHook.POST_STARTUP);\n            if (getBlockingMode() \u003d\u003d false) {\n                runNonBlocking(theClient);\n                if (stopServer \u003d\u003d true) {\n                    logger.log(Level.FINEST, \"Closing selector for {0}\", getName());\n                    selector.close();\n                }\n                return;\n            } else {\n                runBlocking(theClient);\n            }\n        } catch (BindException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"{0} BindException for Port {1} @ {2} : {3}\", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });\n        } catch (javax.net.ssl.SSLException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"SSLException {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (IOException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"IOError {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (Exception e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"Error {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } finally {\n            if (getBlockingMode() \u003d\u003d true) {\n                logger.log(Level.WARNING, \"Closing {0}\", getName());\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            } else if (getBlockingMode() \u003d\u003d false \u0026\u0026 exceptionInRun !\u003d null) {\n                logger.log(Level.WARNING, \"Closing {0} - Had Error: {1}\", new Object[] { getName(), exceptionInRun });\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        if (serverSocketChannel !\u003d null)\n                            serverSocketChannel.close();\n                        if (server !\u003d null)\n                            server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n        }\n    }\n\n    //end of run\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnection \u003d maxConnection;\n        else\n            this.maxConnection \u003d maxConnection;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnection);\n    }\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection() {\n        return maxConnection;\n    }\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount() {\n        if (clientHandlerPool !\u003d null) {\n            try {\n                return getClientHandlerPool().getNumActive();\n            } catch (Exception e) {\n                return 0;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : \u003ccode\u003e-ERR Server Busy. Max Connection Reached\u003c/code\u003e\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n        else\n            this.maxConnectionMsg \u003d maxConnectionMsg;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnectionMsg);\n    }\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg() {\n        return maxConnectionMsg;\n    }\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException {\n        ipAddr \u003d InetAddress.getByName(bindAddr);\n        logger.log(Level.FINEST, \"Set to {0}\", bindAddr);\n    }\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr() {\n        if (ipAddr \u003d\u003d null) {\n            try {\n                ipAddr \u003d InetAddress.getByName(\"0.0.0.0\");\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Unable to create default ip(0.0.0.0) : {0}\", e);\n                throw new RuntimeException(\"Error: Unable to find servers own ip : \" + e);\n            }\n        }\n        return ipAddr;\n    }\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects) {\n        this.storeObjects \u003d storeObjects;\n    }\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return \u003ccode\u003enull\u003c/code\u003e.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects() {\n        return storeObjects;\n    }\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port) {\n        getQSAdminServer().getServer().setPort(port);\n    }\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort() {\n        return getQSAdminServer().getServer().getPort();\n    }\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator) {\n        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);\n    }\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator() {\n        return getQSAdminServer().getServer().getAuthenticator();\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException {\n        getQSAdminServer().setClientAuthenticationHandler(authenticator);\n        getQSAdminServer().startServer(port);\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException {\n        getQSAdminServer().startServer();\n    }\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer() {\n        if (adminServer \u003d\u003d null)\n            adminServer \u003d new QSAdminServer(QuickServer.this);\n        return adminServer;\n    }\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer) {\n        if (adminServer \u003d\u003d null)\n            this.adminServer \u003d adminServer;\n    }\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed() {\n        if (server \u003d\u003d null)\n            return true;\n        return server.isClosed();\n    }\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer\u0027s own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger() {\n        if (appLogger !\u003d null)\n            return appLogger;\n        return logger;\n    }\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger) {\n        this.appLogger \u003d appLogger;\n    }\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler) {\n        clientObjectHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler() {\n        return clientObjectHandlerString;\n    }\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n        if (formatter \u003d\u003d null)\n            return;\n        consoleLoggingformatter \u003d formatter;\n        java.util.logging.Formatter conformatter \u003d (java.util.logging.Formatter) getClass(formatter, true).newInstance();\n        Logger jdkLogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d jdkLogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                handlers[index].setFormatter(conformatter);\n            }\n        }\n        logger.log(Level.FINEST, \"Set to {0}\", formatter);\n    }\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter() {\n        return consoleLoggingformatter;\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MiniFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to logging.MiniFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MicroFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to MicroFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        boolean isConsole \u003d true;\n        try {\n            if (System.console() \u003d\u003d null) {\n                isConsole \u003d false;\n            }\n        } catch (Throwable e) {\n            //ignore\n        }\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                if (isConsole \u003d\u003d false \u0026\u0026 level !\u003d Level.OFF) {\n                    System.out.println(\"QuickServer: You do not have a console.. so turning console logger off..\");\n                    level \u003d Level.OFF;\n                }\n                if (level \u003d\u003d Level.OFF) {\n                    logger.info(\"QuickServer: Removing console handler.. \");\n                    rlogger.removeHandler(handlers[index]);\n                    handlers[index].setLevel(level);\n                    handlers[index].close();\n                } else {\n                    handlers[index].setLevel(level);\n                }\n            }\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            consoleLoggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            consoleLoggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            consoleLoggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            consoleLoggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            consoleLoggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            consoleLoggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            consoleLoggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            consoleLoggingLevel \u003d \"OFF\";\n        else\n            consoleLoggingLevel \u003d \"UNKNOWN\";\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel() {\n        return consoleLoggingLevel;\n    }\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            handlers[index].setLevel(level);\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            loggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            loggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            loggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            loggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            loggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            loggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            loggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            loggingLevel \u003d \"OFF\";\n        else\n            loggingLevel \u003d \"UNKNOWN\";\n        consoleLoggingLevel \u003d loggingLevel;\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    //*** Start of Service interface methods\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError() {\n        return serviceError;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param) {\n        serviceError \u003d null;\n        try {\n            initServer(param);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig) {\n        serviceError \u003d null;\n        try {\n            initServer(qsConfig);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING)\n            return false;\n        try {\n            startServer();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.STOPPED)\n            return false;\n        try {\n            stopServer();\n            clearAllPools();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING) {\n            suspendMaxConnection \u003d maxConnection;\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n            maxConnection \u003d 0;\n            maxConnectionMsg \u003d \"Service is suspended.\";\n            setServiceState(Service.SUSPENDED);\n            logger.log(Level.INFO, \"Service {0} is suspended.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.SUSPENDED) {\n            maxConnection \u003d suspendMaxConnection;\n            maxConnectionMsg \u003d suspendMaxConnectionMsg;\n            setServiceState(Service.RUNNING);\n            logger.log(Level.INFO, \"Service {0} resumed.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info() {\n        serviceError \u003d null;\n        StringBuilder buf \u003d new StringBuilder();\n        buf.append(getName()).append(\"\\n\");\n        buf.append(getBindAddr().getHostAddress()).append(\" \");\n        buf.append(getPort()).append(\"\\n\");\n        return buf.toString();\n    }\n\n    // *** End of Service interface methods\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException {\n        QuickServerConfig qsConfig \u003d null;\n        try {\n            qsConfig \u003d ConfigReader.read((String) param[0]);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not init server from xml file {0} : {1}\", new Object[] { new File((String) param[0]).getAbsolutePath(), e });\n            throw new AppException(\"Could not init server from xml file\", e);\n        }\n        initServer(qsConfig);\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {\n        setConfig(qsConfig);\n        try {\n            configQuickServer();\n            loadApplicationClasses();\n            //start InitServerHooks\n            InitServerHooks ish \u003d getConfig().getInitServerHooks();\n            if (ish !\u003d null) {\n                Iterator iterator \u003d ish.iterator();\n                String initServerHookClassName \u003d null;\n                Class initServerHookClass \u003d null;\n                InitServerHook initServerHook \u003d null;\n                while (iterator.hasNext()) {\n                    initServerHookClassName \u003d (String) iterator.next();\n                    initServerHookClass \u003d getClass(initServerHookClassName, true);\n                    initServerHook \u003d (InitServerHook) initServerHookClass.newInstance();\n                    logger.log(Level.INFO, \"Loaded init server hook: {0}\", initServerHookClassName);\n                    logger.log(Level.FINE, \"Init server hook info: {0}\", initServerHook.info());\n                    initServerHook.handleInit(QuickServer.this);\n                }\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not load init server hook: {0}\", e);\n            logger.log(Level.WARNING, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Could not load init server hook\", e);\n        }\n        setServiceState(Service.INIT);\n        logger.log(Level.FINEST, \"\\r\\n{0}\", MyString.getSystemInfo(getVersion()));\n    }\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState() {\n        return serviceState;\n    }\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state) {\n        serviceState \u003d state;\n    }\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp) {\n        if (temp.equals(\"SEVERE\"))\n            qs.setConsoleLoggingLevel(Level.SEVERE);\n        else if (temp.equals(\"WARNING\"))\n            qs.setConsoleLoggingLevel(Level.WARNING);\n        else if (temp.equals(\"INFO\"))\n            qs.setConsoleLoggingLevel(Level.INFO);\n        else if (temp.equals(\"CONFIG\"))\n            qs.setConsoleLoggingLevel(Level.CONFIG);\n        else if (temp.equals(\"FINE\"))\n            qs.setConsoleLoggingLevel(Level.FINE);\n        else if (temp.equals(\"FINER\"))\n            qs.setConsoleLoggingLevel(Level.FINER);\n        else if (temp.equals(\"FINEST\"))\n            qs.setConsoleLoggingLevel(Level.FINEST);\n        else if (temp.equals(\"OFF\"))\n            qs.setConsoleLoggingLevel(Level.OFF);\n        else\n            logger.log(Level.WARNING, \"unknown level {0}\", temp);\n    }\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception {\n        QuickServer qs \u003d QuickServer.this;\n        //v1.3\n        qs.setConfig(config);\n        qs.setBasicConfig(config);\n        String temp \u003d config.getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        temp \u003d null;\n        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        //v1.3.3\n        qs.setSecurityManagerClass(config.getSecurityManagerClass());\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        temp \u003d config.getApplicationJarPath();\n        if (temp !\u003d null) {\n            File ajp \u003d new File(temp);\n            if (ajp.isAbsolute() \u003d\u003d false) {\n                temp \u003d config.getConfigFile();\n                ajp \u003d new File(temp);\n                temp \u003d ajp.getParent() + File.separatorChar + config.getApplicationJarPath();\n                config.setApplicationJarPath(temp);\n                temp \u003d null;\n            }\n            qs.setApplicationJarPath(config.getApplicationJarPath());\n            //set path also to QSAdmin\n            if (config.getQSAdminServerConfig() !\u003d null) {\n                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());\n            }\n        }\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception {\n        QuickServer qs \u003d getQSAdminServer().getServer();\n        qs.setBasicConfig(config);\n        //set the Logging Level to same as main QS\n        //config.getConsoleLoggingLevel();\n        String temp \u003d getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        //set the Logging Formatter to same as main QS\n        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());\n        //v1.4.6\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        //v1.4.6\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());\n        //v1.3.2\n        if (config.getCommandShellEnable().equals(\"true\"))\n            getQSAdminServer().setShellEnable(true);\n        getQSAdminServer().setPromptName(config.getCommandShellPromptName());\n        //v1.3.3\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception {\n        configQuickServer(getConfig());\n        if (getConfig().getQSAdminServerConfig() !\u003d null) {\n            configQuickServer(getConfig().getQSAdminServerConfig());\n        }\n    }\n\n    /**\n     * Usage: QuickServer [-options]\u003cbr/\u003e\n     * Where options include:\u003cbr/\u003e\n     *   -about\t\tOpens About Dialogbox\u003cbr/\u003e\n     *   -load \u003cxml_config_file\u003e [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File \u003cnew_file_name\u003e\n     */\n    public static void main(String[] args) {\n        try {\n            if (args.length \u003e\u003d 1) {\n                if (args[0].equals(\"-about\")) {\n                    org.quickserver.net.server.gui.About.main(null);\n                } else if (args[0].equals(\"-load\") \u0026\u0026 args.length \u003e\u003d 2) {\n                    QuickServer qs \u003d QuickServer.load(args[1]);\n                    if (qs !\u003d null)\n                        handleOptions(args, qs);\n                } else {\n                    System.out.println(printUsage());\n                }\n            } else {\n                System.out.println(printUsage());\n                org.quickserver.net.server.gui.About.showAbout();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException {\n        QuickServer qs \u003d new QuickServer();\n        Object[] config \u003d new Object[] { xml };\n        qs.initServer(config);\n        qs.startServer();\n        if (qs.getConfig().getQSAdminServerConfig() !\u003d null) {\n            qs.startQSAdminServer();\n        }\n        return qs;\n    }\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage() {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"QuickServer - Java library/framework for creating robust multi-client TCP servers.\\n\");\n        sb.append(\"Copyright (C) QuickServer.org\\n\\n\");\n        sb.append(\"Usage: QuickServer [-options]\\n\");\n        sb.append(\"Where options include:\\n\");\n        sb.append(\"  -about\\t\" + \"Opens About Dialog box\\n\");\n        sb.append(\"  -load \u003cxml_config_file\u003e [load-options]\\t\" + \"Loads the server from xml file.\\n\");\n        sb.append(\"  Where load-options include:\\n\");\n        sb.append(\"     -fullXML2File \u003cfile_name\u003e\\t\" + \"Dumps the Full XML configuration of the QuickServer loaded.\\n\");\n        return sb.toString();\n    }\n\n    private static void handleOptions(String[] args, QuickServer quickserver) {\n        if (args.length \u003c 3)\n            return;\n        if (args[2].equals(\"-fullXML2File\") \u0026\u0026 args.length \u003e\u003d 4) {\n            File file \u003d new File(args[3]);\n            logger.log(Level.INFO, \"Writing full xml configuration to file: {0}\", file.getAbsolutePath());\n            try {\n                TextFile.write(file, quickserver.getConfig().toXML(null));\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error writing full xml configuration: {0}\", e);\n            }\n        }\n    }\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception {\n        try {\n            if (pool !\u003d null)\n                getClientPool().clear();\n            if (clientHandlerPool !\u003d null)\n                getClientHandlerPool().clear();\n            if (getClientDataPool() !\u003d null)\n                getClientDataPool().clear();\n            if (getDBPoolUtil() !\u003d null)\n                getDBPoolUtil().clean();\n            if (byteBufferPool !\u003d null)\n                getByteBufferPool().clear();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error: {0}\", e);\n            throw e;\n        }\n    }\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception {\n        if (pool \u003d\u003d null \u0026\u0026 clientHandlerPool \u003d\u003d null \u0026\u0026 getClientDataPool() \u003d\u003d null \u0026\u0026 getDBPoolUtil() \u003d\u003d null \u0026\u0026 byteBufferPool \u003d\u003d null) {\n            return;\n        }\n        logger.log(Level.FINE, \"Closing pools for {0}\", getName());\n        try {\n            if (pool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {\n                logger.finer(\"Closing ClientThread pool.\");\n                getClientPool().close();\n            }\n            if (clientHandlerPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientHandlerPool())) {\n                logger.finer(\"Closing ClientHandler pool.\");\n                getClientHandlerPool().close();\n            }\n            if (getClientDataPool() !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientDataPool())) {\n                logger.finer(\"Closing ClientData pool.\");\n                getClientDataPool().close();\n            }\n            if (getDBPoolUtil() !\u003d null) {\n                logger.finer(\"Closing DB pool.\");\n                getDBPoolUtil().clean();\n            }\n            if (byteBufferPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getByteBufferPool())) {\n                logger.finer(\"Closing ByteBuffer pool.\");\n                getByteBufferPool().close();\n            }\n            logger.log(Level.FINE, \"Closed pools for {0}\", getName());\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error closing pools for {0}: {1}\", new Object[] { getName(), e });\n            throw e;\n        }\n    }\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception {\n        logger.fine(\"Creating pools\");\n        if (getBlockingMode() \u003d\u003d false) {\n            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());\n        }\n        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());\n        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());\n        //check if client data is poolable\n        if (clientDataClass !\u003d null) {\n            try {\n                clientData \u003d (ClientData) clientDataClass.newInstance();\n                if (PoolableObject.class.isInstance(clientData) \u003d\u003d true) {\n                    PoolableObject po \u003d (PoolableObject) clientData;\n                    if (po.isPoolable() \u003d\u003d true) {\n                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());\n                    } else {\n                        clientDataPool \u003d null;\n                        logger.fine(\"ClientData is not poolable!\");\n                    }\n                }\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error: {0}\", e);\n                throw e;\n            }\n        }\n        try {\n            makeDBObjectPool();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error in makeDBObjectPool() : {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw e;\n        }\n        logger.fine(\"Created pools\");\n    }\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool() {\n        if (pool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientPool available yet!\");\n        return pool;\n    }\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientHandler pool\");\n        PoolableObjectFactory factory \u003d new ClientHandlerObjectFactory(getBlockingMode());\n        clientHandlerPool \u003d poolManager.makeClientHandlerPool(factory, opConfig);\n        poolManager.initPool(clientHandlerPool, opConfig);\n        clientHandlerPool \u003d makeQSObjectPool(clientHandlerPool);\n        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool() {\n        if (clientHandlerPool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientHandler Pool available yet!\");\n        return clientHandlerPool;\n    }\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config) {\n        this.config \u003d config;\n    }\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig() {\n        return config;\n    }\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientData pool\");\n        clientDataPool \u003d poolManager.makeClientDataPool(factory, opConfig);\n        poolManager.initPool(clientDataPool, opConfig);\n        clientDataPool \u003d makeQSObjectPool(clientDataPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool() {\n        return clientDataPool;\n    }\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return \u003ccode\u003enull\u003c/code\u003e\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil() {\n        return dBPoolUtil;\n    }\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {\n        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);\n    }\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception {\n        if (getConfig().getDBObjectPoolConfig() !\u003d null) {\n            logger.fine(\"Creating DBObject Pool\");\n            //logger.finest(\"Got:\\n\"+getConfig().getDBObjectPoolConfig().toXML(null));\n            Class dbPoolUtilClass \u003d getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);\n            dBPoolUtil \u003d (DBPoolUtil) dbPoolUtilClass.newInstance();\n            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());\n            dBPoolUtil.initPool();\n        }\n    }\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id) {\n        return clientIdentifier.findFirstClientById(id);\n    }\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  \u003ccode\u003e\u003cpre\u003e\n     *    Eg:\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tObject syncObj \u003d quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator \u003d quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tClientIdentifier clientIdentifier \u003d quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator \u003d clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    \u003c/code\u003e\u003c/pre\u003e\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient() {\n        return clientIdentifier.findAllClient();\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern) {\n        return clientIdentifier.findAllClientById(pattern);\n    }\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key) {\n        return clientIdentifier.findClientByKey(key);\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern) {\n        return clientIdentifier.findAllClientByKey(pattern);\n    }\n\n    /**\n     * Sets next client has a trusted client.\n     * \u003cp\u003eThis will skip any authentication and will not set any timeout.\u003c/p\u003e\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted() {\n        setSkipValidation(true);\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation() {\n        return skipValidation;\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation) {\n        skipValidation \u003d validation;\n    }\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging) {\n        this.communicationLogging \u003d communicationLogging;\n    }\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging() {\n        return communicationLogging;\n    }\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass) {\n        if (securityManagerClass !\u003d null)\n            this.securityManagerClass \u003d securityManagerClass;\n    }\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass() {\n        return securityManagerClass;\n    }\n\n    public SecurityManager getSecurityManager() throws AppException {\n        if (getSecurityManagerClass() \u003d\u003d null)\n            return null;\n        SecurityManager sm \u003d null;\n        try {\n            sm \u003d (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();\n        } catch (ClassNotFoundException e) {\n            throw new AppException(e.getMessage());\n        } catch (InstantiationException e) {\n            throw new AppException(e.getMessage());\n        } catch (IllegalAccessException e) {\n            throw new AppException(e.getMessage());\n        }\n        return sm;\n    }\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {\n        this.accessConstraintConfig \u003d accessConstraintConfig;\n    }\n\n    /**\n     * Returns Access constraints if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig() {\n        return accessConstraintConfig;\n    }\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader) {\n        this.classLoader \u003d classLoader;\n        Thread.currentThread().setContextClassLoader(classLoader);\n    }\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader() {\n        return classLoader;\n    }\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException {\n        if (name \u003d\u003d null)\n            throw new IllegalArgumentException(\"Class name can\u0027t be null!\");\n        logger.log(Level.FINEST, \"Class: {0}, reload: {1}\", new Object[] { name, reload });\n        if (reload \u003d\u003d true \u0026\u0026 classLoader !\u003d null) {\n            return classLoader.loadClass(name);\n        } else if (reload \u003d\u003d true \u0026\u0026 classLoader \u003d\u003d null \u0026\u0026 this.getClass().getClassLoader() !\u003d null) {\n            return this.getClass().getClassLoader().loadClass(name);\n        } else if (reload \u003d\u003d false \u0026\u0026 classLoader !\u003d null) {\n            return Class.forName(name, true, classLoader);\n        } else /*if(reload\u003d\u003dfalse \u0026\u0026 classLoader\u003d\u003dnull)*/\n        {\n            return Class.forName(name, true, this.getClass().getClassLoader());\n        }\n    }\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath) {\n        this.applicationJarPath \u003d applicationJarPath;\n    }\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath() {\n        return applicationJarPath;\n    }\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks) {\n        this.serverHooks \u003d serverHooks;\n    }\n\n    /**\n     * Returns ServerHooks if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks() {\n        if (serverHooks \u003d\u003d null)\n            serverHooks \u003d new ServerHooks();\n        return serverHooks;\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses() {\n        if (getServerHooks() \u003d\u003d null)\n            return;\n        listOfServerHooks \u003d new ArrayList();\n        ServerHook serverHook \u003d null;\n        String serverHookClassName \u003d null;\n        Class serverHookClass \u003d null;\n        //add system hooks\n        serverHook \u003d new GhostSocketReaper();\n        serverHook.initHook(QuickServer.this);\n        listOfServerHooks.add(serverHook);\n        ghostSocketReaper \u003d (GhostSocketReaper) serverHook;\n        //add user hooks if any\n        Iterator iterator \u003d getServerHooks().iterator();\n        while (iterator.hasNext()) {\n            serverHookClassName \u003d (String) iterator.next();\n            try {\n                serverHookClass \u003d getClass(serverHookClassName, true);\n                serverHook \u003d (ServerHook) serverHookClass.newInstance();\n                serverHook.initHook(QuickServer.this);\n                listOfServerHooks.add(serverHook);\n                logger.log(Level.INFO, \"Loaded server hook: {0}\", serverHookClassName);\n                logger.log(Level.FINE, \"Server hook info: {0}\", serverHook.info());\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Could not load server hook [{0}]: {1}\", new Object[] { serverHookClassName, e });\n                logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            }\n        }\n        //end of while\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event) {\n        if (listOfServerHooks \u003d\u003d null) {\n            logger.warning(\"listOfServerHooks was null!\");\n            return;\n        }\n        ServerHook serverHook \u003d null;\n        boolean result \u003d false;\n        Iterator iterator \u003d listOfServerHooks.iterator();\n        String hooktype \u003d \"UNKNOWN\";\n        switch(event) {\n            case ServerHook.PRE_STARTUP:\n                hooktype \u003d \"PRE_STARTUP\";\n                break;\n            case ServerHook.POST_STARTUP:\n                hooktype \u003d \"POST_STARTUP\";\n                break;\n            case ServerHook.PRE_SHUTDOWN:\n                hooktype \u003d \"PRE_SHUTDOWN\";\n                break;\n            case ServerHook.POST_SHUTDOWN:\n                hooktype \u003d \"POST_SHUTDOWN\";\n                break;\n        }\n        while (iterator.hasNext()) {\n            serverHook \u003d (ServerHook) iterator.next();\n            try {\n                result \u003d serverHook.handleEvent(event);\n            } catch (Exception e) {\n                result \u003d false;\n                logger.log(Level.WARNING, \"Error invoking {0} hook [{1}]: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });\n            }\n            logger.log(Level.FINE, \"Invoked {0} hook [{1}] was: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), result });\n        }\n    }\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone() {\n        Object object \u003d null;\n        try {\n            object \u003d super.clone();\n            QuickServer _qs \u003d (QuickServer) object;\n            _qs.setQSAdminServer(new QSAdminServer(_qs));\n        } catch (CloneNotSupportedException e) {\n            //should not happ\n            logger.log(Level.WARNING, \"Error cloning : {0}\", e);\n        }\n        return object;\n    }\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure) {\n        this.secure \u003d secure;\n    }\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure() {\n        if (secure \u003d\u003d null)\n            secure \u003d new Secure();\n        return secure;\n    }\n\n    /**\n     * \u003cp\u003eReturns if the server is running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure() {\n        return runningSecure;\n    }\n\n    /**\n     * \u003cp\u003eSets the server mode if its running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure) {\n        this.runningSecure \u003d runningSecure;\n    }\n\n    private File makeAbsoluteToConfig(String fileName) {\n        Assertion.affirm(fileName !\u003d null, \"FileName can\u0027t be null\");\n        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());\n    }\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException {\n        server \u003d null;\n        logger.log(Level.FINEST, \"Binding {0} to IP: {1}\", new Object[] { getName(), getBindAddr() });\n        InetSocketAddress bindAddress \u003d new InetSocketAddress(getBindAddr(), getPort());\n        try {\n            NetworkInterface ni \u003d NetworkInterface.getByInetAddress(getBindAddr());\n            if (ni !\u003d null) {\n                logger.fine(\"NetworkInterface: \" + ni);\n            }\n        } catch (Exception igrnore) {\n            /*ignore*/\n        } catch (Error igrnore) {\n            /*ignore*/\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Making a normal ServerSocket for {0}\", getName());\n            setRunningSecure(false);\n            if (getBlockingMode() \u003d\u003d false) {\n                //for non-blocking\n                serverSocketChannel \u003d ServerSocketChannel.open();\n                server \u003d serverSocketChannel.socket();\n                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n            } else {\n                //for blocking\n                server \u003d new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n            }\n        } else {\n            try {\n                logger.log(Level.FINE, \"Making a secure ServerSocket for {0}\", getName());\n                getSSLContext();\n                setRunningSecure(true);\n                if (getBlockingMode() \u003d\u003d false) {\n                    logger.log(Level.FINE, \"Making a secure ServerSocketChannel for {0}\", getName());\n                    //for non-blocking\n                    serverSocketChannel \u003d ServerSocketChannel.open();\n                    server \u003d serverSocketChannel.socket();\n                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n                } else {\n                    ServerSocketFactory ssf \u003d getSSLContext().getServerSocketFactory();\n                    SSLServerSocket serversocket \u003d (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());\n                    setRunningSecure(true);\n                    secureStoreManager.logSSLServerSocketInfo(serversocket);\n                    server \u003d serversocket;\n                    serverSocketChannel \u003d server.getChannel();\n                    if (serverSocketChannel \u003d\u003d null \u0026\u0026 getBlockingMode() \u003d\u003d false) {\n                        logger.warning(\"Secure Server does not support Channel! So will run in blocking mode.\");\n                        blockingMode \u003d false;\n                    }\n                }\n                //blocking\n            } catch (NoSuchAlgorithmException e) {\n                logger.log(Level.WARNING, \"NoSuchAlgorithmException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            } catch (KeyManagementException e) {\n                logger.log(Level.WARNING, \"KeyManagementException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            }\n        }\n        server.setReuseAddress(true);\n        int connectionTime \u003d 0;\n        int latency \u003d 0;\n        int bandwidth \u003d 0;\n        connectionTime \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();\n        latency \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();\n        bandwidth \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();\n        logger.log(Level.FINE, \"getPerformancePreferencesConnectionTime : {0}\", connectionTime);\n        logger.log(Level.FINE, \"getPerformancePreferencesLatency : {0}\", latency);\n        logger.log(Level.FINE, \"getPerformancePreferencesBandwidth : {0}\", bandwidth);\n        server.setPerformancePreferences(connectionTime, latency, bandwidth);\n        int clientSocketReceiveBufferSize \u003d getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();\n        if (clientSocketReceiveBufferSize \u003e 0) {\n            logger.log(Level.FINE, \"clientSocketReceiveBufferSize: {0}\", clientSocketReceiveBufferSize);\n            server.setReceiveBufferSize(clientSocketReceiveBufferSize);\n        }\n        if (getBlockingMode() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Server Mode {0} - Non Blocking\", getName());\n            if (selector \u003d\u003d null || selector.isOpen() \u003d\u003d false) {\n                logger.finest(\"Opening new selector\");\n                selector \u003d Selector.open();\n            } else {\n                logger.log(Level.FINEST, \"Reusing selector: {0}\", selector);\n            }\n            serverSocketChannel.configureBlocking(false);\n            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n            selector.wakeup();\n        } else {\n            logger.log(Level.FINE, \"Server Mode {0} - Blocking\", getName());\n        }\n    }\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {\n        Assertion.affirm(basicConfig !\u003d null, \"BasicServerConfig can\u0027t be null\");\n        this.basicConfig \u003d basicConfig;\n    }\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig() {\n        return basicConfig;\n    }\n\n    /**\n     * Loads the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException {\n        if (getSecure().isLoad() \u003d\u003d false) {\n            throw new IllegalStateException(\"Secure setting is not yet enabled for loading!\");\n        }\n        logger.info(\"Loading Secure Context..\");\n        km \u003d null;\n        tm \u003d null;\n        try {\n            String ssManager \u003d \"org.quickserver.security.SecureStoreManager\";\n            if (getSecure().getSecureStore() !\u003d null)\n                ssManager \u003d getSecure().getSecureStore().getSecureStoreManager();\n            Class secureStoreManagerClass \u003d getClass(ssManager, true);\n            secureStoreManager \u003d (SecureStoreManager) secureStoreManagerClass.newInstance();\n            km \u003d secureStoreManager.loadKeyManagers(getConfig());\n            logger.fine(\"KeyManager got\");\n            tm \u003d secureStoreManager.loadTrustManagers(getConfig());\n            logger.fine(\"TrustManager got\");\n            sslc \u003d secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());\n            sslc.init(km, tm, null);\n            logger.fine(\"SSLContext loaded\");\n        } catch (KeyStoreException e) {\n            logger.warning(\"KeyStoreException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchAlgorithmException e) {\n            logger.warning(\"NoSuchAlgorithmException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchProviderException e) {\n            logger.warning(\"NoSuchProviderException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (UnrecoverableKeyException e) {\n            logger.warning(\"UnrecoverableKeyException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (CertificateException e) {\n            logger.warning(\"CertificateException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (KeyManagementException e) {\n            logger.warning(\"KeyManagementException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (GeneralSecurityException e) {\n            logger.warning(\"GeneralSecurityException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (ClassNotFoundException e) {\n            logger.warning(\"ClassNotFoundException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (InstantiationException e) {\n            logger.warning(\"InstantiationException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (IllegalAccessException e) {\n            logger.warning(\"IllegalAccessException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        return getSSLContext(null);\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        if (protocol !\u003d null \u0026\u0026 secureStoreManager !\u003d null) {\n            SSLContext _sslc \u003d secureStoreManager.getSSLContext(protocol);\n            _sslc.init(km, tm, null);\n            return _sslc;\n        }\n        return sslc;\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext());\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext(protocol));\n    }\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler) {\n        clientBinaryHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler() {\n        return clientBinaryHandlerString;\n    }\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector) {\n        this.selector \u003d selector;\n    }\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector() {\n        return selector;\n    }\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception {\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        //long stime \u003d System.currentTimeMillis();\n        //long etime \u003d System.currentTimeMillis();\n        while (true) {\n            //etime \u003d System.currentTimeMillis();\n            //System.out.println(\"Time Taken: \"+(etime-stime));\n            client \u003d server.accept();\n            //stime \u003d System.currentTimeMillis();\n            if (linger \u003c 0) {\n                client.setSoLinger(false, 0);\n            } else {\n                client.setSoLinger(true, linger);\n            }\n            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                //low delay\u003d10\n                client.setTrafficClass(socketTrafficClass);\n            }\n            logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n            }\n            if (stopServer) {\n                //Client connected when server was about to be shutdown.\n                try {\n                    client.close();\n                } catch (Exception e) {\n                }\n                break;\n            }\n            if (checkAccessConstraint(client) \u003d\u003d false) {\n                continue;\n            }\n            //Check if max connection has reached\n            if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);\n            } else {\n                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);\n            }\n            theClient.setTrusted(getSkipValidation());\n            theClient.setSocket(client);\n            //mostly null\n            theClient.setSocketChannel(client.getChannel());\n            if (clientDataClass !\u003d null) {\n                if (getClientDataPool() \u003d\u003d null) {\n                    clientData \u003d (ClientData) clientDataClass.newInstance();\n                } else {\n                    clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                }\n                theClient.setClientData(clientData);\n            }\n            try {\n                _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                _chPolled.handleClient(theClient);\n            } catch (java.util.NoSuchElementException nsee) {\n                logger.warning(\"Could not borrow ClientHandler from pool. Error: \" + nsee);\n                logger.warning(\"Closing Socket [\" + client + \"] since no ClientHandler available.\");\n                client.close();\n            }\n            if (_chPolled !\u003d null) {\n                try {\n                    getClientPool().addClient(_chPolled, true);\n                } catch (java.util.NoSuchElementException nsee) {\n                    logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                    //logger.warning(\"Closing Socket [\"+client+\"] since no Thread available.\");\n                    //client.close();\n                    //returnClientHandlerToPool(_chPolled);\n                }\n                _chPolled \u003d null;\n            }\n            client \u003d null;\n            //reset it back\n            setSkipValidation(false);\n        }\n        //end of loop\n    }\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception {\n        int selectCount \u003d 0;\n        Iterator iterator \u003d null;\n        SelectionKey key \u003d null;\n        ServerSocketChannel serverChannel \u003d null;\n        SocketChannel socketChannel \u003d null;\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        boolean stopServerProcessed \u003d false;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        registerChannelRequestMap \u003d new HashMap();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        while (true) {\n            selectCount \u003d selector.select(500);\n            //selectCount \u003d selector.select();//for testing\n            //check for any pending registerChannel req.\n            synchronized (registerChannelRequestMap) {\n                if (registerChannelRequestMap.size() \u003e 0) {\n                    RegisterChannelRequest req \u003d null;\n                    Object hashkey \u003d null;\n                    iterator \u003d registerChannelRequestMap.keySet().iterator();\n                    while (iterator.hasNext()) {\n                        hashkey \u003d iterator.next();\n                        req \u003d (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);\n                        req.register(getSelector());\n                    }\n                    iterator \u003d null;\n                    registerChannelRequestMap.clear();\n                }\n                //if\n            }\n            //sync\n            if (stopServer \u003d\u003d true \u0026\u0026 stopServerProcessed \u003d\u003d false) {\n                logger.warning(\"Closing \" + getName());\n                serverSocketChannel.close();\n                stopServerProcessed \u003d true;\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.warning(\"Closed \" + getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n            if (stopServer \u003d\u003d false \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                logger.finest(\"Server must have re-started.. will break\");\n                break;\n            }\n            if (selectCount \u003d\u003d 0 \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                java.util.Set keyset \u003d selector.keys();\n                if (keyset.isEmpty() \u003d\u003d true \u0026\u0026 getClientCount() \u003c\u003d 0) {\n                    break;\n                } else {\n                    continue;\n                }\n            } else if (selectCount \u003d\u003d 0) {\n                continue;\n            }\n            iterator \u003d selector.selectedKeys().iterator();\n            while (iterator.hasNext()) {\n                key \u003d (SelectionKey) iterator.next();\n                if (key.isValid() \u003d\u003d false) {\n                    iterator.remove();\n                    continue;\n                }\n                if (key.isAcceptable() \u0026\u0026 stopServer \u003d\u003d false) {\n                    logger.finest(\"Key is Acceptable\");\n                    serverChannel \u003d (ServerSocketChannel) key.channel();\n                    socketChannel \u003d serverChannel.accept();\n                    if (socketChannel \u003d\u003d null) {\n                        iterator.remove();\n                        continue;\n                    }\n                    client \u003d socketChannel.socket();\n                    if (linger \u003c 0) {\n                        client.setSoLinger(false, 0);\n                    } else {\n                        client.setSoLinger(true, linger);\n                    }\n                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                        //low delay\u003d10\n                        client.setTrafficClass(socketTrafficClass);\n                    }\n                    logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                        logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n                    }\n                    if (checkAccessConstraint(client) \u003d\u003d false) {\n                        iterator.remove();\n                        continue;\n                    }\n                    socketChannel.configureBlocking(false);\n                    theClient.setTrusted(getSkipValidation());\n                    theClient.setSocket(socketChannel.socket());\n                    theClient.setSocketChannel(socketChannel);\n                    if (clientDataClass !\u003d null) {\n                        if (getClientDataPool() \u003d\u003d null) {\n                            clientData \u003d (ClientData) clientDataClass.newInstance();\n                        } else {\n                            //borrow a object from pool\n                            clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                        }\n                        theClient.setClientData(clientData);\n                    }\n                    //Check if max connection has reached\n                    if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                        theClient.setClientEvent(ClientEvent.MAX_CON);\n                    } else {\n                        theClient.setClientEvent(ClientEvent.ACCEPT);\n                    }\n                    try {\n                        _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                        logger.finest(\"Asking \" + _chPolled.getName() + \" to handle.\");\n                        _chPolled.handleClient(theClient);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.warning(\"Could not borrow ClientHandler Object from pool. Error: \" + nsee);\n                        logger.warning(\"Closing SocketChannel [\" + serverChannel.socket() + \"] since no ClientHandler available.\");\n                        socketChannel.close();\n                    }\n                    if (_chPolled !\u003d null) {\n                        try {\n                            getClientPool().addClient(_chPolled, true);\n                        } catch (java.util.NoSuchElementException nsee) {\n                            logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                            //logger.warning(\"Closing SocketChannel [\"+serverChannel.socket()+\"] since no Thread available.\");\n                            //socketChannel.close();\n                            //returnClientHandlerToPool(_chPolled);\n                        }\n                        _chPolled \u003d null;\n                    }\n                    socketChannel \u003d null;\n                    client \u003d null;\n                    //reset it back\n                    setSkipValidation(false);\n                } else if (key.isValid() \u0026\u0026 key.isReadable()) {\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Readable, removing OP_READ from interestOps for \" + _ch.getName());\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_READ));\n                        _ch.addEvent(ClientEvent.READ);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.READ);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (key.isValid() \u0026\u0026 key.isWritable()) {\n                    if (getClientPool().shouldNioWriteHappen() \u003d\u003d false) {\n                        //no need to remove the key\n                        continue;\n                    }\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Writable, removing OP_WRITE from interestOps for \" + _ch.getName());\n                        //remove OP_WRITE from interest set\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_WRITE));\n                        _ch.addEvent(ClientEvent.WRITE);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.WRITE);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (stopServer \u003d\u003d true \u0026\u0026 key.isAcceptable()) {\n                    //we will not accept this key\n                    //reset it back\n                    setSkipValidation(false);\n                } else {\n                    logger.warning(\"Unknown key got in SelectionKey: \" + key);\n                }\n                //Remove key\n                iterator.remove();\n                Thread.yield();\n            }\n            //end of iterator\n            iterator \u003d null;\n        }\n        //end of loop\n    }\n\n    private boolean checkAccessConstraint(Socket socket) {\n        try {\n            if (getAccessConstraintConfig() !\u003d null) {\n                getAccessConstraintConfig().checkAccept(socket);\n            }\n            return true;\n        } catch (SecurityException se) {\n            logger.warning(\"SecurityException occurred accepting connection : \" + se.getMessage());\n            return false;\n        }\n    }\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {\n        if (getSelector() \u003d\u003d null) {\n            throw new IllegalStateException(\"Selector is not open!\");\n        }\n        if (channel \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Can\u0027t register a null channel!\");\n        }\n        if (channel.isConnected() \u003d\u003d false) {\n            throw new ClosedChannelException();\n        }\n        RegisterChannelRequest req \u003d new RegisterChannelRequest(channel, ops, att);\n        RegisterChannelRequest reqOld \u003d null;\n        synchronized (registerChannelRequestMap) {\n            reqOld \u003d (RegisterChannelRequest) registerChannelRequestMap.get(channel);\n            if (reqOld \u003d\u003d null) {\n                registerChannelRequestMap.put(channel, req);\n                getSelector().wakeup();\n                return true;\n            } else {\n                if (reqOld.equals(req) \u003d\u003d false) {\n                    reqOld.setOps(reqOld.getOps() | req.getOps());\n                    reqOld.setAtt(req.getAtt());\n                    return true;\n                }\n                return false;\n            }\n        }\n        /*\n\t\tlogger.warning(\"Before register...\");\n\t\tchannel.register(getSelector(), ops, att);\n\t\tlogger.warning(\"Before wakeup and after register...\");\n\t\tgetSelector().wakeup();\n\t\tlogger.warning(\"After wakeup...\");\n\t\t*/\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig) {\n        logger.finer(\"Creating ByteBufferPool pool\");\n        int bufferSize \u003d getBasicConfig().getAdvancedSettings().getByteBufferSize();\n        boolean useDirectByteBuffer \u003d getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();\n        PoolableObjectFactory factory \u003d new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);\n        byteBufferPool \u003d poolManager.makeByteBufferPool(factory, opConfig);\n        poolManager.initPool(byteBufferPool, opConfig);\n    }\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool() {\n        return byteBufferPool;\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientThread pool\");\n        ThreadObjectFactory factory \u003d new ThreadObjectFactory();\n        ObjectPool objectPool \u003d poolManager.makeClientPool(factory, opConfig);\n        pool \u003d new ClientPool(makeQSObjectPool(objectPool), opConfig);\n        factory.setClientPool(pool);\n        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());\n        poolManager.initPool(objectPool, opConfig);\n    }\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler) {\n        clientWriteHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler() {\n        return clientWriteHandlerString;\n    }\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be \u003ccode\u003enull\u003c/code\u003e if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime() {\n        return lastStartTime;\n    }\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag) {\n        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);\n        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);\n    }\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier() {\n        return clientIdentifier;\n    }\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {\n        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);\n    }\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode() {\n        return blockingMode;\n    }\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception {\n        if (clientCommandHandlerString \u003d\u003d null \u0026\u0026 clientEventHandlerString \u003d\u003d null) {\n            logger.severe(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n            throw new AppException(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n        }\n        clientCommandHandler \u003d null;\n        if (clientCommandHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientCommandHandler class..\");\n            Class clientCommandHandlerClass \u003d getClass(clientCommandHandlerString, true);\n            clientCommandHandler \u003d (ClientCommandHandler) clientCommandHandlerClass.newInstance();\n        }\n        boolean setClientCommandHandlerLookup \u003d false;\n        clientEventHandler \u003d null;\n        if (clientEventHandlerString \u003d\u003d null) {\n            clientEventHandlerString \u003d \"org.quickserver.net.server.impl.DefaultClientEventHandler\";\n            setClientCommandHandlerLookup \u003d true;\n        }\n        logger.finest(\"Loading ClientEventHandler class..\");\n        if (clientEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientEventHandler.class.isInstance(clientCommandHandler)) {\n            clientEventHandler \u003d (ClientEventHandler) clientCommandHandler;\n        } else {\n            clientEventHandler \u003d (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();\n            if (setClientCommandHandlerLookup) {\n                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);\n            }\n        }\n        clientExtendedEventHandler \u003d null;\n        if (clientExtendedEventHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientExtendedEventHandler class..\");\n            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientCommandHandler;\n            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientEventHandler;\n            } else {\n                Class clientExtendedEventHandlerClass \u003d getClass(clientExtendedEventHandlerString, true);\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();\n            }\n        }\n        clientObjectHandler \u003d null;\n        if (clientObjectHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientObjectHandler class..\");\n            if (clientObjectHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientCommandHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientCommandHandler;\n            } else if (clientObjectHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientEventHandler;\n            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientExtendedEventHandler;\n            } else {\n                clientObjectHandler \u003d (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientBinaryHandler \u003d null;\n        if (clientBinaryHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientBinaryHandler class..\");\n            if (clientBinaryHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientCommandHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientCommandHandler;\n            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientExtendedEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientObjectHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientObjectHandler;\n            } else {\n                clientBinaryHandler \u003d (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientWriteHandler \u003d null;\n        if (clientWriteHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientWriteHandler class..\");\n            if (clientWriteHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientCommandHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientCommandHandler;\n            } else if (clientWriteHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientEventHandler;\n            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientExtendedEventHandler;\n            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientObjectHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientObjectHandler;\n            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientBinaryHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientBinaryHandler;\n            } else {\n                clientWriteHandler \u003d (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        Class authenticatorClass \u003d null;\n        if (clientAuthenticationHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientAuthenticationHandler class..\");\n            authenticatorClass \u003d getClass(clientAuthenticationHandlerString, true);\n        }\n        if (authenticatorClass !\u003d null) {\n            Object obj \u003d authenticatorClass.newInstance();\n            if (ClientAuthenticationHandler.class.isInstance(obj))\n                clientAuthenticationHandler \u003d (ClientAuthenticationHandler) obj;\n            else\n                authenticator \u003d (Authenticator) obj;\n        }\n        clientDataClass \u003d null;\n        if (clientDataString !\u003d null) {\n            logger.finest(\"Loading ClientData class..\");\n            clientDataClass \u003d getClass(clientDataString, true);\n        }\n        Assertion.affirm(clientEventHandler !\u003d null, \"ClientEventHandler was not loaded!\");\n    }\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler) {\n        clientEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler() {\n        return clientEventHandlerString;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {\n        if (dataType \u003d\u003d DataType.IN)\n            this.defaultDataModeIN \u003d dataMode;\n        if (dataType \u003d\u003d DataType.OUT)\n            this.defaultDataModeOUT \u003d dataMode;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {\n        defaultDataModeIN \u003d defaultDataMode.getDataMode(DataType.IN);\n        defaultDataModeOUT \u003d defaultDataMode.getDataMode(DataType.OUT);\n        ;\n    }\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType) {\n        if (dataType \u003d\u003d DataType.IN)\n            return defaultDataModeIN;\n        if (dataType \u003d\u003d DataType.OUT)\n            return defaultDataModeOUT;\n        else\n            throw new IllegalArgumentException(\"Unknown DataType: \" + dataType);\n    }\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler) {\n        clientExtendedEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler() {\n        return clientExtendedEventHandlerString;\n    }\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception {\n        if (getApplicationJarPath() !\u003d null \u0026\u0026 getClassLoader() \u003d\u003d null) {\n            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));\n            //update qsadmin to use the same\n            if (adminServer !\u003d null) {\n                adminServer.getServer().setClassLoader(getClassLoader());\n            }\n        }\n    }\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID() {\n        return pid;\n    }\n\n    public boolean isRawCommunicationLogging() {\n        return rawCommunicationLogging;\n    }\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {\n        this.rawCommunicationLogging \u003d rawCommunicationLogging;\n    }\n\n    public int getRawCommunicationMaxLength() {\n        return rawCommunicationMaxLength;\n    }\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {\n        this.rawCommunicationMaxLength \u003d rawCommunicationMaxLength;\n    }\n}\n",
    "package": "org.quickserver.net.server",
    "classname": "QuickServer",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_7Test.java",
    "test_prompt": "// QuickServer_7Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#stopService()} method.\n*/\nclass QuickServer_7Test {",
    "method_signature": "stopService()",
    "suffix": "7"
  },
  {
    "numberTests": "ten",
    "original_code": "// QuickServer.java\n/*\n * This file is part of the QuickServer library \n * Copyright (C) QuickServer.org\n *\n * Use, modification, copying and distribution of this software is subject to\n * the terms and conditions of the GNU Lesser General Public License. \n * You should have received a copy of the GNU LGP License along with this \n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\n *\n * For questions, suggestions, bug-reports, enhancement-requests etc.\n * visit http://www.quickserver.org\n *\n */\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n *  Main class of QuickServer library. This class is used to create\n *  multi client servers quickly.\n *  \u003cp\u003e\n *  Ones a client is connected, it creates {@link ClientHandler} object,\n *  which is run using any thread available from the pool of threads\n *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n *  handles the client. \u003cbr/\u003e\n *  QuickServer divides the application logic of its developer over eight\n *  class, \u003cbr\u003e\n *  \t\u003cul\u003e\n * \t\t\u003cli\u003eClientEventHandler\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client events [Optional Class].\n *  \t\t\u003cli\u003eClientCommandHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client character/string commands.\n *  \t\t\u003cli\u003eClientObjectHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - Object commands.\n * \t\t\u003cli\u003eClientBinaryHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - binary data.\n * \t\t\u003cli\u003eClientWriteHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n *  \t\t\u003cli\u003eClientAuthenticationHandler [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Used to Authencatet a client.\n *  \t\t\u003cli\u003eClientData [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Client data carrier (support class)\n * \t\t\u003cli\u003eClientExtendedEventHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles extended client events.\n *  \t\u003c/ul\u003e\n *\n *  [#] \u003d Any one of these have to be set based on default DataMode for input.\n *  The default DataMode for input is String so if not changes you will\n *  have to set ClientCommandHandler.\n *  \u003c/p\u003e\n *  \u003cp\u003e\n *   Eg:\n *  \u003ccode\u003e\u003cBLOCKQUOTE\u003e\u003cpre\u003e\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle \u003d \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer \u003d new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * \u003c/pre\u003e\u003c/BLOCKQUOTE\u003e\u003c/code\u003e\u003c/p\u003e\n *\n *  @version 1.4.8\n *  @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //Some variable are not initialised to any value because the\n    //default java value was desired initial value.\n    //\u0027dev \u0027 \u003d development build not yet final\n    //\u0027beta\u0027 \u003d test build all features\n    //change also in QSAdminMain\n    private final static String VER \u003d \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n        if (System.getProperty(\"org.quickserver.useOSLineSeparator\") !\u003d null \u0026\u0026 System.getProperty(\"org.quickserver.useOSLineSeparator\").equals(\"true\")) {\n            NEW_LINE \u003d System.getProperty(\"line.separator\");\n        } else {\n            NEW_LINE \u003d \"\\r\\n\";\n        }\n        String _pid \u003d ManagementFactory.getRuntimeMXBean().getName();\n        int i \u003d _pid.indexOf(\"@\");\n        pid \u003d _pid.substring(0, i);\n        System.out.print(\"Loading QuickServer v\" + getVersion() + \" [PID:\" + pid + \"]\");\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort \u003d 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName \u003d \"QuickServer\";\n\n    private long maxConnection \u003d -1;\n\n    //1 min socket timeout\n    private int socketTimeout \u003d 60 * 1000;\n\n    private String maxConnectionMsg \u003d \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg \u003d \"-ERR Timeout\";\n\n    private String maxAuthTryMsg \u003d \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry \u003d 5;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //--v1.2\n    //Logger for QuickServer\n    private static final Logger logger \u003d Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //for Service interface\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState \u003d Service.UNKNOWN;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.3\n    private QuickServerConfig config \u003d new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel \u003d \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel \u003d \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation \u003d false;\n\n    private boolean communicationLogging \u003d true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig \u003d config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km \u003d null;\n\n    private TrustManager[] tm \u003d null;\n\n    private boolean runningSecure \u003d false;\n\n    private SecureStoreManager secureStoreManager \u003d null;\n\n    private Exception exceptionInRun \u003d null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode \u003d true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN \u003d DataMode.STRING;\n\n    private DataMode defaultDataModeOUT \u003d DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging \u003d false;\n\n    private int rawCommunicationMaxLength \u003d 100;\n\n    static {\n        System.out.println(\" Done\");\n        //should be commented if not a patch release\n        //System.out.println(\"[Includes patch(#): t\u003d152\u0026p\u003d532]\");\n        //should be commented if not a dev release\n        //System.out.println(\"[Dev Build Date: Saturday, October 29, 2005]\");\n        logger.log(Level.FINE, \"PID: {0}\", pid);\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion() {\n        return VER;\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo() {\n        return getVersionNo(VER);\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver) {\n        //String ver \u003d getVersion();\n        float version \u003d 0;\n        //check if beta\n        int i \u003d ver.indexOf(\" \");\n        if (i \u003d\u003d -1)\n            i \u003d ver.length();\n        ver \u003d ver.substring(0, i);\n        //check for sub version\n        i \u003d ver.indexOf(\".\");\n        if (i !\u003d -1) {\n            int j \u003d ver.indexOf(\".\", i);\n            if (j !\u003d -1) {\n                ver \u003d ver.substring(0, i) + \".\" + MyString.replaceAll(ver.substring(i + 1), \".\", \"\");\n            }\n        }\n        try {\n            version \u003d Float.parseFloat(ver);\n        } catch (NumberFormatException e) {\n            throw new RuntimeException(\"Corrupt QuickServer\");\n        }\n        return version;\n    }\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine() {\n        return NEW_LINE;\n    }\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString() {\n        return serverName + \" : \" + getPort();\n    }\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n        setClientCommandHandler(commandHandler);\n    }\n\n    /**\n     * Creates a new server at \u003ccode\u003eport\u003c/code\u003e with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n        //send to another constructor\n        this(commandHandler);\n        setPort(port);\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException {\n        logger.log(Level.FINE, \"Starting {0}\", getName());\n        if (isClosed() \u003d\u003d false) {\n            logger.log(Level.WARNING, \"Server {0} already running.\", getName());\n            throw new AppException(\"Server \" + getName() + \" already running.\");\n        }\n        blockingMode \u003d getBasicConfig().getServerMode().getBlocking();\n        if (getSecure().isEnable() \u0026\u0026 blockingMode \u003d\u003d false) {\n            //TODO we need to fix this..\n            logger.warning(\"QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode.\");\n            blockingMode \u003d true;\n            getBasicConfig().getServerMode().setBlocking(blockingMode);\n        }\n        if (serverBanner \u003d\u003d null) {\n            serverBanner \u003d \"\\n-------------------------------\" + \"\\n Name : \" + getName() + \"\\n Port : \" + getPort() + \"\\n-------------------------------\\n\";\n            logger.finest(\"Default Server Banner Generated\");\n        }\n        try {\n            loadApplicationClasses();\n            //load class from Advanced Settings\n            Class clientIdentifierClass \u003d getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);\n            clientIdentifier \u003d (ClientIdentifier) clientIdentifierClass.newInstance();\n            clientIdentifier.setQuickServer(QuickServer.this);\n            //load class from ObjectPoolConfig\n            Class poolManagerClass \u003d getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);\n            poolManager \u003d (PoolManager) poolManagerClass.newInstance();\n            //load class QSObjectPoolMaker\n            Class qsObjectPoolMakerClass \u003d getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);\n            qsObjectPoolMaker \u003d (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();\n            loadServerHooksClasses();\n            processServerHooks(ServerHook.PRE_STARTUP);\n            if (getSecure().isLoad() \u003d\u003d true)\n                //v1.4.0\n                loadSSLContext();\n            loadBusinessLogic();\n        } catch (ClassNotFoundException e) {\n            logger.log(Level.SEVERE, \"Could not load class/s: \" + e, e);\n            throw new AppException(\"Could not load class/s : \" + e);\n        } catch (InstantiationException e) {\n            logger.log(Level.SEVERE, \"Could not instantiate class/s: \" + e, e);\n            throw new AppException(\"Could not instantiate class/s: \" + e);\n        } catch (IllegalAccessException e) {\n            logger.log(Level.SEVERE, \"Illegal access to class/s: \" + e, e);\n            throw new AppException(\"Illegal access to class/s: \" + e);\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"IOException: \" + e, e);\n            throw new AppException(\"IOException: \" + e);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Exception: \" + e, e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Exception : \" + e);\n        }\n        //v1.3.3\n        if (getSecurityManagerClass() !\u003d null) {\n            System.setSecurityManager(getSecurityManager());\n        }\n        setServiceState(Service.INIT);\n        t \u003d new Thread(this, \"QuickServer - \" + getName());\n        t.start();\n        do {\n            Thread.yield();\n        } while (getServiceState() \u003d\u003d Service.INIT);\n        if (getServiceState() !\u003d Service.RUNNING) {\n            if (exceptionInRun !\u003d null)\n                throw new AppException(\"Could not start server \" + getName() + \"! Details: \" + exceptionInRun);\n            else\n                throw new AppException(\"Could not start server \" + getName());\n        }\n        lastStartTime \u003d new java.util.Date();\n        logger.log(Level.FINE, \"Started {0}, Date: {1}\", new Object[] { getName(), lastStartTime });\n    }\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException {\n        processServerHooks(ServerHook.PRE_SHUTDOWN);\n        logger.log(Level.WARNING, \"Stopping {0}\", getName());\n        stopServer \u003d true;\n        Socket death \u003d null;\n        if (isClosed() \u003d\u003d true) {\n            logger.log(Level.WARNING, \"Server {0} is not running!\", getName());\n            throw new AppException(\"Server \" + getName() + \" is not running!\");\n        }\n        try {\n            if (getBlockingMode() \u003d\u003d true) {\n                if (getSecure().isEnable() \u003d\u003d false) {\n                    death \u003d new Socket(server.getInetAddress(), server.getLocalPort());\n                    death.getInputStream().read();\n                    death.close();\n                } else {\n                    death \u003d getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());\n                    Thread.sleep(100);\n                    death.close();\n                }\n            }\n            if (serverSocketChannel !\u003d null) {\n                serverSocketChannel.close();\n            }\n        } catch (IOException e) {\n            logger.log(Level.FINE, \"IOError stopping {0}: {1}\", new Object[] { getName(), e });\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error stopping {0}: {1}\", new Object[] { getName(), e });\n            throw new AppException(\"Error in stopServer \" + getName() + \": \" + e);\n        }\n        for (int i \u003d 0; getServiceState() !\u003d Service.STOPPED; i++) {\n            try {\n                Thread.sleep(60);\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error waiting for {0} to fully stop. Error: {1}\", new Object[] { getName(), e });\n            }\n            if (i \u003e 1000) {\n                logger.severe(\"Server was not stopped even after 10sec.. will terminate now.\");\n                System.exit(-1);\n            }\n        }\n        if (adminServer \u003d\u003d null || getQSAdminServer().getServer() !\u003d this) {\n            //so this is not qsadmin\n            setClassLoader(null);\n        }\n        logger.log(Level.INFO, \"Stopped {0}\", getName());\n    }\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException {\n        stopServer();\n        startServer();\n    }\n\n    /**\n     * Returns the name of the QuickServer. Default is \u0027QuickServer\u0027.\n     * @see #setName\n     */\n    public String getName() {\n        return serverName;\n    }\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name) {\n        serverName \u003d name;\n        logger.log(Level.FINEST, \"Set to : {0}\", name);\n    }\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner() {\n        return serverBanner;\n    }\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. \u003cbr\u003e\u0026nbsp;\u003cbr\u003e\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner) {\n        serverBanner \u003d banner;\n        logger.log(Level.FINEST, \"Set to : {0}\", banner);\n    }\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port) {\n        if (port \u003c 0) {\n            throw new IllegalArgumentException(\"Port number can not be less than 0!\");\n        }\n        serverPort \u003d port;\n        logger.log(Level.FINEST, \"Set to {0}\", port);\n    }\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort() {\n        if (isClosed() \u003d\u003d false) {\n            return server.getLocalPort();\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            return serverPort;\n        } else {\n            int _port \u003d getSecure().getPort();\n            if (_port \u003d\u003d -1)\n                return serverPort;\n            else\n                return _port;\n        }\n    }\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler) {\n        clientCommandHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler() {\n        return clientCommandHandlerString;\n    }\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data) {\n        this.clientDataString \u003d data;\n        logger.log(Level.FINEST, \"Set to {0}\", data);\n    }\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData() {\n        return clientDataString;\n    }\n\n    /**\n     * Sets the client socket\u0027s timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time) {\n        if (time \u003e 0)\n            socketTimeout \u003d time;\n        else\n            socketTimeout \u003d 0;\n        logger.log(Level.FINEST, \"Set to {0}\", socketTimeout);\n    }\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout() {\n        return socketTimeout;\n    }\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry) {\n        maxAuthTry \u003d authTry;\n        logger.log(Level.FINEST, \"Set to {0}\", authTry);\n    }\n\n    /**\n     * Returns max allowed login attempts. Default is \u003ccode\u003e5\u003c/code\u003e.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry() {\n        return maxAuthTry;\n    }\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg) {\n        maxAuthTryMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg() {\n        return maxAuthTryMsg;\n    }\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg) {\n        timeoutMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg() {\n        return timeoutMsg;\n    }\n\n    private TheClient initTheClient() {\n        TheClient theClient \u003d new TheClient();\n        theClient.setServer(QuickServer.this);\n        theClient.setTimeoutMsg(getTimeoutMsg());\n        //v1.2\n        theClient.setMaxAuthTry(getMaxAuthTry());\n        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());\n        theClient.setClientEventHandler(clientEventHandler);\n        //v1.4.6\n        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);\n        theClient.setClientCommandHandler(clientCommandHandler);\n        //v1.2\n        theClient.setClientObjectHandler(clientObjectHandler);\n        //v1.4\n        theClient.setClientBinaryHandler(clientBinaryHandler);\n        //v1.4.5\n        theClient.setClientWriteHandler(clientWriteHandler);\n        //v1.3\n        theClient.setAuthenticator(authenticator);\n        //v1.4.6\n        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);\n        theClient.setTimeout(socketTimeout);\n        theClient.setMaxConnectionMsg(maxConnectionMsg);\n        //v1.3.2\n        theClient.setCommunicationLogging(getCommunicationLogging());\n        return theClient;\n    }\n\n    public void run() {\n        exceptionInRun \u003d null;\n        TheClient theClient \u003d initTheClient();\n        try {\n            stopServer \u003d false;\n            closeAllPools();\n            initAllPools();\n            makeServerSocket();\n            //print banner\n            System.out.println(serverBanner);\n            //v1.2\n            setServiceState(Service.RUNNING);\n            //v1.3.3\n            processServerHooks(ServerHook.POST_STARTUP);\n            if (getBlockingMode() \u003d\u003d false) {\n                runNonBlocking(theClient);\n                if (stopServer \u003d\u003d true) {\n                    logger.log(Level.FINEST, \"Closing selector for {0}\", getName());\n                    selector.close();\n                }\n                return;\n            } else {\n                runBlocking(theClient);\n            }\n        } catch (BindException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"{0} BindException for Port {1} @ {2} : {3}\", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });\n        } catch (javax.net.ssl.SSLException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"SSLException {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (IOException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"IOError {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (Exception e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"Error {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } finally {\n            if (getBlockingMode() \u003d\u003d true) {\n                logger.log(Level.WARNING, \"Closing {0}\", getName());\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            } else if (getBlockingMode() \u003d\u003d false \u0026\u0026 exceptionInRun !\u003d null) {\n                logger.log(Level.WARNING, \"Closing {0} - Had Error: {1}\", new Object[] { getName(), exceptionInRun });\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        if (serverSocketChannel !\u003d null)\n                            serverSocketChannel.close();\n                        if (server !\u003d null)\n                            server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n        }\n    }\n\n    //end of run\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnection \u003d maxConnection;\n        else\n            this.maxConnection \u003d maxConnection;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnection);\n    }\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection() {\n        return maxConnection;\n    }\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount() {\n        if (clientHandlerPool !\u003d null) {\n            try {\n                return getClientHandlerPool().getNumActive();\n            } catch (Exception e) {\n                return 0;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : \u003ccode\u003e-ERR Server Busy. Max Connection Reached\u003c/code\u003e\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n        else\n            this.maxConnectionMsg \u003d maxConnectionMsg;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnectionMsg);\n    }\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg() {\n        return maxConnectionMsg;\n    }\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException {\n        ipAddr \u003d InetAddress.getByName(bindAddr);\n        logger.log(Level.FINEST, \"Set to {0}\", bindAddr);\n    }\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr() {\n        if (ipAddr \u003d\u003d null) {\n            try {\n                ipAddr \u003d InetAddress.getByName(\"0.0.0.0\");\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Unable to create default ip(0.0.0.0) : {0}\", e);\n                throw new RuntimeException(\"Error: Unable to find servers own ip : \" + e);\n            }\n        }\n        return ipAddr;\n    }\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects) {\n        this.storeObjects \u003d storeObjects;\n    }\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return \u003ccode\u003enull\u003c/code\u003e.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects() {\n        return storeObjects;\n    }\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port) {\n        getQSAdminServer().getServer().setPort(port);\n    }\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort() {\n        return getQSAdminServer().getServer().getPort();\n    }\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator) {\n        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);\n    }\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator() {\n        return getQSAdminServer().getServer().getAuthenticator();\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException {\n        getQSAdminServer().setClientAuthenticationHandler(authenticator);\n        getQSAdminServer().startServer(port);\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException {\n        getQSAdminServer().startServer();\n    }\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer() {\n        if (adminServer \u003d\u003d null)\n            adminServer \u003d new QSAdminServer(QuickServer.this);\n        return adminServer;\n    }\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer) {\n        if (adminServer \u003d\u003d null)\n            this.adminServer \u003d adminServer;\n    }\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed() {\n        if (server \u003d\u003d null)\n            return true;\n        return server.isClosed();\n    }\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer\u0027s own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger() {\n        if (appLogger !\u003d null)\n            return appLogger;\n        return logger;\n    }\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger) {\n        this.appLogger \u003d appLogger;\n    }\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler) {\n        clientObjectHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler() {\n        return clientObjectHandlerString;\n    }\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n        if (formatter \u003d\u003d null)\n            return;\n        consoleLoggingformatter \u003d formatter;\n        java.util.logging.Formatter conformatter \u003d (java.util.logging.Formatter) getClass(formatter, true).newInstance();\n        Logger jdkLogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d jdkLogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                handlers[index].setFormatter(conformatter);\n            }\n        }\n        logger.log(Level.FINEST, \"Set to {0}\", formatter);\n    }\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter() {\n        return consoleLoggingformatter;\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MiniFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to logging.MiniFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MicroFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to MicroFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        boolean isConsole \u003d true;\n        try {\n            if (System.console() \u003d\u003d null) {\n                isConsole \u003d false;\n            }\n        } catch (Throwable e) {\n            //ignore\n        }\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                if (isConsole \u003d\u003d false \u0026\u0026 level !\u003d Level.OFF) {\n                    System.out.println(\"QuickServer: You do not have a console.. so turning console logger off..\");\n                    level \u003d Level.OFF;\n                }\n                if (level \u003d\u003d Level.OFF) {\n                    logger.info(\"QuickServer: Removing console handler.. \");\n                    rlogger.removeHandler(handlers[index]);\n                    handlers[index].setLevel(level);\n                    handlers[index].close();\n                } else {\n                    handlers[index].setLevel(level);\n                }\n            }\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            consoleLoggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            consoleLoggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            consoleLoggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            consoleLoggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            consoleLoggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            consoleLoggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            consoleLoggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            consoleLoggingLevel \u003d \"OFF\";\n        else\n            consoleLoggingLevel \u003d \"UNKNOWN\";\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel() {\n        return consoleLoggingLevel;\n    }\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            handlers[index].setLevel(level);\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            loggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            loggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            loggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            loggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            loggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            loggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            loggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            loggingLevel \u003d \"OFF\";\n        else\n            loggingLevel \u003d \"UNKNOWN\";\n        consoleLoggingLevel \u003d loggingLevel;\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    //*** Start of Service interface methods\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError() {\n        return serviceError;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param) {\n        serviceError \u003d null;\n        try {\n            initServer(param);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig) {\n        serviceError \u003d null;\n        try {\n            initServer(qsConfig);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING)\n            return false;\n        try {\n            startServer();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.STOPPED)\n            return false;\n        try {\n            stopServer();\n            clearAllPools();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING) {\n            suspendMaxConnection \u003d maxConnection;\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n            maxConnection \u003d 0;\n            maxConnectionMsg \u003d \"Service is suspended.\";\n            setServiceState(Service.SUSPENDED);\n            logger.log(Level.INFO, \"Service {0} is suspended.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.SUSPENDED) {\n            maxConnection \u003d suspendMaxConnection;\n            maxConnectionMsg \u003d suspendMaxConnectionMsg;\n            setServiceState(Service.RUNNING);\n            logger.log(Level.INFO, \"Service {0} resumed.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info() {\n        serviceError \u003d null;\n        StringBuilder buf \u003d new StringBuilder();\n        buf.append(getName()).append(\"\\n\");\n        buf.append(getBindAddr().getHostAddress()).append(\" \");\n        buf.append(getPort()).append(\"\\n\");\n        return buf.toString();\n    }\n\n    // *** End of Service interface methods\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException {\n        QuickServerConfig qsConfig \u003d null;\n        try {\n            qsConfig \u003d ConfigReader.read((String) param[0]);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not init server from xml file {0} : {1}\", new Object[] { new File((String) param[0]).getAbsolutePath(), e });\n            throw new AppException(\"Could not init server from xml file\", e);\n        }\n        initServer(qsConfig);\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {\n        setConfig(qsConfig);\n        try {\n            configQuickServer();\n            loadApplicationClasses();\n            //start InitServerHooks\n            InitServerHooks ish \u003d getConfig().getInitServerHooks();\n            if (ish !\u003d null) {\n                Iterator iterator \u003d ish.iterator();\n                String initServerHookClassName \u003d null;\n                Class initServerHookClass \u003d null;\n                InitServerHook initServerHook \u003d null;\n                while (iterator.hasNext()) {\n                    initServerHookClassName \u003d (String) iterator.next();\n                    initServerHookClass \u003d getClass(initServerHookClassName, true);\n                    initServerHook \u003d (InitServerHook) initServerHookClass.newInstance();\n                    logger.log(Level.INFO, \"Loaded init server hook: {0}\", initServerHookClassName);\n                    logger.log(Level.FINE, \"Init server hook info: {0}\", initServerHook.info());\n                    initServerHook.handleInit(QuickServer.this);\n                }\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not load init server hook: {0}\", e);\n            logger.log(Level.WARNING, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Could not load init server hook\", e);\n        }\n        setServiceState(Service.INIT);\n        logger.log(Level.FINEST, \"\\r\\n{0}\", MyString.getSystemInfo(getVersion()));\n    }\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState() {\n        return serviceState;\n    }\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state) {\n        serviceState \u003d state;\n    }\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp) {\n        if (temp.equals(\"SEVERE\"))\n            qs.setConsoleLoggingLevel(Level.SEVERE);\n        else if (temp.equals(\"WARNING\"))\n            qs.setConsoleLoggingLevel(Level.WARNING);\n        else if (temp.equals(\"INFO\"))\n            qs.setConsoleLoggingLevel(Level.INFO);\n        else if (temp.equals(\"CONFIG\"))\n            qs.setConsoleLoggingLevel(Level.CONFIG);\n        else if (temp.equals(\"FINE\"))\n            qs.setConsoleLoggingLevel(Level.FINE);\n        else if (temp.equals(\"FINER\"))\n            qs.setConsoleLoggingLevel(Level.FINER);\n        else if (temp.equals(\"FINEST\"))\n            qs.setConsoleLoggingLevel(Level.FINEST);\n        else if (temp.equals(\"OFF\"))\n            qs.setConsoleLoggingLevel(Level.OFF);\n        else\n            logger.log(Level.WARNING, \"unknown level {0}\", temp);\n    }\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception {\n        QuickServer qs \u003d QuickServer.this;\n        //v1.3\n        qs.setConfig(config);\n        qs.setBasicConfig(config);\n        String temp \u003d config.getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        temp \u003d null;\n        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        //v1.3.3\n        qs.setSecurityManagerClass(config.getSecurityManagerClass());\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        temp \u003d config.getApplicationJarPath();\n        if (temp !\u003d null) {\n            File ajp \u003d new File(temp);\n            if (ajp.isAbsolute() \u003d\u003d false) {\n                temp \u003d config.getConfigFile();\n                ajp \u003d new File(temp);\n                temp \u003d ajp.getParent() + File.separatorChar + config.getApplicationJarPath();\n                config.setApplicationJarPath(temp);\n                temp \u003d null;\n            }\n            qs.setApplicationJarPath(config.getApplicationJarPath());\n            //set path also to QSAdmin\n            if (config.getQSAdminServerConfig() !\u003d null) {\n                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());\n            }\n        }\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception {\n        QuickServer qs \u003d getQSAdminServer().getServer();\n        qs.setBasicConfig(config);\n        //set the Logging Level to same as main QS\n        //config.getConsoleLoggingLevel();\n        String temp \u003d getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        //set the Logging Formatter to same as main QS\n        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());\n        //v1.4.6\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        //v1.4.6\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());\n        //v1.3.2\n        if (config.getCommandShellEnable().equals(\"true\"))\n            getQSAdminServer().setShellEnable(true);\n        getQSAdminServer().setPromptName(config.getCommandShellPromptName());\n        //v1.3.3\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception {\n        configQuickServer(getConfig());\n        if (getConfig().getQSAdminServerConfig() !\u003d null) {\n            configQuickServer(getConfig().getQSAdminServerConfig());\n        }\n    }\n\n    /**\n     * Usage: QuickServer [-options]\u003cbr/\u003e\n     * Where options include:\u003cbr/\u003e\n     *   -about\t\tOpens About Dialogbox\u003cbr/\u003e\n     *   -load \u003cxml_config_file\u003e [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File \u003cnew_file_name\u003e\n     */\n    public static void main(String[] args) {\n        try {\n            if (args.length \u003e\u003d 1) {\n                if (args[0].equals(\"-about\")) {\n                    org.quickserver.net.server.gui.About.main(null);\n                } else if (args[0].equals(\"-load\") \u0026\u0026 args.length \u003e\u003d 2) {\n                    QuickServer qs \u003d QuickServer.load(args[1]);\n                    if (qs !\u003d null)\n                        handleOptions(args, qs);\n                } else {\n                    System.out.println(printUsage());\n                }\n            } else {\n                System.out.println(printUsage());\n                org.quickserver.net.server.gui.About.showAbout();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException {\n        QuickServer qs \u003d new QuickServer();\n        Object[] config \u003d new Object[] { xml };\n        qs.initServer(config);\n        qs.startServer();\n        if (qs.getConfig().getQSAdminServerConfig() !\u003d null) {\n            qs.startQSAdminServer();\n        }\n        return qs;\n    }\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage() {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"QuickServer - Java library/framework for creating robust multi-client TCP servers.\\n\");\n        sb.append(\"Copyright (C) QuickServer.org\\n\\n\");\n        sb.append(\"Usage: QuickServer [-options]\\n\");\n        sb.append(\"Where options include:\\n\");\n        sb.append(\"  -about\\t\" + \"Opens About Dialog box\\n\");\n        sb.append(\"  -load \u003cxml_config_file\u003e [load-options]\\t\" + \"Loads the server from xml file.\\n\");\n        sb.append(\"  Where load-options include:\\n\");\n        sb.append(\"     -fullXML2File \u003cfile_name\u003e\\t\" + \"Dumps the Full XML configuration of the QuickServer loaded.\\n\");\n        return sb.toString();\n    }\n\n    private static void handleOptions(String[] args, QuickServer quickserver) {\n        if (args.length \u003c 3)\n            return;\n        if (args[2].equals(\"-fullXML2File\") \u0026\u0026 args.length \u003e\u003d 4) {\n            File file \u003d new File(args[3]);\n            logger.log(Level.INFO, \"Writing full xml configuration to file: {0}\", file.getAbsolutePath());\n            try {\n                TextFile.write(file, quickserver.getConfig().toXML(null));\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error writing full xml configuration: {0}\", e);\n            }\n        }\n    }\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception {\n        try {\n            if (pool !\u003d null)\n                getClientPool().clear();\n            if (clientHandlerPool !\u003d null)\n                getClientHandlerPool().clear();\n            if (getClientDataPool() !\u003d null)\n                getClientDataPool().clear();\n            if (getDBPoolUtil() !\u003d null)\n                getDBPoolUtil().clean();\n            if (byteBufferPool !\u003d null)\n                getByteBufferPool().clear();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error: {0}\", e);\n            throw e;\n        }\n    }\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception {\n        if (pool \u003d\u003d null \u0026\u0026 clientHandlerPool \u003d\u003d null \u0026\u0026 getClientDataPool() \u003d\u003d null \u0026\u0026 getDBPoolUtil() \u003d\u003d null \u0026\u0026 byteBufferPool \u003d\u003d null) {\n            return;\n        }\n        logger.log(Level.FINE, \"Closing pools for {0}\", getName());\n        try {\n            if (pool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {\n                logger.finer(\"Closing ClientThread pool.\");\n                getClientPool().close();\n            }\n            if (clientHandlerPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientHandlerPool())) {\n                logger.finer(\"Closing ClientHandler pool.\");\n                getClientHandlerPool().close();\n            }\n            if (getClientDataPool() !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientDataPool())) {\n                logger.finer(\"Closing ClientData pool.\");\n                getClientDataPool().close();\n            }\n            if (getDBPoolUtil() !\u003d null) {\n                logger.finer(\"Closing DB pool.\");\n                getDBPoolUtil().clean();\n            }\n            if (byteBufferPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getByteBufferPool())) {\n                logger.finer(\"Closing ByteBuffer pool.\");\n                getByteBufferPool().close();\n            }\n            logger.log(Level.FINE, \"Closed pools for {0}\", getName());\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error closing pools for {0}: {1}\", new Object[] { getName(), e });\n            throw e;\n        }\n    }\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception {\n        logger.fine(\"Creating pools\");\n        if (getBlockingMode() \u003d\u003d false) {\n            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());\n        }\n        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());\n        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());\n        //check if client data is poolable\n        if (clientDataClass !\u003d null) {\n            try {\n                clientData \u003d (ClientData) clientDataClass.newInstance();\n                if (PoolableObject.class.isInstance(clientData) \u003d\u003d true) {\n                    PoolableObject po \u003d (PoolableObject) clientData;\n                    if (po.isPoolable() \u003d\u003d true) {\n                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());\n                    } else {\n                        clientDataPool \u003d null;\n                        logger.fine(\"ClientData is not poolable!\");\n                    }\n                }\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error: {0}\", e);\n                throw e;\n            }\n        }\n        try {\n            makeDBObjectPool();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error in makeDBObjectPool() : {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw e;\n        }\n        logger.fine(\"Created pools\");\n    }\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool() {\n        if (pool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientPool available yet!\");\n        return pool;\n    }\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientHandler pool\");\n        PoolableObjectFactory factory \u003d new ClientHandlerObjectFactory(getBlockingMode());\n        clientHandlerPool \u003d poolManager.makeClientHandlerPool(factory, opConfig);\n        poolManager.initPool(clientHandlerPool, opConfig);\n        clientHandlerPool \u003d makeQSObjectPool(clientHandlerPool);\n        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool() {\n        if (clientHandlerPool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientHandler Pool available yet!\");\n        return clientHandlerPool;\n    }\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config) {\n        this.config \u003d config;\n    }\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig() {\n        return config;\n    }\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientData pool\");\n        clientDataPool \u003d poolManager.makeClientDataPool(factory, opConfig);\n        poolManager.initPool(clientDataPool, opConfig);\n        clientDataPool \u003d makeQSObjectPool(clientDataPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool() {\n        return clientDataPool;\n    }\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return \u003ccode\u003enull\u003c/code\u003e\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil() {\n        return dBPoolUtil;\n    }\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {\n        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);\n    }\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception {\n        if (getConfig().getDBObjectPoolConfig() !\u003d null) {\n            logger.fine(\"Creating DBObject Pool\");\n            //logger.finest(\"Got:\\n\"+getConfig().getDBObjectPoolConfig().toXML(null));\n            Class dbPoolUtilClass \u003d getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);\n            dBPoolUtil \u003d (DBPoolUtil) dbPoolUtilClass.newInstance();\n            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());\n            dBPoolUtil.initPool();\n        }\n    }\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id) {\n        return clientIdentifier.findFirstClientById(id);\n    }\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  \u003ccode\u003e\u003cpre\u003e\n     *    Eg:\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tObject syncObj \u003d quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator \u003d quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tClientIdentifier clientIdentifier \u003d quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator \u003d clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    \u003c/code\u003e\u003c/pre\u003e\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient() {\n        return clientIdentifier.findAllClient();\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern) {\n        return clientIdentifier.findAllClientById(pattern);\n    }\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key) {\n        return clientIdentifier.findClientByKey(key);\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern) {\n        return clientIdentifier.findAllClientByKey(pattern);\n    }\n\n    /**\n     * Sets next client has a trusted client.\n     * \u003cp\u003eThis will skip any authentication and will not set any timeout.\u003c/p\u003e\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted() {\n        setSkipValidation(true);\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation() {\n        return skipValidation;\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation) {\n        skipValidation \u003d validation;\n    }\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging) {\n        this.communicationLogging \u003d communicationLogging;\n    }\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging() {\n        return communicationLogging;\n    }\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass) {\n        if (securityManagerClass !\u003d null)\n            this.securityManagerClass \u003d securityManagerClass;\n    }\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass() {\n        return securityManagerClass;\n    }\n\n    public SecurityManager getSecurityManager() throws AppException {\n        if (getSecurityManagerClass() \u003d\u003d null)\n            return null;\n        SecurityManager sm \u003d null;\n        try {\n            sm \u003d (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();\n        } catch (ClassNotFoundException e) {\n            throw new AppException(e.getMessage());\n        } catch (InstantiationException e) {\n            throw new AppException(e.getMessage());\n        } catch (IllegalAccessException e) {\n            throw new AppException(e.getMessage());\n        }\n        return sm;\n    }\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {\n        this.accessConstraintConfig \u003d accessConstraintConfig;\n    }\n\n    /**\n     * Returns Access constraints if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig() {\n        return accessConstraintConfig;\n    }\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader) {\n        this.classLoader \u003d classLoader;\n        Thread.currentThread().setContextClassLoader(classLoader);\n    }\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader() {\n        return classLoader;\n    }\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException {\n        if (name \u003d\u003d null)\n            throw new IllegalArgumentException(\"Class name can\u0027t be null!\");\n        logger.log(Level.FINEST, \"Class: {0}, reload: {1}\", new Object[] { name, reload });\n        if (reload \u003d\u003d true \u0026\u0026 classLoader !\u003d null) {\n            return classLoader.loadClass(name);\n        } else if (reload \u003d\u003d true \u0026\u0026 classLoader \u003d\u003d null \u0026\u0026 this.getClass().getClassLoader() !\u003d null) {\n            return this.getClass().getClassLoader().loadClass(name);\n        } else if (reload \u003d\u003d false \u0026\u0026 classLoader !\u003d null) {\n            return Class.forName(name, true, classLoader);\n        } else /*if(reload\u003d\u003dfalse \u0026\u0026 classLoader\u003d\u003dnull)*/\n        {\n            return Class.forName(name, true, this.getClass().getClassLoader());\n        }\n    }\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath) {\n        this.applicationJarPath \u003d applicationJarPath;\n    }\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath() {\n        return applicationJarPath;\n    }\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks) {\n        this.serverHooks \u003d serverHooks;\n    }\n\n    /**\n     * Returns ServerHooks if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks() {\n        if (serverHooks \u003d\u003d null)\n            serverHooks \u003d new ServerHooks();\n        return serverHooks;\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses() {\n        if (getServerHooks() \u003d\u003d null)\n            return;\n        listOfServerHooks \u003d new ArrayList();\n        ServerHook serverHook \u003d null;\n        String serverHookClassName \u003d null;\n        Class serverHookClass \u003d null;\n        //add system hooks\n        serverHook \u003d new GhostSocketReaper();\n        serverHook.initHook(QuickServer.this);\n        listOfServerHooks.add(serverHook);\n        ghostSocketReaper \u003d (GhostSocketReaper) serverHook;\n        //add user hooks if any\n        Iterator iterator \u003d getServerHooks().iterator();\n        while (iterator.hasNext()) {\n            serverHookClassName \u003d (String) iterator.next();\n            try {\n                serverHookClass \u003d getClass(serverHookClassName, true);\n                serverHook \u003d (ServerHook) serverHookClass.newInstance();\n                serverHook.initHook(QuickServer.this);\n                listOfServerHooks.add(serverHook);\n                logger.log(Level.INFO, \"Loaded server hook: {0}\", serverHookClassName);\n                logger.log(Level.FINE, \"Server hook info: {0}\", serverHook.info());\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Could not load server hook [{0}]: {1}\", new Object[] { serverHookClassName, e });\n                logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            }\n        }\n        //end of while\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event) {\n        if (listOfServerHooks \u003d\u003d null) {\n            logger.warning(\"listOfServerHooks was null!\");\n            return;\n        }\n        ServerHook serverHook \u003d null;\n        boolean result \u003d false;\n        Iterator iterator \u003d listOfServerHooks.iterator();\n        String hooktype \u003d \"UNKNOWN\";\n        switch(event) {\n            case ServerHook.PRE_STARTUP:\n                hooktype \u003d \"PRE_STARTUP\";\n                break;\n            case ServerHook.POST_STARTUP:\n                hooktype \u003d \"POST_STARTUP\";\n                break;\n            case ServerHook.PRE_SHUTDOWN:\n                hooktype \u003d \"PRE_SHUTDOWN\";\n                break;\n            case ServerHook.POST_SHUTDOWN:\n                hooktype \u003d \"POST_SHUTDOWN\";\n                break;\n        }\n        while (iterator.hasNext()) {\n            serverHook \u003d (ServerHook) iterator.next();\n            try {\n                result \u003d serverHook.handleEvent(event);\n            } catch (Exception e) {\n                result \u003d false;\n                logger.log(Level.WARNING, \"Error invoking {0} hook [{1}]: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });\n            }\n            logger.log(Level.FINE, \"Invoked {0} hook [{1}] was: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), result });\n        }\n    }\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone() {\n        Object object \u003d null;\n        try {\n            object \u003d super.clone();\n            QuickServer _qs \u003d (QuickServer) object;\n            _qs.setQSAdminServer(new QSAdminServer(_qs));\n        } catch (CloneNotSupportedException e) {\n            //should not happ\n            logger.log(Level.WARNING, \"Error cloning : {0}\", e);\n        }\n        return object;\n    }\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure) {\n        this.secure \u003d secure;\n    }\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure() {\n        if (secure \u003d\u003d null)\n            secure \u003d new Secure();\n        return secure;\n    }\n\n    /**\n     * \u003cp\u003eReturns if the server is running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure() {\n        return runningSecure;\n    }\n\n    /**\n     * \u003cp\u003eSets the server mode if its running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure) {\n        this.runningSecure \u003d runningSecure;\n    }\n\n    private File makeAbsoluteToConfig(String fileName) {\n        Assertion.affirm(fileName !\u003d null, \"FileName can\u0027t be null\");\n        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());\n    }\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException {\n        server \u003d null;\n        logger.log(Level.FINEST, \"Binding {0} to IP: {1}\", new Object[] { getName(), getBindAddr() });\n        InetSocketAddress bindAddress \u003d new InetSocketAddress(getBindAddr(), getPort());\n        try {\n            NetworkInterface ni \u003d NetworkInterface.getByInetAddress(getBindAddr());\n            if (ni !\u003d null) {\n                logger.fine(\"NetworkInterface: \" + ni);\n            }\n        } catch (Exception igrnore) {\n            /*ignore*/\n        } catch (Error igrnore) {\n            /*ignore*/\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Making a normal ServerSocket for {0}\", getName());\n            setRunningSecure(false);\n            if (getBlockingMode() \u003d\u003d false) {\n                //for non-blocking\n                serverSocketChannel \u003d ServerSocketChannel.open();\n                server \u003d serverSocketChannel.socket();\n                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n            } else {\n                //for blocking\n                server \u003d new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n            }\n        } else {\n            try {\n                logger.log(Level.FINE, \"Making a secure ServerSocket for {0}\", getName());\n                getSSLContext();\n                setRunningSecure(true);\n                if (getBlockingMode() \u003d\u003d false) {\n                    logger.log(Level.FINE, \"Making a secure ServerSocketChannel for {0}\", getName());\n                    //for non-blocking\n                    serverSocketChannel \u003d ServerSocketChannel.open();\n                    server \u003d serverSocketChannel.socket();\n                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n                } else {\n                    ServerSocketFactory ssf \u003d getSSLContext().getServerSocketFactory();\n                    SSLServerSocket serversocket \u003d (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());\n                    setRunningSecure(true);\n                    secureStoreManager.logSSLServerSocketInfo(serversocket);\n                    server \u003d serversocket;\n                    serverSocketChannel \u003d server.getChannel();\n                    if (serverSocketChannel \u003d\u003d null \u0026\u0026 getBlockingMode() \u003d\u003d false) {\n                        logger.warning(\"Secure Server does not support Channel! So will run in blocking mode.\");\n                        blockingMode \u003d false;\n                    }\n                }\n                //blocking\n            } catch (NoSuchAlgorithmException e) {\n                logger.log(Level.WARNING, \"NoSuchAlgorithmException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            } catch (KeyManagementException e) {\n                logger.log(Level.WARNING, \"KeyManagementException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            }\n        }\n        server.setReuseAddress(true);\n        int connectionTime \u003d 0;\n        int latency \u003d 0;\n        int bandwidth \u003d 0;\n        connectionTime \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();\n        latency \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();\n        bandwidth \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();\n        logger.log(Level.FINE, \"getPerformancePreferencesConnectionTime : {0}\", connectionTime);\n        logger.log(Level.FINE, \"getPerformancePreferencesLatency : {0}\", latency);\n        logger.log(Level.FINE, \"getPerformancePreferencesBandwidth : {0}\", bandwidth);\n        server.setPerformancePreferences(connectionTime, latency, bandwidth);\n        int clientSocketReceiveBufferSize \u003d getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();\n        if (clientSocketReceiveBufferSize \u003e 0) {\n            logger.log(Level.FINE, \"clientSocketReceiveBufferSize: {0}\", clientSocketReceiveBufferSize);\n            server.setReceiveBufferSize(clientSocketReceiveBufferSize);\n        }\n        if (getBlockingMode() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Server Mode {0} - Non Blocking\", getName());\n            if (selector \u003d\u003d null || selector.isOpen() \u003d\u003d false) {\n                logger.finest(\"Opening new selector\");\n                selector \u003d Selector.open();\n            } else {\n                logger.log(Level.FINEST, \"Reusing selector: {0}\", selector);\n            }\n            serverSocketChannel.configureBlocking(false);\n            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n            selector.wakeup();\n        } else {\n            logger.log(Level.FINE, \"Server Mode {0} - Blocking\", getName());\n        }\n    }\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {\n        Assertion.affirm(basicConfig !\u003d null, \"BasicServerConfig can\u0027t be null\");\n        this.basicConfig \u003d basicConfig;\n    }\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig() {\n        return basicConfig;\n    }\n\n    /**\n     * Loads the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException {\n        if (getSecure().isLoad() \u003d\u003d false) {\n            throw new IllegalStateException(\"Secure setting is not yet enabled for loading!\");\n        }\n        logger.info(\"Loading Secure Context..\");\n        km \u003d null;\n        tm \u003d null;\n        try {\n            String ssManager \u003d \"org.quickserver.security.SecureStoreManager\";\n            if (getSecure().getSecureStore() !\u003d null)\n                ssManager \u003d getSecure().getSecureStore().getSecureStoreManager();\n            Class secureStoreManagerClass \u003d getClass(ssManager, true);\n            secureStoreManager \u003d (SecureStoreManager) secureStoreManagerClass.newInstance();\n            km \u003d secureStoreManager.loadKeyManagers(getConfig());\n            logger.fine(\"KeyManager got\");\n            tm \u003d secureStoreManager.loadTrustManagers(getConfig());\n            logger.fine(\"TrustManager got\");\n            sslc \u003d secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());\n            sslc.init(km, tm, null);\n            logger.fine(\"SSLContext loaded\");\n        } catch (KeyStoreException e) {\n            logger.warning(\"KeyStoreException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchAlgorithmException e) {\n            logger.warning(\"NoSuchAlgorithmException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchProviderException e) {\n            logger.warning(\"NoSuchProviderException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (UnrecoverableKeyException e) {\n            logger.warning(\"UnrecoverableKeyException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (CertificateException e) {\n            logger.warning(\"CertificateException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (KeyManagementException e) {\n            logger.warning(\"KeyManagementException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (GeneralSecurityException e) {\n            logger.warning(\"GeneralSecurityException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (ClassNotFoundException e) {\n            logger.warning(\"ClassNotFoundException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (InstantiationException e) {\n            logger.warning(\"InstantiationException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (IllegalAccessException e) {\n            logger.warning(\"IllegalAccessException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        return getSSLContext(null);\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        if (protocol !\u003d null \u0026\u0026 secureStoreManager !\u003d null) {\n            SSLContext _sslc \u003d secureStoreManager.getSSLContext(protocol);\n            _sslc.init(km, tm, null);\n            return _sslc;\n        }\n        return sslc;\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext());\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext(protocol));\n    }\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler) {\n        clientBinaryHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler() {\n        return clientBinaryHandlerString;\n    }\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector) {\n        this.selector \u003d selector;\n    }\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector() {\n        return selector;\n    }\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception {\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        //long stime \u003d System.currentTimeMillis();\n        //long etime \u003d System.currentTimeMillis();\n        while (true) {\n            //etime \u003d System.currentTimeMillis();\n            //System.out.println(\"Time Taken: \"+(etime-stime));\n            client \u003d server.accept();\n            //stime \u003d System.currentTimeMillis();\n            if (linger \u003c 0) {\n                client.setSoLinger(false, 0);\n            } else {\n                client.setSoLinger(true, linger);\n            }\n            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                //low delay\u003d10\n                client.setTrafficClass(socketTrafficClass);\n            }\n            logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n            }\n            if (stopServer) {\n                //Client connected when server was about to be shutdown.\n                try {\n                    client.close();\n                } catch (Exception e) {\n                }\n                break;\n            }\n            if (checkAccessConstraint(client) \u003d\u003d false) {\n                continue;\n            }\n            //Check if max connection has reached\n            if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);\n            } else {\n                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);\n            }\n            theClient.setTrusted(getSkipValidation());\n            theClient.setSocket(client);\n            //mostly null\n            theClient.setSocketChannel(client.getChannel());\n            if (clientDataClass !\u003d null) {\n                if (getClientDataPool() \u003d\u003d null) {\n                    clientData \u003d (ClientData) clientDataClass.newInstance();\n                } else {\n                    clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                }\n                theClient.setClientData(clientData);\n            }\n            try {\n                _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                _chPolled.handleClient(theClient);\n            } catch (java.util.NoSuchElementException nsee) {\n                logger.warning(\"Could not borrow ClientHandler from pool. Error: \" + nsee);\n                logger.warning(\"Closing Socket [\" + client + \"] since no ClientHandler available.\");\n                client.close();\n            }\n            if (_chPolled !\u003d null) {\n                try {\n                    getClientPool().addClient(_chPolled, true);\n                } catch (java.util.NoSuchElementException nsee) {\n                    logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                    //logger.warning(\"Closing Socket [\"+client+\"] since no Thread available.\");\n                    //client.close();\n                    //returnClientHandlerToPool(_chPolled);\n                }\n                _chPolled \u003d null;\n            }\n            client \u003d null;\n            //reset it back\n            setSkipValidation(false);\n        }\n        //end of loop\n    }\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception {\n        int selectCount \u003d 0;\n        Iterator iterator \u003d null;\n        SelectionKey key \u003d null;\n        ServerSocketChannel serverChannel \u003d null;\n        SocketChannel socketChannel \u003d null;\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        boolean stopServerProcessed \u003d false;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        registerChannelRequestMap \u003d new HashMap();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        while (true) {\n            selectCount \u003d selector.select(500);\n            //selectCount \u003d selector.select();//for testing\n            //check for any pending registerChannel req.\n            synchronized (registerChannelRequestMap) {\n                if (registerChannelRequestMap.size() \u003e 0) {\n                    RegisterChannelRequest req \u003d null;\n                    Object hashkey \u003d null;\n                    iterator \u003d registerChannelRequestMap.keySet().iterator();\n                    while (iterator.hasNext()) {\n                        hashkey \u003d iterator.next();\n                        req \u003d (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);\n                        req.register(getSelector());\n                    }\n                    iterator \u003d null;\n                    registerChannelRequestMap.clear();\n                }\n                //if\n            }\n            //sync\n            if (stopServer \u003d\u003d true \u0026\u0026 stopServerProcessed \u003d\u003d false) {\n                logger.warning(\"Closing \" + getName());\n                serverSocketChannel.close();\n                stopServerProcessed \u003d true;\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.warning(\"Closed \" + getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n            if (stopServer \u003d\u003d false \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                logger.finest(\"Server must have re-started.. will break\");\n                break;\n            }\n            if (selectCount \u003d\u003d 0 \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                java.util.Set keyset \u003d selector.keys();\n                if (keyset.isEmpty() \u003d\u003d true \u0026\u0026 getClientCount() \u003c\u003d 0) {\n                    break;\n                } else {\n                    continue;\n                }\n            } else if (selectCount \u003d\u003d 0) {\n                continue;\n            }\n            iterator \u003d selector.selectedKeys().iterator();\n            while (iterator.hasNext()) {\n                key \u003d (SelectionKey) iterator.next();\n                if (key.isValid() \u003d\u003d false) {\n                    iterator.remove();\n                    continue;\n                }\n                if (key.isAcceptable() \u0026\u0026 stopServer \u003d\u003d false) {\n                    logger.finest(\"Key is Acceptable\");\n                    serverChannel \u003d (ServerSocketChannel) key.channel();\n                    socketChannel \u003d serverChannel.accept();\n                    if (socketChannel \u003d\u003d null) {\n                        iterator.remove();\n                        continue;\n                    }\n                    client \u003d socketChannel.socket();\n                    if (linger \u003c 0) {\n                        client.setSoLinger(false, 0);\n                    } else {\n                        client.setSoLinger(true, linger);\n                    }\n                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                        //low delay\u003d10\n                        client.setTrafficClass(socketTrafficClass);\n                    }\n                    logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                        logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n                    }\n                    if (checkAccessConstraint(client) \u003d\u003d false) {\n                        iterator.remove();\n                        continue;\n                    }\n                    socketChannel.configureBlocking(false);\n                    theClient.setTrusted(getSkipValidation());\n                    theClient.setSocket(socketChannel.socket());\n                    theClient.setSocketChannel(socketChannel);\n                    if (clientDataClass !\u003d null) {\n                        if (getClientDataPool() \u003d\u003d null) {\n                            clientData \u003d (ClientData) clientDataClass.newInstance();\n                        } else {\n                            //borrow a object from pool\n                            clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                        }\n                        theClient.setClientData(clientData);\n                    }\n                    //Check if max connection has reached\n                    if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                        theClient.setClientEvent(ClientEvent.MAX_CON);\n                    } else {\n                        theClient.setClientEvent(ClientEvent.ACCEPT);\n                    }\n                    try {\n                        _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                        logger.finest(\"Asking \" + _chPolled.getName() + \" to handle.\");\n                        _chPolled.handleClient(theClient);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.warning(\"Could not borrow ClientHandler Object from pool. Error: \" + nsee);\n                        logger.warning(\"Closing SocketChannel [\" + serverChannel.socket() + \"] since no ClientHandler available.\");\n                        socketChannel.close();\n                    }\n                    if (_chPolled !\u003d null) {\n                        try {\n                            getClientPool().addClient(_chPolled, true);\n                        } catch (java.util.NoSuchElementException nsee) {\n                            logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                            //logger.warning(\"Closing SocketChannel [\"+serverChannel.socket()+\"] since no Thread available.\");\n                            //socketChannel.close();\n                            //returnClientHandlerToPool(_chPolled);\n                        }\n                        _chPolled \u003d null;\n                    }\n                    socketChannel \u003d null;\n                    client \u003d null;\n                    //reset it back\n                    setSkipValidation(false);\n                } else if (key.isValid() \u0026\u0026 key.isReadable()) {\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Readable, removing OP_READ from interestOps for \" + _ch.getName());\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_READ));\n                        _ch.addEvent(ClientEvent.READ);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.READ);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (key.isValid() \u0026\u0026 key.isWritable()) {\n                    if (getClientPool().shouldNioWriteHappen() \u003d\u003d false) {\n                        //no need to remove the key\n                        continue;\n                    }\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Writable, removing OP_WRITE from interestOps for \" + _ch.getName());\n                        //remove OP_WRITE from interest set\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_WRITE));\n                        _ch.addEvent(ClientEvent.WRITE);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.WRITE);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (stopServer \u003d\u003d true \u0026\u0026 key.isAcceptable()) {\n                    //we will not accept this key\n                    //reset it back\n                    setSkipValidation(false);\n                } else {\n                    logger.warning(\"Unknown key got in SelectionKey: \" + key);\n                }\n                //Remove key\n                iterator.remove();\n                Thread.yield();\n            }\n            //end of iterator\n            iterator \u003d null;\n        }\n        //end of loop\n    }\n\n    private boolean checkAccessConstraint(Socket socket) {\n        try {\n            if (getAccessConstraintConfig() !\u003d null) {\n                getAccessConstraintConfig().checkAccept(socket);\n            }\n            return true;\n        } catch (SecurityException se) {\n            logger.warning(\"SecurityException occurred accepting connection : \" + se.getMessage());\n            return false;\n        }\n    }\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {\n        if (getSelector() \u003d\u003d null) {\n            throw new IllegalStateException(\"Selector is not open!\");\n        }\n        if (channel \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Can\u0027t register a null channel!\");\n        }\n        if (channel.isConnected() \u003d\u003d false) {\n            throw new ClosedChannelException();\n        }\n        RegisterChannelRequest req \u003d new RegisterChannelRequest(channel, ops, att);\n        RegisterChannelRequest reqOld \u003d null;\n        synchronized (registerChannelRequestMap) {\n            reqOld \u003d (RegisterChannelRequest) registerChannelRequestMap.get(channel);\n            if (reqOld \u003d\u003d null) {\n                registerChannelRequestMap.put(channel, req);\n                getSelector().wakeup();\n                return true;\n            } else {\n                if (reqOld.equals(req) \u003d\u003d false) {\n                    reqOld.setOps(reqOld.getOps() | req.getOps());\n                    reqOld.setAtt(req.getAtt());\n                    return true;\n                }\n                return false;\n            }\n        }\n        /*\n\t\tlogger.warning(\"Before register...\");\n\t\tchannel.register(getSelector(), ops, att);\n\t\tlogger.warning(\"Before wakeup and after register...\");\n\t\tgetSelector().wakeup();\n\t\tlogger.warning(\"After wakeup...\");\n\t\t*/\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig) {\n        logger.finer(\"Creating ByteBufferPool pool\");\n        int bufferSize \u003d getBasicConfig().getAdvancedSettings().getByteBufferSize();\n        boolean useDirectByteBuffer \u003d getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();\n        PoolableObjectFactory factory \u003d new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);\n        byteBufferPool \u003d poolManager.makeByteBufferPool(factory, opConfig);\n        poolManager.initPool(byteBufferPool, opConfig);\n    }\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool() {\n        return byteBufferPool;\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientThread pool\");\n        ThreadObjectFactory factory \u003d new ThreadObjectFactory();\n        ObjectPool objectPool \u003d poolManager.makeClientPool(factory, opConfig);\n        pool \u003d new ClientPool(makeQSObjectPool(objectPool), opConfig);\n        factory.setClientPool(pool);\n        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());\n        poolManager.initPool(objectPool, opConfig);\n    }\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler) {\n        clientWriteHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler() {\n        return clientWriteHandlerString;\n    }\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be \u003ccode\u003enull\u003c/code\u003e if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime() {\n        return lastStartTime;\n    }\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag) {\n        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);\n        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);\n    }\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier() {\n        return clientIdentifier;\n    }\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {\n        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);\n    }\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode() {\n        return blockingMode;\n    }\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception {\n        if (clientCommandHandlerString \u003d\u003d null \u0026\u0026 clientEventHandlerString \u003d\u003d null) {\n            logger.severe(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n            throw new AppException(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n        }\n        clientCommandHandler \u003d null;\n        if (clientCommandHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientCommandHandler class..\");\n            Class clientCommandHandlerClass \u003d getClass(clientCommandHandlerString, true);\n            clientCommandHandler \u003d (ClientCommandHandler) clientCommandHandlerClass.newInstance();\n        }\n        boolean setClientCommandHandlerLookup \u003d false;\n        clientEventHandler \u003d null;\n        if (clientEventHandlerString \u003d\u003d null) {\n            clientEventHandlerString \u003d \"org.quickserver.net.server.impl.DefaultClientEventHandler\";\n            setClientCommandHandlerLookup \u003d true;\n        }\n        logger.finest(\"Loading ClientEventHandler class..\");\n        if (clientEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientEventHandler.class.isInstance(clientCommandHandler)) {\n            clientEventHandler \u003d (ClientEventHandler) clientCommandHandler;\n        } else {\n            clientEventHandler \u003d (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();\n            if (setClientCommandHandlerLookup) {\n                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);\n            }\n        }\n        clientExtendedEventHandler \u003d null;\n        if (clientExtendedEventHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientExtendedEventHandler class..\");\n            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientCommandHandler;\n            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientEventHandler;\n            } else {\n                Class clientExtendedEventHandlerClass \u003d getClass(clientExtendedEventHandlerString, true);\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();\n            }\n        }\n        clientObjectHandler \u003d null;\n        if (clientObjectHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientObjectHandler class..\");\n            if (clientObjectHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientCommandHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientCommandHandler;\n            } else if (clientObjectHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientEventHandler;\n            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientExtendedEventHandler;\n            } else {\n                clientObjectHandler \u003d (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientBinaryHandler \u003d null;\n        if (clientBinaryHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientBinaryHandler class..\");\n            if (clientBinaryHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientCommandHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientCommandHandler;\n            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientExtendedEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientObjectHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientObjectHandler;\n            } else {\n                clientBinaryHandler \u003d (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientWriteHandler \u003d null;\n        if (clientWriteHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientWriteHandler class..\");\n            if (clientWriteHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientCommandHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientCommandHandler;\n            } else if (clientWriteHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientEventHandler;\n            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientExtendedEventHandler;\n            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientObjectHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientObjectHandler;\n            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientBinaryHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientBinaryHandler;\n            } else {\n                clientWriteHandler \u003d (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        Class authenticatorClass \u003d null;\n        if (clientAuthenticationHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientAuthenticationHandler class..\");\n            authenticatorClass \u003d getClass(clientAuthenticationHandlerString, true);\n        }\n        if (authenticatorClass !\u003d null) {\n            Object obj \u003d authenticatorClass.newInstance();\n            if (ClientAuthenticationHandler.class.isInstance(obj))\n                clientAuthenticationHandler \u003d (ClientAuthenticationHandler) obj;\n            else\n                authenticator \u003d (Authenticator) obj;\n        }\n        clientDataClass \u003d null;\n        if (clientDataString !\u003d null) {\n            logger.finest(\"Loading ClientData class..\");\n            clientDataClass \u003d getClass(clientDataString, true);\n        }\n        Assertion.affirm(clientEventHandler !\u003d null, \"ClientEventHandler was not loaded!\");\n    }\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler) {\n        clientEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler() {\n        return clientEventHandlerString;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {\n        if (dataType \u003d\u003d DataType.IN)\n            this.defaultDataModeIN \u003d dataMode;\n        if (dataType \u003d\u003d DataType.OUT)\n            this.defaultDataModeOUT \u003d dataMode;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {\n        defaultDataModeIN \u003d defaultDataMode.getDataMode(DataType.IN);\n        defaultDataModeOUT \u003d defaultDataMode.getDataMode(DataType.OUT);\n        ;\n    }\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType) {\n        if (dataType \u003d\u003d DataType.IN)\n            return defaultDataModeIN;\n        if (dataType \u003d\u003d DataType.OUT)\n            return defaultDataModeOUT;\n        else\n            throw new IllegalArgumentException(\"Unknown DataType: \" + dataType);\n    }\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler) {\n        clientExtendedEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler() {\n        return clientExtendedEventHandlerString;\n    }\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception {\n        if (getApplicationJarPath() !\u003d null \u0026\u0026 getClassLoader() \u003d\u003d null) {\n            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));\n            //update qsadmin to use the same\n            if (adminServer !\u003d null) {\n                adminServer.getServer().setClassLoader(getClassLoader());\n            }\n        }\n    }\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID() {\n        return pid;\n    }\n\n    public boolean isRawCommunicationLogging() {\n        return rawCommunicationLogging;\n    }\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {\n        this.rawCommunicationLogging \u003d rawCommunicationLogging;\n    }\n\n    public int getRawCommunicationMaxLength() {\n        return rawCommunicationMaxLength;\n    }\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {\n        this.rawCommunicationMaxLength \u003d rawCommunicationMaxLength;\n    }\n}\n",
    "package": "org.quickserver.net.server",
    "classname": "QuickServer",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_8Test.java",
    "test_prompt": "// QuickServer_8Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#suspendService()} method.\n*/\nclass QuickServer_8Test {",
    "method_signature": "suspendService()",
    "suffix": "8"
  },
  {
    "numberTests": "ten",
    "original_code": "// QuickServer.java\n/*\n * This file is part of the QuickServer library \n * Copyright (C) QuickServer.org\n *\n * Use, modification, copying and distribution of this software is subject to\n * the terms and conditions of the GNU Lesser General Public License. \n * You should have received a copy of the GNU LGP License along with this \n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\n *\n * For questions, suggestions, bug-reports, enhancement-requests etc.\n * visit http://www.quickserver.org\n *\n */\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n *  Main class of QuickServer library. This class is used to create\n *  multi client servers quickly.\n *  \u003cp\u003e\n *  Ones a client is connected, it creates {@link ClientHandler} object,\n *  which is run using any thread available from the pool of threads\n *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n *  handles the client. \u003cbr/\u003e\n *  QuickServer divides the application logic of its developer over eight\n *  class, \u003cbr\u003e\n *  \t\u003cul\u003e\n * \t\t\u003cli\u003eClientEventHandler\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client events [Optional Class].\n *  \t\t\u003cli\u003eClientCommandHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client character/string commands.\n *  \t\t\u003cli\u003eClientObjectHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - Object commands.\n * \t\t\u003cli\u003eClientBinaryHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - binary data.\n * \t\t\u003cli\u003eClientWriteHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n *  \t\t\u003cli\u003eClientAuthenticationHandler [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Used to Authencatet a client.\n *  \t\t\u003cli\u003eClientData [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Client data carrier (support class)\n * \t\t\u003cli\u003eClientExtendedEventHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles extended client events.\n *  \t\u003c/ul\u003e\n *\n *  [#] \u003d Any one of these have to be set based on default DataMode for input.\n *  The default DataMode for input is String so if not changes you will\n *  have to set ClientCommandHandler.\n *  \u003c/p\u003e\n *  \u003cp\u003e\n *   Eg:\n *  \u003ccode\u003e\u003cBLOCKQUOTE\u003e\u003cpre\u003e\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle \u003d \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer \u003d new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * \u003c/pre\u003e\u003c/BLOCKQUOTE\u003e\u003c/code\u003e\u003c/p\u003e\n *\n *  @version 1.4.8\n *  @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //Some variable are not initialised to any value because the\n    //default java value was desired initial value.\n    //\u0027dev \u0027 \u003d development build not yet final\n    //\u0027beta\u0027 \u003d test build all features\n    //change also in QSAdminMain\n    private final static String VER \u003d \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n        if (System.getProperty(\"org.quickserver.useOSLineSeparator\") !\u003d null \u0026\u0026 System.getProperty(\"org.quickserver.useOSLineSeparator\").equals(\"true\")) {\n            NEW_LINE \u003d System.getProperty(\"line.separator\");\n        } else {\n            NEW_LINE \u003d \"\\r\\n\";\n        }\n        String _pid \u003d ManagementFactory.getRuntimeMXBean().getName();\n        int i \u003d _pid.indexOf(\"@\");\n        pid \u003d _pid.substring(0, i);\n        System.out.print(\"Loading QuickServer v\" + getVersion() + \" [PID:\" + pid + \"]\");\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort \u003d 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName \u003d \"QuickServer\";\n\n    private long maxConnection \u003d -1;\n\n    //1 min socket timeout\n    private int socketTimeout \u003d 60 * 1000;\n\n    private String maxConnectionMsg \u003d \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg \u003d \"-ERR Timeout\";\n\n    private String maxAuthTryMsg \u003d \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry \u003d 5;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //--v1.2\n    //Logger for QuickServer\n    private static final Logger logger \u003d Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //for Service interface\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState \u003d Service.UNKNOWN;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.3\n    private QuickServerConfig config \u003d new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel \u003d \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel \u003d \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation \u003d false;\n\n    private boolean communicationLogging \u003d true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig \u003d config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km \u003d null;\n\n    private TrustManager[] tm \u003d null;\n\n    private boolean runningSecure \u003d false;\n\n    private SecureStoreManager secureStoreManager \u003d null;\n\n    private Exception exceptionInRun \u003d null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode \u003d true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN \u003d DataMode.STRING;\n\n    private DataMode defaultDataModeOUT \u003d DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging \u003d false;\n\n    private int rawCommunicationMaxLength \u003d 100;\n\n    static {\n        System.out.println(\" Done\");\n        //should be commented if not a patch release\n        //System.out.println(\"[Includes patch(#): t\u003d152\u0026p\u003d532]\");\n        //should be commented if not a dev release\n        //System.out.println(\"[Dev Build Date: Saturday, October 29, 2005]\");\n        logger.log(Level.FINE, \"PID: {0}\", pid);\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion() {\n        return VER;\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo() {\n        return getVersionNo(VER);\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver) {\n        //String ver \u003d getVersion();\n        float version \u003d 0;\n        //check if beta\n        int i \u003d ver.indexOf(\" \");\n        if (i \u003d\u003d -1)\n            i \u003d ver.length();\n        ver \u003d ver.substring(0, i);\n        //check for sub version\n        i \u003d ver.indexOf(\".\");\n        if (i !\u003d -1) {\n            int j \u003d ver.indexOf(\".\", i);\n            if (j !\u003d -1) {\n                ver \u003d ver.substring(0, i) + \".\" + MyString.replaceAll(ver.substring(i + 1), \".\", \"\");\n            }\n        }\n        try {\n            version \u003d Float.parseFloat(ver);\n        } catch (NumberFormatException e) {\n            throw new RuntimeException(\"Corrupt QuickServer\");\n        }\n        return version;\n    }\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine() {\n        return NEW_LINE;\n    }\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString() {\n        return serverName + \" : \" + getPort();\n    }\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n        setClientCommandHandler(commandHandler);\n    }\n\n    /**\n     * Creates a new server at \u003ccode\u003eport\u003c/code\u003e with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n        //send to another constructor\n        this(commandHandler);\n        setPort(port);\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException {\n        logger.log(Level.FINE, \"Starting {0}\", getName());\n        if (isClosed() \u003d\u003d false) {\n            logger.log(Level.WARNING, \"Server {0} already running.\", getName());\n            throw new AppException(\"Server \" + getName() + \" already running.\");\n        }\n        blockingMode \u003d getBasicConfig().getServerMode().getBlocking();\n        if (getSecure().isEnable() \u0026\u0026 blockingMode \u003d\u003d false) {\n            //TODO we need to fix this..\n            logger.warning(\"QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode.\");\n            blockingMode \u003d true;\n            getBasicConfig().getServerMode().setBlocking(blockingMode);\n        }\n        if (serverBanner \u003d\u003d null) {\n            serverBanner \u003d \"\\n-------------------------------\" + \"\\n Name : \" + getName() + \"\\n Port : \" + getPort() + \"\\n-------------------------------\\n\";\n            logger.finest(\"Default Server Banner Generated\");\n        }\n        try {\n            loadApplicationClasses();\n            //load class from Advanced Settings\n            Class clientIdentifierClass \u003d getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);\n            clientIdentifier \u003d (ClientIdentifier) clientIdentifierClass.newInstance();\n            clientIdentifier.setQuickServer(QuickServer.this);\n            //load class from ObjectPoolConfig\n            Class poolManagerClass \u003d getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);\n            poolManager \u003d (PoolManager) poolManagerClass.newInstance();\n            //load class QSObjectPoolMaker\n            Class qsObjectPoolMakerClass \u003d getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);\n            qsObjectPoolMaker \u003d (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();\n            loadServerHooksClasses();\n            processServerHooks(ServerHook.PRE_STARTUP);\n            if (getSecure().isLoad() \u003d\u003d true)\n                //v1.4.0\n                loadSSLContext();\n            loadBusinessLogic();\n        } catch (ClassNotFoundException e) {\n            logger.log(Level.SEVERE, \"Could not load class/s: \" + e, e);\n            throw new AppException(\"Could not load class/s : \" + e);\n        } catch (InstantiationException e) {\n            logger.log(Level.SEVERE, \"Could not instantiate class/s: \" + e, e);\n            throw new AppException(\"Could not instantiate class/s: \" + e);\n        } catch (IllegalAccessException e) {\n            logger.log(Level.SEVERE, \"Illegal access to class/s: \" + e, e);\n            throw new AppException(\"Illegal access to class/s: \" + e);\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"IOException: \" + e, e);\n            throw new AppException(\"IOException: \" + e);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Exception: \" + e, e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Exception : \" + e);\n        }\n        //v1.3.3\n        if (getSecurityManagerClass() !\u003d null) {\n            System.setSecurityManager(getSecurityManager());\n        }\n        setServiceState(Service.INIT);\n        t \u003d new Thread(this, \"QuickServer - \" + getName());\n        t.start();\n        do {\n            Thread.yield();\n        } while (getServiceState() \u003d\u003d Service.INIT);\n        if (getServiceState() !\u003d Service.RUNNING) {\n            if (exceptionInRun !\u003d null)\n                throw new AppException(\"Could not start server \" + getName() + \"! Details: \" + exceptionInRun);\n            else\n                throw new AppException(\"Could not start server \" + getName());\n        }\n        lastStartTime \u003d new java.util.Date();\n        logger.log(Level.FINE, \"Started {0}, Date: {1}\", new Object[] { getName(), lastStartTime });\n    }\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException {\n        processServerHooks(ServerHook.PRE_SHUTDOWN);\n        logger.log(Level.WARNING, \"Stopping {0}\", getName());\n        stopServer \u003d true;\n        Socket death \u003d null;\n        if (isClosed() \u003d\u003d true) {\n            logger.log(Level.WARNING, \"Server {0} is not running!\", getName());\n            throw new AppException(\"Server \" + getName() + \" is not running!\");\n        }\n        try {\n            if (getBlockingMode() \u003d\u003d true) {\n                if (getSecure().isEnable() \u003d\u003d false) {\n                    death \u003d new Socket(server.getInetAddress(), server.getLocalPort());\n                    death.getInputStream().read();\n                    death.close();\n                } else {\n                    death \u003d getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());\n                    Thread.sleep(100);\n                    death.close();\n                }\n            }\n            if (serverSocketChannel !\u003d null) {\n                serverSocketChannel.close();\n            }\n        } catch (IOException e) {\n            logger.log(Level.FINE, \"IOError stopping {0}: {1}\", new Object[] { getName(), e });\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error stopping {0}: {1}\", new Object[] { getName(), e });\n            throw new AppException(\"Error in stopServer \" + getName() + \": \" + e);\n        }\n        for (int i \u003d 0; getServiceState() !\u003d Service.STOPPED; i++) {\n            try {\n                Thread.sleep(60);\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error waiting for {0} to fully stop. Error: {1}\", new Object[] { getName(), e });\n            }\n            if (i \u003e 1000) {\n                logger.severe(\"Server was not stopped even after 10sec.. will terminate now.\");\n                System.exit(-1);\n            }\n        }\n        if (adminServer \u003d\u003d null || getQSAdminServer().getServer() !\u003d this) {\n            //so this is not qsadmin\n            setClassLoader(null);\n        }\n        logger.log(Level.INFO, \"Stopped {0}\", getName());\n    }\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException {\n        stopServer();\n        startServer();\n    }\n\n    /**\n     * Returns the name of the QuickServer. Default is \u0027QuickServer\u0027.\n     * @see #setName\n     */\n    public String getName() {\n        return serverName;\n    }\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name) {\n        serverName \u003d name;\n        logger.log(Level.FINEST, \"Set to : {0}\", name);\n    }\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner() {\n        return serverBanner;\n    }\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. \u003cbr\u003e\u0026nbsp;\u003cbr\u003e\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner) {\n        serverBanner \u003d banner;\n        logger.log(Level.FINEST, \"Set to : {0}\", banner);\n    }\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port) {\n        if (port \u003c 0) {\n            throw new IllegalArgumentException(\"Port number can not be less than 0!\");\n        }\n        serverPort \u003d port;\n        logger.log(Level.FINEST, \"Set to {0}\", port);\n    }\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort() {\n        if (isClosed() \u003d\u003d false) {\n            return server.getLocalPort();\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            return serverPort;\n        } else {\n            int _port \u003d getSecure().getPort();\n            if (_port \u003d\u003d -1)\n                return serverPort;\n            else\n                return _port;\n        }\n    }\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler) {\n        clientCommandHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler() {\n        return clientCommandHandlerString;\n    }\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data) {\n        this.clientDataString \u003d data;\n        logger.log(Level.FINEST, \"Set to {0}\", data);\n    }\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData() {\n        return clientDataString;\n    }\n\n    /**\n     * Sets the client socket\u0027s timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time) {\n        if (time \u003e 0)\n            socketTimeout \u003d time;\n        else\n            socketTimeout \u003d 0;\n        logger.log(Level.FINEST, \"Set to {0}\", socketTimeout);\n    }\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout() {\n        return socketTimeout;\n    }\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry) {\n        maxAuthTry \u003d authTry;\n        logger.log(Level.FINEST, \"Set to {0}\", authTry);\n    }\n\n    /**\n     * Returns max allowed login attempts. Default is \u003ccode\u003e5\u003c/code\u003e.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry() {\n        return maxAuthTry;\n    }\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg) {\n        maxAuthTryMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg() {\n        return maxAuthTryMsg;\n    }\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg) {\n        timeoutMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg() {\n        return timeoutMsg;\n    }\n\n    private TheClient initTheClient() {\n        TheClient theClient \u003d new TheClient();\n        theClient.setServer(QuickServer.this);\n        theClient.setTimeoutMsg(getTimeoutMsg());\n        //v1.2\n        theClient.setMaxAuthTry(getMaxAuthTry());\n        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());\n        theClient.setClientEventHandler(clientEventHandler);\n        //v1.4.6\n        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);\n        theClient.setClientCommandHandler(clientCommandHandler);\n        //v1.2\n        theClient.setClientObjectHandler(clientObjectHandler);\n        //v1.4\n        theClient.setClientBinaryHandler(clientBinaryHandler);\n        //v1.4.5\n        theClient.setClientWriteHandler(clientWriteHandler);\n        //v1.3\n        theClient.setAuthenticator(authenticator);\n        //v1.4.6\n        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);\n        theClient.setTimeout(socketTimeout);\n        theClient.setMaxConnectionMsg(maxConnectionMsg);\n        //v1.3.2\n        theClient.setCommunicationLogging(getCommunicationLogging());\n        return theClient;\n    }\n\n    public void run() {\n        exceptionInRun \u003d null;\n        TheClient theClient \u003d initTheClient();\n        try {\n            stopServer \u003d false;\n            closeAllPools();\n            initAllPools();\n            makeServerSocket();\n            //print banner\n            System.out.println(serverBanner);\n            //v1.2\n            setServiceState(Service.RUNNING);\n            //v1.3.3\n            processServerHooks(ServerHook.POST_STARTUP);\n            if (getBlockingMode() \u003d\u003d false) {\n                runNonBlocking(theClient);\n                if (stopServer \u003d\u003d true) {\n                    logger.log(Level.FINEST, \"Closing selector for {0}\", getName());\n                    selector.close();\n                }\n                return;\n            } else {\n                runBlocking(theClient);\n            }\n        } catch (BindException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"{0} BindException for Port {1} @ {2} : {3}\", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });\n        } catch (javax.net.ssl.SSLException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"SSLException {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (IOException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"IOError {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (Exception e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"Error {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } finally {\n            if (getBlockingMode() \u003d\u003d true) {\n                logger.log(Level.WARNING, \"Closing {0}\", getName());\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            } else if (getBlockingMode() \u003d\u003d false \u0026\u0026 exceptionInRun !\u003d null) {\n                logger.log(Level.WARNING, \"Closing {0} - Had Error: {1}\", new Object[] { getName(), exceptionInRun });\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        if (serverSocketChannel !\u003d null)\n                            serverSocketChannel.close();\n                        if (server !\u003d null)\n                            server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n        }\n    }\n\n    //end of run\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnection \u003d maxConnection;\n        else\n            this.maxConnection \u003d maxConnection;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnection);\n    }\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection() {\n        return maxConnection;\n    }\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount() {\n        if (clientHandlerPool !\u003d null) {\n            try {\n                return getClientHandlerPool().getNumActive();\n            } catch (Exception e) {\n                return 0;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : \u003ccode\u003e-ERR Server Busy. Max Connection Reached\u003c/code\u003e\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n        else\n            this.maxConnectionMsg \u003d maxConnectionMsg;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnectionMsg);\n    }\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg() {\n        return maxConnectionMsg;\n    }\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException {\n        ipAddr \u003d InetAddress.getByName(bindAddr);\n        logger.log(Level.FINEST, \"Set to {0}\", bindAddr);\n    }\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr() {\n        if (ipAddr \u003d\u003d null) {\n            try {\n                ipAddr \u003d InetAddress.getByName(\"0.0.0.0\");\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Unable to create default ip(0.0.0.0) : {0}\", e);\n                throw new RuntimeException(\"Error: Unable to find servers own ip : \" + e);\n            }\n        }\n        return ipAddr;\n    }\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects) {\n        this.storeObjects \u003d storeObjects;\n    }\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return \u003ccode\u003enull\u003c/code\u003e.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects() {\n        return storeObjects;\n    }\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port) {\n        getQSAdminServer().getServer().setPort(port);\n    }\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort() {\n        return getQSAdminServer().getServer().getPort();\n    }\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator) {\n        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);\n    }\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator() {\n        return getQSAdminServer().getServer().getAuthenticator();\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException {\n        getQSAdminServer().setClientAuthenticationHandler(authenticator);\n        getQSAdminServer().startServer(port);\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException {\n        getQSAdminServer().startServer();\n    }\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer() {\n        if (adminServer \u003d\u003d null)\n            adminServer \u003d new QSAdminServer(QuickServer.this);\n        return adminServer;\n    }\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer) {\n        if (adminServer \u003d\u003d null)\n            this.adminServer \u003d adminServer;\n    }\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed() {\n        if (server \u003d\u003d null)\n            return true;\n        return server.isClosed();\n    }\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer\u0027s own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger() {\n        if (appLogger !\u003d null)\n            return appLogger;\n        return logger;\n    }\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger) {\n        this.appLogger \u003d appLogger;\n    }\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler) {\n        clientObjectHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler() {\n        return clientObjectHandlerString;\n    }\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n        if (formatter \u003d\u003d null)\n            return;\n        consoleLoggingformatter \u003d formatter;\n        java.util.logging.Formatter conformatter \u003d (java.util.logging.Formatter) getClass(formatter, true).newInstance();\n        Logger jdkLogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d jdkLogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                handlers[index].setFormatter(conformatter);\n            }\n        }\n        logger.log(Level.FINEST, \"Set to {0}\", formatter);\n    }\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter() {\n        return consoleLoggingformatter;\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MiniFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to logging.MiniFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MicroFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to MicroFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        boolean isConsole \u003d true;\n        try {\n            if (System.console() \u003d\u003d null) {\n                isConsole \u003d false;\n            }\n        } catch (Throwable e) {\n            //ignore\n        }\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                if (isConsole \u003d\u003d false \u0026\u0026 level !\u003d Level.OFF) {\n                    System.out.println(\"QuickServer: You do not have a console.. so turning console logger off..\");\n                    level \u003d Level.OFF;\n                }\n                if (level \u003d\u003d Level.OFF) {\n                    logger.info(\"QuickServer: Removing console handler.. \");\n                    rlogger.removeHandler(handlers[index]);\n                    handlers[index].setLevel(level);\n                    handlers[index].close();\n                } else {\n                    handlers[index].setLevel(level);\n                }\n            }\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            consoleLoggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            consoleLoggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            consoleLoggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            consoleLoggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            consoleLoggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            consoleLoggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            consoleLoggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            consoleLoggingLevel \u003d \"OFF\";\n        else\n            consoleLoggingLevel \u003d \"UNKNOWN\";\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel() {\n        return consoleLoggingLevel;\n    }\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            handlers[index].setLevel(level);\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            loggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            loggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            loggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            loggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            loggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            loggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            loggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            loggingLevel \u003d \"OFF\";\n        else\n            loggingLevel \u003d \"UNKNOWN\";\n        consoleLoggingLevel \u003d loggingLevel;\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    //*** Start of Service interface methods\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError() {\n        return serviceError;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param) {\n        serviceError \u003d null;\n        try {\n            initServer(param);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig) {\n        serviceError \u003d null;\n        try {\n            initServer(qsConfig);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING)\n            return false;\n        try {\n            startServer();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.STOPPED)\n            return false;\n        try {\n            stopServer();\n            clearAllPools();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING) {\n            suspendMaxConnection \u003d maxConnection;\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n            maxConnection \u003d 0;\n            maxConnectionMsg \u003d \"Service is suspended.\";\n            setServiceState(Service.SUSPENDED);\n            logger.log(Level.INFO, \"Service {0} is suspended.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.SUSPENDED) {\n            maxConnection \u003d suspendMaxConnection;\n            maxConnectionMsg \u003d suspendMaxConnectionMsg;\n            setServiceState(Service.RUNNING);\n            logger.log(Level.INFO, \"Service {0} resumed.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info() {\n        serviceError \u003d null;\n        StringBuilder buf \u003d new StringBuilder();\n        buf.append(getName()).append(\"\\n\");\n        buf.append(getBindAddr().getHostAddress()).append(\" \");\n        buf.append(getPort()).append(\"\\n\");\n        return buf.toString();\n    }\n\n    // *** End of Service interface methods\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException {\n        QuickServerConfig qsConfig \u003d null;\n        try {\n            qsConfig \u003d ConfigReader.read((String) param[0]);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not init server from xml file {0} : {1}\", new Object[] { new File((String) param[0]).getAbsolutePath(), e });\n            throw new AppException(\"Could not init server from xml file\", e);\n        }\n        initServer(qsConfig);\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {\n        setConfig(qsConfig);\n        try {\n            configQuickServer();\n            loadApplicationClasses();\n            //start InitServerHooks\n            InitServerHooks ish \u003d getConfig().getInitServerHooks();\n            if (ish !\u003d null) {\n                Iterator iterator \u003d ish.iterator();\n                String initServerHookClassName \u003d null;\n                Class initServerHookClass \u003d null;\n                InitServerHook initServerHook \u003d null;\n                while (iterator.hasNext()) {\n                    initServerHookClassName \u003d (String) iterator.next();\n                    initServerHookClass \u003d getClass(initServerHookClassName, true);\n                    initServerHook \u003d (InitServerHook) initServerHookClass.newInstance();\n                    logger.log(Level.INFO, \"Loaded init server hook: {0}\", initServerHookClassName);\n                    logger.log(Level.FINE, \"Init server hook info: {0}\", initServerHook.info());\n                    initServerHook.handleInit(QuickServer.this);\n                }\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not load init server hook: {0}\", e);\n            logger.log(Level.WARNING, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Could not load init server hook\", e);\n        }\n        setServiceState(Service.INIT);\n        logger.log(Level.FINEST, \"\\r\\n{0}\", MyString.getSystemInfo(getVersion()));\n    }\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState() {\n        return serviceState;\n    }\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state) {\n        serviceState \u003d state;\n    }\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp) {\n        if (temp.equals(\"SEVERE\"))\n            qs.setConsoleLoggingLevel(Level.SEVERE);\n        else if (temp.equals(\"WARNING\"))\n            qs.setConsoleLoggingLevel(Level.WARNING);\n        else if (temp.equals(\"INFO\"))\n            qs.setConsoleLoggingLevel(Level.INFO);\n        else if (temp.equals(\"CONFIG\"))\n            qs.setConsoleLoggingLevel(Level.CONFIG);\n        else if (temp.equals(\"FINE\"))\n            qs.setConsoleLoggingLevel(Level.FINE);\n        else if (temp.equals(\"FINER\"))\n            qs.setConsoleLoggingLevel(Level.FINER);\n        else if (temp.equals(\"FINEST\"))\n            qs.setConsoleLoggingLevel(Level.FINEST);\n        else if (temp.equals(\"OFF\"))\n            qs.setConsoleLoggingLevel(Level.OFF);\n        else\n            logger.log(Level.WARNING, \"unknown level {0}\", temp);\n    }\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception {\n        QuickServer qs \u003d QuickServer.this;\n        //v1.3\n        qs.setConfig(config);\n        qs.setBasicConfig(config);\n        String temp \u003d config.getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        temp \u003d null;\n        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        //v1.3.3\n        qs.setSecurityManagerClass(config.getSecurityManagerClass());\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        temp \u003d config.getApplicationJarPath();\n        if (temp !\u003d null) {\n            File ajp \u003d new File(temp);\n            if (ajp.isAbsolute() \u003d\u003d false) {\n                temp \u003d config.getConfigFile();\n                ajp \u003d new File(temp);\n                temp \u003d ajp.getParent() + File.separatorChar + config.getApplicationJarPath();\n                config.setApplicationJarPath(temp);\n                temp \u003d null;\n            }\n            qs.setApplicationJarPath(config.getApplicationJarPath());\n            //set path also to QSAdmin\n            if (config.getQSAdminServerConfig() !\u003d null) {\n                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());\n            }\n        }\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception {\n        QuickServer qs \u003d getQSAdminServer().getServer();\n        qs.setBasicConfig(config);\n        //set the Logging Level to same as main QS\n        //config.getConsoleLoggingLevel();\n        String temp \u003d getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        //set the Logging Formatter to same as main QS\n        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());\n        //v1.4.6\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        //v1.4.6\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());\n        //v1.3.2\n        if (config.getCommandShellEnable().equals(\"true\"))\n            getQSAdminServer().setShellEnable(true);\n        getQSAdminServer().setPromptName(config.getCommandShellPromptName());\n        //v1.3.3\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception {\n        configQuickServer(getConfig());\n        if (getConfig().getQSAdminServerConfig() !\u003d null) {\n            configQuickServer(getConfig().getQSAdminServerConfig());\n        }\n    }\n\n    /**\n     * Usage: QuickServer [-options]\u003cbr/\u003e\n     * Where options include:\u003cbr/\u003e\n     *   -about\t\tOpens About Dialogbox\u003cbr/\u003e\n     *   -load \u003cxml_config_file\u003e [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File \u003cnew_file_name\u003e\n     */\n    public static void main(String[] args) {\n        try {\n            if (args.length \u003e\u003d 1) {\n                if (args[0].equals(\"-about\")) {\n                    org.quickserver.net.server.gui.About.main(null);\n                } else if (args[0].equals(\"-load\") \u0026\u0026 args.length \u003e\u003d 2) {\n                    QuickServer qs \u003d QuickServer.load(args[1]);\n                    if (qs !\u003d null)\n                        handleOptions(args, qs);\n                } else {\n                    System.out.println(printUsage());\n                }\n            } else {\n                System.out.println(printUsage());\n                org.quickserver.net.server.gui.About.showAbout();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException {\n        QuickServer qs \u003d new QuickServer();\n        Object[] config \u003d new Object[] { xml };\n        qs.initServer(config);\n        qs.startServer();\n        if (qs.getConfig().getQSAdminServerConfig() !\u003d null) {\n            qs.startQSAdminServer();\n        }\n        return qs;\n    }\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage() {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"QuickServer - Java library/framework for creating robust multi-client TCP servers.\\n\");\n        sb.append(\"Copyright (C) QuickServer.org\\n\\n\");\n        sb.append(\"Usage: QuickServer [-options]\\n\");\n        sb.append(\"Where options include:\\n\");\n        sb.append(\"  -about\\t\" + \"Opens About Dialog box\\n\");\n        sb.append(\"  -load \u003cxml_config_file\u003e [load-options]\\t\" + \"Loads the server from xml file.\\n\");\n        sb.append(\"  Where load-options include:\\n\");\n        sb.append(\"     -fullXML2File \u003cfile_name\u003e\\t\" + \"Dumps the Full XML configuration of the QuickServer loaded.\\n\");\n        return sb.toString();\n    }\n\n    private static void handleOptions(String[] args, QuickServer quickserver) {\n        if (args.length \u003c 3)\n            return;\n        if (args[2].equals(\"-fullXML2File\") \u0026\u0026 args.length \u003e\u003d 4) {\n            File file \u003d new File(args[3]);\n            logger.log(Level.INFO, \"Writing full xml configuration to file: {0}\", file.getAbsolutePath());\n            try {\n                TextFile.write(file, quickserver.getConfig().toXML(null));\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error writing full xml configuration: {0}\", e);\n            }\n        }\n    }\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception {\n        try {\n            if (pool !\u003d null)\n                getClientPool().clear();\n            if (clientHandlerPool !\u003d null)\n                getClientHandlerPool().clear();\n            if (getClientDataPool() !\u003d null)\n                getClientDataPool().clear();\n            if (getDBPoolUtil() !\u003d null)\n                getDBPoolUtil().clean();\n            if (byteBufferPool !\u003d null)\n                getByteBufferPool().clear();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error: {0}\", e);\n            throw e;\n        }\n    }\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception {\n        if (pool \u003d\u003d null \u0026\u0026 clientHandlerPool \u003d\u003d null \u0026\u0026 getClientDataPool() \u003d\u003d null \u0026\u0026 getDBPoolUtil() \u003d\u003d null \u0026\u0026 byteBufferPool \u003d\u003d null) {\n            return;\n        }\n        logger.log(Level.FINE, \"Closing pools for {0}\", getName());\n        try {\n            if (pool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {\n                logger.finer(\"Closing ClientThread pool.\");\n                getClientPool().close();\n            }\n            if (clientHandlerPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientHandlerPool())) {\n                logger.finer(\"Closing ClientHandler pool.\");\n                getClientHandlerPool().close();\n            }\n            if (getClientDataPool() !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientDataPool())) {\n                logger.finer(\"Closing ClientData pool.\");\n                getClientDataPool().close();\n            }\n            if (getDBPoolUtil() !\u003d null) {\n                logger.finer(\"Closing DB pool.\");\n                getDBPoolUtil().clean();\n            }\n            if (byteBufferPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getByteBufferPool())) {\n                logger.finer(\"Closing ByteBuffer pool.\");\n                getByteBufferPool().close();\n            }\n            logger.log(Level.FINE, \"Closed pools for {0}\", getName());\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error closing pools for {0}: {1}\", new Object[] { getName(), e });\n            throw e;\n        }\n    }\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception {\n        logger.fine(\"Creating pools\");\n        if (getBlockingMode() \u003d\u003d false) {\n            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());\n        }\n        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());\n        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());\n        //check if client data is poolable\n        if (clientDataClass !\u003d null) {\n            try {\n                clientData \u003d (ClientData) clientDataClass.newInstance();\n                if (PoolableObject.class.isInstance(clientData) \u003d\u003d true) {\n                    PoolableObject po \u003d (PoolableObject) clientData;\n                    if (po.isPoolable() \u003d\u003d true) {\n                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());\n                    } else {\n                        clientDataPool \u003d null;\n                        logger.fine(\"ClientData is not poolable!\");\n                    }\n                }\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error: {0}\", e);\n                throw e;\n            }\n        }\n        try {\n            makeDBObjectPool();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error in makeDBObjectPool() : {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw e;\n        }\n        logger.fine(\"Created pools\");\n    }\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool() {\n        if (pool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientPool available yet!\");\n        return pool;\n    }\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientHandler pool\");\n        PoolableObjectFactory factory \u003d new ClientHandlerObjectFactory(getBlockingMode());\n        clientHandlerPool \u003d poolManager.makeClientHandlerPool(factory, opConfig);\n        poolManager.initPool(clientHandlerPool, opConfig);\n        clientHandlerPool \u003d makeQSObjectPool(clientHandlerPool);\n        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool() {\n        if (clientHandlerPool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientHandler Pool available yet!\");\n        return clientHandlerPool;\n    }\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config) {\n        this.config \u003d config;\n    }\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig() {\n        return config;\n    }\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientData pool\");\n        clientDataPool \u003d poolManager.makeClientDataPool(factory, opConfig);\n        poolManager.initPool(clientDataPool, opConfig);\n        clientDataPool \u003d makeQSObjectPool(clientDataPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool() {\n        return clientDataPool;\n    }\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return \u003ccode\u003enull\u003c/code\u003e\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil() {\n        return dBPoolUtil;\n    }\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {\n        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);\n    }\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception {\n        if (getConfig().getDBObjectPoolConfig() !\u003d null) {\n            logger.fine(\"Creating DBObject Pool\");\n            //logger.finest(\"Got:\\n\"+getConfig().getDBObjectPoolConfig().toXML(null));\n            Class dbPoolUtilClass \u003d getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);\n            dBPoolUtil \u003d (DBPoolUtil) dbPoolUtilClass.newInstance();\n            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());\n            dBPoolUtil.initPool();\n        }\n    }\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id) {\n        return clientIdentifier.findFirstClientById(id);\n    }\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  \u003ccode\u003e\u003cpre\u003e\n     *    Eg:\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tObject syncObj \u003d quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator \u003d quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tClientIdentifier clientIdentifier \u003d quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator \u003d clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    \u003c/code\u003e\u003c/pre\u003e\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient() {\n        return clientIdentifier.findAllClient();\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern) {\n        return clientIdentifier.findAllClientById(pattern);\n    }\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key) {\n        return clientIdentifier.findClientByKey(key);\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern) {\n        return clientIdentifier.findAllClientByKey(pattern);\n    }\n\n    /**\n     * Sets next client has a trusted client.\n     * \u003cp\u003eThis will skip any authentication and will not set any timeout.\u003c/p\u003e\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted() {\n        setSkipValidation(true);\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation() {\n        return skipValidation;\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation) {\n        skipValidation \u003d validation;\n    }\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging) {\n        this.communicationLogging \u003d communicationLogging;\n    }\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging() {\n        return communicationLogging;\n    }\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass) {\n        if (securityManagerClass !\u003d null)\n            this.securityManagerClass \u003d securityManagerClass;\n    }\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass() {\n        return securityManagerClass;\n    }\n\n    public SecurityManager getSecurityManager() throws AppException {\n        if (getSecurityManagerClass() \u003d\u003d null)\n            return null;\n        SecurityManager sm \u003d null;\n        try {\n            sm \u003d (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();\n        } catch (ClassNotFoundException e) {\n            throw new AppException(e.getMessage());\n        } catch (InstantiationException e) {\n            throw new AppException(e.getMessage());\n        } catch (IllegalAccessException e) {\n            throw new AppException(e.getMessage());\n        }\n        return sm;\n    }\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {\n        this.accessConstraintConfig \u003d accessConstraintConfig;\n    }\n\n    /**\n     * Returns Access constraints if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig() {\n        return accessConstraintConfig;\n    }\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader) {\n        this.classLoader \u003d classLoader;\n        Thread.currentThread().setContextClassLoader(classLoader);\n    }\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader() {\n        return classLoader;\n    }\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException {\n        if (name \u003d\u003d null)\n            throw new IllegalArgumentException(\"Class name can\u0027t be null!\");\n        logger.log(Level.FINEST, \"Class: {0}, reload: {1}\", new Object[] { name, reload });\n        if (reload \u003d\u003d true \u0026\u0026 classLoader !\u003d null) {\n            return classLoader.loadClass(name);\n        } else if (reload \u003d\u003d true \u0026\u0026 classLoader \u003d\u003d null \u0026\u0026 this.getClass().getClassLoader() !\u003d null) {\n            return this.getClass().getClassLoader().loadClass(name);\n        } else if (reload \u003d\u003d false \u0026\u0026 classLoader !\u003d null) {\n            return Class.forName(name, true, classLoader);\n        } else /*if(reload\u003d\u003dfalse \u0026\u0026 classLoader\u003d\u003dnull)*/\n        {\n            return Class.forName(name, true, this.getClass().getClassLoader());\n        }\n    }\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath) {\n        this.applicationJarPath \u003d applicationJarPath;\n    }\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath() {\n        return applicationJarPath;\n    }\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks) {\n        this.serverHooks \u003d serverHooks;\n    }\n\n    /**\n     * Returns ServerHooks if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks() {\n        if (serverHooks \u003d\u003d null)\n            serverHooks \u003d new ServerHooks();\n        return serverHooks;\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses() {\n        if (getServerHooks() \u003d\u003d null)\n            return;\n        listOfServerHooks \u003d new ArrayList();\n        ServerHook serverHook \u003d null;\n        String serverHookClassName \u003d null;\n        Class serverHookClass \u003d null;\n        //add system hooks\n        serverHook \u003d new GhostSocketReaper();\n        serverHook.initHook(QuickServer.this);\n        listOfServerHooks.add(serverHook);\n        ghostSocketReaper \u003d (GhostSocketReaper) serverHook;\n        //add user hooks if any\n        Iterator iterator \u003d getServerHooks().iterator();\n        while (iterator.hasNext()) {\n            serverHookClassName \u003d (String) iterator.next();\n            try {\n                serverHookClass \u003d getClass(serverHookClassName, true);\n                serverHook \u003d (ServerHook) serverHookClass.newInstance();\n                serverHook.initHook(QuickServer.this);\n                listOfServerHooks.add(serverHook);\n                logger.log(Level.INFO, \"Loaded server hook: {0}\", serverHookClassName);\n                logger.log(Level.FINE, \"Server hook info: {0}\", serverHook.info());\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Could not load server hook [{0}]: {1}\", new Object[] { serverHookClassName, e });\n                logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            }\n        }\n        //end of while\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event) {\n        if (listOfServerHooks \u003d\u003d null) {\n            logger.warning(\"listOfServerHooks was null!\");\n            return;\n        }\n        ServerHook serverHook \u003d null;\n        boolean result \u003d false;\n        Iterator iterator \u003d listOfServerHooks.iterator();\n        String hooktype \u003d \"UNKNOWN\";\n        switch(event) {\n            case ServerHook.PRE_STARTUP:\n                hooktype \u003d \"PRE_STARTUP\";\n                break;\n            case ServerHook.POST_STARTUP:\n                hooktype \u003d \"POST_STARTUP\";\n                break;\n            case ServerHook.PRE_SHUTDOWN:\n                hooktype \u003d \"PRE_SHUTDOWN\";\n                break;\n            case ServerHook.POST_SHUTDOWN:\n                hooktype \u003d \"POST_SHUTDOWN\";\n                break;\n        }\n        while (iterator.hasNext()) {\n            serverHook \u003d (ServerHook) iterator.next();\n            try {\n                result \u003d serverHook.handleEvent(event);\n            } catch (Exception e) {\n                result \u003d false;\n                logger.log(Level.WARNING, \"Error invoking {0} hook [{1}]: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });\n            }\n            logger.log(Level.FINE, \"Invoked {0} hook [{1}] was: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), result });\n        }\n    }\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone() {\n        Object object \u003d null;\n        try {\n            object \u003d super.clone();\n            QuickServer _qs \u003d (QuickServer) object;\n            _qs.setQSAdminServer(new QSAdminServer(_qs));\n        } catch (CloneNotSupportedException e) {\n            //should not happ\n            logger.log(Level.WARNING, \"Error cloning : {0}\", e);\n        }\n        return object;\n    }\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure) {\n        this.secure \u003d secure;\n    }\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure() {\n        if (secure \u003d\u003d null)\n            secure \u003d new Secure();\n        return secure;\n    }\n\n    /**\n     * \u003cp\u003eReturns if the server is running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure() {\n        return runningSecure;\n    }\n\n    /**\n     * \u003cp\u003eSets the server mode if its running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure) {\n        this.runningSecure \u003d runningSecure;\n    }\n\n    private File makeAbsoluteToConfig(String fileName) {\n        Assertion.affirm(fileName !\u003d null, \"FileName can\u0027t be null\");\n        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());\n    }\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException {\n        server \u003d null;\n        logger.log(Level.FINEST, \"Binding {0} to IP: {1}\", new Object[] { getName(), getBindAddr() });\n        InetSocketAddress bindAddress \u003d new InetSocketAddress(getBindAddr(), getPort());\n        try {\n            NetworkInterface ni \u003d NetworkInterface.getByInetAddress(getBindAddr());\n            if (ni !\u003d null) {\n                logger.fine(\"NetworkInterface: \" + ni);\n            }\n        } catch (Exception igrnore) {\n            /*ignore*/\n        } catch (Error igrnore) {\n            /*ignore*/\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Making a normal ServerSocket for {0}\", getName());\n            setRunningSecure(false);\n            if (getBlockingMode() \u003d\u003d false) {\n                //for non-blocking\n                serverSocketChannel \u003d ServerSocketChannel.open();\n                server \u003d serverSocketChannel.socket();\n                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n            } else {\n                //for blocking\n                server \u003d new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n            }\n        } else {\n            try {\n                logger.log(Level.FINE, \"Making a secure ServerSocket for {0}\", getName());\n                getSSLContext();\n                setRunningSecure(true);\n                if (getBlockingMode() \u003d\u003d false) {\n                    logger.log(Level.FINE, \"Making a secure ServerSocketChannel for {0}\", getName());\n                    //for non-blocking\n                    serverSocketChannel \u003d ServerSocketChannel.open();\n                    server \u003d serverSocketChannel.socket();\n                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n                } else {\n                    ServerSocketFactory ssf \u003d getSSLContext().getServerSocketFactory();\n                    SSLServerSocket serversocket \u003d (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());\n                    setRunningSecure(true);\n                    secureStoreManager.logSSLServerSocketInfo(serversocket);\n                    server \u003d serversocket;\n                    serverSocketChannel \u003d server.getChannel();\n                    if (serverSocketChannel \u003d\u003d null \u0026\u0026 getBlockingMode() \u003d\u003d false) {\n                        logger.warning(\"Secure Server does not support Channel! So will run in blocking mode.\");\n                        blockingMode \u003d false;\n                    }\n                }\n                //blocking\n            } catch (NoSuchAlgorithmException e) {\n                logger.log(Level.WARNING, \"NoSuchAlgorithmException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            } catch (KeyManagementException e) {\n                logger.log(Level.WARNING, \"KeyManagementException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            }\n        }\n        server.setReuseAddress(true);\n        int connectionTime \u003d 0;\n        int latency \u003d 0;\n        int bandwidth \u003d 0;\n        connectionTime \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();\n        latency \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();\n        bandwidth \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();\n        logger.log(Level.FINE, \"getPerformancePreferencesConnectionTime : {0}\", connectionTime);\n        logger.log(Level.FINE, \"getPerformancePreferencesLatency : {0}\", latency);\n        logger.log(Level.FINE, \"getPerformancePreferencesBandwidth : {0}\", bandwidth);\n        server.setPerformancePreferences(connectionTime, latency, bandwidth);\n        int clientSocketReceiveBufferSize \u003d getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();\n        if (clientSocketReceiveBufferSize \u003e 0) {\n            logger.log(Level.FINE, \"clientSocketReceiveBufferSize: {0}\", clientSocketReceiveBufferSize);\n            server.setReceiveBufferSize(clientSocketReceiveBufferSize);\n        }\n        if (getBlockingMode() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Server Mode {0} - Non Blocking\", getName());\n            if (selector \u003d\u003d null || selector.isOpen() \u003d\u003d false) {\n                logger.finest(\"Opening new selector\");\n                selector \u003d Selector.open();\n            } else {\n                logger.log(Level.FINEST, \"Reusing selector: {0}\", selector);\n            }\n            serverSocketChannel.configureBlocking(false);\n            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n            selector.wakeup();\n        } else {\n            logger.log(Level.FINE, \"Server Mode {0} - Blocking\", getName());\n        }\n    }\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {\n        Assertion.affirm(basicConfig !\u003d null, \"BasicServerConfig can\u0027t be null\");\n        this.basicConfig \u003d basicConfig;\n    }\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig() {\n        return basicConfig;\n    }\n\n    /**\n     * Loads the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException {\n        if (getSecure().isLoad() \u003d\u003d false) {\n            throw new IllegalStateException(\"Secure setting is not yet enabled for loading!\");\n        }\n        logger.info(\"Loading Secure Context..\");\n        km \u003d null;\n        tm \u003d null;\n        try {\n            String ssManager \u003d \"org.quickserver.security.SecureStoreManager\";\n            if (getSecure().getSecureStore() !\u003d null)\n                ssManager \u003d getSecure().getSecureStore().getSecureStoreManager();\n            Class secureStoreManagerClass \u003d getClass(ssManager, true);\n            secureStoreManager \u003d (SecureStoreManager) secureStoreManagerClass.newInstance();\n            km \u003d secureStoreManager.loadKeyManagers(getConfig());\n            logger.fine(\"KeyManager got\");\n            tm \u003d secureStoreManager.loadTrustManagers(getConfig());\n            logger.fine(\"TrustManager got\");\n            sslc \u003d secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());\n            sslc.init(km, tm, null);\n            logger.fine(\"SSLContext loaded\");\n        } catch (KeyStoreException e) {\n            logger.warning(\"KeyStoreException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchAlgorithmException e) {\n            logger.warning(\"NoSuchAlgorithmException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchProviderException e) {\n            logger.warning(\"NoSuchProviderException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (UnrecoverableKeyException e) {\n            logger.warning(\"UnrecoverableKeyException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (CertificateException e) {\n            logger.warning(\"CertificateException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (KeyManagementException e) {\n            logger.warning(\"KeyManagementException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (GeneralSecurityException e) {\n            logger.warning(\"GeneralSecurityException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (ClassNotFoundException e) {\n            logger.warning(\"ClassNotFoundException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (InstantiationException e) {\n            logger.warning(\"InstantiationException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (IllegalAccessException e) {\n            logger.warning(\"IllegalAccessException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        return getSSLContext(null);\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        if (protocol !\u003d null \u0026\u0026 secureStoreManager !\u003d null) {\n            SSLContext _sslc \u003d secureStoreManager.getSSLContext(protocol);\n            _sslc.init(km, tm, null);\n            return _sslc;\n        }\n        return sslc;\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext());\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext(protocol));\n    }\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler) {\n        clientBinaryHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler() {\n        return clientBinaryHandlerString;\n    }\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector) {\n        this.selector \u003d selector;\n    }\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector() {\n        return selector;\n    }\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception {\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        //long stime \u003d System.currentTimeMillis();\n        //long etime \u003d System.currentTimeMillis();\n        while (true) {\n            //etime \u003d System.currentTimeMillis();\n            //System.out.println(\"Time Taken: \"+(etime-stime));\n            client \u003d server.accept();\n            //stime \u003d System.currentTimeMillis();\n            if (linger \u003c 0) {\n                client.setSoLinger(false, 0);\n            } else {\n                client.setSoLinger(true, linger);\n            }\n            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                //low delay\u003d10\n                client.setTrafficClass(socketTrafficClass);\n            }\n            logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n            }\n            if (stopServer) {\n                //Client connected when server was about to be shutdown.\n                try {\n                    client.close();\n                } catch (Exception e) {\n                }\n                break;\n            }\n            if (checkAccessConstraint(client) \u003d\u003d false) {\n                continue;\n            }\n            //Check if max connection has reached\n            if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);\n            } else {\n                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);\n            }\n            theClient.setTrusted(getSkipValidation());\n            theClient.setSocket(client);\n            //mostly null\n            theClient.setSocketChannel(client.getChannel());\n            if (clientDataClass !\u003d null) {\n                if (getClientDataPool() \u003d\u003d null) {\n                    clientData \u003d (ClientData) clientDataClass.newInstance();\n                } else {\n                    clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                }\n                theClient.setClientData(clientData);\n            }\n            try {\n                _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                _chPolled.handleClient(theClient);\n            } catch (java.util.NoSuchElementException nsee) {\n                logger.warning(\"Could not borrow ClientHandler from pool. Error: \" + nsee);\n                logger.warning(\"Closing Socket [\" + client + \"] since no ClientHandler available.\");\n                client.close();\n            }\n            if (_chPolled !\u003d null) {\n                try {\n                    getClientPool().addClient(_chPolled, true);\n                } catch (java.util.NoSuchElementException nsee) {\n                    logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                    //logger.warning(\"Closing Socket [\"+client+\"] since no Thread available.\");\n                    //client.close();\n                    //returnClientHandlerToPool(_chPolled);\n                }\n                _chPolled \u003d null;\n            }\n            client \u003d null;\n            //reset it back\n            setSkipValidation(false);\n        }\n        //end of loop\n    }\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception {\n        int selectCount \u003d 0;\n        Iterator iterator \u003d null;\n        SelectionKey key \u003d null;\n        ServerSocketChannel serverChannel \u003d null;\n        SocketChannel socketChannel \u003d null;\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        boolean stopServerProcessed \u003d false;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        registerChannelRequestMap \u003d new HashMap();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        while (true) {\n            selectCount \u003d selector.select(500);\n            //selectCount \u003d selector.select();//for testing\n            //check for any pending registerChannel req.\n            synchronized (registerChannelRequestMap) {\n                if (registerChannelRequestMap.size() \u003e 0) {\n                    RegisterChannelRequest req \u003d null;\n                    Object hashkey \u003d null;\n                    iterator \u003d registerChannelRequestMap.keySet().iterator();\n                    while (iterator.hasNext()) {\n                        hashkey \u003d iterator.next();\n                        req \u003d (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);\n                        req.register(getSelector());\n                    }\n                    iterator \u003d null;\n                    registerChannelRequestMap.clear();\n                }\n                //if\n            }\n            //sync\n            if (stopServer \u003d\u003d true \u0026\u0026 stopServerProcessed \u003d\u003d false) {\n                logger.warning(\"Closing \" + getName());\n                serverSocketChannel.close();\n                stopServerProcessed \u003d true;\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.warning(\"Closed \" + getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n            if (stopServer \u003d\u003d false \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                logger.finest(\"Server must have re-started.. will break\");\n                break;\n            }\n            if (selectCount \u003d\u003d 0 \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                java.util.Set keyset \u003d selector.keys();\n                if (keyset.isEmpty() \u003d\u003d true \u0026\u0026 getClientCount() \u003c\u003d 0) {\n                    break;\n                } else {\n                    continue;\n                }\n            } else if (selectCount \u003d\u003d 0) {\n                continue;\n            }\n            iterator \u003d selector.selectedKeys().iterator();\n            while (iterator.hasNext()) {\n                key \u003d (SelectionKey) iterator.next();\n                if (key.isValid() \u003d\u003d false) {\n                    iterator.remove();\n                    continue;\n                }\n                if (key.isAcceptable() \u0026\u0026 stopServer \u003d\u003d false) {\n                    logger.finest(\"Key is Acceptable\");\n                    serverChannel \u003d (ServerSocketChannel) key.channel();\n                    socketChannel \u003d serverChannel.accept();\n                    if (socketChannel \u003d\u003d null) {\n                        iterator.remove();\n                        continue;\n                    }\n                    client \u003d socketChannel.socket();\n                    if (linger \u003c 0) {\n                        client.setSoLinger(false, 0);\n                    } else {\n                        client.setSoLinger(true, linger);\n                    }\n                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                        //low delay\u003d10\n                        client.setTrafficClass(socketTrafficClass);\n                    }\n                    logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                        logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n                    }\n                    if (checkAccessConstraint(client) \u003d\u003d false) {\n                        iterator.remove();\n                        continue;\n                    }\n                    socketChannel.configureBlocking(false);\n                    theClient.setTrusted(getSkipValidation());\n                    theClient.setSocket(socketChannel.socket());\n                    theClient.setSocketChannel(socketChannel);\n                    if (clientDataClass !\u003d null) {\n                        if (getClientDataPool() \u003d\u003d null) {\n                            clientData \u003d (ClientData) clientDataClass.newInstance();\n                        } else {\n                            //borrow a object from pool\n                            clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                        }\n                        theClient.setClientData(clientData);\n                    }\n                    //Check if max connection has reached\n                    if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                        theClient.setClientEvent(ClientEvent.MAX_CON);\n                    } else {\n                        theClient.setClientEvent(ClientEvent.ACCEPT);\n                    }\n                    try {\n                        _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                        logger.finest(\"Asking \" + _chPolled.getName() + \" to handle.\");\n                        _chPolled.handleClient(theClient);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.warning(\"Could not borrow ClientHandler Object from pool. Error: \" + nsee);\n                        logger.warning(\"Closing SocketChannel [\" + serverChannel.socket() + \"] since no ClientHandler available.\");\n                        socketChannel.close();\n                    }\n                    if (_chPolled !\u003d null) {\n                        try {\n                            getClientPool().addClient(_chPolled, true);\n                        } catch (java.util.NoSuchElementException nsee) {\n                            logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                            //logger.warning(\"Closing SocketChannel [\"+serverChannel.socket()+\"] since no Thread available.\");\n                            //socketChannel.close();\n                            //returnClientHandlerToPool(_chPolled);\n                        }\n                        _chPolled \u003d null;\n                    }\n                    socketChannel \u003d null;\n                    client \u003d null;\n                    //reset it back\n                    setSkipValidation(false);\n                } else if (key.isValid() \u0026\u0026 key.isReadable()) {\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Readable, removing OP_READ from interestOps for \" + _ch.getName());\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_READ));\n                        _ch.addEvent(ClientEvent.READ);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.READ);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (key.isValid() \u0026\u0026 key.isWritable()) {\n                    if (getClientPool().shouldNioWriteHappen() \u003d\u003d false) {\n                        //no need to remove the key\n                        continue;\n                    }\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Writable, removing OP_WRITE from interestOps for \" + _ch.getName());\n                        //remove OP_WRITE from interest set\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_WRITE));\n                        _ch.addEvent(ClientEvent.WRITE);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.WRITE);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (stopServer \u003d\u003d true \u0026\u0026 key.isAcceptable()) {\n                    //we will not accept this key\n                    //reset it back\n                    setSkipValidation(false);\n                } else {\n                    logger.warning(\"Unknown key got in SelectionKey: \" + key);\n                }\n                //Remove key\n                iterator.remove();\n                Thread.yield();\n            }\n            //end of iterator\n            iterator \u003d null;\n        }\n        //end of loop\n    }\n\n    private boolean checkAccessConstraint(Socket socket) {\n        try {\n            if (getAccessConstraintConfig() !\u003d null) {\n                getAccessConstraintConfig().checkAccept(socket);\n            }\n            return true;\n        } catch (SecurityException se) {\n            logger.warning(\"SecurityException occurred accepting connection : \" + se.getMessage());\n            return false;\n        }\n    }\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {\n        if (getSelector() \u003d\u003d null) {\n            throw new IllegalStateException(\"Selector is not open!\");\n        }\n        if (channel \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Can\u0027t register a null channel!\");\n        }\n        if (channel.isConnected() \u003d\u003d false) {\n            throw new ClosedChannelException();\n        }\n        RegisterChannelRequest req \u003d new RegisterChannelRequest(channel, ops, att);\n        RegisterChannelRequest reqOld \u003d null;\n        synchronized (registerChannelRequestMap) {\n            reqOld \u003d (RegisterChannelRequest) registerChannelRequestMap.get(channel);\n            if (reqOld \u003d\u003d null) {\n                registerChannelRequestMap.put(channel, req);\n                getSelector().wakeup();\n                return true;\n            } else {\n                if (reqOld.equals(req) \u003d\u003d false) {\n                    reqOld.setOps(reqOld.getOps() | req.getOps());\n                    reqOld.setAtt(req.getAtt());\n                    return true;\n                }\n                return false;\n            }\n        }\n        /*\n\t\tlogger.warning(\"Before register...\");\n\t\tchannel.register(getSelector(), ops, att);\n\t\tlogger.warning(\"Before wakeup and after register...\");\n\t\tgetSelector().wakeup();\n\t\tlogger.warning(\"After wakeup...\");\n\t\t*/\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig) {\n        logger.finer(\"Creating ByteBufferPool pool\");\n        int bufferSize \u003d getBasicConfig().getAdvancedSettings().getByteBufferSize();\n        boolean useDirectByteBuffer \u003d getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();\n        PoolableObjectFactory factory \u003d new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);\n        byteBufferPool \u003d poolManager.makeByteBufferPool(factory, opConfig);\n        poolManager.initPool(byteBufferPool, opConfig);\n    }\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool() {\n        return byteBufferPool;\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientThread pool\");\n        ThreadObjectFactory factory \u003d new ThreadObjectFactory();\n        ObjectPool objectPool \u003d poolManager.makeClientPool(factory, opConfig);\n        pool \u003d new ClientPool(makeQSObjectPool(objectPool), opConfig);\n        factory.setClientPool(pool);\n        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());\n        poolManager.initPool(objectPool, opConfig);\n    }\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler) {\n        clientWriteHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler() {\n        return clientWriteHandlerString;\n    }\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be \u003ccode\u003enull\u003c/code\u003e if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime() {\n        return lastStartTime;\n    }\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag) {\n        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);\n        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);\n    }\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier() {\n        return clientIdentifier;\n    }\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {\n        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);\n    }\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode() {\n        return blockingMode;\n    }\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception {\n        if (clientCommandHandlerString \u003d\u003d null \u0026\u0026 clientEventHandlerString \u003d\u003d null) {\n            logger.severe(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n            throw new AppException(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n        }\n        clientCommandHandler \u003d null;\n        if (clientCommandHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientCommandHandler class..\");\n            Class clientCommandHandlerClass \u003d getClass(clientCommandHandlerString, true);\n            clientCommandHandler \u003d (ClientCommandHandler) clientCommandHandlerClass.newInstance();\n        }\n        boolean setClientCommandHandlerLookup \u003d false;\n        clientEventHandler \u003d null;\n        if (clientEventHandlerString \u003d\u003d null) {\n            clientEventHandlerString \u003d \"org.quickserver.net.server.impl.DefaultClientEventHandler\";\n            setClientCommandHandlerLookup \u003d true;\n        }\n        logger.finest(\"Loading ClientEventHandler class..\");\n        if (clientEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientEventHandler.class.isInstance(clientCommandHandler)) {\n            clientEventHandler \u003d (ClientEventHandler) clientCommandHandler;\n        } else {\n            clientEventHandler \u003d (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();\n            if (setClientCommandHandlerLookup) {\n                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);\n            }\n        }\n        clientExtendedEventHandler \u003d null;\n        if (clientExtendedEventHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientExtendedEventHandler class..\");\n            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientCommandHandler;\n            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientEventHandler;\n            } else {\n                Class clientExtendedEventHandlerClass \u003d getClass(clientExtendedEventHandlerString, true);\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();\n            }\n        }\n        clientObjectHandler \u003d null;\n        if (clientObjectHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientObjectHandler class..\");\n            if (clientObjectHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientCommandHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientCommandHandler;\n            } else if (clientObjectHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientEventHandler;\n            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientExtendedEventHandler;\n            } else {\n                clientObjectHandler \u003d (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientBinaryHandler \u003d null;\n        if (clientBinaryHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientBinaryHandler class..\");\n            if (clientBinaryHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientCommandHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientCommandHandler;\n            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientExtendedEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientObjectHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientObjectHandler;\n            } else {\n                clientBinaryHandler \u003d (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientWriteHandler \u003d null;\n        if (clientWriteHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientWriteHandler class..\");\n            if (clientWriteHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientCommandHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientCommandHandler;\n            } else if (clientWriteHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientEventHandler;\n            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientExtendedEventHandler;\n            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientObjectHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientObjectHandler;\n            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientBinaryHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientBinaryHandler;\n            } else {\n                clientWriteHandler \u003d (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        Class authenticatorClass \u003d null;\n        if (clientAuthenticationHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientAuthenticationHandler class..\");\n            authenticatorClass \u003d getClass(clientAuthenticationHandlerString, true);\n        }\n        if (authenticatorClass !\u003d null) {\n            Object obj \u003d authenticatorClass.newInstance();\n            if (ClientAuthenticationHandler.class.isInstance(obj))\n                clientAuthenticationHandler \u003d (ClientAuthenticationHandler) obj;\n            else\n                authenticator \u003d (Authenticator) obj;\n        }\n        clientDataClass \u003d null;\n        if (clientDataString !\u003d null) {\n            logger.finest(\"Loading ClientData class..\");\n            clientDataClass \u003d getClass(clientDataString, true);\n        }\n        Assertion.affirm(clientEventHandler !\u003d null, \"ClientEventHandler was not loaded!\");\n    }\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler) {\n        clientEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler() {\n        return clientEventHandlerString;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {\n        if (dataType \u003d\u003d DataType.IN)\n            this.defaultDataModeIN \u003d dataMode;\n        if (dataType \u003d\u003d DataType.OUT)\n            this.defaultDataModeOUT \u003d dataMode;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {\n        defaultDataModeIN \u003d defaultDataMode.getDataMode(DataType.IN);\n        defaultDataModeOUT \u003d defaultDataMode.getDataMode(DataType.OUT);\n        ;\n    }\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType) {\n        if (dataType \u003d\u003d DataType.IN)\n            return defaultDataModeIN;\n        if (dataType \u003d\u003d DataType.OUT)\n            return defaultDataModeOUT;\n        else\n            throw new IllegalArgumentException(\"Unknown DataType: \" + dataType);\n    }\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler) {\n        clientExtendedEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler() {\n        return clientExtendedEventHandlerString;\n    }\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception {\n        if (getApplicationJarPath() !\u003d null \u0026\u0026 getClassLoader() \u003d\u003d null) {\n            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));\n            //update qsadmin to use the same\n            if (adminServer !\u003d null) {\n                adminServer.getServer().setClassLoader(getClassLoader());\n            }\n        }\n    }\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID() {\n        return pid;\n    }\n\n    public boolean isRawCommunicationLogging() {\n        return rawCommunicationLogging;\n    }\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {\n        this.rawCommunicationLogging \u003d rawCommunicationLogging;\n    }\n\n    public int getRawCommunicationMaxLength() {\n        return rawCommunicationMaxLength;\n    }\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {\n        this.rawCommunicationMaxLength \u003d rawCommunicationMaxLength;\n    }\n}\n",
    "package": "org.quickserver.net.server",
    "classname": "QuickServer",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_9Test.java",
    "test_prompt": "// QuickServer_9Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#resumeService()} method.\n*/\nclass QuickServer_9Test {",
    "method_signature": "resumeService()",
    "suffix": "9"
  },
  {
    "numberTests": "ten",
    "original_code": "// QuickServer.java\n/*\n * This file is part of the QuickServer library \n * Copyright (C) QuickServer.org\n *\n * Use, modification, copying and distribution of this software is subject to\n * the terms and conditions of the GNU Lesser General Public License. \n * You should have received a copy of the GNU LGP License along with this \n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\n *\n * For questions, suggestions, bug-reports, enhancement-requests etc.\n * visit http://www.quickserver.org\n *\n */\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n *  Main class of QuickServer library. This class is used to create\n *  multi client servers quickly.\n *  \u003cp\u003e\n *  Ones a client is connected, it creates {@link ClientHandler} object,\n *  which is run using any thread available from the pool of threads\n *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n *  handles the client. \u003cbr/\u003e\n *  QuickServer divides the application logic of its developer over eight\n *  class, \u003cbr\u003e\n *  \t\u003cul\u003e\n * \t\t\u003cli\u003eClientEventHandler\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client events [Optional Class].\n *  \t\t\u003cli\u003eClientCommandHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client character/string commands.\n *  \t\t\u003cli\u003eClientObjectHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - Object commands.\n * \t\t\u003cli\u003eClientBinaryHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - binary data.\n * \t\t\u003cli\u003eClientWriteHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n *  \t\t\u003cli\u003eClientAuthenticationHandler [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Used to Authencatet a client.\n *  \t\t\u003cli\u003eClientData [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Client data carrier (support class)\n * \t\t\u003cli\u003eClientExtendedEventHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles extended client events.\n *  \t\u003c/ul\u003e\n *\n *  [#] \u003d Any one of these have to be set based on default DataMode for input.\n *  The default DataMode for input is String so if not changes you will\n *  have to set ClientCommandHandler.\n *  \u003c/p\u003e\n *  \u003cp\u003e\n *   Eg:\n *  \u003ccode\u003e\u003cBLOCKQUOTE\u003e\u003cpre\u003e\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle \u003d \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer \u003d new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * \u003c/pre\u003e\u003c/BLOCKQUOTE\u003e\u003c/code\u003e\u003c/p\u003e\n *\n *  @version 1.4.8\n *  @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //Some variable are not initialised to any value because the\n    //default java value was desired initial value.\n    //\u0027dev \u0027 \u003d development build not yet final\n    //\u0027beta\u0027 \u003d test build all features\n    //change also in QSAdminMain\n    private final static String VER \u003d \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n        if (System.getProperty(\"org.quickserver.useOSLineSeparator\") !\u003d null \u0026\u0026 System.getProperty(\"org.quickserver.useOSLineSeparator\").equals(\"true\")) {\n            NEW_LINE \u003d System.getProperty(\"line.separator\");\n        } else {\n            NEW_LINE \u003d \"\\r\\n\";\n        }\n        String _pid \u003d ManagementFactory.getRuntimeMXBean().getName();\n        int i \u003d _pid.indexOf(\"@\");\n        pid \u003d _pid.substring(0, i);\n        System.out.print(\"Loading QuickServer v\" + getVersion() + \" [PID:\" + pid + \"]\");\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort \u003d 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName \u003d \"QuickServer\";\n\n    private long maxConnection \u003d -1;\n\n    //1 min socket timeout\n    private int socketTimeout \u003d 60 * 1000;\n\n    private String maxConnectionMsg \u003d \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg \u003d \"-ERR Timeout\";\n\n    private String maxAuthTryMsg \u003d \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry \u003d 5;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //--v1.2\n    //Logger for QuickServer\n    private static final Logger logger \u003d Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //for Service interface\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState \u003d Service.UNKNOWN;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.3\n    private QuickServerConfig config \u003d new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel \u003d \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel \u003d \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation \u003d false;\n\n    private boolean communicationLogging \u003d true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig \u003d config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km \u003d null;\n\n    private TrustManager[] tm \u003d null;\n\n    private boolean runningSecure \u003d false;\n\n    private SecureStoreManager secureStoreManager \u003d null;\n\n    private Exception exceptionInRun \u003d null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode \u003d true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN \u003d DataMode.STRING;\n\n    private DataMode defaultDataModeOUT \u003d DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging \u003d false;\n\n    private int rawCommunicationMaxLength \u003d 100;\n\n    static {\n        System.out.println(\" Done\");\n        //should be commented if not a patch release\n        //System.out.println(\"[Includes patch(#): t\u003d152\u0026p\u003d532]\");\n        //should be commented if not a dev release\n        //System.out.println(\"[Dev Build Date: Saturday, October 29, 2005]\");\n        logger.log(Level.FINE, \"PID: {0}\", pid);\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion() {\n        return VER;\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo() {\n        return getVersionNo(VER);\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver) {\n        //String ver \u003d getVersion();\n        float version \u003d 0;\n        //check if beta\n        int i \u003d ver.indexOf(\" \");\n        if (i \u003d\u003d -1)\n            i \u003d ver.length();\n        ver \u003d ver.substring(0, i);\n        //check for sub version\n        i \u003d ver.indexOf(\".\");\n        if (i !\u003d -1) {\n            int j \u003d ver.indexOf(\".\", i);\n            if (j !\u003d -1) {\n                ver \u003d ver.substring(0, i) + \".\" + MyString.replaceAll(ver.substring(i + 1), \".\", \"\");\n            }\n        }\n        try {\n            version \u003d Float.parseFloat(ver);\n        } catch (NumberFormatException e) {\n            throw new RuntimeException(\"Corrupt QuickServer\");\n        }\n        return version;\n    }\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine() {\n        return NEW_LINE;\n    }\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString() {\n        return serverName + \" : \" + getPort();\n    }\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n        setClientCommandHandler(commandHandler);\n    }\n\n    /**\n     * Creates a new server at \u003ccode\u003eport\u003c/code\u003e with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n        //send to another constructor\n        this(commandHandler);\n        setPort(port);\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException {\n        logger.log(Level.FINE, \"Starting {0}\", getName());\n        if (isClosed() \u003d\u003d false) {\n            logger.log(Level.WARNING, \"Server {0} already running.\", getName());\n            throw new AppException(\"Server \" + getName() + \" already running.\");\n        }\n        blockingMode \u003d getBasicConfig().getServerMode().getBlocking();\n        if (getSecure().isEnable() \u0026\u0026 blockingMode \u003d\u003d false) {\n            //TODO we need to fix this..\n            logger.warning(\"QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode.\");\n            blockingMode \u003d true;\n            getBasicConfig().getServerMode().setBlocking(blockingMode);\n        }\n        if (serverBanner \u003d\u003d null) {\n            serverBanner \u003d \"\\n-------------------------------\" + \"\\n Name : \" + getName() + \"\\n Port : \" + getPort() + \"\\n-------------------------------\\n\";\n            logger.finest(\"Default Server Banner Generated\");\n        }\n        try {\n            loadApplicationClasses();\n            //load class from Advanced Settings\n            Class clientIdentifierClass \u003d getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);\n            clientIdentifier \u003d (ClientIdentifier) clientIdentifierClass.newInstance();\n            clientIdentifier.setQuickServer(QuickServer.this);\n            //load class from ObjectPoolConfig\n            Class poolManagerClass \u003d getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);\n            poolManager \u003d (PoolManager) poolManagerClass.newInstance();\n            //load class QSObjectPoolMaker\n            Class qsObjectPoolMakerClass \u003d getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);\n            qsObjectPoolMaker \u003d (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();\n            loadServerHooksClasses();\n            processServerHooks(ServerHook.PRE_STARTUP);\n            if (getSecure().isLoad() \u003d\u003d true)\n                //v1.4.0\n                loadSSLContext();\n            loadBusinessLogic();\n        } catch (ClassNotFoundException e) {\n            logger.log(Level.SEVERE, \"Could not load class/s: \" + e, e);\n            throw new AppException(\"Could not load class/s : \" + e);\n        } catch (InstantiationException e) {\n            logger.log(Level.SEVERE, \"Could not instantiate class/s: \" + e, e);\n            throw new AppException(\"Could not instantiate class/s: \" + e);\n        } catch (IllegalAccessException e) {\n            logger.log(Level.SEVERE, \"Illegal access to class/s: \" + e, e);\n            throw new AppException(\"Illegal access to class/s: \" + e);\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"IOException: \" + e, e);\n            throw new AppException(\"IOException: \" + e);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Exception: \" + e, e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Exception : \" + e);\n        }\n        //v1.3.3\n        if (getSecurityManagerClass() !\u003d null) {\n            System.setSecurityManager(getSecurityManager());\n        }\n        setServiceState(Service.INIT);\n        t \u003d new Thread(this, \"QuickServer - \" + getName());\n        t.start();\n        do {\n            Thread.yield();\n        } while (getServiceState() \u003d\u003d Service.INIT);\n        if (getServiceState() !\u003d Service.RUNNING) {\n            if (exceptionInRun !\u003d null)\n                throw new AppException(\"Could not start server \" + getName() + \"! Details: \" + exceptionInRun);\n            else\n                throw new AppException(\"Could not start server \" + getName());\n        }\n        lastStartTime \u003d new java.util.Date();\n        logger.log(Level.FINE, \"Started {0}, Date: {1}\", new Object[] { getName(), lastStartTime });\n    }\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException {\n        processServerHooks(ServerHook.PRE_SHUTDOWN);\n        logger.log(Level.WARNING, \"Stopping {0}\", getName());\n        stopServer \u003d true;\n        Socket death \u003d null;\n        if (isClosed() \u003d\u003d true) {\n            logger.log(Level.WARNING, \"Server {0} is not running!\", getName());\n            throw new AppException(\"Server \" + getName() + \" is not running!\");\n        }\n        try {\n            if (getBlockingMode() \u003d\u003d true) {\n                if (getSecure().isEnable() \u003d\u003d false) {\n                    death \u003d new Socket(server.getInetAddress(), server.getLocalPort());\n                    death.getInputStream().read();\n                    death.close();\n                } else {\n                    death \u003d getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());\n                    Thread.sleep(100);\n                    death.close();\n                }\n            }\n            if (serverSocketChannel !\u003d null) {\n                serverSocketChannel.close();\n            }\n        } catch (IOException e) {\n            logger.log(Level.FINE, \"IOError stopping {0}: {1}\", new Object[] { getName(), e });\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error stopping {0}: {1}\", new Object[] { getName(), e });\n            throw new AppException(\"Error in stopServer \" + getName() + \": \" + e);\n        }\n        for (int i \u003d 0; getServiceState() !\u003d Service.STOPPED; i++) {\n            try {\n                Thread.sleep(60);\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error waiting for {0} to fully stop. Error: {1}\", new Object[] { getName(), e });\n            }\n            if (i \u003e 1000) {\n                logger.severe(\"Server was not stopped even after 10sec.. will terminate now.\");\n                System.exit(-1);\n            }\n        }\n        if (adminServer \u003d\u003d null || getQSAdminServer().getServer() !\u003d this) {\n            //so this is not qsadmin\n            setClassLoader(null);\n        }\n        logger.log(Level.INFO, \"Stopped {0}\", getName());\n    }\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException {\n        stopServer();\n        startServer();\n    }\n\n    /**\n     * Returns the name of the QuickServer. Default is \u0027QuickServer\u0027.\n     * @see #setName\n     */\n    public String getName() {\n        return serverName;\n    }\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name) {\n        serverName \u003d name;\n        logger.log(Level.FINEST, \"Set to : {0}\", name);\n    }\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner() {\n        return serverBanner;\n    }\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. \u003cbr\u003e\u0026nbsp;\u003cbr\u003e\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner) {\n        serverBanner \u003d banner;\n        logger.log(Level.FINEST, \"Set to : {0}\", banner);\n    }\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port) {\n        if (port \u003c 0) {\n            throw new IllegalArgumentException(\"Port number can not be less than 0!\");\n        }\n        serverPort \u003d port;\n        logger.log(Level.FINEST, \"Set to {0}\", port);\n    }\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort() {\n        if (isClosed() \u003d\u003d false) {\n            return server.getLocalPort();\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            return serverPort;\n        } else {\n            int _port \u003d getSecure().getPort();\n            if (_port \u003d\u003d -1)\n                return serverPort;\n            else\n                return _port;\n        }\n    }\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler) {\n        clientCommandHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler() {\n        return clientCommandHandlerString;\n    }\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data) {\n        this.clientDataString \u003d data;\n        logger.log(Level.FINEST, \"Set to {0}\", data);\n    }\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData() {\n        return clientDataString;\n    }\n\n    /**\n     * Sets the client socket\u0027s timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time) {\n        if (time \u003e 0)\n            socketTimeout \u003d time;\n        else\n            socketTimeout \u003d 0;\n        logger.log(Level.FINEST, \"Set to {0}\", socketTimeout);\n    }\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout() {\n        return socketTimeout;\n    }\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry) {\n        maxAuthTry \u003d authTry;\n        logger.log(Level.FINEST, \"Set to {0}\", authTry);\n    }\n\n    /**\n     * Returns max allowed login attempts. Default is \u003ccode\u003e5\u003c/code\u003e.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry() {\n        return maxAuthTry;\n    }\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg) {\n        maxAuthTryMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg() {\n        return maxAuthTryMsg;\n    }\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg) {\n        timeoutMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg() {\n        return timeoutMsg;\n    }\n\n    private TheClient initTheClient() {\n        TheClient theClient \u003d new TheClient();\n        theClient.setServer(QuickServer.this);\n        theClient.setTimeoutMsg(getTimeoutMsg());\n        //v1.2\n        theClient.setMaxAuthTry(getMaxAuthTry());\n        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());\n        theClient.setClientEventHandler(clientEventHandler);\n        //v1.4.6\n        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);\n        theClient.setClientCommandHandler(clientCommandHandler);\n        //v1.2\n        theClient.setClientObjectHandler(clientObjectHandler);\n        //v1.4\n        theClient.setClientBinaryHandler(clientBinaryHandler);\n        //v1.4.5\n        theClient.setClientWriteHandler(clientWriteHandler);\n        //v1.3\n        theClient.setAuthenticator(authenticator);\n        //v1.4.6\n        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);\n        theClient.setTimeout(socketTimeout);\n        theClient.setMaxConnectionMsg(maxConnectionMsg);\n        //v1.3.2\n        theClient.setCommunicationLogging(getCommunicationLogging());\n        return theClient;\n    }\n\n    public void run() {\n        exceptionInRun \u003d null;\n        TheClient theClient \u003d initTheClient();\n        try {\n            stopServer \u003d false;\n            closeAllPools();\n            initAllPools();\n            makeServerSocket();\n            //print banner\n            System.out.println(serverBanner);\n            //v1.2\n            setServiceState(Service.RUNNING);\n            //v1.3.3\n            processServerHooks(ServerHook.POST_STARTUP);\n            if (getBlockingMode() \u003d\u003d false) {\n                runNonBlocking(theClient);\n                if (stopServer \u003d\u003d true) {\n                    logger.log(Level.FINEST, \"Closing selector for {0}\", getName());\n                    selector.close();\n                }\n                return;\n            } else {\n                runBlocking(theClient);\n            }\n        } catch (BindException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"{0} BindException for Port {1} @ {2} : {3}\", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });\n        } catch (javax.net.ssl.SSLException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"SSLException {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (IOException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"IOError {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (Exception e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"Error {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } finally {\n            if (getBlockingMode() \u003d\u003d true) {\n                logger.log(Level.WARNING, \"Closing {0}\", getName());\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            } else if (getBlockingMode() \u003d\u003d false \u0026\u0026 exceptionInRun !\u003d null) {\n                logger.log(Level.WARNING, \"Closing {0} - Had Error: {1}\", new Object[] { getName(), exceptionInRun });\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        if (serverSocketChannel !\u003d null)\n                            serverSocketChannel.close();\n                        if (server !\u003d null)\n                            server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n        }\n    }\n\n    //end of run\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnection \u003d maxConnection;\n        else\n            this.maxConnection \u003d maxConnection;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnection);\n    }\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection() {\n        return maxConnection;\n    }\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount() {\n        if (clientHandlerPool !\u003d null) {\n            try {\n                return getClientHandlerPool().getNumActive();\n            } catch (Exception e) {\n                return 0;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : \u003ccode\u003e-ERR Server Busy. Max Connection Reached\u003c/code\u003e\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n        else\n            this.maxConnectionMsg \u003d maxConnectionMsg;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnectionMsg);\n    }\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg() {\n        return maxConnectionMsg;\n    }\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException {\n        ipAddr \u003d InetAddress.getByName(bindAddr);\n        logger.log(Level.FINEST, \"Set to {0}\", bindAddr);\n    }\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr() {\n        if (ipAddr \u003d\u003d null) {\n            try {\n                ipAddr \u003d InetAddress.getByName(\"0.0.0.0\");\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Unable to create default ip(0.0.0.0) : {0}\", e);\n                throw new RuntimeException(\"Error: Unable to find servers own ip : \" + e);\n            }\n        }\n        return ipAddr;\n    }\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects) {\n        this.storeObjects \u003d storeObjects;\n    }\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return \u003ccode\u003enull\u003c/code\u003e.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects() {\n        return storeObjects;\n    }\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port) {\n        getQSAdminServer().getServer().setPort(port);\n    }\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort() {\n        return getQSAdminServer().getServer().getPort();\n    }\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator) {\n        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);\n    }\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator() {\n        return getQSAdminServer().getServer().getAuthenticator();\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException {\n        getQSAdminServer().setClientAuthenticationHandler(authenticator);\n        getQSAdminServer().startServer(port);\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException {\n        getQSAdminServer().startServer();\n    }\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer() {\n        if (adminServer \u003d\u003d null)\n            adminServer \u003d new QSAdminServer(QuickServer.this);\n        return adminServer;\n    }\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer) {\n        if (adminServer \u003d\u003d null)\n            this.adminServer \u003d adminServer;\n    }\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed() {\n        if (server \u003d\u003d null)\n            return true;\n        return server.isClosed();\n    }\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer\u0027s own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger() {\n        if (appLogger !\u003d null)\n            return appLogger;\n        return logger;\n    }\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger) {\n        this.appLogger \u003d appLogger;\n    }\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler) {\n        clientObjectHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler() {\n        return clientObjectHandlerString;\n    }\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n        if (formatter \u003d\u003d null)\n            return;\n        consoleLoggingformatter \u003d formatter;\n        java.util.logging.Formatter conformatter \u003d (java.util.logging.Formatter) getClass(formatter, true).newInstance();\n        Logger jdkLogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d jdkLogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                handlers[index].setFormatter(conformatter);\n            }\n        }\n        logger.log(Level.FINEST, \"Set to {0}\", formatter);\n    }\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter() {\n        return consoleLoggingformatter;\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MiniFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to logging.MiniFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MicroFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to MicroFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        boolean isConsole \u003d true;\n        try {\n            if (System.console() \u003d\u003d null) {\n                isConsole \u003d false;\n            }\n        } catch (Throwable e) {\n            //ignore\n        }\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                if (isConsole \u003d\u003d false \u0026\u0026 level !\u003d Level.OFF) {\n                    System.out.println(\"QuickServer: You do not have a console.. so turning console logger off..\");\n                    level \u003d Level.OFF;\n                }\n                if (level \u003d\u003d Level.OFF) {\n                    logger.info(\"QuickServer: Removing console handler.. \");\n                    rlogger.removeHandler(handlers[index]);\n                    handlers[index].setLevel(level);\n                    handlers[index].close();\n                } else {\n                    handlers[index].setLevel(level);\n                }\n            }\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            consoleLoggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            consoleLoggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            consoleLoggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            consoleLoggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            consoleLoggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            consoleLoggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            consoleLoggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            consoleLoggingLevel \u003d \"OFF\";\n        else\n            consoleLoggingLevel \u003d \"UNKNOWN\";\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel() {\n        return consoleLoggingLevel;\n    }\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            handlers[index].setLevel(level);\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            loggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            loggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            loggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            loggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            loggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            loggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            loggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            loggingLevel \u003d \"OFF\";\n        else\n            loggingLevel \u003d \"UNKNOWN\";\n        consoleLoggingLevel \u003d loggingLevel;\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    //*** Start of Service interface methods\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError() {\n        return serviceError;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param) {\n        serviceError \u003d null;\n        try {\n            initServer(param);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig) {\n        serviceError \u003d null;\n        try {\n            initServer(qsConfig);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING)\n            return false;\n        try {\n            startServer();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.STOPPED)\n            return false;\n        try {\n            stopServer();\n            clearAllPools();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING) {\n            suspendMaxConnection \u003d maxConnection;\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n            maxConnection \u003d 0;\n            maxConnectionMsg \u003d \"Service is suspended.\";\n            setServiceState(Service.SUSPENDED);\n            logger.log(Level.INFO, \"Service {0} is suspended.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.SUSPENDED) {\n            maxConnection \u003d suspendMaxConnection;\n            maxConnectionMsg \u003d suspendMaxConnectionMsg;\n            setServiceState(Service.RUNNING);\n            logger.log(Level.INFO, \"Service {0} resumed.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info() {\n        serviceError \u003d null;\n        StringBuilder buf \u003d new StringBuilder();\n        buf.append(getName()).append(\"\\n\");\n        buf.append(getBindAddr().getHostAddress()).append(\" \");\n        buf.append(getPort()).append(\"\\n\");\n        return buf.toString();\n    }\n\n    // *** End of Service interface methods\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException {\n        QuickServerConfig qsConfig \u003d null;\n        try {\n            qsConfig \u003d ConfigReader.read((String) param[0]);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not init server from xml file {0} : {1}\", new Object[] { new File((String) param[0]).getAbsolutePath(), e });\n            throw new AppException(\"Could not init server from xml file\", e);\n        }\n        initServer(qsConfig);\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {\n        setConfig(qsConfig);\n        try {\n            configQuickServer();\n            loadApplicationClasses();\n            //start InitServerHooks\n            InitServerHooks ish \u003d getConfig().getInitServerHooks();\n            if (ish !\u003d null) {\n                Iterator iterator \u003d ish.iterator();\n                String initServerHookClassName \u003d null;\n                Class initServerHookClass \u003d null;\n                InitServerHook initServerHook \u003d null;\n                while (iterator.hasNext()) {\n                    initServerHookClassName \u003d (String) iterator.next();\n                    initServerHookClass \u003d getClass(initServerHookClassName, true);\n                    initServerHook \u003d (InitServerHook) initServerHookClass.newInstance();\n                    logger.log(Level.INFO, \"Loaded init server hook: {0}\", initServerHookClassName);\n                    logger.log(Level.FINE, \"Init server hook info: {0}\", initServerHook.info());\n                    initServerHook.handleInit(QuickServer.this);\n                }\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not load init server hook: {0}\", e);\n            logger.log(Level.WARNING, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Could not load init server hook\", e);\n        }\n        setServiceState(Service.INIT);\n        logger.log(Level.FINEST, \"\\r\\n{0}\", MyString.getSystemInfo(getVersion()));\n    }\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState() {\n        return serviceState;\n    }\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state) {\n        serviceState \u003d state;\n    }\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp) {\n        if (temp.equals(\"SEVERE\"))\n            qs.setConsoleLoggingLevel(Level.SEVERE);\n        else if (temp.equals(\"WARNING\"))\n            qs.setConsoleLoggingLevel(Level.WARNING);\n        else if (temp.equals(\"INFO\"))\n            qs.setConsoleLoggingLevel(Level.INFO);\n        else if (temp.equals(\"CONFIG\"))\n            qs.setConsoleLoggingLevel(Level.CONFIG);\n        else if (temp.equals(\"FINE\"))\n            qs.setConsoleLoggingLevel(Level.FINE);\n        else if (temp.equals(\"FINER\"))\n            qs.setConsoleLoggingLevel(Level.FINER);\n        else if (temp.equals(\"FINEST\"))\n            qs.setConsoleLoggingLevel(Level.FINEST);\n        else if (temp.equals(\"OFF\"))\n            qs.setConsoleLoggingLevel(Level.OFF);\n        else\n            logger.log(Level.WARNING, \"unknown level {0}\", temp);\n    }\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception {\n        QuickServer qs \u003d QuickServer.this;\n        //v1.3\n        qs.setConfig(config);\n        qs.setBasicConfig(config);\n        String temp \u003d config.getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        temp \u003d null;\n        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        //v1.3.3\n        qs.setSecurityManagerClass(config.getSecurityManagerClass());\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        temp \u003d config.getApplicationJarPath();\n        if (temp !\u003d null) {\n            File ajp \u003d new File(temp);\n            if (ajp.isAbsolute() \u003d\u003d false) {\n                temp \u003d config.getConfigFile();\n                ajp \u003d new File(temp);\n                temp \u003d ajp.getParent() + File.separatorChar + config.getApplicationJarPath();\n                config.setApplicationJarPath(temp);\n                temp \u003d null;\n            }\n            qs.setApplicationJarPath(config.getApplicationJarPath());\n            //set path also to QSAdmin\n            if (config.getQSAdminServerConfig() !\u003d null) {\n                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());\n            }\n        }\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception {\n        QuickServer qs \u003d getQSAdminServer().getServer();\n        qs.setBasicConfig(config);\n        //set the Logging Level to same as main QS\n        //config.getConsoleLoggingLevel();\n        String temp \u003d getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        //set the Logging Formatter to same as main QS\n        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());\n        //v1.4.6\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        //v1.4.6\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());\n        //v1.3.2\n        if (config.getCommandShellEnable().equals(\"true\"))\n            getQSAdminServer().setShellEnable(true);\n        getQSAdminServer().setPromptName(config.getCommandShellPromptName());\n        //v1.3.3\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception {\n        configQuickServer(getConfig());\n        if (getConfig().getQSAdminServerConfig() !\u003d null) {\n            configQuickServer(getConfig().getQSAdminServerConfig());\n        }\n    }\n\n    /**\n     * Usage: QuickServer [-options]\u003cbr/\u003e\n     * Where options include:\u003cbr/\u003e\n     *   -about\t\tOpens About Dialogbox\u003cbr/\u003e\n     *   -load \u003cxml_config_file\u003e [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File \u003cnew_file_name\u003e\n     */\n    public static void main(String[] args) {\n        try {\n            if (args.length \u003e\u003d 1) {\n                if (args[0].equals(\"-about\")) {\n                    org.quickserver.net.server.gui.About.main(null);\n                } else if (args[0].equals(\"-load\") \u0026\u0026 args.length \u003e\u003d 2) {\n                    QuickServer qs \u003d QuickServer.load(args[1]);\n                    if (qs !\u003d null)\n                        handleOptions(args, qs);\n                } else {\n                    System.out.println(printUsage());\n                }\n            } else {\n                System.out.println(printUsage());\n                org.quickserver.net.server.gui.About.showAbout();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException {\n        QuickServer qs \u003d new QuickServer();\n        Object[] config \u003d new Object[] { xml };\n        qs.initServer(config);\n        qs.startServer();\n        if (qs.getConfig().getQSAdminServerConfig() !\u003d null) {\n            qs.startQSAdminServer();\n        }\n        return qs;\n    }\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage() {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"QuickServer - Java library/framework for creating robust multi-client TCP servers.\\n\");\n        sb.append(\"Copyright (C) QuickServer.org\\n\\n\");\n        sb.append(\"Usage: QuickServer [-options]\\n\");\n        sb.append(\"Where options include:\\n\");\n        sb.append(\"  -about\\t\" + \"Opens About Dialog box\\n\");\n        sb.append(\"  -load \u003cxml_config_file\u003e [load-options]\\t\" + \"Loads the server from xml file.\\n\");\n        sb.append(\"  Where load-options include:\\n\");\n        sb.append(\"     -fullXML2File \u003cfile_name\u003e\\t\" + \"Dumps the Full XML configuration of the QuickServer loaded.\\n\");\n        return sb.toString();\n    }\n\n    private static void handleOptions(String[] args, QuickServer quickserver) {\n        if (args.length \u003c 3)\n            return;\n        if (args[2].equals(\"-fullXML2File\") \u0026\u0026 args.length \u003e\u003d 4) {\n            File file \u003d new File(args[3]);\n            logger.log(Level.INFO, \"Writing full xml configuration to file: {0}\", file.getAbsolutePath());\n            try {\n                TextFile.write(file, quickserver.getConfig().toXML(null));\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error writing full xml configuration: {0}\", e);\n            }\n        }\n    }\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception {\n        try {\n            if (pool !\u003d null)\n                getClientPool().clear();\n            if (clientHandlerPool !\u003d null)\n                getClientHandlerPool().clear();\n            if (getClientDataPool() !\u003d null)\n                getClientDataPool().clear();\n            if (getDBPoolUtil() !\u003d null)\n                getDBPoolUtil().clean();\n            if (byteBufferPool !\u003d null)\n                getByteBufferPool().clear();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error: {0}\", e);\n            throw e;\n        }\n    }\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception {\n        if (pool \u003d\u003d null \u0026\u0026 clientHandlerPool \u003d\u003d null \u0026\u0026 getClientDataPool() \u003d\u003d null \u0026\u0026 getDBPoolUtil() \u003d\u003d null \u0026\u0026 byteBufferPool \u003d\u003d null) {\n            return;\n        }\n        logger.log(Level.FINE, \"Closing pools for {0}\", getName());\n        try {\n            if (pool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {\n                logger.finer(\"Closing ClientThread pool.\");\n                getClientPool().close();\n            }\n            if (clientHandlerPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientHandlerPool())) {\n                logger.finer(\"Closing ClientHandler pool.\");\n                getClientHandlerPool().close();\n            }\n            if (getClientDataPool() !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientDataPool())) {\n                logger.finer(\"Closing ClientData pool.\");\n                getClientDataPool().close();\n            }\n            if (getDBPoolUtil() !\u003d null) {\n                logger.finer(\"Closing DB pool.\");\n                getDBPoolUtil().clean();\n            }\n            if (byteBufferPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getByteBufferPool())) {\n                logger.finer(\"Closing ByteBuffer pool.\");\n                getByteBufferPool().close();\n            }\n            logger.log(Level.FINE, \"Closed pools for {0}\", getName());\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error closing pools for {0}: {1}\", new Object[] { getName(), e });\n            throw e;\n        }\n    }\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception {\n        logger.fine(\"Creating pools\");\n        if (getBlockingMode() \u003d\u003d false) {\n            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());\n        }\n        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());\n        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());\n        //check if client data is poolable\n        if (clientDataClass !\u003d null) {\n            try {\n                clientData \u003d (ClientData) clientDataClass.newInstance();\n                if (PoolableObject.class.isInstance(clientData) \u003d\u003d true) {\n                    PoolableObject po \u003d (PoolableObject) clientData;\n                    if (po.isPoolable() \u003d\u003d true) {\n                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());\n                    } else {\n                        clientDataPool \u003d null;\n                        logger.fine(\"ClientData is not poolable!\");\n                    }\n                }\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error: {0}\", e);\n                throw e;\n            }\n        }\n        try {\n            makeDBObjectPool();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error in makeDBObjectPool() : {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw e;\n        }\n        logger.fine(\"Created pools\");\n    }\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool() {\n        if (pool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientPool available yet!\");\n        return pool;\n    }\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientHandler pool\");\n        PoolableObjectFactory factory \u003d new ClientHandlerObjectFactory(getBlockingMode());\n        clientHandlerPool \u003d poolManager.makeClientHandlerPool(factory, opConfig);\n        poolManager.initPool(clientHandlerPool, opConfig);\n        clientHandlerPool \u003d makeQSObjectPool(clientHandlerPool);\n        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool() {\n        if (clientHandlerPool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientHandler Pool available yet!\");\n        return clientHandlerPool;\n    }\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config) {\n        this.config \u003d config;\n    }\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig() {\n        return config;\n    }\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientData pool\");\n        clientDataPool \u003d poolManager.makeClientDataPool(factory, opConfig);\n        poolManager.initPool(clientDataPool, opConfig);\n        clientDataPool \u003d makeQSObjectPool(clientDataPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool() {\n        return clientDataPool;\n    }\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return \u003ccode\u003enull\u003c/code\u003e\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil() {\n        return dBPoolUtil;\n    }\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {\n        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);\n    }\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception {\n        if (getConfig().getDBObjectPoolConfig() !\u003d null) {\n            logger.fine(\"Creating DBObject Pool\");\n            //logger.finest(\"Got:\\n\"+getConfig().getDBObjectPoolConfig().toXML(null));\n            Class dbPoolUtilClass \u003d getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);\n            dBPoolUtil \u003d (DBPoolUtil) dbPoolUtilClass.newInstance();\n            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());\n            dBPoolUtil.initPool();\n        }\n    }\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id) {\n        return clientIdentifier.findFirstClientById(id);\n    }\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  \u003ccode\u003e\u003cpre\u003e\n     *    Eg:\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tObject syncObj \u003d quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator \u003d quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tClientIdentifier clientIdentifier \u003d quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator \u003d clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    \u003c/code\u003e\u003c/pre\u003e\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient() {\n        return clientIdentifier.findAllClient();\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern) {\n        return clientIdentifier.findAllClientById(pattern);\n    }\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key) {\n        return clientIdentifier.findClientByKey(key);\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern) {\n        return clientIdentifier.findAllClientByKey(pattern);\n    }\n\n    /**\n     * Sets next client has a trusted client.\n     * \u003cp\u003eThis will skip any authentication and will not set any timeout.\u003c/p\u003e\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted() {\n        setSkipValidation(true);\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation() {\n        return skipValidation;\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation) {\n        skipValidation \u003d validation;\n    }\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging) {\n        this.communicationLogging \u003d communicationLogging;\n    }\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging() {\n        return communicationLogging;\n    }\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass) {\n        if (securityManagerClass !\u003d null)\n            this.securityManagerClass \u003d securityManagerClass;\n    }\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass() {\n        return securityManagerClass;\n    }\n\n    public SecurityManager getSecurityManager() throws AppException {\n        if (getSecurityManagerClass() \u003d\u003d null)\n            return null;\n        SecurityManager sm \u003d null;\n        try {\n            sm \u003d (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();\n        } catch (ClassNotFoundException e) {\n            throw new AppException(e.getMessage());\n        } catch (InstantiationException e) {\n            throw new AppException(e.getMessage());\n        } catch (IllegalAccessException e) {\n            throw new AppException(e.getMessage());\n        }\n        return sm;\n    }\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {\n        this.accessConstraintConfig \u003d accessConstraintConfig;\n    }\n\n    /**\n     * Returns Access constraints if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig() {\n        return accessConstraintConfig;\n    }\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader) {\n        this.classLoader \u003d classLoader;\n        Thread.currentThread().setContextClassLoader(classLoader);\n    }\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader() {\n        return classLoader;\n    }\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException {\n        if (name \u003d\u003d null)\n            throw new IllegalArgumentException(\"Class name can\u0027t be null!\");\n        logger.log(Level.FINEST, \"Class: {0}, reload: {1}\", new Object[] { name, reload });\n        if (reload \u003d\u003d true \u0026\u0026 classLoader !\u003d null) {\n            return classLoader.loadClass(name);\n        } else if (reload \u003d\u003d true \u0026\u0026 classLoader \u003d\u003d null \u0026\u0026 this.getClass().getClassLoader() !\u003d null) {\n            return this.getClass().getClassLoader().loadClass(name);\n        } else if (reload \u003d\u003d false \u0026\u0026 classLoader !\u003d null) {\n            return Class.forName(name, true, classLoader);\n        } else /*if(reload\u003d\u003dfalse \u0026\u0026 classLoader\u003d\u003dnull)*/\n        {\n            return Class.forName(name, true, this.getClass().getClassLoader());\n        }\n    }\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath) {\n        this.applicationJarPath \u003d applicationJarPath;\n    }\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath() {\n        return applicationJarPath;\n    }\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks) {\n        this.serverHooks \u003d serverHooks;\n    }\n\n    /**\n     * Returns ServerHooks if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks() {\n        if (serverHooks \u003d\u003d null)\n            serverHooks \u003d new ServerHooks();\n        return serverHooks;\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses() {\n        if (getServerHooks() \u003d\u003d null)\n            return;\n        listOfServerHooks \u003d new ArrayList();\n        ServerHook serverHook \u003d null;\n        String serverHookClassName \u003d null;\n        Class serverHookClass \u003d null;\n        //add system hooks\n        serverHook \u003d new GhostSocketReaper();\n        serverHook.initHook(QuickServer.this);\n        listOfServerHooks.add(serverHook);\n        ghostSocketReaper \u003d (GhostSocketReaper) serverHook;\n        //add user hooks if any\n        Iterator iterator \u003d getServerHooks().iterator();\n        while (iterator.hasNext()) {\n            serverHookClassName \u003d (String) iterator.next();\n            try {\n                serverHookClass \u003d getClass(serverHookClassName, true);\n                serverHook \u003d (ServerHook) serverHookClass.newInstance();\n                serverHook.initHook(QuickServer.this);\n                listOfServerHooks.add(serverHook);\n                logger.log(Level.INFO, \"Loaded server hook: {0}\", serverHookClassName);\n                logger.log(Level.FINE, \"Server hook info: {0}\", serverHook.info());\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Could not load server hook [{0}]: {1}\", new Object[] { serverHookClassName, e });\n                logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            }\n        }\n        //end of while\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event) {\n        if (listOfServerHooks \u003d\u003d null) {\n            logger.warning(\"listOfServerHooks was null!\");\n            return;\n        }\n        ServerHook serverHook \u003d null;\n        boolean result \u003d false;\n        Iterator iterator \u003d listOfServerHooks.iterator();\n        String hooktype \u003d \"UNKNOWN\";\n        switch(event) {\n            case ServerHook.PRE_STARTUP:\n                hooktype \u003d \"PRE_STARTUP\";\n                break;\n            case ServerHook.POST_STARTUP:\n                hooktype \u003d \"POST_STARTUP\";\n                break;\n            case ServerHook.PRE_SHUTDOWN:\n                hooktype \u003d \"PRE_SHUTDOWN\";\n                break;\n            case ServerHook.POST_SHUTDOWN:\n                hooktype \u003d \"POST_SHUTDOWN\";\n                break;\n        }\n        while (iterator.hasNext()) {\n            serverHook \u003d (ServerHook) iterator.next();\n            try {\n                result \u003d serverHook.handleEvent(event);\n            } catch (Exception e) {\n                result \u003d false;\n                logger.log(Level.WARNING, \"Error invoking {0} hook [{1}]: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });\n            }\n            logger.log(Level.FINE, \"Invoked {0} hook [{1}] was: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), result });\n        }\n    }\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone() {\n        Object object \u003d null;\n        try {\n            object \u003d super.clone();\n            QuickServer _qs \u003d (QuickServer) object;\n            _qs.setQSAdminServer(new QSAdminServer(_qs));\n        } catch (CloneNotSupportedException e) {\n            //should not happ\n            logger.log(Level.WARNING, \"Error cloning : {0}\", e);\n        }\n        return object;\n    }\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure) {\n        this.secure \u003d secure;\n    }\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure() {\n        if (secure \u003d\u003d null)\n            secure \u003d new Secure();\n        return secure;\n    }\n\n    /**\n     * \u003cp\u003eReturns if the server is running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure() {\n        return runningSecure;\n    }\n\n    /**\n     * \u003cp\u003eSets the server mode if its running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure) {\n        this.runningSecure \u003d runningSecure;\n    }\n\n    private File makeAbsoluteToConfig(String fileName) {\n        Assertion.affirm(fileName !\u003d null, \"FileName can\u0027t be null\");\n        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());\n    }\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException {\n        server \u003d null;\n        logger.log(Level.FINEST, \"Binding {0} to IP: {1}\", new Object[] { getName(), getBindAddr() });\n        InetSocketAddress bindAddress \u003d new InetSocketAddress(getBindAddr(), getPort());\n        try {\n            NetworkInterface ni \u003d NetworkInterface.getByInetAddress(getBindAddr());\n            if (ni !\u003d null) {\n                logger.fine(\"NetworkInterface: \" + ni);\n            }\n        } catch (Exception igrnore) {\n            /*ignore*/\n        } catch (Error igrnore) {\n            /*ignore*/\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Making a normal ServerSocket for {0}\", getName());\n            setRunningSecure(false);\n            if (getBlockingMode() \u003d\u003d false) {\n                //for non-blocking\n                serverSocketChannel \u003d ServerSocketChannel.open();\n                server \u003d serverSocketChannel.socket();\n                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n            } else {\n                //for blocking\n                server \u003d new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n            }\n        } else {\n            try {\n                logger.log(Level.FINE, \"Making a secure ServerSocket for {0}\", getName());\n                getSSLContext();\n                setRunningSecure(true);\n                if (getBlockingMode() \u003d\u003d false) {\n                    logger.log(Level.FINE, \"Making a secure ServerSocketChannel for {0}\", getName());\n                    //for non-blocking\n                    serverSocketChannel \u003d ServerSocketChannel.open();\n                    server \u003d serverSocketChannel.socket();\n                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n                } else {\n                    ServerSocketFactory ssf \u003d getSSLContext().getServerSocketFactory();\n                    SSLServerSocket serversocket \u003d (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());\n                    setRunningSecure(true);\n                    secureStoreManager.logSSLServerSocketInfo(serversocket);\n                    server \u003d serversocket;\n                    serverSocketChannel \u003d server.getChannel();\n                    if (serverSocketChannel \u003d\u003d null \u0026\u0026 getBlockingMode() \u003d\u003d false) {\n                        logger.warning(\"Secure Server does not support Channel! So will run in blocking mode.\");\n                        blockingMode \u003d false;\n                    }\n                }\n                //blocking\n            } catch (NoSuchAlgorithmException e) {\n                logger.log(Level.WARNING, \"NoSuchAlgorithmException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            } catch (KeyManagementException e) {\n                logger.log(Level.WARNING, \"KeyManagementException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            }\n        }\n        server.setReuseAddress(true);\n        int connectionTime \u003d 0;\n        int latency \u003d 0;\n        int bandwidth \u003d 0;\n        connectionTime \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();\n        latency \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();\n        bandwidth \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();\n        logger.log(Level.FINE, \"getPerformancePreferencesConnectionTime : {0}\", connectionTime);\n        logger.log(Level.FINE, \"getPerformancePreferencesLatency : {0}\", latency);\n        logger.log(Level.FINE, \"getPerformancePreferencesBandwidth : {0}\", bandwidth);\n        server.setPerformancePreferences(connectionTime, latency, bandwidth);\n        int clientSocketReceiveBufferSize \u003d getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();\n        if (clientSocketReceiveBufferSize \u003e 0) {\n            logger.log(Level.FINE, \"clientSocketReceiveBufferSize: {0}\", clientSocketReceiveBufferSize);\n            server.setReceiveBufferSize(clientSocketReceiveBufferSize);\n        }\n        if (getBlockingMode() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Server Mode {0} - Non Blocking\", getName());\n            if (selector \u003d\u003d null || selector.isOpen() \u003d\u003d false) {\n                logger.finest(\"Opening new selector\");\n                selector \u003d Selector.open();\n            } else {\n                logger.log(Level.FINEST, \"Reusing selector: {0}\", selector);\n            }\n            serverSocketChannel.configureBlocking(false);\n            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n            selector.wakeup();\n        } else {\n            logger.log(Level.FINE, \"Server Mode {0} - Blocking\", getName());\n        }\n    }\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {\n        Assertion.affirm(basicConfig !\u003d null, \"BasicServerConfig can\u0027t be null\");\n        this.basicConfig \u003d basicConfig;\n    }\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig() {\n        return basicConfig;\n    }\n\n    /**\n     * Loads the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException {\n        if (getSecure().isLoad() \u003d\u003d false) {\n            throw new IllegalStateException(\"Secure setting is not yet enabled for loading!\");\n        }\n        logger.info(\"Loading Secure Context..\");\n        km \u003d null;\n        tm \u003d null;\n        try {\n            String ssManager \u003d \"org.quickserver.security.SecureStoreManager\";\n            if (getSecure().getSecureStore() !\u003d null)\n                ssManager \u003d getSecure().getSecureStore().getSecureStoreManager();\n            Class secureStoreManagerClass \u003d getClass(ssManager, true);\n            secureStoreManager \u003d (SecureStoreManager) secureStoreManagerClass.newInstance();\n            km \u003d secureStoreManager.loadKeyManagers(getConfig());\n            logger.fine(\"KeyManager got\");\n            tm \u003d secureStoreManager.loadTrustManagers(getConfig());\n            logger.fine(\"TrustManager got\");\n            sslc \u003d secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());\n            sslc.init(km, tm, null);\n            logger.fine(\"SSLContext loaded\");\n        } catch (KeyStoreException e) {\n            logger.warning(\"KeyStoreException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchAlgorithmException e) {\n            logger.warning(\"NoSuchAlgorithmException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchProviderException e) {\n            logger.warning(\"NoSuchProviderException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (UnrecoverableKeyException e) {\n            logger.warning(\"UnrecoverableKeyException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (CertificateException e) {\n            logger.warning(\"CertificateException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (KeyManagementException e) {\n            logger.warning(\"KeyManagementException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (GeneralSecurityException e) {\n            logger.warning(\"GeneralSecurityException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (ClassNotFoundException e) {\n            logger.warning(\"ClassNotFoundException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (InstantiationException e) {\n            logger.warning(\"InstantiationException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (IllegalAccessException e) {\n            logger.warning(\"IllegalAccessException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        return getSSLContext(null);\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        if (protocol !\u003d null \u0026\u0026 secureStoreManager !\u003d null) {\n            SSLContext _sslc \u003d secureStoreManager.getSSLContext(protocol);\n            _sslc.init(km, tm, null);\n            return _sslc;\n        }\n        return sslc;\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext());\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext(protocol));\n    }\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler) {\n        clientBinaryHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler() {\n        return clientBinaryHandlerString;\n    }\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector) {\n        this.selector \u003d selector;\n    }\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector() {\n        return selector;\n    }\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception {\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        //long stime \u003d System.currentTimeMillis();\n        //long etime \u003d System.currentTimeMillis();\n        while (true) {\n            //etime \u003d System.currentTimeMillis();\n            //System.out.println(\"Time Taken: \"+(etime-stime));\n            client \u003d server.accept();\n            //stime \u003d System.currentTimeMillis();\n            if (linger \u003c 0) {\n                client.setSoLinger(false, 0);\n            } else {\n                client.setSoLinger(true, linger);\n            }\n            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                //low delay\u003d10\n                client.setTrafficClass(socketTrafficClass);\n            }\n            logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n            }\n            if (stopServer) {\n                //Client connected when server was about to be shutdown.\n                try {\n                    client.close();\n                } catch (Exception e) {\n                }\n                break;\n            }\n            if (checkAccessConstraint(client) \u003d\u003d false) {\n                continue;\n            }\n            //Check if max connection has reached\n            if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);\n            } else {\n                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);\n            }\n            theClient.setTrusted(getSkipValidation());\n            theClient.setSocket(client);\n            //mostly null\n            theClient.setSocketChannel(client.getChannel());\n            if (clientDataClass !\u003d null) {\n                if (getClientDataPool() \u003d\u003d null) {\n                    clientData \u003d (ClientData) clientDataClass.newInstance();\n                } else {\n                    clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                }\n                theClient.setClientData(clientData);\n            }\n            try {\n                _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                _chPolled.handleClient(theClient);\n            } catch (java.util.NoSuchElementException nsee) {\n                logger.warning(\"Could not borrow ClientHandler from pool. Error: \" + nsee);\n                logger.warning(\"Closing Socket [\" + client + \"] since no ClientHandler available.\");\n                client.close();\n            }\n            if (_chPolled !\u003d null) {\n                try {\n                    getClientPool().addClient(_chPolled, true);\n                } catch (java.util.NoSuchElementException nsee) {\n                    logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                    //logger.warning(\"Closing Socket [\"+client+\"] since no Thread available.\");\n                    //client.close();\n                    //returnClientHandlerToPool(_chPolled);\n                }\n                _chPolled \u003d null;\n            }\n            client \u003d null;\n            //reset it back\n            setSkipValidation(false);\n        }\n        //end of loop\n    }\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception {\n        int selectCount \u003d 0;\n        Iterator iterator \u003d null;\n        SelectionKey key \u003d null;\n        ServerSocketChannel serverChannel \u003d null;\n        SocketChannel socketChannel \u003d null;\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        boolean stopServerProcessed \u003d false;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        registerChannelRequestMap \u003d new HashMap();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        while (true) {\n            selectCount \u003d selector.select(500);\n            //selectCount \u003d selector.select();//for testing\n            //check for any pending registerChannel req.\n            synchronized (registerChannelRequestMap) {\n                if (registerChannelRequestMap.size() \u003e 0) {\n                    RegisterChannelRequest req \u003d null;\n                    Object hashkey \u003d null;\n                    iterator \u003d registerChannelRequestMap.keySet().iterator();\n                    while (iterator.hasNext()) {\n                        hashkey \u003d iterator.next();\n                        req \u003d (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);\n                        req.register(getSelector());\n                    }\n                    iterator \u003d null;\n                    registerChannelRequestMap.clear();\n                }\n                //if\n            }\n            //sync\n            if (stopServer \u003d\u003d true \u0026\u0026 stopServerProcessed \u003d\u003d false) {\n                logger.warning(\"Closing \" + getName());\n                serverSocketChannel.close();\n                stopServerProcessed \u003d true;\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.warning(\"Closed \" + getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n            if (stopServer \u003d\u003d false \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                logger.finest(\"Server must have re-started.. will break\");\n                break;\n            }\n            if (selectCount \u003d\u003d 0 \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                java.util.Set keyset \u003d selector.keys();\n                if (keyset.isEmpty() \u003d\u003d true \u0026\u0026 getClientCount() \u003c\u003d 0) {\n                    break;\n                } else {\n                    continue;\n                }\n            } else if (selectCount \u003d\u003d 0) {\n                continue;\n            }\n            iterator \u003d selector.selectedKeys().iterator();\n            while (iterator.hasNext()) {\n                key \u003d (SelectionKey) iterator.next();\n                if (key.isValid() \u003d\u003d false) {\n                    iterator.remove();\n                    continue;\n                }\n                if (key.isAcceptable() \u0026\u0026 stopServer \u003d\u003d false) {\n                    logger.finest(\"Key is Acceptable\");\n                    serverChannel \u003d (ServerSocketChannel) key.channel();\n                    socketChannel \u003d serverChannel.accept();\n                    if (socketChannel \u003d\u003d null) {\n                        iterator.remove();\n                        continue;\n                    }\n                    client \u003d socketChannel.socket();\n                    if (linger \u003c 0) {\n                        client.setSoLinger(false, 0);\n                    } else {\n                        client.setSoLinger(true, linger);\n                    }\n                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                        //low delay\u003d10\n                        client.setTrafficClass(socketTrafficClass);\n                    }\n                    logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                        logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n                    }\n                    if (checkAccessConstraint(client) \u003d\u003d false) {\n                        iterator.remove();\n                        continue;\n                    }\n                    socketChannel.configureBlocking(false);\n                    theClient.setTrusted(getSkipValidation());\n                    theClient.setSocket(socketChannel.socket());\n                    theClient.setSocketChannel(socketChannel);\n                    if (clientDataClass !\u003d null) {\n                        if (getClientDataPool() \u003d\u003d null) {\n                            clientData \u003d (ClientData) clientDataClass.newInstance();\n                        } else {\n                            //borrow a object from pool\n                            clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                        }\n                        theClient.setClientData(clientData);\n                    }\n                    //Check if max connection has reached\n                    if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                        theClient.setClientEvent(ClientEvent.MAX_CON);\n                    } else {\n                        theClient.setClientEvent(ClientEvent.ACCEPT);\n                    }\n                    try {\n                        _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                        logger.finest(\"Asking \" + _chPolled.getName() + \" to handle.\");\n                        _chPolled.handleClient(theClient);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.warning(\"Could not borrow ClientHandler Object from pool. Error: \" + nsee);\n                        logger.warning(\"Closing SocketChannel [\" + serverChannel.socket() + \"] since no ClientHandler available.\");\n                        socketChannel.close();\n                    }\n                    if (_chPolled !\u003d null) {\n                        try {\n                            getClientPool().addClient(_chPolled, true);\n                        } catch (java.util.NoSuchElementException nsee) {\n                            logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                            //logger.warning(\"Closing SocketChannel [\"+serverChannel.socket()+\"] since no Thread available.\");\n                            //socketChannel.close();\n                            //returnClientHandlerToPool(_chPolled);\n                        }\n                        _chPolled \u003d null;\n                    }\n                    socketChannel \u003d null;\n                    client \u003d null;\n                    //reset it back\n                    setSkipValidation(false);\n                } else if (key.isValid() \u0026\u0026 key.isReadable()) {\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Readable, removing OP_READ from interestOps for \" + _ch.getName());\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_READ));\n                        _ch.addEvent(ClientEvent.READ);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.READ);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (key.isValid() \u0026\u0026 key.isWritable()) {\n                    if (getClientPool().shouldNioWriteHappen() \u003d\u003d false) {\n                        //no need to remove the key\n                        continue;\n                    }\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Writable, removing OP_WRITE from interestOps for \" + _ch.getName());\n                        //remove OP_WRITE from interest set\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_WRITE));\n                        _ch.addEvent(ClientEvent.WRITE);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.WRITE);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (stopServer \u003d\u003d true \u0026\u0026 key.isAcceptable()) {\n                    //we will not accept this key\n                    //reset it back\n                    setSkipValidation(false);\n                } else {\n                    logger.warning(\"Unknown key got in SelectionKey: \" + key);\n                }\n                //Remove key\n                iterator.remove();\n                Thread.yield();\n            }\n            //end of iterator\n            iterator \u003d null;\n        }\n        //end of loop\n    }\n\n    private boolean checkAccessConstraint(Socket socket) {\n        try {\n            if (getAccessConstraintConfig() !\u003d null) {\n                getAccessConstraintConfig().checkAccept(socket);\n            }\n            return true;\n        } catch (SecurityException se) {\n            logger.warning(\"SecurityException occurred accepting connection : \" + se.getMessage());\n            return false;\n        }\n    }\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {\n        if (getSelector() \u003d\u003d null) {\n            throw new IllegalStateException(\"Selector is not open!\");\n        }\n        if (channel \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Can\u0027t register a null channel!\");\n        }\n        if (channel.isConnected() \u003d\u003d false) {\n            throw new ClosedChannelException();\n        }\n        RegisterChannelRequest req \u003d new RegisterChannelRequest(channel, ops, att);\n        RegisterChannelRequest reqOld \u003d null;\n        synchronized (registerChannelRequestMap) {\n            reqOld \u003d (RegisterChannelRequest) registerChannelRequestMap.get(channel);\n            if (reqOld \u003d\u003d null) {\n                registerChannelRequestMap.put(channel, req);\n                getSelector().wakeup();\n                return true;\n            } else {\n                if (reqOld.equals(req) \u003d\u003d false) {\n                    reqOld.setOps(reqOld.getOps() | req.getOps());\n                    reqOld.setAtt(req.getAtt());\n                    return true;\n                }\n                return false;\n            }\n        }\n        /*\n\t\tlogger.warning(\"Before register...\");\n\t\tchannel.register(getSelector(), ops, att);\n\t\tlogger.warning(\"Before wakeup and after register...\");\n\t\tgetSelector().wakeup();\n\t\tlogger.warning(\"After wakeup...\");\n\t\t*/\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig) {\n        logger.finer(\"Creating ByteBufferPool pool\");\n        int bufferSize \u003d getBasicConfig().getAdvancedSettings().getByteBufferSize();\n        boolean useDirectByteBuffer \u003d getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();\n        PoolableObjectFactory factory \u003d new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);\n        byteBufferPool \u003d poolManager.makeByteBufferPool(factory, opConfig);\n        poolManager.initPool(byteBufferPool, opConfig);\n    }\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool() {\n        return byteBufferPool;\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientThread pool\");\n        ThreadObjectFactory factory \u003d new ThreadObjectFactory();\n        ObjectPool objectPool \u003d poolManager.makeClientPool(factory, opConfig);\n        pool \u003d new ClientPool(makeQSObjectPool(objectPool), opConfig);\n        factory.setClientPool(pool);\n        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());\n        poolManager.initPool(objectPool, opConfig);\n    }\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler) {\n        clientWriteHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler() {\n        return clientWriteHandlerString;\n    }\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be \u003ccode\u003enull\u003c/code\u003e if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime() {\n        return lastStartTime;\n    }\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag) {\n        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);\n        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);\n    }\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier() {\n        return clientIdentifier;\n    }\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {\n        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);\n    }\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode() {\n        return blockingMode;\n    }\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception {\n        if (clientCommandHandlerString \u003d\u003d null \u0026\u0026 clientEventHandlerString \u003d\u003d null) {\n            logger.severe(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n            throw new AppException(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n        }\n        clientCommandHandler \u003d null;\n        if (clientCommandHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientCommandHandler class..\");\n            Class clientCommandHandlerClass \u003d getClass(clientCommandHandlerString, true);\n            clientCommandHandler \u003d (ClientCommandHandler) clientCommandHandlerClass.newInstance();\n        }\n        boolean setClientCommandHandlerLookup \u003d false;\n        clientEventHandler \u003d null;\n        if (clientEventHandlerString \u003d\u003d null) {\n            clientEventHandlerString \u003d \"org.quickserver.net.server.impl.DefaultClientEventHandler\";\n            setClientCommandHandlerLookup \u003d true;\n        }\n        logger.finest(\"Loading ClientEventHandler class..\");\n        if (clientEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientEventHandler.class.isInstance(clientCommandHandler)) {\n            clientEventHandler \u003d (ClientEventHandler) clientCommandHandler;\n        } else {\n            clientEventHandler \u003d (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();\n            if (setClientCommandHandlerLookup) {\n                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);\n            }\n        }\n        clientExtendedEventHandler \u003d null;\n        if (clientExtendedEventHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientExtendedEventHandler class..\");\n            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientCommandHandler;\n            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientEventHandler;\n            } else {\n                Class clientExtendedEventHandlerClass \u003d getClass(clientExtendedEventHandlerString, true);\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();\n            }\n        }\n        clientObjectHandler \u003d null;\n        if (clientObjectHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientObjectHandler class..\");\n            if (clientObjectHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientCommandHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientCommandHandler;\n            } else if (clientObjectHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientEventHandler;\n            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientExtendedEventHandler;\n            } else {\n                clientObjectHandler \u003d (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientBinaryHandler \u003d null;\n        if (clientBinaryHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientBinaryHandler class..\");\n            if (clientBinaryHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientCommandHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientCommandHandler;\n            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientExtendedEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientObjectHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientObjectHandler;\n            } else {\n                clientBinaryHandler \u003d (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientWriteHandler \u003d null;\n        if (clientWriteHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientWriteHandler class..\");\n            if (clientWriteHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientCommandHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientCommandHandler;\n            } else if (clientWriteHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientEventHandler;\n            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientExtendedEventHandler;\n            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientObjectHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientObjectHandler;\n            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientBinaryHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientBinaryHandler;\n            } else {\n                clientWriteHandler \u003d (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        Class authenticatorClass \u003d null;\n        if (clientAuthenticationHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientAuthenticationHandler class..\");\n            authenticatorClass \u003d getClass(clientAuthenticationHandlerString, true);\n        }\n        if (authenticatorClass !\u003d null) {\n            Object obj \u003d authenticatorClass.newInstance();\n            if (ClientAuthenticationHandler.class.isInstance(obj))\n                clientAuthenticationHandler \u003d (ClientAuthenticationHandler) obj;\n            else\n                authenticator \u003d (Authenticator) obj;\n        }\n        clientDataClass \u003d null;\n        if (clientDataString !\u003d null) {\n            logger.finest(\"Loading ClientData class..\");\n            clientDataClass \u003d getClass(clientDataString, true);\n        }\n        Assertion.affirm(clientEventHandler !\u003d null, \"ClientEventHandler was not loaded!\");\n    }\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler) {\n        clientEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler() {\n        return clientEventHandlerString;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {\n        if (dataType \u003d\u003d DataType.IN)\n            this.defaultDataModeIN \u003d dataMode;\n        if (dataType \u003d\u003d DataType.OUT)\n            this.defaultDataModeOUT \u003d dataMode;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {\n        defaultDataModeIN \u003d defaultDataMode.getDataMode(DataType.IN);\n        defaultDataModeOUT \u003d defaultDataMode.getDataMode(DataType.OUT);\n        ;\n    }\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType) {\n        if (dataType \u003d\u003d DataType.IN)\n            return defaultDataModeIN;\n        if (dataType \u003d\u003d DataType.OUT)\n            return defaultDataModeOUT;\n        else\n            throw new IllegalArgumentException(\"Unknown DataType: \" + dataType);\n    }\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler) {\n        clientExtendedEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler() {\n        return clientExtendedEventHandlerString;\n    }\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception {\n        if (getApplicationJarPath() !\u003d null \u0026\u0026 getClassLoader() \u003d\u003d null) {\n            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));\n            //update qsadmin to use the same\n            if (adminServer !\u003d null) {\n                adminServer.getServer().setClassLoader(getClassLoader());\n            }\n        }\n    }\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID() {\n        return pid;\n    }\n\n    public boolean isRawCommunicationLogging() {\n        return rawCommunicationLogging;\n    }\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {\n        this.rawCommunicationLogging \u003d rawCommunicationLogging;\n    }\n\n    public int getRawCommunicationMaxLength() {\n        return rawCommunicationMaxLength;\n    }\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {\n        this.rawCommunicationMaxLength \u003d rawCommunicationMaxLength;\n    }\n}\n",
    "package": "org.quickserver.net.server",
    "classname": "QuickServer",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_10Test.java",
    "test_prompt": "// QuickServer_10Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#info()} method.\n*/\nclass QuickServer_10Test {",
    "method_signature": "info()",
    "suffix": "10"
  },
  {
    "numberTests": "ten",
    "original_code": "// QuickServer.java\n/*\n * This file is part of the QuickServer library \n * Copyright (C) QuickServer.org\n *\n * Use, modification, copying and distribution of this software is subject to\n * the terms and conditions of the GNU Lesser General Public License. \n * You should have received a copy of the GNU LGP License along with this \n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\n *\n * For questions, suggestions, bug-reports, enhancement-requests etc.\n * visit http://www.quickserver.org\n *\n */\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n *  Main class of QuickServer library. This class is used to create\n *  multi client servers quickly.\n *  \u003cp\u003e\n *  Ones a client is connected, it creates {@link ClientHandler} object,\n *  which is run using any thread available from the pool of threads\n *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n *  handles the client. \u003cbr/\u003e\n *  QuickServer divides the application logic of its developer over eight\n *  class, \u003cbr\u003e\n *  \t\u003cul\u003e\n * \t\t\u003cli\u003eClientEventHandler\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client events [Optional Class].\n *  \t\t\u003cli\u003eClientCommandHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client character/string commands.\n *  \t\t\u003cli\u003eClientObjectHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - Object commands.\n * \t\t\u003cli\u003eClientBinaryHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - binary data.\n * \t\t\u003cli\u003eClientWriteHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n *  \t\t\u003cli\u003eClientAuthenticationHandler [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Used to Authencatet a client.\n *  \t\t\u003cli\u003eClientData [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Client data carrier (support class)\n * \t\t\u003cli\u003eClientExtendedEventHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles extended client events.\n *  \t\u003c/ul\u003e\n *\n *  [#] \u003d Any one of these have to be set based on default DataMode for input.\n *  The default DataMode for input is String so if not changes you will\n *  have to set ClientCommandHandler.\n *  \u003c/p\u003e\n *  \u003cp\u003e\n *   Eg:\n *  \u003ccode\u003e\u003cBLOCKQUOTE\u003e\u003cpre\u003e\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle \u003d \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer \u003d new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * \u003c/pre\u003e\u003c/BLOCKQUOTE\u003e\u003c/code\u003e\u003c/p\u003e\n *\n *  @version 1.4.8\n *  @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //Some variable are not initialised to any value because the\n    //default java value was desired initial value.\n    //\u0027dev \u0027 \u003d development build not yet final\n    //\u0027beta\u0027 \u003d test build all features\n    //change also in QSAdminMain\n    private final static String VER \u003d \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n        if (System.getProperty(\"org.quickserver.useOSLineSeparator\") !\u003d null \u0026\u0026 System.getProperty(\"org.quickserver.useOSLineSeparator\").equals(\"true\")) {\n            NEW_LINE \u003d System.getProperty(\"line.separator\");\n        } else {\n            NEW_LINE \u003d \"\\r\\n\";\n        }\n        String _pid \u003d ManagementFactory.getRuntimeMXBean().getName();\n        int i \u003d _pid.indexOf(\"@\");\n        pid \u003d _pid.substring(0, i);\n        System.out.print(\"Loading QuickServer v\" + getVersion() + \" [PID:\" + pid + \"]\");\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort \u003d 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName \u003d \"QuickServer\";\n\n    private long maxConnection \u003d -1;\n\n    //1 min socket timeout\n    private int socketTimeout \u003d 60 * 1000;\n\n    private String maxConnectionMsg \u003d \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg \u003d \"-ERR Timeout\";\n\n    private String maxAuthTryMsg \u003d \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry \u003d 5;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //--v1.2\n    //Logger for QuickServer\n    private static final Logger logger \u003d Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //for Service interface\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState \u003d Service.UNKNOWN;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.3\n    private QuickServerConfig config \u003d new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel \u003d \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel \u003d \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation \u003d false;\n\n    private boolean communicationLogging \u003d true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig \u003d config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km \u003d null;\n\n    private TrustManager[] tm \u003d null;\n\n    private boolean runningSecure \u003d false;\n\n    private SecureStoreManager secureStoreManager \u003d null;\n\n    private Exception exceptionInRun \u003d null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode \u003d true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN \u003d DataMode.STRING;\n\n    private DataMode defaultDataModeOUT \u003d DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging \u003d false;\n\n    private int rawCommunicationMaxLength \u003d 100;\n\n    static {\n        System.out.println(\" Done\");\n        //should be commented if not a patch release\n        //System.out.println(\"[Includes patch(#): t\u003d152\u0026p\u003d532]\");\n        //should be commented if not a dev release\n        //System.out.println(\"[Dev Build Date: Saturday, October 29, 2005]\");\n        logger.log(Level.FINE, \"PID: {0}\", pid);\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion() {\n        return VER;\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo() {\n        return getVersionNo(VER);\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver) {\n        //String ver \u003d getVersion();\n        float version \u003d 0;\n        //check if beta\n        int i \u003d ver.indexOf(\" \");\n        if (i \u003d\u003d -1)\n            i \u003d ver.length();\n        ver \u003d ver.substring(0, i);\n        //check for sub version\n        i \u003d ver.indexOf(\".\");\n        if (i !\u003d -1) {\n            int j \u003d ver.indexOf(\".\", i);\n            if (j !\u003d -1) {\n                ver \u003d ver.substring(0, i) + \".\" + MyString.replaceAll(ver.substring(i + 1), \".\", \"\");\n            }\n        }\n        try {\n            version \u003d Float.parseFloat(ver);\n        } catch (NumberFormatException e) {\n            throw new RuntimeException(\"Corrupt QuickServer\");\n        }\n        return version;\n    }\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine() {\n        return NEW_LINE;\n    }\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString() {\n        return serverName + \" : \" + getPort();\n    }\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n        setClientCommandHandler(commandHandler);\n    }\n\n    /**\n     * Creates a new server at \u003ccode\u003eport\u003c/code\u003e with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n        //send to another constructor\n        this(commandHandler);\n        setPort(port);\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException {\n        logger.log(Level.FINE, \"Starting {0}\", getName());\n        if (isClosed() \u003d\u003d false) {\n            logger.log(Level.WARNING, \"Server {0} already running.\", getName());\n            throw new AppException(\"Server \" + getName() + \" already running.\");\n        }\n        blockingMode \u003d getBasicConfig().getServerMode().getBlocking();\n        if (getSecure().isEnable() \u0026\u0026 blockingMode \u003d\u003d false) {\n            //TODO we need to fix this..\n            logger.warning(\"QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode.\");\n            blockingMode \u003d true;\n            getBasicConfig().getServerMode().setBlocking(blockingMode);\n        }\n        if (serverBanner \u003d\u003d null) {\n            serverBanner \u003d \"\\n-------------------------------\" + \"\\n Name : \" + getName() + \"\\n Port : \" + getPort() + \"\\n-------------------------------\\n\";\n            logger.finest(\"Default Server Banner Generated\");\n        }\n        try {\n            loadApplicationClasses();\n            //load class from Advanced Settings\n            Class clientIdentifierClass \u003d getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);\n            clientIdentifier \u003d (ClientIdentifier) clientIdentifierClass.newInstance();\n            clientIdentifier.setQuickServer(QuickServer.this);\n            //load class from ObjectPoolConfig\n            Class poolManagerClass \u003d getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);\n            poolManager \u003d (PoolManager) poolManagerClass.newInstance();\n            //load class QSObjectPoolMaker\n            Class qsObjectPoolMakerClass \u003d getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);\n            qsObjectPoolMaker \u003d (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();\n            loadServerHooksClasses();\n            processServerHooks(ServerHook.PRE_STARTUP);\n            if (getSecure().isLoad() \u003d\u003d true)\n                //v1.4.0\n                loadSSLContext();\n            loadBusinessLogic();\n        } catch (ClassNotFoundException e) {\n            logger.log(Level.SEVERE, \"Could not load class/s: \" + e, e);\n            throw new AppException(\"Could not load class/s : \" + e);\n        } catch (InstantiationException e) {\n            logger.log(Level.SEVERE, \"Could not instantiate class/s: \" + e, e);\n            throw new AppException(\"Could not instantiate class/s: \" + e);\n        } catch (IllegalAccessException e) {\n            logger.log(Level.SEVERE, \"Illegal access to class/s: \" + e, e);\n            throw new AppException(\"Illegal access to class/s: \" + e);\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"IOException: \" + e, e);\n            throw new AppException(\"IOException: \" + e);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Exception: \" + e, e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Exception : \" + e);\n        }\n        //v1.3.3\n        if (getSecurityManagerClass() !\u003d null) {\n            System.setSecurityManager(getSecurityManager());\n        }\n        setServiceState(Service.INIT);\n        t \u003d new Thread(this, \"QuickServer - \" + getName());\n        t.start();\n        do {\n            Thread.yield();\n        } while (getServiceState() \u003d\u003d Service.INIT);\n        if (getServiceState() !\u003d Service.RUNNING) {\n            if (exceptionInRun !\u003d null)\n                throw new AppException(\"Could not start server \" + getName() + \"! Details: \" + exceptionInRun);\n            else\n                throw new AppException(\"Could not start server \" + getName());\n        }\n        lastStartTime \u003d new java.util.Date();\n        logger.log(Level.FINE, \"Started {0}, Date: {1}\", new Object[] { getName(), lastStartTime });\n    }\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException {\n        processServerHooks(ServerHook.PRE_SHUTDOWN);\n        logger.log(Level.WARNING, \"Stopping {0}\", getName());\n        stopServer \u003d true;\n        Socket death \u003d null;\n        if (isClosed() \u003d\u003d true) {\n            logger.log(Level.WARNING, \"Server {0} is not running!\", getName());\n            throw new AppException(\"Server \" + getName() + \" is not running!\");\n        }\n        try {\n            if (getBlockingMode() \u003d\u003d true) {\n                if (getSecure().isEnable() \u003d\u003d false) {\n                    death \u003d new Socket(server.getInetAddress(), server.getLocalPort());\n                    death.getInputStream().read();\n                    death.close();\n                } else {\n                    death \u003d getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());\n                    Thread.sleep(100);\n                    death.close();\n                }\n            }\n            if (serverSocketChannel !\u003d null) {\n                serverSocketChannel.close();\n            }\n        } catch (IOException e) {\n            logger.log(Level.FINE, \"IOError stopping {0}: {1}\", new Object[] { getName(), e });\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error stopping {0}: {1}\", new Object[] { getName(), e });\n            throw new AppException(\"Error in stopServer \" + getName() + \": \" + e);\n        }\n        for (int i \u003d 0; getServiceState() !\u003d Service.STOPPED; i++) {\n            try {\n                Thread.sleep(60);\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error waiting for {0} to fully stop. Error: {1}\", new Object[] { getName(), e });\n            }\n            if (i \u003e 1000) {\n                logger.severe(\"Server was not stopped even after 10sec.. will terminate now.\");\n                System.exit(-1);\n            }\n        }\n        if (adminServer \u003d\u003d null || getQSAdminServer().getServer() !\u003d this) {\n            //so this is not qsadmin\n            setClassLoader(null);\n        }\n        logger.log(Level.INFO, \"Stopped {0}\", getName());\n    }\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException {\n        stopServer();\n        startServer();\n    }\n\n    /**\n     * Returns the name of the QuickServer. Default is \u0027QuickServer\u0027.\n     * @see #setName\n     */\n    public String getName() {\n        return serverName;\n    }\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name) {\n        serverName \u003d name;\n        logger.log(Level.FINEST, \"Set to : {0}\", name);\n    }\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner() {\n        return serverBanner;\n    }\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. \u003cbr\u003e\u0026nbsp;\u003cbr\u003e\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner) {\n        serverBanner \u003d banner;\n        logger.log(Level.FINEST, \"Set to : {0}\", banner);\n    }\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port) {\n        if (port \u003c 0) {\n            throw new IllegalArgumentException(\"Port number can not be less than 0!\");\n        }\n        serverPort \u003d port;\n        logger.log(Level.FINEST, \"Set to {0}\", port);\n    }\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort() {\n        if (isClosed() \u003d\u003d false) {\n            return server.getLocalPort();\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            return serverPort;\n        } else {\n            int _port \u003d getSecure().getPort();\n            if (_port \u003d\u003d -1)\n                return serverPort;\n            else\n                return _port;\n        }\n    }\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler) {\n        clientCommandHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler() {\n        return clientCommandHandlerString;\n    }\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data) {\n        this.clientDataString \u003d data;\n        logger.log(Level.FINEST, \"Set to {0}\", data);\n    }\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData() {\n        return clientDataString;\n    }\n\n    /**\n     * Sets the client socket\u0027s timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time) {\n        if (time \u003e 0)\n            socketTimeout \u003d time;\n        else\n            socketTimeout \u003d 0;\n        logger.log(Level.FINEST, \"Set to {0}\", socketTimeout);\n    }\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout() {\n        return socketTimeout;\n    }\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry) {\n        maxAuthTry \u003d authTry;\n        logger.log(Level.FINEST, \"Set to {0}\", authTry);\n    }\n\n    /**\n     * Returns max allowed login attempts. Default is \u003ccode\u003e5\u003c/code\u003e.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry() {\n        return maxAuthTry;\n    }\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg) {\n        maxAuthTryMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg() {\n        return maxAuthTryMsg;\n    }\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg) {\n        timeoutMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg() {\n        return timeoutMsg;\n    }\n\n    private TheClient initTheClient() {\n        TheClient theClient \u003d new TheClient();\n        theClient.setServer(QuickServer.this);\n        theClient.setTimeoutMsg(getTimeoutMsg());\n        //v1.2\n        theClient.setMaxAuthTry(getMaxAuthTry());\n        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());\n        theClient.setClientEventHandler(clientEventHandler);\n        //v1.4.6\n        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);\n        theClient.setClientCommandHandler(clientCommandHandler);\n        //v1.2\n        theClient.setClientObjectHandler(clientObjectHandler);\n        //v1.4\n        theClient.setClientBinaryHandler(clientBinaryHandler);\n        //v1.4.5\n        theClient.setClientWriteHandler(clientWriteHandler);\n        //v1.3\n        theClient.setAuthenticator(authenticator);\n        //v1.4.6\n        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);\n        theClient.setTimeout(socketTimeout);\n        theClient.setMaxConnectionMsg(maxConnectionMsg);\n        //v1.3.2\n        theClient.setCommunicationLogging(getCommunicationLogging());\n        return theClient;\n    }\n\n    public void run() {\n        exceptionInRun \u003d null;\n        TheClient theClient \u003d initTheClient();\n        try {\n            stopServer \u003d false;\n            closeAllPools();\n            initAllPools();\n            makeServerSocket();\n            //print banner\n            System.out.println(serverBanner);\n            //v1.2\n            setServiceState(Service.RUNNING);\n            //v1.3.3\n            processServerHooks(ServerHook.POST_STARTUP);\n            if (getBlockingMode() \u003d\u003d false) {\n                runNonBlocking(theClient);\n                if (stopServer \u003d\u003d true) {\n                    logger.log(Level.FINEST, \"Closing selector for {0}\", getName());\n                    selector.close();\n                }\n                return;\n            } else {\n                runBlocking(theClient);\n            }\n        } catch (BindException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"{0} BindException for Port {1} @ {2} : {3}\", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });\n        } catch (javax.net.ssl.SSLException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"SSLException {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (IOException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"IOError {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (Exception e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"Error {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } finally {\n            if (getBlockingMode() \u003d\u003d true) {\n                logger.log(Level.WARNING, \"Closing {0}\", getName());\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            } else if (getBlockingMode() \u003d\u003d false \u0026\u0026 exceptionInRun !\u003d null) {\n                logger.log(Level.WARNING, \"Closing {0} - Had Error: {1}\", new Object[] { getName(), exceptionInRun });\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        if (serverSocketChannel !\u003d null)\n                            serverSocketChannel.close();\n                        if (server !\u003d null)\n                            server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n        }\n    }\n\n    //end of run\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnection \u003d maxConnection;\n        else\n            this.maxConnection \u003d maxConnection;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnection);\n    }\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection() {\n        return maxConnection;\n    }\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount() {\n        if (clientHandlerPool !\u003d null) {\n            try {\n                return getClientHandlerPool().getNumActive();\n            } catch (Exception e) {\n                return 0;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : \u003ccode\u003e-ERR Server Busy. Max Connection Reached\u003c/code\u003e\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n        else\n            this.maxConnectionMsg \u003d maxConnectionMsg;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnectionMsg);\n    }\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg() {\n        return maxConnectionMsg;\n    }\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException {\n        ipAddr \u003d InetAddress.getByName(bindAddr);\n        logger.log(Level.FINEST, \"Set to {0}\", bindAddr);\n    }\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr() {\n        if (ipAddr \u003d\u003d null) {\n            try {\n                ipAddr \u003d InetAddress.getByName(\"0.0.0.0\");\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Unable to create default ip(0.0.0.0) : {0}\", e);\n                throw new RuntimeException(\"Error: Unable to find servers own ip : \" + e);\n            }\n        }\n        return ipAddr;\n    }\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects) {\n        this.storeObjects \u003d storeObjects;\n    }\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return \u003ccode\u003enull\u003c/code\u003e.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects() {\n        return storeObjects;\n    }\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port) {\n        getQSAdminServer().getServer().setPort(port);\n    }\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort() {\n        return getQSAdminServer().getServer().getPort();\n    }\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator) {\n        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);\n    }\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator() {\n        return getQSAdminServer().getServer().getAuthenticator();\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException {\n        getQSAdminServer().setClientAuthenticationHandler(authenticator);\n        getQSAdminServer().startServer(port);\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException {\n        getQSAdminServer().startServer();\n    }\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer() {\n        if (adminServer \u003d\u003d null)\n            adminServer \u003d new QSAdminServer(QuickServer.this);\n        return adminServer;\n    }\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer) {\n        if (adminServer \u003d\u003d null)\n            this.adminServer \u003d adminServer;\n    }\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed() {\n        if (server \u003d\u003d null)\n            return true;\n        return server.isClosed();\n    }\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer\u0027s own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger() {\n        if (appLogger !\u003d null)\n            return appLogger;\n        return logger;\n    }\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger) {\n        this.appLogger \u003d appLogger;\n    }\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler) {\n        clientObjectHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler() {\n        return clientObjectHandlerString;\n    }\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n        if (formatter \u003d\u003d null)\n            return;\n        consoleLoggingformatter \u003d formatter;\n        java.util.logging.Formatter conformatter \u003d (java.util.logging.Formatter) getClass(formatter, true).newInstance();\n        Logger jdkLogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d jdkLogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                handlers[index].setFormatter(conformatter);\n            }\n        }\n        logger.log(Level.FINEST, \"Set to {0}\", formatter);\n    }\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter() {\n        return consoleLoggingformatter;\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MiniFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to logging.MiniFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MicroFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to MicroFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        boolean isConsole \u003d true;\n        try {\n            if (System.console() \u003d\u003d null) {\n                isConsole \u003d false;\n            }\n        } catch (Throwable e) {\n            //ignore\n        }\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                if (isConsole \u003d\u003d false \u0026\u0026 level !\u003d Level.OFF) {\n                    System.out.println(\"QuickServer: You do not have a console.. so turning console logger off..\");\n                    level \u003d Level.OFF;\n                }\n                if (level \u003d\u003d Level.OFF) {\n                    logger.info(\"QuickServer: Removing console handler.. \");\n                    rlogger.removeHandler(handlers[index]);\n                    handlers[index].setLevel(level);\n                    handlers[index].close();\n                } else {\n                    handlers[index].setLevel(level);\n                }\n            }\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            consoleLoggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            consoleLoggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            consoleLoggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            consoleLoggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            consoleLoggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            consoleLoggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            consoleLoggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            consoleLoggingLevel \u003d \"OFF\";\n        else\n            consoleLoggingLevel \u003d \"UNKNOWN\";\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel() {\n        return consoleLoggingLevel;\n    }\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            handlers[index].setLevel(level);\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            loggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            loggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            loggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            loggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            loggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            loggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            loggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            loggingLevel \u003d \"OFF\";\n        else\n            loggingLevel \u003d \"UNKNOWN\";\n        consoleLoggingLevel \u003d loggingLevel;\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    //*** Start of Service interface methods\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError() {\n        return serviceError;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param) {\n        serviceError \u003d null;\n        try {\n            initServer(param);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig) {\n        serviceError \u003d null;\n        try {\n            initServer(qsConfig);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING)\n            return false;\n        try {\n            startServer();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.STOPPED)\n            return false;\n        try {\n            stopServer();\n            clearAllPools();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING) {\n            suspendMaxConnection \u003d maxConnection;\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n            maxConnection \u003d 0;\n            maxConnectionMsg \u003d \"Service is suspended.\";\n            setServiceState(Service.SUSPENDED);\n            logger.log(Level.INFO, \"Service {0} is suspended.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.SUSPENDED) {\n            maxConnection \u003d suspendMaxConnection;\n            maxConnectionMsg \u003d suspendMaxConnectionMsg;\n            setServiceState(Service.RUNNING);\n            logger.log(Level.INFO, \"Service {0} resumed.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info() {\n        serviceError \u003d null;\n        StringBuilder buf \u003d new StringBuilder();\n        buf.append(getName()).append(\"\\n\");\n        buf.append(getBindAddr().getHostAddress()).append(\" \");\n        buf.append(getPort()).append(\"\\n\");\n        return buf.toString();\n    }\n\n    // *** End of Service interface methods\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException {\n        QuickServerConfig qsConfig \u003d null;\n        try {\n            qsConfig \u003d ConfigReader.read((String) param[0]);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not init server from xml file {0} : {1}\", new Object[] { new File((String) param[0]).getAbsolutePath(), e });\n            throw new AppException(\"Could not init server from xml file\", e);\n        }\n        initServer(qsConfig);\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {\n        setConfig(qsConfig);\n        try {\n            configQuickServer();\n            loadApplicationClasses();\n            //start InitServerHooks\n            InitServerHooks ish \u003d getConfig().getInitServerHooks();\n            if (ish !\u003d null) {\n                Iterator iterator \u003d ish.iterator();\n                String initServerHookClassName \u003d null;\n                Class initServerHookClass \u003d null;\n                InitServerHook initServerHook \u003d null;\n                while (iterator.hasNext()) {\n                    initServerHookClassName \u003d (String) iterator.next();\n                    initServerHookClass \u003d getClass(initServerHookClassName, true);\n                    initServerHook \u003d (InitServerHook) initServerHookClass.newInstance();\n                    logger.log(Level.INFO, \"Loaded init server hook: {0}\", initServerHookClassName);\n                    logger.log(Level.FINE, \"Init server hook info: {0}\", initServerHook.info());\n                    initServerHook.handleInit(QuickServer.this);\n                }\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not load init server hook: {0}\", e);\n            logger.log(Level.WARNING, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Could not load init server hook\", e);\n        }\n        setServiceState(Service.INIT);\n        logger.log(Level.FINEST, \"\\r\\n{0}\", MyString.getSystemInfo(getVersion()));\n    }\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState() {\n        return serviceState;\n    }\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state) {\n        serviceState \u003d state;\n    }\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp) {\n        if (temp.equals(\"SEVERE\"))\n            qs.setConsoleLoggingLevel(Level.SEVERE);\n        else if (temp.equals(\"WARNING\"))\n            qs.setConsoleLoggingLevel(Level.WARNING);\n        else if (temp.equals(\"INFO\"))\n            qs.setConsoleLoggingLevel(Level.INFO);\n        else if (temp.equals(\"CONFIG\"))\n            qs.setConsoleLoggingLevel(Level.CONFIG);\n        else if (temp.equals(\"FINE\"))\n            qs.setConsoleLoggingLevel(Level.FINE);\n        else if (temp.equals(\"FINER\"))\n            qs.setConsoleLoggingLevel(Level.FINER);\n        else if (temp.equals(\"FINEST\"))\n            qs.setConsoleLoggingLevel(Level.FINEST);\n        else if (temp.equals(\"OFF\"))\n            qs.setConsoleLoggingLevel(Level.OFF);\n        else\n            logger.log(Level.WARNING, \"unknown level {0}\", temp);\n    }\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception {\n        QuickServer qs \u003d QuickServer.this;\n        //v1.3\n        qs.setConfig(config);\n        qs.setBasicConfig(config);\n        String temp \u003d config.getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        temp \u003d null;\n        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        //v1.3.3\n        qs.setSecurityManagerClass(config.getSecurityManagerClass());\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        temp \u003d config.getApplicationJarPath();\n        if (temp !\u003d null) {\n            File ajp \u003d new File(temp);\n            if (ajp.isAbsolute() \u003d\u003d false) {\n                temp \u003d config.getConfigFile();\n                ajp \u003d new File(temp);\n                temp \u003d ajp.getParent() + File.separatorChar + config.getApplicationJarPath();\n                config.setApplicationJarPath(temp);\n                temp \u003d null;\n            }\n            qs.setApplicationJarPath(config.getApplicationJarPath());\n            //set path also to QSAdmin\n            if (config.getQSAdminServerConfig() !\u003d null) {\n                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());\n            }\n        }\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception {\n        QuickServer qs \u003d getQSAdminServer().getServer();\n        qs.setBasicConfig(config);\n        //set the Logging Level to same as main QS\n        //config.getConsoleLoggingLevel();\n        String temp \u003d getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        //set the Logging Formatter to same as main QS\n        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());\n        //v1.4.6\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        //v1.4.6\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());\n        //v1.3.2\n        if (config.getCommandShellEnable().equals(\"true\"))\n            getQSAdminServer().setShellEnable(true);\n        getQSAdminServer().setPromptName(config.getCommandShellPromptName());\n        //v1.3.3\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception {\n        configQuickServer(getConfig());\n        if (getConfig().getQSAdminServerConfig() !\u003d null) {\n            configQuickServer(getConfig().getQSAdminServerConfig());\n        }\n    }\n\n    /**\n     * Usage: QuickServer [-options]\u003cbr/\u003e\n     * Where options include:\u003cbr/\u003e\n     *   -about\t\tOpens About Dialogbox\u003cbr/\u003e\n     *   -load \u003cxml_config_file\u003e [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File \u003cnew_file_name\u003e\n     */\n    public static void main(String[] args) {\n        try {\n            if (args.length \u003e\u003d 1) {\n                if (args[0].equals(\"-about\")) {\n                    org.quickserver.net.server.gui.About.main(null);\n                } else if (args[0].equals(\"-load\") \u0026\u0026 args.length \u003e\u003d 2) {\n                    QuickServer qs \u003d QuickServer.load(args[1]);\n                    if (qs !\u003d null)\n                        handleOptions(args, qs);\n                } else {\n                    System.out.println(printUsage());\n                }\n            } else {\n                System.out.println(printUsage());\n                org.quickserver.net.server.gui.About.showAbout();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException {\n        QuickServer qs \u003d new QuickServer();\n        Object[] config \u003d new Object[] { xml };\n        qs.initServer(config);\n        qs.startServer();\n        if (qs.getConfig().getQSAdminServerConfig() !\u003d null) {\n            qs.startQSAdminServer();\n        }\n        return qs;\n    }\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage() {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"QuickServer - Java library/framework for creating robust multi-client TCP servers.\\n\");\n        sb.append(\"Copyright (C) QuickServer.org\\n\\n\");\n        sb.append(\"Usage: QuickServer [-options]\\n\");\n        sb.append(\"Where options include:\\n\");\n        sb.append(\"  -about\\t\" + \"Opens About Dialog box\\n\");\n        sb.append(\"  -load \u003cxml_config_file\u003e [load-options]\\t\" + \"Loads the server from xml file.\\n\");\n        sb.append(\"  Where load-options include:\\n\");\n        sb.append(\"     -fullXML2File \u003cfile_name\u003e\\t\" + \"Dumps the Full XML configuration of the QuickServer loaded.\\n\");\n        return sb.toString();\n    }\n\n    private static void handleOptions(String[] args, QuickServer quickserver) {\n        if (args.length \u003c 3)\n            return;\n        if (args[2].equals(\"-fullXML2File\") \u0026\u0026 args.length \u003e\u003d 4) {\n            File file \u003d new File(args[3]);\n            logger.log(Level.INFO, \"Writing full xml configuration to file: {0}\", file.getAbsolutePath());\n            try {\n                TextFile.write(file, quickserver.getConfig().toXML(null));\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error writing full xml configuration: {0}\", e);\n            }\n        }\n    }\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception {\n        try {\n            if (pool !\u003d null)\n                getClientPool().clear();\n            if (clientHandlerPool !\u003d null)\n                getClientHandlerPool().clear();\n            if (getClientDataPool() !\u003d null)\n                getClientDataPool().clear();\n            if (getDBPoolUtil() !\u003d null)\n                getDBPoolUtil().clean();\n            if (byteBufferPool !\u003d null)\n                getByteBufferPool().clear();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error: {0}\", e);\n            throw e;\n        }\n    }\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception {\n        if (pool \u003d\u003d null \u0026\u0026 clientHandlerPool \u003d\u003d null \u0026\u0026 getClientDataPool() \u003d\u003d null \u0026\u0026 getDBPoolUtil() \u003d\u003d null \u0026\u0026 byteBufferPool \u003d\u003d null) {\n            return;\n        }\n        logger.log(Level.FINE, \"Closing pools for {0}\", getName());\n        try {\n            if (pool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {\n                logger.finer(\"Closing ClientThread pool.\");\n                getClientPool().close();\n            }\n            if (clientHandlerPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientHandlerPool())) {\n                logger.finer(\"Closing ClientHandler pool.\");\n                getClientHandlerPool().close();\n            }\n            if (getClientDataPool() !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientDataPool())) {\n                logger.finer(\"Closing ClientData pool.\");\n                getClientDataPool().close();\n            }\n            if (getDBPoolUtil() !\u003d null) {\n                logger.finer(\"Closing DB pool.\");\n                getDBPoolUtil().clean();\n            }\n            if (byteBufferPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getByteBufferPool())) {\n                logger.finer(\"Closing ByteBuffer pool.\");\n                getByteBufferPool().close();\n            }\n            logger.log(Level.FINE, \"Closed pools for {0}\", getName());\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error closing pools for {0}: {1}\", new Object[] { getName(), e });\n            throw e;\n        }\n    }\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception {\n        logger.fine(\"Creating pools\");\n        if (getBlockingMode() \u003d\u003d false) {\n            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());\n        }\n        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());\n        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());\n        //check if client data is poolable\n        if (clientDataClass !\u003d null) {\n            try {\n                clientData \u003d (ClientData) clientDataClass.newInstance();\n                if (PoolableObject.class.isInstance(clientData) \u003d\u003d true) {\n                    PoolableObject po \u003d (PoolableObject) clientData;\n                    if (po.isPoolable() \u003d\u003d true) {\n                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());\n                    } else {\n                        clientDataPool \u003d null;\n                        logger.fine(\"ClientData is not poolable!\");\n                    }\n                }\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error: {0}\", e);\n                throw e;\n            }\n        }\n        try {\n            makeDBObjectPool();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error in makeDBObjectPool() : {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw e;\n        }\n        logger.fine(\"Created pools\");\n    }\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool() {\n        if (pool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientPool available yet!\");\n        return pool;\n    }\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientHandler pool\");\n        PoolableObjectFactory factory \u003d new ClientHandlerObjectFactory(getBlockingMode());\n        clientHandlerPool \u003d poolManager.makeClientHandlerPool(factory, opConfig);\n        poolManager.initPool(clientHandlerPool, opConfig);\n        clientHandlerPool \u003d makeQSObjectPool(clientHandlerPool);\n        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool() {\n        if (clientHandlerPool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientHandler Pool available yet!\");\n        return clientHandlerPool;\n    }\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config) {\n        this.config \u003d config;\n    }\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig() {\n        return config;\n    }\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientData pool\");\n        clientDataPool \u003d poolManager.makeClientDataPool(factory, opConfig);\n        poolManager.initPool(clientDataPool, opConfig);\n        clientDataPool \u003d makeQSObjectPool(clientDataPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool() {\n        return clientDataPool;\n    }\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return \u003ccode\u003enull\u003c/code\u003e\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil() {\n        return dBPoolUtil;\n    }\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {\n        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);\n    }\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception {\n        if (getConfig().getDBObjectPoolConfig() !\u003d null) {\n            logger.fine(\"Creating DBObject Pool\");\n            //logger.finest(\"Got:\\n\"+getConfig().getDBObjectPoolConfig().toXML(null));\n            Class dbPoolUtilClass \u003d getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);\n            dBPoolUtil \u003d (DBPoolUtil) dbPoolUtilClass.newInstance();\n            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());\n            dBPoolUtil.initPool();\n        }\n    }\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id) {\n        return clientIdentifier.findFirstClientById(id);\n    }\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  \u003ccode\u003e\u003cpre\u003e\n     *    Eg:\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tObject syncObj \u003d quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator \u003d quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tClientIdentifier clientIdentifier \u003d quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator \u003d clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    \u003c/code\u003e\u003c/pre\u003e\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient() {\n        return clientIdentifier.findAllClient();\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern) {\n        return clientIdentifier.findAllClientById(pattern);\n    }\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key) {\n        return clientIdentifier.findClientByKey(key);\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern) {\n        return clientIdentifier.findAllClientByKey(pattern);\n    }\n\n    /**\n     * Sets next client has a trusted client.\n     * \u003cp\u003eThis will skip any authentication and will not set any timeout.\u003c/p\u003e\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted() {\n        setSkipValidation(true);\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation() {\n        return skipValidation;\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation) {\n        skipValidation \u003d validation;\n    }\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging) {\n        this.communicationLogging \u003d communicationLogging;\n    }\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging() {\n        return communicationLogging;\n    }\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass) {\n        if (securityManagerClass !\u003d null)\n            this.securityManagerClass \u003d securityManagerClass;\n    }\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass() {\n        return securityManagerClass;\n    }\n\n    public SecurityManager getSecurityManager() throws AppException {\n        if (getSecurityManagerClass() \u003d\u003d null)\n            return null;\n        SecurityManager sm \u003d null;\n        try {\n            sm \u003d (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();\n        } catch (ClassNotFoundException e) {\n            throw new AppException(e.getMessage());\n        } catch (InstantiationException e) {\n            throw new AppException(e.getMessage());\n        } catch (IllegalAccessException e) {\n            throw new AppException(e.getMessage());\n        }\n        return sm;\n    }\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {\n        this.accessConstraintConfig \u003d accessConstraintConfig;\n    }\n\n    /**\n     * Returns Access constraints if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig() {\n        return accessConstraintConfig;\n    }\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader) {\n        this.classLoader \u003d classLoader;\n        Thread.currentThread().setContextClassLoader(classLoader);\n    }\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader() {\n        return classLoader;\n    }\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException {\n        if (name \u003d\u003d null)\n            throw new IllegalArgumentException(\"Class name can\u0027t be null!\");\n        logger.log(Level.FINEST, \"Class: {0}, reload: {1}\", new Object[] { name, reload });\n        if (reload \u003d\u003d true \u0026\u0026 classLoader !\u003d null) {\n            return classLoader.loadClass(name);\n        } else if (reload \u003d\u003d true \u0026\u0026 classLoader \u003d\u003d null \u0026\u0026 this.getClass().getClassLoader() !\u003d null) {\n            return this.getClass().getClassLoader().loadClass(name);\n        } else if (reload \u003d\u003d false \u0026\u0026 classLoader !\u003d null) {\n            return Class.forName(name, true, classLoader);\n        } else /*if(reload\u003d\u003dfalse \u0026\u0026 classLoader\u003d\u003dnull)*/\n        {\n            return Class.forName(name, true, this.getClass().getClassLoader());\n        }\n    }\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath) {\n        this.applicationJarPath \u003d applicationJarPath;\n    }\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath() {\n        return applicationJarPath;\n    }\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks) {\n        this.serverHooks \u003d serverHooks;\n    }\n\n    /**\n     * Returns ServerHooks if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks() {\n        if (serverHooks \u003d\u003d null)\n            serverHooks \u003d new ServerHooks();\n        return serverHooks;\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses() {\n        if (getServerHooks() \u003d\u003d null)\n            return;\n        listOfServerHooks \u003d new ArrayList();\n        ServerHook serverHook \u003d null;\n        String serverHookClassName \u003d null;\n        Class serverHookClass \u003d null;\n        //add system hooks\n        serverHook \u003d new GhostSocketReaper();\n        serverHook.initHook(QuickServer.this);\n        listOfServerHooks.add(serverHook);\n        ghostSocketReaper \u003d (GhostSocketReaper) serverHook;\n        //add user hooks if any\n        Iterator iterator \u003d getServerHooks().iterator();\n        while (iterator.hasNext()) {\n            serverHookClassName \u003d (String) iterator.next();\n            try {\n                serverHookClass \u003d getClass(serverHookClassName, true);\n                serverHook \u003d (ServerHook) serverHookClass.newInstance();\n                serverHook.initHook(QuickServer.this);\n                listOfServerHooks.add(serverHook);\n                logger.log(Level.INFO, \"Loaded server hook: {0}\", serverHookClassName);\n                logger.log(Level.FINE, \"Server hook info: {0}\", serverHook.info());\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Could not load server hook [{0}]: {1}\", new Object[] { serverHookClassName, e });\n                logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            }\n        }\n        //end of while\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event) {\n        if (listOfServerHooks \u003d\u003d null) {\n            logger.warning(\"listOfServerHooks was null!\");\n            return;\n        }\n        ServerHook serverHook \u003d null;\n        boolean result \u003d false;\n        Iterator iterator \u003d listOfServerHooks.iterator();\n        String hooktype \u003d \"UNKNOWN\";\n        switch(event) {\n            case ServerHook.PRE_STARTUP:\n                hooktype \u003d \"PRE_STARTUP\";\n                break;\n            case ServerHook.POST_STARTUP:\n                hooktype \u003d \"POST_STARTUP\";\n                break;\n            case ServerHook.PRE_SHUTDOWN:\n                hooktype \u003d \"PRE_SHUTDOWN\";\n                break;\n            case ServerHook.POST_SHUTDOWN:\n                hooktype \u003d \"POST_SHUTDOWN\";\n                break;\n        }\n        while (iterator.hasNext()) {\n            serverHook \u003d (ServerHook) iterator.next();\n            try {\n                result \u003d serverHook.handleEvent(event);\n            } catch (Exception e) {\n                result \u003d false;\n                logger.log(Level.WARNING, \"Error invoking {0} hook [{1}]: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });\n            }\n            logger.log(Level.FINE, \"Invoked {0} hook [{1}] was: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), result });\n        }\n    }\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone() {\n        Object object \u003d null;\n        try {\n            object \u003d super.clone();\n            QuickServer _qs \u003d (QuickServer) object;\n            _qs.setQSAdminServer(new QSAdminServer(_qs));\n        } catch (CloneNotSupportedException e) {\n            //should not happ\n            logger.log(Level.WARNING, \"Error cloning : {0}\", e);\n        }\n        return object;\n    }\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure) {\n        this.secure \u003d secure;\n    }\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure() {\n        if (secure \u003d\u003d null)\n            secure \u003d new Secure();\n        return secure;\n    }\n\n    /**\n     * \u003cp\u003eReturns if the server is running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure() {\n        return runningSecure;\n    }\n\n    /**\n     * \u003cp\u003eSets the server mode if its running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure) {\n        this.runningSecure \u003d runningSecure;\n    }\n\n    private File makeAbsoluteToConfig(String fileName) {\n        Assertion.affirm(fileName !\u003d null, \"FileName can\u0027t be null\");\n        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());\n    }\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException {\n        server \u003d null;\n        logger.log(Level.FINEST, \"Binding {0} to IP: {1}\", new Object[] { getName(), getBindAddr() });\n        InetSocketAddress bindAddress \u003d new InetSocketAddress(getBindAddr(), getPort());\n        try {\n            NetworkInterface ni \u003d NetworkInterface.getByInetAddress(getBindAddr());\n            if (ni !\u003d null) {\n                logger.fine(\"NetworkInterface: \" + ni);\n            }\n        } catch (Exception igrnore) {\n            /*ignore*/\n        } catch (Error igrnore) {\n            /*ignore*/\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Making a normal ServerSocket for {0}\", getName());\n            setRunningSecure(false);\n            if (getBlockingMode() \u003d\u003d false) {\n                //for non-blocking\n                serverSocketChannel \u003d ServerSocketChannel.open();\n                server \u003d serverSocketChannel.socket();\n                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n            } else {\n                //for blocking\n                server \u003d new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n            }\n        } else {\n            try {\n                logger.log(Level.FINE, \"Making a secure ServerSocket for {0}\", getName());\n                getSSLContext();\n                setRunningSecure(true);\n                if (getBlockingMode() \u003d\u003d false) {\n                    logger.log(Level.FINE, \"Making a secure ServerSocketChannel for {0}\", getName());\n                    //for non-blocking\n                    serverSocketChannel \u003d ServerSocketChannel.open();\n                    server \u003d serverSocketChannel.socket();\n                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n                } else {\n                    ServerSocketFactory ssf \u003d getSSLContext().getServerSocketFactory();\n                    SSLServerSocket serversocket \u003d (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());\n                    setRunningSecure(true);\n                    secureStoreManager.logSSLServerSocketInfo(serversocket);\n                    server \u003d serversocket;\n                    serverSocketChannel \u003d server.getChannel();\n                    if (serverSocketChannel \u003d\u003d null \u0026\u0026 getBlockingMode() \u003d\u003d false) {\n                        logger.warning(\"Secure Server does not support Channel! So will run in blocking mode.\");\n                        blockingMode \u003d false;\n                    }\n                }\n                //blocking\n            } catch (NoSuchAlgorithmException e) {\n                logger.log(Level.WARNING, \"NoSuchAlgorithmException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            } catch (KeyManagementException e) {\n                logger.log(Level.WARNING, \"KeyManagementException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            }\n        }\n        server.setReuseAddress(true);\n        int connectionTime \u003d 0;\n        int latency \u003d 0;\n        int bandwidth \u003d 0;\n        connectionTime \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();\n        latency \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();\n        bandwidth \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();\n        logger.log(Level.FINE, \"getPerformancePreferencesConnectionTime : {0}\", connectionTime);\n        logger.log(Level.FINE, \"getPerformancePreferencesLatency : {0}\", latency);\n        logger.log(Level.FINE, \"getPerformancePreferencesBandwidth : {0}\", bandwidth);\n        server.setPerformancePreferences(connectionTime, latency, bandwidth);\n        int clientSocketReceiveBufferSize \u003d getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();\n        if (clientSocketReceiveBufferSize \u003e 0) {\n            logger.log(Level.FINE, \"clientSocketReceiveBufferSize: {0}\", clientSocketReceiveBufferSize);\n            server.setReceiveBufferSize(clientSocketReceiveBufferSize);\n        }\n        if (getBlockingMode() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Server Mode {0} - Non Blocking\", getName());\n            if (selector \u003d\u003d null || selector.isOpen() \u003d\u003d false) {\n                logger.finest(\"Opening new selector\");\n                selector \u003d Selector.open();\n            } else {\n                logger.log(Level.FINEST, \"Reusing selector: {0}\", selector);\n            }\n            serverSocketChannel.configureBlocking(false);\n            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n            selector.wakeup();\n        } else {\n            logger.log(Level.FINE, \"Server Mode {0} - Blocking\", getName());\n        }\n    }\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {\n        Assertion.affirm(basicConfig !\u003d null, \"BasicServerConfig can\u0027t be null\");\n        this.basicConfig \u003d basicConfig;\n    }\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig() {\n        return basicConfig;\n    }\n\n    /**\n     * Loads the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException {\n        if (getSecure().isLoad() \u003d\u003d false) {\n            throw new IllegalStateException(\"Secure setting is not yet enabled for loading!\");\n        }\n        logger.info(\"Loading Secure Context..\");\n        km \u003d null;\n        tm \u003d null;\n        try {\n            String ssManager \u003d \"org.quickserver.security.SecureStoreManager\";\n            if (getSecure().getSecureStore() !\u003d null)\n                ssManager \u003d getSecure().getSecureStore().getSecureStoreManager();\n            Class secureStoreManagerClass \u003d getClass(ssManager, true);\n            secureStoreManager \u003d (SecureStoreManager) secureStoreManagerClass.newInstance();\n            km \u003d secureStoreManager.loadKeyManagers(getConfig());\n            logger.fine(\"KeyManager got\");\n            tm \u003d secureStoreManager.loadTrustManagers(getConfig());\n            logger.fine(\"TrustManager got\");\n            sslc \u003d secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());\n            sslc.init(km, tm, null);\n            logger.fine(\"SSLContext loaded\");\n        } catch (KeyStoreException e) {\n            logger.warning(\"KeyStoreException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchAlgorithmException e) {\n            logger.warning(\"NoSuchAlgorithmException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchProviderException e) {\n            logger.warning(\"NoSuchProviderException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (UnrecoverableKeyException e) {\n            logger.warning(\"UnrecoverableKeyException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (CertificateException e) {\n            logger.warning(\"CertificateException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (KeyManagementException e) {\n            logger.warning(\"KeyManagementException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (GeneralSecurityException e) {\n            logger.warning(\"GeneralSecurityException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (ClassNotFoundException e) {\n            logger.warning(\"ClassNotFoundException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (InstantiationException e) {\n            logger.warning(\"InstantiationException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (IllegalAccessException e) {\n            logger.warning(\"IllegalAccessException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        return getSSLContext(null);\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        if (protocol !\u003d null \u0026\u0026 secureStoreManager !\u003d null) {\n            SSLContext _sslc \u003d secureStoreManager.getSSLContext(protocol);\n            _sslc.init(km, tm, null);\n            return _sslc;\n        }\n        return sslc;\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext());\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext(protocol));\n    }\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler) {\n        clientBinaryHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler() {\n        return clientBinaryHandlerString;\n    }\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector) {\n        this.selector \u003d selector;\n    }\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector() {\n        return selector;\n    }\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception {\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        //long stime \u003d System.currentTimeMillis();\n        //long etime \u003d System.currentTimeMillis();\n        while (true) {\n            //etime \u003d System.currentTimeMillis();\n            //System.out.println(\"Time Taken: \"+(etime-stime));\n            client \u003d server.accept();\n            //stime \u003d System.currentTimeMillis();\n            if (linger \u003c 0) {\n                client.setSoLinger(false, 0);\n            } else {\n                client.setSoLinger(true, linger);\n            }\n            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                //low delay\u003d10\n                client.setTrafficClass(socketTrafficClass);\n            }\n            logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n            }\n            if (stopServer) {\n                //Client connected when server was about to be shutdown.\n                try {\n                    client.close();\n                } catch (Exception e) {\n                }\n                break;\n            }\n            if (checkAccessConstraint(client) \u003d\u003d false) {\n                continue;\n            }\n            //Check if max connection has reached\n            if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);\n            } else {\n                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);\n            }\n            theClient.setTrusted(getSkipValidation());\n            theClient.setSocket(client);\n            //mostly null\n            theClient.setSocketChannel(client.getChannel());\n            if (clientDataClass !\u003d null) {\n                if (getClientDataPool() \u003d\u003d null) {\n                    clientData \u003d (ClientData) clientDataClass.newInstance();\n                } else {\n                    clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                }\n                theClient.setClientData(clientData);\n            }\n            try {\n                _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                _chPolled.handleClient(theClient);\n            } catch (java.util.NoSuchElementException nsee) {\n                logger.warning(\"Could not borrow ClientHandler from pool. Error: \" + nsee);\n                logger.warning(\"Closing Socket [\" + client + \"] since no ClientHandler available.\");\n                client.close();\n            }\n            if (_chPolled !\u003d null) {\n                try {\n                    getClientPool().addClient(_chPolled, true);\n                } catch (java.util.NoSuchElementException nsee) {\n                    logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                    //logger.warning(\"Closing Socket [\"+client+\"] since no Thread available.\");\n                    //client.close();\n                    //returnClientHandlerToPool(_chPolled);\n                }\n                _chPolled \u003d null;\n            }\n            client \u003d null;\n            //reset it back\n            setSkipValidation(false);\n        }\n        //end of loop\n    }\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception {\n        int selectCount \u003d 0;\n        Iterator iterator \u003d null;\n        SelectionKey key \u003d null;\n        ServerSocketChannel serverChannel \u003d null;\n        SocketChannel socketChannel \u003d null;\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        boolean stopServerProcessed \u003d false;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        registerChannelRequestMap \u003d new HashMap();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        while (true) {\n            selectCount \u003d selector.select(500);\n            //selectCount \u003d selector.select();//for testing\n            //check for any pending registerChannel req.\n            synchronized (registerChannelRequestMap) {\n                if (registerChannelRequestMap.size() \u003e 0) {\n                    RegisterChannelRequest req \u003d null;\n                    Object hashkey \u003d null;\n                    iterator \u003d registerChannelRequestMap.keySet().iterator();\n                    while (iterator.hasNext()) {\n                        hashkey \u003d iterator.next();\n                        req \u003d (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);\n                        req.register(getSelector());\n                    }\n                    iterator \u003d null;\n                    registerChannelRequestMap.clear();\n                }\n                //if\n            }\n            //sync\n            if (stopServer \u003d\u003d true \u0026\u0026 stopServerProcessed \u003d\u003d false) {\n                logger.warning(\"Closing \" + getName());\n                serverSocketChannel.close();\n                stopServerProcessed \u003d true;\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.warning(\"Closed \" + getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n            if (stopServer \u003d\u003d false \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                logger.finest(\"Server must have re-started.. will break\");\n                break;\n            }\n            if (selectCount \u003d\u003d 0 \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                java.util.Set keyset \u003d selector.keys();\n                if (keyset.isEmpty() \u003d\u003d true \u0026\u0026 getClientCount() \u003c\u003d 0) {\n                    break;\n                } else {\n                    continue;\n                }\n            } else if (selectCount \u003d\u003d 0) {\n                continue;\n            }\n            iterator \u003d selector.selectedKeys().iterator();\n            while (iterator.hasNext()) {\n                key \u003d (SelectionKey) iterator.next();\n                if (key.isValid() \u003d\u003d false) {\n                    iterator.remove();\n                    continue;\n                }\n                if (key.isAcceptable() \u0026\u0026 stopServer \u003d\u003d false) {\n                    logger.finest(\"Key is Acceptable\");\n                    serverChannel \u003d (ServerSocketChannel) key.channel();\n                    socketChannel \u003d serverChannel.accept();\n                    if (socketChannel \u003d\u003d null) {\n                        iterator.remove();\n                        continue;\n                    }\n                    client \u003d socketChannel.socket();\n                    if (linger \u003c 0) {\n                        client.setSoLinger(false, 0);\n                    } else {\n                        client.setSoLinger(true, linger);\n                    }\n                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                        //low delay\u003d10\n                        client.setTrafficClass(socketTrafficClass);\n                    }\n                    logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                        logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n                    }\n                    if (checkAccessConstraint(client) \u003d\u003d false) {\n                        iterator.remove();\n                        continue;\n                    }\n                    socketChannel.configureBlocking(false);\n                    theClient.setTrusted(getSkipValidation());\n                    theClient.setSocket(socketChannel.socket());\n                    theClient.setSocketChannel(socketChannel);\n                    if (clientDataClass !\u003d null) {\n                        if (getClientDataPool() \u003d\u003d null) {\n                            clientData \u003d (ClientData) clientDataClass.newInstance();\n                        } else {\n                            //borrow a object from pool\n                            clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                        }\n                        theClient.setClientData(clientData);\n                    }\n                    //Check if max connection has reached\n                    if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                        theClient.setClientEvent(ClientEvent.MAX_CON);\n                    } else {\n                        theClient.setClientEvent(ClientEvent.ACCEPT);\n                    }\n                    try {\n                        _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                        logger.finest(\"Asking \" + _chPolled.getName() + \" to handle.\");\n                        _chPolled.handleClient(theClient);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.warning(\"Could not borrow ClientHandler Object from pool. Error: \" + nsee);\n                        logger.warning(\"Closing SocketChannel [\" + serverChannel.socket() + \"] since no ClientHandler available.\");\n                        socketChannel.close();\n                    }\n                    if (_chPolled !\u003d null) {\n                        try {\n                            getClientPool().addClient(_chPolled, true);\n                        } catch (java.util.NoSuchElementException nsee) {\n                            logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                            //logger.warning(\"Closing SocketChannel [\"+serverChannel.socket()+\"] since no Thread available.\");\n                            //socketChannel.close();\n                            //returnClientHandlerToPool(_chPolled);\n                        }\n                        _chPolled \u003d null;\n                    }\n                    socketChannel \u003d null;\n                    client \u003d null;\n                    //reset it back\n                    setSkipValidation(false);\n                } else if (key.isValid() \u0026\u0026 key.isReadable()) {\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Readable, removing OP_READ from interestOps for \" + _ch.getName());\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_READ));\n                        _ch.addEvent(ClientEvent.READ);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.READ);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (key.isValid() \u0026\u0026 key.isWritable()) {\n                    if (getClientPool().shouldNioWriteHappen() \u003d\u003d false) {\n                        //no need to remove the key\n                        continue;\n                    }\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Writable, removing OP_WRITE from interestOps for \" + _ch.getName());\n                        //remove OP_WRITE from interest set\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_WRITE));\n                        _ch.addEvent(ClientEvent.WRITE);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.WRITE);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (stopServer \u003d\u003d true \u0026\u0026 key.isAcceptable()) {\n                    //we will not accept this key\n                    //reset it back\n                    setSkipValidation(false);\n                } else {\n                    logger.warning(\"Unknown key got in SelectionKey: \" + key);\n                }\n                //Remove key\n                iterator.remove();\n                Thread.yield();\n            }\n            //end of iterator\n            iterator \u003d null;\n        }\n        //end of loop\n    }\n\n    private boolean checkAccessConstraint(Socket socket) {\n        try {\n            if (getAccessConstraintConfig() !\u003d null) {\n                getAccessConstraintConfig().checkAccept(socket);\n            }\n            return true;\n        } catch (SecurityException se) {\n            logger.warning(\"SecurityException occurred accepting connection : \" + se.getMessage());\n            return false;\n        }\n    }\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {\n        if (getSelector() \u003d\u003d null) {\n            throw new IllegalStateException(\"Selector is not open!\");\n        }\n        if (channel \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Can\u0027t register a null channel!\");\n        }\n        if (channel.isConnected() \u003d\u003d false) {\n            throw new ClosedChannelException();\n        }\n        RegisterChannelRequest req \u003d new RegisterChannelRequest(channel, ops, att);\n        RegisterChannelRequest reqOld \u003d null;\n        synchronized (registerChannelRequestMap) {\n            reqOld \u003d (RegisterChannelRequest) registerChannelRequestMap.get(channel);\n            if (reqOld \u003d\u003d null) {\n                registerChannelRequestMap.put(channel, req);\n                getSelector().wakeup();\n                return true;\n            } else {\n                if (reqOld.equals(req) \u003d\u003d false) {\n                    reqOld.setOps(reqOld.getOps() | req.getOps());\n                    reqOld.setAtt(req.getAtt());\n                    return true;\n                }\n                return false;\n            }\n        }\n        /*\n\t\tlogger.warning(\"Before register...\");\n\t\tchannel.register(getSelector(), ops, att);\n\t\tlogger.warning(\"Before wakeup and after register...\");\n\t\tgetSelector().wakeup();\n\t\tlogger.warning(\"After wakeup...\");\n\t\t*/\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig) {\n        logger.finer(\"Creating ByteBufferPool pool\");\n        int bufferSize \u003d getBasicConfig().getAdvancedSettings().getByteBufferSize();\n        boolean useDirectByteBuffer \u003d getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();\n        PoolableObjectFactory factory \u003d new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);\n        byteBufferPool \u003d poolManager.makeByteBufferPool(factory, opConfig);\n        poolManager.initPool(byteBufferPool, opConfig);\n    }\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool() {\n        return byteBufferPool;\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientThread pool\");\n        ThreadObjectFactory factory \u003d new ThreadObjectFactory();\n        ObjectPool objectPool \u003d poolManager.makeClientPool(factory, opConfig);\n        pool \u003d new ClientPool(makeQSObjectPool(objectPool), opConfig);\n        factory.setClientPool(pool);\n        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());\n        poolManager.initPool(objectPool, opConfig);\n    }\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler) {\n        clientWriteHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler() {\n        return clientWriteHandlerString;\n    }\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be \u003ccode\u003enull\u003c/code\u003e if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime() {\n        return lastStartTime;\n    }\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag) {\n        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);\n        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);\n    }\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier() {\n        return clientIdentifier;\n    }\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {\n        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);\n    }\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode() {\n        return blockingMode;\n    }\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception {\n        if (clientCommandHandlerString \u003d\u003d null \u0026\u0026 clientEventHandlerString \u003d\u003d null) {\n            logger.severe(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n            throw new AppException(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n        }\n        clientCommandHandler \u003d null;\n        if (clientCommandHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientCommandHandler class..\");\n            Class clientCommandHandlerClass \u003d getClass(clientCommandHandlerString, true);\n            clientCommandHandler \u003d (ClientCommandHandler) clientCommandHandlerClass.newInstance();\n        }\n        boolean setClientCommandHandlerLookup \u003d false;\n        clientEventHandler \u003d null;\n        if (clientEventHandlerString \u003d\u003d null) {\n            clientEventHandlerString \u003d \"org.quickserver.net.server.impl.DefaultClientEventHandler\";\n            setClientCommandHandlerLookup \u003d true;\n        }\n        logger.finest(\"Loading ClientEventHandler class..\");\n        if (clientEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientEventHandler.class.isInstance(clientCommandHandler)) {\n            clientEventHandler \u003d (ClientEventHandler) clientCommandHandler;\n        } else {\n            clientEventHandler \u003d (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();\n            if (setClientCommandHandlerLookup) {\n                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);\n            }\n        }\n        clientExtendedEventHandler \u003d null;\n        if (clientExtendedEventHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientExtendedEventHandler class..\");\n            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientCommandHandler;\n            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientEventHandler;\n            } else {\n                Class clientExtendedEventHandlerClass \u003d getClass(clientExtendedEventHandlerString, true);\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();\n            }\n        }\n        clientObjectHandler \u003d null;\n        if (clientObjectHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientObjectHandler class..\");\n            if (clientObjectHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientCommandHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientCommandHandler;\n            } else if (clientObjectHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientEventHandler;\n            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientExtendedEventHandler;\n            } else {\n                clientObjectHandler \u003d (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientBinaryHandler \u003d null;\n        if (clientBinaryHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientBinaryHandler class..\");\n            if (clientBinaryHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientCommandHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientCommandHandler;\n            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientExtendedEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientObjectHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientObjectHandler;\n            } else {\n                clientBinaryHandler \u003d (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientWriteHandler \u003d null;\n        if (clientWriteHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientWriteHandler class..\");\n            if (clientWriteHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientCommandHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientCommandHandler;\n            } else if (clientWriteHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientEventHandler;\n            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientExtendedEventHandler;\n            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientObjectHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientObjectHandler;\n            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientBinaryHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientBinaryHandler;\n            } else {\n                clientWriteHandler \u003d (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        Class authenticatorClass \u003d null;\n        if (clientAuthenticationHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientAuthenticationHandler class..\");\n            authenticatorClass \u003d getClass(clientAuthenticationHandlerString, true);\n        }\n        if (authenticatorClass !\u003d null) {\n            Object obj \u003d authenticatorClass.newInstance();\n            if (ClientAuthenticationHandler.class.isInstance(obj))\n                clientAuthenticationHandler \u003d (ClientAuthenticationHandler) obj;\n            else\n                authenticator \u003d (Authenticator) obj;\n        }\n        clientDataClass \u003d null;\n        if (clientDataString !\u003d null) {\n            logger.finest(\"Loading ClientData class..\");\n            clientDataClass \u003d getClass(clientDataString, true);\n        }\n        Assertion.affirm(clientEventHandler !\u003d null, \"ClientEventHandler was not loaded!\");\n    }\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler) {\n        clientEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler() {\n        return clientEventHandlerString;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {\n        if (dataType \u003d\u003d DataType.IN)\n            this.defaultDataModeIN \u003d dataMode;\n        if (dataType \u003d\u003d DataType.OUT)\n            this.defaultDataModeOUT \u003d dataMode;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {\n        defaultDataModeIN \u003d defaultDataMode.getDataMode(DataType.IN);\n        defaultDataModeOUT \u003d defaultDataMode.getDataMode(DataType.OUT);\n        ;\n    }\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType) {\n        if (dataType \u003d\u003d DataType.IN)\n            return defaultDataModeIN;\n        if (dataType \u003d\u003d DataType.OUT)\n            return defaultDataModeOUT;\n        else\n            throw new IllegalArgumentException(\"Unknown DataType: \" + dataType);\n    }\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler) {\n        clientExtendedEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler() {\n        return clientExtendedEventHandlerString;\n    }\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception {\n        if (getApplicationJarPath() !\u003d null \u0026\u0026 getClassLoader() \u003d\u003d null) {\n            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));\n            //update qsadmin to use the same\n            if (adminServer !\u003d null) {\n                adminServer.getServer().setClassLoader(getClassLoader());\n            }\n        }\n    }\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID() {\n        return pid;\n    }\n\n    public boolean isRawCommunicationLogging() {\n        return rawCommunicationLogging;\n    }\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {\n        this.rawCommunicationLogging \u003d rawCommunicationLogging;\n    }\n\n    public int getRawCommunicationMaxLength() {\n        return rawCommunicationMaxLength;\n    }\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {\n        this.rawCommunicationMaxLength \u003d rawCommunicationMaxLength;\n    }\n}\n",
    "package": "org.quickserver.net.server",
    "classname": "QuickServer",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_13Test.java",
    "test_prompt": "// QuickServer_13Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#findAllClient()} method.\n*/\nclass QuickServer_13Test {",
    "method_signature": "findAllClient()",
    "suffix": "13"
  },
  {
    "numberTests": "ten",
    "original_code": "// QuickServer.java\n/*\n * This file is part of the QuickServer library \n * Copyright (C) QuickServer.org\n *\n * Use, modification, copying and distribution of this software is subject to\n * the terms and conditions of the GNU Lesser General Public License. \n * You should have received a copy of the GNU LGP License along with this \n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\n *\n * For questions, suggestions, bug-reports, enhancement-requests etc.\n * visit http://www.quickserver.org\n *\n */\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n *  Main class of QuickServer library. This class is used to create\n *  multi client servers quickly.\n *  \u003cp\u003e\n *  Ones a client is connected, it creates {@link ClientHandler} object,\n *  which is run using any thread available from the pool of threads\n *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n *  handles the client. \u003cbr/\u003e\n *  QuickServer divides the application logic of its developer over eight\n *  class, \u003cbr\u003e\n *  \t\u003cul\u003e\n * \t\t\u003cli\u003eClientEventHandler\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client events [Optional Class].\n *  \t\t\u003cli\u003eClientCommandHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client character/string commands.\n *  \t\t\u003cli\u003eClientObjectHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - Object commands.\n * \t\t\u003cli\u003eClientBinaryHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - binary data.\n * \t\t\u003cli\u003eClientWriteHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n *  \t\t\u003cli\u003eClientAuthenticationHandler [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Used to Authencatet a client.\n *  \t\t\u003cli\u003eClientData [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Client data carrier (support class)\n * \t\t\u003cli\u003eClientExtendedEventHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles extended client events.\n *  \t\u003c/ul\u003e\n *\n *  [#] \u003d Any one of these have to be set based on default DataMode for input.\n *  The default DataMode for input is String so if not changes you will\n *  have to set ClientCommandHandler.\n *  \u003c/p\u003e\n *  \u003cp\u003e\n *   Eg:\n *  \u003ccode\u003e\u003cBLOCKQUOTE\u003e\u003cpre\u003e\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle \u003d \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer \u003d new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * \u003c/pre\u003e\u003c/BLOCKQUOTE\u003e\u003c/code\u003e\u003c/p\u003e\n *\n *  @version 1.4.8\n *  @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //Some variable are not initialised to any value because the\n    //default java value was desired initial value.\n    //\u0027dev \u0027 \u003d development build not yet final\n    //\u0027beta\u0027 \u003d test build all features\n    //change also in QSAdminMain\n    private final static String VER \u003d \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n        if (System.getProperty(\"org.quickserver.useOSLineSeparator\") !\u003d null \u0026\u0026 System.getProperty(\"org.quickserver.useOSLineSeparator\").equals(\"true\")) {\n            NEW_LINE \u003d System.getProperty(\"line.separator\");\n        } else {\n            NEW_LINE \u003d \"\\r\\n\";\n        }\n        String _pid \u003d ManagementFactory.getRuntimeMXBean().getName();\n        int i \u003d _pid.indexOf(\"@\");\n        pid \u003d _pid.substring(0, i);\n        System.out.print(\"Loading QuickServer v\" + getVersion() + \" [PID:\" + pid + \"]\");\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort \u003d 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName \u003d \"QuickServer\";\n\n    private long maxConnection \u003d -1;\n\n    //1 min socket timeout\n    private int socketTimeout \u003d 60 * 1000;\n\n    private String maxConnectionMsg \u003d \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg \u003d \"-ERR Timeout\";\n\n    private String maxAuthTryMsg \u003d \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry \u003d 5;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //--v1.2\n    //Logger for QuickServer\n    private static final Logger logger \u003d Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //for Service interface\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState \u003d Service.UNKNOWN;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.3\n    private QuickServerConfig config \u003d new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel \u003d \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel \u003d \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation \u003d false;\n\n    private boolean communicationLogging \u003d true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig \u003d config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km \u003d null;\n\n    private TrustManager[] tm \u003d null;\n\n    private boolean runningSecure \u003d false;\n\n    private SecureStoreManager secureStoreManager \u003d null;\n\n    private Exception exceptionInRun \u003d null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode \u003d true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN \u003d DataMode.STRING;\n\n    private DataMode defaultDataModeOUT \u003d DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging \u003d false;\n\n    private int rawCommunicationMaxLength \u003d 100;\n\n    static {\n        System.out.println(\" Done\");\n        //should be commented if not a patch release\n        //System.out.println(\"[Includes patch(#): t\u003d152\u0026p\u003d532]\");\n        //should be commented if not a dev release\n        //System.out.println(\"[Dev Build Date: Saturday, October 29, 2005]\");\n        logger.log(Level.FINE, \"PID: {0}\", pid);\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion() {\n        return VER;\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo() {\n        return getVersionNo(VER);\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver) {\n        //String ver \u003d getVersion();\n        float version \u003d 0;\n        //check if beta\n        int i \u003d ver.indexOf(\" \");\n        if (i \u003d\u003d -1)\n            i \u003d ver.length();\n        ver \u003d ver.substring(0, i);\n        //check for sub version\n        i \u003d ver.indexOf(\".\");\n        if (i !\u003d -1) {\n            int j \u003d ver.indexOf(\".\", i);\n            if (j !\u003d -1) {\n                ver \u003d ver.substring(0, i) + \".\" + MyString.replaceAll(ver.substring(i + 1), \".\", \"\");\n            }\n        }\n        try {\n            version \u003d Float.parseFloat(ver);\n        } catch (NumberFormatException e) {\n            throw new RuntimeException(\"Corrupt QuickServer\");\n        }\n        return version;\n    }\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine() {\n        return NEW_LINE;\n    }\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString() {\n        return serverName + \" : \" + getPort();\n    }\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n        setClientCommandHandler(commandHandler);\n    }\n\n    /**\n     * Creates a new server at \u003ccode\u003eport\u003c/code\u003e with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n        //send to another constructor\n        this(commandHandler);\n        setPort(port);\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException {\n        logger.log(Level.FINE, \"Starting {0}\", getName());\n        if (isClosed() \u003d\u003d false) {\n            logger.log(Level.WARNING, \"Server {0} already running.\", getName());\n            throw new AppException(\"Server \" + getName() + \" already running.\");\n        }\n        blockingMode \u003d getBasicConfig().getServerMode().getBlocking();\n        if (getSecure().isEnable() \u0026\u0026 blockingMode \u003d\u003d false) {\n            //TODO we need to fix this..\n            logger.warning(\"QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode.\");\n            blockingMode \u003d true;\n            getBasicConfig().getServerMode().setBlocking(blockingMode);\n        }\n        if (serverBanner \u003d\u003d null) {\n            serverBanner \u003d \"\\n-------------------------------\" + \"\\n Name : \" + getName() + \"\\n Port : \" + getPort() + \"\\n-------------------------------\\n\";\n            logger.finest(\"Default Server Banner Generated\");\n        }\n        try {\n            loadApplicationClasses();\n            //load class from Advanced Settings\n            Class clientIdentifierClass \u003d getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);\n            clientIdentifier \u003d (ClientIdentifier) clientIdentifierClass.newInstance();\n            clientIdentifier.setQuickServer(QuickServer.this);\n            //load class from ObjectPoolConfig\n            Class poolManagerClass \u003d getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);\n            poolManager \u003d (PoolManager) poolManagerClass.newInstance();\n            //load class QSObjectPoolMaker\n            Class qsObjectPoolMakerClass \u003d getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);\n            qsObjectPoolMaker \u003d (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();\n            loadServerHooksClasses();\n            processServerHooks(ServerHook.PRE_STARTUP);\n            if (getSecure().isLoad() \u003d\u003d true)\n                //v1.4.0\n                loadSSLContext();\n            loadBusinessLogic();\n        } catch (ClassNotFoundException e) {\n            logger.log(Level.SEVERE, \"Could not load class/s: \" + e, e);\n            throw new AppException(\"Could not load class/s : \" + e);\n        } catch (InstantiationException e) {\n            logger.log(Level.SEVERE, \"Could not instantiate class/s: \" + e, e);\n            throw new AppException(\"Could not instantiate class/s: \" + e);\n        } catch (IllegalAccessException e) {\n            logger.log(Level.SEVERE, \"Illegal access to class/s: \" + e, e);\n            throw new AppException(\"Illegal access to class/s: \" + e);\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"IOException: \" + e, e);\n            throw new AppException(\"IOException: \" + e);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Exception: \" + e, e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Exception : \" + e);\n        }\n        //v1.3.3\n        if (getSecurityManagerClass() !\u003d null) {\n            System.setSecurityManager(getSecurityManager());\n        }\n        setServiceState(Service.INIT);\n        t \u003d new Thread(this, \"QuickServer - \" + getName());\n        t.start();\n        do {\n            Thread.yield();\n        } while (getServiceState() \u003d\u003d Service.INIT);\n        if (getServiceState() !\u003d Service.RUNNING) {\n            if (exceptionInRun !\u003d null)\n                throw new AppException(\"Could not start server \" + getName() + \"! Details: \" + exceptionInRun);\n            else\n                throw new AppException(\"Could not start server \" + getName());\n        }\n        lastStartTime \u003d new java.util.Date();\n        logger.log(Level.FINE, \"Started {0}, Date: {1}\", new Object[] { getName(), lastStartTime });\n    }\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException {\n        processServerHooks(ServerHook.PRE_SHUTDOWN);\n        logger.log(Level.WARNING, \"Stopping {0}\", getName());\n        stopServer \u003d true;\n        Socket death \u003d null;\n        if (isClosed() \u003d\u003d true) {\n            logger.log(Level.WARNING, \"Server {0} is not running!\", getName());\n            throw new AppException(\"Server \" + getName() + \" is not running!\");\n        }\n        try {\n            if (getBlockingMode() \u003d\u003d true) {\n                if (getSecure().isEnable() \u003d\u003d false) {\n                    death \u003d new Socket(server.getInetAddress(), server.getLocalPort());\n                    death.getInputStream().read();\n                    death.close();\n                } else {\n                    death \u003d getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());\n                    Thread.sleep(100);\n                    death.close();\n                }\n            }\n            if (serverSocketChannel !\u003d null) {\n                serverSocketChannel.close();\n            }\n        } catch (IOException e) {\n            logger.log(Level.FINE, \"IOError stopping {0}: {1}\", new Object[] { getName(), e });\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error stopping {0}: {1}\", new Object[] { getName(), e });\n            throw new AppException(\"Error in stopServer \" + getName() + \": \" + e);\n        }\n        for (int i \u003d 0; getServiceState() !\u003d Service.STOPPED; i++) {\n            try {\n                Thread.sleep(60);\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error waiting for {0} to fully stop. Error: {1}\", new Object[] { getName(), e });\n            }\n            if (i \u003e 1000) {\n                logger.severe(\"Server was not stopped even after 10sec.. will terminate now.\");\n                System.exit(-1);\n            }\n        }\n        if (adminServer \u003d\u003d null || getQSAdminServer().getServer() !\u003d this) {\n            //so this is not qsadmin\n            setClassLoader(null);\n        }\n        logger.log(Level.INFO, \"Stopped {0}\", getName());\n    }\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException {\n        stopServer();\n        startServer();\n    }\n\n    /**\n     * Returns the name of the QuickServer. Default is \u0027QuickServer\u0027.\n     * @see #setName\n     */\n    public String getName() {\n        return serverName;\n    }\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name) {\n        serverName \u003d name;\n        logger.log(Level.FINEST, \"Set to : {0}\", name);\n    }\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner() {\n        return serverBanner;\n    }\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. \u003cbr\u003e\u0026nbsp;\u003cbr\u003e\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner) {\n        serverBanner \u003d banner;\n        logger.log(Level.FINEST, \"Set to : {0}\", banner);\n    }\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port) {\n        if (port \u003c 0) {\n            throw new IllegalArgumentException(\"Port number can not be less than 0!\");\n        }\n        serverPort \u003d port;\n        logger.log(Level.FINEST, \"Set to {0}\", port);\n    }\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort() {\n        if (isClosed() \u003d\u003d false) {\n            return server.getLocalPort();\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            return serverPort;\n        } else {\n            int _port \u003d getSecure().getPort();\n            if (_port \u003d\u003d -1)\n                return serverPort;\n            else\n                return _port;\n        }\n    }\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler) {\n        clientCommandHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler() {\n        return clientCommandHandlerString;\n    }\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data) {\n        this.clientDataString \u003d data;\n        logger.log(Level.FINEST, \"Set to {0}\", data);\n    }\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData() {\n        return clientDataString;\n    }\n\n    /**\n     * Sets the client socket\u0027s timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time) {\n        if (time \u003e 0)\n            socketTimeout \u003d time;\n        else\n            socketTimeout \u003d 0;\n        logger.log(Level.FINEST, \"Set to {0}\", socketTimeout);\n    }\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout() {\n        return socketTimeout;\n    }\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry) {\n        maxAuthTry \u003d authTry;\n        logger.log(Level.FINEST, \"Set to {0}\", authTry);\n    }\n\n    /**\n     * Returns max allowed login attempts. Default is \u003ccode\u003e5\u003c/code\u003e.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry() {\n        return maxAuthTry;\n    }\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg) {\n        maxAuthTryMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg() {\n        return maxAuthTryMsg;\n    }\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg) {\n        timeoutMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg() {\n        return timeoutMsg;\n    }\n\n    private TheClient initTheClient() {\n        TheClient theClient \u003d new TheClient();\n        theClient.setServer(QuickServer.this);\n        theClient.setTimeoutMsg(getTimeoutMsg());\n        //v1.2\n        theClient.setMaxAuthTry(getMaxAuthTry());\n        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());\n        theClient.setClientEventHandler(clientEventHandler);\n        //v1.4.6\n        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);\n        theClient.setClientCommandHandler(clientCommandHandler);\n        //v1.2\n        theClient.setClientObjectHandler(clientObjectHandler);\n        //v1.4\n        theClient.setClientBinaryHandler(clientBinaryHandler);\n        //v1.4.5\n        theClient.setClientWriteHandler(clientWriteHandler);\n        //v1.3\n        theClient.setAuthenticator(authenticator);\n        //v1.4.6\n        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);\n        theClient.setTimeout(socketTimeout);\n        theClient.setMaxConnectionMsg(maxConnectionMsg);\n        //v1.3.2\n        theClient.setCommunicationLogging(getCommunicationLogging());\n        return theClient;\n    }\n\n    public void run() {\n        exceptionInRun \u003d null;\n        TheClient theClient \u003d initTheClient();\n        try {\n            stopServer \u003d false;\n            closeAllPools();\n            initAllPools();\n            makeServerSocket();\n            //print banner\n            System.out.println(serverBanner);\n            //v1.2\n            setServiceState(Service.RUNNING);\n            //v1.3.3\n            processServerHooks(ServerHook.POST_STARTUP);\n            if (getBlockingMode() \u003d\u003d false) {\n                runNonBlocking(theClient);\n                if (stopServer \u003d\u003d true) {\n                    logger.log(Level.FINEST, \"Closing selector for {0}\", getName());\n                    selector.close();\n                }\n                return;\n            } else {\n                runBlocking(theClient);\n            }\n        } catch (BindException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"{0} BindException for Port {1} @ {2} : {3}\", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });\n        } catch (javax.net.ssl.SSLException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"SSLException {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (IOException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"IOError {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (Exception e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"Error {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } finally {\n            if (getBlockingMode() \u003d\u003d true) {\n                logger.log(Level.WARNING, \"Closing {0}\", getName());\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            } else if (getBlockingMode() \u003d\u003d false \u0026\u0026 exceptionInRun !\u003d null) {\n                logger.log(Level.WARNING, \"Closing {0} - Had Error: {1}\", new Object[] { getName(), exceptionInRun });\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        if (serverSocketChannel !\u003d null)\n                            serverSocketChannel.close();\n                        if (server !\u003d null)\n                            server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n        }\n    }\n\n    //end of run\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnection \u003d maxConnection;\n        else\n            this.maxConnection \u003d maxConnection;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnection);\n    }\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection() {\n        return maxConnection;\n    }\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount() {\n        if (clientHandlerPool !\u003d null) {\n            try {\n                return getClientHandlerPool().getNumActive();\n            } catch (Exception e) {\n                return 0;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : \u003ccode\u003e-ERR Server Busy. Max Connection Reached\u003c/code\u003e\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n        else\n            this.maxConnectionMsg \u003d maxConnectionMsg;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnectionMsg);\n    }\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg() {\n        return maxConnectionMsg;\n    }\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException {\n        ipAddr \u003d InetAddress.getByName(bindAddr);\n        logger.log(Level.FINEST, \"Set to {0}\", bindAddr);\n    }\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr() {\n        if (ipAddr \u003d\u003d null) {\n            try {\n                ipAddr \u003d InetAddress.getByName(\"0.0.0.0\");\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Unable to create default ip(0.0.0.0) : {0}\", e);\n                throw new RuntimeException(\"Error: Unable to find servers own ip : \" + e);\n            }\n        }\n        return ipAddr;\n    }\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects) {\n        this.storeObjects \u003d storeObjects;\n    }\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return \u003ccode\u003enull\u003c/code\u003e.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects() {\n        return storeObjects;\n    }\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port) {\n        getQSAdminServer().getServer().setPort(port);\n    }\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort() {\n        return getQSAdminServer().getServer().getPort();\n    }\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator) {\n        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);\n    }\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator() {\n        return getQSAdminServer().getServer().getAuthenticator();\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException {\n        getQSAdminServer().setClientAuthenticationHandler(authenticator);\n        getQSAdminServer().startServer(port);\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException {\n        getQSAdminServer().startServer();\n    }\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer() {\n        if (adminServer \u003d\u003d null)\n            adminServer \u003d new QSAdminServer(QuickServer.this);\n        return adminServer;\n    }\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer) {\n        if (adminServer \u003d\u003d null)\n            this.adminServer \u003d adminServer;\n    }\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed() {\n        if (server \u003d\u003d null)\n            return true;\n        return server.isClosed();\n    }\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer\u0027s own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger() {\n        if (appLogger !\u003d null)\n            return appLogger;\n        return logger;\n    }\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger) {\n        this.appLogger \u003d appLogger;\n    }\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler) {\n        clientObjectHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler() {\n        return clientObjectHandlerString;\n    }\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n        if (formatter \u003d\u003d null)\n            return;\n        consoleLoggingformatter \u003d formatter;\n        java.util.logging.Formatter conformatter \u003d (java.util.logging.Formatter) getClass(formatter, true).newInstance();\n        Logger jdkLogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d jdkLogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                handlers[index].setFormatter(conformatter);\n            }\n        }\n        logger.log(Level.FINEST, \"Set to {0}\", formatter);\n    }\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter() {\n        return consoleLoggingformatter;\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MiniFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to logging.MiniFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MicroFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to MicroFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        boolean isConsole \u003d true;\n        try {\n            if (System.console() \u003d\u003d null) {\n                isConsole \u003d false;\n            }\n        } catch (Throwable e) {\n            //ignore\n        }\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                if (isConsole \u003d\u003d false \u0026\u0026 level !\u003d Level.OFF) {\n                    System.out.println(\"QuickServer: You do not have a console.. so turning console logger off..\");\n                    level \u003d Level.OFF;\n                }\n                if (level \u003d\u003d Level.OFF) {\n                    logger.info(\"QuickServer: Removing console handler.. \");\n                    rlogger.removeHandler(handlers[index]);\n                    handlers[index].setLevel(level);\n                    handlers[index].close();\n                } else {\n                    handlers[index].setLevel(level);\n                }\n            }\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            consoleLoggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            consoleLoggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            consoleLoggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            consoleLoggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            consoleLoggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            consoleLoggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            consoleLoggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            consoleLoggingLevel \u003d \"OFF\";\n        else\n            consoleLoggingLevel \u003d \"UNKNOWN\";\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel() {\n        return consoleLoggingLevel;\n    }\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            handlers[index].setLevel(level);\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            loggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            loggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            loggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            loggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            loggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            loggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            loggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            loggingLevel \u003d \"OFF\";\n        else\n            loggingLevel \u003d \"UNKNOWN\";\n        consoleLoggingLevel \u003d loggingLevel;\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    //*** Start of Service interface methods\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError() {\n        return serviceError;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param) {\n        serviceError \u003d null;\n        try {\n            initServer(param);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig) {\n        serviceError \u003d null;\n        try {\n            initServer(qsConfig);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING)\n            return false;\n        try {\n            startServer();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.STOPPED)\n            return false;\n        try {\n            stopServer();\n            clearAllPools();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING) {\n            suspendMaxConnection \u003d maxConnection;\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n            maxConnection \u003d 0;\n            maxConnectionMsg \u003d \"Service is suspended.\";\n            setServiceState(Service.SUSPENDED);\n            logger.log(Level.INFO, \"Service {0} is suspended.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.SUSPENDED) {\n            maxConnection \u003d suspendMaxConnection;\n            maxConnectionMsg \u003d suspendMaxConnectionMsg;\n            setServiceState(Service.RUNNING);\n            logger.log(Level.INFO, \"Service {0} resumed.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info() {\n        serviceError \u003d null;\n        StringBuilder buf \u003d new StringBuilder();\n        buf.append(getName()).append(\"\\n\");\n        buf.append(getBindAddr().getHostAddress()).append(\" \");\n        buf.append(getPort()).append(\"\\n\");\n        return buf.toString();\n    }\n\n    // *** End of Service interface methods\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException {\n        QuickServerConfig qsConfig \u003d null;\n        try {\n            qsConfig \u003d ConfigReader.read((String) param[0]);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not init server from xml file {0} : {1}\", new Object[] { new File((String) param[0]).getAbsolutePath(), e });\n            throw new AppException(\"Could not init server from xml file\", e);\n        }\n        initServer(qsConfig);\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {\n        setConfig(qsConfig);\n        try {\n            configQuickServer();\n            loadApplicationClasses();\n            //start InitServerHooks\n            InitServerHooks ish \u003d getConfig().getInitServerHooks();\n            if (ish !\u003d null) {\n                Iterator iterator \u003d ish.iterator();\n                String initServerHookClassName \u003d null;\n                Class initServerHookClass \u003d null;\n                InitServerHook initServerHook \u003d null;\n                while (iterator.hasNext()) {\n                    initServerHookClassName \u003d (String) iterator.next();\n                    initServerHookClass \u003d getClass(initServerHookClassName, true);\n                    initServerHook \u003d (InitServerHook) initServerHookClass.newInstance();\n                    logger.log(Level.INFO, \"Loaded init server hook: {0}\", initServerHookClassName);\n                    logger.log(Level.FINE, \"Init server hook info: {0}\", initServerHook.info());\n                    initServerHook.handleInit(QuickServer.this);\n                }\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not load init server hook: {0}\", e);\n            logger.log(Level.WARNING, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Could not load init server hook\", e);\n        }\n        setServiceState(Service.INIT);\n        logger.log(Level.FINEST, \"\\r\\n{0}\", MyString.getSystemInfo(getVersion()));\n    }\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState() {\n        return serviceState;\n    }\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state) {\n        serviceState \u003d state;\n    }\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp) {\n        if (temp.equals(\"SEVERE\"))\n            qs.setConsoleLoggingLevel(Level.SEVERE);\n        else if (temp.equals(\"WARNING\"))\n            qs.setConsoleLoggingLevel(Level.WARNING);\n        else if (temp.equals(\"INFO\"))\n            qs.setConsoleLoggingLevel(Level.INFO);\n        else if (temp.equals(\"CONFIG\"))\n            qs.setConsoleLoggingLevel(Level.CONFIG);\n        else if (temp.equals(\"FINE\"))\n            qs.setConsoleLoggingLevel(Level.FINE);\n        else if (temp.equals(\"FINER\"))\n            qs.setConsoleLoggingLevel(Level.FINER);\n        else if (temp.equals(\"FINEST\"))\n            qs.setConsoleLoggingLevel(Level.FINEST);\n        else if (temp.equals(\"OFF\"))\n            qs.setConsoleLoggingLevel(Level.OFF);\n        else\n            logger.log(Level.WARNING, \"unknown level {0}\", temp);\n    }\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception {\n        QuickServer qs \u003d QuickServer.this;\n        //v1.3\n        qs.setConfig(config);\n        qs.setBasicConfig(config);\n        String temp \u003d config.getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        temp \u003d null;\n        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        //v1.3.3\n        qs.setSecurityManagerClass(config.getSecurityManagerClass());\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        temp \u003d config.getApplicationJarPath();\n        if (temp !\u003d null) {\n            File ajp \u003d new File(temp);\n            if (ajp.isAbsolute() \u003d\u003d false) {\n                temp \u003d config.getConfigFile();\n                ajp \u003d new File(temp);\n                temp \u003d ajp.getParent() + File.separatorChar + config.getApplicationJarPath();\n                config.setApplicationJarPath(temp);\n                temp \u003d null;\n            }\n            qs.setApplicationJarPath(config.getApplicationJarPath());\n            //set path also to QSAdmin\n            if (config.getQSAdminServerConfig() !\u003d null) {\n                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());\n            }\n        }\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception {\n        QuickServer qs \u003d getQSAdminServer().getServer();\n        qs.setBasicConfig(config);\n        //set the Logging Level to same as main QS\n        //config.getConsoleLoggingLevel();\n        String temp \u003d getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        //set the Logging Formatter to same as main QS\n        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());\n        //v1.4.6\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        //v1.4.6\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());\n        //v1.3.2\n        if (config.getCommandShellEnable().equals(\"true\"))\n            getQSAdminServer().setShellEnable(true);\n        getQSAdminServer().setPromptName(config.getCommandShellPromptName());\n        //v1.3.3\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception {\n        configQuickServer(getConfig());\n        if (getConfig().getQSAdminServerConfig() !\u003d null) {\n            configQuickServer(getConfig().getQSAdminServerConfig());\n        }\n    }\n\n    /**\n     * Usage: QuickServer [-options]\u003cbr/\u003e\n     * Where options include:\u003cbr/\u003e\n     *   -about\t\tOpens About Dialogbox\u003cbr/\u003e\n     *   -load \u003cxml_config_file\u003e [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File \u003cnew_file_name\u003e\n     */\n    public static void main(String[] args) {\n        try {\n            if (args.length \u003e\u003d 1) {\n                if (args[0].equals(\"-about\")) {\n                    org.quickserver.net.server.gui.About.main(null);\n                } else if (args[0].equals(\"-load\") \u0026\u0026 args.length \u003e\u003d 2) {\n                    QuickServer qs \u003d QuickServer.load(args[1]);\n                    if (qs !\u003d null)\n                        handleOptions(args, qs);\n                } else {\n                    System.out.println(printUsage());\n                }\n            } else {\n                System.out.println(printUsage());\n                org.quickserver.net.server.gui.About.showAbout();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException {\n        QuickServer qs \u003d new QuickServer();\n        Object[] config \u003d new Object[] { xml };\n        qs.initServer(config);\n        qs.startServer();\n        if (qs.getConfig().getQSAdminServerConfig() !\u003d null) {\n            qs.startQSAdminServer();\n        }\n        return qs;\n    }\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage() {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"QuickServer - Java library/framework for creating robust multi-client TCP servers.\\n\");\n        sb.append(\"Copyright (C) QuickServer.org\\n\\n\");\n        sb.append(\"Usage: QuickServer [-options]\\n\");\n        sb.append(\"Where options include:\\n\");\n        sb.append(\"  -about\\t\" + \"Opens About Dialog box\\n\");\n        sb.append(\"  -load \u003cxml_config_file\u003e [load-options]\\t\" + \"Loads the server from xml file.\\n\");\n        sb.append(\"  Where load-options include:\\n\");\n        sb.append(\"     -fullXML2File \u003cfile_name\u003e\\t\" + \"Dumps the Full XML configuration of the QuickServer loaded.\\n\");\n        return sb.toString();\n    }\n\n    private static void handleOptions(String[] args, QuickServer quickserver) {\n        if (args.length \u003c 3)\n            return;\n        if (args[2].equals(\"-fullXML2File\") \u0026\u0026 args.length \u003e\u003d 4) {\n            File file \u003d new File(args[3]);\n            logger.log(Level.INFO, \"Writing full xml configuration to file: {0}\", file.getAbsolutePath());\n            try {\n                TextFile.write(file, quickserver.getConfig().toXML(null));\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error writing full xml configuration: {0}\", e);\n            }\n        }\n    }\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception {\n        try {\n            if (pool !\u003d null)\n                getClientPool().clear();\n            if (clientHandlerPool !\u003d null)\n                getClientHandlerPool().clear();\n            if (getClientDataPool() !\u003d null)\n                getClientDataPool().clear();\n            if (getDBPoolUtil() !\u003d null)\n                getDBPoolUtil().clean();\n            if (byteBufferPool !\u003d null)\n                getByteBufferPool().clear();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error: {0}\", e);\n            throw e;\n        }\n    }\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception {\n        if (pool \u003d\u003d null \u0026\u0026 clientHandlerPool \u003d\u003d null \u0026\u0026 getClientDataPool() \u003d\u003d null \u0026\u0026 getDBPoolUtil() \u003d\u003d null \u0026\u0026 byteBufferPool \u003d\u003d null) {\n            return;\n        }\n        logger.log(Level.FINE, \"Closing pools for {0}\", getName());\n        try {\n            if (pool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {\n                logger.finer(\"Closing ClientThread pool.\");\n                getClientPool().close();\n            }\n            if (clientHandlerPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientHandlerPool())) {\n                logger.finer(\"Closing ClientHandler pool.\");\n                getClientHandlerPool().close();\n            }\n            if (getClientDataPool() !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientDataPool())) {\n                logger.finer(\"Closing ClientData pool.\");\n                getClientDataPool().close();\n            }\n            if (getDBPoolUtil() !\u003d null) {\n                logger.finer(\"Closing DB pool.\");\n                getDBPoolUtil().clean();\n            }\n            if (byteBufferPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getByteBufferPool())) {\n                logger.finer(\"Closing ByteBuffer pool.\");\n                getByteBufferPool().close();\n            }\n            logger.log(Level.FINE, \"Closed pools for {0}\", getName());\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error closing pools for {0}: {1}\", new Object[] { getName(), e });\n            throw e;\n        }\n    }\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception {\n        logger.fine(\"Creating pools\");\n        if (getBlockingMode() \u003d\u003d false) {\n            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());\n        }\n        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());\n        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());\n        //check if client data is poolable\n        if (clientDataClass !\u003d null) {\n            try {\n                clientData \u003d (ClientData) clientDataClass.newInstance();\n                if (PoolableObject.class.isInstance(clientData) \u003d\u003d true) {\n                    PoolableObject po \u003d (PoolableObject) clientData;\n                    if (po.isPoolable() \u003d\u003d true) {\n                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());\n                    } else {\n                        clientDataPool \u003d null;\n                        logger.fine(\"ClientData is not poolable!\");\n                    }\n                }\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error: {0}\", e);\n                throw e;\n            }\n        }\n        try {\n            makeDBObjectPool();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error in makeDBObjectPool() : {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw e;\n        }\n        logger.fine(\"Created pools\");\n    }\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool() {\n        if (pool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientPool available yet!\");\n        return pool;\n    }\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientHandler pool\");\n        PoolableObjectFactory factory \u003d new ClientHandlerObjectFactory(getBlockingMode());\n        clientHandlerPool \u003d poolManager.makeClientHandlerPool(factory, opConfig);\n        poolManager.initPool(clientHandlerPool, opConfig);\n        clientHandlerPool \u003d makeQSObjectPool(clientHandlerPool);\n        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool() {\n        if (clientHandlerPool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientHandler Pool available yet!\");\n        return clientHandlerPool;\n    }\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config) {\n        this.config \u003d config;\n    }\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig() {\n        return config;\n    }\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientData pool\");\n        clientDataPool \u003d poolManager.makeClientDataPool(factory, opConfig);\n        poolManager.initPool(clientDataPool, opConfig);\n        clientDataPool \u003d makeQSObjectPool(clientDataPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool() {\n        return clientDataPool;\n    }\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return \u003ccode\u003enull\u003c/code\u003e\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil() {\n        return dBPoolUtil;\n    }\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {\n        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);\n    }\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception {\n        if (getConfig().getDBObjectPoolConfig() !\u003d null) {\n            logger.fine(\"Creating DBObject Pool\");\n            //logger.finest(\"Got:\\n\"+getConfig().getDBObjectPoolConfig().toXML(null));\n            Class dbPoolUtilClass \u003d getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);\n            dBPoolUtil \u003d (DBPoolUtil) dbPoolUtilClass.newInstance();\n            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());\n            dBPoolUtil.initPool();\n        }\n    }\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id) {\n        return clientIdentifier.findFirstClientById(id);\n    }\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  \u003ccode\u003e\u003cpre\u003e\n     *    Eg:\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tObject syncObj \u003d quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator \u003d quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tClientIdentifier clientIdentifier \u003d quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator \u003d clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    \u003c/code\u003e\u003c/pre\u003e\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient() {\n        return clientIdentifier.findAllClient();\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern) {\n        return clientIdentifier.findAllClientById(pattern);\n    }\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key) {\n        return clientIdentifier.findClientByKey(key);\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern) {\n        return clientIdentifier.findAllClientByKey(pattern);\n    }\n\n    /**\n     * Sets next client has a trusted client.\n     * \u003cp\u003eThis will skip any authentication and will not set any timeout.\u003c/p\u003e\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted() {\n        setSkipValidation(true);\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation() {\n        return skipValidation;\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation) {\n        skipValidation \u003d validation;\n    }\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging) {\n        this.communicationLogging \u003d communicationLogging;\n    }\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging() {\n        return communicationLogging;\n    }\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass) {\n        if (securityManagerClass !\u003d null)\n            this.securityManagerClass \u003d securityManagerClass;\n    }\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass() {\n        return securityManagerClass;\n    }\n\n    public SecurityManager getSecurityManager() throws AppException {\n        if (getSecurityManagerClass() \u003d\u003d null)\n            return null;\n        SecurityManager sm \u003d null;\n        try {\n            sm \u003d (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();\n        } catch (ClassNotFoundException e) {\n            throw new AppException(e.getMessage());\n        } catch (InstantiationException e) {\n            throw new AppException(e.getMessage());\n        } catch (IllegalAccessException e) {\n            throw new AppException(e.getMessage());\n        }\n        return sm;\n    }\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {\n        this.accessConstraintConfig \u003d accessConstraintConfig;\n    }\n\n    /**\n     * Returns Access constraints if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig() {\n        return accessConstraintConfig;\n    }\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader) {\n        this.classLoader \u003d classLoader;\n        Thread.currentThread().setContextClassLoader(classLoader);\n    }\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader() {\n        return classLoader;\n    }\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException {\n        if (name \u003d\u003d null)\n            throw new IllegalArgumentException(\"Class name can\u0027t be null!\");\n        logger.log(Level.FINEST, \"Class: {0}, reload: {1}\", new Object[] { name, reload });\n        if (reload \u003d\u003d true \u0026\u0026 classLoader !\u003d null) {\n            return classLoader.loadClass(name);\n        } else if (reload \u003d\u003d true \u0026\u0026 classLoader \u003d\u003d null \u0026\u0026 this.getClass().getClassLoader() !\u003d null) {\n            return this.getClass().getClassLoader().loadClass(name);\n        } else if (reload \u003d\u003d false \u0026\u0026 classLoader !\u003d null) {\n            return Class.forName(name, true, classLoader);\n        } else /*if(reload\u003d\u003dfalse \u0026\u0026 classLoader\u003d\u003dnull)*/\n        {\n            return Class.forName(name, true, this.getClass().getClassLoader());\n        }\n    }\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath) {\n        this.applicationJarPath \u003d applicationJarPath;\n    }\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath() {\n        return applicationJarPath;\n    }\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks) {\n        this.serverHooks \u003d serverHooks;\n    }\n\n    /**\n     * Returns ServerHooks if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks() {\n        if (serverHooks \u003d\u003d null)\n            serverHooks \u003d new ServerHooks();\n        return serverHooks;\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses() {\n        if (getServerHooks() \u003d\u003d null)\n            return;\n        listOfServerHooks \u003d new ArrayList();\n        ServerHook serverHook \u003d null;\n        String serverHookClassName \u003d null;\n        Class serverHookClass \u003d null;\n        //add system hooks\n        serverHook \u003d new GhostSocketReaper();\n        serverHook.initHook(QuickServer.this);\n        listOfServerHooks.add(serverHook);\n        ghostSocketReaper \u003d (GhostSocketReaper) serverHook;\n        //add user hooks if any\n        Iterator iterator \u003d getServerHooks().iterator();\n        while (iterator.hasNext()) {\n            serverHookClassName \u003d (String) iterator.next();\n            try {\n                serverHookClass \u003d getClass(serverHookClassName, true);\n                serverHook \u003d (ServerHook) serverHookClass.newInstance();\n                serverHook.initHook(QuickServer.this);\n                listOfServerHooks.add(serverHook);\n                logger.log(Level.INFO, \"Loaded server hook: {0}\", serverHookClassName);\n                logger.log(Level.FINE, \"Server hook info: {0}\", serverHook.info());\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Could not load server hook [{0}]: {1}\", new Object[] { serverHookClassName, e });\n                logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            }\n        }\n        //end of while\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event) {\n        if (listOfServerHooks \u003d\u003d null) {\n            logger.warning(\"listOfServerHooks was null!\");\n            return;\n        }\n        ServerHook serverHook \u003d null;\n        boolean result \u003d false;\n        Iterator iterator \u003d listOfServerHooks.iterator();\n        String hooktype \u003d \"UNKNOWN\";\n        switch(event) {\n            case ServerHook.PRE_STARTUP:\n                hooktype \u003d \"PRE_STARTUP\";\n                break;\n            case ServerHook.POST_STARTUP:\n                hooktype \u003d \"POST_STARTUP\";\n                break;\n            case ServerHook.PRE_SHUTDOWN:\n                hooktype \u003d \"PRE_SHUTDOWN\";\n                break;\n            case ServerHook.POST_SHUTDOWN:\n                hooktype \u003d \"POST_SHUTDOWN\";\n                break;\n        }\n        while (iterator.hasNext()) {\n            serverHook \u003d (ServerHook) iterator.next();\n            try {\n                result \u003d serverHook.handleEvent(event);\n            } catch (Exception e) {\n                result \u003d false;\n                logger.log(Level.WARNING, \"Error invoking {0} hook [{1}]: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });\n            }\n            logger.log(Level.FINE, \"Invoked {0} hook [{1}] was: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), result });\n        }\n    }\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone() {\n        Object object \u003d null;\n        try {\n            object \u003d super.clone();\n            QuickServer _qs \u003d (QuickServer) object;\n            _qs.setQSAdminServer(new QSAdminServer(_qs));\n        } catch (CloneNotSupportedException e) {\n            //should not happ\n            logger.log(Level.WARNING, \"Error cloning : {0}\", e);\n        }\n        return object;\n    }\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure) {\n        this.secure \u003d secure;\n    }\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure() {\n        if (secure \u003d\u003d null)\n            secure \u003d new Secure();\n        return secure;\n    }\n\n    /**\n     * \u003cp\u003eReturns if the server is running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure() {\n        return runningSecure;\n    }\n\n    /**\n     * \u003cp\u003eSets the server mode if its running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure) {\n        this.runningSecure \u003d runningSecure;\n    }\n\n    private File makeAbsoluteToConfig(String fileName) {\n        Assertion.affirm(fileName !\u003d null, \"FileName can\u0027t be null\");\n        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());\n    }\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException {\n        server \u003d null;\n        logger.log(Level.FINEST, \"Binding {0} to IP: {1}\", new Object[] { getName(), getBindAddr() });\n        InetSocketAddress bindAddress \u003d new InetSocketAddress(getBindAddr(), getPort());\n        try {\n            NetworkInterface ni \u003d NetworkInterface.getByInetAddress(getBindAddr());\n            if (ni !\u003d null) {\n                logger.fine(\"NetworkInterface: \" + ni);\n            }\n        } catch (Exception igrnore) {\n            /*ignore*/\n        } catch (Error igrnore) {\n            /*ignore*/\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Making a normal ServerSocket for {0}\", getName());\n            setRunningSecure(false);\n            if (getBlockingMode() \u003d\u003d false) {\n                //for non-blocking\n                serverSocketChannel \u003d ServerSocketChannel.open();\n                server \u003d serverSocketChannel.socket();\n                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n            } else {\n                //for blocking\n                server \u003d new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n            }\n        } else {\n            try {\n                logger.log(Level.FINE, \"Making a secure ServerSocket for {0}\", getName());\n                getSSLContext();\n                setRunningSecure(true);\n                if (getBlockingMode() \u003d\u003d false) {\n                    logger.log(Level.FINE, \"Making a secure ServerSocketChannel for {0}\", getName());\n                    //for non-blocking\n                    serverSocketChannel \u003d ServerSocketChannel.open();\n                    server \u003d serverSocketChannel.socket();\n                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n                } else {\n                    ServerSocketFactory ssf \u003d getSSLContext().getServerSocketFactory();\n                    SSLServerSocket serversocket \u003d (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());\n                    setRunningSecure(true);\n                    secureStoreManager.logSSLServerSocketInfo(serversocket);\n                    server \u003d serversocket;\n                    serverSocketChannel \u003d server.getChannel();\n                    if (serverSocketChannel \u003d\u003d null \u0026\u0026 getBlockingMode() \u003d\u003d false) {\n                        logger.warning(\"Secure Server does not support Channel! So will run in blocking mode.\");\n                        blockingMode \u003d false;\n                    }\n                }\n                //blocking\n            } catch (NoSuchAlgorithmException e) {\n                logger.log(Level.WARNING, \"NoSuchAlgorithmException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            } catch (KeyManagementException e) {\n                logger.log(Level.WARNING, \"KeyManagementException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            }\n        }\n        server.setReuseAddress(true);\n        int connectionTime \u003d 0;\n        int latency \u003d 0;\n        int bandwidth \u003d 0;\n        connectionTime \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();\n        latency \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();\n        bandwidth \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();\n        logger.log(Level.FINE, \"getPerformancePreferencesConnectionTime : {0}\", connectionTime);\n        logger.log(Level.FINE, \"getPerformancePreferencesLatency : {0}\", latency);\n        logger.log(Level.FINE, \"getPerformancePreferencesBandwidth : {0}\", bandwidth);\n        server.setPerformancePreferences(connectionTime, latency, bandwidth);\n        int clientSocketReceiveBufferSize \u003d getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();\n        if (clientSocketReceiveBufferSize \u003e 0) {\n            logger.log(Level.FINE, \"clientSocketReceiveBufferSize: {0}\", clientSocketReceiveBufferSize);\n            server.setReceiveBufferSize(clientSocketReceiveBufferSize);\n        }\n        if (getBlockingMode() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Server Mode {0} - Non Blocking\", getName());\n            if (selector \u003d\u003d null || selector.isOpen() \u003d\u003d false) {\n                logger.finest(\"Opening new selector\");\n                selector \u003d Selector.open();\n            } else {\n                logger.log(Level.FINEST, \"Reusing selector: {0}\", selector);\n            }\n            serverSocketChannel.configureBlocking(false);\n            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n            selector.wakeup();\n        } else {\n            logger.log(Level.FINE, \"Server Mode {0} - Blocking\", getName());\n        }\n    }\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {\n        Assertion.affirm(basicConfig !\u003d null, \"BasicServerConfig can\u0027t be null\");\n        this.basicConfig \u003d basicConfig;\n    }\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig() {\n        return basicConfig;\n    }\n\n    /**\n     * Loads the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException {\n        if (getSecure().isLoad() \u003d\u003d false) {\n            throw new IllegalStateException(\"Secure setting is not yet enabled for loading!\");\n        }\n        logger.info(\"Loading Secure Context..\");\n        km \u003d null;\n        tm \u003d null;\n        try {\n            String ssManager \u003d \"org.quickserver.security.SecureStoreManager\";\n            if (getSecure().getSecureStore() !\u003d null)\n                ssManager \u003d getSecure().getSecureStore().getSecureStoreManager();\n            Class secureStoreManagerClass \u003d getClass(ssManager, true);\n            secureStoreManager \u003d (SecureStoreManager) secureStoreManagerClass.newInstance();\n            km \u003d secureStoreManager.loadKeyManagers(getConfig());\n            logger.fine(\"KeyManager got\");\n            tm \u003d secureStoreManager.loadTrustManagers(getConfig());\n            logger.fine(\"TrustManager got\");\n            sslc \u003d secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());\n            sslc.init(km, tm, null);\n            logger.fine(\"SSLContext loaded\");\n        } catch (KeyStoreException e) {\n            logger.warning(\"KeyStoreException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchAlgorithmException e) {\n            logger.warning(\"NoSuchAlgorithmException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchProviderException e) {\n            logger.warning(\"NoSuchProviderException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (UnrecoverableKeyException e) {\n            logger.warning(\"UnrecoverableKeyException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (CertificateException e) {\n            logger.warning(\"CertificateException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (KeyManagementException e) {\n            logger.warning(\"KeyManagementException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (GeneralSecurityException e) {\n            logger.warning(\"GeneralSecurityException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (ClassNotFoundException e) {\n            logger.warning(\"ClassNotFoundException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (InstantiationException e) {\n            logger.warning(\"InstantiationException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (IllegalAccessException e) {\n            logger.warning(\"IllegalAccessException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        return getSSLContext(null);\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        if (protocol !\u003d null \u0026\u0026 secureStoreManager !\u003d null) {\n            SSLContext _sslc \u003d secureStoreManager.getSSLContext(protocol);\n            _sslc.init(km, tm, null);\n            return _sslc;\n        }\n        return sslc;\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext());\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext(protocol));\n    }\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler) {\n        clientBinaryHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler() {\n        return clientBinaryHandlerString;\n    }\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector) {\n        this.selector \u003d selector;\n    }\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector() {\n        return selector;\n    }\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception {\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        //long stime \u003d System.currentTimeMillis();\n        //long etime \u003d System.currentTimeMillis();\n        while (true) {\n            //etime \u003d System.currentTimeMillis();\n            //System.out.println(\"Time Taken: \"+(etime-stime));\n            client \u003d server.accept();\n            //stime \u003d System.currentTimeMillis();\n            if (linger \u003c 0) {\n                client.setSoLinger(false, 0);\n            } else {\n                client.setSoLinger(true, linger);\n            }\n            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                //low delay\u003d10\n                client.setTrafficClass(socketTrafficClass);\n            }\n            logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n            }\n            if (stopServer) {\n                //Client connected when server was about to be shutdown.\n                try {\n                    client.close();\n                } catch (Exception e) {\n                }\n                break;\n            }\n            if (checkAccessConstraint(client) \u003d\u003d false) {\n                continue;\n            }\n            //Check if max connection has reached\n            if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);\n            } else {\n                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);\n            }\n            theClient.setTrusted(getSkipValidation());\n            theClient.setSocket(client);\n            //mostly null\n            theClient.setSocketChannel(client.getChannel());\n            if (clientDataClass !\u003d null) {\n                if (getClientDataPool() \u003d\u003d null) {\n                    clientData \u003d (ClientData) clientDataClass.newInstance();\n                } else {\n                    clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                }\n                theClient.setClientData(clientData);\n            }\n            try {\n                _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                _chPolled.handleClient(theClient);\n            } catch (java.util.NoSuchElementException nsee) {\n                logger.warning(\"Could not borrow ClientHandler from pool. Error: \" + nsee);\n                logger.warning(\"Closing Socket [\" + client + \"] since no ClientHandler available.\");\n                client.close();\n            }\n            if (_chPolled !\u003d null) {\n                try {\n                    getClientPool().addClient(_chPolled, true);\n                } catch (java.util.NoSuchElementException nsee) {\n                    logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                    //logger.warning(\"Closing Socket [\"+client+\"] since no Thread available.\");\n                    //client.close();\n                    //returnClientHandlerToPool(_chPolled);\n                }\n                _chPolled \u003d null;\n            }\n            client \u003d null;\n            //reset it back\n            setSkipValidation(false);\n        }\n        //end of loop\n    }\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception {\n        int selectCount \u003d 0;\n        Iterator iterator \u003d null;\n        SelectionKey key \u003d null;\n        ServerSocketChannel serverChannel \u003d null;\n        SocketChannel socketChannel \u003d null;\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        boolean stopServerProcessed \u003d false;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        registerChannelRequestMap \u003d new HashMap();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        while (true) {\n            selectCount \u003d selector.select(500);\n            //selectCount \u003d selector.select();//for testing\n            //check for any pending registerChannel req.\n            synchronized (registerChannelRequestMap) {\n                if (registerChannelRequestMap.size() \u003e 0) {\n                    RegisterChannelRequest req \u003d null;\n                    Object hashkey \u003d null;\n                    iterator \u003d registerChannelRequestMap.keySet().iterator();\n                    while (iterator.hasNext()) {\n                        hashkey \u003d iterator.next();\n                        req \u003d (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);\n                        req.register(getSelector());\n                    }\n                    iterator \u003d null;\n                    registerChannelRequestMap.clear();\n                }\n                //if\n            }\n            //sync\n            if (stopServer \u003d\u003d true \u0026\u0026 stopServerProcessed \u003d\u003d false) {\n                logger.warning(\"Closing \" + getName());\n                serverSocketChannel.close();\n                stopServerProcessed \u003d true;\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.warning(\"Closed \" + getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n            if (stopServer \u003d\u003d false \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                logger.finest(\"Server must have re-started.. will break\");\n                break;\n            }\n            if (selectCount \u003d\u003d 0 \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                java.util.Set keyset \u003d selector.keys();\n                if (keyset.isEmpty() \u003d\u003d true \u0026\u0026 getClientCount() \u003c\u003d 0) {\n                    break;\n                } else {\n                    continue;\n                }\n            } else if (selectCount \u003d\u003d 0) {\n                continue;\n            }\n            iterator \u003d selector.selectedKeys().iterator();\n            while (iterator.hasNext()) {\n                key \u003d (SelectionKey) iterator.next();\n                if (key.isValid() \u003d\u003d false) {\n                    iterator.remove();\n                    continue;\n                }\n                if (key.isAcceptable() \u0026\u0026 stopServer \u003d\u003d false) {\n                    logger.finest(\"Key is Acceptable\");\n                    serverChannel \u003d (ServerSocketChannel) key.channel();\n                    socketChannel \u003d serverChannel.accept();\n                    if (socketChannel \u003d\u003d null) {\n                        iterator.remove();\n                        continue;\n                    }\n                    client \u003d socketChannel.socket();\n                    if (linger \u003c 0) {\n                        client.setSoLinger(false, 0);\n                    } else {\n                        client.setSoLinger(true, linger);\n                    }\n                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                        //low delay\u003d10\n                        client.setTrafficClass(socketTrafficClass);\n                    }\n                    logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                        logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n                    }\n                    if (checkAccessConstraint(client) \u003d\u003d false) {\n                        iterator.remove();\n                        continue;\n                    }\n                    socketChannel.configureBlocking(false);\n                    theClient.setTrusted(getSkipValidation());\n                    theClient.setSocket(socketChannel.socket());\n                    theClient.setSocketChannel(socketChannel);\n                    if (clientDataClass !\u003d null) {\n                        if (getClientDataPool() \u003d\u003d null) {\n                            clientData \u003d (ClientData) clientDataClass.newInstance();\n                        } else {\n                            //borrow a object from pool\n                            clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                        }\n                        theClient.setClientData(clientData);\n                    }\n                    //Check if max connection has reached\n                    if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                        theClient.setClientEvent(ClientEvent.MAX_CON);\n                    } else {\n                        theClient.setClientEvent(ClientEvent.ACCEPT);\n                    }\n                    try {\n                        _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                        logger.finest(\"Asking \" + _chPolled.getName() + \" to handle.\");\n                        _chPolled.handleClient(theClient);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.warning(\"Could not borrow ClientHandler Object from pool. Error: \" + nsee);\n                        logger.warning(\"Closing SocketChannel [\" + serverChannel.socket() + \"] since no ClientHandler available.\");\n                        socketChannel.close();\n                    }\n                    if (_chPolled !\u003d null) {\n                        try {\n                            getClientPool().addClient(_chPolled, true);\n                        } catch (java.util.NoSuchElementException nsee) {\n                            logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                            //logger.warning(\"Closing SocketChannel [\"+serverChannel.socket()+\"] since no Thread available.\");\n                            //socketChannel.close();\n                            //returnClientHandlerToPool(_chPolled);\n                        }\n                        _chPolled \u003d null;\n                    }\n                    socketChannel \u003d null;\n                    client \u003d null;\n                    //reset it back\n                    setSkipValidation(false);\n                } else if (key.isValid() \u0026\u0026 key.isReadable()) {\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Readable, removing OP_READ from interestOps for \" + _ch.getName());\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_READ));\n                        _ch.addEvent(ClientEvent.READ);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.READ);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (key.isValid() \u0026\u0026 key.isWritable()) {\n                    if (getClientPool().shouldNioWriteHappen() \u003d\u003d false) {\n                        //no need to remove the key\n                        continue;\n                    }\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Writable, removing OP_WRITE from interestOps for \" + _ch.getName());\n                        //remove OP_WRITE from interest set\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_WRITE));\n                        _ch.addEvent(ClientEvent.WRITE);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.WRITE);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (stopServer \u003d\u003d true \u0026\u0026 key.isAcceptable()) {\n                    //we will not accept this key\n                    //reset it back\n                    setSkipValidation(false);\n                } else {\n                    logger.warning(\"Unknown key got in SelectionKey: \" + key);\n                }\n                //Remove key\n                iterator.remove();\n                Thread.yield();\n            }\n            //end of iterator\n            iterator \u003d null;\n        }\n        //end of loop\n    }\n\n    private boolean checkAccessConstraint(Socket socket) {\n        try {\n            if (getAccessConstraintConfig() !\u003d null) {\n                getAccessConstraintConfig().checkAccept(socket);\n            }\n            return true;\n        } catch (SecurityException se) {\n            logger.warning(\"SecurityException occurred accepting connection : \" + se.getMessage());\n            return false;\n        }\n    }\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {\n        if (getSelector() \u003d\u003d null) {\n            throw new IllegalStateException(\"Selector is not open!\");\n        }\n        if (channel \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Can\u0027t register a null channel!\");\n        }\n        if (channel.isConnected() \u003d\u003d false) {\n            throw new ClosedChannelException();\n        }\n        RegisterChannelRequest req \u003d new RegisterChannelRequest(channel, ops, att);\n        RegisterChannelRequest reqOld \u003d null;\n        synchronized (registerChannelRequestMap) {\n            reqOld \u003d (RegisterChannelRequest) registerChannelRequestMap.get(channel);\n            if (reqOld \u003d\u003d null) {\n                registerChannelRequestMap.put(channel, req);\n                getSelector().wakeup();\n                return true;\n            } else {\n                if (reqOld.equals(req) \u003d\u003d false) {\n                    reqOld.setOps(reqOld.getOps() | req.getOps());\n                    reqOld.setAtt(req.getAtt());\n                    return true;\n                }\n                return false;\n            }\n        }\n        /*\n\t\tlogger.warning(\"Before register...\");\n\t\tchannel.register(getSelector(), ops, att);\n\t\tlogger.warning(\"Before wakeup and after register...\");\n\t\tgetSelector().wakeup();\n\t\tlogger.warning(\"After wakeup...\");\n\t\t*/\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig) {\n        logger.finer(\"Creating ByteBufferPool pool\");\n        int bufferSize \u003d getBasicConfig().getAdvancedSettings().getByteBufferSize();\n        boolean useDirectByteBuffer \u003d getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();\n        PoolableObjectFactory factory \u003d new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);\n        byteBufferPool \u003d poolManager.makeByteBufferPool(factory, opConfig);\n        poolManager.initPool(byteBufferPool, opConfig);\n    }\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool() {\n        return byteBufferPool;\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientThread pool\");\n        ThreadObjectFactory factory \u003d new ThreadObjectFactory();\n        ObjectPool objectPool \u003d poolManager.makeClientPool(factory, opConfig);\n        pool \u003d new ClientPool(makeQSObjectPool(objectPool), opConfig);\n        factory.setClientPool(pool);\n        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());\n        poolManager.initPool(objectPool, opConfig);\n    }\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler) {\n        clientWriteHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler() {\n        return clientWriteHandlerString;\n    }\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be \u003ccode\u003enull\u003c/code\u003e if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime() {\n        return lastStartTime;\n    }\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag) {\n        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);\n        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);\n    }\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier() {\n        return clientIdentifier;\n    }\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {\n        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);\n    }\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode() {\n        return blockingMode;\n    }\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception {\n        if (clientCommandHandlerString \u003d\u003d null \u0026\u0026 clientEventHandlerString \u003d\u003d null) {\n            logger.severe(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n            throw new AppException(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n        }\n        clientCommandHandler \u003d null;\n        if (clientCommandHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientCommandHandler class..\");\n            Class clientCommandHandlerClass \u003d getClass(clientCommandHandlerString, true);\n            clientCommandHandler \u003d (ClientCommandHandler) clientCommandHandlerClass.newInstance();\n        }\n        boolean setClientCommandHandlerLookup \u003d false;\n        clientEventHandler \u003d null;\n        if (clientEventHandlerString \u003d\u003d null) {\n            clientEventHandlerString \u003d \"org.quickserver.net.server.impl.DefaultClientEventHandler\";\n            setClientCommandHandlerLookup \u003d true;\n        }\n        logger.finest(\"Loading ClientEventHandler class..\");\n        if (clientEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientEventHandler.class.isInstance(clientCommandHandler)) {\n            clientEventHandler \u003d (ClientEventHandler) clientCommandHandler;\n        } else {\n            clientEventHandler \u003d (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();\n            if (setClientCommandHandlerLookup) {\n                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);\n            }\n        }\n        clientExtendedEventHandler \u003d null;\n        if (clientExtendedEventHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientExtendedEventHandler class..\");\n            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientCommandHandler;\n            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientEventHandler;\n            } else {\n                Class clientExtendedEventHandlerClass \u003d getClass(clientExtendedEventHandlerString, true);\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();\n            }\n        }\n        clientObjectHandler \u003d null;\n        if (clientObjectHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientObjectHandler class..\");\n            if (clientObjectHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientCommandHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientCommandHandler;\n            } else if (clientObjectHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientEventHandler;\n            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientExtendedEventHandler;\n            } else {\n                clientObjectHandler \u003d (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientBinaryHandler \u003d null;\n        if (clientBinaryHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientBinaryHandler class..\");\n            if (clientBinaryHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientCommandHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientCommandHandler;\n            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientExtendedEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientObjectHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientObjectHandler;\n            } else {\n                clientBinaryHandler \u003d (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientWriteHandler \u003d null;\n        if (clientWriteHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientWriteHandler class..\");\n            if (clientWriteHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientCommandHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientCommandHandler;\n            } else if (clientWriteHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientEventHandler;\n            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientExtendedEventHandler;\n            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientObjectHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientObjectHandler;\n            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientBinaryHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientBinaryHandler;\n            } else {\n                clientWriteHandler \u003d (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        Class authenticatorClass \u003d null;\n        if (clientAuthenticationHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientAuthenticationHandler class..\");\n            authenticatorClass \u003d getClass(clientAuthenticationHandlerString, true);\n        }\n        if (authenticatorClass !\u003d null) {\n            Object obj \u003d authenticatorClass.newInstance();\n            if (ClientAuthenticationHandler.class.isInstance(obj))\n                clientAuthenticationHandler \u003d (ClientAuthenticationHandler) obj;\n            else\n                authenticator \u003d (Authenticator) obj;\n        }\n        clientDataClass \u003d null;\n        if (clientDataString !\u003d null) {\n            logger.finest(\"Loading ClientData class..\");\n            clientDataClass \u003d getClass(clientDataString, true);\n        }\n        Assertion.affirm(clientEventHandler !\u003d null, \"ClientEventHandler was not loaded!\");\n    }\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler) {\n        clientEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler() {\n        return clientEventHandlerString;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {\n        if (dataType \u003d\u003d DataType.IN)\n            this.defaultDataModeIN \u003d dataMode;\n        if (dataType \u003d\u003d DataType.OUT)\n            this.defaultDataModeOUT \u003d dataMode;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {\n        defaultDataModeIN \u003d defaultDataMode.getDataMode(DataType.IN);\n        defaultDataModeOUT \u003d defaultDataMode.getDataMode(DataType.OUT);\n        ;\n    }\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType) {\n        if (dataType \u003d\u003d DataType.IN)\n            return defaultDataModeIN;\n        if (dataType \u003d\u003d DataType.OUT)\n            return defaultDataModeOUT;\n        else\n            throw new IllegalArgumentException(\"Unknown DataType: \" + dataType);\n    }\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler) {\n        clientExtendedEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler() {\n        return clientExtendedEventHandlerString;\n    }\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception {\n        if (getApplicationJarPath() !\u003d null \u0026\u0026 getClassLoader() \u003d\u003d null) {\n            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));\n            //update qsadmin to use the same\n            if (adminServer !\u003d null) {\n                adminServer.getServer().setClassLoader(getClassLoader());\n            }\n        }\n    }\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID() {\n        return pid;\n    }\n\n    public boolean isRawCommunicationLogging() {\n        return rawCommunicationLogging;\n    }\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {\n        this.rawCommunicationLogging \u003d rawCommunicationLogging;\n    }\n\n    public int getRawCommunicationMaxLength() {\n        return rawCommunicationMaxLength;\n    }\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {\n        this.rawCommunicationMaxLength \u003d rawCommunicationMaxLength;\n    }\n}\n",
    "package": "org.quickserver.net.server",
    "classname": "QuickServer",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_18Test.java",
    "test_prompt": "// QuickServer_18Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#getSSLContext(String)} method.\n*/\nclass QuickServer_18Test {",
    "method_signature": "getSSLContext(String)",
    "suffix": "18"
  },
  {
    "numberTests": "ten",
    "original_code": "// QuickServer.java\n/*\n * This file is part of the QuickServer library \n * Copyright (C) QuickServer.org\n *\n * Use, modification, copying and distribution of this software is subject to\n * the terms and conditions of the GNU Lesser General Public License. \n * You should have received a copy of the GNU LGP License along with this \n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\n *\n * For questions, suggestions, bug-reports, enhancement-requests etc.\n * visit http://www.quickserver.org\n *\n */\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n *  Main class of QuickServer library. This class is used to create\n *  multi client servers quickly.\n *  \u003cp\u003e\n *  Ones a client is connected, it creates {@link ClientHandler} object,\n *  which is run using any thread available from the pool of threads\n *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n *  handles the client. \u003cbr/\u003e\n *  QuickServer divides the application logic of its developer over eight\n *  class, \u003cbr\u003e\n *  \t\u003cul\u003e\n * \t\t\u003cli\u003eClientEventHandler\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client events [Optional Class].\n *  \t\t\u003cli\u003eClientCommandHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client character/string commands.\n *  \t\t\u003cli\u003eClientObjectHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - Object commands.\n * \t\t\u003cli\u003eClientBinaryHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - binary data.\n * \t\t\u003cli\u003eClientWriteHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n *  \t\t\u003cli\u003eClientAuthenticationHandler [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Used to Authencatet a client.\n *  \t\t\u003cli\u003eClientData [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Client data carrier (support class)\n * \t\t\u003cli\u003eClientExtendedEventHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles extended client events.\n *  \t\u003c/ul\u003e\n *\n *  [#] \u003d Any one of these have to be set based on default DataMode for input.\n *  The default DataMode for input is String so if not changes you will\n *  have to set ClientCommandHandler.\n *  \u003c/p\u003e\n *  \u003cp\u003e\n *   Eg:\n *  \u003ccode\u003e\u003cBLOCKQUOTE\u003e\u003cpre\u003e\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle \u003d \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer \u003d new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * \u003c/pre\u003e\u003c/BLOCKQUOTE\u003e\u003c/code\u003e\u003c/p\u003e\n *\n *  @version 1.4.8\n *  @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //Some variable are not initialised to any value because the\n    //default java value was desired initial value.\n    //\u0027dev \u0027 \u003d development build not yet final\n    //\u0027beta\u0027 \u003d test build all features\n    //change also in QSAdminMain\n    private final static String VER \u003d \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n        if (System.getProperty(\"org.quickserver.useOSLineSeparator\") !\u003d null \u0026\u0026 System.getProperty(\"org.quickserver.useOSLineSeparator\").equals(\"true\")) {\n            NEW_LINE \u003d System.getProperty(\"line.separator\");\n        } else {\n            NEW_LINE \u003d \"\\r\\n\";\n        }\n        String _pid \u003d ManagementFactory.getRuntimeMXBean().getName();\n        int i \u003d _pid.indexOf(\"@\");\n        pid \u003d _pid.substring(0, i);\n        System.out.print(\"Loading QuickServer v\" + getVersion() + \" [PID:\" + pid + \"]\");\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort \u003d 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName \u003d \"QuickServer\";\n\n    private long maxConnection \u003d -1;\n\n    //1 min socket timeout\n    private int socketTimeout \u003d 60 * 1000;\n\n    private String maxConnectionMsg \u003d \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg \u003d \"-ERR Timeout\";\n\n    private String maxAuthTryMsg \u003d \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry \u003d 5;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //--v1.2\n    //Logger for QuickServer\n    private static final Logger logger \u003d Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //for Service interface\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState \u003d Service.UNKNOWN;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.3\n    private QuickServerConfig config \u003d new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel \u003d \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel \u003d \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation \u003d false;\n\n    private boolean communicationLogging \u003d true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig \u003d config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km \u003d null;\n\n    private TrustManager[] tm \u003d null;\n\n    private boolean runningSecure \u003d false;\n\n    private SecureStoreManager secureStoreManager \u003d null;\n\n    private Exception exceptionInRun \u003d null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode \u003d true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN \u003d DataMode.STRING;\n\n    private DataMode defaultDataModeOUT \u003d DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging \u003d false;\n\n    private int rawCommunicationMaxLength \u003d 100;\n\n    static {\n        System.out.println(\" Done\");\n        //should be commented if not a patch release\n        //System.out.println(\"[Includes patch(#): t\u003d152\u0026p\u003d532]\");\n        //should be commented if not a dev release\n        //System.out.println(\"[Dev Build Date: Saturday, October 29, 2005]\");\n        logger.log(Level.FINE, \"PID: {0}\", pid);\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion() {\n        return VER;\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo() {\n        return getVersionNo(VER);\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver) {\n        //String ver \u003d getVersion();\n        float version \u003d 0;\n        //check if beta\n        int i \u003d ver.indexOf(\" \");\n        if (i \u003d\u003d -1)\n            i \u003d ver.length();\n        ver \u003d ver.substring(0, i);\n        //check for sub version\n        i \u003d ver.indexOf(\".\");\n        if (i !\u003d -1) {\n            int j \u003d ver.indexOf(\".\", i);\n            if (j !\u003d -1) {\n                ver \u003d ver.substring(0, i) + \".\" + MyString.replaceAll(ver.substring(i + 1), \".\", \"\");\n            }\n        }\n        try {\n            version \u003d Float.parseFloat(ver);\n        } catch (NumberFormatException e) {\n            throw new RuntimeException(\"Corrupt QuickServer\");\n        }\n        return version;\n    }\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine() {\n        return NEW_LINE;\n    }\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString() {\n        return serverName + \" : \" + getPort();\n    }\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n        setClientCommandHandler(commandHandler);\n    }\n\n    /**\n     * Creates a new server at \u003ccode\u003eport\u003c/code\u003e with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n        //send to another constructor\n        this(commandHandler);\n        setPort(port);\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException {\n        logger.log(Level.FINE, \"Starting {0}\", getName());\n        if (isClosed() \u003d\u003d false) {\n            logger.log(Level.WARNING, \"Server {0} already running.\", getName());\n            throw new AppException(\"Server \" + getName() + \" already running.\");\n        }\n        blockingMode \u003d getBasicConfig().getServerMode().getBlocking();\n        if (getSecure().isEnable() \u0026\u0026 blockingMode \u003d\u003d false) {\n            //TODO we need to fix this..\n            logger.warning(\"QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode.\");\n            blockingMode \u003d true;\n            getBasicConfig().getServerMode().setBlocking(blockingMode);\n        }\n        if (serverBanner \u003d\u003d null) {\n            serverBanner \u003d \"\\n-------------------------------\" + \"\\n Name : \" + getName() + \"\\n Port : \" + getPort() + \"\\n-------------------------------\\n\";\n            logger.finest(\"Default Server Banner Generated\");\n        }\n        try {\n            loadApplicationClasses();\n            //load class from Advanced Settings\n            Class clientIdentifierClass \u003d getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);\n            clientIdentifier \u003d (ClientIdentifier) clientIdentifierClass.newInstance();\n            clientIdentifier.setQuickServer(QuickServer.this);\n            //load class from ObjectPoolConfig\n            Class poolManagerClass \u003d getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);\n            poolManager \u003d (PoolManager) poolManagerClass.newInstance();\n            //load class QSObjectPoolMaker\n            Class qsObjectPoolMakerClass \u003d getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);\n            qsObjectPoolMaker \u003d (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();\n            loadServerHooksClasses();\n            processServerHooks(ServerHook.PRE_STARTUP);\n            if (getSecure().isLoad() \u003d\u003d true)\n                //v1.4.0\n                loadSSLContext();\n            loadBusinessLogic();\n        } catch (ClassNotFoundException e) {\n            logger.log(Level.SEVERE, \"Could not load class/s: \" + e, e);\n            throw new AppException(\"Could not load class/s : \" + e);\n        } catch (InstantiationException e) {\n            logger.log(Level.SEVERE, \"Could not instantiate class/s: \" + e, e);\n            throw new AppException(\"Could not instantiate class/s: \" + e);\n        } catch (IllegalAccessException e) {\n            logger.log(Level.SEVERE, \"Illegal access to class/s: \" + e, e);\n            throw new AppException(\"Illegal access to class/s: \" + e);\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"IOException: \" + e, e);\n            throw new AppException(\"IOException: \" + e);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Exception: \" + e, e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Exception : \" + e);\n        }\n        //v1.3.3\n        if (getSecurityManagerClass() !\u003d null) {\n            System.setSecurityManager(getSecurityManager());\n        }\n        setServiceState(Service.INIT);\n        t \u003d new Thread(this, \"QuickServer - \" + getName());\n        t.start();\n        do {\n            Thread.yield();\n        } while (getServiceState() \u003d\u003d Service.INIT);\n        if (getServiceState() !\u003d Service.RUNNING) {\n            if (exceptionInRun !\u003d null)\n                throw new AppException(\"Could not start server \" + getName() + \"! Details: \" + exceptionInRun);\n            else\n                throw new AppException(\"Could not start server \" + getName());\n        }\n        lastStartTime \u003d new java.util.Date();\n        logger.log(Level.FINE, \"Started {0}, Date: {1}\", new Object[] { getName(), lastStartTime });\n    }\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException {\n        processServerHooks(ServerHook.PRE_SHUTDOWN);\n        logger.log(Level.WARNING, \"Stopping {0}\", getName());\n        stopServer \u003d true;\n        Socket death \u003d null;\n        if (isClosed() \u003d\u003d true) {\n            logger.log(Level.WARNING, \"Server {0} is not running!\", getName());\n            throw new AppException(\"Server \" + getName() + \" is not running!\");\n        }\n        try {\n            if (getBlockingMode() \u003d\u003d true) {\n                if (getSecure().isEnable() \u003d\u003d false) {\n                    death \u003d new Socket(server.getInetAddress(), server.getLocalPort());\n                    death.getInputStream().read();\n                    death.close();\n                } else {\n                    death \u003d getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());\n                    Thread.sleep(100);\n                    death.close();\n                }\n            }\n            if (serverSocketChannel !\u003d null) {\n                serverSocketChannel.close();\n            }\n        } catch (IOException e) {\n            logger.log(Level.FINE, \"IOError stopping {0}: {1}\", new Object[] { getName(), e });\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error stopping {0}: {1}\", new Object[] { getName(), e });\n            throw new AppException(\"Error in stopServer \" + getName() + \": \" + e);\n        }\n        for (int i \u003d 0; getServiceState() !\u003d Service.STOPPED; i++) {\n            try {\n                Thread.sleep(60);\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error waiting for {0} to fully stop. Error: {1}\", new Object[] { getName(), e });\n            }\n            if (i \u003e 1000) {\n                logger.severe(\"Server was not stopped even after 10sec.. will terminate now.\");\n                System.exit(-1);\n            }\n        }\n        if (adminServer \u003d\u003d null || getQSAdminServer().getServer() !\u003d this) {\n            //so this is not qsadmin\n            setClassLoader(null);\n        }\n        logger.log(Level.INFO, \"Stopped {0}\", getName());\n    }\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException {\n        stopServer();\n        startServer();\n    }\n\n    /**\n     * Returns the name of the QuickServer. Default is \u0027QuickServer\u0027.\n     * @see #setName\n     */\n    public String getName() {\n        return serverName;\n    }\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name) {\n        serverName \u003d name;\n        logger.log(Level.FINEST, \"Set to : {0}\", name);\n    }\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner() {\n        return serverBanner;\n    }\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. \u003cbr\u003e\u0026nbsp;\u003cbr\u003e\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner) {\n        serverBanner \u003d banner;\n        logger.log(Level.FINEST, \"Set to : {0}\", banner);\n    }\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port) {\n        if (port \u003c 0) {\n            throw new IllegalArgumentException(\"Port number can not be less than 0!\");\n        }\n        serverPort \u003d port;\n        logger.log(Level.FINEST, \"Set to {0}\", port);\n    }\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort() {\n        if (isClosed() \u003d\u003d false) {\n            return server.getLocalPort();\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            return serverPort;\n        } else {\n            int _port \u003d getSecure().getPort();\n            if (_port \u003d\u003d -1)\n                return serverPort;\n            else\n                return _port;\n        }\n    }\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler) {\n        clientCommandHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler() {\n        return clientCommandHandlerString;\n    }\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data) {\n        this.clientDataString \u003d data;\n        logger.log(Level.FINEST, \"Set to {0}\", data);\n    }\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData() {\n        return clientDataString;\n    }\n\n    /**\n     * Sets the client socket\u0027s timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time) {\n        if (time \u003e 0)\n            socketTimeout \u003d time;\n        else\n            socketTimeout \u003d 0;\n        logger.log(Level.FINEST, \"Set to {0}\", socketTimeout);\n    }\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout() {\n        return socketTimeout;\n    }\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry) {\n        maxAuthTry \u003d authTry;\n        logger.log(Level.FINEST, \"Set to {0}\", authTry);\n    }\n\n    /**\n     * Returns max allowed login attempts. Default is \u003ccode\u003e5\u003c/code\u003e.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry() {\n        return maxAuthTry;\n    }\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg) {\n        maxAuthTryMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg() {\n        return maxAuthTryMsg;\n    }\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg) {\n        timeoutMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg() {\n        return timeoutMsg;\n    }\n\n    private TheClient initTheClient() {\n        TheClient theClient \u003d new TheClient();\n        theClient.setServer(QuickServer.this);\n        theClient.setTimeoutMsg(getTimeoutMsg());\n        //v1.2\n        theClient.setMaxAuthTry(getMaxAuthTry());\n        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());\n        theClient.setClientEventHandler(clientEventHandler);\n        //v1.4.6\n        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);\n        theClient.setClientCommandHandler(clientCommandHandler);\n        //v1.2\n        theClient.setClientObjectHandler(clientObjectHandler);\n        //v1.4\n        theClient.setClientBinaryHandler(clientBinaryHandler);\n        //v1.4.5\n        theClient.setClientWriteHandler(clientWriteHandler);\n        //v1.3\n        theClient.setAuthenticator(authenticator);\n        //v1.4.6\n        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);\n        theClient.setTimeout(socketTimeout);\n        theClient.setMaxConnectionMsg(maxConnectionMsg);\n        //v1.3.2\n        theClient.setCommunicationLogging(getCommunicationLogging());\n        return theClient;\n    }\n\n    public void run() {\n        exceptionInRun \u003d null;\n        TheClient theClient \u003d initTheClient();\n        try {\n            stopServer \u003d false;\n            closeAllPools();\n            initAllPools();\n            makeServerSocket();\n            //print banner\n            System.out.println(serverBanner);\n            //v1.2\n            setServiceState(Service.RUNNING);\n            //v1.3.3\n            processServerHooks(ServerHook.POST_STARTUP);\n            if (getBlockingMode() \u003d\u003d false) {\n                runNonBlocking(theClient);\n                if (stopServer \u003d\u003d true) {\n                    logger.log(Level.FINEST, \"Closing selector for {0}\", getName());\n                    selector.close();\n                }\n                return;\n            } else {\n                runBlocking(theClient);\n            }\n        } catch (BindException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"{0} BindException for Port {1} @ {2} : {3}\", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });\n        } catch (javax.net.ssl.SSLException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"SSLException {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (IOException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"IOError {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (Exception e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"Error {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } finally {\n            if (getBlockingMode() \u003d\u003d true) {\n                logger.log(Level.WARNING, \"Closing {0}\", getName());\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            } else if (getBlockingMode() \u003d\u003d false \u0026\u0026 exceptionInRun !\u003d null) {\n                logger.log(Level.WARNING, \"Closing {0} - Had Error: {1}\", new Object[] { getName(), exceptionInRun });\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        if (serverSocketChannel !\u003d null)\n                            serverSocketChannel.close();\n                        if (server !\u003d null)\n                            server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n        }\n    }\n\n    //end of run\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnection \u003d maxConnection;\n        else\n            this.maxConnection \u003d maxConnection;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnection);\n    }\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection() {\n        return maxConnection;\n    }\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount() {\n        if (clientHandlerPool !\u003d null) {\n            try {\n                return getClientHandlerPool().getNumActive();\n            } catch (Exception e) {\n                return 0;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : \u003ccode\u003e-ERR Server Busy. Max Connection Reached\u003c/code\u003e\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n        else\n            this.maxConnectionMsg \u003d maxConnectionMsg;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnectionMsg);\n    }\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg() {\n        return maxConnectionMsg;\n    }\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException {\n        ipAddr \u003d InetAddress.getByName(bindAddr);\n        logger.log(Level.FINEST, \"Set to {0}\", bindAddr);\n    }\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr() {\n        if (ipAddr \u003d\u003d null) {\n            try {\n                ipAddr \u003d InetAddress.getByName(\"0.0.0.0\");\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Unable to create default ip(0.0.0.0) : {0}\", e);\n                throw new RuntimeException(\"Error: Unable to find servers own ip : \" + e);\n            }\n        }\n        return ipAddr;\n    }\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects) {\n        this.storeObjects \u003d storeObjects;\n    }\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return \u003ccode\u003enull\u003c/code\u003e.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects() {\n        return storeObjects;\n    }\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port) {\n        getQSAdminServer().getServer().setPort(port);\n    }\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort() {\n        return getQSAdminServer().getServer().getPort();\n    }\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator) {\n        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);\n    }\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator() {\n        return getQSAdminServer().getServer().getAuthenticator();\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException {\n        getQSAdminServer().setClientAuthenticationHandler(authenticator);\n        getQSAdminServer().startServer(port);\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException {\n        getQSAdminServer().startServer();\n    }\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer() {\n        if (adminServer \u003d\u003d null)\n            adminServer \u003d new QSAdminServer(QuickServer.this);\n        return adminServer;\n    }\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer) {\n        if (adminServer \u003d\u003d null)\n            this.adminServer \u003d adminServer;\n    }\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed() {\n        if (server \u003d\u003d null)\n            return true;\n        return server.isClosed();\n    }\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer\u0027s own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger() {\n        if (appLogger !\u003d null)\n            return appLogger;\n        return logger;\n    }\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger) {\n        this.appLogger \u003d appLogger;\n    }\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler) {\n        clientObjectHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler() {\n        return clientObjectHandlerString;\n    }\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n        if (formatter \u003d\u003d null)\n            return;\n        consoleLoggingformatter \u003d formatter;\n        java.util.logging.Formatter conformatter \u003d (java.util.logging.Formatter) getClass(formatter, true).newInstance();\n        Logger jdkLogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d jdkLogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                handlers[index].setFormatter(conformatter);\n            }\n        }\n        logger.log(Level.FINEST, \"Set to {0}\", formatter);\n    }\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter() {\n        return consoleLoggingformatter;\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MiniFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to logging.MiniFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MicroFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to MicroFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        boolean isConsole \u003d true;\n        try {\n            if (System.console() \u003d\u003d null) {\n                isConsole \u003d false;\n            }\n        } catch (Throwable e) {\n            //ignore\n        }\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                if (isConsole \u003d\u003d false \u0026\u0026 level !\u003d Level.OFF) {\n                    System.out.println(\"QuickServer: You do not have a console.. so turning console logger off..\");\n                    level \u003d Level.OFF;\n                }\n                if (level \u003d\u003d Level.OFF) {\n                    logger.info(\"QuickServer: Removing console handler.. \");\n                    rlogger.removeHandler(handlers[index]);\n                    handlers[index].setLevel(level);\n                    handlers[index].close();\n                } else {\n                    handlers[index].setLevel(level);\n                }\n            }\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            consoleLoggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            consoleLoggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            consoleLoggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            consoleLoggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            consoleLoggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            consoleLoggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            consoleLoggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            consoleLoggingLevel \u003d \"OFF\";\n        else\n            consoleLoggingLevel \u003d \"UNKNOWN\";\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel() {\n        return consoleLoggingLevel;\n    }\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            handlers[index].setLevel(level);\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            loggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            loggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            loggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            loggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            loggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            loggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            loggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            loggingLevel \u003d \"OFF\";\n        else\n            loggingLevel \u003d \"UNKNOWN\";\n        consoleLoggingLevel \u003d loggingLevel;\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    //*** Start of Service interface methods\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError() {\n        return serviceError;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param) {\n        serviceError \u003d null;\n        try {\n            initServer(param);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig) {\n        serviceError \u003d null;\n        try {\n            initServer(qsConfig);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING)\n            return false;\n        try {\n            startServer();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.STOPPED)\n            return false;\n        try {\n            stopServer();\n            clearAllPools();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING) {\n            suspendMaxConnection \u003d maxConnection;\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n            maxConnection \u003d 0;\n            maxConnectionMsg \u003d \"Service is suspended.\";\n            setServiceState(Service.SUSPENDED);\n            logger.log(Level.INFO, \"Service {0} is suspended.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.SUSPENDED) {\n            maxConnection \u003d suspendMaxConnection;\n            maxConnectionMsg \u003d suspendMaxConnectionMsg;\n            setServiceState(Service.RUNNING);\n            logger.log(Level.INFO, \"Service {0} resumed.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info() {\n        serviceError \u003d null;\n        StringBuilder buf \u003d new StringBuilder();\n        buf.append(getName()).append(\"\\n\");\n        buf.append(getBindAddr().getHostAddress()).append(\" \");\n        buf.append(getPort()).append(\"\\n\");\n        return buf.toString();\n    }\n\n    // *** End of Service interface methods\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException {\n        QuickServerConfig qsConfig \u003d null;\n        try {\n            qsConfig \u003d ConfigReader.read((String) param[0]);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not init server from xml file {0} : {1}\", new Object[] { new File((String) param[0]).getAbsolutePath(), e });\n            throw new AppException(\"Could not init server from xml file\", e);\n        }\n        initServer(qsConfig);\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {\n        setConfig(qsConfig);\n        try {\n            configQuickServer();\n            loadApplicationClasses();\n            //start InitServerHooks\n            InitServerHooks ish \u003d getConfig().getInitServerHooks();\n            if (ish !\u003d null) {\n                Iterator iterator \u003d ish.iterator();\n                String initServerHookClassName \u003d null;\n                Class initServerHookClass \u003d null;\n                InitServerHook initServerHook \u003d null;\n                while (iterator.hasNext()) {\n                    initServerHookClassName \u003d (String) iterator.next();\n                    initServerHookClass \u003d getClass(initServerHookClassName, true);\n                    initServerHook \u003d (InitServerHook) initServerHookClass.newInstance();\n                    logger.log(Level.INFO, \"Loaded init server hook: {0}\", initServerHookClassName);\n                    logger.log(Level.FINE, \"Init server hook info: {0}\", initServerHook.info());\n                    initServerHook.handleInit(QuickServer.this);\n                }\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not load init server hook: {0}\", e);\n            logger.log(Level.WARNING, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Could not load init server hook\", e);\n        }\n        setServiceState(Service.INIT);\n        logger.log(Level.FINEST, \"\\r\\n{0}\", MyString.getSystemInfo(getVersion()));\n    }\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState() {\n        return serviceState;\n    }\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state) {\n        serviceState \u003d state;\n    }\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp) {\n        if (temp.equals(\"SEVERE\"))\n            qs.setConsoleLoggingLevel(Level.SEVERE);\n        else if (temp.equals(\"WARNING\"))\n            qs.setConsoleLoggingLevel(Level.WARNING);\n        else if (temp.equals(\"INFO\"))\n            qs.setConsoleLoggingLevel(Level.INFO);\n        else if (temp.equals(\"CONFIG\"))\n            qs.setConsoleLoggingLevel(Level.CONFIG);\n        else if (temp.equals(\"FINE\"))\n            qs.setConsoleLoggingLevel(Level.FINE);\n        else if (temp.equals(\"FINER\"))\n            qs.setConsoleLoggingLevel(Level.FINER);\n        else if (temp.equals(\"FINEST\"))\n            qs.setConsoleLoggingLevel(Level.FINEST);\n        else if (temp.equals(\"OFF\"))\n            qs.setConsoleLoggingLevel(Level.OFF);\n        else\n            logger.log(Level.WARNING, \"unknown level {0}\", temp);\n    }\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception {\n        QuickServer qs \u003d QuickServer.this;\n        //v1.3\n        qs.setConfig(config);\n        qs.setBasicConfig(config);\n        String temp \u003d config.getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        temp \u003d null;\n        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        //v1.3.3\n        qs.setSecurityManagerClass(config.getSecurityManagerClass());\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        temp \u003d config.getApplicationJarPath();\n        if (temp !\u003d null) {\n            File ajp \u003d new File(temp);\n            if (ajp.isAbsolute() \u003d\u003d false) {\n                temp \u003d config.getConfigFile();\n                ajp \u003d new File(temp);\n                temp \u003d ajp.getParent() + File.separatorChar + config.getApplicationJarPath();\n                config.setApplicationJarPath(temp);\n                temp \u003d null;\n            }\n            qs.setApplicationJarPath(config.getApplicationJarPath());\n            //set path also to QSAdmin\n            if (config.getQSAdminServerConfig() !\u003d null) {\n                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());\n            }\n        }\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception {\n        QuickServer qs \u003d getQSAdminServer().getServer();\n        qs.setBasicConfig(config);\n        //set the Logging Level to same as main QS\n        //config.getConsoleLoggingLevel();\n        String temp \u003d getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        //set the Logging Formatter to same as main QS\n        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());\n        //v1.4.6\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        //v1.4.6\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());\n        //v1.3.2\n        if (config.getCommandShellEnable().equals(\"true\"))\n            getQSAdminServer().setShellEnable(true);\n        getQSAdminServer().setPromptName(config.getCommandShellPromptName());\n        //v1.3.3\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception {\n        configQuickServer(getConfig());\n        if (getConfig().getQSAdminServerConfig() !\u003d null) {\n            configQuickServer(getConfig().getQSAdminServerConfig());\n        }\n    }\n\n    /**\n     * Usage: QuickServer [-options]\u003cbr/\u003e\n     * Where options include:\u003cbr/\u003e\n     *   -about\t\tOpens About Dialogbox\u003cbr/\u003e\n     *   -load \u003cxml_config_file\u003e [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File \u003cnew_file_name\u003e\n     */\n    public static void main(String[] args) {\n        try {\n            if (args.length \u003e\u003d 1) {\n                if (args[0].equals(\"-about\")) {\n                    org.quickserver.net.server.gui.About.main(null);\n                } else if (args[0].equals(\"-load\") \u0026\u0026 args.length \u003e\u003d 2) {\n                    QuickServer qs \u003d QuickServer.load(args[1]);\n                    if (qs !\u003d null)\n                        handleOptions(args, qs);\n                } else {\n                    System.out.println(printUsage());\n                }\n            } else {\n                System.out.println(printUsage());\n                org.quickserver.net.server.gui.About.showAbout();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException {\n        QuickServer qs \u003d new QuickServer();\n        Object[] config \u003d new Object[] { xml };\n        qs.initServer(config);\n        qs.startServer();\n        if (qs.getConfig().getQSAdminServerConfig() !\u003d null) {\n            qs.startQSAdminServer();\n        }\n        return qs;\n    }\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage() {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"QuickServer - Java library/framework for creating robust multi-client TCP servers.\\n\");\n        sb.append(\"Copyright (C) QuickServer.org\\n\\n\");\n        sb.append(\"Usage: QuickServer [-options]\\n\");\n        sb.append(\"Where options include:\\n\");\n        sb.append(\"  -about\\t\" + \"Opens About Dialog box\\n\");\n        sb.append(\"  -load \u003cxml_config_file\u003e [load-options]\\t\" + \"Loads the server from xml file.\\n\");\n        sb.append(\"  Where load-options include:\\n\");\n        sb.append(\"     -fullXML2File \u003cfile_name\u003e\\t\" + \"Dumps the Full XML configuration of the QuickServer loaded.\\n\");\n        return sb.toString();\n    }\n\n    private static void handleOptions(String[] args, QuickServer quickserver) {\n        if (args.length \u003c 3)\n            return;\n        if (args[2].equals(\"-fullXML2File\") \u0026\u0026 args.length \u003e\u003d 4) {\n            File file \u003d new File(args[3]);\n            logger.log(Level.INFO, \"Writing full xml configuration to file: {0}\", file.getAbsolutePath());\n            try {\n                TextFile.write(file, quickserver.getConfig().toXML(null));\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error writing full xml configuration: {0}\", e);\n            }\n        }\n    }\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception {\n        try {\n            if (pool !\u003d null)\n                getClientPool().clear();\n            if (clientHandlerPool !\u003d null)\n                getClientHandlerPool().clear();\n            if (getClientDataPool() !\u003d null)\n                getClientDataPool().clear();\n            if (getDBPoolUtil() !\u003d null)\n                getDBPoolUtil().clean();\n            if (byteBufferPool !\u003d null)\n                getByteBufferPool().clear();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error: {0}\", e);\n            throw e;\n        }\n    }\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception {\n        if (pool \u003d\u003d null \u0026\u0026 clientHandlerPool \u003d\u003d null \u0026\u0026 getClientDataPool() \u003d\u003d null \u0026\u0026 getDBPoolUtil() \u003d\u003d null \u0026\u0026 byteBufferPool \u003d\u003d null) {\n            return;\n        }\n        logger.log(Level.FINE, \"Closing pools for {0}\", getName());\n        try {\n            if (pool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {\n                logger.finer(\"Closing ClientThread pool.\");\n                getClientPool().close();\n            }\n            if (clientHandlerPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientHandlerPool())) {\n                logger.finer(\"Closing ClientHandler pool.\");\n                getClientHandlerPool().close();\n            }\n            if (getClientDataPool() !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientDataPool())) {\n                logger.finer(\"Closing ClientData pool.\");\n                getClientDataPool().close();\n            }\n            if (getDBPoolUtil() !\u003d null) {\n                logger.finer(\"Closing DB pool.\");\n                getDBPoolUtil().clean();\n            }\n            if (byteBufferPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getByteBufferPool())) {\n                logger.finer(\"Closing ByteBuffer pool.\");\n                getByteBufferPool().close();\n            }\n            logger.log(Level.FINE, \"Closed pools for {0}\", getName());\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error closing pools for {0}: {1}\", new Object[] { getName(), e });\n            throw e;\n        }\n    }\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception {\n        logger.fine(\"Creating pools\");\n        if (getBlockingMode() \u003d\u003d false) {\n            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());\n        }\n        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());\n        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());\n        //check if client data is poolable\n        if (clientDataClass !\u003d null) {\n            try {\n                clientData \u003d (ClientData) clientDataClass.newInstance();\n                if (PoolableObject.class.isInstance(clientData) \u003d\u003d true) {\n                    PoolableObject po \u003d (PoolableObject) clientData;\n                    if (po.isPoolable() \u003d\u003d true) {\n                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());\n                    } else {\n                        clientDataPool \u003d null;\n                        logger.fine(\"ClientData is not poolable!\");\n                    }\n                }\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error: {0}\", e);\n                throw e;\n            }\n        }\n        try {\n            makeDBObjectPool();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error in makeDBObjectPool() : {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw e;\n        }\n        logger.fine(\"Created pools\");\n    }\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool() {\n        if (pool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientPool available yet!\");\n        return pool;\n    }\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientHandler pool\");\n        PoolableObjectFactory factory \u003d new ClientHandlerObjectFactory(getBlockingMode());\n        clientHandlerPool \u003d poolManager.makeClientHandlerPool(factory, opConfig);\n        poolManager.initPool(clientHandlerPool, opConfig);\n        clientHandlerPool \u003d makeQSObjectPool(clientHandlerPool);\n        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool() {\n        if (clientHandlerPool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientHandler Pool available yet!\");\n        return clientHandlerPool;\n    }\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config) {\n        this.config \u003d config;\n    }\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig() {\n        return config;\n    }\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientData pool\");\n        clientDataPool \u003d poolManager.makeClientDataPool(factory, opConfig);\n        poolManager.initPool(clientDataPool, opConfig);\n        clientDataPool \u003d makeQSObjectPool(clientDataPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool() {\n        return clientDataPool;\n    }\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return \u003ccode\u003enull\u003c/code\u003e\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil() {\n        return dBPoolUtil;\n    }\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {\n        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);\n    }\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception {\n        if (getConfig().getDBObjectPoolConfig() !\u003d null) {\n            logger.fine(\"Creating DBObject Pool\");\n            //logger.finest(\"Got:\\n\"+getConfig().getDBObjectPoolConfig().toXML(null));\n            Class dbPoolUtilClass \u003d getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);\n            dBPoolUtil \u003d (DBPoolUtil) dbPoolUtilClass.newInstance();\n            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());\n            dBPoolUtil.initPool();\n        }\n    }\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id) {\n        return clientIdentifier.findFirstClientById(id);\n    }\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  \u003ccode\u003e\u003cpre\u003e\n     *    Eg:\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tObject syncObj \u003d quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator \u003d quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tClientIdentifier clientIdentifier \u003d quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator \u003d clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    \u003c/code\u003e\u003c/pre\u003e\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient() {\n        return clientIdentifier.findAllClient();\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern) {\n        return clientIdentifier.findAllClientById(pattern);\n    }\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key) {\n        return clientIdentifier.findClientByKey(key);\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern) {\n        return clientIdentifier.findAllClientByKey(pattern);\n    }\n\n    /**\n     * Sets next client has a trusted client.\n     * \u003cp\u003eThis will skip any authentication and will not set any timeout.\u003c/p\u003e\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted() {\n        setSkipValidation(true);\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation() {\n        return skipValidation;\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation) {\n        skipValidation \u003d validation;\n    }\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging) {\n        this.communicationLogging \u003d communicationLogging;\n    }\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging() {\n        return communicationLogging;\n    }\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass) {\n        if (securityManagerClass !\u003d null)\n            this.securityManagerClass \u003d securityManagerClass;\n    }\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass() {\n        return securityManagerClass;\n    }\n\n    public SecurityManager getSecurityManager() throws AppException {\n        if (getSecurityManagerClass() \u003d\u003d null)\n            return null;\n        SecurityManager sm \u003d null;\n        try {\n            sm \u003d (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();\n        } catch (ClassNotFoundException e) {\n            throw new AppException(e.getMessage());\n        } catch (InstantiationException e) {\n            throw new AppException(e.getMessage());\n        } catch (IllegalAccessException e) {\n            throw new AppException(e.getMessage());\n        }\n        return sm;\n    }\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {\n        this.accessConstraintConfig \u003d accessConstraintConfig;\n    }\n\n    /**\n     * Returns Access constraints if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig() {\n        return accessConstraintConfig;\n    }\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader) {\n        this.classLoader \u003d classLoader;\n        Thread.currentThread().setContextClassLoader(classLoader);\n    }\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader() {\n        return classLoader;\n    }\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException {\n        if (name \u003d\u003d null)\n            throw new IllegalArgumentException(\"Class name can\u0027t be null!\");\n        logger.log(Level.FINEST, \"Class: {0}, reload: {1}\", new Object[] { name, reload });\n        if (reload \u003d\u003d true \u0026\u0026 classLoader !\u003d null) {\n            return classLoader.loadClass(name);\n        } else if (reload \u003d\u003d true \u0026\u0026 classLoader \u003d\u003d null \u0026\u0026 this.getClass().getClassLoader() !\u003d null) {\n            return this.getClass().getClassLoader().loadClass(name);\n        } else if (reload \u003d\u003d false \u0026\u0026 classLoader !\u003d null) {\n            return Class.forName(name, true, classLoader);\n        } else /*if(reload\u003d\u003dfalse \u0026\u0026 classLoader\u003d\u003dnull)*/\n        {\n            return Class.forName(name, true, this.getClass().getClassLoader());\n        }\n    }\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath) {\n        this.applicationJarPath \u003d applicationJarPath;\n    }\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath() {\n        return applicationJarPath;\n    }\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks) {\n        this.serverHooks \u003d serverHooks;\n    }\n\n    /**\n     * Returns ServerHooks if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks() {\n        if (serverHooks \u003d\u003d null)\n            serverHooks \u003d new ServerHooks();\n        return serverHooks;\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses() {\n        if (getServerHooks() \u003d\u003d null)\n            return;\n        listOfServerHooks \u003d new ArrayList();\n        ServerHook serverHook \u003d null;\n        String serverHookClassName \u003d null;\n        Class serverHookClass \u003d null;\n        //add system hooks\n        serverHook \u003d new GhostSocketReaper();\n        serverHook.initHook(QuickServer.this);\n        listOfServerHooks.add(serverHook);\n        ghostSocketReaper \u003d (GhostSocketReaper) serverHook;\n        //add user hooks if any\n        Iterator iterator \u003d getServerHooks().iterator();\n        while (iterator.hasNext()) {\n            serverHookClassName \u003d (String) iterator.next();\n            try {\n                serverHookClass \u003d getClass(serverHookClassName, true);\n                serverHook \u003d (ServerHook) serverHookClass.newInstance();\n                serverHook.initHook(QuickServer.this);\n                listOfServerHooks.add(serverHook);\n                logger.log(Level.INFO, \"Loaded server hook: {0}\", serverHookClassName);\n                logger.log(Level.FINE, \"Server hook info: {0}\", serverHook.info());\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Could not load server hook [{0}]: {1}\", new Object[] { serverHookClassName, e });\n                logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            }\n        }\n        //end of while\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event) {\n        if (listOfServerHooks \u003d\u003d null) {\n            logger.warning(\"listOfServerHooks was null!\");\n            return;\n        }\n        ServerHook serverHook \u003d null;\n        boolean result \u003d false;\n        Iterator iterator \u003d listOfServerHooks.iterator();\n        String hooktype \u003d \"UNKNOWN\";\n        switch(event) {\n            case ServerHook.PRE_STARTUP:\n                hooktype \u003d \"PRE_STARTUP\";\n                break;\n            case ServerHook.POST_STARTUP:\n                hooktype \u003d \"POST_STARTUP\";\n                break;\n            case ServerHook.PRE_SHUTDOWN:\n                hooktype \u003d \"PRE_SHUTDOWN\";\n                break;\n            case ServerHook.POST_SHUTDOWN:\n                hooktype \u003d \"POST_SHUTDOWN\";\n                break;\n        }\n        while (iterator.hasNext()) {\n            serverHook \u003d (ServerHook) iterator.next();\n            try {\n                result \u003d serverHook.handleEvent(event);\n            } catch (Exception e) {\n                result \u003d false;\n                logger.log(Level.WARNING, \"Error invoking {0} hook [{1}]: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });\n            }\n            logger.log(Level.FINE, \"Invoked {0} hook [{1}] was: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), result });\n        }\n    }\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone() {\n        Object object \u003d null;\n        try {\n            object \u003d super.clone();\n            QuickServer _qs \u003d (QuickServer) object;\n            _qs.setQSAdminServer(new QSAdminServer(_qs));\n        } catch (CloneNotSupportedException e) {\n            //should not happ\n            logger.log(Level.WARNING, \"Error cloning : {0}\", e);\n        }\n        return object;\n    }\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure) {\n        this.secure \u003d secure;\n    }\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure() {\n        if (secure \u003d\u003d null)\n            secure \u003d new Secure();\n        return secure;\n    }\n\n    /**\n     * \u003cp\u003eReturns if the server is running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure() {\n        return runningSecure;\n    }\n\n    /**\n     * \u003cp\u003eSets the server mode if its running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure) {\n        this.runningSecure \u003d runningSecure;\n    }\n\n    private File makeAbsoluteToConfig(String fileName) {\n        Assertion.affirm(fileName !\u003d null, \"FileName can\u0027t be null\");\n        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());\n    }\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException {\n        server \u003d null;\n        logger.log(Level.FINEST, \"Binding {0} to IP: {1}\", new Object[] { getName(), getBindAddr() });\n        InetSocketAddress bindAddress \u003d new InetSocketAddress(getBindAddr(), getPort());\n        try {\n            NetworkInterface ni \u003d NetworkInterface.getByInetAddress(getBindAddr());\n            if (ni !\u003d null) {\n                logger.fine(\"NetworkInterface: \" + ni);\n            }\n        } catch (Exception igrnore) {\n            /*ignore*/\n        } catch (Error igrnore) {\n            /*ignore*/\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Making a normal ServerSocket for {0}\", getName());\n            setRunningSecure(false);\n            if (getBlockingMode() \u003d\u003d false) {\n                //for non-blocking\n                serverSocketChannel \u003d ServerSocketChannel.open();\n                server \u003d serverSocketChannel.socket();\n                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n            } else {\n                //for blocking\n                server \u003d new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n            }\n        } else {\n            try {\n                logger.log(Level.FINE, \"Making a secure ServerSocket for {0}\", getName());\n                getSSLContext();\n                setRunningSecure(true);\n                if (getBlockingMode() \u003d\u003d false) {\n                    logger.log(Level.FINE, \"Making a secure ServerSocketChannel for {0}\", getName());\n                    //for non-blocking\n                    serverSocketChannel \u003d ServerSocketChannel.open();\n                    server \u003d serverSocketChannel.socket();\n                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n                } else {\n                    ServerSocketFactory ssf \u003d getSSLContext().getServerSocketFactory();\n                    SSLServerSocket serversocket \u003d (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());\n                    setRunningSecure(true);\n                    secureStoreManager.logSSLServerSocketInfo(serversocket);\n                    server \u003d serversocket;\n                    serverSocketChannel \u003d server.getChannel();\n                    if (serverSocketChannel \u003d\u003d null \u0026\u0026 getBlockingMode() \u003d\u003d false) {\n                        logger.warning(\"Secure Server does not support Channel! So will run in blocking mode.\");\n                        blockingMode \u003d false;\n                    }\n                }\n                //blocking\n            } catch (NoSuchAlgorithmException e) {\n                logger.log(Level.WARNING, \"NoSuchAlgorithmException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            } catch (KeyManagementException e) {\n                logger.log(Level.WARNING, \"KeyManagementException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            }\n        }\n        server.setReuseAddress(true);\n        int connectionTime \u003d 0;\n        int latency \u003d 0;\n        int bandwidth \u003d 0;\n        connectionTime \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();\n        latency \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();\n        bandwidth \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();\n        logger.log(Level.FINE, \"getPerformancePreferencesConnectionTime : {0}\", connectionTime);\n        logger.log(Level.FINE, \"getPerformancePreferencesLatency : {0}\", latency);\n        logger.log(Level.FINE, \"getPerformancePreferencesBandwidth : {0}\", bandwidth);\n        server.setPerformancePreferences(connectionTime, latency, bandwidth);\n        int clientSocketReceiveBufferSize \u003d getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();\n        if (clientSocketReceiveBufferSize \u003e 0) {\n            logger.log(Level.FINE, \"clientSocketReceiveBufferSize: {0}\", clientSocketReceiveBufferSize);\n            server.setReceiveBufferSize(clientSocketReceiveBufferSize);\n        }\n        if (getBlockingMode() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Server Mode {0} - Non Blocking\", getName());\n            if (selector \u003d\u003d null || selector.isOpen() \u003d\u003d false) {\n                logger.finest(\"Opening new selector\");\n                selector \u003d Selector.open();\n            } else {\n                logger.log(Level.FINEST, \"Reusing selector: {0}\", selector);\n            }\n            serverSocketChannel.configureBlocking(false);\n            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n            selector.wakeup();\n        } else {\n            logger.log(Level.FINE, \"Server Mode {0} - Blocking\", getName());\n        }\n    }\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {\n        Assertion.affirm(basicConfig !\u003d null, \"BasicServerConfig can\u0027t be null\");\n        this.basicConfig \u003d basicConfig;\n    }\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig() {\n        return basicConfig;\n    }\n\n    /**\n     * Loads the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException {\n        if (getSecure().isLoad() \u003d\u003d false) {\n            throw new IllegalStateException(\"Secure setting is not yet enabled for loading!\");\n        }\n        logger.info(\"Loading Secure Context..\");\n        km \u003d null;\n        tm \u003d null;\n        try {\n            String ssManager \u003d \"org.quickserver.security.SecureStoreManager\";\n            if (getSecure().getSecureStore() !\u003d null)\n                ssManager \u003d getSecure().getSecureStore().getSecureStoreManager();\n            Class secureStoreManagerClass \u003d getClass(ssManager, true);\n            secureStoreManager \u003d (SecureStoreManager) secureStoreManagerClass.newInstance();\n            km \u003d secureStoreManager.loadKeyManagers(getConfig());\n            logger.fine(\"KeyManager got\");\n            tm \u003d secureStoreManager.loadTrustManagers(getConfig());\n            logger.fine(\"TrustManager got\");\n            sslc \u003d secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());\n            sslc.init(km, tm, null);\n            logger.fine(\"SSLContext loaded\");\n        } catch (KeyStoreException e) {\n            logger.warning(\"KeyStoreException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchAlgorithmException e) {\n            logger.warning(\"NoSuchAlgorithmException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchProviderException e) {\n            logger.warning(\"NoSuchProviderException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (UnrecoverableKeyException e) {\n            logger.warning(\"UnrecoverableKeyException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (CertificateException e) {\n            logger.warning(\"CertificateException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (KeyManagementException e) {\n            logger.warning(\"KeyManagementException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (GeneralSecurityException e) {\n            logger.warning(\"GeneralSecurityException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (ClassNotFoundException e) {\n            logger.warning(\"ClassNotFoundException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (InstantiationException e) {\n            logger.warning(\"InstantiationException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (IllegalAccessException e) {\n            logger.warning(\"IllegalAccessException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        return getSSLContext(null);\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        if (protocol !\u003d null \u0026\u0026 secureStoreManager !\u003d null) {\n            SSLContext _sslc \u003d secureStoreManager.getSSLContext(protocol);\n            _sslc.init(km, tm, null);\n            return _sslc;\n        }\n        return sslc;\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext());\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext(protocol));\n    }\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler) {\n        clientBinaryHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler() {\n        return clientBinaryHandlerString;\n    }\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector) {\n        this.selector \u003d selector;\n    }\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector() {\n        return selector;\n    }\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception {\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        //long stime \u003d System.currentTimeMillis();\n        //long etime \u003d System.currentTimeMillis();\n        while (true) {\n            //etime \u003d System.currentTimeMillis();\n            //System.out.println(\"Time Taken: \"+(etime-stime));\n            client \u003d server.accept();\n            //stime \u003d System.currentTimeMillis();\n            if (linger \u003c 0) {\n                client.setSoLinger(false, 0);\n            } else {\n                client.setSoLinger(true, linger);\n            }\n            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                //low delay\u003d10\n                client.setTrafficClass(socketTrafficClass);\n            }\n            logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n            }\n            if (stopServer) {\n                //Client connected when server was about to be shutdown.\n                try {\n                    client.close();\n                } catch (Exception e) {\n                }\n                break;\n            }\n            if (checkAccessConstraint(client) \u003d\u003d false) {\n                continue;\n            }\n            //Check if max connection has reached\n            if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);\n            } else {\n                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);\n            }\n            theClient.setTrusted(getSkipValidation());\n            theClient.setSocket(client);\n            //mostly null\n            theClient.setSocketChannel(client.getChannel());\n            if (clientDataClass !\u003d null) {\n                if (getClientDataPool() \u003d\u003d null) {\n                    clientData \u003d (ClientData) clientDataClass.newInstance();\n                } else {\n                    clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                }\n                theClient.setClientData(clientData);\n            }\n            try {\n                _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                _chPolled.handleClient(theClient);\n            } catch (java.util.NoSuchElementException nsee) {\n                logger.warning(\"Could not borrow ClientHandler from pool. Error: \" + nsee);\n                logger.warning(\"Closing Socket [\" + client + \"] since no ClientHandler available.\");\n                client.close();\n            }\n            if (_chPolled !\u003d null) {\n                try {\n                    getClientPool().addClient(_chPolled, true);\n                } catch (java.util.NoSuchElementException nsee) {\n                    logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                    //logger.warning(\"Closing Socket [\"+client+\"] since no Thread available.\");\n                    //client.close();\n                    //returnClientHandlerToPool(_chPolled);\n                }\n                _chPolled \u003d null;\n            }\n            client \u003d null;\n            //reset it back\n            setSkipValidation(false);\n        }\n        //end of loop\n    }\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception {\n        int selectCount \u003d 0;\n        Iterator iterator \u003d null;\n        SelectionKey key \u003d null;\n        ServerSocketChannel serverChannel \u003d null;\n        SocketChannel socketChannel \u003d null;\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        boolean stopServerProcessed \u003d false;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        registerChannelRequestMap \u003d new HashMap();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        while (true) {\n            selectCount \u003d selector.select(500);\n            //selectCount \u003d selector.select();//for testing\n            //check for any pending registerChannel req.\n            synchronized (registerChannelRequestMap) {\n                if (registerChannelRequestMap.size() \u003e 0) {\n                    RegisterChannelRequest req \u003d null;\n                    Object hashkey \u003d null;\n                    iterator \u003d registerChannelRequestMap.keySet().iterator();\n                    while (iterator.hasNext()) {\n                        hashkey \u003d iterator.next();\n                        req \u003d (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);\n                        req.register(getSelector());\n                    }\n                    iterator \u003d null;\n                    registerChannelRequestMap.clear();\n                }\n                //if\n            }\n            //sync\n            if (stopServer \u003d\u003d true \u0026\u0026 stopServerProcessed \u003d\u003d false) {\n                logger.warning(\"Closing \" + getName());\n                serverSocketChannel.close();\n                stopServerProcessed \u003d true;\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.warning(\"Closed \" + getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n            if (stopServer \u003d\u003d false \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                logger.finest(\"Server must have re-started.. will break\");\n                break;\n            }\n            if (selectCount \u003d\u003d 0 \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                java.util.Set keyset \u003d selector.keys();\n                if (keyset.isEmpty() \u003d\u003d true \u0026\u0026 getClientCount() \u003c\u003d 0) {\n                    break;\n                } else {\n                    continue;\n                }\n            } else if (selectCount \u003d\u003d 0) {\n                continue;\n            }\n            iterator \u003d selector.selectedKeys().iterator();\n            while (iterator.hasNext()) {\n                key \u003d (SelectionKey) iterator.next();\n                if (key.isValid() \u003d\u003d false) {\n                    iterator.remove();\n                    continue;\n                }\n                if (key.isAcceptable() \u0026\u0026 stopServer \u003d\u003d false) {\n                    logger.finest(\"Key is Acceptable\");\n                    serverChannel \u003d (ServerSocketChannel) key.channel();\n                    socketChannel \u003d serverChannel.accept();\n                    if (socketChannel \u003d\u003d null) {\n                        iterator.remove();\n                        continue;\n                    }\n                    client \u003d socketChannel.socket();\n                    if (linger \u003c 0) {\n                        client.setSoLinger(false, 0);\n                    } else {\n                        client.setSoLinger(true, linger);\n                    }\n                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                        //low delay\u003d10\n                        client.setTrafficClass(socketTrafficClass);\n                    }\n                    logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                        logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n                    }\n                    if (checkAccessConstraint(client) \u003d\u003d false) {\n                        iterator.remove();\n                        continue;\n                    }\n                    socketChannel.configureBlocking(false);\n                    theClient.setTrusted(getSkipValidation());\n                    theClient.setSocket(socketChannel.socket());\n                    theClient.setSocketChannel(socketChannel);\n                    if (clientDataClass !\u003d null) {\n                        if (getClientDataPool() \u003d\u003d null) {\n                            clientData \u003d (ClientData) clientDataClass.newInstance();\n                        } else {\n                            //borrow a object from pool\n                            clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                        }\n                        theClient.setClientData(clientData);\n                    }\n                    //Check if max connection has reached\n                    if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                        theClient.setClientEvent(ClientEvent.MAX_CON);\n                    } else {\n                        theClient.setClientEvent(ClientEvent.ACCEPT);\n                    }\n                    try {\n                        _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                        logger.finest(\"Asking \" + _chPolled.getName() + \" to handle.\");\n                        _chPolled.handleClient(theClient);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.warning(\"Could not borrow ClientHandler Object from pool. Error: \" + nsee);\n                        logger.warning(\"Closing SocketChannel [\" + serverChannel.socket() + \"] since no ClientHandler available.\");\n                        socketChannel.close();\n                    }\n                    if (_chPolled !\u003d null) {\n                        try {\n                            getClientPool().addClient(_chPolled, true);\n                        } catch (java.util.NoSuchElementException nsee) {\n                            logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                            //logger.warning(\"Closing SocketChannel [\"+serverChannel.socket()+\"] since no Thread available.\");\n                            //socketChannel.close();\n                            //returnClientHandlerToPool(_chPolled);\n                        }\n                        _chPolled \u003d null;\n                    }\n                    socketChannel \u003d null;\n                    client \u003d null;\n                    //reset it back\n                    setSkipValidation(false);\n                } else if (key.isValid() \u0026\u0026 key.isReadable()) {\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Readable, removing OP_READ from interestOps for \" + _ch.getName());\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_READ));\n                        _ch.addEvent(ClientEvent.READ);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.READ);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (key.isValid() \u0026\u0026 key.isWritable()) {\n                    if (getClientPool().shouldNioWriteHappen() \u003d\u003d false) {\n                        //no need to remove the key\n                        continue;\n                    }\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Writable, removing OP_WRITE from interestOps for \" + _ch.getName());\n                        //remove OP_WRITE from interest set\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_WRITE));\n                        _ch.addEvent(ClientEvent.WRITE);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.WRITE);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (stopServer \u003d\u003d true \u0026\u0026 key.isAcceptable()) {\n                    //we will not accept this key\n                    //reset it back\n                    setSkipValidation(false);\n                } else {\n                    logger.warning(\"Unknown key got in SelectionKey: \" + key);\n                }\n                //Remove key\n                iterator.remove();\n                Thread.yield();\n            }\n            //end of iterator\n            iterator \u003d null;\n        }\n        //end of loop\n    }\n\n    private boolean checkAccessConstraint(Socket socket) {\n        try {\n            if (getAccessConstraintConfig() !\u003d null) {\n                getAccessConstraintConfig().checkAccept(socket);\n            }\n            return true;\n        } catch (SecurityException se) {\n            logger.warning(\"SecurityException occurred accepting connection : \" + se.getMessage());\n            return false;\n        }\n    }\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {\n        if (getSelector() \u003d\u003d null) {\n            throw new IllegalStateException(\"Selector is not open!\");\n        }\n        if (channel \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Can\u0027t register a null channel!\");\n        }\n        if (channel.isConnected() \u003d\u003d false) {\n            throw new ClosedChannelException();\n        }\n        RegisterChannelRequest req \u003d new RegisterChannelRequest(channel, ops, att);\n        RegisterChannelRequest reqOld \u003d null;\n        synchronized (registerChannelRequestMap) {\n            reqOld \u003d (RegisterChannelRequest) registerChannelRequestMap.get(channel);\n            if (reqOld \u003d\u003d null) {\n                registerChannelRequestMap.put(channel, req);\n                getSelector().wakeup();\n                return true;\n            } else {\n                if (reqOld.equals(req) \u003d\u003d false) {\n                    reqOld.setOps(reqOld.getOps() | req.getOps());\n                    reqOld.setAtt(req.getAtt());\n                    return true;\n                }\n                return false;\n            }\n        }\n        /*\n\t\tlogger.warning(\"Before register...\");\n\t\tchannel.register(getSelector(), ops, att);\n\t\tlogger.warning(\"Before wakeup and after register...\");\n\t\tgetSelector().wakeup();\n\t\tlogger.warning(\"After wakeup...\");\n\t\t*/\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig) {\n        logger.finer(\"Creating ByteBufferPool pool\");\n        int bufferSize \u003d getBasicConfig().getAdvancedSettings().getByteBufferSize();\n        boolean useDirectByteBuffer \u003d getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();\n        PoolableObjectFactory factory \u003d new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);\n        byteBufferPool \u003d poolManager.makeByteBufferPool(factory, opConfig);\n        poolManager.initPool(byteBufferPool, opConfig);\n    }\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool() {\n        return byteBufferPool;\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientThread pool\");\n        ThreadObjectFactory factory \u003d new ThreadObjectFactory();\n        ObjectPool objectPool \u003d poolManager.makeClientPool(factory, opConfig);\n        pool \u003d new ClientPool(makeQSObjectPool(objectPool), opConfig);\n        factory.setClientPool(pool);\n        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());\n        poolManager.initPool(objectPool, opConfig);\n    }\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler) {\n        clientWriteHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler() {\n        return clientWriteHandlerString;\n    }\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be \u003ccode\u003enull\u003c/code\u003e if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime() {\n        return lastStartTime;\n    }\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag) {\n        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);\n        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);\n    }\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier() {\n        return clientIdentifier;\n    }\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {\n        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);\n    }\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode() {\n        return blockingMode;\n    }\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception {\n        if (clientCommandHandlerString \u003d\u003d null \u0026\u0026 clientEventHandlerString \u003d\u003d null) {\n            logger.severe(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n            throw new AppException(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n        }\n        clientCommandHandler \u003d null;\n        if (clientCommandHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientCommandHandler class..\");\n            Class clientCommandHandlerClass \u003d getClass(clientCommandHandlerString, true);\n            clientCommandHandler \u003d (ClientCommandHandler) clientCommandHandlerClass.newInstance();\n        }\n        boolean setClientCommandHandlerLookup \u003d false;\n        clientEventHandler \u003d null;\n        if (clientEventHandlerString \u003d\u003d null) {\n            clientEventHandlerString \u003d \"org.quickserver.net.server.impl.DefaultClientEventHandler\";\n            setClientCommandHandlerLookup \u003d true;\n        }\n        logger.finest(\"Loading ClientEventHandler class..\");\n        if (clientEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientEventHandler.class.isInstance(clientCommandHandler)) {\n            clientEventHandler \u003d (ClientEventHandler) clientCommandHandler;\n        } else {\n            clientEventHandler \u003d (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();\n            if (setClientCommandHandlerLookup) {\n                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);\n            }\n        }\n        clientExtendedEventHandler \u003d null;\n        if (clientExtendedEventHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientExtendedEventHandler class..\");\n            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientCommandHandler;\n            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientEventHandler;\n            } else {\n                Class clientExtendedEventHandlerClass \u003d getClass(clientExtendedEventHandlerString, true);\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();\n            }\n        }\n        clientObjectHandler \u003d null;\n        if (clientObjectHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientObjectHandler class..\");\n            if (clientObjectHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientCommandHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientCommandHandler;\n            } else if (clientObjectHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientEventHandler;\n            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientExtendedEventHandler;\n            } else {\n                clientObjectHandler \u003d (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientBinaryHandler \u003d null;\n        if (clientBinaryHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientBinaryHandler class..\");\n            if (clientBinaryHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientCommandHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientCommandHandler;\n            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientExtendedEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientObjectHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientObjectHandler;\n            } else {\n                clientBinaryHandler \u003d (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientWriteHandler \u003d null;\n        if (clientWriteHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientWriteHandler class..\");\n            if (clientWriteHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientCommandHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientCommandHandler;\n            } else if (clientWriteHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientEventHandler;\n            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientExtendedEventHandler;\n            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientObjectHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientObjectHandler;\n            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientBinaryHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientBinaryHandler;\n            } else {\n                clientWriteHandler \u003d (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        Class authenticatorClass \u003d null;\n        if (clientAuthenticationHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientAuthenticationHandler class..\");\n            authenticatorClass \u003d getClass(clientAuthenticationHandlerString, true);\n        }\n        if (authenticatorClass !\u003d null) {\n            Object obj \u003d authenticatorClass.newInstance();\n            if (ClientAuthenticationHandler.class.isInstance(obj))\n                clientAuthenticationHandler \u003d (ClientAuthenticationHandler) obj;\n            else\n                authenticator \u003d (Authenticator) obj;\n        }\n        clientDataClass \u003d null;\n        if (clientDataString !\u003d null) {\n            logger.finest(\"Loading ClientData class..\");\n            clientDataClass \u003d getClass(clientDataString, true);\n        }\n        Assertion.affirm(clientEventHandler !\u003d null, \"ClientEventHandler was not loaded!\");\n    }\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler) {\n        clientEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler() {\n        return clientEventHandlerString;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {\n        if (dataType \u003d\u003d DataType.IN)\n            this.defaultDataModeIN \u003d dataMode;\n        if (dataType \u003d\u003d DataType.OUT)\n            this.defaultDataModeOUT \u003d dataMode;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {\n        defaultDataModeIN \u003d defaultDataMode.getDataMode(DataType.IN);\n        defaultDataModeOUT \u003d defaultDataMode.getDataMode(DataType.OUT);\n        ;\n    }\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType) {\n        if (dataType \u003d\u003d DataType.IN)\n            return defaultDataModeIN;\n        if (dataType \u003d\u003d DataType.OUT)\n            return defaultDataModeOUT;\n        else\n            throw new IllegalArgumentException(\"Unknown DataType: \" + dataType);\n    }\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler) {\n        clientExtendedEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler() {\n        return clientExtendedEventHandlerString;\n    }\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception {\n        if (getApplicationJarPath() !\u003d null \u0026\u0026 getClassLoader() \u003d\u003d null) {\n            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));\n            //update qsadmin to use the same\n            if (adminServer !\u003d null) {\n                adminServer.getServer().setClassLoader(getClassLoader());\n            }\n        }\n    }\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID() {\n        return pid;\n    }\n\n    public boolean isRawCommunicationLogging() {\n        return rawCommunicationLogging;\n    }\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {\n        this.rawCommunicationLogging \u003d rawCommunicationLogging;\n    }\n\n    public int getRawCommunicationMaxLength() {\n        return rawCommunicationMaxLength;\n    }\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {\n        this.rawCommunicationMaxLength \u003d rawCommunicationMaxLength;\n    }\n}\n",
    "package": "org.quickserver.net.server",
    "classname": "QuickServer",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_19Test.java",
    "test_prompt": "// QuickServer_19Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#getSSLSocketFactory(String)} method.\n*/\nclass QuickServer_19Test {",
    "method_signature": "getSSLSocketFactory(String)",
    "suffix": "19"
  },
  {
    "numberTests": "ten",
    "original_code": "// QuickServer.java\n/*\n * This file is part of the QuickServer library \n * Copyright (C) QuickServer.org\n *\n * Use, modification, copying and distribution of this software is subject to\n * the terms and conditions of the GNU Lesser General Public License. \n * You should have received a copy of the GNU LGP License along with this \n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\n *\n * For questions, suggestions, bug-reports, enhancement-requests etc.\n * visit http://www.quickserver.org\n *\n */\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\n\n/**\n *  Main class of QuickServer library. This class is used to create\n *  multi client servers quickly.\n *  \u003cp\u003e\n *  Ones a client is connected, it creates {@link ClientHandler} object,\n *  which is run using any thread available from the pool of threads\n *  maintained by {@link org.quickserver.util.pool.thread.ClientPool}, which\n *  handles the client. \u003cbr/\u003e\n *  QuickServer divides the application logic of its developer over eight\n *  class, \u003cbr\u003e\n *  \t\u003cul\u003e\n * \t\t\u003cli\u003eClientEventHandler\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client events [Optional Class].\n *  \t\t\u003cli\u003eClientCommandHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client character/string commands.\n *  \t\t\u003cli\u003eClientObjectHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - Object commands.\n * \t\t\u003cli\u003eClientBinaryHandler [#]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - binary data.\n * \t\t\u003cli\u003eClientWriteHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles client interaction - writing data (Only used in non-blocking mode).\n *  \t\t\u003cli\u003eClientAuthenticationHandler [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Used to Authencatet a client.\n *  \t\t\u003cli\u003eClientData [Optional Class]\u003cbr\u003e\n *  \t\t\t\u0026nbsp;Client data carrier (support class)\n * \t\t\u003cli\u003eClientExtendedEventHandler [Optional Class]\u003cbr\u003e\n *  \t\t   \u0026nbsp;Handles extended client events.\n *  \t\u003c/ul\u003e\n *\n *  [#] \u003d Any one of these have to be set based on default DataMode for input.\n *  The default DataMode for input is String so if not changes you will\n *  have to set ClientCommandHandler.\n *  \u003c/p\u003e\n *  \u003cp\u003e\n *   Eg:\n *  \u003ccode\u003e\u003cBLOCKQUOTE\u003e\u003cpre\u003e\n * package echoserver;\n *\n * import org.quickserver.net.*;\n * import org.quickserver.net.server.*;\n *\n * import java.io.*;\n *\n * public class EchoServer {\n * \tpublic static void main(String args[])\t{\n * \t\tString cmdHandle \u003d \"echoserver.EchoCommandHandler\";\n *\n * \t\tQuickServer myServer \u003d new QuickServer();\n * \t\tmyServer.setClientCommandHandler(cmdHandle);\n * \t\tmyServer.setPort(4123);\n * \t\tmyServer.setName(Echo Server v1.0\");\n * \t\ttry {\n * \t\t\tmyServer.startServer();\n * \t\t} catch(AppException e) {\n * \t\t\tSystem.err.println(\"Error in server : \"+e);\n * \t\t\te.printStackTrace();\n * \t\t}\n * \t}\n * }\n * \u003c/pre\u003e\u003c/BLOCKQUOTE\u003e\u003c/code\u003e\u003c/p\u003e\n *\n *  @version 1.4.8\n *  @author Akshathkumar Shetty\n */\npublic class QuickServer implements Runnable, Service, Cloneable, Serializable {\n\n    //Some variable are not initialised to any value because the\n    //default java value was desired initial value.\n    //\u0027dev \u0027 \u003d development build not yet final\n    //\u0027beta\u0027 \u003d test build all features\n    //change also in QSAdminMain\n    private final static String VER \u003d \"2.0.0 RC1\";\n\n    private final static String NEW_LINE;\n\n    private final static String pid;\n\n    static {\n        if (System.getProperty(\"org.quickserver.useOSLineSeparator\") !\u003d null \u0026\u0026 System.getProperty(\"org.quickserver.useOSLineSeparator\").equals(\"true\")) {\n            NEW_LINE \u003d System.getProperty(\"line.separator\");\n        } else {\n            NEW_LINE \u003d \"\\r\\n\";\n        }\n        String _pid \u003d ManagementFactory.getRuntimeMXBean().getName();\n        int i \u003d _pid.indexOf(\"@\");\n        pid \u003d _pid.substring(0, i);\n        System.out.print(\"Loading QuickServer v\" + getVersion() + \" [PID:\" + pid + \"]\");\n    }\n\n    private String serverBanner;\n\n    //v1.4.6\n    private String clientAuthenticationHandlerString;\n\n    //v1.4.6\n    private String clientEventHandlerString;\n\n    //v1.4.6\n    private String clientExtendedEventHandlerString;\n\n    private String clientCommandHandlerString;\n\n    //v1.2\n    private String clientObjectHandlerString;\n\n    //v1.4\n    private String clientBinaryHandlerString;\n\n    //v1.4.5\n    private String clientWriteHandlerString;\n\n    private String clientDataString;\n\n    private Authenticator authenticator;\n\n    //v1.4.6\n    private ClientAuthenticationHandler clientAuthenticationHandler;\n\n    //v1.4.6\n    private ClientEventHandler clientEventHandler;\n\n    //v1.4.6\n    private ClientExtendedEventHandler clientExtendedEventHandler;\n\n    private ClientCommandHandler clientCommandHandler;\n\n    //v1.2\n    private ClientObjectHandler clientObjectHandler;\n\n    //v1.4\n    private ClientBinaryHandler clientBinaryHandler;\n\n    //v1.4.5\n    private ClientWriteHandler clientWriteHandler;\n\n    private ClientData clientData;\n\n    protected Class clientDataClass;\n\n    private int serverPort \u003d 9876;\n\n    //Main thread\n    private Thread t;\n\n    private ServerSocket server;\n\n    private String serverName \u003d \"QuickServer\";\n\n    private long maxConnection \u003d -1;\n\n    //1 min socket timeout\n    private int socketTimeout \u003d 60 * 1000;\n\n    private String maxConnectionMsg \u003d \"-ERR Server Busy. Max Connection Reached\";\n\n    private String timeoutMsg \u003d \"-ERR Timeout\";\n\n    private String maxAuthTryMsg \u003d \"-ERR Max Auth Try Reached\";\n\n    //v1.2\n    private int maxAuthTry \u003d 5;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.1\n    private InetAddress ipAddr;\n\n    private boolean stopServer;\n\n    private Object[] storeObjects;\n\n    private QSAdminServer adminServer;\n\n    //--v1.2\n    //Logger for QuickServer\n    private static final Logger logger \u003d Logger.getLogger(QuickServer.class.getName());\n\n    //Logger for the application using this QuickServer\n    private Logger appLogger;\n\n    //for Service interface\n    //backup\n    private long suspendMaxConnection;\n\n    //backup\n    private String suspendMaxConnectionMsg;\n\n    private int serviceState \u003d Service.UNKNOWN;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.3\n    private QuickServerConfig config \u003d new QuickServerConfig();\n\n    private String consoleLoggingformatter;\n\n    private String consoleLoggingLevel \u003d \"INFO\";\n\n    private ClientPool pool;\n\n    private ObjectPool clientHandlerPool;\n\n    private ObjectPool clientDataPool;\n\n    private DBPoolUtil dBPoolUtil;\n\n    //--v1.3.1\n    private String loggingLevel \u003d \"INFO\";\n\n    //--v1.3.2\n    private boolean skipValidation \u003d false;\n\n    private boolean communicationLogging \u003d true;\n\n    //--v1.3.3\n    private String securityManagerClass;\n\n    private AccessConstraintConfig accessConstraintConfig;\n\n    private ClassLoader classLoader;\n\n    private String applicationJarPath;\n\n    private ServerHooks serverHooks;\n\n    private ArrayList listOfServerHooks;\n\n    static {\n        System.out.print(\".\");\n    }\n\n    //--v1.4.0\n    private Secure secure;\n\n    private BasicServerConfig basicConfig \u003d config;\n\n    private SSLContext sslc;\n\n    private KeyManager[] km \u003d null;\n\n    private TrustManager[] tm \u003d null;\n\n    private boolean runningSecure \u003d false;\n\n    private SecureStoreManager secureStoreManager \u003d null;\n\n    private Exception exceptionInRun \u003d null;\n\n    //--v1.4.5\n    private ServerSocketChannel serverSocketChannel;\n\n    private Selector selector;\n\n    private boolean blockingMode \u003d true;\n\n    private ObjectPool byteBufferPool;\n\n    private java.util.Date lastStartTime;\n\n    private ClientIdentifier clientIdentifier;\n\n    private GhostSocketReaper ghostSocketReaper;\n\n    private PoolManager poolManager;\n\n    private QSObjectPoolMaker qsObjectPoolMaker;\n\n    //--v1.4.6\n    private DataMode defaultDataModeIN \u003d DataMode.STRING;\n\n    private DataMode defaultDataModeOUT \u003d DataMode.STRING;\n\n    //-v1.4.7\n    private Throwable serviceError;\n\n    private Map registerChannelRequestMap;\n\n    //v-1.4.8\n    private boolean rawCommunicationLogging \u003d false;\n\n    private int rawCommunicationMaxLength \u003d 100;\n\n    static {\n        System.out.println(\" Done\");\n        //should be commented if not a patch release\n        //System.out.println(\"[Includes patch(#): t\u003d152\u0026p\u003d532]\");\n        //should be commented if not a dev release\n        //System.out.println(\"[Dev Build Date: Saturday, October 29, 2005]\");\n        logger.log(Level.FINE, \"PID: {0}\", pid);\n    }\n\n    /**\n     * Returns the version of the library.\n     */\n    public static final String getVersion() {\n        return VER;\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.2\n     */\n    public static final float getVersionNo() {\n        return getVersionNo(VER);\n    }\n\n    /**\n     * Returns the numerical version of the library.\n     * @since 1.4.5\n     */\n    public static final float getVersionNo(String ver) {\n        //String ver \u003d getVersion();\n        float version \u003d 0;\n        //check if beta\n        int i \u003d ver.indexOf(\" \");\n        if (i \u003d\u003d -1)\n            i \u003d ver.length();\n        ver \u003d ver.substring(0, i);\n        //check for sub version\n        i \u003d ver.indexOf(\".\");\n        if (i !\u003d -1) {\n            int j \u003d ver.indexOf(\".\", i);\n            if (j !\u003d -1) {\n                ver \u003d ver.substring(0, i) + \".\" + MyString.replaceAll(ver.substring(i + 1), \".\", \"\");\n            }\n        }\n        try {\n            version \u003d Float.parseFloat(ver);\n        } catch (NumberFormatException e) {\n            throw new RuntimeException(\"Corrupt QuickServer\");\n        }\n        return version;\n    }\n\n    /**\n     * Returns the new line string used by QuickServer.\n     * @since 1.2\n     */\n    public static String getNewLine() {\n        return NEW_LINE;\n    }\n\n    /**\n     * Returns the Server name : port of the QuickServer.\n     */\n    public String toString() {\n        return serverName + \" : \" + getPort();\n    }\n\n    /**\n     * Creates a new server without any configuration.\n     * Make sure you configure the QuickServer, before\n     * calling startServer()\n     * @see org.quickserver.net.server.ClientEventHandler\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientObjectHandler\n     * @see org.quickserver.net.server.ClientBinaryHandler\n     * @see org.quickserver.net.server.ClientWriteHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #configQuickServer\n     * @see #initService\n     * @see #setPort\n     * @see #setClientCommandHandler\n     * @since 1.2\n     */\n    public QuickServer() {\n    }\n\n    /**\n     * Creates a new server with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     * @param commandHandler the fully qualified name of the\n     *  desired class that implements {@link ClientCommandHandler}\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     * @see #setPort\n     */\n    public QuickServer(String commandHandler) {\n        setClientCommandHandler(commandHandler);\n    }\n\n    /**\n     * Creates a new server at \u003ccode\u003eport\u003c/code\u003e with the specified\n     * \u003ccode\u003ecommandHandler\u003c/code\u003e has it {@link ClientCommandHandler}.\n     *\n     * @param commandHandler fully qualified name of the class that\n     * implements {@link ClientCommandHandler}\n     * @param port to listen on.\n     *\n     * @see org.quickserver.net.server.ClientCommandHandler\n     * @see org.quickserver.net.server.ClientAuthenticationHandler\n     * @see org.quickserver.net.server.ClientHandler\n     */\n    public QuickServer(String commandHandler, int port) {\n        //send to another constructor\n        this(commandHandler);\n        setPort(port);\n    }\n\n    /**\n     * Starts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @see #startService\n     */\n    public void startServer() throws AppException {\n        logger.log(Level.FINE, \"Starting {0}\", getName());\n        if (isClosed() \u003d\u003d false) {\n            logger.log(Level.WARNING, \"Server {0} already running.\", getName());\n            throw new AppException(\"Server \" + getName() + \" already running.\");\n        }\n        blockingMode \u003d getBasicConfig().getServerMode().getBlocking();\n        if (getSecure().isEnable() \u0026\u0026 blockingMode \u003d\u003d false) {\n            //TODO we need to fix this..\n            logger.warning(\"QuickServer does not support secure servers under non-blocking mode! So will run in blocking mode.\");\n            blockingMode \u003d true;\n            getBasicConfig().getServerMode().setBlocking(blockingMode);\n        }\n        if (serverBanner \u003d\u003d null) {\n            serverBanner \u003d \"\\n-------------------------------\" + \"\\n Name : \" + getName() + \"\\n Port : \" + getPort() + \"\\n-------------------------------\\n\";\n            logger.finest(\"Default Server Banner Generated\");\n        }\n        try {\n            loadApplicationClasses();\n            //load class from Advanced Settings\n            Class clientIdentifierClass \u003d getClass(getBasicConfig().getAdvancedSettings().getClientIdentifier(), true);\n            clientIdentifier \u003d (ClientIdentifier) clientIdentifierClass.newInstance();\n            clientIdentifier.setQuickServer(QuickServer.this);\n            //load class from ObjectPoolConfig\n            Class poolManagerClass \u003d getClass(getBasicConfig().getObjectPoolConfig().getPoolManager(), true);\n            poolManager \u003d (PoolManager) poolManagerClass.newInstance();\n            //load class QSObjectPoolMaker\n            Class qsObjectPoolMakerClass \u003d getClass(getBasicConfig().getAdvancedSettings().getQSObjectPoolMaker(), true);\n            qsObjectPoolMaker \u003d (QSObjectPoolMaker) qsObjectPoolMakerClass.newInstance();\n            loadServerHooksClasses();\n            processServerHooks(ServerHook.PRE_STARTUP);\n            if (getSecure().isLoad() \u003d\u003d true)\n                //v1.4.0\n                loadSSLContext();\n            loadBusinessLogic();\n        } catch (ClassNotFoundException e) {\n            logger.log(Level.SEVERE, \"Could not load class/s: \" + e, e);\n            throw new AppException(\"Could not load class/s : \" + e);\n        } catch (InstantiationException e) {\n            logger.log(Level.SEVERE, \"Could not instantiate class/s: \" + e, e);\n            throw new AppException(\"Could not instantiate class/s: \" + e);\n        } catch (IllegalAccessException e) {\n            logger.log(Level.SEVERE, \"Illegal access to class/s: \" + e, e);\n            throw new AppException(\"Illegal access to class/s: \" + e);\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"IOException: \" + e, e);\n            throw new AppException(\"IOException: \" + e);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Exception: \" + e, e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Exception : \" + e);\n        }\n        //v1.3.3\n        if (getSecurityManagerClass() !\u003d null) {\n            System.setSecurityManager(getSecurityManager());\n        }\n        setServiceState(Service.INIT);\n        t \u003d new Thread(this, \"QuickServer - \" + getName());\n        t.start();\n        do {\n            Thread.yield();\n        } while (getServiceState() \u003d\u003d Service.INIT);\n        if (getServiceState() !\u003d Service.RUNNING) {\n            if (exceptionInRun !\u003d null)\n                throw new AppException(\"Could not start server \" + getName() + \"! Details: \" + exceptionInRun);\n            else\n                throw new AppException(\"Could not start server \" + getName());\n        }\n        lastStartTime \u003d new java.util.Date();\n        logger.log(Level.FINE, \"Started {0}, Date: {1}\", new Object[] { getName(), lastStartTime });\n    }\n\n    /**\n     * Stops the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server\n     * @since 1.1\n     * @see #stopService\n     */\n    public void stopServer() throws AppException {\n        processServerHooks(ServerHook.PRE_SHUTDOWN);\n        logger.log(Level.WARNING, \"Stopping {0}\", getName());\n        stopServer \u003d true;\n        Socket death \u003d null;\n        if (isClosed() \u003d\u003d true) {\n            logger.log(Level.WARNING, \"Server {0} is not running!\", getName());\n            throw new AppException(\"Server \" + getName() + \" is not running!\");\n        }\n        try {\n            if (getBlockingMode() \u003d\u003d true) {\n                if (getSecure().isEnable() \u003d\u003d false) {\n                    death \u003d new Socket(server.getInetAddress(), server.getLocalPort());\n                    death.getInputStream().read();\n                    death.close();\n                } else {\n                    death \u003d getSSLSocketFactory().createSocket(server.getInetAddress(), server.getLocalPort());\n                    Thread.sleep(100);\n                    death.close();\n                }\n            }\n            if (serverSocketChannel !\u003d null) {\n                serverSocketChannel.close();\n            }\n        } catch (IOException e) {\n            logger.log(Level.FINE, \"IOError stopping {0}: {1}\", new Object[] { getName(), e });\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error stopping {0}: {1}\", new Object[] { getName(), e });\n            throw new AppException(\"Error in stopServer \" + getName() + \": \" + e);\n        }\n        for (int i \u003d 0; getServiceState() !\u003d Service.STOPPED; i++) {\n            try {\n                Thread.sleep(60);\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error waiting for {0} to fully stop. Error: {1}\", new Object[] { getName(), e });\n            }\n            if (i \u003e 1000) {\n                logger.severe(\"Server was not stopped even after 10sec.. will terminate now.\");\n                System.exit(-1);\n            }\n        }\n        if (adminServer \u003d\u003d null || getQSAdminServer().getServer() !\u003d this) {\n            //so this is not qsadmin\n            setClassLoader(null);\n        }\n        logger.log(Level.INFO, \"Stopped {0}\", getName());\n    }\n\n    /**\n     * Restarts the QuickServer.\n     *\n     * @exception org.quickserver.net.AppException\n     *  if could not stop server or if it could not start the server.\n     * @since 1.2\n     */\n    public void restartServer() throws AppException {\n        stopServer();\n        startServer();\n    }\n\n    /**\n     * Returns the name of the QuickServer. Default is \u0027QuickServer\u0027.\n     * @see #setName\n     */\n    public String getName() {\n        return serverName;\n    }\n\n    /**\n     * Sets the name for the QuickServer\n     * @param name for the QuickServer\n     * @see #getName\n     */\n    public void setName(String name) {\n        serverName \u003d name;\n        logger.log(Level.FINEST, \"Set to : {0}\", name);\n    }\n\n    /**\n     * Returns the Server Banner of the QuickServer\n     * @see #setServerBanner\n     */\n    public String getServerBanner() {\n        return serverBanner;\n    }\n\n    /**\n     * Sets the serverBanner for the QuickServer\n     * that will be displayed on the standard output [console]\n     * when server starts. \u003cbr\u003e\u0026nbsp;\u003cbr\u003e\n     * To set welcome message to your client\n     * {@link ClientEventHandler#gotConnected}\n     * @param banner for the QuickServer\n     * @see #getServerBanner\n     */\n    public void setServerBanner(String banner) {\n        serverBanner \u003d banner;\n        logger.log(Level.FINEST, \"Set to : {0}\", banner);\n    }\n\n    /**\n     * Sets the port for the QuickServer to listen on.\n     * If not set, it will run on Port 9876\n     * @param port to listen on.\n     * @see #getPort\n     */\n    public void setPort(int port) {\n        if (port \u003c 0) {\n            throw new IllegalArgumentException(\"Port number can not be less than 0!\");\n        }\n        serverPort \u003d port;\n        logger.log(Level.FINEST, \"Set to {0}\", port);\n    }\n\n    /**\n     * Returns the port for the QuickServer.\n     * @see #setPort\n     */\n    public int getPort() {\n        if (isClosed() \u003d\u003d false) {\n            return server.getLocalPort();\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            return serverPort;\n        } else {\n            int _port \u003d getSecure().getPort();\n            if (_port \u003d\u003d -1)\n                return serverPort;\n            else\n                return _port;\n        }\n    }\n\n    /**\n     * Sets the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientCommandHandler}\n     * @see #getClientCommandHandler\n     */\n    public void setClientCommandHandler(String handler) {\n        clientCommandHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientCommandHandler class that interacts with\n     * client sockets.\n     * @see #setClientCommandHandler\n     * @since 1.1\n     */\n    public String getClientCommandHandler() {\n        return clientCommandHandlerString;\n    }\n\n    /**\n     * Sets the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link ClientAuthenticationHandler}.\n     * @see #getClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public void setClientAuthenticationHandler(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the ClientAuthenticationHandler class that\n     * handles the authentication of a client.\n     * @see #setClientAuthenticationHandler\n     * @since 1.4.6\n     */\n    public String getClientAuthenticationHandler() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the Authenticator class that\n     * handles the authentication of a client.\n     * @param authenticator the fully qualified name of the class\n     * that implements {@link Authenticator} or {@link ClientAuthenticationHandler}.\n     * @see #getAuthenticator\n     * @deprecated since 1.4.6 use setClientAuthenticationHandler\n     * @since 1.3\n     */\n    public void setAuthenticator(String authenticator) {\n        clientAuthenticationHandlerString \u003d authenticator;\n        logger.log(Level.FINEST, \"Set to {0}\", authenticator);\n    }\n\n    /**\n     * Returns the Authenticator class that\n     * handles the authentication of a client.\n     * @see #setAuthenticator\n     * @deprecated since 1.4.6 use getClientAuthenticationHandler\n     * @since 1.3\n     */\n    public String getAuthenticator() {\n        return clientAuthenticationHandlerString;\n    }\n\n    /**\n     * Sets the ClientData class that carries client data.\n     * @param data the fully qualified name of the class that\n     * extends {@link ClientData}.\n     * @see #getClientData\n     */\n    public void setClientData(String data) {\n        this.clientDataString \u003d data;\n        logger.log(Level.FINEST, \"Set to {0}\", data);\n    }\n\n    /**\n     * Returns the ClientData class string that carries client data\n     * @return the fully qualified name of the class that\n     * implements {@link ClientData}.\n     * @see #setClientData\n     */\n    public String getClientData() {\n        return clientDataString;\n    }\n\n    /**\n     * Sets the client socket\u0027s timeout.\n     * @param time client socket timeout in milliseconds.\n     * @see #getTimeout\n     */\n    public void setTimeout(int time) {\n        if (time \u003e 0)\n            socketTimeout \u003d time;\n        else\n            socketTimeout \u003d 0;\n        logger.log(Level.FINEST, \"Set to {0}\", socketTimeout);\n    }\n\n    /**\n     * Returns the Client socket timeout in milliseconds.\n     * @see #setTimeout\n     */\n    public int getTimeout() {\n        return socketTimeout;\n    }\n\n    /**\n     * Sets max allowed login attempts.\n     * @since 1.2\n     * @see #getMaxAuthTry\n     */\n    public void setMaxAuthTry(int authTry) {\n        maxAuthTry \u003d authTry;\n        logger.log(Level.FINEST, \"Set to {0}\", authTry);\n    }\n\n    /**\n     * Returns max allowed login attempts. Default is \u003ccode\u003e5\u003c/code\u003e.\n     * @since 1.2\n     * @see #setMaxAuthTry\n     */\n    public int getMaxAuthTry() {\n        return maxAuthTry;\n    }\n\n    /**\n     * Sets message to be displayed when maximum allowed login\n     * attempts has reached.\n     * Default is : -ERR Max Auth Try Reached\n     * @see #getMaxAuthTryMsg\n     */\n    public void setMaxAuthTryMsg(String msg) {\n        maxAuthTryMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns message to be displayed when maximum allowed login\n     * attempts has reached.\n     * @see #getMaxAuthTryMsg\n     */\n    public String getMaxAuthTryMsg() {\n        return maxAuthTryMsg;\n    }\n\n    /**\n     * Sets timeout message.\n     * Default is : -ERR Timeout\n     * @see #getTimeoutMsg\n     */\n    public void setTimeoutMsg(String msg) {\n        timeoutMsg \u003d msg;\n        logger.log(Level.FINEST, \"Set to {0}\", msg);\n    }\n\n    /**\n     * Returns timeout message.\n     * @see #setTimeoutMsg\n     */\n    public String getTimeoutMsg() {\n        return timeoutMsg;\n    }\n\n    private TheClient initTheClient() {\n        TheClient theClient \u003d new TheClient();\n        theClient.setServer(QuickServer.this);\n        theClient.setTimeoutMsg(getTimeoutMsg());\n        //v1.2\n        theClient.setMaxAuthTry(getMaxAuthTry());\n        theClient.setMaxAuthTryMsg(getMaxAuthTryMsg());\n        theClient.setClientEventHandler(clientEventHandler);\n        //v1.4.6\n        theClient.setClientExtendedEventHandler(clientExtendedEventHandler);\n        theClient.setClientCommandHandler(clientCommandHandler);\n        //v1.2\n        theClient.setClientObjectHandler(clientObjectHandler);\n        //v1.4\n        theClient.setClientBinaryHandler(clientBinaryHandler);\n        //v1.4.5\n        theClient.setClientWriteHandler(clientWriteHandler);\n        //v1.3\n        theClient.setAuthenticator(authenticator);\n        //v1.4.6\n        theClient.setClientAuthenticationHandler(clientAuthenticationHandler);\n        theClient.setTimeout(socketTimeout);\n        theClient.setMaxConnectionMsg(maxConnectionMsg);\n        //v1.3.2\n        theClient.setCommunicationLogging(getCommunicationLogging());\n        return theClient;\n    }\n\n    public void run() {\n        exceptionInRun \u003d null;\n        TheClient theClient \u003d initTheClient();\n        try {\n            stopServer \u003d false;\n            closeAllPools();\n            initAllPools();\n            makeServerSocket();\n            //print banner\n            System.out.println(serverBanner);\n            //v1.2\n            setServiceState(Service.RUNNING);\n            //v1.3.3\n            processServerHooks(ServerHook.POST_STARTUP);\n            if (getBlockingMode() \u003d\u003d false) {\n                runNonBlocking(theClient);\n                if (stopServer \u003d\u003d true) {\n                    logger.log(Level.FINEST, \"Closing selector for {0}\", getName());\n                    selector.close();\n                }\n                return;\n            } else {\n                runBlocking(theClient);\n            }\n        } catch (BindException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"{0} BindException for Port {1} @ {2} : {3}\", new Object[] { getName(), getPort(), getBindAddr().getHostAddress(), e.getMessage() });\n        } catch (javax.net.ssl.SSLException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"SSLException {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (IOException e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"IOError {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } catch (Exception e) {\n            exceptionInRun \u003d e;\n            logger.log(Level.SEVERE, \"Error {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n        } finally {\n            if (getBlockingMode() \u003d\u003d true) {\n                logger.log(Level.WARNING, \"Closing {0}\", getName());\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            } else if (getBlockingMode() \u003d\u003d false \u0026\u0026 exceptionInRun !\u003d null) {\n                logger.log(Level.WARNING, \"Closing {0} - Had Error: {1}\", new Object[] { getName(), exceptionInRun });\n                try {\n                    if (isClosed() \u003d\u003d false) {\n                        if (serverSocketChannel !\u003d null)\n                            serverSocketChannel.close();\n                        if (server !\u003d null)\n                            server.close();\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.log(Level.WARNING, \"Closed {0}\", getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n        }\n    }\n\n    //end of run\n    /**\n     * Sets the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #getMaxConnection\n     */\n    public void setMaxConnection(long maxConnection) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnection \u003d maxConnection;\n        else\n            this.maxConnection \u003d maxConnection;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnection);\n    }\n\n    /**\n     * Returns the maximum number of client connection allowed.\n     * @since 1.1\n     * @see #setMaxConnection\n     */\n    public long getMaxConnection() {\n        return maxConnection;\n    }\n\n    /**\n     * Returns number of clients connected.\n     * @since 1.1\n     */\n    public long getClientCount() {\n        if (clientHandlerPool !\u003d null) {\n            try {\n                return getClientHandlerPool().getNumActive();\n            } catch (Exception e) {\n                return 0;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Sets the message to be sent to any new client connected after\n     * maximum client connection has reached.\n     * Default is : \u003ccode\u003e-ERR Server Busy. Max Connection Reached\u003c/code\u003e\n     * @since 1.1\n     * @see #getMaxConnectionMsg\n     */\n    public void setMaxConnectionMsg(String maxConnectionMsg) {\n        if (getServiceState() \u003d\u003d Service.SUSPENDED)\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n        else\n            this.maxConnectionMsg \u003d maxConnectionMsg;\n        logger.log(Level.FINEST, \"Set to {0}\", maxConnectionMsg);\n    }\n\n    /**\n     * Returns the message to be sent to any new client connected\n     * after maximum client connection has reached.\n     * @since 1.1\n     * @see #setMaxConnectionMsg\n     */\n    public String getMaxConnectionMsg() {\n        return maxConnectionMsg;\n    }\n\n    /**\n     * Sets the Ip address to bind to.\n     * @param bindAddr argument can be used on a multi-homed host for a\n     * QuickServer that will only accept connect requests to one\n     * of its addresses. If not set, it will default accepting\n     * connections on any/all local addresses.\n     * @exception java.net.UnknownHostException if no IP address for\n     * the host could be found\n     * @since 1.1\n     * @see #getBindAddr\n     */\n    public void setBindAddr(String bindAddr) throws UnknownHostException {\n        ipAddr \u003d InetAddress.getByName(bindAddr);\n        logger.log(Level.FINEST, \"Set to {0}\", bindAddr);\n    }\n\n    /**\n     * Returns the IP address binding to.\n     * @since 1.1\n     * @see #setBindAddr\n     */\n    public InetAddress getBindAddr() {\n        if (ipAddr \u003d\u003d null) {\n            try {\n                ipAddr \u003d InetAddress.getByName(\"0.0.0.0\");\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Unable to create default ip(0.0.0.0) : {0}\", e);\n                throw new RuntimeException(\"Error: Unable to find servers own ip : \" + e);\n            }\n        }\n        return ipAddr;\n    }\n\n    /**\n     * Sets the store of objects to QuickServer, it is an array of objects\n     * that main program or the class that created QuickServer passes to\n     * the QuickServer.\n     * @param storeObjects array of objects\n     * @see #getStoreObjects\n     * @since 1.1\n     */\n    public void setStoreObjects(Object[] storeObjects) {\n        this.storeObjects \u003d storeObjects;\n    }\n\n    /**\n     * Returns store of objects from QuickServer, if nothing was set will\n     * return \u003ccode\u003enull\u003c/code\u003e.\n     * @see #setStoreObjects\n     * @since 1.1\n     */\n    public Object[] getStoreObjects() {\n        return storeObjects;\n    }\n\n    /**\n     * Set the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public void setQSAdminServerPort(int port) {\n        getQSAdminServer().getServer().setPort(port);\n    }\n\n    /**\n     * Returns the port to run QSAdminServer on.\n     * @since 1.2\n     */\n    public int getQSAdminServerPort() {\n        return getQSAdminServer().getServer().getPort();\n    }\n\n    /**\n     * Set the ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public void setQSAdminServerAuthenticator(String authenticator) {\n        getQSAdminServer().getServer().setClientAuthenticationHandler(authenticator);\n    }\n\n    /**\n     * Returns the Authenticator or ClientAuthenticationHandler class of\n     * QSAdminServer that handles the authentication of a client.\n     * @since 1.2\n     */\n    public String getQSAdminServerAuthenticator() {\n        return getQSAdminServer().getServer().getAuthenticator();\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @param authenticator sets the ClientAuthenticationHandler class that\n     *   handles the authentication of a client,\n     *   if null uses {@link org.quickserver.net.qsadmin.Authenticator}.\n     * @param port to run QSAdminServer on\n     * @exception org.quickserver.net.AppException\n     *  if Server already running or if it could not load the classes\n     *  [ClientCommandHandler, ClientAuthenticationHandler, ClientData].\n     * @since 1.1\n     */\n    public void startQSAdminServer(int port, String authenticator) throws AppException {\n        getQSAdminServer().setClientAuthenticationHandler(authenticator);\n        getQSAdminServer().startServer(port);\n    }\n\n    /**\n     * Starts QSAdminServer for this QuickServer.\n     * @see org.quickserver.net.qsadmin.QSAdminServer\n     * @since 1.2\n     */\n    public void startQSAdminServer() throws AppException {\n        getQSAdminServer().startServer();\n    }\n\n    /**\n     * Returns {@link QSAdminServer} associated with this QuickServer\n     * @since 1.1\n     */\n    public QSAdminServer getQSAdminServer() {\n        if (adminServer \u003d\u003d null)\n            adminServer \u003d new QSAdminServer(QuickServer.this);\n        return adminServer;\n    }\n\n    /**\n     * Sets {@link QSAdminServer} associated with this QuickServer\n     * @since 1.3.3\n     */\n    public void setQSAdminServer(QSAdminServer adminServer) {\n        if (adminServer \u003d\u003d null)\n            this.adminServer \u003d adminServer;\n    }\n\n    /**\n     * Returns the closed state of the QuickServer Socket.\n     * @since 1.1\n     */\n    public boolean isClosed() {\n        if (server \u003d\u003d null)\n            return true;\n        return server.isClosed();\n    }\n\n    /**\n     * Returns the application logger associated with QuickServer.\n     * If it was not set will return QuickServer\u0027s own logger.\n     * @since 1.2\n     */\n    public Logger getAppLogger() {\n        if (appLogger !\u003d null)\n            return appLogger;\n        return logger;\n    }\n\n    /**\n     * Sets the application logger associated with QuickServer\n     * @since 1.2\n     */\n    public void setAppLogger(Logger appLogger) {\n        this.appLogger \u003d appLogger;\n    }\n\n    /**\n     * Sets the ClientObjectHandler class that interacts with\n     * client sockets to handle java objects.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientObjectHandler}\n     * @see #getClientObjectHandler\n     * @since 1.2\n     */\n    public void setClientObjectHandler(String handler) {\n        clientObjectHandlerString \u003d handler;\n        logger.log(Level.FINEST, \"Set to {0}\", handler);\n    }\n\n    /**\n     * Returns the ClientObjectHandler class that interacts with\n     * client sockets.\n     * @see #setClientObjectHandler\n     * @since 1.2\n     */\n    public String getClientObjectHandler() {\n        return clientObjectHandlerString;\n    }\n\n    /**\n     * Sets the console log handler formatter.\n     * @param formatter fully qualified name of the class that implements\n     * {@link java.util.logging.Formatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingFormatter(String formatter) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n        if (formatter \u003d\u003d null)\n            return;\n        consoleLoggingformatter \u003d formatter;\n        java.util.logging.Formatter conformatter \u003d (java.util.logging.Formatter) getClass(formatter, true).newInstance();\n        Logger jdkLogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d jdkLogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                handlers[index].setFormatter(conformatter);\n            }\n        }\n        logger.log(Level.FINEST, \"Set to {0}\", formatter);\n    }\n\n    /**\n     * Gets the console log handler formatter.\n     * @since 1.3\n     */\n    public String getConsoleLoggingFormatter() {\n        return consoleLoggingformatter;\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MiniFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMini() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MiniFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to logging.MiniFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler formater to\n     * {@link org.quickserver.util.logging.MicroFormatter}\n     * @since 1.2\n     */\n    public void setConsoleLoggingToMicro() {\n        try {\n            setConsoleLoggingFormatter(\"org.quickserver.util.logging.MicroFormatter\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Setting to MicroFormatter : {0}\", e);\n        }\n    }\n\n    /**\n     * Sets the console log handler level.\n     * @since 1.2\n     */\n    public void setConsoleLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        boolean isConsole \u003d true;\n        try {\n            if (System.console() \u003d\u003d null) {\n                isConsole \u003d false;\n            }\n        } catch (Throwable e) {\n            //ignore\n        }\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            if (ConsoleHandler.class.isInstance(handlers[index])) {\n                if (isConsole \u003d\u003d false \u0026\u0026 level !\u003d Level.OFF) {\n                    System.out.println(\"QuickServer: You do not have a console.. so turning console logger off..\");\n                    level \u003d Level.OFF;\n                }\n                if (level \u003d\u003d Level.OFF) {\n                    logger.info(\"QuickServer: Removing console handler.. \");\n                    rlogger.removeHandler(handlers[index]);\n                    handlers[index].setLevel(level);\n                    handlers[index].close();\n                } else {\n                    handlers[index].setLevel(level);\n                }\n            }\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            consoleLoggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            consoleLoggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            consoleLoggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            consoleLoggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            consoleLoggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            consoleLoggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            consoleLoggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            consoleLoggingLevel \u003d \"OFF\";\n        else\n            consoleLoggingLevel \u003d \"UNKNOWN\";\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    /**\n     * Gets the console log handler level.\n     * @since 1.3\n     */\n    public String getConsoleLoggingLevel() {\n        return consoleLoggingLevel;\n    }\n\n    /**\n     * Sets the level for all log handlers.\n     * @since 1.3.1\n     */\n    public void setLoggingLevel(Level level) {\n        Logger rlogger \u003d Logger.getLogger(\"\");\n        Handler[] handlers \u003d rlogger.getHandlers();\n        for (int index \u003d 0; index \u003c handlers.length; index++) {\n            handlers[index].setLevel(level);\n        }\n        if (level \u003d\u003d Level.SEVERE)\n            loggingLevel \u003d \"SEVERE\";\n        else if (level \u003d\u003d Level.WARNING)\n            loggingLevel \u003d \"WARNING\";\n        else if (level \u003d\u003d Level.INFO)\n            loggingLevel \u003d \"INFO\";\n        else if (level \u003d\u003d Level.CONFIG)\n            loggingLevel \u003d \"CONFIG\";\n        else if (level \u003d\u003d Level.FINE)\n            loggingLevel \u003d \"FINE\";\n        else if (level \u003d\u003d Level.FINER)\n            loggingLevel \u003d \"FINER\";\n        else if (level \u003d\u003d Level.FINEST)\n            loggingLevel \u003d \"FINEST\";\n        else if (level \u003d\u003d Level.OFF)\n            loggingLevel \u003d \"OFF\";\n        else\n            loggingLevel \u003d \"UNKNOWN\";\n        consoleLoggingLevel \u003d loggingLevel;\n        logger.log(Level.FINE, \"Set to {0}\", level);\n    }\n\n    //*** Start of Service interface methods\n    /**\n     * Returns service error if any.\n     * @since 1.4.7\n     */\n    public Throwable getServiceError() {\n        return serviceError;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param param of the xml configuration file.\n     * @since 1.2\n     */\n    public synchronized boolean initService(Object[] param) {\n        serviceError \u003d null;\n        try {\n            initServer(param);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.6\n     */\n    public synchronized boolean initService(QuickServerConfig qsConfig) {\n        serviceError \u003d null;\n        try {\n            initServer(qsConfig);\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Start the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean startService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING)\n            return false;\n        try {\n            startServer();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Stop the service.\n     * @return true if serivce was stopped from Running state.\n     * @since 1.2\n     */\n    public boolean stopService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.STOPPED)\n            return false;\n        try {\n            stopServer();\n            clearAllPools();\n        } catch (AppException e) {\n            serviceError \u003d e;\n            return false;\n        } catch (Exception e) {\n            serviceError \u003d e;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Suspends the service.\n     * @return true if service was suspended from resumed state.\n     * @since 1.2\n     */\n    public boolean suspendService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.RUNNING) {\n            suspendMaxConnection \u003d maxConnection;\n            suspendMaxConnectionMsg \u003d maxConnectionMsg;\n            maxConnection \u003d 0;\n            maxConnectionMsg \u003d \"Service is suspended.\";\n            setServiceState(Service.SUSPENDED);\n            logger.log(Level.INFO, \"Service {0} is suspended.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Resume the service.\n     * @return true if service was resumed from suspended state.\n     * @since 1.2\n     */\n    public boolean resumeService() {\n        serviceError \u003d null;\n        if (getServiceState() \u003d\u003d Service.SUSPENDED) {\n            maxConnection \u003d suspendMaxConnection;\n            maxConnectionMsg \u003d suspendMaxConnectionMsg;\n            setServiceState(Service.RUNNING);\n            logger.log(Level.INFO, \"Service {0} resumed.\", getName());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Information about the service.\n     * @since 1.2\n     */\n    public String info() {\n        serviceError \u003d null;\n        StringBuilder buf \u003d new StringBuilder();\n        buf.append(getName()).append(\"\\n\");\n        buf.append(getBindAddr().getHostAddress()).append(\" \");\n        buf.append(getPort()).append(\"\\n\");\n        return buf.toString();\n    }\n\n    // *** End of Service interface methods\n    /**\n     * Initialise and create the server.\n     * @param param of the xml configuration file.\n     * @exception AppException if QuickServerConfig creation failed from the xml config file.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(Object[] param) throws AppException {\n        QuickServerConfig qsConfig \u003d null;\n        try {\n            qsConfig \u003d ConfigReader.read((String) param[0]);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not init server from xml file {0} : {1}\", new Object[] { new File((String) param[0]).getAbsolutePath(), e });\n            throw new AppException(\"Could not init server from xml file\", e);\n        }\n        initServer(qsConfig);\n    }\n\n    /**\n     * Initialise and create the service.\n     * @param qsConfig QuickServerConfig object.\n     * @since 1.4.7\n     */\n    public synchronized void initServer(QuickServerConfig qsConfig) throws AppException {\n        setConfig(qsConfig);\n        try {\n            configQuickServer();\n            loadApplicationClasses();\n            //start InitServerHooks\n            InitServerHooks ish \u003d getConfig().getInitServerHooks();\n            if (ish !\u003d null) {\n                Iterator iterator \u003d ish.iterator();\n                String initServerHookClassName \u003d null;\n                Class initServerHookClass \u003d null;\n                InitServerHook initServerHook \u003d null;\n                while (iterator.hasNext()) {\n                    initServerHookClassName \u003d (String) iterator.next();\n                    initServerHookClass \u003d getClass(initServerHookClassName, true);\n                    initServerHook \u003d (InitServerHook) initServerHookClass.newInstance();\n                    logger.log(Level.INFO, \"Loaded init server hook: {0}\", initServerHookClassName);\n                    logger.log(Level.FINE, \"Init server hook info: {0}\", initServerHook.info());\n                    initServerHook.handleInit(QuickServer.this);\n                }\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not load init server hook: {0}\", e);\n            logger.log(Level.WARNING, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw new AppException(\"Could not load init server hook\", e);\n        }\n        setServiceState(Service.INIT);\n        logger.log(Level.FINEST, \"\\r\\n{0}\", MyString.getSystemInfo(getVersion()));\n    }\n\n    /**\n     * Returns the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public int getServiceState() {\n        return serviceState;\n    }\n\n    /**\n     * Sets the state of the process\n     * As any constant of {@link Service} interface.\n     * @since 1.2\n     */\n    public void setServiceState(int state) {\n        serviceState \u003d state;\n    }\n\n    private void configConsoleLoggingLevel(QuickServer qs, String temp) {\n        if (temp.equals(\"SEVERE\"))\n            qs.setConsoleLoggingLevel(Level.SEVERE);\n        else if (temp.equals(\"WARNING\"))\n            qs.setConsoleLoggingLevel(Level.WARNING);\n        else if (temp.equals(\"INFO\"))\n            qs.setConsoleLoggingLevel(Level.INFO);\n        else if (temp.equals(\"CONFIG\"))\n            qs.setConsoleLoggingLevel(Level.CONFIG);\n        else if (temp.equals(\"FINE\"))\n            qs.setConsoleLoggingLevel(Level.FINE);\n        else if (temp.equals(\"FINER\"))\n            qs.setConsoleLoggingLevel(Level.FINER);\n        else if (temp.equals(\"FINEST\"))\n            qs.setConsoleLoggingLevel(Level.FINEST);\n        else if (temp.equals(\"OFF\"))\n            qs.setConsoleLoggingLevel(Level.OFF);\n        else\n            logger.log(Level.WARNING, \"unknown level {0}\", temp);\n    }\n\n    /**\n     * Configures QuickServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QuickServerConfig config) throws Exception {\n        QuickServer qs \u003d QuickServer.this;\n        //v1.3\n        qs.setConfig(config);\n        qs.setBasicConfig(config);\n        String temp \u003d config.getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        temp \u003d null;\n        qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        //v1.3.3\n        qs.setSecurityManagerClass(config.getSecurityManagerClass());\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        temp \u003d config.getApplicationJarPath();\n        if (temp !\u003d null) {\n            File ajp \u003d new File(temp);\n            if (ajp.isAbsolute() \u003d\u003d false) {\n                temp \u003d config.getConfigFile();\n                ajp \u003d new File(temp);\n                temp \u003d ajp.getParent() + File.separatorChar + config.getApplicationJarPath();\n                config.setApplicationJarPath(temp);\n                temp \u003d null;\n            }\n            qs.setApplicationJarPath(config.getApplicationJarPath());\n            //set path also to QSAdmin\n            if (config.getQSAdminServerConfig() !\u003d null) {\n                getQSAdminServer().getServer().setApplicationJarPath(config.getApplicationJarPath());\n            }\n        }\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer based on the passed QuickServerConfig object.\n     * @since 1.2\n     */\n    public void configQuickServer(QSAdminServerConfig config) throws Exception {\n        QuickServer qs \u003d getQSAdminServer().getServer();\n        qs.setBasicConfig(config);\n        //set the Logging Level to same as main QS\n        //config.getConsoleLoggingLevel();\n        String temp \u003d getConsoleLoggingLevel();\n        configConsoleLoggingLevel(qs, temp);\n        //set the Logging Formatter to same as main QS\n        //qs.setConsoleLoggingFormatter(config.getConsoleLoggingFormatter());\n        qs.setConsoleLoggingFormatter(getConsoleLoggingFormatter());\n        //v1.4.6\n        qs.setClientEventHandler(config.getClientEventHandler());\n        qs.setClientCommandHandler(config.getClientCommandHandler());\n        qs.setName(config.getName());\n        qs.setPort(config.getPort());\n        if (config.getAuthenticator() !\u003d null)\n            //v1.3\n            qs.setAuthenticator(config.getAuthenticator());\n        else if (config.getClientAuthenticationHandler() !\u003d null)\n            //v1.4.6\n            qs.setClientAuthenticationHandler(config.getClientAuthenticationHandler());\n        qs.setClientObjectHandler(config.getClientObjectHandler());\n        //v1.4\n        qs.setClientBinaryHandler(config.getClientBinaryHandler());\n        //v1.4.5\n        qs.setClientWriteHandler(config.getClientWriteHandler());\n        qs.setClientData(config.getClientData());\n        //v1.4.6\n        qs.setClientExtendedEventHandler(config.getClientExtendedEventHandler());\n        //v1.4.6\n        qs.setDefaultDataMode(config.getDefaultDataMode());\n        qs.setServerBanner(config.getServerBanner());\n        qs.setTimeout(config.getTimeout());\n        qs.setMaxAuthTry(config.getMaxAuthTry());\n        qs.setMaxAuthTryMsg(config.getMaxAuthTryMsg());\n        qs.setTimeoutMsg(config.getTimeoutMsg());\n        qs.setMaxConnection(config.getMaxConnection());\n        qs.setMaxConnectionMsg(config.getMaxConnectionMsg());\n        qs.setBindAddr(config.getBindAddr());\n        //v1.3.2\n        qs.setCommunicationLogging(config.getCommunicationLogging());\n        getQSAdminServer().setCommandPlugin(config.getCommandPlugin());\n        //v1.3.2\n        if (config.getCommandShellEnable().equals(\"true\"))\n            getQSAdminServer().setShellEnable(true);\n        getQSAdminServer().setPromptName(config.getCommandShellPromptName());\n        //v1.3.3\n        qs.setAccessConstraintConfig(config.getAccessConstraintConfig());\n        qs.setServerHooks(config.getServerHooks());\n        qs.setSecure(config.getSecure());\n    }\n\n    /**\n     * Configures QSAdminServer and QuickServer based on the\n     * internal QuickServerConfig object.\n     * @since 1.3\n     */\n    public void configQuickServer() throws Exception {\n        configQuickServer(getConfig());\n        if (getConfig().getQSAdminServerConfig() !\u003d null) {\n            configQuickServer(getConfig().getQSAdminServerConfig());\n        }\n    }\n\n    /**\n     * Usage: QuickServer [-options]\u003cbr/\u003e\n     * Where options include:\u003cbr/\u003e\n     *   -about\t\tOpens About Dialogbox\u003cbr/\u003e\n     *   -load \u003cxml_config_file\u003e [options]\tLoads the server from xml file.\n     * where options include:\n     *    -fullXML2File \u003cnew_file_name\u003e\n     */\n    public static void main(String[] args) {\n        try {\n            if (args.length \u003e\u003d 1) {\n                if (args[0].equals(\"-about\")) {\n                    org.quickserver.net.server.gui.About.main(null);\n                } else if (args[0].equals(\"-load\") \u0026\u0026 args.length \u003e\u003d 2) {\n                    QuickServer qs \u003d QuickServer.load(args[1]);\n                    if (qs !\u003d null)\n                        handleOptions(args, qs);\n                } else {\n                    System.out.println(printUsage());\n                }\n            } else {\n                System.out.println(printUsage());\n                org.quickserver.net.server.gui.About.showAbout();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Loads the server from the xml file name passed.\n     * @since 1.4.7\n     */\n    public static QuickServer load(String xml) throws AppException {\n        QuickServer qs \u003d new QuickServer();\n        Object[] config \u003d new Object[] { xml };\n        qs.initServer(config);\n        qs.startServer();\n        if (qs.getConfig().getQSAdminServerConfig() !\u003d null) {\n            qs.startQSAdminServer();\n        }\n        return qs;\n    }\n\n    /**\n     * Prints usage\n     */\n    private static String printUsage() {\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"QuickServer - Java library/framework for creating robust multi-client TCP servers.\\n\");\n        sb.append(\"Copyright (C) QuickServer.org\\n\\n\");\n        sb.append(\"Usage: QuickServer [-options]\\n\");\n        sb.append(\"Where options include:\\n\");\n        sb.append(\"  -about\\t\" + \"Opens About Dialog box\\n\");\n        sb.append(\"  -load \u003cxml_config_file\u003e [load-options]\\t\" + \"Loads the server from xml file.\\n\");\n        sb.append(\"  Where load-options include:\\n\");\n        sb.append(\"     -fullXML2File \u003cfile_name\u003e\\t\" + \"Dumps the Full XML configuration of the QuickServer loaded.\\n\");\n        return sb.toString();\n    }\n\n    private static void handleOptions(String[] args, QuickServer quickserver) {\n        if (args.length \u003c 3)\n            return;\n        if (args[2].equals(\"-fullXML2File\") \u0026\u0026 args.length \u003e\u003d 4) {\n            File file \u003d new File(args[3]);\n            logger.log(Level.INFO, \"Writing full xml configuration to file: {0}\", file.getAbsolutePath());\n            try {\n                TextFile.write(file, quickserver.getConfig().toXML(null));\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error writing full xml configuration: {0}\", e);\n            }\n        }\n    }\n\n    /**\n     * Cleans all Object and Thread pools\n     * @since 1.3\n     */\n    public void clearAllPools() throws Exception {\n        try {\n            if (pool !\u003d null)\n                getClientPool().clear();\n            if (clientHandlerPool !\u003d null)\n                getClientHandlerPool().clear();\n            if (getClientDataPool() !\u003d null)\n                getClientDataPool().clear();\n            if (getDBPoolUtil() !\u003d null)\n                getDBPoolUtil().clean();\n            if (byteBufferPool !\u003d null)\n                getByteBufferPool().clear();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error: {0}\", e);\n            throw e;\n        }\n    }\n\n    /**\n     * Closes all Object and Thread pools\n     * @since 1.3\n     */\n    public void closeAllPools() throws Exception {\n        if (pool \u003d\u003d null \u0026\u0026 clientHandlerPool \u003d\u003d null \u0026\u0026 getClientDataPool() \u003d\u003d null \u0026\u0026 getDBPoolUtil() \u003d\u003d null \u0026\u0026 byteBufferPool \u003d\u003d null) {\n            return;\n        }\n        logger.log(Level.FINE, \"Closing pools for {0}\", getName());\n        try {\n            if (pool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientPool().getObjectPool())) {\n                logger.finer(\"Closing ClientThread pool.\");\n                getClientPool().close();\n            }\n            if (clientHandlerPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientHandlerPool())) {\n                logger.finer(\"Closing ClientHandler pool.\");\n                getClientHandlerPool().close();\n            }\n            if (getClientDataPool() !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getClientDataPool())) {\n                logger.finer(\"Closing ClientData pool.\");\n                getClientDataPool().close();\n            }\n            if (getDBPoolUtil() !\u003d null) {\n                logger.finer(\"Closing DB pool.\");\n                getDBPoolUtil().clean();\n            }\n            if (byteBufferPool !\u003d null \u0026\u0026 PoolHelper.isPoolOpen(getByteBufferPool())) {\n                logger.finer(\"Closing ByteBuffer pool.\");\n                getByteBufferPool().close();\n            }\n            logger.log(Level.FINE, \"Closed pools for {0}\", getName());\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error closing pools for {0}: {1}\", new Object[] { getName(), e });\n            throw e;\n        }\n    }\n\n    /**\n     * Initialise all Object and Thread pools.\n     * @since 1.3\n     */\n    public void initAllPools() throws Exception {\n        logger.fine(\"Creating pools\");\n        if (getBlockingMode() \u003d\u003d false) {\n            makeByteBufferPool(getBasicConfig().getObjectPoolConfig().getByteBufferObjectPoolConfig());\n        }\n        makeClientPool(getBasicConfig().getObjectPoolConfig().getThreadObjectPoolConfig());\n        makeClientHandlerPool(getBasicConfig().getObjectPoolConfig().getClientHandlerObjectPoolConfig());\n        //check if client data is poolable\n        if (clientDataClass !\u003d null) {\n            try {\n                clientData \u003d (ClientData) clientDataClass.newInstance();\n                if (PoolableObject.class.isInstance(clientData) \u003d\u003d true) {\n                    PoolableObject po \u003d (PoolableObject) clientData;\n                    if (po.isPoolable() \u003d\u003d true) {\n                        makeClientDataPool(po.getPoolableObjectFactory(), getBasicConfig().getObjectPoolConfig().getClientDataObjectPoolConfig());\n                    } else {\n                        clientDataPool \u003d null;\n                        logger.fine(\"ClientData is not poolable!\");\n                    }\n                }\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error: {0}\", e);\n                throw e;\n            }\n        }\n        try {\n            makeDBObjectPool();\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error in makeDBObjectPool() : {0}\", e);\n            logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            throw e;\n        }\n        logger.fine(\"Created pools\");\n    }\n\n    /**\n     * Returns {@link org.quickserver.util.pool.thread.ClientPool} class that\n     * managing the pool of threads for handling clients.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ClientPool getClientPool() {\n        if (pool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientPool available yet!\");\n        return pool;\n    }\n\n    /**\n     * Makes the pool of ClientHandler\n     * @since 1.3\n     */\n    private void makeClientHandlerPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientHandler pool\");\n        PoolableObjectFactory factory \u003d new ClientHandlerObjectFactory(getBlockingMode());\n        clientHandlerPool \u003d poolManager.makeClientHandlerPool(factory, opConfig);\n        poolManager.initPool(clientHandlerPool, opConfig);\n        clientHandlerPool \u003d makeQSObjectPool(clientHandlerPool);\n        clientIdentifier.setClientHandlerPool((QSObjectPool) clientHandlerPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientHandler}\n     * class.\n     * @exception IllegalStateException if pool is not created yet.\n     * @since 1.3\n     */\n    public ObjectPool getClientHandlerPool() {\n        if (clientHandlerPool \u003d\u003d null)\n            throw new IllegalStateException(\"No ClientHandler Pool available yet!\");\n        return clientHandlerPool;\n    }\n\n    /**\n     * Sets the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public void setConfig(QuickServerConfig config) {\n        this.config \u003d config;\n    }\n\n    /**\n     * Returns the configuration of the QuickServer.\n     * @since 1.3\n     */\n    public QuickServerConfig getConfig() {\n        return config;\n    }\n\n    /**\n     * Makes the pool of ClientData\n     * @since 1.3\n     */\n    private void makeClientDataPool(PoolableObjectFactory factory, PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientData pool\");\n        clientDataPool \u003d poolManager.makeClientDataPool(factory, opConfig);\n        poolManager.initPool(clientDataPool, opConfig);\n        clientDataPool \u003d makeQSObjectPool(clientDataPool);\n    }\n\n    /**\n     * Returns ObjectPool of {@link org.quickserver.net.server.ClientData}\n     * class. If ClientData was not poolable will return  null.\n     * @since 1.3\n     */\n    public ObjectPool getClientDataPool() {\n        return clientDataPool;\n    }\n\n    /**\n     * Returns {@link org.quickserver.sql.DBPoolUtil} object if\n     * {@link org.quickserver.util.xmlreader.DBObjectPoolConfig} was set.\n     * @return DBPoolUtil object if object could be loaded, else will return \u003ccode\u003enull\u003c/code\u003e\n     * @since 1.3\n     */\n    public DBPoolUtil getDBPoolUtil() {\n        return dBPoolUtil;\n    }\n\n    /**\n     * Sets {@link org.quickserver.util.xmlreader.DBObjectPoolConfig}\n     * @since 1.3\n     */\n    public void setDBObjectPoolConfig(DBObjectPoolConfig dBObjectPoolConfig) {\n        getConfig().setDBObjectPoolConfig(dBObjectPoolConfig);\n    }\n\n    /**\n     * Makes the pool of Database Objects\n     * @since 1.3\n     */\n    private void makeDBObjectPool() throws Exception {\n        if (getConfig().getDBObjectPoolConfig() !\u003d null) {\n            logger.fine(\"Creating DBObject Pool\");\n            //logger.finest(\"Got:\\n\"+getConfig().getDBObjectPoolConfig().toXML(null));\n            Class dbPoolUtilClass \u003d getClass(getConfig().getDBObjectPoolConfig().getDbPoolUtil(), true);\n            dBPoolUtil \u003d (DBPoolUtil) dbPoolUtilClass.newInstance();\n            dBPoolUtil.setDatabaseConnections(getConfig().getDBObjectPoolConfig().getDatabaseConnectionSet().iterator());\n            dBPoolUtil.initPool();\n        }\n    }\n\n    /**\n     *  Tries to find the Client by the Id passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same clinet has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findFirstClientById(String id) {\n        return clientIdentifier.findFirstClientById(id);\n    }\n\n    /**\n     *  Returns an iterator containing all the\n     *  {@link org.quickserver.net.server.ClientHandler} that\n     *  are currently handling clients.\n     *  It is recommended not to change the collection under an iterator.\n     *\n     *  It is imperative that the user manually synchronize on the returned collection\n     *  when iterating over it:\n     *  \u003ccode\u003e\u003cpre\u003e\n     *    Eg:\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tObject syncObj \u003d quickserver.getClientIdentifier().getObjectToSynchronize();\n     * \tsynchronized(syncObj) {\n     * \t\tIterator iterator \u003d quickserver.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *\n     * \t//OR\n     *\n     * \tClientData foundClientData \u003d null;\n     * \tClientIdentifier clientIdentifier \u003d quickserver.getClientIdentifier();\n     * \tsynchronized(clientIdentifier.getObjectToSynchronize()) {\n     * \t\tIterator iterator \u003d clientIdentifier.findAllClient();\n     * \t\twhile(iterator.hasNext()) {\n     * \t\t\tfoundClientHandler \u003d (ClientHandler) iterator.next();\n     * \t\t\t....\n     * \t\t}\n     * \t}\n     *    \u003c/code\u003e\u003c/pre\u003e\n     *  @since 1.3.1\n     */\n    public Iterator findAllClient() {\n        return clientIdentifier.findAllClient();\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the Id.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientById(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.2\n     */\n    public Iterator findAllClientById(String pattern) {\n        return clientIdentifier.findAllClientById(pattern);\n    }\n\n    /**\n     *  Tries to find the Client by the Key passed.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//someother client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findClientByKey(\"friendskey\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.3.1\n     */\n    public ClientHandler findClientByKey(String key) {\n        return clientIdentifier.findClientByKey(key);\n    }\n\n    /**\n     *  Tries to find the Client by the matching pattern passed to the key.\n     *  \u003cp\u003e\n     *  Note: This command is an expensive so do use it limitedly and\n     *  cache the returned object. But before you start sending message to the\n     *  cached object do validate that ClientHandler with you is currently\n     *  connected and is pointing to the same client has it was before.\n     *  This can be done as follows. \u003cpre\u003e\n     * \tfoundClientHandler.isConnected(); //this method will through SocketException if not connected\n     * \tDate newTime \u003d foundClientHandler.getClientConnectedTime();\n     * \tif(oldCachedTime!\u003dnewTime) {\n     * \t\t//Client had disconnected and ClientHandler was reused for\n     * \t\t//some other client, so write code to again find ur client\n     * \t\tfoundClientHandler \u003d handler.getServer().findFirstClientByKey(\"friendsid\");\n     * \t\t...\n     * \t}\u003c/pre\u003e\n     *  \u003c/p\u003e\n     *  @see ClientIdentifiable\n     *  @return ClientHandler object if client was found else \u003ccode\u003enull\u003c/code\u003e\n     *  @since 1.4\n     */\n    public Iterator findAllClientByKey(String pattern) {\n        return clientIdentifier.findAllClientByKey(pattern);\n    }\n\n    /**\n     * Sets next client has a trusted client.\n     * \u003cp\u003eThis will skip any authentication and will not set any timeout.\u003c/p\u003e\n     * @since 1.3.2\n     */\n    public void nextClientIsTrusted() {\n        setSkipValidation(true);\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized boolean getSkipValidation() {\n        return skipValidation;\n    }\n\n    /**\n     * @since 1.3.2\n     */\n    private synchronized void setSkipValidation(boolean validation) {\n        skipValidation \u003d validation;\n    }\n\n    /**\n     * Sets the communication logging flag.\n     * @see #getCommunicationLogging\n     * @since 1.3.2\n     */\n    public void setCommunicationLogging(boolean communicationLogging) {\n        this.communicationLogging \u003d communicationLogging;\n    }\n\n    /**\n     * Returns the communication logging flag.\n     * @see #setCommunicationLogging\n     * @since 1.3.2\n     */\n    public boolean getCommunicationLogging() {\n        return communicationLogging;\n    }\n\n    /**\n     * Sets the SecurityManager class\n     * @param securityManagerClass the fully qualified name of the class\n     * that extends {@link java.lang.SecurityManager}.\n     * @see #getSecurityManagerClass\n     * @since 1.3.3\n     */\n    public void setSecurityManagerClass(String securityManagerClass) {\n        if (securityManagerClass !\u003d null)\n            this.securityManagerClass \u003d securityManagerClass;\n    }\n\n    /**\n     * Returns the SecurityManager class\n     * @see #setSecurityManagerClass\n     * @since 1.3.3\n     */\n    public String getSecurityManagerClass() {\n        return securityManagerClass;\n    }\n\n    public SecurityManager getSecurityManager() throws AppException {\n        if (getSecurityManagerClass() \u003d\u003d null)\n            return null;\n        SecurityManager sm \u003d null;\n        try {\n            sm \u003d (SecurityManager) getClass(getSecurityManagerClass(), true).newInstance();\n        } catch (ClassNotFoundException e) {\n            throw new AppException(e.getMessage());\n        } catch (InstantiationException e) {\n            throw new AppException(e.getMessage());\n        } catch (IllegalAccessException e) {\n            throw new AppException(e.getMessage());\n        }\n        return sm;\n    }\n\n    /**\n     * Sets the Access constraints\n     * @since 1.3.3\n     */\n    public void setAccessConstraintConfig(AccessConstraintConfig accessConstraintConfig) {\n        this.accessConstraintConfig \u003d accessConstraintConfig;\n    }\n\n    /**\n     * Returns Access constraints if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public AccessConstraintConfig getAccessConstraintConfig() {\n        return accessConstraintConfig;\n    }\n\n    /**\n     * Sets the classloader to be used to load the dynamically resolved\n     * classes\n     * @since 1.3.3\n     */\n    public void setClassLoader(ClassLoader classLoader) {\n        this.classLoader \u003d classLoader;\n        Thread.currentThread().setContextClassLoader(classLoader);\n    }\n\n    /**\n     * Gets the classloader used to load the dynamically resolved\n     * classes.\n     * @since 1.4.6\n     */\n    public ClassLoader getClassLoader() {\n        return classLoader;\n    }\n\n    /**\n     * Utility method to load a class\n     * @since 1.3.3\n     */\n    public Class getClass(String name, boolean reload) throws ClassNotFoundException {\n        if (name \u003d\u003d null)\n            throw new IllegalArgumentException(\"Class name can\u0027t be null!\");\n        logger.log(Level.FINEST, \"Class: {0}, reload: {1}\", new Object[] { name, reload });\n        if (reload \u003d\u003d true \u0026\u0026 classLoader !\u003d null) {\n            return classLoader.loadClass(name);\n        } else if (reload \u003d\u003d true \u0026\u0026 classLoader \u003d\u003d null \u0026\u0026 this.getClass().getClassLoader() !\u003d null) {\n            return this.getClass().getClassLoader().loadClass(name);\n        } else if (reload \u003d\u003d false \u0026\u0026 classLoader !\u003d null) {\n            return Class.forName(name, true, classLoader);\n        } else /*if(reload\u003d\u003dfalse \u0026\u0026 classLoader\u003d\u003dnull)*/\n        {\n            return Class.forName(name, true, this.getClass().getClassLoader());\n        }\n    }\n\n    /**\n     * Sets the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing\n     * the jars needed by the application.\n     * @see #getApplicationJarPath\n     * @since 1.3.3\n     */\n    protected void setApplicationJarPath(String applicationJarPath) {\n        this.applicationJarPath \u003d applicationJarPath;\n    }\n\n    /**\n     * Returns the applications jar/s path. This can be either absolute or\n     * relative(to config file) path to the jar file or the directory containing the\n     * jars needed by the application.\n     * @see #setApplicationJarPath\n     * @since 1.3.3\n     */\n    public String getApplicationJarPath() {\n        return applicationJarPath;\n    }\n\n    /**\n     * Sets the ServerHooks\n     * @since 1.3.3\n     */\n    public void setServerHooks(ServerHooks serverHooks) {\n        this.serverHooks \u003d serverHooks;\n    }\n\n    /**\n     * Returns ServerHooks if present else \u003ccode\u003enull\u003c/code\u003e.\n     * @since 1.3.3\n     */\n    public ServerHooks getServerHooks() {\n        if (serverHooks \u003d\u003d null)\n            serverHooks \u003d new ServerHooks();\n        return serverHooks;\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void loadServerHooksClasses() {\n        if (getServerHooks() \u003d\u003d null)\n            return;\n        listOfServerHooks \u003d new ArrayList();\n        ServerHook serverHook \u003d null;\n        String serverHookClassName \u003d null;\n        Class serverHookClass \u003d null;\n        //add system hooks\n        serverHook \u003d new GhostSocketReaper();\n        serverHook.initHook(QuickServer.this);\n        listOfServerHooks.add(serverHook);\n        ghostSocketReaper \u003d (GhostSocketReaper) serverHook;\n        //add user hooks if any\n        Iterator iterator \u003d getServerHooks().iterator();\n        while (iterator.hasNext()) {\n            serverHookClassName \u003d (String) iterator.next();\n            try {\n                serverHookClass \u003d getClass(serverHookClassName, true);\n                serverHook \u003d (ServerHook) serverHookClass.newInstance();\n                serverHook.initHook(QuickServer.this);\n                listOfServerHooks.add(serverHook);\n                logger.log(Level.INFO, \"Loaded server hook: {0}\", serverHookClassName);\n                logger.log(Level.FINE, \"Server hook info: {0}\", serverHook.info());\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Could not load server hook [{0}]: {1}\", new Object[] { serverHookClassName, e });\n                logger.log(Level.FINE, \"StackTrace:\\n{0}\", MyString.getStackTrace(e));\n            }\n        }\n        //end of while\n    }\n\n    /**\n     * @since 1.3.3\n     */\n    private void processServerHooks(int event) {\n        if (listOfServerHooks \u003d\u003d null) {\n            logger.warning(\"listOfServerHooks was null!\");\n            return;\n        }\n        ServerHook serverHook \u003d null;\n        boolean result \u003d false;\n        Iterator iterator \u003d listOfServerHooks.iterator();\n        String hooktype \u003d \"UNKNOWN\";\n        switch(event) {\n            case ServerHook.PRE_STARTUP:\n                hooktype \u003d \"PRE_STARTUP\";\n                break;\n            case ServerHook.POST_STARTUP:\n                hooktype \u003d \"POST_STARTUP\";\n                break;\n            case ServerHook.PRE_SHUTDOWN:\n                hooktype \u003d \"PRE_SHUTDOWN\";\n                break;\n            case ServerHook.POST_SHUTDOWN:\n                hooktype \u003d \"POST_SHUTDOWN\";\n                break;\n        }\n        while (iterator.hasNext()) {\n            serverHook \u003d (ServerHook) iterator.next();\n            try {\n                result \u003d serverHook.handleEvent(event);\n            } catch (Exception e) {\n                result \u003d false;\n                logger.log(Level.WARNING, \"Error invoking {0} hook [{1}]: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), e.getMessage() });\n            }\n            logger.log(Level.FINE, \"Invoked {0} hook [{1}] was: {2}\", new Object[] { hooktype, serverHook.getClass().getName(), result });\n        }\n    }\n\n    /**\n     * Creates and returns a copy of this object.\n     * @since 1.3.3\n     */\n    public Object clone() {\n        Object object \u003d null;\n        try {\n            object \u003d super.clone();\n            QuickServer _qs \u003d (QuickServer) object;\n            _qs.setQSAdminServer(new QSAdminServer(_qs));\n        } catch (CloneNotSupportedException e) {\n            //should not happ\n            logger.log(Level.WARNING, \"Error cloning : {0}\", e);\n        }\n        return object;\n    }\n\n    /**\n     * Sets the Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public void setSecure(Secure secure) {\n        this.secure \u003d secure;\n    }\n\n    /**\n     * Returns Secure setting for QuickServer\n     * @since 1.4.0\n     */\n    public Secure getSecure() {\n        if (secure \u003d\u003d null)\n            secure \u003d new Secure();\n        return secure;\n    }\n\n    /**\n     * \u003cp\u003eReturns if the server is running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public boolean isRunningSecure() {\n        return runningSecure;\n    }\n\n    /**\n     * \u003cp\u003eSets the server mode if its running in Secure mode [SSL or TLS].\u003c/p\u003e\n     * @since 1.4.0\n     */\n    public void setRunningSecure(boolean runningSecure) {\n        this.runningSecure \u003d runningSecure;\n    }\n\n    private File makeAbsoluteToConfig(String fileName) {\n        Assertion.affirm(fileName !\u003d null, \"FileName can\u0027t be null\");\n        return ConfigReader.makeAbsoluteToConfig(fileName, getConfig());\n    }\n\n    /**\n     * Returns a ServerSocket object to be used for listening.\n     * @since 1.4.0\n     */\n    protected void makeServerSocket() throws BindException, IOException {\n        server \u003d null;\n        logger.log(Level.FINEST, \"Binding {0} to IP: {1}\", new Object[] { getName(), getBindAddr() });\n        InetSocketAddress bindAddress \u003d new InetSocketAddress(getBindAddr(), getPort());\n        try {\n            NetworkInterface ni \u003d NetworkInterface.getByInetAddress(getBindAddr());\n            if (ni !\u003d null) {\n                logger.fine(\"NetworkInterface: \" + ni);\n            }\n        } catch (Exception igrnore) {\n            /*ignore*/\n        } catch (Error igrnore) {\n            /*ignore*/\n        }\n        if (getSecure().isEnable() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Making a normal ServerSocket for {0}\", getName());\n            setRunningSecure(false);\n            if (getBlockingMode() \u003d\u003d false) {\n                //for non-blocking\n                serverSocketChannel \u003d ServerSocketChannel.open();\n                server \u003d serverSocketChannel.socket();\n                server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n            } else {\n                //for blocking\n                server \u003d new ServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n            }\n        } else {\n            try {\n                logger.log(Level.FINE, \"Making a secure ServerSocket for {0}\", getName());\n                getSSLContext();\n                setRunningSecure(true);\n                if (getBlockingMode() \u003d\u003d false) {\n                    logger.log(Level.FINE, \"Making a secure ServerSocketChannel for {0}\", getName());\n                    //for non-blocking\n                    serverSocketChannel \u003d ServerSocketChannel.open();\n                    server \u003d serverSocketChannel.socket();\n                    server.bind(bindAddress, getBasicConfig().getAdvancedSettings().getBacklog());\n                } else {\n                    ServerSocketFactory ssf \u003d getSSLContext().getServerSocketFactory();\n                    SSLServerSocket serversocket \u003d (SSLServerSocket) ssf.createServerSocket(getPort(), getBasicConfig().getAdvancedSettings().getBacklog(), getBindAddr());\n                    serversocket.setNeedClientAuth(secure.isClientAuthEnable());\n                    setRunningSecure(true);\n                    secureStoreManager.logSSLServerSocketInfo(serversocket);\n                    server \u003d serversocket;\n                    serverSocketChannel \u003d server.getChannel();\n                    if (serverSocketChannel \u003d\u003d null \u0026\u0026 getBlockingMode() \u003d\u003d false) {\n                        logger.warning(\"Secure Server does not support Channel! So will run in blocking mode.\");\n                        blockingMode \u003d false;\n                    }\n                }\n                //blocking\n            } catch (NoSuchAlgorithmException e) {\n                logger.log(Level.WARNING, \"NoSuchAlgorithmException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            } catch (KeyManagementException e) {\n                logger.log(Level.WARNING, \"KeyManagementException : {0}\", e);\n                throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n            }\n        }\n        server.setReuseAddress(true);\n        int connectionTime \u003d 0;\n        int latency \u003d 0;\n        int bandwidth \u003d 0;\n        connectionTime \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesConnectionTime();\n        latency \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesLatency();\n        bandwidth \u003d getBasicConfig().getAdvancedSettings().getPerformancePreferencesBandwidth();\n        logger.log(Level.FINE, \"getPerformancePreferencesConnectionTime : {0}\", connectionTime);\n        logger.log(Level.FINE, \"getPerformancePreferencesLatency : {0}\", latency);\n        logger.log(Level.FINE, \"getPerformancePreferencesBandwidth : {0}\", bandwidth);\n        server.setPerformancePreferences(connectionTime, latency, bandwidth);\n        int clientSocketReceiveBufferSize \u003d getBasicConfig().getAdvancedSettings().getClientSocketReceiveBufferSize();\n        if (clientSocketReceiveBufferSize \u003e 0) {\n            logger.log(Level.FINE, \"clientSocketReceiveBufferSize: {0}\", clientSocketReceiveBufferSize);\n            server.setReceiveBufferSize(clientSocketReceiveBufferSize);\n        }\n        if (getBlockingMode() \u003d\u003d false) {\n            logger.log(Level.FINE, \"Server Mode {0} - Non Blocking\", getName());\n            if (selector \u003d\u003d null || selector.isOpen() \u003d\u003d false) {\n                logger.finest(\"Opening new selector\");\n                selector \u003d Selector.open();\n            } else {\n                logger.log(Level.FINEST, \"Reusing selector: {0}\", selector);\n            }\n            serverSocketChannel.configureBlocking(false);\n            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n            selector.wakeup();\n        } else {\n            logger.log(Level.FINE, \"Server Mode {0} - Blocking\", getName());\n        }\n    }\n\n    /**\n     * Sets the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public void setBasicConfig(BasicServerConfig basicConfig) throws Exception {\n        Assertion.affirm(basicConfig !\u003d null, \"BasicServerConfig can\u0027t be null\");\n        this.basicConfig \u003d basicConfig;\n    }\n\n    /**\n     * Returns the basic configuration of the QuickServer.\n     * @since 1.4.0\n     */\n    public BasicServerConfig getBasicConfig() {\n        return basicConfig;\n    }\n\n    /**\n     * Loads the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring if set.\n     * @see #setSecure\n     * @since 1.4.0\n     */\n    public void loadSSLContext() throws IOException {\n        if (getSecure().isLoad() \u003d\u003d false) {\n            throw new IllegalStateException(\"Secure setting is not yet enabled for loading!\");\n        }\n        logger.info(\"Loading Secure Context..\");\n        km \u003d null;\n        tm \u003d null;\n        try {\n            String ssManager \u003d \"org.quickserver.security.SecureStoreManager\";\n            if (getSecure().getSecureStore() !\u003d null)\n                ssManager \u003d getSecure().getSecureStore().getSecureStoreManager();\n            Class secureStoreManagerClass \u003d getClass(ssManager, true);\n            secureStoreManager \u003d (SecureStoreManager) secureStoreManagerClass.newInstance();\n            km \u003d secureStoreManager.loadKeyManagers(getConfig());\n            logger.fine(\"KeyManager got\");\n            tm \u003d secureStoreManager.loadTrustManagers(getConfig());\n            logger.fine(\"TrustManager got\");\n            sslc \u003d secureStoreManager.getSSLContext(getConfig().getSecure().getProtocol());\n            sslc.init(km, tm, null);\n            logger.fine(\"SSLContext loaded\");\n        } catch (KeyStoreException e) {\n            logger.warning(\"KeyStoreException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchAlgorithmException e) {\n            logger.warning(\"NoSuchAlgorithmException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (NoSuchProviderException e) {\n            logger.warning(\"NoSuchProviderException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (UnrecoverableKeyException e) {\n            logger.warning(\"UnrecoverableKeyException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (CertificateException e) {\n            logger.warning(\"CertificateException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (KeyManagementException e) {\n            logger.warning(\"KeyManagementException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (GeneralSecurityException e) {\n            logger.warning(\"GeneralSecurityException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (ClassNotFoundException e) {\n            logger.warning(\"ClassNotFoundException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (InstantiationException e) {\n            logger.warning(\"InstantiationException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        } catch (IllegalAccessException e) {\n            logger.warning(\"IllegalAccessException : \" + e);\n            throw new IOException(\"Error creating secure socket : \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e from Secure configuring.\n     * @see #loadSSLContext\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        return getSSLContext(null);\n    }\n\n    /**\n     * Returns the \u003ccode\u003eSSLContext\u003c/code\u003e object that implements the specified\n     * secure socket protocol from Secure configuring.\n     * @see #loadSSLContext\n     * @param protocol the standard name of the requested protocol. If \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLContext getSSLContext(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        if (protocol !\u003d null \u0026\u0026 secureStoreManager !\u003d null) {\n            SSLContext _sslc \u003d secureStoreManager.getSSLContext(protocol);\n            _sslc.init(km, tm, null);\n            return _sslc;\n        }\n        return sslc;\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * Secure socket protocol will be picked from the Secure configuring.\n     * @see #setSecure\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory() throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext());\n    }\n\n    /**\n     * Returns a SSLSocketFactory object to be used for creating SSLSockets.\n     * @see #setSecure\n     * @param protocol the standard name of the requested protocol. If\n     * \u003ccode\u003enull\u003c/code\u003e will use the protocol set in secure configuration\n     * of the server.\n     * @throws IOException\n     * @throws NoSuchAlgorithmException\n     * @throws KeyManagementException\n     * @since 1.4.0\n     */\n    public SSLSocketFactory getSSLSocketFactory(String protocol) throws IOException, NoSuchAlgorithmException, KeyManagementException {\n        if (sslc \u003d\u003d null)\n            loadSSLContext();\n        return secureStoreManager.getSocketFactory(getSSLContext(protocol));\n    }\n\n    /**\n     * Sets the ClientBinaryHandler class that interacts with\n     * client sockets to handle binary data.\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientBinaryHandler}\n     * @see #getClientBinaryHandler\n     * @since 1.4\n     */\n    public void setClientBinaryHandler(String handler) {\n        clientBinaryHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientBinaryHandler class that interacts with\n     * client sockets.\n     * @see #setClientBinaryHandler\n     * @since 1.4\n     */\n    public String getClientBinaryHandler() {\n        return clientBinaryHandlerString;\n    }\n\n    /**\n     * Sets the Selector (NIO).\n     * @since 1.4.5\n     */\n    public void setSelector(Selector selector) {\n        this.selector \u003d selector;\n    }\n\n    /**\n     * Returns the Selector (NIO),if any.\n     * @since 1.4.5\n     */\n    public Selector getSelector() {\n        return selector;\n    }\n\n    /**\n     * Starts server in blocking mode.\n     * @since 1.4.5\n     */\n    private void runBlocking(TheClient theClient) throws Exception {\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        //long stime \u003d System.currentTimeMillis();\n        //long etime \u003d System.currentTimeMillis();\n        while (true) {\n            //etime \u003d System.currentTimeMillis();\n            //System.out.println(\"Time Taken: \"+(etime-stime));\n            client \u003d server.accept();\n            //stime \u003d System.currentTimeMillis();\n            if (linger \u003c 0) {\n                client.setSoLinger(false, 0);\n            } else {\n                client.setSoLinger(true, linger);\n            }\n            client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                //low delay\u003d10\n                client.setTrafficClass(socketTrafficClass);\n            }\n            logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n            if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n            }\n            if (stopServer) {\n                //Client connected when server was about to be shutdown.\n                try {\n                    client.close();\n                } catch (Exception e) {\n                }\n                break;\n            }\n            if (checkAccessConstraint(client) \u003d\u003d false) {\n                continue;\n            }\n            //Check if max connection has reached\n            if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                theClient.setClientEvent(ClientEvent.MAX_CON_BLOCKING);\n            } else {\n                theClient.setClientEvent(ClientEvent.RUN_BLOCKING);\n            }\n            theClient.setTrusted(getSkipValidation());\n            theClient.setSocket(client);\n            //mostly null\n            theClient.setSocketChannel(client.getChannel());\n            if (clientDataClass !\u003d null) {\n                if (getClientDataPool() \u003d\u003d null) {\n                    clientData \u003d (ClientData) clientDataClass.newInstance();\n                } else {\n                    clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                }\n                theClient.setClientData(clientData);\n            }\n            try {\n                _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                _chPolled.handleClient(theClient);\n            } catch (java.util.NoSuchElementException nsee) {\n                logger.warning(\"Could not borrow ClientHandler from pool. Error: \" + nsee);\n                logger.warning(\"Closing Socket [\" + client + \"] since no ClientHandler available.\");\n                client.close();\n            }\n            if (_chPolled !\u003d null) {\n                try {\n                    getClientPool().addClient(_chPolled, true);\n                } catch (java.util.NoSuchElementException nsee) {\n                    logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                    //logger.warning(\"Closing Socket [\"+client+\"] since no Thread available.\");\n                    //client.close();\n                    //returnClientHandlerToPool(_chPolled);\n                }\n                _chPolled \u003d null;\n            }\n            client \u003d null;\n            //reset it back\n            setSkipValidation(false);\n        }\n        //end of loop\n    }\n\n    /**\n     * Starts server in non-blocking mode.\n     * @since 1.4.5\n     */\n    private void runNonBlocking(TheClient theClient) throws Exception {\n        int selectCount \u003d 0;\n        Iterator iterator \u003d null;\n        SelectionKey key \u003d null;\n        ServerSocketChannel serverChannel \u003d null;\n        SocketChannel socketChannel \u003d null;\n        Socket client \u003d null;\n        ClientHandler _chPolled \u003d null;\n        boolean stopServerProcessed \u003d false;\n        int linger \u003d getBasicConfig().getAdvancedSettings().getSocketLinger();\n        registerChannelRequestMap \u003d new HashMap();\n        int socketTrafficClass \u003d 0;\n        if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n            socketTrafficClass \u003d Integer.parseInt(getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass());\n        }\n        while (true) {\n            selectCount \u003d selector.select(500);\n            //selectCount \u003d selector.select();//for testing\n            //check for any pending registerChannel req.\n            synchronized (registerChannelRequestMap) {\n                if (registerChannelRequestMap.size() \u003e 0) {\n                    RegisterChannelRequest req \u003d null;\n                    Object hashkey \u003d null;\n                    iterator \u003d registerChannelRequestMap.keySet().iterator();\n                    while (iterator.hasNext()) {\n                        hashkey \u003d iterator.next();\n                        req \u003d (RegisterChannelRequest) registerChannelRequestMap.get(hashkey);\n                        req.register(getSelector());\n                    }\n                    iterator \u003d null;\n                    registerChannelRequestMap.clear();\n                }\n                //if\n            }\n            //sync\n            if (stopServer \u003d\u003d true \u0026\u0026 stopServerProcessed \u003d\u003d false) {\n                logger.warning(\"Closing \" + getName());\n                serverSocketChannel.close();\n                stopServerProcessed \u003d true;\n                server \u003d null;\n                serverSocketChannel \u003d null;\n                setServiceState(Service.STOPPED);\n                logger.warning(\"Closed \" + getName());\n                processServerHooks(ServerHook.POST_SHUTDOWN);\n            }\n            if (stopServer \u003d\u003d false \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                logger.finest(\"Server must have re-started.. will break\");\n                break;\n            }\n            if (selectCount \u003d\u003d 0 \u0026\u0026 stopServerProcessed \u003d\u003d true) {\n                java.util.Set keyset \u003d selector.keys();\n                if (keyset.isEmpty() \u003d\u003d true \u0026\u0026 getClientCount() \u003c\u003d 0) {\n                    break;\n                } else {\n                    continue;\n                }\n            } else if (selectCount \u003d\u003d 0) {\n                continue;\n            }\n            iterator \u003d selector.selectedKeys().iterator();\n            while (iterator.hasNext()) {\n                key \u003d (SelectionKey) iterator.next();\n                if (key.isValid() \u003d\u003d false) {\n                    iterator.remove();\n                    continue;\n                }\n                if (key.isAcceptable() \u0026\u0026 stopServer \u003d\u003d false) {\n                    logger.finest(\"Key is Acceptable\");\n                    serverChannel \u003d (ServerSocketChannel) key.channel();\n                    socketChannel \u003d serverChannel.accept();\n                    if (socketChannel \u003d\u003d null) {\n                        iterator.remove();\n                        continue;\n                    }\n                    client \u003d socketChannel.socket();\n                    if (linger \u003c 0) {\n                        client.setSoLinger(false, 0);\n                    } else {\n                        client.setSoLinger(true, linger);\n                    }\n                    client.setTcpNoDelay(getBasicConfig().getAdvancedSettings().getClientSocketTcpNoDelay());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketTrafficClass() !\u003d null) {\n                        //low delay\u003d10\n                        client.setTrafficClass(socketTrafficClass);\n                    }\n                    logger.fine(\"ReceiveBufferSize: \" + client.getReceiveBufferSize());\n                    if (getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize() !\u003d 0) {\n                        client.setSendBufferSize(getBasicConfig().getAdvancedSettings().getClientSocketSendBufferSize());\n                        logger.fine(\"SendBufferSize: \" + client.getSendBufferSize());\n                    }\n                    if (checkAccessConstraint(client) \u003d\u003d false) {\n                        iterator.remove();\n                        continue;\n                    }\n                    socketChannel.configureBlocking(false);\n                    theClient.setTrusted(getSkipValidation());\n                    theClient.setSocket(socketChannel.socket());\n                    theClient.setSocketChannel(socketChannel);\n                    if (clientDataClass !\u003d null) {\n                        if (getClientDataPool() \u003d\u003d null) {\n                            clientData \u003d (ClientData) clientDataClass.newInstance();\n                        } else {\n                            //borrow a object from pool\n                            clientData \u003d (ClientData) getClientDataPool().borrowObject();\n                        }\n                        theClient.setClientData(clientData);\n                    }\n                    //Check if max connection has reached\n                    if (getSkipValidation() !\u003d true \u0026\u0026 maxConnection !\u003d -1 \u0026\u0026 getClientHandlerPool().getNumActive() \u003e\u003d maxConnection) {\n                        theClient.setClientEvent(ClientEvent.MAX_CON);\n                    } else {\n                        theClient.setClientEvent(ClientEvent.ACCEPT);\n                    }\n                    try {\n                        _chPolled \u003d (ClientHandler) getClientHandlerPool().borrowObject();\n                        logger.finest(\"Asking \" + _chPolled.getName() + \" to handle.\");\n                        _chPolled.handleClient(theClient);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.warning(\"Could not borrow ClientHandler Object from pool. Error: \" + nsee);\n                        logger.warning(\"Closing SocketChannel [\" + serverChannel.socket() + \"] since no ClientHandler available.\");\n                        socketChannel.close();\n                    }\n                    if (_chPolled !\u003d null) {\n                        try {\n                            getClientPool().addClient(_chPolled, true);\n                        } catch (java.util.NoSuchElementException nsee) {\n                            logger.warning(\"Could not borrow Thread from pool. Error: \" + nsee);\n                            //logger.warning(\"Closing SocketChannel [\"+serverChannel.socket()+\"] since no Thread available.\");\n                            //socketChannel.close();\n                            //returnClientHandlerToPool(_chPolled);\n                        }\n                        _chPolled \u003d null;\n                    }\n                    socketChannel \u003d null;\n                    client \u003d null;\n                    //reset it back\n                    setSkipValidation(false);\n                } else if (key.isValid() \u0026\u0026 key.isReadable()) {\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Readable, removing OP_READ from interestOps for \" + _ch.getName());\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_READ));\n                        _ch.addEvent(ClientEvent.READ);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.READ);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (key.isValid() \u0026\u0026 key.isWritable()) {\n                    if (getClientPool().shouldNioWriteHappen() \u003d\u003d false) {\n                        //no need to remove the key\n                        continue;\n                    }\n                    boolean addedEvent \u003d false;\n                    ClientHandler _ch \u003d null;\n                    try {\n                        _ch \u003d (ClientHandler) key.attachment();\n                        logger.finest(\"Key is Writable, removing OP_WRITE from interestOps for \" + _ch.getName());\n                        //remove OP_WRITE from interest set\n                        key.interestOps(key.interestOps() \u0026 (~SelectionKey.OP_WRITE));\n                        _ch.addEvent(ClientEvent.WRITE);\n                        addedEvent \u003d true;\n                        //_ch.setSelectionKey(key);\n                        getClientPool().addClient(_ch);\n                    } catch (CancelledKeyException cke) {\n                        logger.fine(\"Ignored Error - Key was Cancelled: \" + cke);\n                    } catch (java.util.NoSuchElementException nsee) {\n                        logger.finest(\"NoSuchElementException: \" + nsee);\n                        if (addedEvent)\n                            _ch.removeEvent(ClientEvent.WRITE);\n                        //no need to remove the key\n                        continue;\n                    }\n                    _ch \u003d null;\n                } else if (stopServer \u003d\u003d true \u0026\u0026 key.isAcceptable()) {\n                    //we will not accept this key\n                    //reset it back\n                    setSkipValidation(false);\n                } else {\n                    logger.warning(\"Unknown key got in SelectionKey: \" + key);\n                }\n                //Remove key\n                iterator.remove();\n                Thread.yield();\n            }\n            //end of iterator\n            iterator \u003d null;\n        }\n        //end of loop\n    }\n\n    private boolean checkAccessConstraint(Socket socket) {\n        try {\n            if (getAccessConstraintConfig() !\u003d null) {\n                getAccessConstraintConfig().checkAccept(socket);\n            }\n            return true;\n        } catch (SecurityException se) {\n            logger.warning(\"SecurityException occurred accepting connection : \" + se.getMessage());\n            return false;\n        }\n    }\n\n    /**\n     * Register the given channel for the given operations. This adds the request\n     * to a list and will be processed after selector select wakes up.\n     * @return boolean flag to indicate if new entry was added to the list to register.\n     * @since 1.4.5\n     */\n    public boolean registerChannel(SocketChannel channel, int ops, Object att) throws IOException, ClosedChannelException {\n        if (getSelector() \u003d\u003d null) {\n            throw new IllegalStateException(\"Selector is not open!\");\n        }\n        if (channel \u003d\u003d null) {\n            throw new IllegalArgumentException(\"Can\u0027t register a null channel!\");\n        }\n        if (channel.isConnected() \u003d\u003d false) {\n            throw new ClosedChannelException();\n        }\n        RegisterChannelRequest req \u003d new RegisterChannelRequest(channel, ops, att);\n        RegisterChannelRequest reqOld \u003d null;\n        synchronized (registerChannelRequestMap) {\n            reqOld \u003d (RegisterChannelRequest) registerChannelRequestMap.get(channel);\n            if (reqOld \u003d\u003d null) {\n                registerChannelRequestMap.put(channel, req);\n                getSelector().wakeup();\n                return true;\n            } else {\n                if (reqOld.equals(req) \u003d\u003d false) {\n                    reqOld.setOps(reqOld.getOps() | req.getOps());\n                    reqOld.setAtt(req.getAtt());\n                    return true;\n                }\n                return false;\n            }\n        }\n        /*\n\t\tlogger.warning(\"Before register...\");\n\t\tchannel.register(getSelector(), ops, att);\n\t\tlogger.warning(\"Before wakeup and after register...\");\n\t\tgetSelector().wakeup();\n\t\tlogger.warning(\"After wakeup...\");\n\t\t*/\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeByteBufferPool(PoolConfig opConfig) {\n        logger.finer(\"Creating ByteBufferPool pool\");\n        int bufferSize \u003d getBasicConfig().getAdvancedSettings().getByteBufferSize();\n        boolean useDirectByteBuffer \u003d getBasicConfig().getAdvancedSettings().getUseDirectByteBuffer();\n        PoolableObjectFactory factory \u003d new ByteBufferObjectFactory(bufferSize, useDirectByteBuffer);\n        byteBufferPool \u003d poolManager.makeByteBufferPool(factory, opConfig);\n        poolManager.initPool(byteBufferPool, opConfig);\n    }\n\n    /**\n     * Returns ObjectPool of java.nio.ByteBuffer class.\n     * @since 1.4.5\n     */\n    public ObjectPool getByteBufferPool() {\n        return byteBufferPool;\n    }\n\n    /**\n     * Makes the pool of ByteBuffer\n     * @since 1.4.5\n     */\n    private void makeClientPool(PoolConfig opConfig) throws Exception {\n        logger.finer(\"Creating ClientThread pool\");\n        ThreadObjectFactory factory \u003d new ThreadObjectFactory();\n        ObjectPool objectPool \u003d poolManager.makeClientPool(factory, opConfig);\n        pool \u003d new ClientPool(makeQSObjectPool(objectPool), opConfig);\n        factory.setClientPool(pool);\n        pool.setMaxThreadsForNioWrite(getBasicConfig().getAdvancedSettings().getMaxThreadsForNioWrite());\n        poolManager.initPool(objectPool, opConfig);\n    }\n\n    /**\n     * Sets the ClientWriteHandler class that interacts with\n     * client sockets to handle data write (only used in non-blocking mode).\n     * @param handler object the fully qualified name of the class that\n     *  implements {@link ClientWriteHandler}\n     * @see #getClientWriteHandler\n     * @since 1.4.5\n     */\n    public void setClientWriteHandler(String handler) {\n        clientWriteHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientWriteHandler class that interacts with\n     * client sockets (only used in non-blocking mode).\n     * @see #setClientWriteHandler\n     * @since 1.4.5\n     */\n    public String getClientWriteHandler() {\n        return clientWriteHandlerString;\n    }\n\n    /**\n     * Returns the date/time when the server was last started.\n     * @return last started time. Will be \u003ccode\u003enull\u003c/code\u003e if never started.\n     * @since 1.4.5\n     */\n    public java.util.Date getLastStartTime() {\n        return lastStartTime;\n    }\n\n    /**\n     * Sets the debug flag to ByteBufferOutputStream and\n     * ByteBufferInputStream class that are used in non-blcking mode\n     * @since 1.4.5\n     */\n    public static void setDebugNonBlockingMode(boolean flag) {\n        org.quickserver.util.io.ByteBufferOutputStream.setDebug(flag);\n        org.quickserver.util.io.ByteBufferInputStream.setDebug(flag);\n    }\n\n    /**\n     * Returns the implementation that is used to do Client Identification.\n     * @since 1.4.5\n     */\n    public ClientIdentifier getClientIdentifier() {\n        return clientIdentifier;\n    }\n\n    /**\n     * Makes QSObjectPool from ObjectPool\n     * @since 1.4.5\n     */\n    private QSObjectPool makeQSObjectPool(ObjectPool objectPool) throws Exception {\n        return (QSObjectPool) qsObjectPoolMaker.getQSObjectPool(objectPool);\n    }\n\n    /**\n     * Returns the current blocking mode of the server.\n     * @since 1.4.6\n     */\n    public boolean getBlockingMode() {\n        return blockingMode;\n    }\n\n    /**\n     * Loads all the Business Logic class\n     * @since 1.4.6\n     */\n    protected void loadBusinessLogic() throws Exception {\n        if (clientCommandHandlerString \u003d\u003d null \u0026\u0026 clientEventHandlerString \u003d\u003d null) {\n            logger.severe(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n            throw new AppException(\"ClientCommandHandler AND ClientEventHandler was not set.\");\n        }\n        clientCommandHandler \u003d null;\n        if (clientCommandHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientCommandHandler class..\");\n            Class clientCommandHandlerClass \u003d getClass(clientCommandHandlerString, true);\n            clientCommandHandler \u003d (ClientCommandHandler) clientCommandHandlerClass.newInstance();\n        }\n        boolean setClientCommandHandlerLookup \u003d false;\n        clientEventHandler \u003d null;\n        if (clientEventHandlerString \u003d\u003d null) {\n            clientEventHandlerString \u003d \"org.quickserver.net.server.impl.DefaultClientEventHandler\";\n            setClientCommandHandlerLookup \u003d true;\n        }\n        logger.finest(\"Loading ClientEventHandler class..\");\n        if (clientEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientEventHandler.class.isInstance(clientCommandHandler)) {\n            clientEventHandler \u003d (ClientEventHandler) clientCommandHandler;\n        } else {\n            clientEventHandler \u003d (ClientEventHandler) getClass(clientEventHandlerString, true).newInstance();\n            if (setClientCommandHandlerLookup) {\n                ((DefaultClientEventHandler) clientEventHandler).setClientCommandHandler(clientCommandHandler);\n            }\n        }\n        clientExtendedEventHandler \u003d null;\n        if (clientExtendedEventHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientExtendedEventHandler class..\");\n            if (clientExtendedEventHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientCommandHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientCommandHandler;\n            } else if (clientExtendedEventHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientExtendedEventHandler.class.isInstance(clientEventHandler)) {\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientEventHandler;\n            } else {\n                Class clientExtendedEventHandlerClass \u003d getClass(clientExtendedEventHandlerString, true);\n                clientExtendedEventHandler \u003d (ClientExtendedEventHandler) clientExtendedEventHandlerClass.newInstance();\n            }\n        }\n        clientObjectHandler \u003d null;\n        if (clientObjectHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientObjectHandler class..\");\n            if (clientObjectHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientCommandHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientCommandHandler;\n            } else if (clientObjectHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientEventHandler;\n            } else if (clientObjectHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientObjectHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientObjectHandler \u003d (ClientObjectHandler) clientExtendedEventHandler;\n            } else {\n                clientObjectHandler \u003d (ClientObjectHandler) getClass(clientObjectHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientBinaryHandler \u003d null;\n        if (clientBinaryHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientBinaryHandler class..\");\n            if (clientBinaryHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientCommandHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientCommandHandler;\n            } else if (clientBinaryHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientExtendedEventHandler;\n            } else if (clientBinaryHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientBinaryHandler.class.isInstance(clientObjectHandler)) {\n                clientBinaryHandler \u003d (ClientBinaryHandler) clientObjectHandler;\n            } else {\n                clientBinaryHandler \u003d (ClientBinaryHandler) getClass(clientBinaryHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        clientWriteHandler \u003d null;\n        if (clientWriteHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientWriteHandler class..\");\n            if (clientWriteHandlerString.equals(clientCommandHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientCommandHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientCommandHandler;\n            } else if (clientWriteHandlerString.equals(clientEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientEventHandler;\n            } else if (clientWriteHandlerString.equals(clientExtendedEventHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientExtendedEventHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientExtendedEventHandler;\n            } else if (clientWriteHandlerString.equals(clientObjectHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientObjectHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientObjectHandler;\n            } else if (clientWriteHandlerString.equals(clientBinaryHandlerString) \u0026\u0026 ClientWriteHandler.class.isInstance(clientBinaryHandler)) {\n                clientWriteHandler \u003d (ClientWriteHandler) clientBinaryHandler;\n            } else {\n                clientWriteHandler \u003d (ClientWriteHandler) getClass(clientWriteHandlerString, true).newInstance();\n            }\n        }\n        //end of !\u003d null\n        Class authenticatorClass \u003d null;\n        if (clientAuthenticationHandlerString !\u003d null) {\n            logger.finest(\"Loading ClientAuthenticationHandler class..\");\n            authenticatorClass \u003d getClass(clientAuthenticationHandlerString, true);\n        }\n        if (authenticatorClass !\u003d null) {\n            Object obj \u003d authenticatorClass.newInstance();\n            if (ClientAuthenticationHandler.class.isInstance(obj))\n                clientAuthenticationHandler \u003d (ClientAuthenticationHandler) obj;\n            else\n                authenticator \u003d (Authenticator) obj;\n        }\n        clientDataClass \u003d null;\n        if (clientDataString !\u003d null) {\n            logger.finest(\"Loading ClientData class..\");\n            clientDataClass \u003d getClass(clientDataString, true);\n        }\n        Assertion.affirm(clientEventHandler !\u003d null, \"ClientEventHandler was not loaded!\");\n    }\n\n    /**\n     * Sets the ClientEventHandler class that gets notified of\n     * client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientEventHandler}\n     * @see #getClientEventHandler\n     * @since 1.4.6\n     */\n    public void setClientEventHandler(String handler) {\n        clientEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientEventHandler class that gets notified of\n     * client events.\n     * @see #setClientEventHandler\n     * @since 1.4.6\n     */\n    public String getClientEventHandler() {\n        return clientEventHandlerString;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DataMode dataMode, DataType dataType) throws IOException {\n        if (dataType \u003d\u003d DataType.IN)\n            this.defaultDataModeIN \u003d dataMode;\n        if (dataType \u003d\u003d DataType.OUT)\n            this.defaultDataModeOUT \u003d dataMode;\n    }\n\n    /**\n     * Sets the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public void setDefaultDataMode(DefaultDataMode defaultDataMode) throws IOException {\n        defaultDataModeIN \u003d defaultDataMode.getDataMode(DataType.IN);\n        defaultDataModeOUT \u003d defaultDataMode.getDataMode(DataType.OUT);\n        ;\n    }\n\n    /**\n     * Returns the default {@link DataMode} for the ClientHandler\n     * @since 1.4.6\n     */\n    public DataMode getDefaultDataMode(DataType dataType) {\n        if (dataType \u003d\u003d DataType.IN)\n            return defaultDataModeIN;\n        if (dataType \u003d\u003d DataType.OUT)\n            return defaultDataModeOUT;\n        else\n            throw new IllegalArgumentException(\"Unknown DataType: \" + dataType);\n    }\n\n    /**\n     * Sets the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @param handler the fully qualified name of the class that\n     *  implements {@link ClientExtendedEventHandler}\n     * @see #getClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public void setClientExtendedEventHandler(String handler) {\n        clientExtendedEventHandlerString \u003d handler;\n        logger.finest(\"Set to \" + handler);\n    }\n\n    /**\n     * Returns the ClientExtendedEventHandler class that gets notified of\n     * extended client events.\n     * @see #setClientExtendedEventHandler\n     * @since 1.4.6\n     */\n    public String getClientExtendedEventHandler() {\n        return clientExtendedEventHandlerString;\n    }\n\n    /**\n     * If Application Jar Path was set, load the jars\n     * @since 1.4.6\n     */\n    private void loadApplicationClasses() throws Exception {\n        if (getApplicationJarPath() !\u003d null \u0026\u0026 getClassLoader() \u003d\u003d null) {\n            setClassLoader(ClassUtil.getClassLoader(getApplicationJarPath()));\n            //update qsadmin to use the same\n            if (adminServer !\u003d null) {\n                adminServer.getServer().setClassLoader(getClassLoader());\n            }\n        }\n    }\n\n    /**\n     * Returns PID of the JVM\n     * @return PID of the JVM\n     * @since 1.4.8\n     */\n    public static String getPID() {\n        return pid;\n    }\n\n    public boolean isRawCommunicationLogging() {\n        return rawCommunicationLogging;\n    }\n\n    public void setRawCommunicationLogging(boolean rawCommunicationLogging) {\n        this.rawCommunicationLogging \u003d rawCommunicationLogging;\n    }\n\n    public int getRawCommunicationMaxLength() {\n        return rawCommunicationMaxLength;\n    }\n\n    public void setRawCommunicationMaxLength(int rawCommunicationMaxLength) {\n        this.rawCommunicationMaxLength \u003d rawCommunicationMaxLength;\n    }\n}\n",
    "package": "org.quickserver.net.server",
    "classname": "QuickServer",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/server/QuickServer_22Test.java",
    "test_prompt": "// QuickServer_22Test.java\npackage org.quickserver.net.server;\n\nimport java.io.*;\nimport java.lang.management.ManagementFactory;\nimport java.net.*;\nimport org.quickserver.net.*;\n//v1.1\nimport org.quickserver.net.qsadmin.*;\n//v1.2\nimport java.util.logging.*;\n//v1.3\nimport org.quickserver.util.pool.*;\nimport org.quickserver.util.pool.thread.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.util.xmlreader.*;\nimport org.quickserver.sql.*;\n//v1.3.1\nimport java.util.logging.Formatter;\nimport java.util.*;\n//v1.3.2\nimport org.quickserver.util.*;\n//v1.3.3\nimport org.quickserver.security.*;\n//v1.4.0\nimport javax.net.ssl.*;\nimport javax.net.*;\nimport java.security.*;\nimport java.security.cert.*;\n//v1.4.5\nimport java.nio.channels.*;\nimport org.quickserver.net.server.impl.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QuickServer}.\n* It contains ten unit test cases for the {@link QuickServer#getPID()} method.\n*/\nclass QuickServer_22Test {",
    "method_signature": "getPID()",
    "suffix": "22"
  },
  {
    "numberTests": "ten",
    "original_code": "// QSAdminAPI.java\n/*\r\n * This file is part of the QuickServer library \r\n * Copyright (C) QuickServer.org\r\n *\r\n * Use, modification, copying and distribution of this software is subject to\r\n * the terms and conditions of the GNU Lesser General Public License. \r\n * You should have received a copy of the GNU LGP License along with this \r\n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\r\n *\r\n * For questions, suggestions, bug-reports, enhancement-requests etc.\r\n * visit http://www.quickserver.org\r\n *\r\n */\r\npackage org.quickserver.net.qsadmin;\r\n\r\nimport java.io.*;\r\nimport java.net.*;\r\nimport java.util.logging.*;\r\n\r\n/**\r\n *  QSAdminAPI class to communicate to QsAdmin from java applications.\r\n *  \u003cp\u003e\r\n *   Eg:\r\n *  \u003ccode\u003e\u003cBLOCKQUOTE\u003e\u003cpre\u003e\r\n * \tQSAdminAPI qsAdminApi \u003d new QSAdminAPI(\"127.0.0.1\", 9080);\r\n * \tif(qsAdminApi.logon()) {\r\n * \t\tSystem.out.println(\"Logged in\");\r\n * \t\tString info \u003d qsAdminApi.sendCommand(\"info server\");\r\n * \t\tSystem.out.println(\"Info on Server :\\n\"+info);\r\n * \t\tqsAdminApi.logoff();\r\n * \t} else {\r\n * \t\tSystem.out.println(\"Bad Login\");\r\n * \t\tqsAdminApi.close();\r\n * \t}\r\n * \u003c/pre\u003e\u003c/BLOCKQUOTE\u003e\u003c/code\u003e\u003c/p\u003e\r\n *  @see QSAdminServer\r\n *  @since 1.4\r\n *  @author Akshathkumar Shetty\r\n */\r\npublic class QSAdminAPI {\r\n\r\n    private static final Logger logger \u003d Logger.getLogger(QSAdminAPI.class.getName());\r\n\r\n    private String username \u003d \"Admin\";\r\n\r\n    private String password \u003d \"QsAdm1n\";\r\n\r\n    private String host \u003d \"localhost\";\r\n\r\n    private int port \u003d 9877;\r\n\r\n    private Socket socket;\r\n\r\n    private InputStream in;\r\n\r\n    private OutputStream out;\r\n\r\n    private BufferedReader br;\r\n\r\n    private BufferedWriter bw;\r\n\r\n    /**\r\n     * Creates QSAdminAPI object that will communicate with the\r\n     * passed host and port.\r\n     */\r\n    public QSAdminAPI(String host, int port) {\r\n        this.host \u003d host;\r\n        this.port \u003d port;\r\n    }\r\n\r\n    /**\r\n     * Will attempt to connect and logon to the remote QsAdminServer.\r\n     */\r\n    public boolean logon() throws IOException {\r\n        return logon(username, password);\r\n    }\r\n\r\n    /**\r\n     * Will attempt to connect and logon to the remote QsAdminServer.\r\n     */\r\n    public boolean logon(String username, String password) throws IOException {\r\n        this.username \u003d username;\r\n        this.password \u003d password;\r\n        logger.fine(\"Connecting to \" + host + \":\" + port);\r\n        socket \u003d new Socket(host, port);\r\n        in \u003d socket.getInputStream();\r\n        out \u003d socket.getOutputStream();\r\n        br \u003d new BufferedReader(new InputStreamReader(in, \"UTF-8\"));\r\n        bw \u003d new BufferedWriter(new OutputStreamWriter(out, \"UTF-8\"));\r\n        logger.fine(\"Got : \" + br.readLine());\r\n        logger.fine(\"Got : \" + br.readLine());\r\n        logger.fine(\"Got : \" + br.readLine());\r\n        logger.fine(\"Got : \" + br.readLine());\r\n        logger.fine(\"Sending username\");\r\n        bw.write(username + \"\\r\\n\");\r\n        bw.flush();\r\n        logger.fine(\"Got : \" + br.readLine());\r\n        logger.fine(\"Sending password\");\r\n        bw.write(password + \"\\r\\n\");\r\n        bw.flush();\r\n        String temp \u003d br.readLine();\r\n        logger.fine(\"Got : \" + temp);\r\n        return temp.startsWith(\"+OK \");\r\n    }\r\n\r\n    /**\r\n     * Sends the given command to QSAdmin and gives the response back.\r\n     */\r\n    public String sendCommand(String data) throws IOException {\r\n        logger.fine(\"Sending command : \" + data);\r\n        bw.write(data + \"\\r\\n\");\r\n        bw.flush();\r\n        String temp \u003d readResponse();\r\n        logger.fine(\"Got : \" + temp);\r\n        return temp;\r\n    }\r\n\r\n    private String readResponse() throws IOException {\r\n        StringBuilder command \u003d new StringBuilder();\r\n        String res \u003d br.readLine();\r\n        if (res !\u003d null \u0026\u0026 res.equals(\"+OK info follows\") \u003d\u003d false)\r\n            return res;\r\n        while (res !\u003d null \u0026\u0026 res.equals(\".\") \u003d\u003d false) {\r\n            command.append(res + \"\\r\\n\");\r\n            res \u003d br.readLine();\r\n        }\r\n        return command.toString();\r\n    }\r\n\r\n    /**\r\n     * Logoff the QSAdminServer and closed the socket associated.\r\n     */\r\n    public void logoff() throws IOException {\r\n        logger.fine(\"Logging off\");\r\n        logger.fine(\"Sending command : quit\");\r\n        bw.write(\"quit\" + \"\\r\\n\");\r\n        bw.flush();\r\n        logger.fine(\"Got : \" + br.readLine());\r\n        close();\r\n    }\r\n\r\n    /**\r\n     * Closes the socket associated.\r\n     */\r\n    public void close() throws IOException {\r\n        logger.fine(\"Closing\");\r\n        socket.close();\r\n        socket \u003d null;\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        QSAdminAPI qsAdminApi \u003d new QSAdminAPI(\"127.0.0.1\", 9080);\r\n        if (qsAdminApi.logon()) {\r\n            logger.info(\"Logged in\");\r\n            String info \u003d qsAdminApi.sendCommand(\"info server\");\r\n            logger.info(\"Info on Server :\\n\" + info);\r\n            qsAdminApi.logoff();\r\n        } else {\r\n            logger.warning(\"Bad Login!\");\r\n            qsAdminApi.close();\r\n        }\r\n    }\r\n}\r\n",
    "package": "org.quickserver.net.qsadmin",
    "classname": "QSAdminAPI",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/net/qsadmin/QSAdminAPI_0Test.java",
    "test_prompt": "// QSAdminAPI_0Test.java\npackage org.quickserver.net.qsadmin;\n\nimport java.io.*;\nimport java.net.*;\nimport java.util.logging.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link QSAdminAPI}.\n* It contains ten unit test cases for the {@link QSAdminAPI#logon()} method.\n*/\nclass QSAdminAPI_0Test {",
    "method_signature": "logon()",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// PasswordField.java\n/*\r\n * This file is part of the QuickServer library \r\n * Copyright (C) QuickServer.org\r\n *\r\n * Use, modification, copying and distribution of this software is subject to\r\n * the terms and conditions of the GNU Lesser General Public License. \r\n * You should have received a copy of the GNU LGP License along with this \r\n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\r\n *\r\n * For questions, suggestions, bug-reports, enhancement-requests etc.\r\n * visit http://www.quickserver.org\r\n *\r\n */\r\npackage org.quickserver.util.io;\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\nimport java.util.logging.*;\r\n\r\n/**\r\n * This class prompts the user for a password and attempts to mask\r\n * input.\r\n * @since 1.4\r\n */\r\npublic class PasswordField {\r\n\r\n    private static Logger logger \u003d Logger.getLogger(PasswordField.class.getName());\r\n\r\n    /**\r\n     * @param prompt The prompt to display to the user.\r\n     * @return The password as entered by the user.\r\n     */\r\n    public static final char[] getPassword(String prompt) throws IOException {\r\n        return getPassword(System.in, prompt);\r\n    }\r\n\r\n    /**\r\n     * @param in input stream to be used (e.g. System.in)\r\n     * @param prompt The prompt to display to the user.\r\n     * @return The password as entered by the user.\r\n     */\r\n    public static final char[] getPassword(InputStream in, String prompt) throws IOException {\r\n        MaskingThread maskingthread \u003d new MaskingThread(prompt);\r\n        Thread thread \u003d new Thread(maskingthread);\r\n        thread.start();\r\n        char[] lineBuffer;\r\n        char[] buf;\r\n        int i;\r\n        buf \u003d lineBuffer \u003d new char[128];\r\n        int room \u003d buf.length;\r\n        int offset \u003d 0;\r\n        int c;\r\n        loop: while (true) {\r\n            c \u003d in.read();\r\n            switch(c) {\r\n                case -1:\r\n                case \u0027\\n\u0027:\r\n                    break loop;\r\n                case \u0027\\r\u0027:\r\n                    int c2 \u003d in.read();\r\n                    if ((c2 !\u003d \u0027\\n\u0027) \u0026\u0026 (c2 !\u003d -1)) {\r\n                        if (!(in instanceof PushbackInputStream)) {\r\n                            in \u003d new PushbackInputStream(in);\r\n                        }\r\n                        ((PushbackInputStream) in).unread(c2);\r\n                    } else {\r\n                        break loop;\r\n                    }\r\n                default:\r\n                    if (--room \u003c 0) {\r\n                        buf \u003d new char[offset + 128];\r\n                        room \u003d buf.length - offset - 1;\r\n                        System.arraycopy(lineBuffer, 0, buf, 0, offset);\r\n                        Arrays.fill(lineBuffer, \u0027 \u0027);\r\n                        lineBuffer \u003d buf;\r\n                    }\r\n                    buf[offset++] \u003d (char) c;\r\n                    break;\r\n            }\r\n        }\r\n        maskingthread.stopMasking();\r\n        System.out.print(\"\\010\");\r\n        //Code to clear doskey on win nt/2000 - Alt+F7\r\n        String os \u003d System.getProperty(\"os.name\");\r\n        if (os !\u003d null \u0026\u0026 os.toLowerCase().startsWith(\"windows\")) {\r\n            try {\r\n                java.awt.Robot robot \u003d new java.awt.Robot();\r\n                robot.keyPress(java.awt.event.KeyEvent.VK_ALT);\r\n                robot.keyPress(java.awt.event.KeyEvent.VK_F7);\r\n                robot.keyRelease(java.awt.event.KeyEvent.VK_F7);\r\n                robot.keyRelease(java.awt.event.KeyEvent.VK_ALT);\r\n            } catch (Exception ignore) {\r\n                logger.warning(\"Could not clears command history: \" + ignore);\r\n            }\r\n        }\r\n        if (offset \u003d\u003d 0) {\r\n            return null;\r\n        }\r\n        char[] ret \u003d new char[offset];\r\n        System.arraycopy(buf, 0, ret, 0, offset);\r\n        Arrays.fill(buf, \u0027 \u0027);\r\n        return ret;\r\n    }\r\n}\r\n",
    "package": "org.quickserver.util.io",
    "classname": "PasswordField",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/util/io/PasswordField_0Test.java",
    "test_prompt": "// PasswordField_0Test.java\npackage org.quickserver.util.io;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PasswordField}.\n* It contains ten unit test cases for the {@link PasswordField#getPassword(String)} method.\n*/\nclass PasswordField_0Test {",
    "method_signature": "getPassword(String)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// PasswordField.java\n/*\r\n * This file is part of the QuickServer library \r\n * Copyright (C) QuickServer.org\r\n *\r\n * Use, modification, copying and distribution of this software is subject to\r\n * the terms and conditions of the GNU Lesser General Public License. \r\n * You should have received a copy of the GNU LGP License along with this \r\n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\r\n *\r\n * For questions, suggestions, bug-reports, enhancement-requests etc.\r\n * visit http://www.quickserver.org\r\n *\r\n */\r\npackage org.quickserver.util.io;\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\nimport java.util.logging.*;\r\n\r\n/**\r\n * This class prompts the user for a password and attempts to mask\r\n * input.\r\n * @since 1.4\r\n */\r\npublic class PasswordField {\r\n\r\n    private static Logger logger \u003d Logger.getLogger(PasswordField.class.getName());\r\n\r\n    /**\r\n     * @param prompt The prompt to display to the user.\r\n     * @return The password as entered by the user.\r\n     */\r\n    public static final char[] getPassword(String prompt) throws IOException {\r\n        return getPassword(System.in, prompt);\r\n    }\r\n\r\n    /**\r\n     * @param in input stream to be used (e.g. System.in)\r\n     * @param prompt The prompt to display to the user.\r\n     * @return The password as entered by the user.\r\n     */\r\n    public static final char[] getPassword(InputStream in, String prompt) throws IOException {\r\n        MaskingThread maskingthread \u003d new MaskingThread(prompt);\r\n        Thread thread \u003d new Thread(maskingthread);\r\n        thread.start();\r\n        char[] lineBuffer;\r\n        char[] buf;\r\n        int i;\r\n        buf \u003d lineBuffer \u003d new char[128];\r\n        int room \u003d buf.length;\r\n        int offset \u003d 0;\r\n        int c;\r\n        loop: while (true) {\r\n            c \u003d in.read();\r\n            switch(c) {\r\n                case -1:\r\n                case \u0027\\n\u0027:\r\n                    break loop;\r\n                case \u0027\\r\u0027:\r\n                    int c2 \u003d in.read();\r\n                    if ((c2 !\u003d \u0027\\n\u0027) \u0026\u0026 (c2 !\u003d -1)) {\r\n                        if (!(in instanceof PushbackInputStream)) {\r\n                            in \u003d new PushbackInputStream(in);\r\n                        }\r\n                        ((PushbackInputStream) in).unread(c2);\r\n                    } else {\r\n                        break loop;\r\n                    }\r\n                default:\r\n                    if (--room \u003c 0) {\r\n                        buf \u003d new char[offset + 128];\r\n                        room \u003d buf.length - offset - 1;\r\n                        System.arraycopy(lineBuffer, 0, buf, 0, offset);\r\n                        Arrays.fill(lineBuffer, \u0027 \u0027);\r\n                        lineBuffer \u003d buf;\r\n                    }\r\n                    buf[offset++] \u003d (char) c;\r\n                    break;\r\n            }\r\n        }\r\n        maskingthread.stopMasking();\r\n        System.out.print(\"\\010\");\r\n        //Code to clear doskey on win nt/2000 - Alt+F7\r\n        String os \u003d System.getProperty(\"os.name\");\r\n        if (os !\u003d null \u0026\u0026 os.toLowerCase().startsWith(\"windows\")) {\r\n            try {\r\n                java.awt.Robot robot \u003d new java.awt.Robot();\r\n                robot.keyPress(java.awt.event.KeyEvent.VK_ALT);\r\n                robot.keyPress(java.awt.event.KeyEvent.VK_F7);\r\n                robot.keyRelease(java.awt.event.KeyEvent.VK_F7);\r\n                robot.keyRelease(java.awt.event.KeyEvent.VK_ALT);\r\n            } catch (Exception ignore) {\r\n                logger.warning(\"Could not clears command history: \" + ignore);\r\n            }\r\n        }\r\n        if (offset \u003d\u003d 0) {\r\n            return null;\r\n        }\r\n        char[] ret \u003d new char[offset];\r\n        System.arraycopy(buf, 0, ret, 0, offset);\r\n        Arrays.fill(buf, \u0027 \u0027);\r\n        return ret;\r\n    }\r\n}\r\n",
    "package": "org.quickserver.util.io",
    "classname": "PasswordField",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/util/io/PasswordField_1Test.java",
    "test_prompt": "// PasswordField_1Test.java\npackage org.quickserver.util.io;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PasswordField}.\n* It contains ten unit test cases for the {@link PasswordField#getPassword(InputStream, String)} method.\n*/\nclass PasswordField_1Test {",
    "method_signature": "getPassword(InputStream, String)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// ByteBufferInputStream.java\n/*\r\n * This file is part of the QuickServer library \r\n * Copyright (C) QuickServer.org\r\n *\r\n * Use, modification, copying and distribution of this software is subject to\r\n * the terms and conditions of the GNU Lesser General Public License. \r\n * You should have received a copy of the GNU LGP License along with this \r\n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\r\n *\r\n * For questions, suggestions, bug-reports, enhancement-requests etc.\r\n * visit http://www.quickserver.org\r\n *\r\n */\r\npackage org.quickserver.util.io;\r\n\r\nimport java.io.*;\r\nimport java.nio.*;\r\nimport java.nio.charset.*;\r\nimport java.util.*;\r\nimport org.quickserver.net.server.ClientHandler;\r\nimport java.util.logging.*;\r\nimport org.quickserver.util.*;\r\n\r\n/**\r\n * This is an InputStream constructed from list of ByteBuffers. This is\r\n * used in non-blocking mode.\r\n * @since 1.4.5\r\n * @author Akshathkumar Shetty\r\n */\r\npublic class ByteBufferInputStream extends InputStream {\r\n\r\n    private static final Logger logger \u003d Logger.getLogger(ByteBufferInputStream.class.getName());\r\n\r\n    static {\r\n        logger.setLevel(Level.INFO);\r\n    }\r\n\r\n    /**\r\n     * Sets the debug flag.\r\n     */\r\n    public static void setDebug(boolean flag) {\r\n        if (flag)\r\n            logger.setLevel(Level.FINEST);\r\n        else\r\n            logger.setLevel(Level.INFO);\r\n    }\r\n\r\n    /**\r\n     * @since 1.4.7\r\n     */\r\n    public static boolean isLoggable(Level level) {\r\n        return logger.isLoggable(level);\r\n    }\r\n\r\n    private final ArrayList bufferList;\r\n\r\n    private ClientHandler handler;\r\n\r\n    private CharsetDecoder decoder;\r\n\r\n    private CharsetEncoder encoder;\r\n\r\n    private StringBuilder strings;\r\n\r\n    private int pos \u003d 0;\r\n\r\n    private int index \u003d -1;\r\n\r\n    private int start \u003d 0;\r\n\r\n    private boolean lookingForLineFeed \u003d false;\r\n\r\n    public ByteBufferInputStream(ArrayList bufferList, ClientHandler handler, String charset) {\r\n        if (bufferList \u003d\u003d null || handler \u003d\u003d null)\r\n            throw new IllegalArgumentException(\"ArrayList or ClientHandler was null.\");\r\n        this.bufferList \u003d bufferList;\r\n        this.handler \u003d handler;\r\n        Charset _charset \u003d Charset.forName(charset);\r\n        decoder \u003d _charset.newDecoder();\r\n        encoder \u003d _charset.newEncoder();\r\n        strings \u003d new StringBuilder();\r\n    }\r\n\r\n    public synchronized int availableOnlyInByteBuffer() {\r\n        int count \u003d 0;\r\n        ByteBuffer byteBuffer \u003d null;\r\n        int size \u003d bufferList.size();\r\n        for (int c \u003d 0; c \u003c size; c++) {\r\n            byteBuffer \u003d (ByteBuffer) bufferList.get(c);\r\n            count +\u003d byteBuffer.remaining();\r\n        }\r\n        logger.finest(\"count: \" + count);\r\n        return count;\r\n    }\r\n\r\n    public synchronized int available() {\r\n        int count \u003d 0;\r\n        ByteBuffer byteBuffer \u003d null;\r\n        if (lookingForLineFeed) {\r\n            char c \u003d \u0027\\0\u0027;\r\n            if (strings.length() !\u003d 0) {\r\n                c \u003d strings.charAt(0);\r\n                if (c \u003d\u003d \u0027\\n\u0027) {\r\n                    strings.deleteCharAt(0);\r\n                    lookingForLineFeed \u003d false;\r\n                }\r\n            } else {\r\n                while (!bufferList.isEmpty()) {\r\n                    byteBuffer \u003d (ByteBuffer) bufferList.get(0);\r\n                    if (byteBuffer.remaining() \u003d\u003d 0) {\r\n                        returnBufferBack();\r\n                        continue;\r\n                    }\r\n                    int p \u003d byteBuffer.position();\r\n                    c \u003d (char) byteBuffer.get(p);\r\n                    if (c \u003d\u003d \u0027\\n\u0027) {\r\n                        //move position\r\n                        byteBuffer.get();\r\n                        lookingForLineFeed \u003d false;\r\n                    }\r\n                    break;\r\n                }\r\n                //end of while\r\n            }\r\n        }\r\n        count +\u003d strings.length();\r\n        int size \u003d bufferList.size();\r\n        for (int c \u003d 0; c \u003c size; c++) {\r\n            byteBuffer \u003d (ByteBuffer) bufferList.get(c);\r\n            count +\u003d byteBuffer.remaining();\r\n        }\r\n        //logger.finest(\"count: \"+count);\r\n        return count;\r\n    }\r\n\r\n    public synchronized void close() throws IOException {\r\n        if (handler.getSocketChannel() !\u003d null)\r\n            handler.getSocketChannel().close();\r\n        //handler.closeConnection();\r\n    }\r\n\r\n    public boolean markSupported() {\r\n        return false;\r\n    }\r\n\r\n    public synchronized int read() throws IOException {\r\n        handler.isConnected();\r\n        if (strings.length() !\u003d 0) {\r\n            addStringsBackAsBuffer();\r\n        }\r\n        if (bufferList.isEmpty()) {\r\n            try {\r\n                wait();\r\n            } catch (InterruptedException ie) {\r\n                logger.warning(\"InterruptedException: \" + ie);\r\n                return -1;\r\n            }\r\n            if (bufferList.isEmpty())\r\n                return -1;\r\n        }\r\n        ByteBuffer byteBuffer \u003d null;\r\n        while (!bufferList.isEmpty()) {\r\n            byteBuffer \u003d (ByteBuffer) bufferList.get(0);\r\n            if (byteBuffer.remaining() \u003d\u003d 0) {\r\n                returnBufferBack();\r\n                continue;\r\n            }\r\n            if (lookingForLineFeed) {\r\n                int lflfChar \u003d (int) byteBuffer.get();\r\n                lookingForLineFeed \u003d false;\r\n                if (lflfChar \u003d\u003d (int) \u0027\\n\u0027) {\r\n                    continue;\r\n                } else {\r\n                    return lflfChar;\r\n                }\r\n            } else {\r\n                return (int) byteBuffer.get();\r\n            }\r\n        }\r\n        return read();\r\n    }\r\n\r\n    public int read(byte[] b) throws IOException {\r\n        return read(b, 0, b.length);\r\n    }\r\n\r\n    public synchronized int read(byte[] b, int off, int len) throws IOException {\r\n        handler.isConnected();\r\n        if (strings.length() !\u003d 0) {\r\n            addStringsBackAsBuffer();\r\n        }\r\n        if (bufferList.isEmpty()) {\r\n            try {\r\n                wait();\r\n            } catch (InterruptedException ie) {\r\n                logger.warning(\"InterruptedException: \" + ie);\r\n                //ie.printStackTrace();\r\n                return -1;\r\n            }\r\n            if (bufferList.isEmpty())\r\n                return -1;\r\n        }\r\n        ByteBuffer byteBuffer \u003d null;\r\n        int read \u003d 0;\r\n        int remaining \u003d 0;\r\n        int toRead \u003d len;\r\n        do {\r\n            byteBuffer \u003d (ByteBuffer) bufferList.get(0);\r\n            remaining \u003d byteBuffer.remaining();\r\n            if (remaining \u003d\u003d 0) {\r\n                returnBufferBack();\r\n                continue;\r\n            }\r\n            if (lookingForLineFeed) {\r\n                int p \u003d byteBuffer.position();\r\n                byte lflfChar \u003d byteBuffer.get(p);\r\n                lookingForLineFeed \u003d false;\r\n                if (lflfChar \u003d\u003d (byte) \u0027\\n\u0027) {\r\n                    //move position\r\n                    byteBuffer.get();\r\n                    continue;\r\n                }\r\n            }\r\n            if (remaining \u003c toRead) {\r\n                byteBuffer.get(b, off, remaining);\r\n                off \u003d off + remaining;\r\n                read \u003d read + remaining;\r\n                toRead \u003d toRead - remaining;\r\n            } else {\r\n                byteBuffer.get(b, off, toRead);\r\n                read \u003d read + toRead;\r\n                return read;\r\n            }\r\n        } while (!bufferList.isEmpty());\r\n        return read;\r\n    }\r\n\r\n    public long skip(long n) throws IOException {\r\n        if (n \u003c 0)\r\n            return 0;\r\n        int s \u003d 0;\r\n        for (; s \u003c n; s++) {\r\n            if (read() \u003d\u003d -1)\r\n                break;\r\n        }\r\n        return s;\r\n    }\r\n\r\n    private void addStringsBackAsBuffer() {\r\n        try {\r\n            ByteBuffer borrowBuffer \u003d null;\r\n            ByteBuffer bb \u003d encoder.encode(CharBuffer.wrap(strings));\r\n            strings.setLength(0);\r\n            do {\r\n                if (borrowBuffer \u003d\u003d null) {\r\n                    borrowBuffer \u003d (ByteBuffer) handler.getServer().getByteBufferPool().borrowObject();\r\n                }\r\n                borrowBuffer.put(bb.get());\r\n                if (borrowBuffer.hasRemaining() \u003d\u003d false) {\r\n                    borrowBuffer.flip();\r\n                    bufferList.add(0, borrowBuffer);\r\n                    borrowBuffer \u003d null;\r\n                }\r\n            } while (bb.hasRemaining());\r\n            if (borrowBuffer !\u003d null) {\r\n                borrowBuffer.flip();\r\n                bufferList.add(0, borrowBuffer);\r\n            }\r\n        } catch (Exception er) {\r\n            logger.warning(\"Error : \" + er);\r\n        }\r\n        start \u003d 0;\r\n        index \u003d -1;\r\n        pos \u003d 0;\r\n    }\r\n\r\n    private void returnBufferBack() {\r\n        returnBufferBack((ByteBuffer) bufferList.remove(0));\r\n    }\r\n\r\n    private void returnBufferBack(ByteBuffer byteBuffer) {\r\n        try {\r\n            handler.getServer().getByteBufferPool().returnObject(byteBuffer);\r\n        } catch (Exception er) {\r\n            logger.warning(\"Error while returning ByteBuffer to pool: \" + er);\r\n        }\r\n    }\r\n\r\n    //-- extra helpers\r\n    /**\r\n     * Checks if a line of String is ready to be read.\r\n     * @throws IOException if connection is lost or closed.\r\n     */\r\n    public synchronized boolean isLineReady() throws IOException {\r\n        handler.isConnected();\r\n        boolean result \u003d false;\r\n        result \u003d isLineReadyForStringBuilder();\r\n        if (result \u003d\u003d true || bufferList.isEmpty()) {\r\n            if (logger.isLoggable(Level.FINEST))\r\n                logger.finest(\"result: \" + result);\r\n            return result;\r\n        }\r\n        ByteBuffer byteBuffer \u003d null;\r\n        CharBuffer charBuffer \u003d null;\r\n        while (result \u003d\u003d false \u0026\u0026 !bufferList.isEmpty()) {\r\n            byteBuffer \u003d (ByteBuffer) bufferList.get(0);\r\n            if (byteBuffer.remaining() \u003d\u003d 0) {\r\n                returnBufferBack();\r\n                continue;\r\n            }\r\n            charBuffer \u003d decoder.decode(byteBuffer);\r\n            if (charBuffer \u003d\u003d null) {\r\n                returnBufferBack();\r\n                continue;\r\n            }\r\n            strings.append(charBuffer);\r\n            returnBufferBack();\r\n            result \u003d isLineReadyForStringBuilder();\r\n        }\r\n        //end of while\r\n        if (logger.isLoggable(Level.FINEST))\r\n            logger.finest(\"result: \" + result);\r\n        return result;\r\n    }\r\n\r\n    private boolean isLineReadyForStringBuilder() {\r\n        if (index !\u003d -1)\r\n            return true;\r\n        int stringsLength \u003d strings.length();\r\n        while (pos \u003c stringsLength) {\r\n            char c \u003d strings.charAt(pos);\r\n            if (c \u003d\u003d \u0027\\n\u0027) {\r\n                if (lookingForLineFeed) {\r\n                    strings.deleteCharAt(0);\r\n                    stringsLength--;\r\n                    lookingForLineFeed \u003d false;\r\n                    continue;\r\n                } else {\r\n                    index \u003d pos;\r\n                    pos++;\r\n                    return true;\r\n                }\r\n            }\r\n            if (c \u003d\u003d \u0027\\r\u0027) {\r\n                index \u003d pos;\r\n                lookingForLineFeed \u003d true;\r\n                pos++;\r\n                return true;\r\n            } else {\r\n                pos++;\r\n                lookingForLineFeed \u003d false;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Reads a line of String if ready. If line is not yet ready this will\r\n     * block. To find out if the line is ready use \u003ccode\u003eisLineReady()\u003c/code\u003e\r\n     * @see #isLineReady()\r\n     */\r\n    public synchronized String readLine() throws IOException {\r\n        if (index \u003d\u003d -1) {\r\n            while (isLineReady() \u003d\u003d false) {\r\n                try {\r\n                    wait();\r\n                } catch (InterruptedException ie) {\r\n                    logger.warning(\"InterruptedException: \" + ie);\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n        int stringsLength \u003d strings.length();\r\n        Assertion.affirm(index \u003c\u003d stringsLength);\r\n        String data \u003d strings.substring(start, index);\r\n        if (pos \u003c stringsLength)\r\n            strings.delete(0, pos);\r\n        else\r\n            strings.setLength(0);\r\n        start \u003d 0;\r\n        pos \u003d start;\r\n        index \u003d -1;\r\n        return data;\r\n    }\r\n\r\n    public void dumpContent() {\r\n        if (logger.isLoggable(Level.FINE) \u003d\u003d false) {\r\n            //logger.warning(\"Can\u0027t precede. Logging level FINE is not loggable! \");\r\n            return;\r\n        }\r\n        logger.fine(\"Start of dump..\");\r\n        synchronized (bufferList) {\r\n            int size \u003d bufferList.size();\r\n            ByteBuffer byteBuffer \u003d null;\r\n            if (strings.length() !\u003d 0) {\r\n                logger.fine(\"[decoded] \" + strings);\r\n            }\r\n            for (int c \u003d 0; c \u003c size; c++) {\r\n                byteBuffer \u003d (ByteBuffer) bufferList.get(c);\r\n                try {\r\n                    logger.fine(\"[\" + c + \"] \" + decoder.decode(byteBuffer.duplicate()));\r\n                } catch (Exception e) {\r\n                    logger.fine(\"[\" + c + \"] Error : \" + e);\r\n                }\r\n            }\r\n        }\r\n        logger.fine(\"End of dump..\");\r\n    }\r\n}\r\n",
    "package": "org.quickserver.util.io",
    "classname": "ByteBufferInputStream",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/util/io/ByteBufferInputStream_8Test.java",
    "test_prompt": "// ByteBufferInputStream_8Test.java\npackage org.quickserver.util.io;\n\nimport java.io.*;\nimport java.nio.*;\nimport java.nio.charset.*;\nimport java.util.*;\nimport org.quickserver.net.server.ClientHandler;\nimport java.util.logging.*;\nimport org.quickserver.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ByteBufferInputStream}.\n* It contains ten unit test cases for the {@link ByteBufferInputStream#readLine()} method.\n*/\nclass ByteBufferInputStream_8Test {",
    "method_signature": "readLine()",
    "suffix": "8"
  },
  {
    "numberTests": "ten",
    "original_code": "// ClassUtil.java\n/*\r\n * This file is part of the QuickServer library \r\n * Copyright (C) QuickServer.org\r\n *\r\n * Use, modification, copying and distribution of this software is subject to\r\n * the terms and conditions of the GNU Lesser General Public License. \r\n * You should have received a copy of the GNU LGP License along with this \r\n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\r\n *\r\n * For questions, suggestions, bug-reports, enhancement-requests etc.\r\n * visit http://www.quickserver.org\r\n *\r\n */\r\npackage org.quickserver.util;\r\n\r\nimport java.util.*;\r\nimport java.io.*;\r\nimport java.net.*;\r\nimport org.quickserver.util.io.*;\r\nimport java.util.logging.*;\r\n\r\n/**\r\n * A utility class to load class.\r\n * @author Akshathkumar Shetty\r\n * @since 1.3.2\r\n */\r\npublic class ClassUtil {\r\n\r\n    private static Logger logger \u003d Logger.getLogger(ClassUtil.class.getName());\r\n\r\n    /**\r\n     * Tries to load the classes present in the array\r\n     * passed has second parameter from\r\n     * the ClassLoader passed has first parameter.\r\n     * Returns the HashMap of all the classed successfully loaded.\r\n     * @param classLoader ClassLoader used to find the class\r\n     * @param classes[] array of classes to load.\r\n     */\r\n    public static Map loadClass(ClassLoader classLoader, String[] classNames) throws Exception {\r\n        Class classloded \u003d null;\r\n        HashMap classHash \u003d new HashMap();\r\n        for (int i \u003d 0; i \u003c classNames.length; i++) {\r\n            try {\r\n                classloded \u003d classLoader.loadClass(classNames[i]);\r\n                classHash.put(classNames[i], classloded);\r\n            } catch (Exception e) {\r\n                logger.warning(\"Could not load classes : \" + e);\r\n            }\r\n        }\r\n        return classHash;\r\n    }\r\n\r\n    /**\r\n     * Returns the ClassLoader to all the jars present in the\r\n     * dir passed has first parameter.\r\n     * @param jarDir path to the directory containing the jars\r\n     */\r\n    public static ClassLoader getClassLoaderFromJars(String jarDir) throws Exception {\r\n        logger.fine(\"Getting ClassLoader for jars in \" + jarDir);\r\n        File file \u003d new File(jarDir);\r\n        ArrayList list \u003d new ArrayList();\r\n        File[] jars \u003d file.listFiles(new JarFileList());\r\n        for (int j \u003d 0; j \u003c jars.length; j++) {\r\n            list.add(jars[j].toURL());\r\n        }\r\n        Object[] array \u003d list.toArray();\r\n        URL[] jarurl \u003d new URL[array.length];\r\n        for (int i \u003d 0; i \u003c array.length; i++) {\r\n            jarurl[i] \u003d (URL) array[i];\r\n        }\r\n        URLClassLoader classLoader \u003d URLClassLoader.newInstance(jarurl);\r\n        return classLoader;\r\n    }\r\n\r\n    /**\r\n     * Returns the ClassLoader to a jar\r\n     * @since 1.3.3\r\n     */\r\n    public static ClassLoader getClassLoaderFromJar(String jarPath) throws Exception {\r\n        File file \u003d new File(jarPath);\r\n        logger.fine(\"Getting ClassLoader for \" + file.getCanonicalPath());\r\n        URL[] jarurl \u003d { file.toURL() };\r\n        URLClassLoader classLoader \u003d URLClassLoader.newInstance(jarurl);\r\n        return classLoader;\r\n    }\r\n\r\n    /**\r\n     * Returns the ClassLoader\r\n     * @since 1.3.3\r\n     */\r\n    public static ClassLoader getClassLoader(String path) throws Exception {\r\n        File file \u003d new File(path);\r\n        if (file.canRead() \u003d\u003d false) {\r\n            logger.warning(\"Could not read path: \" + path);\r\n            return null;\r\n        }\r\n        if (file.isDirectory())\r\n            return getClassLoaderFromJars(path);\r\n        else\r\n            return getClassLoaderFromJar(path);\r\n    }\r\n}\r\n",
    "package": "org.quickserver.util",
    "classname": "ClassUtil",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/util/ClassUtil_1Test.java",
    "test_prompt": "// ClassUtil_1Test.java\npackage org.quickserver.util;\n\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\nimport org.quickserver.util.io.*;\nimport java.util.logging.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassUtil}.\n* It contains ten unit test cases for the {@link ClassUtil#getClassLoaderFromJars(String)} method.\n*/\nclass ClassUtil_1Test {",
    "method_signature": "getClassLoaderFromJars(String)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// ClientPool.java\n/*\r\n * This file is part of the QuickServer library \r\n * Copyright (C) QuickServer.org\r\n *\r\n * Use, modification, copying and distribution of this software is subject to\r\n * the terms and conditions of the GNU Lesser General Public License. \r\n * You should have received a copy of the GNU LGP License along with this \r\n * library; if not, you can download a copy from \u003chttp://www.quickserver.org/\u003e.\r\n *\r\n * For questions, suggestions, bug-reports, enhancement-requests etc.\r\n * visit http://www.quickserver.org\r\n *\r\n */\r\npackage org.quickserver.util.pool.thread;\r\n\r\nimport java.util.*;\r\nimport org.quickserver.util.pool.*;\r\nimport org.apache.commons.pool.*;\r\nimport org.quickserver.net.server.*;\r\nimport org.quickserver.util.xmlreader.PoolConfig;\r\nimport java.util.logging.*;\r\n\r\n/**\r\n * This is a class for managing the pool of threads for\r\n * handling clients.\r\n * @author Akshathkumar Shetty\r\n * @since 1.3\r\n */\r\npublic class ClientPool {\r\n\r\n    private static final Logger logger \u003d Logger.getLogger(ClientPool.class.getName());\r\n\r\n    protected List clients \u003d new ArrayList(3);\r\n\r\n    protected ObjectPool pool;\r\n\r\n    protected PoolConfig poolConfig;\r\n\r\n    //v1.4.6\r\n    private int countNioWriteThreads;\r\n\r\n    private int maxThreadsForNioWrite \u003d 10;\r\n\r\n    public ClientPool(QSObjectPool objectPool, PoolConfig poolConfig) {\r\n        this.poolConfig \u003d poolConfig;\r\n        pool \u003d objectPool;\r\n    }\r\n\r\n    public ObjectPool getObjectPool() {\r\n        return pool;\r\n    }\r\n\r\n    public void addClient(Runnable r) throws NoSuchElementException {\r\n        addClient(r, false);\r\n    }\r\n\r\n    public synchronized void addClient(Runnable r, boolean keepObjOnFail) throws NoSuchElementException {\r\n        //logger.finest(\"Adding Runnable: \"+r);\r\n        clients.add(r);\r\n        ClientThread ct \u003d null;\r\n        try {\r\n            ct \u003d (ClientThread) pool.borrowObject();\r\n            if (ct.isReady() \u003d\u003d false) {\r\n                //ct.start();\r\n                //timeout was just in case :-)\r\n                wait(500);\r\n                //Thread.yield();\r\n            } else {\r\n                synchronized (ct) {\r\n                    ct.notify();\r\n                }\r\n            }\r\n        } catch (NoSuchElementException e) {\r\n            logger.info(\"No free threads: \" + e);\r\n            if (keepObjOnFail \u003d\u003d false)\r\n                clients.remove(r);\r\n            throw e;\r\n        } catch (Exception e) {\r\n            logger.warning(\"Error in addClient: \" + e + \", Closing client: \" + (ClientHandler) r);\r\n            try {\r\n                ((ClientHandler) r).forceClose();\r\n            } catch (Exception er) {\r\n                logger.warning(\"Error closing client: \" + er);\r\n            }\r\n            try {\r\n                if (ct !\u003d null)\r\n                    pool.returnObject(ct);\r\n            } catch (Exception er) {\r\n                logger.warning(\"Error in returning thread: \" + er);\r\n            }\r\n        }\r\n    }\r\n\r\n    public synchronized void returnObject(Object object) {\r\n        try {\r\n            pool.returnObject(object);\r\n        } catch (Exception e) {\r\n            logger.warning(\"IGONRED: Error while returning object : \" + e);\r\n            ((Thread) object).interrupt();\r\n        }\r\n    }\r\n\r\n    public synchronized Runnable getClient() {\r\n        if (clients.isEmpty()) {\r\n            return null;\r\n        }\r\n        return (Runnable) clients.remove(0);\r\n    }\r\n\r\n    /**\r\n     * @since 1.4.5\r\n     */\r\n    public boolean isClientAvailable() {\r\n        if (clients.isEmpty()) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    protected void finalize() throws Throwable {\r\n        try {\r\n            close();\r\n        } catch (Exception e) {\r\n            logger.warning(\"IGONRED:finalize in pool close : \" + e);\r\n        }\r\n        super.finalize();\r\n    }\r\n\r\n    public void close() throws Exception {\r\n        pool.close();\r\n    }\r\n\r\n    public void clear() throws Exception {\r\n        pool.clear();\r\n    }\r\n\r\n    /**\r\n     * Return the number of instances currently borrowed from my pool.\r\n     * @since 1.4.1\r\n     */\r\n    public int getNumActive() {\r\n        return pool.getNumActive();\r\n    }\r\n\r\n    /**\r\n     * Return the number of instances currently idle in my pool.\r\n     * @since 1.4.1\r\n     */\r\n    public int getNumIdle() {\r\n        return pool.getNumIdle();\r\n    }\r\n\r\n    /**\r\n     * Returns iterator containing all the active\r\n     * threads i.e ClientHandler handling connected clients.\r\n     * @since 1.3.1\r\n     */\r\n    public final Iterator getAllClientThread() {\r\n        return ((QSObjectPool) pool).getAllActiveObjects();\r\n    }\r\n\r\n    public Object getObjectToSynchronize() {\r\n        return ((QSObjectPool) pool).getObjectToSynchronize();\r\n    }\r\n\r\n    /**\r\n     * Returns PoolConfig object that configured this pool\r\n     * @since 1.4.5\r\n     */\r\n    public PoolConfig getPoolConfig() {\r\n        return poolConfig;\r\n    }\r\n\r\n    /**\r\n     * Sets the maximum threads allowed for nio write. If set to 0 or less no limit is\r\n     * imposed.\r\n     * @since 1.4.6\r\n     */\r\n    public void setMaxThreadsForNioWrite(int count) {\r\n        this.maxThreadsForNioWrite \u003d count;\r\n    }\r\n\r\n    /**\r\n     * Returns the maximum threads allowed for nio write\r\n     * @since 1.4.6\r\n     */\r\n    public int getMaxThreadsForNioWrite() {\r\n        return maxThreadsForNioWrite;\r\n    }\r\n\r\n    /**\r\n     * Notifies when NIO write is complete.\r\n     * @since 1.4.6\r\n     */\r\n    protected void nioWriteEnd() {\r\n        countNioWriteThreads--;\r\n        if (countNioWriteThreads \u003c 0) {\r\n            logger.warning(\"countNioWriteThreads should not go less than 0\");\r\n            countNioWriteThreads \u003d 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Notifies when NIO write is about to start.\r\n     * @since 1.4.6\r\n     */\r\n    protected void nioWriteStart() {\r\n        countNioWriteThreads++;\r\n    }\r\n\r\n    /**\r\n     * Method to suggest if nio write should be sent for processing.\r\n     * @since 1.4.6\r\n     */\r\n    public boolean shouldNioWriteHappen() {\r\n        if (maxThreadsForNioWrite \u003c\u003d 0 || countNioWriteThreads \u003c maxThreadsForNioWrite) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n",
    "package": "org.quickserver.util.pool.thread",
    "classname": "ClientPool",
    "id": "/EvoSuiteBenchmark/original/93_quickserver/src/main/java/org/quickserver/util/pool/thread/ClientPool.java",
    "test_prompt": "// ClientPoolTest.java\npackage org.quickserver.util.pool.thread;\n\nimport java.util.*;\nimport org.quickserver.util.pool.*;\nimport org.apache.commons.pool.*;\nimport org.quickserver.net.server.*;\nimport org.quickserver.util.xmlreader.PoolConfig;\nimport java.util.logging.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClientPool}.\n* It contains ten unit test cases for the {@link ClientPool#shouldNioWriteHappen()} method.\n*/\nclass ClientPoolTest {",
    "method_signature": "shouldNioWriteHappen()",
    "suffix": ""
  }
]