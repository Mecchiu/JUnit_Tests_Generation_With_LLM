[
  {
    "numberTests": "ten",
    "original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * \u003cp\u003e\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c \u003d javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS \u003d 1, NO_INHERITED_METHODS \u003d 2;\r\n\r\n    private String[] cMethods, fndMethods \u003d null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() !\u003d null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c !\u003d java.lang.Object.class \u0026\u0026 !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c \u003d getClass(name);\r\n        if (c \u003d\u003d null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m \u003d c.getMethods();\r\n        Object[] obj \u003d null;\r\n        cMethods \u003d getData(m);\r\n        if (cMethods !\u003d null) {\r\n            if (c !\u003d java.lang.Object.class) {\r\n                StringList tempList \u003d new StringList();\r\n                for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") \u003d\u003d -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods \u003d tempList.toArray();\r\n            }\r\n            for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                if (!statusAbstract \u0026\u0026 cMethods[count].indexOf(\"abstract\") !\u003d -1)\r\n                    statusAbstract \u003d true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan \u003d locManager;\r\n        knownPackages \u003d dirMan.getPackageList();\r\n        c \u003d getClass(name);\r\n        if (c \u003d\u003d null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m \u003d c.getMethods();\r\n        Object[] obj \u003d null;\r\n        cMethods \u003d getData(m);\r\n        if (cMethods !\u003d null) {\r\n            if (c !\u003d java.lang.Object.class) {\r\n                StringList tempList \u003d new StringList();\r\n                for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") \u003d\u003d -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods \u003d tempList.toArray();\r\n            }\r\n            for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                if (!statusAbstract \u0026\u0026 cMethods[count].indexOf(\"abstract\") !\u003d -1)\r\n                    statusAbstract \u003d true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f \u003d c.getFields();\r\n        length \u003d f.length;\r\n        String[] StringData \u003d null;\r\n        if (length \u003e 0) {\r\n            StringData \u003d new String[length];\r\n            String tempStr;\r\n            Object obj \u003d new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count \u003d 0; count \u003c length; count++) {\r\n                try {\r\n                    tempStr \u003d f[count] + \"\u003d\" + f[count].get(obj);\r\n                    StringData[count] \u003d tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr \u003d f[count] + \"\u003d ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] \u003d tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr \u003d f[count] + \"\u003d ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] \u003d tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray \u003d null;\r\n        if (cMethods !\u003d null) {\r\n            tempArray \u003d new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug \u0026\u0026 tempArray \u003d\u003d null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods \u003d\u003d null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d cMethods;\r\n        StringList tempList \u003d new StringList();\r\n        for (int i \u003d 0; i \u003c cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + \u0027.\u0027) !\u003d -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data \u003d tempList.toArray();\r\n        else\r\n            data \u003d null;\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr \u003d c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d getData(constr);\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter \u003d c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d getData(inter);\r\n        if (c !\u003d java.lang.Object.class \u0026\u0026 !c.isInterface()) {\r\n            Class superC \u003d c.getSuperclass();\r\n            TreeSet\u003cString\u003e hInterfaces \u003d new TreeSet\u003cString\u003e();\r\n            int i \u003d 0;\r\n            if (data !\u003d null)\r\n                for (i \u003d 0; i \u003c data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC !\u003d null \u0026\u0026 superC !\u003d java.lang.Object.class) {\r\n                inter \u003d superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data \u003d getData(inter);\r\n                if (data !\u003d null)\r\n                    for (i \u003d 0; i \u003c data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC \u003d superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() !\u003d 0) {\r\n                data \u003d new String[hInterfaces.size()];\r\n                Iterator it \u003d hInterfaces.iterator();\r\n                i \u003d 0;\r\n                while (it.hasNext()) {\r\n                    data[i] \u003d (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length \u003d m.length;\r\n        if (length \u003d\u003d 0)\r\n            return null;\r\n        String[] StringData \u003d new String[length];\r\n        String tempStr;\r\n        for (count \u003d 0; count \u003c m.length; count++) {\r\n            tempStr \u003d m[count].toString();\r\n            StringData[count] \u003d tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length \u003d m.length;\r\n        if (length \u003d\u003d 0)\r\n            return null;\r\n        String[] StringData \u003d new String[length];\r\n        String tempStr;\r\n        for (count \u003d 0; count \u003c m.length; count++) {\r\n            tempStr \u003d m[count].getName();\r\n            StringData[count] \u003d tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * \u003cp\u003e\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr \u003d\u003d null)\r\n            return null;\r\n        fndMethods \u003d StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods !\u003d null) {\r\n            String[] tempArray \u003d new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * \u003cp\u003e\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr \u003d\u003d null)\r\n            return null;\r\n        fndMethods \u003d StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods !\u003d null) {\r\n            String[] tempArray \u003d new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods \u003d\u003d null || pos \u003e fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn\u0027t out of range\r\n            String tempStr \u003d fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end \u003d tempStr.indexOf(\")\");\r\n                tempStr \u003d tempStr.substring(0, end + 1);\r\n                begin \u003d tempStr.lastIndexOf(\" \");\r\n                tempStr \u003d tempStr.substring(begin + 1, tempStr.length());\r\n                begin \u003d tempStr.indexOf(\"(\");\r\n                end \u003d tempStr.lastIndexOf(\".\", begin);\r\n                className \u003d tempStr.substring(0, end);\r\n                methodName \u003d tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className\u003d\" + className);\r\n                methClass \u003d ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass\u003d\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass \u003d\u003d null)\r\n                    return null;\r\n                return methClass.getPackage() !\u003d null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass \u003d\u003d null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length \u003d array.length;\r\n        if (length \u003d\u003d 0)\r\n            return;\r\n        for (count \u003d 0; count \u003c length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr \u003d name;\r\n        Class tempClass \u003d null;\r\n        tempClass \u003d tryClass(name);\r\n        if (tempClass \u003d\u003d null) {\r\n            for (int i \u003d 0; i \u003c knownPackages.length; i++) {\r\n                tempStr \u003d knownPackages[i] + name;\r\n                tempClass \u003d tryClass(tempStr);\r\n                if (tempClass !\u003d null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass \u003d null;\r\n        try {\r\n            if (name !\u003d null)\r\n                tempClass \u003d Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c !\u003d java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 \u003d System.currentTimeMillis();\r\n        debug \u003d true;\r\n        String name \u003d null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length \u003e 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name \u003d args[1];\r\n            } else {\r\n                name \u003d args[0];\r\n                try {\r\n                    myClassInfo \u003d new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo \u003d new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
    "package": "com.jstevh.viewer",
    "classname": "ClassInfo",
    "id": "/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_0Test.java",
    "test_prompt": "// ClassInfo_0Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\n//8-01-04 Handled exceptions with fields.   ___JSH\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#printFields()} method.\n*/\nclass ClassInfo_0Test {",
    "method_signature": "printFields()",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * \u003cp\u003e\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c \u003d javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS \u003d 1, NO_INHERITED_METHODS \u003d 2;\r\n\r\n    private String[] cMethods, fndMethods \u003d null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() !\u003d null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c !\u003d java.lang.Object.class \u0026\u0026 !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c \u003d getClass(name);\r\n        if (c \u003d\u003d null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m \u003d c.getMethods();\r\n        Object[] obj \u003d null;\r\n        cMethods \u003d getData(m);\r\n        if (cMethods !\u003d null) {\r\n            if (c !\u003d java.lang.Object.class) {\r\n                StringList tempList \u003d new StringList();\r\n                for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") \u003d\u003d -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods \u003d tempList.toArray();\r\n            }\r\n            for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                if (!statusAbstract \u0026\u0026 cMethods[count].indexOf(\"abstract\") !\u003d -1)\r\n                    statusAbstract \u003d true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan \u003d locManager;\r\n        knownPackages \u003d dirMan.getPackageList();\r\n        c \u003d getClass(name);\r\n        if (c \u003d\u003d null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m \u003d c.getMethods();\r\n        Object[] obj \u003d null;\r\n        cMethods \u003d getData(m);\r\n        if (cMethods !\u003d null) {\r\n            if (c !\u003d java.lang.Object.class) {\r\n                StringList tempList \u003d new StringList();\r\n                for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") \u003d\u003d -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods \u003d tempList.toArray();\r\n            }\r\n            for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                if (!statusAbstract \u0026\u0026 cMethods[count].indexOf(\"abstract\") !\u003d -1)\r\n                    statusAbstract \u003d true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f \u003d c.getFields();\r\n        length \u003d f.length;\r\n        String[] StringData \u003d null;\r\n        if (length \u003e 0) {\r\n            StringData \u003d new String[length];\r\n            String tempStr;\r\n            Object obj \u003d new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count \u003d 0; count \u003c length; count++) {\r\n                try {\r\n                    tempStr \u003d f[count] + \"\u003d\" + f[count].get(obj);\r\n                    StringData[count] \u003d tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr \u003d f[count] + \"\u003d ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] \u003d tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr \u003d f[count] + \"\u003d ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] \u003d tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray \u003d null;\r\n        if (cMethods !\u003d null) {\r\n            tempArray \u003d new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug \u0026\u0026 tempArray \u003d\u003d null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods \u003d\u003d null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d cMethods;\r\n        StringList tempList \u003d new StringList();\r\n        for (int i \u003d 0; i \u003c cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + \u0027.\u0027) !\u003d -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data \u003d tempList.toArray();\r\n        else\r\n            data \u003d null;\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr \u003d c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d getData(constr);\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter \u003d c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d getData(inter);\r\n        if (c !\u003d java.lang.Object.class \u0026\u0026 !c.isInterface()) {\r\n            Class superC \u003d c.getSuperclass();\r\n            TreeSet\u003cString\u003e hInterfaces \u003d new TreeSet\u003cString\u003e();\r\n            int i \u003d 0;\r\n            if (data !\u003d null)\r\n                for (i \u003d 0; i \u003c data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC !\u003d null \u0026\u0026 superC !\u003d java.lang.Object.class) {\r\n                inter \u003d superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data \u003d getData(inter);\r\n                if (data !\u003d null)\r\n                    for (i \u003d 0; i \u003c data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC \u003d superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() !\u003d 0) {\r\n                data \u003d new String[hInterfaces.size()];\r\n                Iterator it \u003d hInterfaces.iterator();\r\n                i \u003d 0;\r\n                while (it.hasNext()) {\r\n                    data[i] \u003d (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length \u003d m.length;\r\n        if (length \u003d\u003d 0)\r\n            return null;\r\n        String[] StringData \u003d new String[length];\r\n        String tempStr;\r\n        for (count \u003d 0; count \u003c m.length; count++) {\r\n            tempStr \u003d m[count].toString();\r\n            StringData[count] \u003d tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length \u003d m.length;\r\n        if (length \u003d\u003d 0)\r\n            return null;\r\n        String[] StringData \u003d new String[length];\r\n        String tempStr;\r\n        for (count \u003d 0; count \u003c m.length; count++) {\r\n            tempStr \u003d m[count].getName();\r\n            StringData[count] \u003d tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * \u003cp\u003e\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr \u003d\u003d null)\r\n            return null;\r\n        fndMethods \u003d StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods !\u003d null) {\r\n            String[] tempArray \u003d new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * \u003cp\u003e\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr \u003d\u003d null)\r\n            return null;\r\n        fndMethods \u003d StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods !\u003d null) {\r\n            String[] tempArray \u003d new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods \u003d\u003d null || pos \u003e fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn\u0027t out of range\r\n            String tempStr \u003d fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end \u003d tempStr.indexOf(\")\");\r\n                tempStr \u003d tempStr.substring(0, end + 1);\r\n                begin \u003d tempStr.lastIndexOf(\" \");\r\n                tempStr \u003d tempStr.substring(begin + 1, tempStr.length());\r\n                begin \u003d tempStr.indexOf(\"(\");\r\n                end \u003d tempStr.lastIndexOf(\".\", begin);\r\n                className \u003d tempStr.substring(0, end);\r\n                methodName \u003d tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className\u003d\" + className);\r\n                methClass \u003d ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass\u003d\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass \u003d\u003d null)\r\n                    return null;\r\n                return methClass.getPackage() !\u003d null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass \u003d\u003d null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length \u003d array.length;\r\n        if (length \u003d\u003d 0)\r\n            return;\r\n        for (count \u003d 0; count \u003c length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr \u003d name;\r\n        Class tempClass \u003d null;\r\n        tempClass \u003d tryClass(name);\r\n        if (tempClass \u003d\u003d null) {\r\n            for (int i \u003d 0; i \u003c knownPackages.length; i++) {\r\n                tempStr \u003d knownPackages[i] + name;\r\n                tempClass \u003d tryClass(tempStr);\r\n                if (tempClass !\u003d null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass \u003d null;\r\n        try {\r\n            if (name !\u003d null)\r\n                tempClass \u003d Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c !\u003d java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 \u003d System.currentTimeMillis();\r\n        debug \u003d true;\r\n        String name \u003d null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length \u003e 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name \u003d args[1];\r\n            } else {\r\n                name \u003d args[0];\r\n                try {\r\n                    myClassInfo \u003d new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo \u003d new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
    "package": "com.jstevh.viewer",
    "classname": "ClassInfo",
    "id": "/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_1Test.java",
    "test_prompt": "// ClassInfo_1Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#printMethods()} method.\n*/\nclass ClassInfo_1Test {",
    "method_signature": "printMethods()",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * \u003cp\u003e\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c \u003d javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS \u003d 1, NO_INHERITED_METHODS \u003d 2;\r\n\r\n    private String[] cMethods, fndMethods \u003d null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() !\u003d null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c !\u003d java.lang.Object.class \u0026\u0026 !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c \u003d getClass(name);\r\n        if (c \u003d\u003d null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m \u003d c.getMethods();\r\n        Object[] obj \u003d null;\r\n        cMethods \u003d getData(m);\r\n        if (cMethods !\u003d null) {\r\n            if (c !\u003d java.lang.Object.class) {\r\n                StringList tempList \u003d new StringList();\r\n                for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") \u003d\u003d -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods \u003d tempList.toArray();\r\n            }\r\n            for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                if (!statusAbstract \u0026\u0026 cMethods[count].indexOf(\"abstract\") !\u003d -1)\r\n                    statusAbstract \u003d true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan \u003d locManager;\r\n        knownPackages \u003d dirMan.getPackageList();\r\n        c \u003d getClass(name);\r\n        if (c \u003d\u003d null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m \u003d c.getMethods();\r\n        Object[] obj \u003d null;\r\n        cMethods \u003d getData(m);\r\n        if (cMethods !\u003d null) {\r\n            if (c !\u003d java.lang.Object.class) {\r\n                StringList tempList \u003d new StringList();\r\n                for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") \u003d\u003d -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods \u003d tempList.toArray();\r\n            }\r\n            for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                if (!statusAbstract \u0026\u0026 cMethods[count].indexOf(\"abstract\") !\u003d -1)\r\n                    statusAbstract \u003d true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f \u003d c.getFields();\r\n        length \u003d f.length;\r\n        String[] StringData \u003d null;\r\n        if (length \u003e 0) {\r\n            StringData \u003d new String[length];\r\n            String tempStr;\r\n            Object obj \u003d new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count \u003d 0; count \u003c length; count++) {\r\n                try {\r\n                    tempStr \u003d f[count] + \"\u003d\" + f[count].get(obj);\r\n                    StringData[count] \u003d tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr \u003d f[count] + \"\u003d ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] \u003d tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr \u003d f[count] + \"\u003d ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] \u003d tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray \u003d null;\r\n        if (cMethods !\u003d null) {\r\n            tempArray \u003d new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug \u0026\u0026 tempArray \u003d\u003d null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods \u003d\u003d null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d cMethods;\r\n        StringList tempList \u003d new StringList();\r\n        for (int i \u003d 0; i \u003c cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + \u0027.\u0027) !\u003d -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data \u003d tempList.toArray();\r\n        else\r\n            data \u003d null;\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr \u003d c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d getData(constr);\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter \u003d c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d getData(inter);\r\n        if (c !\u003d java.lang.Object.class \u0026\u0026 !c.isInterface()) {\r\n            Class superC \u003d c.getSuperclass();\r\n            TreeSet\u003cString\u003e hInterfaces \u003d new TreeSet\u003cString\u003e();\r\n            int i \u003d 0;\r\n            if (data !\u003d null)\r\n                for (i \u003d 0; i \u003c data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC !\u003d null \u0026\u0026 superC !\u003d java.lang.Object.class) {\r\n                inter \u003d superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data \u003d getData(inter);\r\n                if (data !\u003d null)\r\n                    for (i \u003d 0; i \u003c data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC \u003d superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() !\u003d 0) {\r\n                data \u003d new String[hInterfaces.size()];\r\n                Iterator it \u003d hInterfaces.iterator();\r\n                i \u003d 0;\r\n                while (it.hasNext()) {\r\n                    data[i] \u003d (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length \u003d m.length;\r\n        if (length \u003d\u003d 0)\r\n            return null;\r\n        String[] StringData \u003d new String[length];\r\n        String tempStr;\r\n        for (count \u003d 0; count \u003c m.length; count++) {\r\n            tempStr \u003d m[count].toString();\r\n            StringData[count] \u003d tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length \u003d m.length;\r\n        if (length \u003d\u003d 0)\r\n            return null;\r\n        String[] StringData \u003d new String[length];\r\n        String tempStr;\r\n        for (count \u003d 0; count \u003c m.length; count++) {\r\n            tempStr \u003d m[count].getName();\r\n            StringData[count] \u003d tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * \u003cp\u003e\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr \u003d\u003d null)\r\n            return null;\r\n        fndMethods \u003d StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods !\u003d null) {\r\n            String[] tempArray \u003d new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * \u003cp\u003e\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr \u003d\u003d null)\r\n            return null;\r\n        fndMethods \u003d StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods !\u003d null) {\r\n            String[] tempArray \u003d new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods \u003d\u003d null || pos \u003e fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn\u0027t out of range\r\n            String tempStr \u003d fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end \u003d tempStr.indexOf(\")\");\r\n                tempStr \u003d tempStr.substring(0, end + 1);\r\n                begin \u003d tempStr.lastIndexOf(\" \");\r\n                tempStr \u003d tempStr.substring(begin + 1, tempStr.length());\r\n                begin \u003d tempStr.indexOf(\"(\");\r\n                end \u003d tempStr.lastIndexOf(\".\", begin);\r\n                className \u003d tempStr.substring(0, end);\r\n                methodName \u003d tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className\u003d\" + className);\r\n                methClass \u003d ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass\u003d\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass \u003d\u003d null)\r\n                    return null;\r\n                return methClass.getPackage() !\u003d null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass \u003d\u003d null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length \u003d array.length;\r\n        if (length \u003d\u003d 0)\r\n            return;\r\n        for (count \u003d 0; count \u003c length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr \u003d name;\r\n        Class tempClass \u003d null;\r\n        tempClass \u003d tryClass(name);\r\n        if (tempClass \u003d\u003d null) {\r\n            for (int i \u003d 0; i \u003c knownPackages.length; i++) {\r\n                tempStr \u003d knownPackages[i] + name;\r\n                tempClass \u003d tryClass(tempStr);\r\n                if (tempClass !\u003d null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass \u003d null;\r\n        try {\r\n            if (name !\u003d null)\r\n                tempClass \u003d Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c !\u003d java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 \u003d System.currentTimeMillis();\r\n        debug \u003d true;\r\n        String name \u003d null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length \u003e 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name \u003d args[1];\r\n            } else {\r\n                name \u003d args[0];\r\n                try {\r\n                    myClassInfo \u003d new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo \u003d new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
    "package": "com.jstevh.viewer",
    "classname": "ClassInfo",
    "id": "/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_2Test.java",
    "test_prompt": "// ClassInfo_2Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#printMethods(int)} method.\n*/\nclass ClassInfo_2Test {",
    "method_signature": "printMethods(int)",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * \u003cp\u003e\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c \u003d javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS \u003d 1, NO_INHERITED_METHODS \u003d 2;\r\n\r\n    private String[] cMethods, fndMethods \u003d null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() !\u003d null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c !\u003d java.lang.Object.class \u0026\u0026 !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c \u003d getClass(name);\r\n        if (c \u003d\u003d null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m \u003d c.getMethods();\r\n        Object[] obj \u003d null;\r\n        cMethods \u003d getData(m);\r\n        if (cMethods !\u003d null) {\r\n            if (c !\u003d java.lang.Object.class) {\r\n                StringList tempList \u003d new StringList();\r\n                for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") \u003d\u003d -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods \u003d tempList.toArray();\r\n            }\r\n            for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                if (!statusAbstract \u0026\u0026 cMethods[count].indexOf(\"abstract\") !\u003d -1)\r\n                    statusAbstract \u003d true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan \u003d locManager;\r\n        knownPackages \u003d dirMan.getPackageList();\r\n        c \u003d getClass(name);\r\n        if (c \u003d\u003d null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m \u003d c.getMethods();\r\n        Object[] obj \u003d null;\r\n        cMethods \u003d getData(m);\r\n        if (cMethods !\u003d null) {\r\n            if (c !\u003d java.lang.Object.class) {\r\n                StringList tempList \u003d new StringList();\r\n                for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") \u003d\u003d -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods \u003d tempList.toArray();\r\n            }\r\n            for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                if (!statusAbstract \u0026\u0026 cMethods[count].indexOf(\"abstract\") !\u003d -1)\r\n                    statusAbstract \u003d true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f \u003d c.getFields();\r\n        length \u003d f.length;\r\n        String[] StringData \u003d null;\r\n        if (length \u003e 0) {\r\n            StringData \u003d new String[length];\r\n            String tempStr;\r\n            Object obj \u003d new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count \u003d 0; count \u003c length; count++) {\r\n                try {\r\n                    tempStr \u003d f[count] + \"\u003d\" + f[count].get(obj);\r\n                    StringData[count] \u003d tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr \u003d f[count] + \"\u003d ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] \u003d tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr \u003d f[count] + \"\u003d ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] \u003d tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray \u003d null;\r\n        if (cMethods !\u003d null) {\r\n            tempArray \u003d new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug \u0026\u0026 tempArray \u003d\u003d null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods \u003d\u003d null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d cMethods;\r\n        StringList tempList \u003d new StringList();\r\n        for (int i \u003d 0; i \u003c cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + \u0027.\u0027) !\u003d -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data \u003d tempList.toArray();\r\n        else\r\n            data \u003d null;\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr \u003d c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d getData(constr);\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter \u003d c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d getData(inter);\r\n        if (c !\u003d java.lang.Object.class \u0026\u0026 !c.isInterface()) {\r\n            Class superC \u003d c.getSuperclass();\r\n            TreeSet\u003cString\u003e hInterfaces \u003d new TreeSet\u003cString\u003e();\r\n            int i \u003d 0;\r\n            if (data !\u003d null)\r\n                for (i \u003d 0; i \u003c data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC !\u003d null \u0026\u0026 superC !\u003d java.lang.Object.class) {\r\n                inter \u003d superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data \u003d getData(inter);\r\n                if (data !\u003d null)\r\n                    for (i \u003d 0; i \u003c data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC \u003d superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() !\u003d 0) {\r\n                data \u003d new String[hInterfaces.size()];\r\n                Iterator it \u003d hInterfaces.iterator();\r\n                i \u003d 0;\r\n                while (it.hasNext()) {\r\n                    data[i] \u003d (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length \u003d m.length;\r\n        if (length \u003d\u003d 0)\r\n            return null;\r\n        String[] StringData \u003d new String[length];\r\n        String tempStr;\r\n        for (count \u003d 0; count \u003c m.length; count++) {\r\n            tempStr \u003d m[count].toString();\r\n            StringData[count] \u003d tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length \u003d m.length;\r\n        if (length \u003d\u003d 0)\r\n            return null;\r\n        String[] StringData \u003d new String[length];\r\n        String tempStr;\r\n        for (count \u003d 0; count \u003c m.length; count++) {\r\n            tempStr \u003d m[count].getName();\r\n            StringData[count] \u003d tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * \u003cp\u003e\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr \u003d\u003d null)\r\n            return null;\r\n        fndMethods \u003d StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods !\u003d null) {\r\n            String[] tempArray \u003d new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * \u003cp\u003e\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr \u003d\u003d null)\r\n            return null;\r\n        fndMethods \u003d StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods !\u003d null) {\r\n            String[] tempArray \u003d new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods \u003d\u003d null || pos \u003e fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn\u0027t out of range\r\n            String tempStr \u003d fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end \u003d tempStr.indexOf(\")\");\r\n                tempStr \u003d tempStr.substring(0, end + 1);\r\n                begin \u003d tempStr.lastIndexOf(\" \");\r\n                tempStr \u003d tempStr.substring(begin + 1, tempStr.length());\r\n                begin \u003d tempStr.indexOf(\"(\");\r\n                end \u003d tempStr.lastIndexOf(\".\", begin);\r\n                className \u003d tempStr.substring(0, end);\r\n                methodName \u003d tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className\u003d\" + className);\r\n                methClass \u003d ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass\u003d\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass \u003d\u003d null)\r\n                    return null;\r\n                return methClass.getPackage() !\u003d null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass \u003d\u003d null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length \u003d array.length;\r\n        if (length \u003d\u003d 0)\r\n            return;\r\n        for (count \u003d 0; count \u003c length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr \u003d name;\r\n        Class tempClass \u003d null;\r\n        tempClass \u003d tryClass(name);\r\n        if (tempClass \u003d\u003d null) {\r\n            for (int i \u003d 0; i \u003c knownPackages.length; i++) {\r\n                tempStr \u003d knownPackages[i] + name;\r\n                tempClass \u003d tryClass(tempStr);\r\n                if (tempClass !\u003d null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass \u003d null;\r\n        try {\r\n            if (name !\u003d null)\r\n                tempClass \u003d Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c !\u003d java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 \u003d System.currentTimeMillis();\r\n        debug \u003d true;\r\n        String name \u003d null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length \u003e 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name \u003d args[1];\r\n            } else {\r\n                name \u003d args[0];\r\n                try {\r\n                    myClassInfo \u003d new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo \u003d new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
    "package": "com.jstevh.viewer",
    "classname": "ClassInfo",
    "id": "/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_3Test.java",
    "test_prompt": "// ClassInfo_3Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#printConstructors()} method.\n*/\nclass ClassInfo_3Test {",
    "method_signature": "printConstructors()",
    "suffix": "3"
  },
  {
    "numberTests": "ten",
    "original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * \u003cp\u003e\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c \u003d javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS \u003d 1, NO_INHERITED_METHODS \u003d 2;\r\n\r\n    private String[] cMethods, fndMethods \u003d null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() !\u003d null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c !\u003d java.lang.Object.class \u0026\u0026 !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c \u003d getClass(name);\r\n        if (c \u003d\u003d null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m \u003d c.getMethods();\r\n        Object[] obj \u003d null;\r\n        cMethods \u003d getData(m);\r\n        if (cMethods !\u003d null) {\r\n            if (c !\u003d java.lang.Object.class) {\r\n                StringList tempList \u003d new StringList();\r\n                for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") \u003d\u003d -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods \u003d tempList.toArray();\r\n            }\r\n            for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                if (!statusAbstract \u0026\u0026 cMethods[count].indexOf(\"abstract\") !\u003d -1)\r\n                    statusAbstract \u003d true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan \u003d locManager;\r\n        knownPackages \u003d dirMan.getPackageList();\r\n        c \u003d getClass(name);\r\n        if (c \u003d\u003d null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m \u003d c.getMethods();\r\n        Object[] obj \u003d null;\r\n        cMethods \u003d getData(m);\r\n        if (cMethods !\u003d null) {\r\n            if (c !\u003d java.lang.Object.class) {\r\n                StringList tempList \u003d new StringList();\r\n                for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") \u003d\u003d -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods \u003d tempList.toArray();\r\n            }\r\n            for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                if (!statusAbstract \u0026\u0026 cMethods[count].indexOf(\"abstract\") !\u003d -1)\r\n                    statusAbstract \u003d true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f \u003d c.getFields();\r\n        length \u003d f.length;\r\n        String[] StringData \u003d null;\r\n        if (length \u003e 0) {\r\n            StringData \u003d new String[length];\r\n            String tempStr;\r\n            Object obj \u003d new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count \u003d 0; count \u003c length; count++) {\r\n                try {\r\n                    tempStr \u003d f[count] + \"\u003d\" + f[count].get(obj);\r\n                    StringData[count] \u003d tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr \u003d f[count] + \"\u003d ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] \u003d tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr \u003d f[count] + \"\u003d ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] \u003d tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray \u003d null;\r\n        if (cMethods !\u003d null) {\r\n            tempArray \u003d new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug \u0026\u0026 tempArray \u003d\u003d null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods \u003d\u003d null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d cMethods;\r\n        StringList tempList \u003d new StringList();\r\n        for (int i \u003d 0; i \u003c cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + \u0027.\u0027) !\u003d -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data \u003d tempList.toArray();\r\n        else\r\n            data \u003d null;\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr \u003d c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d getData(constr);\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter \u003d c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d getData(inter);\r\n        if (c !\u003d java.lang.Object.class \u0026\u0026 !c.isInterface()) {\r\n            Class superC \u003d c.getSuperclass();\r\n            TreeSet\u003cString\u003e hInterfaces \u003d new TreeSet\u003cString\u003e();\r\n            int i \u003d 0;\r\n            if (data !\u003d null)\r\n                for (i \u003d 0; i \u003c data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC !\u003d null \u0026\u0026 superC !\u003d java.lang.Object.class) {\r\n                inter \u003d superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data \u003d getData(inter);\r\n                if (data !\u003d null)\r\n                    for (i \u003d 0; i \u003c data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC \u003d superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() !\u003d 0) {\r\n                data \u003d new String[hInterfaces.size()];\r\n                Iterator it \u003d hInterfaces.iterator();\r\n                i \u003d 0;\r\n                while (it.hasNext()) {\r\n                    data[i] \u003d (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length \u003d m.length;\r\n        if (length \u003d\u003d 0)\r\n            return null;\r\n        String[] StringData \u003d new String[length];\r\n        String tempStr;\r\n        for (count \u003d 0; count \u003c m.length; count++) {\r\n            tempStr \u003d m[count].toString();\r\n            StringData[count] \u003d tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length \u003d m.length;\r\n        if (length \u003d\u003d 0)\r\n            return null;\r\n        String[] StringData \u003d new String[length];\r\n        String tempStr;\r\n        for (count \u003d 0; count \u003c m.length; count++) {\r\n            tempStr \u003d m[count].getName();\r\n            StringData[count] \u003d tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * \u003cp\u003e\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr \u003d\u003d null)\r\n            return null;\r\n        fndMethods \u003d StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods !\u003d null) {\r\n            String[] tempArray \u003d new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * \u003cp\u003e\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr \u003d\u003d null)\r\n            return null;\r\n        fndMethods \u003d StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods !\u003d null) {\r\n            String[] tempArray \u003d new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods \u003d\u003d null || pos \u003e fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn\u0027t out of range\r\n            String tempStr \u003d fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end \u003d tempStr.indexOf(\")\");\r\n                tempStr \u003d tempStr.substring(0, end + 1);\r\n                begin \u003d tempStr.lastIndexOf(\" \");\r\n                tempStr \u003d tempStr.substring(begin + 1, tempStr.length());\r\n                begin \u003d tempStr.indexOf(\"(\");\r\n                end \u003d tempStr.lastIndexOf(\".\", begin);\r\n                className \u003d tempStr.substring(0, end);\r\n                methodName \u003d tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className\u003d\" + className);\r\n                methClass \u003d ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass\u003d\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass \u003d\u003d null)\r\n                    return null;\r\n                return methClass.getPackage() !\u003d null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass \u003d\u003d null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length \u003d array.length;\r\n        if (length \u003d\u003d 0)\r\n            return;\r\n        for (count \u003d 0; count \u003c length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr \u003d name;\r\n        Class tempClass \u003d null;\r\n        tempClass \u003d tryClass(name);\r\n        if (tempClass \u003d\u003d null) {\r\n            for (int i \u003d 0; i \u003c knownPackages.length; i++) {\r\n                tempStr \u003d knownPackages[i] + name;\r\n                tempClass \u003d tryClass(tempStr);\r\n                if (tempClass !\u003d null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass \u003d null;\r\n        try {\r\n            if (name !\u003d null)\r\n                tempClass \u003d Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c !\u003d java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 \u003d System.currentTimeMillis();\r\n        debug \u003d true;\r\n        String name \u003d null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length \u003e 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name \u003d args[1];\r\n            } else {\r\n                name \u003d args[0];\r\n                try {\r\n                    myClassInfo \u003d new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo \u003d new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
    "package": "com.jstevh.viewer",
    "classname": "ClassInfo",
    "id": "/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_4Test.java",
    "test_prompt": "// ClassInfo_4Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#printInterfaces()} method.\n*/\nclass ClassInfo_4Test {",
    "method_signature": "printInterfaces()",
    "suffix": "4"
  },
  {
    "numberTests": "ten",
    "original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * \u003cp\u003e\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c \u003d javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS \u003d 1, NO_INHERITED_METHODS \u003d 2;\r\n\r\n    private String[] cMethods, fndMethods \u003d null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() !\u003d null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c !\u003d java.lang.Object.class \u0026\u0026 !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c \u003d getClass(name);\r\n        if (c \u003d\u003d null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m \u003d c.getMethods();\r\n        Object[] obj \u003d null;\r\n        cMethods \u003d getData(m);\r\n        if (cMethods !\u003d null) {\r\n            if (c !\u003d java.lang.Object.class) {\r\n                StringList tempList \u003d new StringList();\r\n                for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") \u003d\u003d -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods \u003d tempList.toArray();\r\n            }\r\n            for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                if (!statusAbstract \u0026\u0026 cMethods[count].indexOf(\"abstract\") !\u003d -1)\r\n                    statusAbstract \u003d true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan \u003d locManager;\r\n        knownPackages \u003d dirMan.getPackageList();\r\n        c \u003d getClass(name);\r\n        if (c \u003d\u003d null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m \u003d c.getMethods();\r\n        Object[] obj \u003d null;\r\n        cMethods \u003d getData(m);\r\n        if (cMethods !\u003d null) {\r\n            if (c !\u003d java.lang.Object.class) {\r\n                StringList tempList \u003d new StringList();\r\n                for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") \u003d\u003d -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods \u003d tempList.toArray();\r\n            }\r\n            for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                if (!statusAbstract \u0026\u0026 cMethods[count].indexOf(\"abstract\") !\u003d -1)\r\n                    statusAbstract \u003d true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f \u003d c.getFields();\r\n        length \u003d f.length;\r\n        String[] StringData \u003d null;\r\n        if (length \u003e 0) {\r\n            StringData \u003d new String[length];\r\n            String tempStr;\r\n            Object obj \u003d new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count \u003d 0; count \u003c length; count++) {\r\n                try {\r\n                    tempStr \u003d f[count] + \"\u003d\" + f[count].get(obj);\r\n                    StringData[count] \u003d tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr \u003d f[count] + \"\u003d ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] \u003d tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr \u003d f[count] + \"\u003d ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] \u003d tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray \u003d null;\r\n        if (cMethods !\u003d null) {\r\n            tempArray \u003d new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug \u0026\u0026 tempArray \u003d\u003d null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods \u003d\u003d null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d cMethods;\r\n        StringList tempList \u003d new StringList();\r\n        for (int i \u003d 0; i \u003c cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + \u0027.\u0027) !\u003d -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data \u003d tempList.toArray();\r\n        else\r\n            data \u003d null;\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr \u003d c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d getData(constr);\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter \u003d c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d getData(inter);\r\n        if (c !\u003d java.lang.Object.class \u0026\u0026 !c.isInterface()) {\r\n            Class superC \u003d c.getSuperclass();\r\n            TreeSet\u003cString\u003e hInterfaces \u003d new TreeSet\u003cString\u003e();\r\n            int i \u003d 0;\r\n            if (data !\u003d null)\r\n                for (i \u003d 0; i \u003c data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC !\u003d null \u0026\u0026 superC !\u003d java.lang.Object.class) {\r\n                inter \u003d superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data \u003d getData(inter);\r\n                if (data !\u003d null)\r\n                    for (i \u003d 0; i \u003c data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC \u003d superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() !\u003d 0) {\r\n                data \u003d new String[hInterfaces.size()];\r\n                Iterator it \u003d hInterfaces.iterator();\r\n                i \u003d 0;\r\n                while (it.hasNext()) {\r\n                    data[i] \u003d (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length \u003d m.length;\r\n        if (length \u003d\u003d 0)\r\n            return null;\r\n        String[] StringData \u003d new String[length];\r\n        String tempStr;\r\n        for (count \u003d 0; count \u003c m.length; count++) {\r\n            tempStr \u003d m[count].toString();\r\n            StringData[count] \u003d tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length \u003d m.length;\r\n        if (length \u003d\u003d 0)\r\n            return null;\r\n        String[] StringData \u003d new String[length];\r\n        String tempStr;\r\n        for (count \u003d 0; count \u003c m.length; count++) {\r\n            tempStr \u003d m[count].getName();\r\n            StringData[count] \u003d tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * \u003cp\u003e\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr \u003d\u003d null)\r\n            return null;\r\n        fndMethods \u003d StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods !\u003d null) {\r\n            String[] tempArray \u003d new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * \u003cp\u003e\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr \u003d\u003d null)\r\n            return null;\r\n        fndMethods \u003d StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods !\u003d null) {\r\n            String[] tempArray \u003d new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods \u003d\u003d null || pos \u003e fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn\u0027t out of range\r\n            String tempStr \u003d fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end \u003d tempStr.indexOf(\")\");\r\n                tempStr \u003d tempStr.substring(0, end + 1);\r\n                begin \u003d tempStr.lastIndexOf(\" \");\r\n                tempStr \u003d tempStr.substring(begin + 1, tempStr.length());\r\n                begin \u003d tempStr.indexOf(\"(\");\r\n                end \u003d tempStr.lastIndexOf(\".\", begin);\r\n                className \u003d tempStr.substring(0, end);\r\n                methodName \u003d tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className\u003d\" + className);\r\n                methClass \u003d ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass\u003d\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass \u003d\u003d null)\r\n                    return null;\r\n                return methClass.getPackage() !\u003d null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass \u003d\u003d null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length \u003d array.length;\r\n        if (length \u003d\u003d 0)\r\n            return;\r\n        for (count \u003d 0; count \u003c length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr \u003d name;\r\n        Class tempClass \u003d null;\r\n        tempClass \u003d tryClass(name);\r\n        if (tempClass \u003d\u003d null) {\r\n            for (int i \u003d 0; i \u003c knownPackages.length; i++) {\r\n                tempStr \u003d knownPackages[i] + name;\r\n                tempClass \u003d tryClass(tempStr);\r\n                if (tempClass !\u003d null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass \u003d null;\r\n        try {\r\n            if (name !\u003d null)\r\n                tempClass \u003d Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c !\u003d java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 \u003d System.currentTimeMillis();\r\n        debug \u003d true;\r\n        String name \u003d null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length \u003e 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name \u003d args[1];\r\n            } else {\r\n                name \u003d args[0];\r\n                try {\r\n                    myClassInfo \u003d new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo \u003d new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
    "package": "com.jstevh.viewer",
    "classname": "ClassInfo",
    "id": "/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_5Test.java",
    "test_prompt": "// ClassInfo_5Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#getData(Member[])} method.\n*/\nclass ClassInfo_5Test {",
    "method_signature": "getData(Member[])",
    "suffix": "5"
  },
  {
    "numberTests": "ten",
    "original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * \u003cp\u003e\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c \u003d javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS \u003d 1, NO_INHERITED_METHODS \u003d 2;\r\n\r\n    private String[] cMethods, fndMethods \u003d null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() !\u003d null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c !\u003d java.lang.Object.class \u0026\u0026 !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c \u003d getClass(name);\r\n        if (c \u003d\u003d null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m \u003d c.getMethods();\r\n        Object[] obj \u003d null;\r\n        cMethods \u003d getData(m);\r\n        if (cMethods !\u003d null) {\r\n            if (c !\u003d java.lang.Object.class) {\r\n                StringList tempList \u003d new StringList();\r\n                for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") \u003d\u003d -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods \u003d tempList.toArray();\r\n            }\r\n            for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                if (!statusAbstract \u0026\u0026 cMethods[count].indexOf(\"abstract\") !\u003d -1)\r\n                    statusAbstract \u003d true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan \u003d locManager;\r\n        knownPackages \u003d dirMan.getPackageList();\r\n        c \u003d getClass(name);\r\n        if (c \u003d\u003d null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m \u003d c.getMethods();\r\n        Object[] obj \u003d null;\r\n        cMethods \u003d getData(m);\r\n        if (cMethods !\u003d null) {\r\n            if (c !\u003d java.lang.Object.class) {\r\n                StringList tempList \u003d new StringList();\r\n                for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") \u003d\u003d -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods \u003d tempList.toArray();\r\n            }\r\n            for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                if (!statusAbstract \u0026\u0026 cMethods[count].indexOf(\"abstract\") !\u003d -1)\r\n                    statusAbstract \u003d true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f \u003d c.getFields();\r\n        length \u003d f.length;\r\n        String[] StringData \u003d null;\r\n        if (length \u003e 0) {\r\n            StringData \u003d new String[length];\r\n            String tempStr;\r\n            Object obj \u003d new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count \u003d 0; count \u003c length; count++) {\r\n                try {\r\n                    tempStr \u003d f[count] + \"\u003d\" + f[count].get(obj);\r\n                    StringData[count] \u003d tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr \u003d f[count] + \"\u003d ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] \u003d tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr \u003d f[count] + \"\u003d ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] \u003d tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray \u003d null;\r\n        if (cMethods !\u003d null) {\r\n            tempArray \u003d new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug \u0026\u0026 tempArray \u003d\u003d null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods \u003d\u003d null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d cMethods;\r\n        StringList tempList \u003d new StringList();\r\n        for (int i \u003d 0; i \u003c cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + \u0027.\u0027) !\u003d -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data \u003d tempList.toArray();\r\n        else\r\n            data \u003d null;\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr \u003d c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d getData(constr);\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter \u003d c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d getData(inter);\r\n        if (c !\u003d java.lang.Object.class \u0026\u0026 !c.isInterface()) {\r\n            Class superC \u003d c.getSuperclass();\r\n            TreeSet\u003cString\u003e hInterfaces \u003d new TreeSet\u003cString\u003e();\r\n            int i \u003d 0;\r\n            if (data !\u003d null)\r\n                for (i \u003d 0; i \u003c data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC !\u003d null \u0026\u0026 superC !\u003d java.lang.Object.class) {\r\n                inter \u003d superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data \u003d getData(inter);\r\n                if (data !\u003d null)\r\n                    for (i \u003d 0; i \u003c data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC \u003d superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() !\u003d 0) {\r\n                data \u003d new String[hInterfaces.size()];\r\n                Iterator it \u003d hInterfaces.iterator();\r\n                i \u003d 0;\r\n                while (it.hasNext()) {\r\n                    data[i] \u003d (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length \u003d m.length;\r\n        if (length \u003d\u003d 0)\r\n            return null;\r\n        String[] StringData \u003d new String[length];\r\n        String tempStr;\r\n        for (count \u003d 0; count \u003c m.length; count++) {\r\n            tempStr \u003d m[count].toString();\r\n            StringData[count] \u003d tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length \u003d m.length;\r\n        if (length \u003d\u003d 0)\r\n            return null;\r\n        String[] StringData \u003d new String[length];\r\n        String tempStr;\r\n        for (count \u003d 0; count \u003c m.length; count++) {\r\n            tempStr \u003d m[count].getName();\r\n            StringData[count] \u003d tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * \u003cp\u003e\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr \u003d\u003d null)\r\n            return null;\r\n        fndMethods \u003d StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods !\u003d null) {\r\n            String[] tempArray \u003d new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * \u003cp\u003e\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr \u003d\u003d null)\r\n            return null;\r\n        fndMethods \u003d StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods !\u003d null) {\r\n            String[] tempArray \u003d new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods \u003d\u003d null || pos \u003e fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn\u0027t out of range\r\n            String tempStr \u003d fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end \u003d tempStr.indexOf(\")\");\r\n                tempStr \u003d tempStr.substring(0, end + 1);\r\n                begin \u003d tempStr.lastIndexOf(\" \");\r\n                tempStr \u003d tempStr.substring(begin + 1, tempStr.length());\r\n                begin \u003d tempStr.indexOf(\"(\");\r\n                end \u003d tempStr.lastIndexOf(\".\", begin);\r\n                className \u003d tempStr.substring(0, end);\r\n                methodName \u003d tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className\u003d\" + className);\r\n                methClass \u003d ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass\u003d\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass \u003d\u003d null)\r\n                    return null;\r\n                return methClass.getPackage() !\u003d null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass \u003d\u003d null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length \u003d array.length;\r\n        if (length \u003d\u003d 0)\r\n            return;\r\n        for (count \u003d 0; count \u003c length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr \u003d name;\r\n        Class tempClass \u003d null;\r\n        tempClass \u003d tryClass(name);\r\n        if (tempClass \u003d\u003d null) {\r\n            for (int i \u003d 0; i \u003c knownPackages.length; i++) {\r\n                tempStr \u003d knownPackages[i] + name;\r\n                tempClass \u003d tryClass(tempStr);\r\n                if (tempClass !\u003d null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass \u003d null;\r\n        try {\r\n            if (name !\u003d null)\r\n                tempClass \u003d Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c !\u003d java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 \u003d System.currentTimeMillis();\r\n        debug \u003d true;\r\n        String name \u003d null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length \u003e 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name \u003d args[1];\r\n            } else {\r\n                name \u003d args[0];\r\n                try {\r\n                    myClassInfo \u003d new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo \u003d new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
    "package": "com.jstevh.viewer",
    "classname": "ClassInfo",
    "id": "/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_6Test.java",
    "test_prompt": "// ClassInfo_6Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#getData(Class[])} method.\n*/\nclass ClassInfo_6Test {",
    "method_signature": "getData(Class[])",
    "suffix": "6"
  },
  {
    "numberTests": "ten",
    "original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * \u003cp\u003e\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c \u003d javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS \u003d 1, NO_INHERITED_METHODS \u003d 2;\r\n\r\n    private String[] cMethods, fndMethods \u003d null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() !\u003d null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c !\u003d java.lang.Object.class \u0026\u0026 !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c \u003d getClass(name);\r\n        if (c \u003d\u003d null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m \u003d c.getMethods();\r\n        Object[] obj \u003d null;\r\n        cMethods \u003d getData(m);\r\n        if (cMethods !\u003d null) {\r\n            if (c !\u003d java.lang.Object.class) {\r\n                StringList tempList \u003d new StringList();\r\n                for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") \u003d\u003d -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods \u003d tempList.toArray();\r\n            }\r\n            for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                if (!statusAbstract \u0026\u0026 cMethods[count].indexOf(\"abstract\") !\u003d -1)\r\n                    statusAbstract \u003d true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan \u003d locManager;\r\n        knownPackages \u003d dirMan.getPackageList();\r\n        c \u003d getClass(name);\r\n        if (c \u003d\u003d null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m \u003d c.getMethods();\r\n        Object[] obj \u003d null;\r\n        cMethods \u003d getData(m);\r\n        if (cMethods !\u003d null) {\r\n            if (c !\u003d java.lang.Object.class) {\r\n                StringList tempList \u003d new StringList();\r\n                for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") \u003d\u003d -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods \u003d tempList.toArray();\r\n            }\r\n            for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                if (!statusAbstract \u0026\u0026 cMethods[count].indexOf(\"abstract\") !\u003d -1)\r\n                    statusAbstract \u003d true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f \u003d c.getFields();\r\n        length \u003d f.length;\r\n        String[] StringData \u003d null;\r\n        if (length \u003e 0) {\r\n            StringData \u003d new String[length];\r\n            String tempStr;\r\n            Object obj \u003d new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count \u003d 0; count \u003c length; count++) {\r\n                try {\r\n                    tempStr \u003d f[count] + \"\u003d\" + f[count].get(obj);\r\n                    StringData[count] \u003d tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr \u003d f[count] + \"\u003d ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] \u003d tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr \u003d f[count] + \"\u003d ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] \u003d tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray \u003d null;\r\n        if (cMethods !\u003d null) {\r\n            tempArray \u003d new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug \u0026\u0026 tempArray \u003d\u003d null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods \u003d\u003d null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d cMethods;\r\n        StringList tempList \u003d new StringList();\r\n        for (int i \u003d 0; i \u003c cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + \u0027.\u0027) !\u003d -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data \u003d tempList.toArray();\r\n        else\r\n            data \u003d null;\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr \u003d c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d getData(constr);\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter \u003d c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d getData(inter);\r\n        if (c !\u003d java.lang.Object.class \u0026\u0026 !c.isInterface()) {\r\n            Class superC \u003d c.getSuperclass();\r\n            TreeSet\u003cString\u003e hInterfaces \u003d new TreeSet\u003cString\u003e();\r\n            int i \u003d 0;\r\n            if (data !\u003d null)\r\n                for (i \u003d 0; i \u003c data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC !\u003d null \u0026\u0026 superC !\u003d java.lang.Object.class) {\r\n                inter \u003d superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data \u003d getData(inter);\r\n                if (data !\u003d null)\r\n                    for (i \u003d 0; i \u003c data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC \u003d superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() !\u003d 0) {\r\n                data \u003d new String[hInterfaces.size()];\r\n                Iterator it \u003d hInterfaces.iterator();\r\n                i \u003d 0;\r\n                while (it.hasNext()) {\r\n                    data[i] \u003d (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length \u003d m.length;\r\n        if (length \u003d\u003d 0)\r\n            return null;\r\n        String[] StringData \u003d new String[length];\r\n        String tempStr;\r\n        for (count \u003d 0; count \u003c m.length; count++) {\r\n            tempStr \u003d m[count].toString();\r\n            StringData[count] \u003d tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length \u003d m.length;\r\n        if (length \u003d\u003d 0)\r\n            return null;\r\n        String[] StringData \u003d new String[length];\r\n        String tempStr;\r\n        for (count \u003d 0; count \u003c m.length; count++) {\r\n            tempStr \u003d m[count].getName();\r\n            StringData[count] \u003d tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * \u003cp\u003e\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr \u003d\u003d null)\r\n            return null;\r\n        fndMethods \u003d StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods !\u003d null) {\r\n            String[] tempArray \u003d new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * \u003cp\u003e\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr \u003d\u003d null)\r\n            return null;\r\n        fndMethods \u003d StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods !\u003d null) {\r\n            String[] tempArray \u003d new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods \u003d\u003d null || pos \u003e fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn\u0027t out of range\r\n            String tempStr \u003d fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end \u003d tempStr.indexOf(\")\");\r\n                tempStr \u003d tempStr.substring(0, end + 1);\r\n                begin \u003d tempStr.lastIndexOf(\" \");\r\n                tempStr \u003d tempStr.substring(begin + 1, tempStr.length());\r\n                begin \u003d tempStr.indexOf(\"(\");\r\n                end \u003d tempStr.lastIndexOf(\".\", begin);\r\n                className \u003d tempStr.substring(0, end);\r\n                methodName \u003d tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className\u003d\" + className);\r\n                methClass \u003d ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass\u003d\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass \u003d\u003d null)\r\n                    return null;\r\n                return methClass.getPackage() !\u003d null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass \u003d\u003d null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length \u003d array.length;\r\n        if (length \u003d\u003d 0)\r\n            return;\r\n        for (count \u003d 0; count \u003c length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr \u003d name;\r\n        Class tempClass \u003d null;\r\n        tempClass \u003d tryClass(name);\r\n        if (tempClass \u003d\u003d null) {\r\n            for (int i \u003d 0; i \u003c knownPackages.length; i++) {\r\n                tempStr \u003d knownPackages[i] + name;\r\n                tempClass \u003d tryClass(tempStr);\r\n                if (tempClass !\u003d null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass \u003d null;\r\n        try {\r\n            if (name !\u003d null)\r\n                tempClass \u003d Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c !\u003d java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 \u003d System.currentTimeMillis();\r\n        debug \u003d true;\r\n        String name \u003d null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length \u003e 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name \u003d args[1];\r\n            } else {\r\n                name \u003d args[0];\r\n                try {\r\n                    myClassInfo \u003d new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo \u003d new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
    "package": "com.jstevh.viewer",
    "classname": "ClassInfo",
    "id": "/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_7Test.java",
    "test_prompt": "// ClassInfo_7Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#srchMethods(String)} method.\n*/\nclass ClassInfo_7Test {",
    "method_signature": "srchMethods(String)",
    "suffix": "7"
  },
  {
    "numberTests": "ten",
    "original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * \u003cp\u003e\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c \u003d javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS \u003d 1, NO_INHERITED_METHODS \u003d 2;\r\n\r\n    private String[] cMethods, fndMethods \u003d null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() !\u003d null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c !\u003d java.lang.Object.class \u0026\u0026 !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c \u003d getClass(name);\r\n        if (c \u003d\u003d null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m \u003d c.getMethods();\r\n        Object[] obj \u003d null;\r\n        cMethods \u003d getData(m);\r\n        if (cMethods !\u003d null) {\r\n            if (c !\u003d java.lang.Object.class) {\r\n                StringList tempList \u003d new StringList();\r\n                for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") \u003d\u003d -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods \u003d tempList.toArray();\r\n            }\r\n            for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                if (!statusAbstract \u0026\u0026 cMethods[count].indexOf(\"abstract\") !\u003d -1)\r\n                    statusAbstract \u003d true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan \u003d locManager;\r\n        knownPackages \u003d dirMan.getPackageList();\r\n        c \u003d getClass(name);\r\n        if (c \u003d\u003d null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m \u003d c.getMethods();\r\n        Object[] obj \u003d null;\r\n        cMethods \u003d getData(m);\r\n        if (cMethods !\u003d null) {\r\n            if (c !\u003d java.lang.Object.class) {\r\n                StringList tempList \u003d new StringList();\r\n                for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") \u003d\u003d -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods \u003d tempList.toArray();\r\n            }\r\n            for (count \u003d 0; count \u003c cMethods.length; count++) {\r\n                if (!statusAbstract \u0026\u0026 cMethods[count].indexOf(\"abstract\") !\u003d -1)\r\n                    statusAbstract \u003d true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f \u003d c.getFields();\r\n        length \u003d f.length;\r\n        String[] StringData \u003d null;\r\n        if (length \u003e 0) {\r\n            StringData \u003d new String[length];\r\n            String tempStr;\r\n            Object obj \u003d new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count \u003d 0; count \u003c length; count++) {\r\n                try {\r\n                    tempStr \u003d f[count] + \"\u003d\" + f[count].get(obj);\r\n                    StringData[count] \u003d tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr \u003d f[count] + \"\u003d ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] \u003d tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr \u003d f[count] + \"\u003d ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] \u003d tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray \u003d null;\r\n        if (cMethods !\u003d null) {\r\n            tempArray \u003d new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug \u0026\u0026 tempArray \u003d\u003d null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods \u003d\u003d null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d cMethods;\r\n        StringList tempList \u003d new StringList();\r\n        for (int i \u003d 0; i \u003c cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + \u0027.\u0027) !\u003d -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data \u003d tempList.toArray();\r\n        else\r\n            data \u003d null;\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr \u003d c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d getData(constr);\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * \u003cp\u003e\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter \u003d c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data \u003d getData(inter);\r\n        if (c !\u003d java.lang.Object.class \u0026\u0026 !c.isInterface()) {\r\n            Class superC \u003d c.getSuperclass();\r\n            TreeSet\u003cString\u003e hInterfaces \u003d new TreeSet\u003cString\u003e();\r\n            int i \u003d 0;\r\n            if (data !\u003d null)\r\n                for (i \u003d 0; i \u003c data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC !\u003d null \u0026\u0026 superC !\u003d java.lang.Object.class) {\r\n                inter \u003d superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data \u003d getData(inter);\r\n                if (data !\u003d null)\r\n                    for (i \u003d 0; i \u003c data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC \u003d superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() !\u003d 0) {\r\n                data \u003d new String[hInterfaces.size()];\r\n                Iterator it \u003d hInterfaces.iterator();\r\n                i \u003d 0;\r\n                while (it.hasNext()) {\r\n                    data[i] \u003d (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug \u0026\u0026 data \u003d\u003d null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length \u003d m.length;\r\n        if (length \u003d\u003d 0)\r\n            return null;\r\n        String[] StringData \u003d new String[length];\r\n        String tempStr;\r\n        for (count \u003d 0; count \u003c m.length; count++) {\r\n            tempStr \u003d m[count].toString();\r\n            StringData[count] \u003d tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * \u003cp\u003e\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length \u003d m.length;\r\n        if (length \u003d\u003d 0)\r\n            return null;\r\n        String[] StringData \u003d new String[length];\r\n        String tempStr;\r\n        for (count \u003d 0; count \u003c m.length; count++) {\r\n            tempStr \u003d m[count].getName();\r\n            StringData[count] \u003d tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * \u003cp\u003e\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr \u003d\u003d null)\r\n            return null;\r\n        fndMethods \u003d StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods !\u003d null) {\r\n            String[] tempArray \u003d new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * \u003cp\u003e\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr \u003d\u003d null)\r\n            return null;\r\n        fndMethods \u003d StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods !\u003d null) {\r\n            String[] tempArray \u003d new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods \u003d\u003d null || pos \u003e fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn\u0027t out of range\r\n            String tempStr \u003d fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end \u003d tempStr.indexOf(\")\");\r\n                tempStr \u003d tempStr.substring(0, end + 1);\r\n                begin \u003d tempStr.lastIndexOf(\" \");\r\n                tempStr \u003d tempStr.substring(begin + 1, tempStr.length());\r\n                begin \u003d tempStr.indexOf(\"(\");\r\n                end \u003d tempStr.lastIndexOf(\".\", begin);\r\n                className \u003d tempStr.substring(0, end);\r\n                methodName \u003d tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className\u003d\" + className);\r\n                methClass \u003d ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass\u003d\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass \u003d\u003d null)\r\n                    return null;\r\n                return methClass.getPackage() !\u003d null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass \u003d\u003d null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length \u003d array.length;\r\n        if (length \u003d\u003d 0)\r\n            return;\r\n        for (count \u003d 0; count \u003c length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr \u003d name;\r\n        Class tempClass \u003d null;\r\n        tempClass \u003d tryClass(name);\r\n        if (tempClass \u003d\u003d null) {\r\n            for (int i \u003d 0; i \u003c knownPackages.length; i++) {\r\n                tempStr \u003d knownPackages[i] + name;\r\n                tempClass \u003d tryClass(tempStr);\r\n                if (tempClass !\u003d null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass \u003d null;\r\n        try {\r\n            if (name !\u003d null)\r\n                tempClass \u003d Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c !\u003d java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 \u003d System.currentTimeMillis();\r\n        debug \u003d true;\r\n        String name \u003d null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length \u003e 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name \u003d args[1];\r\n            } else {\r\n                name \u003d args[0];\r\n                try {\r\n                    myClassInfo \u003d new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo \u003d new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
    "package": "com.jstevh.viewer",
    "classname": "ClassInfo",
    "id": "/EvoSuiteBenchmark/original/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_9Test.java",
    "test_prompt": "// ClassInfo_9Test.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#getFoundMethod(int)} method.\n*/\nclass ClassInfo_9Test {",
    "method_signature": "getFoundMethod(int)",
    "suffix": "9"
  }
]