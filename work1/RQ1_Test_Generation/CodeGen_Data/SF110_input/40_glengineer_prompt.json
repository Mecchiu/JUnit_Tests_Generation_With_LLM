[
  {
    "numberTests": "ten",
    "original_code": "// HorizontalBlock.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * An implementation of the abstract class {@code Block}\r\n * used for horizontal layouting.\r\n */\r\npublic class HorizontalBlock extends Block {\r\n\r\n    public HorizontalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {\r\n        super(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public HorizontalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {\r\n        super(scheme, p1, p2);\r\n    }\r\n\r\n    public HorizontalBlock(Scheme scheme) {\r\n        super(scheme);\r\n    }\r\n\r\n    public HorizontalBlock(Block b) {\r\n        super(b.scheme, b.getPos1(), b.getPos2());\r\n    }\r\n\r\n    public HorizontalBlock(Block block, int x1, int y1, int x2, int y2) {\r\n        super(block.scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public Block subblock(int x1, int y1, int x2, int y2) {\r\n        return new HorizontalBlock(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public HorizontalBlock cloneWith(CharPosition1 p1) {\r\n        return new HorizontalBlock(scheme, p1, getPos2());\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of sequential subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     *\r\n     * @return\ta list of optimized sequential subblocks.\r\n     */\r\n    public List\u003cBlock\u003e extractSequentialSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList\u003cBlock\u003e();\r\n        List\u003cBlock\u003e result \u003d new LinkedList\u003cBlock\u003e();\r\n        Block firstBlock;\r\n        HorizontalBlock theRest \u003d this;\r\n        do {\r\n            firstBlock \u003d theRest.extractFirstSequentialSubblock();\r\n            theRest \u003d theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));\r\n            firstBlock.optimize();\r\n            if (!firstBlock.isTrivial())\r\n                result.add(firstBlock);\r\n            theRest.optimize();\r\n        } while (!theRest.isTrivial());\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the left subblock of this block.\r\n     * \u003cp\u003e\r\n     * The required block is chosen so that its last exclusive vertical line\r\n     * does not contain elements of components, gaps , or horizontal lines\r\n     * starting on the left from the line.\r\n     * \u003cp\u003e\r\n     * The algorithm just finds the most left entity\r\n     * (an element of a component, gap, or horizontal line)\r\n     * using simple search along the scheme,\r\n     * identifies the horizontal element containing the entity found,\r\n     * checks whether the last exclusive vertical line of the element\r\n     * matches the requirement for the boundary of the required block,\r\n     * and, if does not, takes the detaining horizontal element\r\n     * and continues the cycle.\r\n     */\r\n    private Block extractFirstSequentialSubblock() {\r\n        final HWordPosition firstWord \u003d scheme.anyHElementAt(firstEntity());\r\n        HWordPosition lastWord \u003d firstWord;\r\n        HWordPosition nextWord \u003d firstWord;\r\n        for (; nextWord !\u003d null; ) {\r\n            lastWord \u003d nextWord;\r\n            nextWord \u003d findAWordExtendingSubblockToTheRightFrom(nextWord);\r\n        }\r\n        int startX \u003d firstWord.x1;\r\n        int endX \u003d lastWord.x2;\r\n        //For the case of words containing cells outside of this block:\r\n        startX \u003d Math.max(startX, x1);\r\n        endX \u003d Math.min(endX, x2);\r\n        return subblock(startX, y1, endX, y2);\r\n    }\r\n\r\n    /**\r\n     * Searches down and to the right from the beginning of this block\r\n     * for the first occurrence of an entity.\r\n     * @return\tthe position of the entity found.\r\n     * @throws\tIllegalArgumentException if this block\r\n     * \t\t\tdoes not contain entities.\r\n     */\r\n    private CharPosition firstEntity() {\r\n        int y \u003d firstEntityBelow(x1, y1);\r\n        if (y !\u003d y2)\r\n            return new CharPosition(x1, y);\r\n        int x \u003d x1 + 1;\r\n        for (; x \u003c x2; x++) {\r\n            y \u003d firstEntityBelow(x, y1);\r\n            if (y !\u003d y2)\r\n                break;\r\n        }\r\n        if (x !\u003d x2)\r\n            return new CharPosition(x, y);\r\n        else\r\n            throw new IllegalArgumentException(\"Can not extract a group from an empty block:\\n\" + this);\r\n    }\r\n\r\n    /**\r\n     * Finds the first entity below the specified position.\r\n     * @return\tthe y-coordinate of the entity found or y2 if not found.\r\n     */\r\n    private int firstEntityBelow(int x, int y) {\r\n        for (; y \u003c y2; y++) if (entityAt(x, y))\r\n            break;\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the character under the cell\r\n     * determined by the specified coordinates\r\n     * is a word character or a horizontal line character.\r\n     */\r\n    private boolean entityAt(int x, int y) {\r\n        char c \u003d charAt(x, y);\r\n        /* \r\n\t\t * Since all symbols on the scheme are correct\r\n\t\t * (which has been verified in its constructor),\r\n\t\t * there is no need to use the slower method isWordChar().\r\n\t\t */\r\n        return c !\u003d \u0027 \u0027 \u0026\u0026 c !\u003d \u0027|\u0027;\r\n    }\r\n\r\n    /**\r\n     * Returns a word which starts not righter than the right end of the\r\n     * {@code currentWord} but ends strictly righter\r\n     * (or null if does not exist).\r\n     */\r\n    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord) {\r\n        int x \u003d currentWord.x2 - 1;\r\n        int y \u003d y1;\r\n        int yToSkip \u003d currentWord.y;\r\n        HWordPosition result;\r\n        for (; y \u003c y2; y++) {\r\n            if (y \u003d\u003d yToSkip || !entityAt(x, y))\r\n                continue;\r\n            result \u003d scheme.anyHElementAt(x, y);\r\n            if (result \u003d\u003d null)\r\n                continue;\r\n            if (result.x2 \u003e currentWord.x2)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     * \u003cp\u003e\r\n     * If the block has horizontal lines,\r\n     * this method divides the block by the maximal horizontal lines only.\r\n     * \u003cp\u003e\r\n     * If there are no horizontal lines, the block is divided into\r\n     * usual parallel subblocks.\r\n     */\r\n    public List\u003cBlock\u003e extractParallelSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList\u003cBlock\u003e();\r\n        Set\u003cHWordPosition\u003e hLines \u003d getIntersectingHLines();\r\n        if (hLines.size() \u003e 0)\r\n            return extractParallelSubblocksSeparatedByLines(hLines);\r\n        else\r\n            return extractParallelSubblocksWithoutLines();\r\n    }\r\n\r\n    /**\r\n     * Returns the set of all horizontal lines intersecting this block.\r\n     */\r\n    private Set\u003cHWordPosition\u003e getIntersectingHLines() {\r\n        Set\u003cHWordPosition\u003e source \u003d scheme.getHLinesPositions();\r\n        Set\u003cHWordPosition\u003e result \u003d new HashSet\u003cHWordPosition\u003e();\r\n        for (HWordPosition line : source) if (line.intersects(this))\r\n            result.add(line);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks\r\n     * by its most long horizontal lines,\r\n     * optimizes these subblocks, and returns them as a linked list.\r\n     */\r\n    protected List\u003cBlock\u003e extractParallelSubblocksSeparatedByLines(Set\u003cHWordPosition\u003e hLines) {\r\n        removeSmallHLinesFrom(hLines);\r\n        List\u003cInteger\u003e separators \u003d sortedYsOf(hLines);\r\n        return extractParallelSubblocksSeparatedBy(separators);\r\n    }\r\n\r\n    /**\r\n     * Finds the longest lines in the specified set of horizontal lines\r\n     * and then removes from it all other elements.\r\n     * \u003cp\u003e\r\n     * Note that, more formally, this method considers the lengths\r\n     * of \u003ci\u003eintersections\u003c/i\u003e of the lines with this block.\r\n     */\r\n    private void removeSmallHLinesFrom(Set\u003cHWordPosition\u003e hLines) {\r\n        //determine the maximum length:\r\n        int maxLength \u003d 0;\r\n        int length;\r\n        for (HWordPosition line : hLines) {\r\n            length \u003d line.getLengthInsideOf(this);\r\n            maxLength \u003d Math.max(length, maxLength);\r\n        }\r\n        //remove the short lines:\r\n        HWordPosition line;\r\n        Iterator\u003cHWordPosition\u003e i \u003d hLines.iterator();\r\n        for (; i.hasNext(); ) {\r\n            line \u003d i.next();\r\n            if (line.getLengthInsideOf(this) \u003c maxLength)\r\n                i.remove();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a list of the specified horizontal lines\u0027 vertical coordinates.\r\n     */\r\n    private List\u003cInteger\u003e sortedYsOf(Set\u003cHWordPosition\u003e hLines) {\r\n        LinkedList\u003cInteger\u003e linesY \u003d new LinkedList\u003cInteger\u003e();\r\n        for (HWordPosition line : hLines) linesY.add(new Integer(line.y));\r\n        Collections.sort(linesY);\r\n        return linesY;\r\n    }\r\n\r\n    private List\u003cBlock\u003e extractParallelSubblocksSeparatedBy(List\u003cInteger\u003e ySeparators) {\r\n        List\u003cBlock\u003e blocksList \u003d new LinkedList\u003cBlock\u003e();\r\n        Block subBlock;\r\n        //upper bound of a subblock\r\n        int upperY \u003d y1;\r\n        for (int lowerY : ySeparators) {\r\n            if (lowerY \u003e upperY) {\r\n                //there is a (non-trivial?) block between two lines.\r\n                subBlock \u003d new HorizontalBlock(this, x1, upperY, x2, lowerY);\r\n                subBlock.optimize();\r\n                if (!subBlock.isTrivial())\r\n                    blocksList.add(subBlock);\r\n            }\r\n            upperY \u003d lowerY + 1;\r\n        }\r\n        //below the last line:\r\n        if (upperY \u003c y2) {\r\n            subBlock \u003d new HorizontalBlock(this, x1, upperY, x2, y2);\r\n            subBlock.optimize();\r\n            if (!subBlock.isTrivial())\r\n                blocksList.add(subBlock);\r\n        }\r\n        return blocksList;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block without horizontal lines\r\n     * into a set of parallel subblocks, optimizes these subblocks\r\n     * and returns them as a linked list.\r\n     */\r\n    protected List\u003cBlock\u003e extractParallelSubblocksWithoutLines() {\r\n        List\u003cBlock\u003e result \u003d new LinkedList\u003cBlock\u003e();\r\n        Block block;\r\n        for (int y \u003d y1; y \u003c y2; y++) {\r\n            block \u003d subblock(x1, y, x2, y + 1);\r\n            block.optimize();\r\n            if (!block.isTrivial())\r\n                result.add(block);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n",
    "package": "glengineer.blocks",
    "classname": "HorizontalBlock",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlock_2Test.java",
    "test_prompt": "// HorizontalBlock_2Test.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HorizontalBlock}.\n* It contains ten unit test cases for the {@link HorizontalBlock#extractSequentialSubblocks()} method.\n*/\nclass HorizontalBlock_2Test {",
    "method_signature": "extractSequentialSubblocks()",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// HorizontalBlock.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * An implementation of the abstract class {@code Block}\r\n * used for horizontal layouting.\r\n */\r\npublic class HorizontalBlock extends Block {\r\n\r\n    public HorizontalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {\r\n        super(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public HorizontalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {\r\n        super(scheme, p1, p2);\r\n    }\r\n\r\n    public HorizontalBlock(Scheme scheme) {\r\n        super(scheme);\r\n    }\r\n\r\n    public HorizontalBlock(Block b) {\r\n        super(b.scheme, b.getPos1(), b.getPos2());\r\n    }\r\n\r\n    public HorizontalBlock(Block block, int x1, int y1, int x2, int y2) {\r\n        super(block.scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public Block subblock(int x1, int y1, int x2, int y2) {\r\n        return new HorizontalBlock(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public HorizontalBlock cloneWith(CharPosition1 p1) {\r\n        return new HorizontalBlock(scheme, p1, getPos2());\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of sequential subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     *\r\n     * @return\ta list of optimized sequential subblocks.\r\n     */\r\n    public List\u003cBlock\u003e extractSequentialSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList\u003cBlock\u003e();\r\n        List\u003cBlock\u003e result \u003d new LinkedList\u003cBlock\u003e();\r\n        Block firstBlock;\r\n        HorizontalBlock theRest \u003d this;\r\n        do {\r\n            firstBlock \u003d theRest.extractFirstSequentialSubblock();\r\n            theRest \u003d theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));\r\n            firstBlock.optimize();\r\n            if (!firstBlock.isTrivial())\r\n                result.add(firstBlock);\r\n            theRest.optimize();\r\n        } while (!theRest.isTrivial());\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the left subblock of this block.\r\n     * \u003cp\u003e\r\n     * The required block is chosen so that its last exclusive vertical line\r\n     * does not contain elements of components, gaps , or horizontal lines\r\n     * starting on the left from the line.\r\n     * \u003cp\u003e\r\n     * The algorithm just finds the most left entity\r\n     * (an element of a component, gap, or horizontal line)\r\n     * using simple search along the scheme,\r\n     * identifies the horizontal element containing the entity found,\r\n     * checks whether the last exclusive vertical line of the element\r\n     * matches the requirement for the boundary of the required block,\r\n     * and, if does not, takes the detaining horizontal element\r\n     * and continues the cycle.\r\n     */\r\n    private Block extractFirstSequentialSubblock() {\r\n        final HWordPosition firstWord \u003d scheme.anyHElementAt(firstEntity());\r\n        HWordPosition lastWord \u003d firstWord;\r\n        HWordPosition nextWord \u003d firstWord;\r\n        for (; nextWord !\u003d null; ) {\r\n            lastWord \u003d nextWord;\r\n            nextWord \u003d findAWordExtendingSubblockToTheRightFrom(nextWord);\r\n        }\r\n        int startX \u003d firstWord.x1;\r\n        int endX \u003d lastWord.x2;\r\n        //For the case of words containing cells outside of this block:\r\n        startX \u003d Math.max(startX, x1);\r\n        endX \u003d Math.min(endX, x2);\r\n        return subblock(startX, y1, endX, y2);\r\n    }\r\n\r\n    /**\r\n     * Searches down and to the right from the beginning of this block\r\n     * for the first occurrence of an entity.\r\n     * @return\tthe position of the entity found.\r\n     * @throws\tIllegalArgumentException if this block\r\n     * \t\t\tdoes not contain entities.\r\n     */\r\n    private CharPosition firstEntity() {\r\n        int y \u003d firstEntityBelow(x1, y1);\r\n        if (y !\u003d y2)\r\n            return new CharPosition(x1, y);\r\n        int x \u003d x1 + 1;\r\n        for (; x \u003c x2; x++) {\r\n            y \u003d firstEntityBelow(x, y1);\r\n            if (y !\u003d y2)\r\n                break;\r\n        }\r\n        if (x !\u003d x2)\r\n            return new CharPosition(x, y);\r\n        else\r\n            throw new IllegalArgumentException(\"Can not extract a group from an empty block:\\n\" + this);\r\n    }\r\n\r\n    /**\r\n     * Finds the first entity below the specified position.\r\n     * @return\tthe y-coordinate of the entity found or y2 if not found.\r\n     */\r\n    private int firstEntityBelow(int x, int y) {\r\n        for (; y \u003c y2; y++) if (entityAt(x, y))\r\n            break;\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the character under the cell\r\n     * determined by the specified coordinates\r\n     * is a word character or a horizontal line character.\r\n     */\r\n    private boolean entityAt(int x, int y) {\r\n        char c \u003d charAt(x, y);\r\n        /* \r\n\t\t * Since all symbols on the scheme are correct\r\n\t\t * (which has been verified in its constructor),\r\n\t\t * there is no need to use the slower method isWordChar().\r\n\t\t */\r\n        return c !\u003d \u0027 \u0027 \u0026\u0026 c !\u003d \u0027|\u0027;\r\n    }\r\n\r\n    /**\r\n     * Returns a word which starts not righter than the right end of the\r\n     * {@code currentWord} but ends strictly righter\r\n     * (or null if does not exist).\r\n     */\r\n    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord) {\r\n        int x \u003d currentWord.x2 - 1;\r\n        int y \u003d y1;\r\n        int yToSkip \u003d currentWord.y;\r\n        HWordPosition result;\r\n        for (; y \u003c y2; y++) {\r\n            if (y \u003d\u003d yToSkip || !entityAt(x, y))\r\n                continue;\r\n            result \u003d scheme.anyHElementAt(x, y);\r\n            if (result \u003d\u003d null)\r\n                continue;\r\n            if (result.x2 \u003e currentWord.x2)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     * \u003cp\u003e\r\n     * If the block has horizontal lines,\r\n     * this method divides the block by the maximal horizontal lines only.\r\n     * \u003cp\u003e\r\n     * If there are no horizontal lines, the block is divided into\r\n     * usual parallel subblocks.\r\n     */\r\n    public List\u003cBlock\u003e extractParallelSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList\u003cBlock\u003e();\r\n        Set\u003cHWordPosition\u003e hLines \u003d getIntersectingHLines();\r\n        if (hLines.size() \u003e 0)\r\n            return extractParallelSubblocksSeparatedByLines(hLines);\r\n        else\r\n            return extractParallelSubblocksWithoutLines();\r\n    }\r\n\r\n    /**\r\n     * Returns the set of all horizontal lines intersecting this block.\r\n     */\r\n    private Set\u003cHWordPosition\u003e getIntersectingHLines() {\r\n        Set\u003cHWordPosition\u003e source \u003d scheme.getHLinesPositions();\r\n        Set\u003cHWordPosition\u003e result \u003d new HashSet\u003cHWordPosition\u003e();\r\n        for (HWordPosition line : source) if (line.intersects(this))\r\n            result.add(line);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks\r\n     * by its most long horizontal lines,\r\n     * optimizes these subblocks, and returns them as a linked list.\r\n     */\r\n    protected List\u003cBlock\u003e extractParallelSubblocksSeparatedByLines(Set\u003cHWordPosition\u003e hLines) {\r\n        removeSmallHLinesFrom(hLines);\r\n        List\u003cInteger\u003e separators \u003d sortedYsOf(hLines);\r\n        return extractParallelSubblocksSeparatedBy(separators);\r\n    }\r\n\r\n    /**\r\n     * Finds the longest lines in the specified set of horizontal lines\r\n     * and then removes from it all other elements.\r\n     * \u003cp\u003e\r\n     * Note that, more formally, this method considers the lengths\r\n     * of \u003ci\u003eintersections\u003c/i\u003e of the lines with this block.\r\n     */\r\n    private void removeSmallHLinesFrom(Set\u003cHWordPosition\u003e hLines) {\r\n        //determine the maximum length:\r\n        int maxLength \u003d 0;\r\n        int length;\r\n        for (HWordPosition line : hLines) {\r\n            length \u003d line.getLengthInsideOf(this);\r\n            maxLength \u003d Math.max(length, maxLength);\r\n        }\r\n        //remove the short lines:\r\n        HWordPosition line;\r\n        Iterator\u003cHWordPosition\u003e i \u003d hLines.iterator();\r\n        for (; i.hasNext(); ) {\r\n            line \u003d i.next();\r\n            if (line.getLengthInsideOf(this) \u003c maxLength)\r\n                i.remove();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a list of the specified horizontal lines\u0027 vertical coordinates.\r\n     */\r\n    private List\u003cInteger\u003e sortedYsOf(Set\u003cHWordPosition\u003e hLines) {\r\n        LinkedList\u003cInteger\u003e linesY \u003d new LinkedList\u003cInteger\u003e();\r\n        for (HWordPosition line : hLines) linesY.add(new Integer(line.y));\r\n        Collections.sort(linesY);\r\n        return linesY;\r\n    }\r\n\r\n    private List\u003cBlock\u003e extractParallelSubblocksSeparatedBy(List\u003cInteger\u003e ySeparators) {\r\n        List\u003cBlock\u003e blocksList \u003d new LinkedList\u003cBlock\u003e();\r\n        Block subBlock;\r\n        //upper bound of a subblock\r\n        int upperY \u003d y1;\r\n        for (int lowerY : ySeparators) {\r\n            if (lowerY \u003e upperY) {\r\n                //there is a (non-trivial?) block between two lines.\r\n                subBlock \u003d new HorizontalBlock(this, x1, upperY, x2, lowerY);\r\n                subBlock.optimize();\r\n                if (!subBlock.isTrivial())\r\n                    blocksList.add(subBlock);\r\n            }\r\n            upperY \u003d lowerY + 1;\r\n        }\r\n        //below the last line:\r\n        if (upperY \u003c y2) {\r\n            subBlock \u003d new HorizontalBlock(this, x1, upperY, x2, y2);\r\n            subBlock.optimize();\r\n            if (!subBlock.isTrivial())\r\n                blocksList.add(subBlock);\r\n        }\r\n        return blocksList;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block without horizontal lines\r\n     * into a set of parallel subblocks, optimizes these subblocks\r\n     * and returns them as a linked list.\r\n     */\r\n    protected List\u003cBlock\u003e extractParallelSubblocksWithoutLines() {\r\n        List\u003cBlock\u003e result \u003d new LinkedList\u003cBlock\u003e();\r\n        Block block;\r\n        for (int y \u003d y1; y \u003c y2; y++) {\r\n            block \u003d subblock(x1, y, x2, y + 1);\r\n            block.optimize();\r\n            if (!block.isTrivial())\r\n                result.add(block);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n",
    "package": "glengineer.blocks",
    "classname": "HorizontalBlock",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlock_3Test.java",
    "test_prompt": "// HorizontalBlock_3Test.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HorizontalBlock}.\n* It contains ten unit test cases for the {@link HorizontalBlock#extractParallelSubblocks()} method.\n*/\nclass HorizontalBlock_3Test {",
    "method_signature": "extractParallelSubblocks()",
    "suffix": "3"
  },
  {
    "numberTests": "ten",
    "original_code": "// VerticalBlock.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * An implementation of the abstract class {@code Block}\r\n * used for vertical layouting.\r\n */\r\npublic class VerticalBlock extends Block {\r\n\r\n    public VerticalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {\r\n        super(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public VerticalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {\r\n        super(scheme, p1, p2);\r\n    }\r\n\r\n    public VerticalBlock(Scheme scheme) {\r\n        super(scheme);\r\n    }\r\n\r\n    public VerticalBlock(Block b) {\r\n        super(b.scheme, b.getPos1(), b.getPos2());\r\n    }\r\n\r\n    public VerticalBlock(Block block, int x1, int y1, int x2, int y2) {\r\n        super(block.scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public VerticalBlock subblock(int x1, int y1, int x2, int y2) {\r\n        return new VerticalBlock(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public VerticalBlock cloneWith(CharPosition1 p1) {\r\n        return new VerticalBlock(scheme, p1, getPos2());\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of sequential subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     *\r\n     * @return\ta list of optimized sequential subblocks.\r\n     */\r\n    public List\u003cBlock\u003e extractSequentialSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList\u003cBlock\u003e();\r\n        List\u003cBlock\u003e result \u003d new LinkedList\u003cBlock\u003e();\r\n        VerticalBlock firstBlock;\r\n        VerticalBlock theRest \u003d this;\r\n        do {\r\n            firstBlock \u003d theRest.extractFirstSequentialSubblock();\r\n            theRest \u003d theRest.cloneWith(new CharPosition1(this.x1, firstBlock.y2));\r\n            firstBlock.optimize();\r\n            if (!firstBlock.isTrivial())\r\n                result.add(firstBlock);\r\n            theRest.optimize();\r\n        } while (!theRest.isTrivial());\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the upper subblock of this block.\r\n     * \u003cp\u003e\r\n     * The required block is chosen so that its last exclusive horizontal line\r\n     * does not contain elements of vertical lines\r\n     * starting above the line.\r\n     * \u003cp\u003e\r\n     * The algorithm finds the upper entity\r\n     * (an element of a component, gap, or vertical line)\r\n     * using simple search along the scheme,\r\n     * and retains it as the top of the required block.\r\n     * Then, starting from the height of that point,\r\n     * it sequentially finds vertical lines\r\n     * end below but begin not below\r\n     * and moves to lower end of such lines.\r\n     * The lower end of the last such vertical line defines\r\n     * the bottom of the required block.\r\n     */\r\n    private VerticalBlock extractFirstSequentialSubblock() {\r\n        Set\u003cVWordPosition\u003e vLines \u003d getIntersectingVLines();\r\n        CharPosition blockStart \u003d getBlockStart();\r\n        int y2 \u003d getUpperSubblockEnd(blockStart, vLines);\r\n        return subblock(this.x1, blockStart.y, this.x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Returns the set of all vertical lines intersecting this block.\r\n     */\r\n    private Set\u003cVWordPosition\u003e getIntersectingVLines() {\r\n        Set\u003cVWordPosition\u003e source \u003d scheme.getVLinesPositions();\r\n        Set\u003cVWordPosition\u003e result \u003d new HashSet\u003cVWordPosition\u003e();\r\n        for (VWordPosition line : source) if (line.intersects(this))\r\n            result.add(line);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Finds the upper entity (an element of a word or vertical line)\r\n     * of this block.\r\n     * Returns its position on the scheme.\r\n     * @throws\tIllegalArgumentException if this block happens to be empty.\r\n     */\r\n    private CharPosition getBlockStart() {\r\n        int x \u003d x1;\r\n        int y \u003d y1;\r\n        for (; y \u003c y2; y++) for (x \u003d x1; x \u003c x2; x++) if (entityAt(x, y))\r\n            return new CharPosition(x, y);\r\n        throw new IllegalArgumentException(\"Can not extract elements from an empty block:\\n\" + this);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the character under the cell\r\n     * determined by the specified coordinates\r\n     * is a word character or a vertical line character.\r\n     */\r\n    private boolean entityAt(int x, int y) {\r\n        char c \u003d charAt(x, y);\r\n        /* \r\n\t\t * Since all symbols on the scheme are correct\r\n\t\t * (which has been verified in its constructor),\r\n\t\t * there is no need to use the slower method isWordChar().\r\n\t\t */\r\n        return c !\u003d \u0027 \u0027 \u0026\u0026 c !\u003d \u0027-\u0027;\r\n    }\r\n\r\n    /**\r\n     * Finds the last line of the subblock\r\n     * containing the specified position {@code blockStart}.\r\n     * Returns the coordinate {@code y2} of such block.\r\n     */\r\n    private int getUpperSubblockEnd(CharPosition blockStart, Set\u003cVWordPosition\u003e vLines) {\r\n        int nextY \u003d blockStart.y;\r\n        int currentY;\r\n        do {\r\n            currentY \u003d nextY;\r\n            nextY \u003d y2OfAVLineCovering(currentY, vLines);\r\n        } while (nextY \u003e currentY \u0026\u0026 nextY \u003c y2 - 1);\r\n        return Math.min(y2, nextY + 1);\r\n    }\r\n\r\n    /**\r\n     * Finds a vertical line which vertical range covers\r\n     * the specified value {@code y}\r\n     * and which lower point is lower than {@code y}.\r\n     * Returns the position of the last element of such line (inclusive)\r\n     * or {@code y} if such line does not exist.\r\n     */\r\n    private int y2OfAVLineCovering(int y, Set\u003cVWordPosition\u003e vLines) {\r\n        for (VWordPosition line : vLines) if (line.y1 \u003c\u003d y \u0026\u0026 y + 1 \u003c line.y2)\r\n            return line.y2 - 1;\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     * \u003cp\u003e\r\n     * If the block has vertical lines,\r\n     * this method divides the block by the maximal vertical lines only.\r\n     * \u003cp\u003e\r\n     * If there are no vertical lines, the block is divided into\r\n     * usual parallel subblocks.\r\n     */\r\n    public List\u003cBlock\u003e extractParallelSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList\u003cBlock\u003e();\r\n        Set\u003cVWordPosition\u003e vLines \u003d getIntersectingVLines();\r\n        if (vLines.size() \u003e 0)\r\n            return extractParallelSubblocksSeparatedByLines(vLines);\r\n        else\r\n            return extractParallelSubblocksWithoutLines();\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks\r\n     * by its most long vertical lines,\r\n     * optimizes these subblocks, and returns them as a linked list.\r\n     */\r\n    protected List\u003cBlock\u003e extractParallelSubblocksSeparatedByLines(Set\u003cVWordPosition\u003e vLines) {\r\n        removeSmallVLinesFrom(vLines);\r\n        return extractParallelSubblocksSeparatedBy(vLines);\r\n    }\r\n\r\n    /**\r\n     * Finds the longest lines in the specified set of vertical lines\r\n     * and then removes from it all other elements.\r\n     * \u003cp\u003e\r\n     * Note that, more formally, this method considers the lengths\r\n     * of \u003ci\u003eintersections\u003c/i\u003e of the lines with this block.\r\n     */\r\n    private void removeSmallVLinesFrom(Set\u003cVWordPosition\u003e vLines) {\r\n        //determine the maximum length:\r\n        int maxLength \u003d 0;\r\n        int length;\r\n        for (VWordPosition line : vLines) {\r\n            length \u003d line.getLengthInsideOf(this);\r\n            maxLength \u003d Math.max(length, maxLength);\r\n        }\r\n        //remove the short lines:\r\n        VWordPosition line;\r\n        Iterator\u003cVWordPosition\u003e i \u003d vLines.iterator();\r\n        for (; i.hasNext(); ) {\r\n            line \u003d i.next();\r\n            if (line.getLengthInsideOf(this) \u003c maxLength)\r\n                i.remove();\r\n        }\r\n    }\r\n\r\n    private List\u003cBlock\u003e extractParallelSubblocksSeparatedBy(Set\u003cVWordPosition\u003e separators) {\r\n        List\u003cBlock\u003e result \u003d new LinkedList\u003cBlock\u003e();\r\n        Block subBlock;\r\n        //the left bound of a subblock\r\n        int leftX \u003d x1;\r\n        //the exclusive right bound of a subblock\r\n        int rightX;\r\n        //(may exist; widens the separator)\r\n        HWordPosition gapAtSeparator \u003d null;\r\n        for (VWordPosition rightSeparator : sortedVLines(separators)) {\r\n            rightX \u003d rightSeparator.x;\r\n            //if the separator has a gap, the latter must be skipped:\r\n            gapAtSeparator \u003d scheme.gapAtLine(rightSeparator);\r\n            if (gapAtSeparator !\u003d null)\r\n                rightX \u003d gapAtSeparator.x1;\r\n            //adding the subblock between leftX and rightX:\r\n            if (rightX \u003e leftX + 1) {\r\n                subBlock \u003d subblock(leftX, y1, rightX, y2);\r\n                subBlock.optimize();\r\n                if (!subBlock.isTrivial())\r\n                    result.add(subBlock);\r\n            }\r\n            //iterating leftX:\r\n            if (gapAtSeparator \u003d\u003d null)\r\n                leftX \u003d rightX + 1;\r\n            else\r\n                leftX \u003d gapAtSeparator.x2;\r\n        }\r\n        //on the right of the last line:\r\n        if (leftX \u003c x2) {\r\n            subBlock \u003d subblock(leftX, y1, x2, y2);\r\n            subBlock.optimize();\r\n            if (!subBlock.isTrivial())\r\n                result.add(subBlock);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /*\r\n\t * Returns a list of the specified vertical lines\r\n\t * sorted according to the horizontal coordinates.\r\n\t */\r\n    private List\u003cVWordPosition\u003e sortedVLines(Set\u003cVWordPosition\u003e vLines) {\r\n        LinkedList\u003cVWordPosition\u003e list \u003d new LinkedList\u003cVWordPosition\u003e(vLines);\r\n        Collections.sort(list);\r\n        return list;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block without vertical lines\r\n     * into a set of (optimized) parallel subblocks.\r\n     * Returns them as a linked list.\r\n     */\r\n    protected List\u003cBlock\u003e extractParallelSubblocksWithoutLines() {\r\n        List\u003cBlock\u003e result \u003d new LinkedList\u003cBlock\u003e();\r\n        Block firstBlock;\r\n        VerticalBlock theRest \u003d this;\r\n        do {\r\n            firstBlock \u003d theRest.extractFirstParallelSubblock();\r\n            theRest \u003d theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));\r\n            firstBlock.optimize();\r\n            if (!firstBlock.isTrivial())\r\n                result.add(firstBlock);\r\n            theRest.optimize();\r\n        } while (!theRest.isTrivial());\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the left subblock of this block.\r\n     * \u003cp\u003e\r\n     * The required block is chosen so that its last exclusive vertical line\r\n     * does not contain elements of components or gaps\r\n     * starting on the left from the line.\r\n     * \u003cp\u003e\r\n     * The algorithm just finds the most left entity\r\n     * (an element of a component or gap)\r\n     * using simple search along the scheme,\r\n     * identifies the horizontal element containing the entity found,\r\n     * checks whether the last exclusive vertical line of the element\r\n     * matches the requirement for the boundary of the required block,\r\n     * and, if does not, takes the detaining horizontal element\r\n     * and continues the cycle.\r\n     */\r\n    private Block extractFirstParallelSubblock() {\r\n        final HWordPosition firstWord \u003d scheme.anyHElementAt(firstWordChar());\r\n        HWordPosition lastWord \u003d firstWord;\r\n        HWordPosition nextWord \u003d firstWord;\r\n        for (; nextWord !\u003d null; ) {\r\n            lastWord \u003d nextWord;\r\n            nextWord \u003d findAWordExtendingSubblockToTheRightFrom(nextWord);\r\n        }\r\n        int startX \u003d firstWord.x1;\r\n        int endX \u003d lastWord.x2;\r\n        //For the case of words containing cells outside of this block:\r\n        startX \u003d Math.max(startX, x1);\r\n        endX \u003d Math.min(endX, x2);\r\n        return subblock(startX, y1, endX, y2);\r\n    }\r\n\r\n    /**\r\n     * Searches down and to the right from the beginning of this block\r\n     * for the first occurrence of a word character.\r\n     * @return\tthe position of the word character found.\r\n     * @throws\tIllegalArgumentException if this block\r\n     * \t\t\tdoes not contain word characters.\r\n     */\r\n    private CharPosition firstWordChar() {\r\n        int y \u003d firstWordCharBelow(x1, y1);\r\n        if (y !\u003d y2)\r\n            return new CharPosition(x1, y);\r\n        int x \u003d x1 + 1;\r\n        for (; x \u003c x2; x++) {\r\n            y \u003d firstWordCharBelow(x, y1);\r\n            if (y !\u003d y2)\r\n                break;\r\n        }\r\n        if (x !\u003d x2)\r\n            return new CharPosition(x, y);\r\n        else\r\n            throw new IllegalArgumentException(\"Can not extract a group from an empty block:\\n\" + this);\r\n    }\r\n\r\n    /**\r\n     * Finds the first entity below the specified position.\r\n     * @return\tthe y-coordinate of the entity found or y2 if not found.\r\n     */\r\n    private int firstWordCharBelow(int x, int y) {\r\n        for (; y \u003c y2; y++) if (wordCharAt(x, y))\r\n            break;\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the character under the cell\r\n     * determined by the specified coordinates\r\n     * is a word character.\r\n     * \u003cp\u003e\r\n     * Overrides the less optimal method {@code CharTable.wordCharAt()}.\r\n     * Since all symbols on the scheme are definitely correct\r\n     * (which has been verified in its constructor),\r\n     * there is no need to use slower method.\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        char c \u003d charAt(x, y);\r\n        return c !\u003d \u0027 \u0027 \u0026\u0026 c !\u003d \u0027-\u0027 \u0026\u0026 c !\u003d \u0027|\u0027 \u0026\u0026 c !\u003d \u0027+\u0027;\r\n    }\r\n\r\n    /**\r\n     * Returns a word which starts not righter than the right end of the\r\n     * {@code currentWord} but ends strictly righter\r\n     * (or null if does not exist).\r\n     */\r\n    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord) {\r\n        int x \u003d currentWord.x2 - 1;\r\n        int y \u003d y1;\r\n        int yToSkip \u003d currentWord.y;\r\n        HWordPosition result;\r\n        for (; y \u003c y2; y++) {\r\n            if (y \u003d\u003d yToSkip || !wordCharAt(x, y))\r\n                continue;\r\n            result \u003d scheme.anyHElementAt(x, y);\r\n            if (result \u003d\u003d null)\r\n                continue;\r\n            if (result.x2 \u003e currentWord.x2)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n",
    "package": "glengineer.blocks",
    "classname": "VerticalBlock",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/blocks/VerticalBlock_2Test.java",
    "test_prompt": "// VerticalBlock_2Test.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VerticalBlock}.\n* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.\n*/\nclass VerticalBlock_2Test {",
    "method_signature": "extractSequentialSubblocks()",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// VerticalBlock.java\npackage glengineer.blocks;\r\n\r\nimport glengineer.positions.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * An implementation of the abstract class {@code Block}\r\n * used for vertical layouting.\r\n */\r\npublic class VerticalBlock extends Block {\r\n\r\n    public VerticalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {\r\n        super(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public VerticalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {\r\n        super(scheme, p1, p2);\r\n    }\r\n\r\n    public VerticalBlock(Scheme scheme) {\r\n        super(scheme);\r\n    }\r\n\r\n    public VerticalBlock(Block b) {\r\n        super(b.scheme, b.getPos1(), b.getPos2());\r\n    }\r\n\r\n    public VerticalBlock(Block block, int x1, int y1, int x2, int y2) {\r\n        super(block.scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public VerticalBlock subblock(int x1, int y1, int x2, int y2) {\r\n        return new VerticalBlock(scheme, x1, y1, x2, y2);\r\n    }\r\n\r\n    public VerticalBlock cloneWith(CharPosition1 p1) {\r\n        return new VerticalBlock(scheme, p1, getPos2());\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of sequential subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     *\r\n     * @return\ta list of optimized sequential subblocks.\r\n     */\r\n    public List\u003cBlock\u003e extractSequentialSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList\u003cBlock\u003e();\r\n        List\u003cBlock\u003e result \u003d new LinkedList\u003cBlock\u003e();\r\n        VerticalBlock firstBlock;\r\n        VerticalBlock theRest \u003d this;\r\n        do {\r\n            firstBlock \u003d theRest.extractFirstSequentialSubblock();\r\n            theRest \u003d theRest.cloneWith(new CharPosition1(this.x1, firstBlock.y2));\r\n            firstBlock.optimize();\r\n            if (!firstBlock.isTrivial())\r\n                result.add(firstBlock);\r\n            theRest.optimize();\r\n        } while (!theRest.isTrivial());\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the upper subblock of this block.\r\n     * \u003cp\u003e\r\n     * The required block is chosen so that its last exclusive horizontal line\r\n     * does not contain elements of vertical lines\r\n     * starting above the line.\r\n     * \u003cp\u003e\r\n     * The algorithm finds the upper entity\r\n     * (an element of a component, gap, or vertical line)\r\n     * using simple search along the scheme,\r\n     * and retains it as the top of the required block.\r\n     * Then, starting from the height of that point,\r\n     * it sequentially finds vertical lines\r\n     * end below but begin not below\r\n     * and moves to lower end of such lines.\r\n     * The lower end of the last such vertical line defines\r\n     * the bottom of the required block.\r\n     */\r\n    private VerticalBlock extractFirstSequentialSubblock() {\r\n        Set\u003cVWordPosition\u003e vLines \u003d getIntersectingVLines();\r\n        CharPosition blockStart \u003d getBlockStart();\r\n        int y2 \u003d getUpperSubblockEnd(blockStart, vLines);\r\n        return subblock(this.x1, blockStart.y, this.x2, y2);\r\n    }\r\n\r\n    /**\r\n     * Returns the set of all vertical lines intersecting this block.\r\n     */\r\n    private Set\u003cVWordPosition\u003e getIntersectingVLines() {\r\n        Set\u003cVWordPosition\u003e source \u003d scheme.getVLinesPositions();\r\n        Set\u003cVWordPosition\u003e result \u003d new HashSet\u003cVWordPosition\u003e();\r\n        for (VWordPosition line : source) if (line.intersects(this))\r\n            result.add(line);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Finds the upper entity (an element of a word or vertical line)\r\n     * of this block.\r\n     * Returns its position on the scheme.\r\n     * @throws\tIllegalArgumentException if this block happens to be empty.\r\n     */\r\n    private CharPosition getBlockStart() {\r\n        int x \u003d x1;\r\n        int y \u003d y1;\r\n        for (; y \u003c y2; y++) for (x \u003d x1; x \u003c x2; x++) if (entityAt(x, y))\r\n            return new CharPosition(x, y);\r\n        throw new IllegalArgumentException(\"Can not extract elements from an empty block:\\n\" + this);\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the character under the cell\r\n     * determined by the specified coordinates\r\n     * is a word character or a vertical line character.\r\n     */\r\n    private boolean entityAt(int x, int y) {\r\n        char c \u003d charAt(x, y);\r\n        /* \r\n\t\t * Since all symbols on the scheme are correct\r\n\t\t * (which has been verified in its constructor),\r\n\t\t * there is no need to use the slower method isWordChar().\r\n\t\t */\r\n        return c !\u003d \u0027 \u0027 \u0026\u0026 c !\u003d \u0027-\u0027;\r\n    }\r\n\r\n    /**\r\n     * Finds the last line of the subblock\r\n     * containing the specified position {@code blockStart}.\r\n     * Returns the coordinate {@code y2} of such block.\r\n     */\r\n    private int getUpperSubblockEnd(CharPosition blockStart, Set\u003cVWordPosition\u003e vLines) {\r\n        int nextY \u003d blockStart.y;\r\n        int currentY;\r\n        do {\r\n            currentY \u003d nextY;\r\n            nextY \u003d y2OfAVLineCovering(currentY, vLines);\r\n        } while (nextY \u003e currentY \u0026\u0026 nextY \u003c y2 - 1);\r\n        return Math.min(y2, nextY + 1);\r\n    }\r\n\r\n    /**\r\n     * Finds a vertical line which vertical range covers\r\n     * the specified value {@code y}\r\n     * and which lower point is lower than {@code y}.\r\n     * Returns the position of the last element of such line (inclusive)\r\n     * or {@code y} if such line does not exist.\r\n     */\r\n    private int y2OfAVLineCovering(int y, Set\u003cVWordPosition\u003e vLines) {\r\n        for (VWordPosition line : vLines) if (line.y1 \u003c\u003d y \u0026\u0026 y + 1 \u003c line.y2)\r\n            return line.y2 - 1;\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks,\r\n     * optimizes these subblocks and returns them as a linked list.\r\n     * \u003cp\u003e\r\n     * If the block has vertical lines,\r\n     * this method divides the block by the maximal vertical lines only.\r\n     * \u003cp\u003e\r\n     * If there are no vertical lines, the block is divided into\r\n     * usual parallel subblocks.\r\n     */\r\n    public List\u003cBlock\u003e extractParallelSubblocks() {\r\n        this.optimize();\r\n        if (isTrivial())\r\n            return new LinkedList\u003cBlock\u003e();\r\n        Set\u003cVWordPosition\u003e vLines \u003d getIntersectingVLines();\r\n        if (vLines.size() \u003e 0)\r\n            return extractParallelSubblocksSeparatedByLines(vLines);\r\n        else\r\n            return extractParallelSubblocksWithoutLines();\r\n    }\r\n\r\n    /**\r\n     * Divides the current block into a set of parallel subblocks\r\n     * by its most long vertical lines,\r\n     * optimizes these subblocks, and returns them as a linked list.\r\n     */\r\n    protected List\u003cBlock\u003e extractParallelSubblocksSeparatedByLines(Set\u003cVWordPosition\u003e vLines) {\r\n        removeSmallVLinesFrom(vLines);\r\n        return extractParallelSubblocksSeparatedBy(vLines);\r\n    }\r\n\r\n    /**\r\n     * Finds the longest lines in the specified set of vertical lines\r\n     * and then removes from it all other elements.\r\n     * \u003cp\u003e\r\n     * Note that, more formally, this method considers the lengths\r\n     * of \u003ci\u003eintersections\u003c/i\u003e of the lines with this block.\r\n     */\r\n    private void removeSmallVLinesFrom(Set\u003cVWordPosition\u003e vLines) {\r\n        //determine the maximum length:\r\n        int maxLength \u003d 0;\r\n        int length;\r\n        for (VWordPosition line : vLines) {\r\n            length \u003d line.getLengthInsideOf(this);\r\n            maxLength \u003d Math.max(length, maxLength);\r\n        }\r\n        //remove the short lines:\r\n        VWordPosition line;\r\n        Iterator\u003cVWordPosition\u003e i \u003d vLines.iterator();\r\n        for (; i.hasNext(); ) {\r\n            line \u003d i.next();\r\n            if (line.getLengthInsideOf(this) \u003c maxLength)\r\n                i.remove();\r\n        }\r\n    }\r\n\r\n    private List\u003cBlock\u003e extractParallelSubblocksSeparatedBy(Set\u003cVWordPosition\u003e separators) {\r\n        List\u003cBlock\u003e result \u003d new LinkedList\u003cBlock\u003e();\r\n        Block subBlock;\r\n        //the left bound of a subblock\r\n        int leftX \u003d x1;\r\n        //the exclusive right bound of a subblock\r\n        int rightX;\r\n        //(may exist; widens the separator)\r\n        HWordPosition gapAtSeparator \u003d null;\r\n        for (VWordPosition rightSeparator : sortedVLines(separators)) {\r\n            rightX \u003d rightSeparator.x;\r\n            //if the separator has a gap, the latter must be skipped:\r\n            gapAtSeparator \u003d scheme.gapAtLine(rightSeparator);\r\n            if (gapAtSeparator !\u003d null)\r\n                rightX \u003d gapAtSeparator.x1;\r\n            //adding the subblock between leftX and rightX:\r\n            if (rightX \u003e leftX + 1) {\r\n                subBlock \u003d subblock(leftX, y1, rightX, y2);\r\n                subBlock.optimize();\r\n                if (!subBlock.isTrivial())\r\n                    result.add(subBlock);\r\n            }\r\n            //iterating leftX:\r\n            if (gapAtSeparator \u003d\u003d null)\r\n                leftX \u003d rightX + 1;\r\n            else\r\n                leftX \u003d gapAtSeparator.x2;\r\n        }\r\n        //on the right of the last line:\r\n        if (leftX \u003c x2) {\r\n            subBlock \u003d subblock(leftX, y1, x2, y2);\r\n            subBlock.optimize();\r\n            if (!subBlock.isTrivial())\r\n                result.add(subBlock);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /*\r\n\t * Returns a list of the specified vertical lines\r\n\t * sorted according to the horizontal coordinates.\r\n\t */\r\n    private List\u003cVWordPosition\u003e sortedVLines(Set\u003cVWordPosition\u003e vLines) {\r\n        LinkedList\u003cVWordPosition\u003e list \u003d new LinkedList\u003cVWordPosition\u003e(vLines);\r\n        Collections.sort(list);\r\n        return list;\r\n    }\r\n\r\n    /**\r\n     * Divides the current block without vertical lines\r\n     * into a set of (optimized) parallel subblocks.\r\n     * Returns them as a linked list.\r\n     */\r\n    protected List\u003cBlock\u003e extractParallelSubblocksWithoutLines() {\r\n        List\u003cBlock\u003e result \u003d new LinkedList\u003cBlock\u003e();\r\n        Block firstBlock;\r\n        VerticalBlock theRest \u003d this;\r\n        do {\r\n            firstBlock \u003d theRest.extractFirstParallelSubblock();\r\n            theRest \u003d theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));\r\n            firstBlock.optimize();\r\n            if (!firstBlock.isTrivial())\r\n                result.add(firstBlock);\r\n            theRest.optimize();\r\n        } while (!theRest.isTrivial());\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the left subblock of this block.\r\n     * \u003cp\u003e\r\n     * The required block is chosen so that its last exclusive vertical line\r\n     * does not contain elements of components or gaps\r\n     * starting on the left from the line.\r\n     * \u003cp\u003e\r\n     * The algorithm just finds the most left entity\r\n     * (an element of a component or gap)\r\n     * using simple search along the scheme,\r\n     * identifies the horizontal element containing the entity found,\r\n     * checks whether the last exclusive vertical line of the element\r\n     * matches the requirement for the boundary of the required block,\r\n     * and, if does not, takes the detaining horizontal element\r\n     * and continues the cycle.\r\n     */\r\n    private Block extractFirstParallelSubblock() {\r\n        final HWordPosition firstWord \u003d scheme.anyHElementAt(firstWordChar());\r\n        HWordPosition lastWord \u003d firstWord;\r\n        HWordPosition nextWord \u003d firstWord;\r\n        for (; nextWord !\u003d null; ) {\r\n            lastWord \u003d nextWord;\r\n            nextWord \u003d findAWordExtendingSubblockToTheRightFrom(nextWord);\r\n        }\r\n        int startX \u003d firstWord.x1;\r\n        int endX \u003d lastWord.x2;\r\n        //For the case of words containing cells outside of this block:\r\n        startX \u003d Math.max(startX, x1);\r\n        endX \u003d Math.min(endX, x2);\r\n        return subblock(startX, y1, endX, y2);\r\n    }\r\n\r\n    /**\r\n     * Searches down and to the right from the beginning of this block\r\n     * for the first occurrence of a word character.\r\n     * @return\tthe position of the word character found.\r\n     * @throws\tIllegalArgumentException if this block\r\n     * \t\t\tdoes not contain word characters.\r\n     */\r\n    private CharPosition firstWordChar() {\r\n        int y \u003d firstWordCharBelow(x1, y1);\r\n        if (y !\u003d y2)\r\n            return new CharPosition(x1, y);\r\n        int x \u003d x1 + 1;\r\n        for (; x \u003c x2; x++) {\r\n            y \u003d firstWordCharBelow(x, y1);\r\n            if (y !\u003d y2)\r\n                break;\r\n        }\r\n        if (x !\u003d x2)\r\n            return new CharPosition(x, y);\r\n        else\r\n            throw new IllegalArgumentException(\"Can not extract a group from an empty block:\\n\" + this);\r\n    }\r\n\r\n    /**\r\n     * Finds the first entity below the specified position.\r\n     * @return\tthe y-coordinate of the entity found or y2 if not found.\r\n     */\r\n    private int firstWordCharBelow(int x, int y) {\r\n        for (; y \u003c y2; y++) if (wordCharAt(x, y))\r\n            break;\r\n        return y;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether the character under the cell\r\n     * determined by the specified coordinates\r\n     * is a word character.\r\n     * \u003cp\u003e\r\n     * Overrides the less optimal method {@code CharTable.wordCharAt()}.\r\n     * Since all symbols on the scheme are definitely correct\r\n     * (which has been verified in its constructor),\r\n     * there is no need to use slower method.\r\n     */\r\n    public boolean wordCharAt(int x, int y) {\r\n        char c \u003d charAt(x, y);\r\n        return c !\u003d \u0027 \u0027 \u0026\u0026 c !\u003d \u0027-\u0027 \u0026\u0026 c !\u003d \u0027|\u0027 \u0026\u0026 c !\u003d \u0027+\u0027;\r\n    }\r\n\r\n    /**\r\n     * Returns a word which starts not righter than the right end of the\r\n     * {@code currentWord} but ends strictly righter\r\n     * (or null if does not exist).\r\n     */\r\n    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord) {\r\n        int x \u003d currentWord.x2 - 1;\r\n        int y \u003d y1;\r\n        int yToSkip \u003d currentWord.y;\r\n        HWordPosition result;\r\n        for (; y \u003c y2; y++) {\r\n            if (y \u003d\u003d yToSkip || !wordCharAt(x, y))\r\n                continue;\r\n            result \u003d scheme.anyHElementAt(x, y);\r\n            if (result \u003d\u003d null)\r\n                continue;\r\n            if (result.x2 \u003e currentWord.x2)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n",
    "package": "glengineer.blocks",
    "classname": "VerticalBlock",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/blocks/VerticalBlock_3Test.java",
    "test_prompt": "// VerticalBlock_3Test.java\npackage glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VerticalBlock}.\n* It contains ten unit test cases for the {@link VerticalBlock#extractParallelSubblocks()} method.\n*/\nclass VerticalBlock_3Test {",
    "method_signature": "extractParallelSubblocks()",
    "suffix": "3"
  },
  {
    "numberTests": "ten",
    "original_code": "// GroupLayoutEngineer.java\npackage glengineer;\n\nimport glengineer.agents.*;\nimport glengineer.agents.setters.*;\nimport glengineer.agents.settings.*;\nimport glengineer.blocks.*;\nimport java.util.*;\nimport java.awt.Component;\nimport java.awt.Container;\nimport javax.swing.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\n\n/**\n * {@code GroupLayoutEngineer} is a shell for the layout manager\n * {@code GroupLayout}. It allows to control components\u0027 placement\n * using simple 2-dimensional textual schemes.\n * \u003cp\u003e\n * Such approach to GUI creation removes the problem\n * of representing a 2-dimensional GUI by 1-dimensional code.\n *\n * \u003ch3\u003eHow to use the {@code GroupLayoutEngineer}\u003c/h3\u003e\n *\n * \u003col\u003e\n * \u003cli\u003e Create an instance of the {@code GroupLayoutEngineer}.\n * The first parameter of the constructor is a reference to the container,\n * and the rest are the lines of the textual scheme. For example:\n * \u003cpre\u003e\n * GroupLayoutEngineer gle \u003d new GroupLayoutEngineer(\n *    getContentPane(),\n * \t\"FINDLABEL  TEXTFIELD      FINDBUTTON  \",\n * \t\"          --------------+             \",\n * \t\"           CB11   CB12  | CANSELBUTTON\",\n * \t\"                        |             \",\n * \t\"           CB21   CB22  |             \");\n * \u003c/pre\u003e\n *\n * \u003cli\u003e Associate the names on the scheme with concrete components, for example:\n * \u003cpre\u003e\n * gle.associate(\"FINDLABEL\", new JLabel(\"Find What:\"));\n * gle.associate(\"TEXTFIELD\", new JTextField());\n * gle.associate(\"FINDBUTTON\", new JButton(\"Find\"));\n * gle.associate(\"CB11\", new JCheckBox(\"Match Case\"));\n * gle.associate(\"CB12\", new JCheckBox(\"Wrap Around\"));\n * gle.associate(\"CB21\", new JCheckBox(\"Whole Words\"));\n * gle.associate(\"CB22\", new JCheckBox(\"Search Backwards\"));\n * gle.associate(\"CANSELBUTTON\", new JButton(\"Cancel\"));\n * \u003c/pre\u003e\n *\n * \u003cli\u003e Apply optional preferences (such as special alignment), for example:\n * \u003cpre\u003e\n * gle.linkSize(\"FINDBUTTON\", \"CANSELBUTTON\");\n *\n * gle.getParallelGroup(Axis.VERTICAL, \"FINDLABEL\",\"FINDBUTTON\")\n * \t.setContentAlignment(Alignment.BASELINE);\n *\n * gle.setAutoCreateGaps(true);\n * gle.setAutoCreateContainerGaps(true);\n * \u003c/pre\u003e\n * Note that the alignment in the group above\n * could also be automatically set to {@code Baseline}\n * by calling the method {@code setAutoAlignJTextFields()}.\n * \u003cp\u003e\u003cbr\u003e\n *\n * \u003cli\u003e Invoke the method\n * \u003cpre\u003e\n * gle.engineer();\n * \u003c/pre\u003e\n * \u003c/ol\u003e\n *\n * \u003ch3\u003eHow to control gaps\u003c/h3\u003e\n *\n * If you wish to control the gaps yourself instead of relying\n * on automatic gaps creation, you will have two choices.\n * \u003cp\u003e\n * We recommend to deal with gaps like with components, i.e.,\n * to place the required gaps at the scheme\n * and then to associate them with concrete parameters (types and lengthes),\n * for example:\n * \u003cpre\u003e\n * GroupLayoutEngineer gle \u003d new GroupLayoutEngineer(\n *    getContentPane(),\n * \t\"FINDLABEL .. TEXTFIELD      . FINDBUTTON  \",\n * \t\"            --------------+       .       \",\n * \t\"             CB11 .g CB12 |   CANSELBUTTON\",\n * \t\"               .          |               \",\n * \t\"             CB21    CB22 |               \");\n *\n * gle.associateGap(\".\", ComponentPlacement.RELATED);\n * gle.associateGap(\"..\", ComponentPlacement.UNRELATED);\n * gle.associateGap(\".g1\", 20);\n * \u003c/pre\u003e\n *\n * Note that each gap on the scheme must be started from a dot\n * (in order to make it looking different from components).\n * \u003cp\u003e\n * Also note that any gap (associated with the required parameters)\n * may appear on the scheme any number of times,\n * unlike the components, which appear on the scheme only once.\n * \u003cp\u003e\n * Note that you may skip the associations of the denotations \".\" and \"..\"\n * with related and unrelated gaps respectively,\n * because these associations are always applied by default.\n *\n * \u003cp\u003e\u003cbr\u003e\n * Alternatively, you may add gaps to the layout\n * without making additional changes to the scheme.\n * This approach requires specifying concrete sequential or parallel groups\n * and their concrete elements near which a gap should be added, for example:\n * \u003cpre\u003e\n * gle.getSequentialGroup(Axis.HORIZONTAL, \"CB11\", \"CB22\")\n *   .getGroup(\"CB12\",\"CB22\")\n *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);\n * \u003c/pre\u003e\n * We do not recommend to use the letter approach because it minimizes\n * the advantages of the group layout engineer.\n *\n * \u003ch3\u003eHow to draw schemes\u003c/h3\u003e\n *\n * In order to avoid formal introduction to this topic,\n * we refer to the examples in the package {@code glengineer.demos}\n * for general introduction to the schemes.\n * \u003cp\u003e\n * Here we mention specific yet essential details only.\n *\n * \u003col\u003e\n * \u003cli\u003e The names of components (and gaps) on the scheme may consist of\n * letters of any case, numbers, and underscores \u0027_\u0027.\n * \u003cli\u003e For each layout direction (horizontal and vertical)\n * the engineer tries to divide every non-trivial block of elements\n * on the scheme into a sequential or a parallel\n * (if the former is not possible) group of elements or subblocks.\n * \u003cli\u003e One may place on the scheme horizontal and vertical lines\n * which consist of symbols \u0027-\u0027 and \u0027|\u0027 respectively\n * (and optionally of symbols \u0027+\u0027 for the intersections).\n * \u003cli\u003e If a block on the scheme is intersected by\n * a (horizontal or vertical) line, then this block will\n * not be divided into a sequential group of that direction.\n * Hence, it will be divided into a parallel group.\n * \u003cli\u003e The lines do not influence the layout in the perpendicular direction\n * (but, certainly, this layout direction is influenced\n * by the space under the line).\n * \u003cli\u003e If a block is divided into a parallel group by a number of lines,\n * it is divided only by those of them which have the maximum length,\n * and the smaller lines (if they exist) are left for the subblocks.\n * \u003cli\u003e Gaps on the scheme affect sequential groups only.\n * \u003cli\u003e If two sequential subblocks are divided by a number of gaps,\n * then these gaps will be replaced by a single gap of that type.\n * \u003cli\u003e Gaps on the scheme may lie AT lines.\n * Such lines are considered as being continued under that gaps,\n * and the gaps affect only the direction perpendicular to the\n * corresponding line.\n * \u003cli\u003e A line may be intersected only by one gap.\n * \u003cli\u003e If a gap touches one of the sides of a line,\n * it is also assumed that they intersect.\n * \u003c/ol\u003e\n *\n * @author Yevgen Ivakhno\n * @version 1.1, 18/05/2009\n */\npublic class GroupLayoutEngineer {\n\n    private Scheme scheme;\n\n    /**\n     * The mapping of the names on the scheme to the associated components.\n     */\n    private NamesToComponents namesToComponents;\n\n    private NamesToGapAgents namesToGapAgents;\n\n    /**\n     * The layout manager {@code GroupLayout} under control.\n     */\n    private GroupLayout gl;\n\n    /**\n     * The object which can create sequential and parallel\n     * {@code GroupLayout} groups and add components to groups\n     * using the components\u0027 names.\n     * \u003cp\u003e\n     * A reference to this object is given to the agents of elements.\n     *\n     * @see glengineer.agents\n     */\n    private GroupCreatorAndElementAdderClass creatorAndAdder;\n\n    /**\n     * The agent of the top level horizontal group.\n     */\n    private TopSequentialGroupAgent horizontalLayoutAgent;\n\n    /**\n     * The agent of the top level vertical group.\n     */\n    private TopSequentialGroupAgent verticalLayoutAgent;\n\n    /**\n     * Whether all vertical parallel groups\n     * containing JTextFields but not containing other groups\n     * should automatically have baseline alignment.\n     */\n    private boolean autoBaselineAlignment \u003d false;\n\n    /**\n     * @param container\tthe container that needs to be laid out\n     * @param lines\t\ta sequence of lines representing the scheme\n     */\n    public GroupLayoutEngineer(Container container, String... lines) {\n        scheme \u003d new Scheme(lines);\n        namesToComponents \u003d new NamesToComponents();\n        namesToGapAgents \u003d new NamesToGapAgents();\n        horizontalLayoutAgent \u003d compouseTopSequentialGroup(Axis.HORIZONTAL);\n        verticalLayoutAgent \u003d compouseTopSequentialGroup(Axis.VERTICAL);\n        horizontalLayoutAgent.removeGapsFromParallelGroups();\n        verticalLayoutAgent.removeGapsFromParallelGroups();\n        gl \u003d new GroupLayout(container);\n        container.setLayout(gl);\n        //\t\tsetAutoCreateGaps(true);\n        //\t\tsetAutoCreateContainerGaps(true);\n    }\n\n    /**\n     * Returns a top sequential group agent for the specified layout direction.\n     * \u003cp\u003e\n     * A group will be created even if it would contain a single element.\n     *\n     * @param axis\tthe layout direction\n     *\n     * @return\t\tthe agent of the new sequential group\n     */\n    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis) {\n        Block topBlock;\n        if (axis \u003d\u003d Axis.HORIZONTAL)\n            topBlock \u003d new HorizontalBlock(scheme);\n        else\n            //VERTICAL\n            topBlock \u003d new VerticalBlock(scheme);\n        topBlock.optimize();\n        if (topBlock.isTrivial())\n            throw new IllegalArgumentException(\"the scheme does not possess components\u0027 names\");\n        TopSequentialGroupAgent result \u003d new TopSequentialGroupAgent();\n        List\u003cBlock\u003e blocksList \u003d topBlock.extractSequentialSubblocks();\n        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));\n        return result;\n    }\n\n    /**\n     * Returns a new sequential group agent filled with\n     * the agents of the specified block content.\n     *\n     * @param block\tthe block which content should be placed\n     * \t\t\t\tinto a sequential group.\n     *\n     * @return\t\tthe agent of the new sequential group.\n     */\n    protected Agent compouseSequentialGroupFromBlock(Block block) {\n        block.optimize();\n        if (block.isTrivial())\n            return null;\n        List\u003cBlock\u003e blocksList \u003d block.extractSequentialSubblocks();\n        if (blocksList.size() \u003d\u003d 1)\n            return processSubblockOfSequentialGroup(block);\n        SequentialGroupAgent result \u003d new SequentialGroupAgent();\n        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));\n        return result;\n    }\n\n    /**\n     * Verifies whether the specified subblock contains a single element\n     * or a set of elements\n     * and either returns the agent of the corresponding element,\n     * or divides the set of elements into a new parallel subgroup\n     * and returns the corresponding agent.\n     *\n     * @param subblock\ta block in a sequential group.\n     *\n     * @return\t\t\tthe agent of the specified subblock content.\n     */\n    private Agent processSubblockOfSequentialGroup(Block subblock) {\n        if (subblock.containsOnlyOneWord())\n            return getElementFromBlockWithOnlyWord(subblock);\n        else\n            return composeParallelGroupFromBlock(subblock);\n    }\n\n    /**\n     * Returns the agent of the unique element (a component or a gap)\n     * in the specified block which is added into a sequential group.\n     *\n     * @param block\ta block with an only element in a parallel group.\n     *\n     * @return\t\tthe agent of the unique element in the specified block.\n     */\n    private Agent getElementFromBlockWithOnlyWord(Block block) {\n        String word \u003d block.textAt(block.firstWord_Horizontally());\n        if (word.charAt(0) \u003d\u003d \u0027.\u0027)\n            return new TemporaryGapAgent(word);\n        return new ComponentAgent(word);\n    }\n\n    /**\n     * Returns a new parallel group agent filled with\n     * the agents of the specified block content.\n     *\n     * @param block\tthe block which content should be placed\n     * \t\t\t\tinto a sequential group.\n     *\n     * @return\t\tthe agent of the new parallel group.\n     */\n    protected Agent composeParallelGroupFromBlock(Block block) {\n        block.optimize();\n        if (block.isTrivial())\n            return null;\n        List\u003cBlock\u003e blocksList \u003d block.extractParallelSubblocks();\n        if (blocksList.size() \u003d\u003d 1)\n            return processSubblockOfParallelGroup(block);\n        ParallelGroupAgent result \u003d new ParallelGroupAgent();\n        Agent agent;\n        for (Block subBlock : blocksList) {\n            agent \u003d processSubblockOfParallelGroup(subBlock);\n            if (agent !\u003d null)\n                result.addAgent(agent);\n        }\n        return result;\n    }\n\n    /**\n     * Verifies whether the specified subblock contains a single element\n     * or a set of elements\n     * and then either returns the agent of the corresponding element,\n     * or divides the set of elements into a new sequential subgroup\n     * and returns the corresponding agent.\n     * \u003cp\u003e\n     * If there is a unique element and it is a gap,\n     *\n     * @param subblock\ta block in a parallel group.\n     *\n     * @return\tthe agent of the specified subblock content.\n     */\n    private Agent processSubblockOfParallelGroup(Block subblock) {\n        if (subblock.containsOnlyOneWord())\n            return getElementFromBlockWithOnlyWord(subblock);\n        else\n            return compouseSequentialGroupFromBlock(subblock);\n    }\n\n    /**\n     * Associates the specified {@code name} on the scheme\n     * with the specified {@code component}.\n     *\n     * @param name\t\tthe component name present on the scheme.\n     * @param component\tthe component to be associated with the name.\n     */\n    public void associate(String name, Component component) {\n        namesToComponents.put(name, component);\n    }\n\n    /**\n     * Associates the specified {@code denotation} on the scheme\n     * with gaps of the specified {@code size}.\n     */\n    public void associateGap(String denotation, int size) {\n        namesToGapAgents.put(denotation, new GapAgent(size));\n    }\n\n    /**\n     * Associates the specified {@code denotation} on the scheme with gaps\n     * of the specified {@code min}, {@code pref}, and {@code max} sizes.\n     */\n    public void associateGap(String denotation, int min, int pref, int max) {\n        namesToGapAgents.put(denotation, new GapAgent(min, pref, max));\n    }\n\n    /**\n     * Associates the specified {@code denotation} on the scheme\n     * with preferred gaps\n     * of the specified component placement type (related or unrelated).\n     */\n    public void associateGap(String denotation, ComponentPlacement type) {\n        namesToGapAgents.put(denotation, new PreferredGapAgent(type));\n    }\n\n    /**\n     * Associates the specified {@code denotation} on the scheme\n     * with preferred gaps\n     * of the specified component placement type (related or unrelated)\n     * and of the specified preferred and maximum sizes.\n     */\n    public void associateGap(String denotation, ComponentPlacement type, int pref, int max) {\n        namesToGapAgents.put(denotation, new PreferredGapAgent(type, pref, max));\n    }\n\n    /**\n     * Sets whether a gap between components should automatically be\n     * created. For example, if this is {@code true} and you add two\n     * components to a {@code SequentialGroup} a gap between the\n     * two components is automatically be created.\n     *\n     * @param autoCreatePadding\twhether a gap between components is\n     *        \t\t\t\t\tautomatically created.\n     */\n    public void setAutoCreateGaps(boolean autoCreatePadding) {\n        gl.setAutoCreateGaps(autoCreatePadding);\n    }\n\n    /**\n     * Sets whether a gap between the container and components that touch\n     * the border of the container should automatically be created.\n     *\n     * @param autoCreateContainerGaps\twhether a gap between the container\n     * \t\t\t\t\t\t\t\t\tand components that touch the border\n     * \t\t\t\t\t\t\t\t\tof the container should automatically\n     * \t\t\t\t\t\t\t\t\tbe created.\n     */\n    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps) {\n        gl.setAutoCreateContainerGaps(autoCreateContainerGaps);\n    }\n\n    /**\n     * Sets whether all vertical parallel groups\n     * containing JTextFields but not containing other groups\n     * should automatically have baseline alignment.\n     */\n    public void setAutoAlignJTextFields(boolean autoBaselineAlignment) {\n        this.autoBaselineAlignment \u003d autoBaselineAlignment;\n    }\n\n    /**\n     * Forces the specified components to have the same size\n     * regardless of their preferred, minimum or maximum sizes.\n     * Components that are linked are given the maximum\n     * of the preferred size of each of the linked components.\n     *\n     * @param names\tthe names of the components\tthat are\n     * \t\t\t\tto have the same size.\n     */\n    public void linkSize(String... names) {\n        Component[] components \u003d namesToComponents.getComponents(names);\n        gl.linkSize(components);\n    }\n\n    /**\n     * Forces the specified components to have the same size\n     * along the specified axis regardless of their\n     * preferred, minimum or maximum sizes.\n     * Components that are linked are given the maximum\n     * of the preferred size of each of the linked components.\n     *\n     * @param axis\tthe axis to link the size along.\n     * @param names\tthe names of the components\tthat are\n     * \t\t\t\tto have the same size.\n     */\n    public void linkSize(Axis axis, String... names) {\n        Component[] components \u003d namesToComponents.getComponents(names);\n        if (axis \u003d\u003d Axis.HORIZONTAL)\n            gl.linkSize(SwingConstants.HORIZONTAL, components);\n        else\n            //axis\u003d\u003dAxis.VERTICAL\n            gl.linkSize(SwingConstants.VERTICAL, components);\n    }\n\n    /**\n     * Disables the components under the specified names.\n     * \u003cp\u003e\n     * Each component must be associated with its name\n     * before this method is applied.\n     */\n    public void disable(String... componentsNames) {\n        for (Component c : namesToComponents.getComponents(componentsNames)) c.setEnabled(false);\n    }\n\n    /**\n     * Finds the agent of the component with the specified name\n     * and returns an interface for adjusting that component.\n     *\n     * @param axis\t\t\tlayout direction\n     * @param componentName\tthe name of the component to be found\n     * @return\t\t\t\tan interface {@code FunctionsOnComponent}\n     * \t\t\t\t\t\tfor adjusting the component\n     */\n    public FunctionsOnComponent getComponent(Axis axis, String componentName) {\n        Agent agent \u003d getAgent(axis, componentName);\n        if (agent \u003d\u003d null)\n            throw new IllegalArgumentException(\"no such component found: \" + componentName);\n        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();\n    }\n\n    /**\n     * Finds the agent of the group which first and last components\n     * have the specified names;\n     * returns an interface for adjusting that group and adding gaps into it.\n     *\n     * @param axis\t\tlayout direction\n     * @param firstName\tthe name of the first component in the group\n     * @param lastName\tthe name of the last component in the group\n     * @return\t\t\tan interface {@code FunctionsOnGroup}\n     * \t\t\t\t\tfor adjusting that group and adding gaps into it\n     */\n    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {\n        Agent agent \u003d getGroupAgent(axis, firstName, lastName);\n        if (agent \u003d\u003d null || !(agent instanceof GroupAgent))\n            throw new IllegalArgumentException(\"no such group found: \u003c\" + firstName + \",\" + lastName + \"\u003e\");\n        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();\n    }\n\n    /**\n     * Finds the agent of the parallel group which first and last components\n     * have the specified names;\n     * returns an interface for adjusting that group and adding gaps into it.\n     *\n     * @param axis\t\tlayout direction\n     * @param firstName\tthe name of the first component in the group\n     * @param lastName\tthe name of the last component in the group\n     * @return\t\t\tan interface {@code FunctionsOnParallelGroup}\n     * \t\t\t\t\tfor adjusting that group and adding gaps into it\n     */\n    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {\n        Agent agent \u003d getParallelGroupAgent(axis, firstName, lastName);\n        if (agent \u003d\u003d null)\n            throw new IllegalArgumentException(\"no such parallel group found: \u003c\" + firstName + \",\" + lastName + \"\u003e\");\n        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();\n    }\n\n    /**\n     * Finds the agent of the sequential group which first and last components\n     * have the specified names;\n     * returns an interface for adjusting that group and adding gaps into it.\n     *\n     * @param axis\t\tlayout direction\n     * @param firstName\tthe name of the first component in the group\n     * @param lastName\tthe name of the last component in the group\n     * @return\t\t\tan interface {@code FunctionsOnSequentialGroup}\n     * \t\t\t\t\tfor adjusting that group and adding gaps into it\n     */\n    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {\n        Agent agent \u003d getSequentialGroupAgent(axis, firstName, lastName);\n        if (agent \u003d\u003d null)\n            throw new IllegalArgumentException(\"No such sequential group found: \u003c\" + firstName + \",\" + lastName + \"\u003e.\");\n        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();\n    }\n\n    /**\n     * Returns the agent of the top level sequential group\n     * under the specified layout direction.\n     *\n     * @param axis\tlayout direction\n     * @return\t\tthe agent of the top level sequential group\n     * \t\t\t\tunder the specified layout direction\n     */\n    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {\n        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();\n    }\n\n    /**\n     * Returns the agent of the component with the specified name\n     * under the specified layout direction.\n     *\n     * @param axis\tlayout direction\n     * @param name\tthe name of the component to be found\n     * @return\t\tthe corresponding agent\n     */\n    private Agent getAgent(Axis axis, String name) {\n        return getTopAgent(axis).findDependingComponentByName(name);\n    }\n\n    /**\n     * Returns the agent of the group with the specified first and last names\n     * under the specified layout direction.\n     *\n     * @param axis\t\tlayout direction\n     * @param firstName\tthe name of the first component in the group\n     * @param lastName\tthe name of the last component in the group\n     * @return\t\t\tthe agent of the corresponding group\n     */\n    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName) {\n        return getTopAgent(axis).findDependingGroupByNames(firstName, lastName);\n    }\n\n    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName) {\n        return getTopAgent(axis).findDependingSequentialGroupByNames(firstName, lastName);\n    }\n\n    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName) {\n        return getTopAgent(axis).findDependingParallelGroupByNames(firstName, lastName);\n    }\n\n    /**\n     * Returns (a reference to) the top agent\n     * for the specified layout direction.\n     *\n     * @param axis\tlayout direction\n     * @return\t\tthe corresponding top agent\n     */\n    private TopSequentialGroupAgent getTopAgent(Axis axis) {\n        return axis \u003d\u003d Axis.HORIZONTAL ? horizontalLayoutAgent : verticalLayoutAgent;\n    }\n\n    /**\n     * Places the components into the container\n     * according to the scheme and to all additional preferences.\n     */\n    public void engineer() {\n        horizontalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);\n        verticalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);\n        if (autoBaselineAlignment)\n            makeTextFieldsBaselineIn(verticalLayoutAgent);\n        creatorAndAdder \u003d new GroupCreatorAndElementAdderClass();\n        gl.setHorizontalGroup(horizontalLayoutAgent.groupContent(creatorAndAdder));\n        gl.setVerticalGroup(verticalLayoutAgent.groupContent(creatorAndAdder));\n    }\n\n    /**\n     * If the specified group is parallel,\n     * contains directly a component of type {@code JTextField},\n     * and does not contain other groups with components,\n     * then this method makes the alignment of the group {@code Baseline}.\n     * \u003cp\u003e\n     * In the case of a group having subgroups with components\n     * this method passes the call to that subgroups.\n     * \u003cp\u003e\n     * As a result of applying this method,\n     * all parallel groups having TextFields (but having no subgroups)\n     * will be aligned along baselines.\n     */\n    private void makeTextFieldsBaselineIn(GroupAgent group) {\n        boolean containsGroups \u003d false;\n        //the group must be baseline aligned\n        boolean containsTextfields \u003d false;\n        boolean isParallel \u003d group instanceof ParallelGroupAgent;\n        for (Agent child : group.getChildren()) {\n            if (child instanceof GroupAgent \u0026\u0026 ((GroupAgent) child).getFirstName() !\u003d null) {\n                //child is a group with components.\n                makeTextFieldsBaselineIn((GroupAgent) child);\n                containsGroups \u003d true;\n            } else if (child instanceof ComponentAgent \u0026\u0026 isParallel \u0026\u0026 !containsGroups) {\n                ComponentAgent agent \u003d (ComponentAgent) child;\n                Component comp \u003d namesToComponents.compMap.get(agent.getFirstName());\n                if (comp instanceof JTextField)\n                    containsTextfields \u003d true;\n            }\n        }\n        if (containsTextfields) {\n            ParallelGroupSettings settings \u003d ((ParallelGroupAgent) group).getSettings();\n            if (settings.contentAlignment \u003d\u003d null)\n                settings.contentAlignment \u003d Alignment.BASELINE;\n        }\n    }\n\n    /**\n     * Outputs the groups hierarchy.\n     */\n    public void printGroupStructure() {\n        new GroupPrinter().printTopGroupsStructure();\n    }\n\n    /**\n     * Encapsulates the \"names of components - to - components\" mapping\n     * and the corresponding methods of access and modification.\n     */\n    private class NamesToComponents {\n\n        /**\n         * Holds the association between the names of the components on\n         * the scheme and the corresponding components.\n         */\n        private HashMap\u003cString, Component\u003e compMap \u003d new HashMap\u003cString, Component\u003e();\n\n        public NamesToComponents() {\n        }\n\n        @SuppressWarnings(\"unused\")\n        public boolean contains(String name) {\n            return compMap.containsKey(name);\n        }\n\n        @SuppressWarnings(\"unused\")\n        public boolean contains(Component component) {\n            return compMap.containsValue(component);\n        }\n\n        public void put(String name, Component component) {\n            if (name \u003d\u003d null || component \u003d\u003d null || !scheme.containsComponentName(name) || compMap.put(name, component) !\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate a component\" + \" with the name \\\"\" + name + \"\\\"\");\n        }\n\n        /**\n         * Returns the component associated with the specified name.\n         *\n         * @param name\tthe name of the component to return\n         *\n         * @return\t\tthe component associated with the specified name\n         */\n        public Component getComponent(String name) {\n            if (name \u003d\u003d null)\n                throw new IllegalArgumentException(\"No name specified\");\n            Component result \u003d compMap.get(name);\n            if (result \u003d\u003d null)\n                throw new IllegalArgumentException(\"cannot find a component\" + \" with the specified name \\\"\" + name + \"\\\"\");\n            return result;\n        }\n\n        /**\n         * Returns the components associated with the specified names.\n         *\n         * @param names\tthe names of the components to return\n         *\n         * @return\t\tthe components associated with the specified names\n         */\n        public Component[] getComponents(String... names) {\n            int l \u003d names.length;\n            Component[] components \u003d new Component[l];\n            for (int i \u003d 0; i \u003c l; i++) components[i] \u003d getComponent(names[i]);\n            return components;\n        }\n    }\n\n    /**\n     * Declares the method of possessing the gap agent\n     * by a temporary gap agent.\n     */\n    public interface TemporaryGapsToGaps {\n\n        /**\n         * Returns the gap agent associated with the specified\n         * temporary gap agent.\n         */\n        public Agent gap(TemporaryGapAgent temp);\n    }\n\n    /**\n     * Encapsulates the \"names of the gaps - to - agents of these gaps\" mapping\n     * and the corresponding methods of access and modification.\n     */\n    private class NamesToGapAgents implements TemporaryGapsToGaps {\n\n        /**\n         * Holds the association between the gaps denotations\n         * on the scheme and the corresponding gap types.\n         * \u003cp\u003e\n         * The gaps (which can be preferred or simple) are represented\n         * by instances of {@code Agent}, which is a superclass\n         * for both {@code PreferredGapAgent} and {@code GapAgent}.\n         */\n        private HashMap\u003cString, Agent\u003e gapMap \u003d new HashMap\u003cString, Agent\u003e();\n\n        public NamesToGapAgents() {\n            safePut(\".\", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));\n            safePut(\"..\", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));\n        }\n\n        public void put(String name, GapAgent agent) {\n            if (name \u003d\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate a gap with a null name.\");\n            if (agent \u003d\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate null agents.\");\n            if (!scheme.containsGapName(name))\n                return;\n            /*throw new IllegalArgumentException(\n\t\t\t\t\t\"The gap name \" + name + \" not found on the scheme.\");*/\n            safePut(name, agent);\n        }\n\n        protected void safePut(String name, GapAgent agent) {\n            gapMap.put(name, agent);\n        }\n\n        public void put(String name, PreferredGapAgent agent) {\n            if (name \u003d\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate a gap with a null name.\");\n            if (agent \u003d\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate null agents.\");\n            if (!scheme.containsGapName(name))\n                return;\n            /*throw new IllegalArgumentException(\n\t\t\t\t\t\"The gap name \" + name + \" not found on the scheme.\");*/\n            safePut(name, agent);\n        }\n\n        protected void safePut(String name, PreferredGapAgent agent) {\n            gapMap.put(name, agent);\n        }\n\n        /**\n         * Returns the gap agent associated with the specified name.\n         */\n        public Agent gap(String name) {\n            if (name \u003d\u003d null)\n                throw new IllegalArgumentException(\"No name specified\");\n            Agent result \u003d gapMap.get(name);\n            if (result \u003d\u003d null)\n                throw new IllegalArgumentException(\"cannot find a gap denoted by \\\"\" + name + \"\\\"\");\n            return result;\n        }\n\n        /**\n         * Returns the gap agent associated with the specified\n         * temporary gap agent.\n         */\n        public Agent gap(TemporaryGapAgent temp) {\n            return gap(temp.getDenotation());\n        }\n    }\n\n    /**\n     * An adapter for such functions of the {@code GroupLayout}\n     * as creating new groups and adding groups and components to groups.\n     */\n    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {\n\n        /**\n         * Creates and returns a new {@code SequentialGroup}.\n         */\n        public SequentialGroup createSequentialGroup() {\n            return gl.createSequentialGroup();\n        }\n\n        /**\n         * Creates and returns a new {@code ParallelGroup}\n         * with the specified settings.\n         */\n        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {\n            if (settings.contentAlignment !\u003d null)\n                if (settings.resizable !\u003d null)\n                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);\n                else\n                    //(resizable \u003d\u003d null)\n                    return gl.createParallelGroup(settings.contentAlignment);\n            else //(settings.contentAlignment \u003d\u003d null)\n            if (settings.resizable !\u003d null)\n                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);\n            else\n                return gl.createParallelGroup();\n        }\n\n        /**\n         * Adds the component having the specified {@code compName}\n         * to the specified {@code group},\n         * applies to it the specified {@code settings}.\n         */\n        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {\n            if (settings.alignmentWithRespectToParent !\u003d null)\n                //It seems that we must add to a parallel group.\n                if (group instanceof ParallelGroup)\n                    //Really, to a parallel.\n                    if (settings.sizes !\u003d null) {\n                        Sizes sizes \u003d settings.sizes;\n                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);\n                    } else\n                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);\n                else\n                    //Parallel group not found.\n                    throw new IllegalArgumentException(\"components can be aligned in parallel groups only\");\n            else //Alignment not specified.\n            if (settings.sizes !\u003d null) {\n                Sizes sizes \u003d settings.sizes;\n                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);\n            } else\n                //Even sizes aren\u0027t specified.\n                group.addComponent(namesToComponents.getComponent(compName));\n        }\n\n        /**\n         * Adds the specified {@code group} with the specified {@code settings}\n         * to another group {@code parentGroup}.\n         */\n        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {\n            if (settings.alignmentWithRespectToParent !\u003d null)\n                if (parentGroup instanceof ParallelGroup)\n                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);\n                else\n                    throw new IllegalArgumentException(\"content can be aligned in parallel groups only\");\n            parentGroup.addGroup(group);\n        }\n    }\n\n    /**\n     * Provides output of the created groups\u0027 structure.\n     * \u003cp\u003e\n     * Is maintained for debugging purposes.\n     */\n    public class GroupPrinter {\n\n        /**\n         * Outputs the both directions top groups structures.\n         */\n        public void printTopGroupsStructure() {\n            Axis axis;\n            axis \u003d Axis.HORIZONTAL;\n            System.out.println(\"\\nTop \" + axis.toString().toUpperCase() + \" group structure.\");\n            printTopGroupStructure(axis);\n            System.out.println(\"\\n-----------------------------\\n\");\n            axis \u003d Axis.VERTICAL;\n            System.out.println(\"Top \" + axis.toString().toUpperCase() + \" group structure.\");\n            printTopGroupStructure(axis);\n        }\n\n        /**\n         * Outputs the specified direction top group structure.\n         */\n        public void printTopGroupStructure(Axis axis) {\n            printGroupStructure(getTopAgent(axis));\n        }\n\n        /**\n         * Outputs the specified group structure.\n         */\n        public void printGroupStructure(GroupAgent group) {\n            System.out.println();\n            System.out.println(\"Elements of \" + group.toString() + \":\");\n            List\u003cAgent\u003e childrenAgents \u003d group.getChildren();\n            for (Agent child : childrenAgents) System.out.println(child.toString());\n            for (Agent child : childrenAgents) if (child instanceof GroupAgent)\n                printGroupStructure((GroupAgent) child);\n        }\n    }\n}\n",
    "package": "glengineer",
    "classname": "GroupLayoutEngineer",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_0Test.java",
    "test_prompt": "// GroupLayoutEngineer_0Test.java\npackage glengineer;\n\nimport glengineer.agents.*;\nimport glengineer.agents.setters.*;\nimport glengineer.agents.settings.*;\nimport glengineer.blocks.*;\nimport java.util.*;\nimport java.awt.Component;\nimport java.awt.Container;\nimport javax.swing.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GroupLayoutEngineer}.\n* It contains ten unit test cases for the {@link GroupLayoutEngineer#getComponent(Axis, String)} method.\n*/\nclass GroupLayoutEngineer_0Test {",
    "method_signature": "getComponent(Axis, String)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// GroupLayoutEngineer.java\npackage glengineer;\n\nimport glengineer.agents.*;\nimport glengineer.agents.setters.*;\nimport glengineer.agents.settings.*;\nimport glengineer.blocks.*;\nimport java.util.*;\nimport java.awt.Component;\nimport java.awt.Container;\nimport javax.swing.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\n\n/**\n * {@code GroupLayoutEngineer} is a shell for the layout manager\n * {@code GroupLayout}. It allows to control components\u0027 placement\n * using simple 2-dimensional textual schemes.\n * \u003cp\u003e\n * Such approach to GUI creation removes the problem\n * of representing a 2-dimensional GUI by 1-dimensional code.\n *\n * \u003ch3\u003eHow to use the {@code GroupLayoutEngineer}\u003c/h3\u003e\n *\n * \u003col\u003e\n * \u003cli\u003e Create an instance of the {@code GroupLayoutEngineer}.\n * The first parameter of the constructor is a reference to the container,\n * and the rest are the lines of the textual scheme. For example:\n * \u003cpre\u003e\n * GroupLayoutEngineer gle \u003d new GroupLayoutEngineer(\n *    getContentPane(),\n * \t\"FINDLABEL  TEXTFIELD      FINDBUTTON  \",\n * \t\"          --------------+             \",\n * \t\"           CB11   CB12  | CANSELBUTTON\",\n * \t\"                        |             \",\n * \t\"           CB21   CB22  |             \");\n * \u003c/pre\u003e\n *\n * \u003cli\u003e Associate the names on the scheme with concrete components, for example:\n * \u003cpre\u003e\n * gle.associate(\"FINDLABEL\", new JLabel(\"Find What:\"));\n * gle.associate(\"TEXTFIELD\", new JTextField());\n * gle.associate(\"FINDBUTTON\", new JButton(\"Find\"));\n * gle.associate(\"CB11\", new JCheckBox(\"Match Case\"));\n * gle.associate(\"CB12\", new JCheckBox(\"Wrap Around\"));\n * gle.associate(\"CB21\", new JCheckBox(\"Whole Words\"));\n * gle.associate(\"CB22\", new JCheckBox(\"Search Backwards\"));\n * gle.associate(\"CANSELBUTTON\", new JButton(\"Cancel\"));\n * \u003c/pre\u003e\n *\n * \u003cli\u003e Apply optional preferences (such as special alignment), for example:\n * \u003cpre\u003e\n * gle.linkSize(\"FINDBUTTON\", \"CANSELBUTTON\");\n *\n * gle.getParallelGroup(Axis.VERTICAL, \"FINDLABEL\",\"FINDBUTTON\")\n * \t.setContentAlignment(Alignment.BASELINE);\n *\n * gle.setAutoCreateGaps(true);\n * gle.setAutoCreateContainerGaps(true);\n * \u003c/pre\u003e\n * Note that the alignment in the group above\n * could also be automatically set to {@code Baseline}\n * by calling the method {@code setAutoAlignJTextFields()}.\n * \u003cp\u003e\u003cbr\u003e\n *\n * \u003cli\u003e Invoke the method\n * \u003cpre\u003e\n * gle.engineer();\n * \u003c/pre\u003e\n * \u003c/ol\u003e\n *\n * \u003ch3\u003eHow to control gaps\u003c/h3\u003e\n *\n * If you wish to control the gaps yourself instead of relying\n * on automatic gaps creation, you will have two choices.\n * \u003cp\u003e\n * We recommend to deal with gaps like with components, i.e.,\n * to place the required gaps at the scheme\n * and then to associate them with concrete parameters (types and lengthes),\n * for example:\n * \u003cpre\u003e\n * GroupLayoutEngineer gle \u003d new GroupLayoutEngineer(\n *    getContentPane(),\n * \t\"FINDLABEL .. TEXTFIELD      . FINDBUTTON  \",\n * \t\"            --------------+       .       \",\n * \t\"             CB11 .g CB12 |   CANSELBUTTON\",\n * \t\"               .          |               \",\n * \t\"             CB21    CB22 |               \");\n *\n * gle.associateGap(\".\", ComponentPlacement.RELATED);\n * gle.associateGap(\"..\", ComponentPlacement.UNRELATED);\n * gle.associateGap(\".g1\", 20);\n * \u003c/pre\u003e\n *\n * Note that each gap on the scheme must be started from a dot\n * (in order to make it looking different from components).\n * \u003cp\u003e\n * Also note that any gap (associated with the required parameters)\n * may appear on the scheme any number of times,\n * unlike the components, which appear on the scheme only once.\n * \u003cp\u003e\n * Note that you may skip the associations of the denotations \".\" and \"..\"\n * with related and unrelated gaps respectively,\n * because these associations are always applied by default.\n *\n * \u003cp\u003e\u003cbr\u003e\n * Alternatively, you may add gaps to the layout\n * without making additional changes to the scheme.\n * This approach requires specifying concrete sequential or parallel groups\n * and their concrete elements near which a gap should be added, for example:\n * \u003cpre\u003e\n * gle.getSequentialGroup(Axis.HORIZONTAL, \"CB11\", \"CB22\")\n *   .getGroup(\"CB12\",\"CB22\")\n *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);\n * \u003c/pre\u003e\n * We do not recommend to use the letter approach because it minimizes\n * the advantages of the group layout engineer.\n *\n * \u003ch3\u003eHow to draw schemes\u003c/h3\u003e\n *\n * In order to avoid formal introduction to this topic,\n * we refer to the examples in the package {@code glengineer.demos}\n * for general introduction to the schemes.\n * \u003cp\u003e\n * Here we mention specific yet essential details only.\n *\n * \u003col\u003e\n * \u003cli\u003e The names of components (and gaps) on the scheme may consist of\n * letters of any case, numbers, and underscores \u0027_\u0027.\n * \u003cli\u003e For each layout direction (horizontal and vertical)\n * the engineer tries to divide every non-trivial block of elements\n * on the scheme into a sequential or a parallel\n * (if the former is not possible) group of elements or subblocks.\n * \u003cli\u003e One may place on the scheme horizontal and vertical lines\n * which consist of symbols \u0027-\u0027 and \u0027|\u0027 respectively\n * (and optionally of symbols \u0027+\u0027 for the intersections).\n * \u003cli\u003e If a block on the scheme is intersected by\n * a (horizontal or vertical) line, then this block will\n * not be divided into a sequential group of that direction.\n * Hence, it will be divided into a parallel group.\n * \u003cli\u003e The lines do not influence the layout in the perpendicular direction\n * (but, certainly, this layout direction is influenced\n * by the space under the line).\n * \u003cli\u003e If a block is divided into a parallel group by a number of lines,\n * it is divided only by those of them which have the maximum length,\n * and the smaller lines (if they exist) are left for the subblocks.\n * \u003cli\u003e Gaps on the scheme affect sequential groups only.\n * \u003cli\u003e If two sequential subblocks are divided by a number of gaps,\n * then these gaps will be replaced by a single gap of that type.\n * \u003cli\u003e Gaps on the scheme may lie AT lines.\n * Such lines are considered as being continued under that gaps,\n * and the gaps affect only the direction perpendicular to the\n * corresponding line.\n * \u003cli\u003e A line may be intersected only by one gap.\n * \u003cli\u003e If a gap touches one of the sides of a line,\n * it is also assumed that they intersect.\n * \u003c/ol\u003e\n *\n * @author Yevgen Ivakhno\n * @version 1.1, 18/05/2009\n */\npublic class GroupLayoutEngineer {\n\n    private Scheme scheme;\n\n    /**\n     * The mapping of the names on the scheme to the associated components.\n     */\n    private NamesToComponents namesToComponents;\n\n    private NamesToGapAgents namesToGapAgents;\n\n    /**\n     * The layout manager {@code GroupLayout} under control.\n     */\n    private GroupLayout gl;\n\n    /**\n     * The object which can create sequential and parallel\n     * {@code GroupLayout} groups and add components to groups\n     * using the components\u0027 names.\n     * \u003cp\u003e\n     * A reference to this object is given to the agents of elements.\n     *\n     * @see glengineer.agents\n     */\n    private GroupCreatorAndElementAdderClass creatorAndAdder;\n\n    /**\n     * The agent of the top level horizontal group.\n     */\n    private TopSequentialGroupAgent horizontalLayoutAgent;\n\n    /**\n     * The agent of the top level vertical group.\n     */\n    private TopSequentialGroupAgent verticalLayoutAgent;\n\n    /**\n     * Whether all vertical parallel groups\n     * containing JTextFields but not containing other groups\n     * should automatically have baseline alignment.\n     */\n    private boolean autoBaselineAlignment \u003d false;\n\n    /**\n     * @param container\tthe container that needs to be laid out\n     * @param lines\t\ta sequence of lines representing the scheme\n     */\n    public GroupLayoutEngineer(Container container, String... lines) {\n        scheme \u003d new Scheme(lines);\n        namesToComponents \u003d new NamesToComponents();\n        namesToGapAgents \u003d new NamesToGapAgents();\n        horizontalLayoutAgent \u003d compouseTopSequentialGroup(Axis.HORIZONTAL);\n        verticalLayoutAgent \u003d compouseTopSequentialGroup(Axis.VERTICAL);\n        horizontalLayoutAgent.removeGapsFromParallelGroups();\n        verticalLayoutAgent.removeGapsFromParallelGroups();\n        gl \u003d new GroupLayout(container);\n        container.setLayout(gl);\n        //\t\tsetAutoCreateGaps(true);\n        //\t\tsetAutoCreateContainerGaps(true);\n    }\n\n    /**\n     * Returns a top sequential group agent for the specified layout direction.\n     * \u003cp\u003e\n     * A group will be created even if it would contain a single element.\n     *\n     * @param axis\tthe layout direction\n     *\n     * @return\t\tthe agent of the new sequential group\n     */\n    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis) {\n        Block topBlock;\n        if (axis \u003d\u003d Axis.HORIZONTAL)\n            topBlock \u003d new HorizontalBlock(scheme);\n        else\n            //VERTICAL\n            topBlock \u003d new VerticalBlock(scheme);\n        topBlock.optimize();\n        if (topBlock.isTrivial())\n            throw new IllegalArgumentException(\"the scheme does not possess components\u0027 names\");\n        TopSequentialGroupAgent result \u003d new TopSequentialGroupAgent();\n        List\u003cBlock\u003e blocksList \u003d topBlock.extractSequentialSubblocks();\n        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));\n        return result;\n    }\n\n    /**\n     * Returns a new sequential group agent filled with\n     * the agents of the specified block content.\n     *\n     * @param block\tthe block which content should be placed\n     * \t\t\t\tinto a sequential group.\n     *\n     * @return\t\tthe agent of the new sequential group.\n     */\n    protected Agent compouseSequentialGroupFromBlock(Block block) {\n        block.optimize();\n        if (block.isTrivial())\n            return null;\n        List\u003cBlock\u003e blocksList \u003d block.extractSequentialSubblocks();\n        if (blocksList.size() \u003d\u003d 1)\n            return processSubblockOfSequentialGroup(block);\n        SequentialGroupAgent result \u003d new SequentialGroupAgent();\n        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));\n        return result;\n    }\n\n    /**\n     * Verifies whether the specified subblock contains a single element\n     * or a set of elements\n     * and either returns the agent of the corresponding element,\n     * or divides the set of elements into a new parallel subgroup\n     * and returns the corresponding agent.\n     *\n     * @param subblock\ta block in a sequential group.\n     *\n     * @return\t\t\tthe agent of the specified subblock content.\n     */\n    private Agent processSubblockOfSequentialGroup(Block subblock) {\n        if (subblock.containsOnlyOneWord())\n            return getElementFromBlockWithOnlyWord(subblock);\n        else\n            return composeParallelGroupFromBlock(subblock);\n    }\n\n    /**\n     * Returns the agent of the unique element (a component or a gap)\n     * in the specified block which is added into a sequential group.\n     *\n     * @param block\ta block with an only element in a parallel group.\n     *\n     * @return\t\tthe agent of the unique element in the specified block.\n     */\n    private Agent getElementFromBlockWithOnlyWord(Block block) {\n        String word \u003d block.textAt(block.firstWord_Horizontally());\n        if (word.charAt(0) \u003d\u003d \u0027.\u0027)\n            return new TemporaryGapAgent(word);\n        return new ComponentAgent(word);\n    }\n\n    /**\n     * Returns a new parallel group agent filled with\n     * the agents of the specified block content.\n     *\n     * @param block\tthe block which content should be placed\n     * \t\t\t\tinto a sequential group.\n     *\n     * @return\t\tthe agent of the new parallel group.\n     */\n    protected Agent composeParallelGroupFromBlock(Block block) {\n        block.optimize();\n        if (block.isTrivial())\n            return null;\n        List\u003cBlock\u003e blocksList \u003d block.extractParallelSubblocks();\n        if (blocksList.size() \u003d\u003d 1)\n            return processSubblockOfParallelGroup(block);\n        ParallelGroupAgent result \u003d new ParallelGroupAgent();\n        Agent agent;\n        for (Block subBlock : blocksList) {\n            agent \u003d processSubblockOfParallelGroup(subBlock);\n            if (agent !\u003d null)\n                result.addAgent(agent);\n        }\n        return result;\n    }\n\n    /**\n     * Verifies whether the specified subblock contains a single element\n     * or a set of elements\n     * and then either returns the agent of the corresponding element,\n     * or divides the set of elements into a new sequential subgroup\n     * and returns the corresponding agent.\n     * \u003cp\u003e\n     * If there is a unique element and it is a gap,\n     *\n     * @param subblock\ta block in a parallel group.\n     *\n     * @return\tthe agent of the specified subblock content.\n     */\n    private Agent processSubblockOfParallelGroup(Block subblock) {\n        if (subblock.containsOnlyOneWord())\n            return getElementFromBlockWithOnlyWord(subblock);\n        else\n            return compouseSequentialGroupFromBlock(subblock);\n    }\n\n    /**\n     * Associates the specified {@code name} on the scheme\n     * with the specified {@code component}.\n     *\n     * @param name\t\tthe component name present on the scheme.\n     * @param component\tthe component to be associated with the name.\n     */\n    public void associate(String name, Component component) {\n        namesToComponents.put(name, component);\n    }\n\n    /**\n     * Associates the specified {@code denotation} on the scheme\n     * with gaps of the specified {@code size}.\n     */\n    public void associateGap(String denotation, int size) {\n        namesToGapAgents.put(denotation, new GapAgent(size));\n    }\n\n    /**\n     * Associates the specified {@code denotation} on the scheme with gaps\n     * of the specified {@code min}, {@code pref}, and {@code max} sizes.\n     */\n    public void associateGap(String denotation, int min, int pref, int max) {\n        namesToGapAgents.put(denotation, new GapAgent(min, pref, max));\n    }\n\n    /**\n     * Associates the specified {@code denotation} on the scheme\n     * with preferred gaps\n     * of the specified component placement type (related or unrelated).\n     */\n    public void associateGap(String denotation, ComponentPlacement type) {\n        namesToGapAgents.put(denotation, new PreferredGapAgent(type));\n    }\n\n    /**\n     * Associates the specified {@code denotation} on the scheme\n     * with preferred gaps\n     * of the specified component placement type (related or unrelated)\n     * and of the specified preferred and maximum sizes.\n     */\n    public void associateGap(String denotation, ComponentPlacement type, int pref, int max) {\n        namesToGapAgents.put(denotation, new PreferredGapAgent(type, pref, max));\n    }\n\n    /**\n     * Sets whether a gap between components should automatically be\n     * created. For example, if this is {@code true} and you add two\n     * components to a {@code SequentialGroup} a gap between the\n     * two components is automatically be created.\n     *\n     * @param autoCreatePadding\twhether a gap between components is\n     *        \t\t\t\t\tautomatically created.\n     */\n    public void setAutoCreateGaps(boolean autoCreatePadding) {\n        gl.setAutoCreateGaps(autoCreatePadding);\n    }\n\n    /**\n     * Sets whether a gap between the container and components that touch\n     * the border of the container should automatically be created.\n     *\n     * @param autoCreateContainerGaps\twhether a gap between the container\n     * \t\t\t\t\t\t\t\t\tand components that touch the border\n     * \t\t\t\t\t\t\t\t\tof the container should automatically\n     * \t\t\t\t\t\t\t\t\tbe created.\n     */\n    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps) {\n        gl.setAutoCreateContainerGaps(autoCreateContainerGaps);\n    }\n\n    /**\n     * Sets whether all vertical parallel groups\n     * containing JTextFields but not containing other groups\n     * should automatically have baseline alignment.\n     */\n    public void setAutoAlignJTextFields(boolean autoBaselineAlignment) {\n        this.autoBaselineAlignment \u003d autoBaselineAlignment;\n    }\n\n    /**\n     * Forces the specified components to have the same size\n     * regardless of their preferred, minimum or maximum sizes.\n     * Components that are linked are given the maximum\n     * of the preferred size of each of the linked components.\n     *\n     * @param names\tthe names of the components\tthat are\n     * \t\t\t\tto have the same size.\n     */\n    public void linkSize(String... names) {\n        Component[] components \u003d namesToComponents.getComponents(names);\n        gl.linkSize(components);\n    }\n\n    /**\n     * Forces the specified components to have the same size\n     * along the specified axis regardless of their\n     * preferred, minimum or maximum sizes.\n     * Components that are linked are given the maximum\n     * of the preferred size of each of the linked components.\n     *\n     * @param axis\tthe axis to link the size along.\n     * @param names\tthe names of the components\tthat are\n     * \t\t\t\tto have the same size.\n     */\n    public void linkSize(Axis axis, String... names) {\n        Component[] components \u003d namesToComponents.getComponents(names);\n        if (axis \u003d\u003d Axis.HORIZONTAL)\n            gl.linkSize(SwingConstants.HORIZONTAL, components);\n        else\n            //axis\u003d\u003dAxis.VERTICAL\n            gl.linkSize(SwingConstants.VERTICAL, components);\n    }\n\n    /**\n     * Disables the components under the specified names.\n     * \u003cp\u003e\n     * Each component must be associated with its name\n     * before this method is applied.\n     */\n    public void disable(String... componentsNames) {\n        for (Component c : namesToComponents.getComponents(componentsNames)) c.setEnabled(false);\n    }\n\n    /**\n     * Finds the agent of the component with the specified name\n     * and returns an interface for adjusting that component.\n     *\n     * @param axis\t\t\tlayout direction\n     * @param componentName\tthe name of the component to be found\n     * @return\t\t\t\tan interface {@code FunctionsOnComponent}\n     * \t\t\t\t\t\tfor adjusting the component\n     */\n    public FunctionsOnComponent getComponent(Axis axis, String componentName) {\n        Agent agent \u003d getAgent(axis, componentName);\n        if (agent \u003d\u003d null)\n            throw new IllegalArgumentException(\"no such component found: \" + componentName);\n        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();\n    }\n\n    /**\n     * Finds the agent of the group which first and last components\n     * have the specified names;\n     * returns an interface for adjusting that group and adding gaps into it.\n     *\n     * @param axis\t\tlayout direction\n     * @param firstName\tthe name of the first component in the group\n     * @param lastName\tthe name of the last component in the group\n     * @return\t\t\tan interface {@code FunctionsOnGroup}\n     * \t\t\t\t\tfor adjusting that group and adding gaps into it\n     */\n    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {\n        Agent agent \u003d getGroupAgent(axis, firstName, lastName);\n        if (agent \u003d\u003d null || !(agent instanceof GroupAgent))\n            throw new IllegalArgumentException(\"no such group found: \u003c\" + firstName + \",\" + lastName + \"\u003e\");\n        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();\n    }\n\n    /**\n     * Finds the agent of the parallel group which first and last components\n     * have the specified names;\n     * returns an interface for adjusting that group and adding gaps into it.\n     *\n     * @param axis\t\tlayout direction\n     * @param firstName\tthe name of the first component in the group\n     * @param lastName\tthe name of the last component in the group\n     * @return\t\t\tan interface {@code FunctionsOnParallelGroup}\n     * \t\t\t\t\tfor adjusting that group and adding gaps into it\n     */\n    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {\n        Agent agent \u003d getParallelGroupAgent(axis, firstName, lastName);\n        if (agent \u003d\u003d null)\n            throw new IllegalArgumentException(\"no such parallel group found: \u003c\" + firstName + \",\" + lastName + \"\u003e\");\n        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();\n    }\n\n    /**\n     * Finds the agent of the sequential group which first and last components\n     * have the specified names;\n     * returns an interface for adjusting that group and adding gaps into it.\n     *\n     * @param axis\t\tlayout direction\n     * @param firstName\tthe name of the first component in the group\n     * @param lastName\tthe name of the last component in the group\n     * @return\t\t\tan interface {@code FunctionsOnSequentialGroup}\n     * \t\t\t\t\tfor adjusting that group and adding gaps into it\n     */\n    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {\n        Agent agent \u003d getSequentialGroupAgent(axis, firstName, lastName);\n        if (agent \u003d\u003d null)\n            throw new IllegalArgumentException(\"No such sequential group found: \u003c\" + firstName + \",\" + lastName + \"\u003e.\");\n        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();\n    }\n\n    /**\n     * Returns the agent of the top level sequential group\n     * under the specified layout direction.\n     *\n     * @param axis\tlayout direction\n     * @return\t\tthe agent of the top level sequential group\n     * \t\t\t\tunder the specified layout direction\n     */\n    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {\n        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();\n    }\n\n    /**\n     * Returns the agent of the component with the specified name\n     * under the specified layout direction.\n     *\n     * @param axis\tlayout direction\n     * @param name\tthe name of the component to be found\n     * @return\t\tthe corresponding agent\n     */\n    private Agent getAgent(Axis axis, String name) {\n        return getTopAgent(axis).findDependingComponentByName(name);\n    }\n\n    /**\n     * Returns the agent of the group with the specified first and last names\n     * under the specified layout direction.\n     *\n     * @param axis\t\tlayout direction\n     * @param firstName\tthe name of the first component in the group\n     * @param lastName\tthe name of the last component in the group\n     * @return\t\t\tthe agent of the corresponding group\n     */\n    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName) {\n        return getTopAgent(axis).findDependingGroupByNames(firstName, lastName);\n    }\n\n    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName) {\n        return getTopAgent(axis).findDependingSequentialGroupByNames(firstName, lastName);\n    }\n\n    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName) {\n        return getTopAgent(axis).findDependingParallelGroupByNames(firstName, lastName);\n    }\n\n    /**\n     * Returns (a reference to) the top agent\n     * for the specified layout direction.\n     *\n     * @param axis\tlayout direction\n     * @return\t\tthe corresponding top agent\n     */\n    private TopSequentialGroupAgent getTopAgent(Axis axis) {\n        return axis \u003d\u003d Axis.HORIZONTAL ? horizontalLayoutAgent : verticalLayoutAgent;\n    }\n\n    /**\n     * Places the components into the container\n     * according to the scheme and to all additional preferences.\n     */\n    public void engineer() {\n        horizontalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);\n        verticalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);\n        if (autoBaselineAlignment)\n            makeTextFieldsBaselineIn(verticalLayoutAgent);\n        creatorAndAdder \u003d new GroupCreatorAndElementAdderClass();\n        gl.setHorizontalGroup(horizontalLayoutAgent.groupContent(creatorAndAdder));\n        gl.setVerticalGroup(verticalLayoutAgent.groupContent(creatorAndAdder));\n    }\n\n    /**\n     * If the specified group is parallel,\n     * contains directly a component of type {@code JTextField},\n     * and does not contain other groups with components,\n     * then this method makes the alignment of the group {@code Baseline}.\n     * \u003cp\u003e\n     * In the case of a group having subgroups with components\n     * this method passes the call to that subgroups.\n     * \u003cp\u003e\n     * As a result of applying this method,\n     * all parallel groups having TextFields (but having no subgroups)\n     * will be aligned along baselines.\n     */\n    private void makeTextFieldsBaselineIn(GroupAgent group) {\n        boolean containsGroups \u003d false;\n        //the group must be baseline aligned\n        boolean containsTextfields \u003d false;\n        boolean isParallel \u003d group instanceof ParallelGroupAgent;\n        for (Agent child : group.getChildren()) {\n            if (child instanceof GroupAgent \u0026\u0026 ((GroupAgent) child).getFirstName() !\u003d null) {\n                //child is a group with components.\n                makeTextFieldsBaselineIn((GroupAgent) child);\n                containsGroups \u003d true;\n            } else if (child instanceof ComponentAgent \u0026\u0026 isParallel \u0026\u0026 !containsGroups) {\n                ComponentAgent agent \u003d (ComponentAgent) child;\n                Component comp \u003d namesToComponents.compMap.get(agent.getFirstName());\n                if (comp instanceof JTextField)\n                    containsTextfields \u003d true;\n            }\n        }\n        if (containsTextfields) {\n            ParallelGroupSettings settings \u003d ((ParallelGroupAgent) group).getSettings();\n            if (settings.contentAlignment \u003d\u003d null)\n                settings.contentAlignment \u003d Alignment.BASELINE;\n        }\n    }\n\n    /**\n     * Outputs the groups hierarchy.\n     */\n    public void printGroupStructure() {\n        new GroupPrinter().printTopGroupsStructure();\n    }\n\n    /**\n     * Encapsulates the \"names of components - to - components\" mapping\n     * and the corresponding methods of access and modification.\n     */\n    private class NamesToComponents {\n\n        /**\n         * Holds the association between the names of the components on\n         * the scheme and the corresponding components.\n         */\n        private HashMap\u003cString, Component\u003e compMap \u003d new HashMap\u003cString, Component\u003e();\n\n        public NamesToComponents() {\n        }\n\n        @SuppressWarnings(\"unused\")\n        public boolean contains(String name) {\n            return compMap.containsKey(name);\n        }\n\n        @SuppressWarnings(\"unused\")\n        public boolean contains(Component component) {\n            return compMap.containsValue(component);\n        }\n\n        public void put(String name, Component component) {\n            if (name \u003d\u003d null || component \u003d\u003d null || !scheme.containsComponentName(name) || compMap.put(name, component) !\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate a component\" + \" with the name \\\"\" + name + \"\\\"\");\n        }\n\n        /**\n         * Returns the component associated with the specified name.\n         *\n         * @param name\tthe name of the component to return\n         *\n         * @return\t\tthe component associated with the specified name\n         */\n        public Component getComponent(String name) {\n            if (name \u003d\u003d null)\n                throw new IllegalArgumentException(\"No name specified\");\n            Component result \u003d compMap.get(name);\n            if (result \u003d\u003d null)\n                throw new IllegalArgumentException(\"cannot find a component\" + \" with the specified name \\\"\" + name + \"\\\"\");\n            return result;\n        }\n\n        /**\n         * Returns the components associated with the specified names.\n         *\n         * @param names\tthe names of the components to return\n         *\n         * @return\t\tthe components associated with the specified names\n         */\n        public Component[] getComponents(String... names) {\n            int l \u003d names.length;\n            Component[] components \u003d new Component[l];\n            for (int i \u003d 0; i \u003c l; i++) components[i] \u003d getComponent(names[i]);\n            return components;\n        }\n    }\n\n    /**\n     * Declares the method of possessing the gap agent\n     * by a temporary gap agent.\n     */\n    public interface TemporaryGapsToGaps {\n\n        /**\n         * Returns the gap agent associated with the specified\n         * temporary gap agent.\n         */\n        public Agent gap(TemporaryGapAgent temp);\n    }\n\n    /**\n     * Encapsulates the \"names of the gaps - to - agents of these gaps\" mapping\n     * and the corresponding methods of access and modification.\n     */\n    private class NamesToGapAgents implements TemporaryGapsToGaps {\n\n        /**\n         * Holds the association between the gaps denotations\n         * on the scheme and the corresponding gap types.\n         * \u003cp\u003e\n         * The gaps (which can be preferred or simple) are represented\n         * by instances of {@code Agent}, which is a superclass\n         * for both {@code PreferredGapAgent} and {@code GapAgent}.\n         */\n        private HashMap\u003cString, Agent\u003e gapMap \u003d new HashMap\u003cString, Agent\u003e();\n\n        public NamesToGapAgents() {\n            safePut(\".\", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));\n            safePut(\"..\", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));\n        }\n\n        public void put(String name, GapAgent agent) {\n            if (name \u003d\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate a gap with a null name.\");\n            if (agent \u003d\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate null agents.\");\n            if (!scheme.containsGapName(name))\n                return;\n            /*throw new IllegalArgumentException(\n\t\t\t\t\t\"The gap name \" + name + \" not found on the scheme.\");*/\n            safePut(name, agent);\n        }\n\n        protected void safePut(String name, GapAgent agent) {\n            gapMap.put(name, agent);\n        }\n\n        public void put(String name, PreferredGapAgent agent) {\n            if (name \u003d\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate a gap with a null name.\");\n            if (agent \u003d\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate null agents.\");\n            if (!scheme.containsGapName(name))\n                return;\n            /*throw new IllegalArgumentException(\n\t\t\t\t\t\"The gap name \" + name + \" not found on the scheme.\");*/\n            safePut(name, agent);\n        }\n\n        protected void safePut(String name, PreferredGapAgent agent) {\n            gapMap.put(name, agent);\n        }\n\n        /**\n         * Returns the gap agent associated with the specified name.\n         */\n        public Agent gap(String name) {\n            if (name \u003d\u003d null)\n                throw new IllegalArgumentException(\"No name specified\");\n            Agent result \u003d gapMap.get(name);\n            if (result \u003d\u003d null)\n                throw new IllegalArgumentException(\"cannot find a gap denoted by \\\"\" + name + \"\\\"\");\n            return result;\n        }\n\n        /**\n         * Returns the gap agent associated with the specified\n         * temporary gap agent.\n         */\n        public Agent gap(TemporaryGapAgent temp) {\n            return gap(temp.getDenotation());\n        }\n    }\n\n    /**\n     * An adapter for such functions of the {@code GroupLayout}\n     * as creating new groups and adding groups and components to groups.\n     */\n    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {\n\n        /**\n         * Creates and returns a new {@code SequentialGroup}.\n         */\n        public SequentialGroup createSequentialGroup() {\n            return gl.createSequentialGroup();\n        }\n\n        /**\n         * Creates and returns a new {@code ParallelGroup}\n         * with the specified settings.\n         */\n        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {\n            if (settings.contentAlignment !\u003d null)\n                if (settings.resizable !\u003d null)\n                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);\n                else\n                    //(resizable \u003d\u003d null)\n                    return gl.createParallelGroup(settings.contentAlignment);\n            else //(settings.contentAlignment \u003d\u003d null)\n            if (settings.resizable !\u003d null)\n                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);\n            else\n                return gl.createParallelGroup();\n        }\n\n        /**\n         * Adds the component having the specified {@code compName}\n         * to the specified {@code group},\n         * applies to it the specified {@code settings}.\n         */\n        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {\n            if (settings.alignmentWithRespectToParent !\u003d null)\n                //It seems that we must add to a parallel group.\n                if (group instanceof ParallelGroup)\n                    //Really, to a parallel.\n                    if (settings.sizes !\u003d null) {\n                        Sizes sizes \u003d settings.sizes;\n                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);\n                    } else\n                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);\n                else\n                    //Parallel group not found.\n                    throw new IllegalArgumentException(\"components can be aligned in parallel groups only\");\n            else //Alignment not specified.\n            if (settings.sizes !\u003d null) {\n                Sizes sizes \u003d settings.sizes;\n                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);\n            } else\n                //Even sizes aren\u0027t specified.\n                group.addComponent(namesToComponents.getComponent(compName));\n        }\n\n        /**\n         * Adds the specified {@code group} with the specified {@code settings}\n         * to another group {@code parentGroup}.\n         */\n        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {\n            if (settings.alignmentWithRespectToParent !\u003d null)\n                if (parentGroup instanceof ParallelGroup)\n                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);\n                else\n                    throw new IllegalArgumentException(\"content can be aligned in parallel groups only\");\n            parentGroup.addGroup(group);\n        }\n    }\n\n    /**\n     * Provides output of the created groups\u0027 structure.\n     * \u003cp\u003e\n     * Is maintained for debugging purposes.\n     */\n    public class GroupPrinter {\n\n        /**\n         * Outputs the both directions top groups structures.\n         */\n        public void printTopGroupsStructure() {\n            Axis axis;\n            axis \u003d Axis.HORIZONTAL;\n            System.out.println(\"\\nTop \" + axis.toString().toUpperCase() + \" group structure.\");\n            printTopGroupStructure(axis);\n            System.out.println(\"\\n-----------------------------\\n\");\n            axis \u003d Axis.VERTICAL;\n            System.out.println(\"Top \" + axis.toString().toUpperCase() + \" group structure.\");\n            printTopGroupStructure(axis);\n        }\n\n        /**\n         * Outputs the specified direction top group structure.\n         */\n        public void printTopGroupStructure(Axis axis) {\n            printGroupStructure(getTopAgent(axis));\n        }\n\n        /**\n         * Outputs the specified group structure.\n         */\n        public void printGroupStructure(GroupAgent group) {\n            System.out.println();\n            System.out.println(\"Elements of \" + group.toString() + \":\");\n            List\u003cAgent\u003e childrenAgents \u003d group.getChildren();\n            for (Agent child : childrenAgents) System.out.println(child.toString());\n            for (Agent child : childrenAgents) if (child instanceof GroupAgent)\n                printGroupStructure((GroupAgent) child);\n        }\n    }\n}\n",
    "package": "glengineer",
    "classname": "GroupLayoutEngineer",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_1Test.java",
    "test_prompt": "// GroupLayoutEngineer_1Test.java\npackage glengineer;\n\nimport glengineer.agents.*;\nimport glengineer.agents.setters.*;\nimport glengineer.agents.settings.*;\nimport glengineer.blocks.*;\nimport java.util.*;\nimport java.awt.Component;\nimport java.awt.Container;\nimport javax.swing.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GroupLayoutEngineer}.\n* It contains ten unit test cases for the {@link GroupLayoutEngineer#getGroup(Axis, String, String)} method.\n*/\nclass GroupLayoutEngineer_1Test {",
    "method_signature": "getGroup(Axis, String, String)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// GroupLayoutEngineer.java\npackage glengineer;\n\nimport glengineer.agents.*;\nimport glengineer.agents.setters.*;\nimport glengineer.agents.settings.*;\nimport glengineer.blocks.*;\nimport java.util.*;\nimport java.awt.Component;\nimport java.awt.Container;\nimport javax.swing.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\n\n/**\n * {@code GroupLayoutEngineer} is a shell for the layout manager\n * {@code GroupLayout}. It allows to control components\u0027 placement\n * using simple 2-dimensional textual schemes.\n * \u003cp\u003e\n * Such approach to GUI creation removes the problem\n * of representing a 2-dimensional GUI by 1-dimensional code.\n *\n * \u003ch3\u003eHow to use the {@code GroupLayoutEngineer}\u003c/h3\u003e\n *\n * \u003col\u003e\n * \u003cli\u003e Create an instance of the {@code GroupLayoutEngineer}.\n * The first parameter of the constructor is a reference to the container,\n * and the rest are the lines of the textual scheme. For example:\n * \u003cpre\u003e\n * GroupLayoutEngineer gle \u003d new GroupLayoutEngineer(\n *    getContentPane(),\n * \t\"FINDLABEL  TEXTFIELD      FINDBUTTON  \",\n * \t\"          --------------+             \",\n * \t\"           CB11   CB12  | CANSELBUTTON\",\n * \t\"                        |             \",\n * \t\"           CB21   CB22  |             \");\n * \u003c/pre\u003e\n *\n * \u003cli\u003e Associate the names on the scheme with concrete components, for example:\n * \u003cpre\u003e\n * gle.associate(\"FINDLABEL\", new JLabel(\"Find What:\"));\n * gle.associate(\"TEXTFIELD\", new JTextField());\n * gle.associate(\"FINDBUTTON\", new JButton(\"Find\"));\n * gle.associate(\"CB11\", new JCheckBox(\"Match Case\"));\n * gle.associate(\"CB12\", new JCheckBox(\"Wrap Around\"));\n * gle.associate(\"CB21\", new JCheckBox(\"Whole Words\"));\n * gle.associate(\"CB22\", new JCheckBox(\"Search Backwards\"));\n * gle.associate(\"CANSELBUTTON\", new JButton(\"Cancel\"));\n * \u003c/pre\u003e\n *\n * \u003cli\u003e Apply optional preferences (such as special alignment), for example:\n * \u003cpre\u003e\n * gle.linkSize(\"FINDBUTTON\", \"CANSELBUTTON\");\n *\n * gle.getParallelGroup(Axis.VERTICAL, \"FINDLABEL\",\"FINDBUTTON\")\n * \t.setContentAlignment(Alignment.BASELINE);\n *\n * gle.setAutoCreateGaps(true);\n * gle.setAutoCreateContainerGaps(true);\n * \u003c/pre\u003e\n * Note that the alignment in the group above\n * could also be automatically set to {@code Baseline}\n * by calling the method {@code setAutoAlignJTextFields()}.\n * \u003cp\u003e\u003cbr\u003e\n *\n * \u003cli\u003e Invoke the method\n * \u003cpre\u003e\n * gle.engineer();\n * \u003c/pre\u003e\n * \u003c/ol\u003e\n *\n * \u003ch3\u003eHow to control gaps\u003c/h3\u003e\n *\n * If you wish to control the gaps yourself instead of relying\n * on automatic gaps creation, you will have two choices.\n * \u003cp\u003e\n * We recommend to deal with gaps like with components, i.e.,\n * to place the required gaps at the scheme\n * and then to associate them with concrete parameters (types and lengthes),\n * for example:\n * \u003cpre\u003e\n * GroupLayoutEngineer gle \u003d new GroupLayoutEngineer(\n *    getContentPane(),\n * \t\"FINDLABEL .. TEXTFIELD      . FINDBUTTON  \",\n * \t\"            --------------+       .       \",\n * \t\"             CB11 .g CB12 |   CANSELBUTTON\",\n * \t\"               .          |               \",\n * \t\"             CB21    CB22 |               \");\n *\n * gle.associateGap(\".\", ComponentPlacement.RELATED);\n * gle.associateGap(\"..\", ComponentPlacement.UNRELATED);\n * gle.associateGap(\".g1\", 20);\n * \u003c/pre\u003e\n *\n * Note that each gap on the scheme must be started from a dot\n * (in order to make it looking different from components).\n * \u003cp\u003e\n * Also note that any gap (associated with the required parameters)\n * may appear on the scheme any number of times,\n * unlike the components, which appear on the scheme only once.\n * \u003cp\u003e\n * Note that you may skip the associations of the denotations \".\" and \"..\"\n * with related and unrelated gaps respectively,\n * because these associations are always applied by default.\n *\n * \u003cp\u003e\u003cbr\u003e\n * Alternatively, you may add gaps to the layout\n * without making additional changes to the scheme.\n * This approach requires specifying concrete sequential or parallel groups\n * and their concrete elements near which a gap should be added, for example:\n * \u003cpre\u003e\n * gle.getSequentialGroup(Axis.HORIZONTAL, \"CB11\", \"CB22\")\n *   .getGroup(\"CB12\",\"CB22\")\n *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);\n * \u003c/pre\u003e\n * We do not recommend to use the letter approach because it minimizes\n * the advantages of the group layout engineer.\n *\n * \u003ch3\u003eHow to draw schemes\u003c/h3\u003e\n *\n * In order to avoid formal introduction to this topic,\n * we refer to the examples in the package {@code glengineer.demos}\n * for general introduction to the schemes.\n * \u003cp\u003e\n * Here we mention specific yet essential details only.\n *\n * \u003col\u003e\n * \u003cli\u003e The names of components (and gaps) on the scheme may consist of\n * letters of any case, numbers, and underscores \u0027_\u0027.\n * \u003cli\u003e For each layout direction (horizontal and vertical)\n * the engineer tries to divide every non-trivial block of elements\n * on the scheme into a sequential or a parallel\n * (if the former is not possible) group of elements or subblocks.\n * \u003cli\u003e One may place on the scheme horizontal and vertical lines\n * which consist of symbols \u0027-\u0027 and \u0027|\u0027 respectively\n * (and optionally of symbols \u0027+\u0027 for the intersections).\n * \u003cli\u003e If a block on the scheme is intersected by\n * a (horizontal or vertical) line, then this block will\n * not be divided into a sequential group of that direction.\n * Hence, it will be divided into a parallel group.\n * \u003cli\u003e The lines do not influence the layout in the perpendicular direction\n * (but, certainly, this layout direction is influenced\n * by the space under the line).\n * \u003cli\u003e If a block is divided into a parallel group by a number of lines,\n * it is divided only by those of them which have the maximum length,\n * and the smaller lines (if they exist) are left for the subblocks.\n * \u003cli\u003e Gaps on the scheme affect sequential groups only.\n * \u003cli\u003e If two sequential subblocks are divided by a number of gaps,\n * then these gaps will be replaced by a single gap of that type.\n * \u003cli\u003e Gaps on the scheme may lie AT lines.\n * Such lines are considered as being continued under that gaps,\n * and the gaps affect only the direction perpendicular to the\n * corresponding line.\n * \u003cli\u003e A line may be intersected only by one gap.\n * \u003cli\u003e If a gap touches one of the sides of a line,\n * it is also assumed that they intersect.\n * \u003c/ol\u003e\n *\n * @author Yevgen Ivakhno\n * @version 1.1, 18/05/2009\n */\npublic class GroupLayoutEngineer {\n\n    private Scheme scheme;\n\n    /**\n     * The mapping of the names on the scheme to the associated components.\n     */\n    private NamesToComponents namesToComponents;\n\n    private NamesToGapAgents namesToGapAgents;\n\n    /**\n     * The layout manager {@code GroupLayout} under control.\n     */\n    private GroupLayout gl;\n\n    /**\n     * The object which can create sequential and parallel\n     * {@code GroupLayout} groups and add components to groups\n     * using the components\u0027 names.\n     * \u003cp\u003e\n     * A reference to this object is given to the agents of elements.\n     *\n     * @see glengineer.agents\n     */\n    private GroupCreatorAndElementAdderClass creatorAndAdder;\n\n    /**\n     * The agent of the top level horizontal group.\n     */\n    private TopSequentialGroupAgent horizontalLayoutAgent;\n\n    /**\n     * The agent of the top level vertical group.\n     */\n    private TopSequentialGroupAgent verticalLayoutAgent;\n\n    /**\n     * Whether all vertical parallel groups\n     * containing JTextFields but not containing other groups\n     * should automatically have baseline alignment.\n     */\n    private boolean autoBaselineAlignment \u003d false;\n\n    /**\n     * @param container\tthe container that needs to be laid out\n     * @param lines\t\ta sequence of lines representing the scheme\n     */\n    public GroupLayoutEngineer(Container container, String... lines) {\n        scheme \u003d new Scheme(lines);\n        namesToComponents \u003d new NamesToComponents();\n        namesToGapAgents \u003d new NamesToGapAgents();\n        horizontalLayoutAgent \u003d compouseTopSequentialGroup(Axis.HORIZONTAL);\n        verticalLayoutAgent \u003d compouseTopSequentialGroup(Axis.VERTICAL);\n        horizontalLayoutAgent.removeGapsFromParallelGroups();\n        verticalLayoutAgent.removeGapsFromParallelGroups();\n        gl \u003d new GroupLayout(container);\n        container.setLayout(gl);\n        //\t\tsetAutoCreateGaps(true);\n        //\t\tsetAutoCreateContainerGaps(true);\n    }\n\n    /**\n     * Returns a top sequential group agent for the specified layout direction.\n     * \u003cp\u003e\n     * A group will be created even if it would contain a single element.\n     *\n     * @param axis\tthe layout direction\n     *\n     * @return\t\tthe agent of the new sequential group\n     */\n    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis) {\n        Block topBlock;\n        if (axis \u003d\u003d Axis.HORIZONTAL)\n            topBlock \u003d new HorizontalBlock(scheme);\n        else\n            //VERTICAL\n            topBlock \u003d new VerticalBlock(scheme);\n        topBlock.optimize();\n        if (topBlock.isTrivial())\n            throw new IllegalArgumentException(\"the scheme does not possess components\u0027 names\");\n        TopSequentialGroupAgent result \u003d new TopSequentialGroupAgent();\n        List\u003cBlock\u003e blocksList \u003d topBlock.extractSequentialSubblocks();\n        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));\n        return result;\n    }\n\n    /**\n     * Returns a new sequential group agent filled with\n     * the agents of the specified block content.\n     *\n     * @param block\tthe block which content should be placed\n     * \t\t\t\tinto a sequential group.\n     *\n     * @return\t\tthe agent of the new sequential group.\n     */\n    protected Agent compouseSequentialGroupFromBlock(Block block) {\n        block.optimize();\n        if (block.isTrivial())\n            return null;\n        List\u003cBlock\u003e blocksList \u003d block.extractSequentialSubblocks();\n        if (blocksList.size() \u003d\u003d 1)\n            return processSubblockOfSequentialGroup(block);\n        SequentialGroupAgent result \u003d new SequentialGroupAgent();\n        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));\n        return result;\n    }\n\n    /**\n     * Verifies whether the specified subblock contains a single element\n     * or a set of elements\n     * and either returns the agent of the corresponding element,\n     * or divides the set of elements into a new parallel subgroup\n     * and returns the corresponding agent.\n     *\n     * @param subblock\ta block in a sequential group.\n     *\n     * @return\t\t\tthe agent of the specified subblock content.\n     */\n    private Agent processSubblockOfSequentialGroup(Block subblock) {\n        if (subblock.containsOnlyOneWord())\n            return getElementFromBlockWithOnlyWord(subblock);\n        else\n            return composeParallelGroupFromBlock(subblock);\n    }\n\n    /**\n     * Returns the agent of the unique element (a component or a gap)\n     * in the specified block which is added into a sequential group.\n     *\n     * @param block\ta block with an only element in a parallel group.\n     *\n     * @return\t\tthe agent of the unique element in the specified block.\n     */\n    private Agent getElementFromBlockWithOnlyWord(Block block) {\n        String word \u003d block.textAt(block.firstWord_Horizontally());\n        if (word.charAt(0) \u003d\u003d \u0027.\u0027)\n            return new TemporaryGapAgent(word);\n        return new ComponentAgent(word);\n    }\n\n    /**\n     * Returns a new parallel group agent filled with\n     * the agents of the specified block content.\n     *\n     * @param block\tthe block which content should be placed\n     * \t\t\t\tinto a sequential group.\n     *\n     * @return\t\tthe agent of the new parallel group.\n     */\n    protected Agent composeParallelGroupFromBlock(Block block) {\n        block.optimize();\n        if (block.isTrivial())\n            return null;\n        List\u003cBlock\u003e blocksList \u003d block.extractParallelSubblocks();\n        if (blocksList.size() \u003d\u003d 1)\n            return processSubblockOfParallelGroup(block);\n        ParallelGroupAgent result \u003d new ParallelGroupAgent();\n        Agent agent;\n        for (Block subBlock : blocksList) {\n            agent \u003d processSubblockOfParallelGroup(subBlock);\n            if (agent !\u003d null)\n                result.addAgent(agent);\n        }\n        return result;\n    }\n\n    /**\n     * Verifies whether the specified subblock contains a single element\n     * or a set of elements\n     * and then either returns the agent of the corresponding element,\n     * or divides the set of elements into a new sequential subgroup\n     * and returns the corresponding agent.\n     * \u003cp\u003e\n     * If there is a unique element and it is a gap,\n     *\n     * @param subblock\ta block in a parallel group.\n     *\n     * @return\tthe agent of the specified subblock content.\n     */\n    private Agent processSubblockOfParallelGroup(Block subblock) {\n        if (subblock.containsOnlyOneWord())\n            return getElementFromBlockWithOnlyWord(subblock);\n        else\n            return compouseSequentialGroupFromBlock(subblock);\n    }\n\n    /**\n     * Associates the specified {@code name} on the scheme\n     * with the specified {@code component}.\n     *\n     * @param name\t\tthe component name present on the scheme.\n     * @param component\tthe component to be associated with the name.\n     */\n    public void associate(String name, Component component) {\n        namesToComponents.put(name, component);\n    }\n\n    /**\n     * Associates the specified {@code denotation} on the scheme\n     * with gaps of the specified {@code size}.\n     */\n    public void associateGap(String denotation, int size) {\n        namesToGapAgents.put(denotation, new GapAgent(size));\n    }\n\n    /**\n     * Associates the specified {@code denotation} on the scheme with gaps\n     * of the specified {@code min}, {@code pref}, and {@code max} sizes.\n     */\n    public void associateGap(String denotation, int min, int pref, int max) {\n        namesToGapAgents.put(denotation, new GapAgent(min, pref, max));\n    }\n\n    /**\n     * Associates the specified {@code denotation} on the scheme\n     * with preferred gaps\n     * of the specified component placement type (related or unrelated).\n     */\n    public void associateGap(String denotation, ComponentPlacement type) {\n        namesToGapAgents.put(denotation, new PreferredGapAgent(type));\n    }\n\n    /**\n     * Associates the specified {@code denotation} on the scheme\n     * with preferred gaps\n     * of the specified component placement type (related or unrelated)\n     * and of the specified preferred and maximum sizes.\n     */\n    public void associateGap(String denotation, ComponentPlacement type, int pref, int max) {\n        namesToGapAgents.put(denotation, new PreferredGapAgent(type, pref, max));\n    }\n\n    /**\n     * Sets whether a gap between components should automatically be\n     * created. For example, if this is {@code true} and you add two\n     * components to a {@code SequentialGroup} a gap between the\n     * two components is automatically be created.\n     *\n     * @param autoCreatePadding\twhether a gap between components is\n     *        \t\t\t\t\tautomatically created.\n     */\n    public void setAutoCreateGaps(boolean autoCreatePadding) {\n        gl.setAutoCreateGaps(autoCreatePadding);\n    }\n\n    /**\n     * Sets whether a gap between the container and components that touch\n     * the border of the container should automatically be created.\n     *\n     * @param autoCreateContainerGaps\twhether a gap between the container\n     * \t\t\t\t\t\t\t\t\tand components that touch the border\n     * \t\t\t\t\t\t\t\t\tof the container should automatically\n     * \t\t\t\t\t\t\t\t\tbe created.\n     */\n    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps) {\n        gl.setAutoCreateContainerGaps(autoCreateContainerGaps);\n    }\n\n    /**\n     * Sets whether all vertical parallel groups\n     * containing JTextFields but not containing other groups\n     * should automatically have baseline alignment.\n     */\n    public void setAutoAlignJTextFields(boolean autoBaselineAlignment) {\n        this.autoBaselineAlignment \u003d autoBaselineAlignment;\n    }\n\n    /**\n     * Forces the specified components to have the same size\n     * regardless of their preferred, minimum or maximum sizes.\n     * Components that are linked are given the maximum\n     * of the preferred size of each of the linked components.\n     *\n     * @param names\tthe names of the components\tthat are\n     * \t\t\t\tto have the same size.\n     */\n    public void linkSize(String... names) {\n        Component[] components \u003d namesToComponents.getComponents(names);\n        gl.linkSize(components);\n    }\n\n    /**\n     * Forces the specified components to have the same size\n     * along the specified axis regardless of their\n     * preferred, minimum or maximum sizes.\n     * Components that are linked are given the maximum\n     * of the preferred size of each of the linked components.\n     *\n     * @param axis\tthe axis to link the size along.\n     * @param names\tthe names of the components\tthat are\n     * \t\t\t\tto have the same size.\n     */\n    public void linkSize(Axis axis, String... names) {\n        Component[] components \u003d namesToComponents.getComponents(names);\n        if (axis \u003d\u003d Axis.HORIZONTAL)\n            gl.linkSize(SwingConstants.HORIZONTAL, components);\n        else\n            //axis\u003d\u003dAxis.VERTICAL\n            gl.linkSize(SwingConstants.VERTICAL, components);\n    }\n\n    /**\n     * Disables the components under the specified names.\n     * \u003cp\u003e\n     * Each component must be associated with its name\n     * before this method is applied.\n     */\n    public void disable(String... componentsNames) {\n        for (Component c : namesToComponents.getComponents(componentsNames)) c.setEnabled(false);\n    }\n\n    /**\n     * Finds the agent of the component with the specified name\n     * and returns an interface for adjusting that component.\n     *\n     * @param axis\t\t\tlayout direction\n     * @param componentName\tthe name of the component to be found\n     * @return\t\t\t\tan interface {@code FunctionsOnComponent}\n     * \t\t\t\t\t\tfor adjusting the component\n     */\n    public FunctionsOnComponent getComponent(Axis axis, String componentName) {\n        Agent agent \u003d getAgent(axis, componentName);\n        if (agent \u003d\u003d null)\n            throw new IllegalArgumentException(\"no such component found: \" + componentName);\n        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();\n    }\n\n    /**\n     * Finds the agent of the group which first and last components\n     * have the specified names;\n     * returns an interface for adjusting that group and adding gaps into it.\n     *\n     * @param axis\t\tlayout direction\n     * @param firstName\tthe name of the first component in the group\n     * @param lastName\tthe name of the last component in the group\n     * @return\t\t\tan interface {@code FunctionsOnGroup}\n     * \t\t\t\t\tfor adjusting that group and adding gaps into it\n     */\n    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {\n        Agent agent \u003d getGroupAgent(axis, firstName, lastName);\n        if (agent \u003d\u003d null || !(agent instanceof GroupAgent))\n            throw new IllegalArgumentException(\"no such group found: \u003c\" + firstName + \",\" + lastName + \"\u003e\");\n        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();\n    }\n\n    /**\n     * Finds the agent of the parallel group which first and last components\n     * have the specified names;\n     * returns an interface for adjusting that group and adding gaps into it.\n     *\n     * @param axis\t\tlayout direction\n     * @param firstName\tthe name of the first component in the group\n     * @param lastName\tthe name of the last component in the group\n     * @return\t\t\tan interface {@code FunctionsOnParallelGroup}\n     * \t\t\t\t\tfor adjusting that group and adding gaps into it\n     */\n    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {\n        Agent agent \u003d getParallelGroupAgent(axis, firstName, lastName);\n        if (agent \u003d\u003d null)\n            throw new IllegalArgumentException(\"no such parallel group found: \u003c\" + firstName + \",\" + lastName + \"\u003e\");\n        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();\n    }\n\n    /**\n     * Finds the agent of the sequential group which first and last components\n     * have the specified names;\n     * returns an interface for adjusting that group and adding gaps into it.\n     *\n     * @param axis\t\tlayout direction\n     * @param firstName\tthe name of the first component in the group\n     * @param lastName\tthe name of the last component in the group\n     * @return\t\t\tan interface {@code FunctionsOnSequentialGroup}\n     * \t\t\t\t\tfor adjusting that group and adding gaps into it\n     */\n    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {\n        Agent agent \u003d getSequentialGroupAgent(axis, firstName, lastName);\n        if (agent \u003d\u003d null)\n            throw new IllegalArgumentException(\"No such sequential group found: \u003c\" + firstName + \",\" + lastName + \"\u003e.\");\n        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();\n    }\n\n    /**\n     * Returns the agent of the top level sequential group\n     * under the specified layout direction.\n     *\n     * @param axis\tlayout direction\n     * @return\t\tthe agent of the top level sequential group\n     * \t\t\t\tunder the specified layout direction\n     */\n    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {\n        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();\n    }\n\n    /**\n     * Returns the agent of the component with the specified name\n     * under the specified layout direction.\n     *\n     * @param axis\tlayout direction\n     * @param name\tthe name of the component to be found\n     * @return\t\tthe corresponding agent\n     */\n    private Agent getAgent(Axis axis, String name) {\n        return getTopAgent(axis).findDependingComponentByName(name);\n    }\n\n    /**\n     * Returns the agent of the group with the specified first and last names\n     * under the specified layout direction.\n     *\n     * @param axis\t\tlayout direction\n     * @param firstName\tthe name of the first component in the group\n     * @param lastName\tthe name of the last component in the group\n     * @return\t\t\tthe agent of the corresponding group\n     */\n    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName) {\n        return getTopAgent(axis).findDependingGroupByNames(firstName, lastName);\n    }\n\n    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName) {\n        return getTopAgent(axis).findDependingSequentialGroupByNames(firstName, lastName);\n    }\n\n    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName) {\n        return getTopAgent(axis).findDependingParallelGroupByNames(firstName, lastName);\n    }\n\n    /**\n     * Returns (a reference to) the top agent\n     * for the specified layout direction.\n     *\n     * @param axis\tlayout direction\n     * @return\t\tthe corresponding top agent\n     */\n    private TopSequentialGroupAgent getTopAgent(Axis axis) {\n        return axis \u003d\u003d Axis.HORIZONTAL ? horizontalLayoutAgent : verticalLayoutAgent;\n    }\n\n    /**\n     * Places the components into the container\n     * according to the scheme and to all additional preferences.\n     */\n    public void engineer() {\n        horizontalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);\n        verticalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);\n        if (autoBaselineAlignment)\n            makeTextFieldsBaselineIn(verticalLayoutAgent);\n        creatorAndAdder \u003d new GroupCreatorAndElementAdderClass();\n        gl.setHorizontalGroup(horizontalLayoutAgent.groupContent(creatorAndAdder));\n        gl.setVerticalGroup(verticalLayoutAgent.groupContent(creatorAndAdder));\n    }\n\n    /**\n     * If the specified group is parallel,\n     * contains directly a component of type {@code JTextField},\n     * and does not contain other groups with components,\n     * then this method makes the alignment of the group {@code Baseline}.\n     * \u003cp\u003e\n     * In the case of a group having subgroups with components\n     * this method passes the call to that subgroups.\n     * \u003cp\u003e\n     * As a result of applying this method,\n     * all parallel groups having TextFields (but having no subgroups)\n     * will be aligned along baselines.\n     */\n    private void makeTextFieldsBaselineIn(GroupAgent group) {\n        boolean containsGroups \u003d false;\n        //the group must be baseline aligned\n        boolean containsTextfields \u003d false;\n        boolean isParallel \u003d group instanceof ParallelGroupAgent;\n        for (Agent child : group.getChildren()) {\n            if (child instanceof GroupAgent \u0026\u0026 ((GroupAgent) child).getFirstName() !\u003d null) {\n                //child is a group with components.\n                makeTextFieldsBaselineIn((GroupAgent) child);\n                containsGroups \u003d true;\n            } else if (child instanceof ComponentAgent \u0026\u0026 isParallel \u0026\u0026 !containsGroups) {\n                ComponentAgent agent \u003d (ComponentAgent) child;\n                Component comp \u003d namesToComponents.compMap.get(agent.getFirstName());\n                if (comp instanceof JTextField)\n                    containsTextfields \u003d true;\n            }\n        }\n        if (containsTextfields) {\n            ParallelGroupSettings settings \u003d ((ParallelGroupAgent) group).getSettings();\n            if (settings.contentAlignment \u003d\u003d null)\n                settings.contentAlignment \u003d Alignment.BASELINE;\n        }\n    }\n\n    /**\n     * Outputs the groups hierarchy.\n     */\n    public void printGroupStructure() {\n        new GroupPrinter().printTopGroupsStructure();\n    }\n\n    /**\n     * Encapsulates the \"names of components - to - components\" mapping\n     * and the corresponding methods of access and modification.\n     */\n    private class NamesToComponents {\n\n        /**\n         * Holds the association between the names of the components on\n         * the scheme and the corresponding components.\n         */\n        private HashMap\u003cString, Component\u003e compMap \u003d new HashMap\u003cString, Component\u003e();\n\n        public NamesToComponents() {\n        }\n\n        @SuppressWarnings(\"unused\")\n        public boolean contains(String name) {\n            return compMap.containsKey(name);\n        }\n\n        @SuppressWarnings(\"unused\")\n        public boolean contains(Component component) {\n            return compMap.containsValue(component);\n        }\n\n        public void put(String name, Component component) {\n            if (name \u003d\u003d null || component \u003d\u003d null || !scheme.containsComponentName(name) || compMap.put(name, component) !\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate a component\" + \" with the name \\\"\" + name + \"\\\"\");\n        }\n\n        /**\n         * Returns the component associated with the specified name.\n         *\n         * @param name\tthe name of the component to return\n         *\n         * @return\t\tthe component associated with the specified name\n         */\n        public Component getComponent(String name) {\n            if (name \u003d\u003d null)\n                throw new IllegalArgumentException(\"No name specified\");\n            Component result \u003d compMap.get(name);\n            if (result \u003d\u003d null)\n                throw new IllegalArgumentException(\"cannot find a component\" + \" with the specified name \\\"\" + name + \"\\\"\");\n            return result;\n        }\n\n        /**\n         * Returns the components associated with the specified names.\n         *\n         * @param names\tthe names of the components to return\n         *\n         * @return\t\tthe components associated with the specified names\n         */\n        public Component[] getComponents(String... names) {\n            int l \u003d names.length;\n            Component[] components \u003d new Component[l];\n            for (int i \u003d 0; i \u003c l; i++) components[i] \u003d getComponent(names[i]);\n            return components;\n        }\n    }\n\n    /**\n     * Declares the method of possessing the gap agent\n     * by a temporary gap agent.\n     */\n    public interface TemporaryGapsToGaps {\n\n        /**\n         * Returns the gap agent associated with the specified\n         * temporary gap agent.\n         */\n        public Agent gap(TemporaryGapAgent temp);\n    }\n\n    /**\n     * Encapsulates the \"names of the gaps - to - agents of these gaps\" mapping\n     * and the corresponding methods of access and modification.\n     */\n    private class NamesToGapAgents implements TemporaryGapsToGaps {\n\n        /**\n         * Holds the association between the gaps denotations\n         * on the scheme and the corresponding gap types.\n         * \u003cp\u003e\n         * The gaps (which can be preferred or simple) are represented\n         * by instances of {@code Agent}, which is a superclass\n         * for both {@code PreferredGapAgent} and {@code GapAgent}.\n         */\n        private HashMap\u003cString, Agent\u003e gapMap \u003d new HashMap\u003cString, Agent\u003e();\n\n        public NamesToGapAgents() {\n            safePut(\".\", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));\n            safePut(\"..\", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));\n        }\n\n        public void put(String name, GapAgent agent) {\n            if (name \u003d\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate a gap with a null name.\");\n            if (agent \u003d\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate null agents.\");\n            if (!scheme.containsGapName(name))\n                return;\n            /*throw new IllegalArgumentException(\n\t\t\t\t\t\"The gap name \" + name + \" not found on the scheme.\");*/\n            safePut(name, agent);\n        }\n\n        protected void safePut(String name, GapAgent agent) {\n            gapMap.put(name, agent);\n        }\n\n        public void put(String name, PreferredGapAgent agent) {\n            if (name \u003d\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate a gap with a null name.\");\n            if (agent \u003d\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate null agents.\");\n            if (!scheme.containsGapName(name))\n                return;\n            /*throw new IllegalArgumentException(\n\t\t\t\t\t\"The gap name \" + name + \" not found on the scheme.\");*/\n            safePut(name, agent);\n        }\n\n        protected void safePut(String name, PreferredGapAgent agent) {\n            gapMap.put(name, agent);\n        }\n\n        /**\n         * Returns the gap agent associated with the specified name.\n         */\n        public Agent gap(String name) {\n            if (name \u003d\u003d null)\n                throw new IllegalArgumentException(\"No name specified\");\n            Agent result \u003d gapMap.get(name);\n            if (result \u003d\u003d null)\n                throw new IllegalArgumentException(\"cannot find a gap denoted by \\\"\" + name + \"\\\"\");\n            return result;\n        }\n\n        /**\n         * Returns the gap agent associated with the specified\n         * temporary gap agent.\n         */\n        public Agent gap(TemporaryGapAgent temp) {\n            return gap(temp.getDenotation());\n        }\n    }\n\n    /**\n     * An adapter for such functions of the {@code GroupLayout}\n     * as creating new groups and adding groups and components to groups.\n     */\n    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {\n\n        /**\n         * Creates and returns a new {@code SequentialGroup}.\n         */\n        public SequentialGroup createSequentialGroup() {\n            return gl.createSequentialGroup();\n        }\n\n        /**\n         * Creates and returns a new {@code ParallelGroup}\n         * with the specified settings.\n         */\n        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {\n            if (settings.contentAlignment !\u003d null)\n                if (settings.resizable !\u003d null)\n                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);\n                else\n                    //(resizable \u003d\u003d null)\n                    return gl.createParallelGroup(settings.contentAlignment);\n            else //(settings.contentAlignment \u003d\u003d null)\n            if (settings.resizable !\u003d null)\n                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);\n            else\n                return gl.createParallelGroup();\n        }\n\n        /**\n         * Adds the component having the specified {@code compName}\n         * to the specified {@code group},\n         * applies to it the specified {@code settings}.\n         */\n        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {\n            if (settings.alignmentWithRespectToParent !\u003d null)\n                //It seems that we must add to a parallel group.\n                if (group instanceof ParallelGroup)\n                    //Really, to a parallel.\n                    if (settings.sizes !\u003d null) {\n                        Sizes sizes \u003d settings.sizes;\n                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);\n                    } else\n                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);\n                else\n                    //Parallel group not found.\n                    throw new IllegalArgumentException(\"components can be aligned in parallel groups only\");\n            else //Alignment not specified.\n            if (settings.sizes !\u003d null) {\n                Sizes sizes \u003d settings.sizes;\n                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);\n            } else\n                //Even sizes aren\u0027t specified.\n                group.addComponent(namesToComponents.getComponent(compName));\n        }\n\n        /**\n         * Adds the specified {@code group} with the specified {@code settings}\n         * to another group {@code parentGroup}.\n         */\n        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {\n            if (settings.alignmentWithRespectToParent !\u003d null)\n                if (parentGroup instanceof ParallelGroup)\n                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);\n                else\n                    throw new IllegalArgumentException(\"content can be aligned in parallel groups only\");\n            parentGroup.addGroup(group);\n        }\n    }\n\n    /**\n     * Provides output of the created groups\u0027 structure.\n     * \u003cp\u003e\n     * Is maintained for debugging purposes.\n     */\n    public class GroupPrinter {\n\n        /**\n         * Outputs the both directions top groups structures.\n         */\n        public void printTopGroupsStructure() {\n            Axis axis;\n            axis \u003d Axis.HORIZONTAL;\n            System.out.println(\"\\nTop \" + axis.toString().toUpperCase() + \" group structure.\");\n            printTopGroupStructure(axis);\n            System.out.println(\"\\n-----------------------------\\n\");\n            axis \u003d Axis.VERTICAL;\n            System.out.println(\"Top \" + axis.toString().toUpperCase() + \" group structure.\");\n            printTopGroupStructure(axis);\n        }\n\n        /**\n         * Outputs the specified direction top group structure.\n         */\n        public void printTopGroupStructure(Axis axis) {\n            printGroupStructure(getTopAgent(axis));\n        }\n\n        /**\n         * Outputs the specified group structure.\n         */\n        public void printGroupStructure(GroupAgent group) {\n            System.out.println();\n            System.out.println(\"Elements of \" + group.toString() + \":\");\n            List\u003cAgent\u003e childrenAgents \u003d group.getChildren();\n            for (Agent child : childrenAgents) System.out.println(child.toString());\n            for (Agent child : childrenAgents) if (child instanceof GroupAgent)\n                printGroupStructure((GroupAgent) child);\n        }\n    }\n}\n",
    "package": "glengineer",
    "classname": "GroupLayoutEngineer",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_2Test.java",
    "test_prompt": "// GroupLayoutEngineer_2Test.java\npackage glengineer;\n\nimport glengineer.agents.*;\nimport glengineer.agents.setters.*;\nimport glengineer.agents.settings.*;\nimport glengineer.blocks.*;\nimport java.util.*;\nimport java.awt.Component;\nimport java.awt.Container;\nimport javax.swing.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GroupLayoutEngineer}.\n* It contains ten unit test cases for the {@link GroupLayoutEngineer#getParallelGroup(Axis, String, String)} method.\n*/\nclass GroupLayoutEngineer_2Test {",
    "method_signature": "getParallelGroup(Axis, String, String)",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// GroupLayoutEngineer.java\npackage glengineer;\n\nimport glengineer.agents.*;\nimport glengineer.agents.setters.*;\nimport glengineer.agents.settings.*;\nimport glengineer.blocks.*;\nimport java.util.*;\nimport java.awt.Component;\nimport java.awt.Container;\nimport javax.swing.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\n\n/**\n * {@code GroupLayoutEngineer} is a shell for the layout manager\n * {@code GroupLayout}. It allows to control components\u0027 placement\n * using simple 2-dimensional textual schemes.\n * \u003cp\u003e\n * Such approach to GUI creation removes the problem\n * of representing a 2-dimensional GUI by 1-dimensional code.\n *\n * \u003ch3\u003eHow to use the {@code GroupLayoutEngineer}\u003c/h3\u003e\n *\n * \u003col\u003e\n * \u003cli\u003e Create an instance of the {@code GroupLayoutEngineer}.\n * The first parameter of the constructor is a reference to the container,\n * and the rest are the lines of the textual scheme. For example:\n * \u003cpre\u003e\n * GroupLayoutEngineer gle \u003d new GroupLayoutEngineer(\n *    getContentPane(),\n * \t\"FINDLABEL  TEXTFIELD      FINDBUTTON  \",\n * \t\"          --------------+             \",\n * \t\"           CB11   CB12  | CANSELBUTTON\",\n * \t\"                        |             \",\n * \t\"           CB21   CB22  |             \");\n * \u003c/pre\u003e\n *\n * \u003cli\u003e Associate the names on the scheme with concrete components, for example:\n * \u003cpre\u003e\n * gle.associate(\"FINDLABEL\", new JLabel(\"Find What:\"));\n * gle.associate(\"TEXTFIELD\", new JTextField());\n * gle.associate(\"FINDBUTTON\", new JButton(\"Find\"));\n * gle.associate(\"CB11\", new JCheckBox(\"Match Case\"));\n * gle.associate(\"CB12\", new JCheckBox(\"Wrap Around\"));\n * gle.associate(\"CB21\", new JCheckBox(\"Whole Words\"));\n * gle.associate(\"CB22\", new JCheckBox(\"Search Backwards\"));\n * gle.associate(\"CANSELBUTTON\", new JButton(\"Cancel\"));\n * \u003c/pre\u003e\n *\n * \u003cli\u003e Apply optional preferences (such as special alignment), for example:\n * \u003cpre\u003e\n * gle.linkSize(\"FINDBUTTON\", \"CANSELBUTTON\");\n *\n * gle.getParallelGroup(Axis.VERTICAL, \"FINDLABEL\",\"FINDBUTTON\")\n * \t.setContentAlignment(Alignment.BASELINE);\n *\n * gle.setAutoCreateGaps(true);\n * gle.setAutoCreateContainerGaps(true);\n * \u003c/pre\u003e\n * Note that the alignment in the group above\n * could also be automatically set to {@code Baseline}\n * by calling the method {@code setAutoAlignJTextFields()}.\n * \u003cp\u003e\u003cbr\u003e\n *\n * \u003cli\u003e Invoke the method\n * \u003cpre\u003e\n * gle.engineer();\n * \u003c/pre\u003e\n * \u003c/ol\u003e\n *\n * \u003ch3\u003eHow to control gaps\u003c/h3\u003e\n *\n * If you wish to control the gaps yourself instead of relying\n * on automatic gaps creation, you will have two choices.\n * \u003cp\u003e\n * We recommend to deal with gaps like with components, i.e.,\n * to place the required gaps at the scheme\n * and then to associate them with concrete parameters (types and lengthes),\n * for example:\n * \u003cpre\u003e\n * GroupLayoutEngineer gle \u003d new GroupLayoutEngineer(\n *    getContentPane(),\n * \t\"FINDLABEL .. TEXTFIELD      . FINDBUTTON  \",\n * \t\"            --------------+       .       \",\n * \t\"             CB11 .g CB12 |   CANSELBUTTON\",\n * \t\"               .          |               \",\n * \t\"             CB21    CB22 |               \");\n *\n * gle.associateGap(\".\", ComponentPlacement.RELATED);\n * gle.associateGap(\"..\", ComponentPlacement.UNRELATED);\n * gle.associateGap(\".g1\", 20);\n * \u003c/pre\u003e\n *\n * Note that each gap on the scheme must be started from a dot\n * (in order to make it looking different from components).\n * \u003cp\u003e\n * Also note that any gap (associated with the required parameters)\n * may appear on the scheme any number of times,\n * unlike the components, which appear on the scheme only once.\n * \u003cp\u003e\n * Note that you may skip the associations of the denotations \".\" and \"..\"\n * with related and unrelated gaps respectively,\n * because these associations are always applied by default.\n *\n * \u003cp\u003e\u003cbr\u003e\n * Alternatively, you may add gaps to the layout\n * without making additional changes to the scheme.\n * This approach requires specifying concrete sequential or parallel groups\n * and their concrete elements near which a gap should be added, for example:\n * \u003cpre\u003e\n * gle.getSequentialGroup(Axis.HORIZONTAL, \"CB11\", \"CB22\")\n *   .getGroup(\"CB12\",\"CB22\")\n *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);\n * \u003c/pre\u003e\n * We do not recommend to use the letter approach because it minimizes\n * the advantages of the group layout engineer.\n *\n * \u003ch3\u003eHow to draw schemes\u003c/h3\u003e\n *\n * In order to avoid formal introduction to this topic,\n * we refer to the examples in the package {@code glengineer.demos}\n * for general introduction to the schemes.\n * \u003cp\u003e\n * Here we mention specific yet essential details only.\n *\n * \u003col\u003e\n * \u003cli\u003e The names of components (and gaps) on the scheme may consist of\n * letters of any case, numbers, and underscores \u0027_\u0027.\n * \u003cli\u003e For each layout direction (horizontal and vertical)\n * the engineer tries to divide every non-trivial block of elements\n * on the scheme into a sequential or a parallel\n * (if the former is not possible) group of elements or subblocks.\n * \u003cli\u003e One may place on the scheme horizontal and vertical lines\n * which consist of symbols \u0027-\u0027 and \u0027|\u0027 respectively\n * (and optionally of symbols \u0027+\u0027 for the intersections).\n * \u003cli\u003e If a block on the scheme is intersected by\n * a (horizontal or vertical) line, then this block will\n * not be divided into a sequential group of that direction.\n * Hence, it will be divided into a parallel group.\n * \u003cli\u003e The lines do not influence the layout in the perpendicular direction\n * (but, certainly, this layout direction is influenced\n * by the space under the line).\n * \u003cli\u003e If a block is divided into a parallel group by a number of lines,\n * it is divided only by those of them which have the maximum length,\n * and the smaller lines (if they exist) are left for the subblocks.\n * \u003cli\u003e Gaps on the scheme affect sequential groups only.\n * \u003cli\u003e If two sequential subblocks are divided by a number of gaps,\n * then these gaps will be replaced by a single gap of that type.\n * \u003cli\u003e Gaps on the scheme may lie AT lines.\n * Such lines are considered as being continued under that gaps,\n * and the gaps affect only the direction perpendicular to the\n * corresponding line.\n * \u003cli\u003e A line may be intersected only by one gap.\n * \u003cli\u003e If a gap touches one of the sides of a line,\n * it is also assumed that they intersect.\n * \u003c/ol\u003e\n *\n * @author Yevgen Ivakhno\n * @version 1.1, 18/05/2009\n */\npublic class GroupLayoutEngineer {\n\n    private Scheme scheme;\n\n    /**\n     * The mapping of the names on the scheme to the associated components.\n     */\n    private NamesToComponents namesToComponents;\n\n    private NamesToGapAgents namesToGapAgents;\n\n    /**\n     * The layout manager {@code GroupLayout} under control.\n     */\n    private GroupLayout gl;\n\n    /**\n     * The object which can create sequential and parallel\n     * {@code GroupLayout} groups and add components to groups\n     * using the components\u0027 names.\n     * \u003cp\u003e\n     * A reference to this object is given to the agents of elements.\n     *\n     * @see glengineer.agents\n     */\n    private GroupCreatorAndElementAdderClass creatorAndAdder;\n\n    /**\n     * The agent of the top level horizontal group.\n     */\n    private TopSequentialGroupAgent horizontalLayoutAgent;\n\n    /**\n     * The agent of the top level vertical group.\n     */\n    private TopSequentialGroupAgent verticalLayoutAgent;\n\n    /**\n     * Whether all vertical parallel groups\n     * containing JTextFields but not containing other groups\n     * should automatically have baseline alignment.\n     */\n    private boolean autoBaselineAlignment \u003d false;\n\n    /**\n     * @param container\tthe container that needs to be laid out\n     * @param lines\t\ta sequence of lines representing the scheme\n     */\n    public GroupLayoutEngineer(Container container, String... lines) {\n        scheme \u003d new Scheme(lines);\n        namesToComponents \u003d new NamesToComponents();\n        namesToGapAgents \u003d new NamesToGapAgents();\n        horizontalLayoutAgent \u003d compouseTopSequentialGroup(Axis.HORIZONTAL);\n        verticalLayoutAgent \u003d compouseTopSequentialGroup(Axis.VERTICAL);\n        horizontalLayoutAgent.removeGapsFromParallelGroups();\n        verticalLayoutAgent.removeGapsFromParallelGroups();\n        gl \u003d new GroupLayout(container);\n        container.setLayout(gl);\n        //\t\tsetAutoCreateGaps(true);\n        //\t\tsetAutoCreateContainerGaps(true);\n    }\n\n    /**\n     * Returns a top sequential group agent for the specified layout direction.\n     * \u003cp\u003e\n     * A group will be created even if it would contain a single element.\n     *\n     * @param axis\tthe layout direction\n     *\n     * @return\t\tthe agent of the new sequential group\n     */\n    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis) {\n        Block topBlock;\n        if (axis \u003d\u003d Axis.HORIZONTAL)\n            topBlock \u003d new HorizontalBlock(scheme);\n        else\n            //VERTICAL\n            topBlock \u003d new VerticalBlock(scheme);\n        topBlock.optimize();\n        if (topBlock.isTrivial())\n            throw new IllegalArgumentException(\"the scheme does not possess components\u0027 names\");\n        TopSequentialGroupAgent result \u003d new TopSequentialGroupAgent();\n        List\u003cBlock\u003e blocksList \u003d topBlock.extractSequentialSubblocks();\n        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));\n        return result;\n    }\n\n    /**\n     * Returns a new sequential group agent filled with\n     * the agents of the specified block content.\n     *\n     * @param block\tthe block which content should be placed\n     * \t\t\t\tinto a sequential group.\n     *\n     * @return\t\tthe agent of the new sequential group.\n     */\n    protected Agent compouseSequentialGroupFromBlock(Block block) {\n        block.optimize();\n        if (block.isTrivial())\n            return null;\n        List\u003cBlock\u003e blocksList \u003d block.extractSequentialSubblocks();\n        if (blocksList.size() \u003d\u003d 1)\n            return processSubblockOfSequentialGroup(block);\n        SequentialGroupAgent result \u003d new SequentialGroupAgent();\n        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));\n        return result;\n    }\n\n    /**\n     * Verifies whether the specified subblock contains a single element\n     * or a set of elements\n     * and either returns the agent of the corresponding element,\n     * or divides the set of elements into a new parallel subgroup\n     * and returns the corresponding agent.\n     *\n     * @param subblock\ta block in a sequential group.\n     *\n     * @return\t\t\tthe agent of the specified subblock content.\n     */\n    private Agent processSubblockOfSequentialGroup(Block subblock) {\n        if (subblock.containsOnlyOneWord())\n            return getElementFromBlockWithOnlyWord(subblock);\n        else\n            return composeParallelGroupFromBlock(subblock);\n    }\n\n    /**\n     * Returns the agent of the unique element (a component or a gap)\n     * in the specified block which is added into a sequential group.\n     *\n     * @param block\ta block with an only element in a parallel group.\n     *\n     * @return\t\tthe agent of the unique element in the specified block.\n     */\n    private Agent getElementFromBlockWithOnlyWord(Block block) {\n        String word \u003d block.textAt(block.firstWord_Horizontally());\n        if (word.charAt(0) \u003d\u003d \u0027.\u0027)\n            return new TemporaryGapAgent(word);\n        return new ComponentAgent(word);\n    }\n\n    /**\n     * Returns a new parallel group agent filled with\n     * the agents of the specified block content.\n     *\n     * @param block\tthe block which content should be placed\n     * \t\t\t\tinto a sequential group.\n     *\n     * @return\t\tthe agent of the new parallel group.\n     */\n    protected Agent composeParallelGroupFromBlock(Block block) {\n        block.optimize();\n        if (block.isTrivial())\n            return null;\n        List\u003cBlock\u003e blocksList \u003d block.extractParallelSubblocks();\n        if (blocksList.size() \u003d\u003d 1)\n            return processSubblockOfParallelGroup(block);\n        ParallelGroupAgent result \u003d new ParallelGroupAgent();\n        Agent agent;\n        for (Block subBlock : blocksList) {\n            agent \u003d processSubblockOfParallelGroup(subBlock);\n            if (agent !\u003d null)\n                result.addAgent(agent);\n        }\n        return result;\n    }\n\n    /**\n     * Verifies whether the specified subblock contains a single element\n     * or a set of elements\n     * and then either returns the agent of the corresponding element,\n     * or divides the set of elements into a new sequential subgroup\n     * and returns the corresponding agent.\n     * \u003cp\u003e\n     * If there is a unique element and it is a gap,\n     *\n     * @param subblock\ta block in a parallel group.\n     *\n     * @return\tthe agent of the specified subblock content.\n     */\n    private Agent processSubblockOfParallelGroup(Block subblock) {\n        if (subblock.containsOnlyOneWord())\n            return getElementFromBlockWithOnlyWord(subblock);\n        else\n            return compouseSequentialGroupFromBlock(subblock);\n    }\n\n    /**\n     * Associates the specified {@code name} on the scheme\n     * with the specified {@code component}.\n     *\n     * @param name\t\tthe component name present on the scheme.\n     * @param component\tthe component to be associated with the name.\n     */\n    public void associate(String name, Component component) {\n        namesToComponents.put(name, component);\n    }\n\n    /**\n     * Associates the specified {@code denotation} on the scheme\n     * with gaps of the specified {@code size}.\n     */\n    public void associateGap(String denotation, int size) {\n        namesToGapAgents.put(denotation, new GapAgent(size));\n    }\n\n    /**\n     * Associates the specified {@code denotation} on the scheme with gaps\n     * of the specified {@code min}, {@code pref}, and {@code max} sizes.\n     */\n    public void associateGap(String denotation, int min, int pref, int max) {\n        namesToGapAgents.put(denotation, new GapAgent(min, pref, max));\n    }\n\n    /**\n     * Associates the specified {@code denotation} on the scheme\n     * with preferred gaps\n     * of the specified component placement type (related or unrelated).\n     */\n    public void associateGap(String denotation, ComponentPlacement type) {\n        namesToGapAgents.put(denotation, new PreferredGapAgent(type));\n    }\n\n    /**\n     * Associates the specified {@code denotation} on the scheme\n     * with preferred gaps\n     * of the specified component placement type (related or unrelated)\n     * and of the specified preferred and maximum sizes.\n     */\n    public void associateGap(String denotation, ComponentPlacement type, int pref, int max) {\n        namesToGapAgents.put(denotation, new PreferredGapAgent(type, pref, max));\n    }\n\n    /**\n     * Sets whether a gap between components should automatically be\n     * created. For example, if this is {@code true} and you add two\n     * components to a {@code SequentialGroup} a gap between the\n     * two components is automatically be created.\n     *\n     * @param autoCreatePadding\twhether a gap between components is\n     *        \t\t\t\t\tautomatically created.\n     */\n    public void setAutoCreateGaps(boolean autoCreatePadding) {\n        gl.setAutoCreateGaps(autoCreatePadding);\n    }\n\n    /**\n     * Sets whether a gap between the container and components that touch\n     * the border of the container should automatically be created.\n     *\n     * @param autoCreateContainerGaps\twhether a gap between the container\n     * \t\t\t\t\t\t\t\t\tand components that touch the border\n     * \t\t\t\t\t\t\t\t\tof the container should automatically\n     * \t\t\t\t\t\t\t\t\tbe created.\n     */\n    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps) {\n        gl.setAutoCreateContainerGaps(autoCreateContainerGaps);\n    }\n\n    /**\n     * Sets whether all vertical parallel groups\n     * containing JTextFields but not containing other groups\n     * should automatically have baseline alignment.\n     */\n    public void setAutoAlignJTextFields(boolean autoBaselineAlignment) {\n        this.autoBaselineAlignment \u003d autoBaselineAlignment;\n    }\n\n    /**\n     * Forces the specified components to have the same size\n     * regardless of their preferred, minimum or maximum sizes.\n     * Components that are linked are given the maximum\n     * of the preferred size of each of the linked components.\n     *\n     * @param names\tthe names of the components\tthat are\n     * \t\t\t\tto have the same size.\n     */\n    public void linkSize(String... names) {\n        Component[] components \u003d namesToComponents.getComponents(names);\n        gl.linkSize(components);\n    }\n\n    /**\n     * Forces the specified components to have the same size\n     * along the specified axis regardless of their\n     * preferred, minimum or maximum sizes.\n     * Components that are linked are given the maximum\n     * of the preferred size of each of the linked components.\n     *\n     * @param axis\tthe axis to link the size along.\n     * @param names\tthe names of the components\tthat are\n     * \t\t\t\tto have the same size.\n     */\n    public void linkSize(Axis axis, String... names) {\n        Component[] components \u003d namesToComponents.getComponents(names);\n        if (axis \u003d\u003d Axis.HORIZONTAL)\n            gl.linkSize(SwingConstants.HORIZONTAL, components);\n        else\n            //axis\u003d\u003dAxis.VERTICAL\n            gl.linkSize(SwingConstants.VERTICAL, components);\n    }\n\n    /**\n     * Disables the components under the specified names.\n     * \u003cp\u003e\n     * Each component must be associated with its name\n     * before this method is applied.\n     */\n    public void disable(String... componentsNames) {\n        for (Component c : namesToComponents.getComponents(componentsNames)) c.setEnabled(false);\n    }\n\n    /**\n     * Finds the agent of the component with the specified name\n     * and returns an interface for adjusting that component.\n     *\n     * @param axis\t\t\tlayout direction\n     * @param componentName\tthe name of the component to be found\n     * @return\t\t\t\tan interface {@code FunctionsOnComponent}\n     * \t\t\t\t\t\tfor adjusting the component\n     */\n    public FunctionsOnComponent getComponent(Axis axis, String componentName) {\n        Agent agent \u003d getAgent(axis, componentName);\n        if (agent \u003d\u003d null)\n            throw new IllegalArgumentException(\"no such component found: \" + componentName);\n        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();\n    }\n\n    /**\n     * Finds the agent of the group which first and last components\n     * have the specified names;\n     * returns an interface for adjusting that group and adding gaps into it.\n     *\n     * @param axis\t\tlayout direction\n     * @param firstName\tthe name of the first component in the group\n     * @param lastName\tthe name of the last component in the group\n     * @return\t\t\tan interface {@code FunctionsOnGroup}\n     * \t\t\t\t\tfor adjusting that group and adding gaps into it\n     */\n    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {\n        Agent agent \u003d getGroupAgent(axis, firstName, lastName);\n        if (agent \u003d\u003d null || !(agent instanceof GroupAgent))\n            throw new IllegalArgumentException(\"no such group found: \u003c\" + firstName + \",\" + lastName + \"\u003e\");\n        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();\n    }\n\n    /**\n     * Finds the agent of the parallel group which first and last components\n     * have the specified names;\n     * returns an interface for adjusting that group and adding gaps into it.\n     *\n     * @param axis\t\tlayout direction\n     * @param firstName\tthe name of the first component in the group\n     * @param lastName\tthe name of the last component in the group\n     * @return\t\t\tan interface {@code FunctionsOnParallelGroup}\n     * \t\t\t\t\tfor adjusting that group and adding gaps into it\n     */\n    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {\n        Agent agent \u003d getParallelGroupAgent(axis, firstName, lastName);\n        if (agent \u003d\u003d null)\n            throw new IllegalArgumentException(\"no such parallel group found: \u003c\" + firstName + \",\" + lastName + \"\u003e\");\n        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();\n    }\n\n    /**\n     * Finds the agent of the sequential group which first and last components\n     * have the specified names;\n     * returns an interface for adjusting that group and adding gaps into it.\n     *\n     * @param axis\t\tlayout direction\n     * @param firstName\tthe name of the first component in the group\n     * @param lastName\tthe name of the last component in the group\n     * @return\t\t\tan interface {@code FunctionsOnSequentialGroup}\n     * \t\t\t\t\tfor adjusting that group and adding gaps into it\n     */\n    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {\n        Agent agent \u003d getSequentialGroupAgent(axis, firstName, lastName);\n        if (agent \u003d\u003d null)\n            throw new IllegalArgumentException(\"No such sequential group found: \u003c\" + firstName + \",\" + lastName + \"\u003e.\");\n        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();\n    }\n\n    /**\n     * Returns the agent of the top level sequential group\n     * under the specified layout direction.\n     *\n     * @param axis\tlayout direction\n     * @return\t\tthe agent of the top level sequential group\n     * \t\t\t\tunder the specified layout direction\n     */\n    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {\n        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();\n    }\n\n    /**\n     * Returns the agent of the component with the specified name\n     * under the specified layout direction.\n     *\n     * @param axis\tlayout direction\n     * @param name\tthe name of the component to be found\n     * @return\t\tthe corresponding agent\n     */\n    private Agent getAgent(Axis axis, String name) {\n        return getTopAgent(axis).findDependingComponentByName(name);\n    }\n\n    /**\n     * Returns the agent of the group with the specified first and last names\n     * under the specified layout direction.\n     *\n     * @param axis\t\tlayout direction\n     * @param firstName\tthe name of the first component in the group\n     * @param lastName\tthe name of the last component in the group\n     * @return\t\t\tthe agent of the corresponding group\n     */\n    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName) {\n        return getTopAgent(axis).findDependingGroupByNames(firstName, lastName);\n    }\n\n    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName) {\n        return getTopAgent(axis).findDependingSequentialGroupByNames(firstName, lastName);\n    }\n\n    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName) {\n        return getTopAgent(axis).findDependingParallelGroupByNames(firstName, lastName);\n    }\n\n    /**\n     * Returns (a reference to) the top agent\n     * for the specified layout direction.\n     *\n     * @param axis\tlayout direction\n     * @return\t\tthe corresponding top agent\n     */\n    private TopSequentialGroupAgent getTopAgent(Axis axis) {\n        return axis \u003d\u003d Axis.HORIZONTAL ? horizontalLayoutAgent : verticalLayoutAgent;\n    }\n\n    /**\n     * Places the components into the container\n     * according to the scheme and to all additional preferences.\n     */\n    public void engineer() {\n        horizontalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);\n        verticalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);\n        if (autoBaselineAlignment)\n            makeTextFieldsBaselineIn(verticalLayoutAgent);\n        creatorAndAdder \u003d new GroupCreatorAndElementAdderClass();\n        gl.setHorizontalGroup(horizontalLayoutAgent.groupContent(creatorAndAdder));\n        gl.setVerticalGroup(verticalLayoutAgent.groupContent(creatorAndAdder));\n    }\n\n    /**\n     * If the specified group is parallel,\n     * contains directly a component of type {@code JTextField},\n     * and does not contain other groups with components,\n     * then this method makes the alignment of the group {@code Baseline}.\n     * \u003cp\u003e\n     * In the case of a group having subgroups with components\n     * this method passes the call to that subgroups.\n     * \u003cp\u003e\n     * As a result of applying this method,\n     * all parallel groups having TextFields (but having no subgroups)\n     * will be aligned along baselines.\n     */\n    private void makeTextFieldsBaselineIn(GroupAgent group) {\n        boolean containsGroups \u003d false;\n        //the group must be baseline aligned\n        boolean containsTextfields \u003d false;\n        boolean isParallel \u003d group instanceof ParallelGroupAgent;\n        for (Agent child : group.getChildren()) {\n            if (child instanceof GroupAgent \u0026\u0026 ((GroupAgent) child).getFirstName() !\u003d null) {\n                //child is a group with components.\n                makeTextFieldsBaselineIn((GroupAgent) child);\n                containsGroups \u003d true;\n            } else if (child instanceof ComponentAgent \u0026\u0026 isParallel \u0026\u0026 !containsGroups) {\n                ComponentAgent agent \u003d (ComponentAgent) child;\n                Component comp \u003d namesToComponents.compMap.get(agent.getFirstName());\n                if (comp instanceof JTextField)\n                    containsTextfields \u003d true;\n            }\n        }\n        if (containsTextfields) {\n            ParallelGroupSettings settings \u003d ((ParallelGroupAgent) group).getSettings();\n            if (settings.contentAlignment \u003d\u003d null)\n                settings.contentAlignment \u003d Alignment.BASELINE;\n        }\n    }\n\n    /**\n     * Outputs the groups hierarchy.\n     */\n    public void printGroupStructure() {\n        new GroupPrinter().printTopGroupsStructure();\n    }\n\n    /**\n     * Encapsulates the \"names of components - to - components\" mapping\n     * and the corresponding methods of access and modification.\n     */\n    private class NamesToComponents {\n\n        /**\n         * Holds the association between the names of the components on\n         * the scheme and the corresponding components.\n         */\n        private HashMap\u003cString, Component\u003e compMap \u003d new HashMap\u003cString, Component\u003e();\n\n        public NamesToComponents() {\n        }\n\n        @SuppressWarnings(\"unused\")\n        public boolean contains(String name) {\n            return compMap.containsKey(name);\n        }\n\n        @SuppressWarnings(\"unused\")\n        public boolean contains(Component component) {\n            return compMap.containsValue(component);\n        }\n\n        public void put(String name, Component component) {\n            if (name \u003d\u003d null || component \u003d\u003d null || !scheme.containsComponentName(name) || compMap.put(name, component) !\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate a component\" + \" with the name \\\"\" + name + \"\\\"\");\n        }\n\n        /**\n         * Returns the component associated with the specified name.\n         *\n         * @param name\tthe name of the component to return\n         *\n         * @return\t\tthe component associated with the specified name\n         */\n        public Component getComponent(String name) {\n            if (name \u003d\u003d null)\n                throw new IllegalArgumentException(\"No name specified\");\n            Component result \u003d compMap.get(name);\n            if (result \u003d\u003d null)\n                throw new IllegalArgumentException(\"cannot find a component\" + \" with the specified name \\\"\" + name + \"\\\"\");\n            return result;\n        }\n\n        /**\n         * Returns the components associated with the specified names.\n         *\n         * @param names\tthe names of the components to return\n         *\n         * @return\t\tthe components associated with the specified names\n         */\n        public Component[] getComponents(String... names) {\n            int l \u003d names.length;\n            Component[] components \u003d new Component[l];\n            for (int i \u003d 0; i \u003c l; i++) components[i] \u003d getComponent(names[i]);\n            return components;\n        }\n    }\n\n    /**\n     * Declares the method of possessing the gap agent\n     * by a temporary gap agent.\n     */\n    public interface TemporaryGapsToGaps {\n\n        /**\n         * Returns the gap agent associated with the specified\n         * temporary gap agent.\n         */\n        public Agent gap(TemporaryGapAgent temp);\n    }\n\n    /**\n     * Encapsulates the \"names of the gaps - to - agents of these gaps\" mapping\n     * and the corresponding methods of access and modification.\n     */\n    private class NamesToGapAgents implements TemporaryGapsToGaps {\n\n        /**\n         * Holds the association between the gaps denotations\n         * on the scheme and the corresponding gap types.\n         * \u003cp\u003e\n         * The gaps (which can be preferred or simple) are represented\n         * by instances of {@code Agent}, which is a superclass\n         * for both {@code PreferredGapAgent} and {@code GapAgent}.\n         */\n        private HashMap\u003cString, Agent\u003e gapMap \u003d new HashMap\u003cString, Agent\u003e();\n\n        public NamesToGapAgents() {\n            safePut(\".\", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));\n            safePut(\"..\", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));\n        }\n\n        public void put(String name, GapAgent agent) {\n            if (name \u003d\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate a gap with a null name.\");\n            if (agent \u003d\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate null agents.\");\n            if (!scheme.containsGapName(name))\n                return;\n            /*throw new IllegalArgumentException(\n\t\t\t\t\t\"The gap name \" + name + \" not found on the scheme.\");*/\n            safePut(name, agent);\n        }\n\n        protected void safePut(String name, GapAgent agent) {\n            gapMap.put(name, agent);\n        }\n\n        public void put(String name, PreferredGapAgent agent) {\n            if (name \u003d\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate a gap with a null name.\");\n            if (agent \u003d\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate null agents.\");\n            if (!scheme.containsGapName(name))\n                return;\n            /*throw new IllegalArgumentException(\n\t\t\t\t\t\"The gap name \" + name + \" not found on the scheme.\");*/\n            safePut(name, agent);\n        }\n\n        protected void safePut(String name, PreferredGapAgent agent) {\n            gapMap.put(name, agent);\n        }\n\n        /**\n         * Returns the gap agent associated with the specified name.\n         */\n        public Agent gap(String name) {\n            if (name \u003d\u003d null)\n                throw new IllegalArgumentException(\"No name specified\");\n            Agent result \u003d gapMap.get(name);\n            if (result \u003d\u003d null)\n                throw new IllegalArgumentException(\"cannot find a gap denoted by \\\"\" + name + \"\\\"\");\n            return result;\n        }\n\n        /**\n         * Returns the gap agent associated with the specified\n         * temporary gap agent.\n         */\n        public Agent gap(TemporaryGapAgent temp) {\n            return gap(temp.getDenotation());\n        }\n    }\n\n    /**\n     * An adapter for such functions of the {@code GroupLayout}\n     * as creating new groups and adding groups and components to groups.\n     */\n    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {\n\n        /**\n         * Creates and returns a new {@code SequentialGroup}.\n         */\n        public SequentialGroup createSequentialGroup() {\n            return gl.createSequentialGroup();\n        }\n\n        /**\n         * Creates and returns a new {@code ParallelGroup}\n         * with the specified settings.\n         */\n        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {\n            if (settings.contentAlignment !\u003d null)\n                if (settings.resizable !\u003d null)\n                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);\n                else\n                    //(resizable \u003d\u003d null)\n                    return gl.createParallelGroup(settings.contentAlignment);\n            else //(settings.contentAlignment \u003d\u003d null)\n            if (settings.resizable !\u003d null)\n                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);\n            else\n                return gl.createParallelGroup();\n        }\n\n        /**\n         * Adds the component having the specified {@code compName}\n         * to the specified {@code group},\n         * applies to it the specified {@code settings}.\n         */\n        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {\n            if (settings.alignmentWithRespectToParent !\u003d null)\n                //It seems that we must add to a parallel group.\n                if (group instanceof ParallelGroup)\n                    //Really, to a parallel.\n                    if (settings.sizes !\u003d null) {\n                        Sizes sizes \u003d settings.sizes;\n                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);\n                    } else\n                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);\n                else\n                    //Parallel group not found.\n                    throw new IllegalArgumentException(\"components can be aligned in parallel groups only\");\n            else //Alignment not specified.\n            if (settings.sizes !\u003d null) {\n                Sizes sizes \u003d settings.sizes;\n                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);\n            } else\n                //Even sizes aren\u0027t specified.\n                group.addComponent(namesToComponents.getComponent(compName));\n        }\n\n        /**\n         * Adds the specified {@code group} with the specified {@code settings}\n         * to another group {@code parentGroup}.\n         */\n        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {\n            if (settings.alignmentWithRespectToParent !\u003d null)\n                if (parentGroup instanceof ParallelGroup)\n                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);\n                else\n                    throw new IllegalArgumentException(\"content can be aligned in parallel groups only\");\n            parentGroup.addGroup(group);\n        }\n    }\n\n    /**\n     * Provides output of the created groups\u0027 structure.\n     * \u003cp\u003e\n     * Is maintained for debugging purposes.\n     */\n    public class GroupPrinter {\n\n        /**\n         * Outputs the both directions top groups structures.\n         */\n        public void printTopGroupsStructure() {\n            Axis axis;\n            axis \u003d Axis.HORIZONTAL;\n            System.out.println(\"\\nTop \" + axis.toString().toUpperCase() + \" group structure.\");\n            printTopGroupStructure(axis);\n            System.out.println(\"\\n-----------------------------\\n\");\n            axis \u003d Axis.VERTICAL;\n            System.out.println(\"Top \" + axis.toString().toUpperCase() + \" group structure.\");\n            printTopGroupStructure(axis);\n        }\n\n        /**\n         * Outputs the specified direction top group structure.\n         */\n        public void printTopGroupStructure(Axis axis) {\n            printGroupStructure(getTopAgent(axis));\n        }\n\n        /**\n         * Outputs the specified group structure.\n         */\n        public void printGroupStructure(GroupAgent group) {\n            System.out.println();\n            System.out.println(\"Elements of \" + group.toString() + \":\");\n            List\u003cAgent\u003e childrenAgents \u003d group.getChildren();\n            for (Agent child : childrenAgents) System.out.println(child.toString());\n            for (Agent child : childrenAgents) if (child instanceof GroupAgent)\n                printGroupStructure((GroupAgent) child);\n        }\n    }\n}\n",
    "package": "glengineer",
    "classname": "GroupLayoutEngineer",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_3Test.java",
    "test_prompt": "// GroupLayoutEngineer_3Test.java\npackage glengineer;\n\nimport glengineer.agents.*;\nimport glengineer.agents.setters.*;\nimport glengineer.agents.settings.*;\nimport glengineer.blocks.*;\nimport java.util.*;\nimport java.awt.Component;\nimport java.awt.Container;\nimport javax.swing.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GroupLayoutEngineer}.\n* It contains ten unit test cases for the {@link GroupLayoutEngineer#getSequentialGroup(Axis, String, String)} method.\n*/\nclass GroupLayoutEngineer_3Test {",
    "method_signature": "getSequentialGroup(Axis, String, String)",
    "suffix": "3"
  },
  {
    "numberTests": "ten",
    "original_code": "// GroupLayoutEngineer.java\npackage glengineer;\n\nimport glengineer.agents.*;\nimport glengineer.agents.setters.*;\nimport glengineer.agents.settings.*;\nimport glengineer.blocks.*;\nimport java.util.*;\nimport java.awt.Component;\nimport java.awt.Container;\nimport javax.swing.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\n\n/**\n * {@code GroupLayoutEngineer} is a shell for the layout manager\n * {@code GroupLayout}. It allows to control components\u0027 placement\n * using simple 2-dimensional textual schemes.\n * \u003cp\u003e\n * Such approach to GUI creation removes the problem\n * of representing a 2-dimensional GUI by 1-dimensional code.\n *\n * \u003ch3\u003eHow to use the {@code GroupLayoutEngineer}\u003c/h3\u003e\n *\n * \u003col\u003e\n * \u003cli\u003e Create an instance of the {@code GroupLayoutEngineer}.\n * The first parameter of the constructor is a reference to the container,\n * and the rest are the lines of the textual scheme. For example:\n * \u003cpre\u003e\n * GroupLayoutEngineer gle \u003d new GroupLayoutEngineer(\n *    getContentPane(),\n * \t\"FINDLABEL  TEXTFIELD      FINDBUTTON  \",\n * \t\"          --------------+             \",\n * \t\"           CB11   CB12  | CANSELBUTTON\",\n * \t\"                        |             \",\n * \t\"           CB21   CB22  |             \");\n * \u003c/pre\u003e\n *\n * \u003cli\u003e Associate the names on the scheme with concrete components, for example:\n * \u003cpre\u003e\n * gle.associate(\"FINDLABEL\", new JLabel(\"Find What:\"));\n * gle.associate(\"TEXTFIELD\", new JTextField());\n * gle.associate(\"FINDBUTTON\", new JButton(\"Find\"));\n * gle.associate(\"CB11\", new JCheckBox(\"Match Case\"));\n * gle.associate(\"CB12\", new JCheckBox(\"Wrap Around\"));\n * gle.associate(\"CB21\", new JCheckBox(\"Whole Words\"));\n * gle.associate(\"CB22\", new JCheckBox(\"Search Backwards\"));\n * gle.associate(\"CANSELBUTTON\", new JButton(\"Cancel\"));\n * \u003c/pre\u003e\n *\n * \u003cli\u003e Apply optional preferences (such as special alignment), for example:\n * \u003cpre\u003e\n * gle.linkSize(\"FINDBUTTON\", \"CANSELBUTTON\");\n *\n * gle.getParallelGroup(Axis.VERTICAL, \"FINDLABEL\",\"FINDBUTTON\")\n * \t.setContentAlignment(Alignment.BASELINE);\n *\n * gle.setAutoCreateGaps(true);\n * gle.setAutoCreateContainerGaps(true);\n * \u003c/pre\u003e\n * Note that the alignment in the group above\n * could also be automatically set to {@code Baseline}\n * by calling the method {@code setAutoAlignJTextFields()}.\n * \u003cp\u003e\u003cbr\u003e\n *\n * \u003cli\u003e Invoke the method\n * \u003cpre\u003e\n * gle.engineer();\n * \u003c/pre\u003e\n * \u003c/ol\u003e\n *\n * \u003ch3\u003eHow to control gaps\u003c/h3\u003e\n *\n * If you wish to control the gaps yourself instead of relying\n * on automatic gaps creation, you will have two choices.\n * \u003cp\u003e\n * We recommend to deal with gaps like with components, i.e.,\n * to place the required gaps at the scheme\n * and then to associate them with concrete parameters (types and lengthes),\n * for example:\n * \u003cpre\u003e\n * GroupLayoutEngineer gle \u003d new GroupLayoutEngineer(\n *    getContentPane(),\n * \t\"FINDLABEL .. TEXTFIELD      . FINDBUTTON  \",\n * \t\"            --------------+       .       \",\n * \t\"             CB11 .g CB12 |   CANSELBUTTON\",\n * \t\"               .          |               \",\n * \t\"             CB21    CB22 |               \");\n *\n * gle.associateGap(\".\", ComponentPlacement.RELATED);\n * gle.associateGap(\"..\", ComponentPlacement.UNRELATED);\n * gle.associateGap(\".g1\", 20);\n * \u003c/pre\u003e\n *\n * Note that each gap on the scheme must be started from a dot\n * (in order to make it looking different from components).\n * \u003cp\u003e\n * Also note that any gap (associated with the required parameters)\n * may appear on the scheme any number of times,\n * unlike the components, which appear on the scheme only once.\n * \u003cp\u003e\n * Note that you may skip the associations of the denotations \".\" and \"..\"\n * with related and unrelated gaps respectively,\n * because these associations are always applied by default.\n *\n * \u003cp\u003e\u003cbr\u003e\n * Alternatively, you may add gaps to the layout\n * without making additional changes to the scheme.\n * This approach requires specifying concrete sequential or parallel groups\n * and their concrete elements near which a gap should be added, for example:\n * \u003cpre\u003e\n * gle.getSequentialGroup(Axis.HORIZONTAL, \"CB11\", \"CB22\")\n *   .getGroup(\"CB12\",\"CB22\")\n *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);\n * \u003c/pre\u003e\n * We do not recommend to use the letter approach because it minimizes\n * the advantages of the group layout engineer.\n *\n * \u003ch3\u003eHow to draw schemes\u003c/h3\u003e\n *\n * In order to avoid formal introduction to this topic,\n * we refer to the examples in the package {@code glengineer.demos}\n * for general introduction to the schemes.\n * \u003cp\u003e\n * Here we mention specific yet essential details only.\n *\n * \u003col\u003e\n * \u003cli\u003e The names of components (and gaps) on the scheme may consist of\n * letters of any case, numbers, and underscores \u0027_\u0027.\n * \u003cli\u003e For each layout direction (horizontal and vertical)\n * the engineer tries to divide every non-trivial block of elements\n * on the scheme into a sequential or a parallel\n * (if the former is not possible) group of elements or subblocks.\n * \u003cli\u003e One may place on the scheme horizontal and vertical lines\n * which consist of symbols \u0027-\u0027 and \u0027|\u0027 respectively\n * (and optionally of symbols \u0027+\u0027 for the intersections).\n * \u003cli\u003e If a block on the scheme is intersected by\n * a (horizontal or vertical) line, then this block will\n * not be divided into a sequential group of that direction.\n * Hence, it will be divided into a parallel group.\n * \u003cli\u003e The lines do not influence the layout in the perpendicular direction\n * (but, certainly, this layout direction is influenced\n * by the space under the line).\n * \u003cli\u003e If a block is divided into a parallel group by a number of lines,\n * it is divided only by those of them which have the maximum length,\n * and the smaller lines (if they exist) are left for the subblocks.\n * \u003cli\u003e Gaps on the scheme affect sequential groups only.\n * \u003cli\u003e If two sequential subblocks are divided by a number of gaps,\n * then these gaps will be replaced by a single gap of that type.\n * \u003cli\u003e Gaps on the scheme may lie AT lines.\n * Such lines are considered as being continued under that gaps,\n * and the gaps affect only the direction perpendicular to the\n * corresponding line.\n * \u003cli\u003e A line may be intersected only by one gap.\n * \u003cli\u003e If a gap touches one of the sides of a line,\n * it is also assumed that they intersect.\n * \u003c/ol\u003e\n *\n * @author Yevgen Ivakhno\n * @version 1.1, 18/05/2009\n */\npublic class GroupLayoutEngineer {\n\n    private Scheme scheme;\n\n    /**\n     * The mapping of the names on the scheme to the associated components.\n     */\n    private NamesToComponents namesToComponents;\n\n    private NamesToGapAgents namesToGapAgents;\n\n    /**\n     * The layout manager {@code GroupLayout} under control.\n     */\n    private GroupLayout gl;\n\n    /**\n     * The object which can create sequential and parallel\n     * {@code GroupLayout} groups and add components to groups\n     * using the components\u0027 names.\n     * \u003cp\u003e\n     * A reference to this object is given to the agents of elements.\n     *\n     * @see glengineer.agents\n     */\n    private GroupCreatorAndElementAdderClass creatorAndAdder;\n\n    /**\n     * The agent of the top level horizontal group.\n     */\n    private TopSequentialGroupAgent horizontalLayoutAgent;\n\n    /**\n     * The agent of the top level vertical group.\n     */\n    private TopSequentialGroupAgent verticalLayoutAgent;\n\n    /**\n     * Whether all vertical parallel groups\n     * containing JTextFields but not containing other groups\n     * should automatically have baseline alignment.\n     */\n    private boolean autoBaselineAlignment \u003d false;\n\n    /**\n     * @param container\tthe container that needs to be laid out\n     * @param lines\t\ta sequence of lines representing the scheme\n     */\n    public GroupLayoutEngineer(Container container, String... lines) {\n        scheme \u003d new Scheme(lines);\n        namesToComponents \u003d new NamesToComponents();\n        namesToGapAgents \u003d new NamesToGapAgents();\n        horizontalLayoutAgent \u003d compouseTopSequentialGroup(Axis.HORIZONTAL);\n        verticalLayoutAgent \u003d compouseTopSequentialGroup(Axis.VERTICAL);\n        horizontalLayoutAgent.removeGapsFromParallelGroups();\n        verticalLayoutAgent.removeGapsFromParallelGroups();\n        gl \u003d new GroupLayout(container);\n        container.setLayout(gl);\n        //\t\tsetAutoCreateGaps(true);\n        //\t\tsetAutoCreateContainerGaps(true);\n    }\n\n    /**\n     * Returns a top sequential group agent for the specified layout direction.\n     * \u003cp\u003e\n     * A group will be created even if it would contain a single element.\n     *\n     * @param axis\tthe layout direction\n     *\n     * @return\t\tthe agent of the new sequential group\n     */\n    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis) {\n        Block topBlock;\n        if (axis \u003d\u003d Axis.HORIZONTAL)\n            topBlock \u003d new HorizontalBlock(scheme);\n        else\n            //VERTICAL\n            topBlock \u003d new VerticalBlock(scheme);\n        topBlock.optimize();\n        if (topBlock.isTrivial())\n            throw new IllegalArgumentException(\"the scheme does not possess components\u0027 names\");\n        TopSequentialGroupAgent result \u003d new TopSequentialGroupAgent();\n        List\u003cBlock\u003e blocksList \u003d topBlock.extractSequentialSubblocks();\n        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));\n        return result;\n    }\n\n    /**\n     * Returns a new sequential group agent filled with\n     * the agents of the specified block content.\n     *\n     * @param block\tthe block which content should be placed\n     * \t\t\t\tinto a sequential group.\n     *\n     * @return\t\tthe agent of the new sequential group.\n     */\n    protected Agent compouseSequentialGroupFromBlock(Block block) {\n        block.optimize();\n        if (block.isTrivial())\n            return null;\n        List\u003cBlock\u003e blocksList \u003d block.extractSequentialSubblocks();\n        if (blocksList.size() \u003d\u003d 1)\n            return processSubblockOfSequentialGroup(block);\n        SequentialGroupAgent result \u003d new SequentialGroupAgent();\n        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));\n        return result;\n    }\n\n    /**\n     * Verifies whether the specified subblock contains a single element\n     * or a set of elements\n     * and either returns the agent of the corresponding element,\n     * or divides the set of elements into a new parallel subgroup\n     * and returns the corresponding agent.\n     *\n     * @param subblock\ta block in a sequential group.\n     *\n     * @return\t\t\tthe agent of the specified subblock content.\n     */\n    private Agent processSubblockOfSequentialGroup(Block subblock) {\n        if (subblock.containsOnlyOneWord())\n            return getElementFromBlockWithOnlyWord(subblock);\n        else\n            return composeParallelGroupFromBlock(subblock);\n    }\n\n    /**\n     * Returns the agent of the unique element (a component or a gap)\n     * in the specified block which is added into a sequential group.\n     *\n     * @param block\ta block with an only element in a parallel group.\n     *\n     * @return\t\tthe agent of the unique element in the specified block.\n     */\n    private Agent getElementFromBlockWithOnlyWord(Block block) {\n        String word \u003d block.textAt(block.firstWord_Horizontally());\n        if (word.charAt(0) \u003d\u003d \u0027.\u0027)\n            return new TemporaryGapAgent(word);\n        return new ComponentAgent(word);\n    }\n\n    /**\n     * Returns a new parallel group agent filled with\n     * the agents of the specified block content.\n     *\n     * @param block\tthe block which content should be placed\n     * \t\t\t\tinto a sequential group.\n     *\n     * @return\t\tthe agent of the new parallel group.\n     */\n    protected Agent composeParallelGroupFromBlock(Block block) {\n        block.optimize();\n        if (block.isTrivial())\n            return null;\n        List\u003cBlock\u003e blocksList \u003d block.extractParallelSubblocks();\n        if (blocksList.size() \u003d\u003d 1)\n            return processSubblockOfParallelGroup(block);\n        ParallelGroupAgent result \u003d new ParallelGroupAgent();\n        Agent agent;\n        for (Block subBlock : blocksList) {\n            agent \u003d processSubblockOfParallelGroup(subBlock);\n            if (agent !\u003d null)\n                result.addAgent(agent);\n        }\n        return result;\n    }\n\n    /**\n     * Verifies whether the specified subblock contains a single element\n     * or a set of elements\n     * and then either returns the agent of the corresponding element,\n     * or divides the set of elements into a new sequential subgroup\n     * and returns the corresponding agent.\n     * \u003cp\u003e\n     * If there is a unique element and it is a gap,\n     *\n     * @param subblock\ta block in a parallel group.\n     *\n     * @return\tthe agent of the specified subblock content.\n     */\n    private Agent processSubblockOfParallelGroup(Block subblock) {\n        if (subblock.containsOnlyOneWord())\n            return getElementFromBlockWithOnlyWord(subblock);\n        else\n            return compouseSequentialGroupFromBlock(subblock);\n    }\n\n    /**\n     * Associates the specified {@code name} on the scheme\n     * with the specified {@code component}.\n     *\n     * @param name\t\tthe component name present on the scheme.\n     * @param component\tthe component to be associated with the name.\n     */\n    public void associate(String name, Component component) {\n        namesToComponents.put(name, component);\n    }\n\n    /**\n     * Associates the specified {@code denotation} on the scheme\n     * with gaps of the specified {@code size}.\n     */\n    public void associateGap(String denotation, int size) {\n        namesToGapAgents.put(denotation, new GapAgent(size));\n    }\n\n    /**\n     * Associates the specified {@code denotation} on the scheme with gaps\n     * of the specified {@code min}, {@code pref}, and {@code max} sizes.\n     */\n    public void associateGap(String denotation, int min, int pref, int max) {\n        namesToGapAgents.put(denotation, new GapAgent(min, pref, max));\n    }\n\n    /**\n     * Associates the specified {@code denotation} on the scheme\n     * with preferred gaps\n     * of the specified component placement type (related or unrelated).\n     */\n    public void associateGap(String denotation, ComponentPlacement type) {\n        namesToGapAgents.put(denotation, new PreferredGapAgent(type));\n    }\n\n    /**\n     * Associates the specified {@code denotation} on the scheme\n     * with preferred gaps\n     * of the specified component placement type (related or unrelated)\n     * and of the specified preferred and maximum sizes.\n     */\n    public void associateGap(String denotation, ComponentPlacement type, int pref, int max) {\n        namesToGapAgents.put(denotation, new PreferredGapAgent(type, pref, max));\n    }\n\n    /**\n     * Sets whether a gap between components should automatically be\n     * created. For example, if this is {@code true} and you add two\n     * components to a {@code SequentialGroup} a gap between the\n     * two components is automatically be created.\n     *\n     * @param autoCreatePadding\twhether a gap between components is\n     *        \t\t\t\t\tautomatically created.\n     */\n    public void setAutoCreateGaps(boolean autoCreatePadding) {\n        gl.setAutoCreateGaps(autoCreatePadding);\n    }\n\n    /**\n     * Sets whether a gap between the container and components that touch\n     * the border of the container should automatically be created.\n     *\n     * @param autoCreateContainerGaps\twhether a gap between the container\n     * \t\t\t\t\t\t\t\t\tand components that touch the border\n     * \t\t\t\t\t\t\t\t\tof the container should automatically\n     * \t\t\t\t\t\t\t\t\tbe created.\n     */\n    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps) {\n        gl.setAutoCreateContainerGaps(autoCreateContainerGaps);\n    }\n\n    /**\n     * Sets whether all vertical parallel groups\n     * containing JTextFields but not containing other groups\n     * should automatically have baseline alignment.\n     */\n    public void setAutoAlignJTextFields(boolean autoBaselineAlignment) {\n        this.autoBaselineAlignment \u003d autoBaselineAlignment;\n    }\n\n    /**\n     * Forces the specified components to have the same size\n     * regardless of their preferred, minimum or maximum sizes.\n     * Components that are linked are given the maximum\n     * of the preferred size of each of the linked components.\n     *\n     * @param names\tthe names of the components\tthat are\n     * \t\t\t\tto have the same size.\n     */\n    public void linkSize(String... names) {\n        Component[] components \u003d namesToComponents.getComponents(names);\n        gl.linkSize(components);\n    }\n\n    /**\n     * Forces the specified components to have the same size\n     * along the specified axis regardless of their\n     * preferred, minimum or maximum sizes.\n     * Components that are linked are given the maximum\n     * of the preferred size of each of the linked components.\n     *\n     * @param axis\tthe axis to link the size along.\n     * @param names\tthe names of the components\tthat are\n     * \t\t\t\tto have the same size.\n     */\n    public void linkSize(Axis axis, String... names) {\n        Component[] components \u003d namesToComponents.getComponents(names);\n        if (axis \u003d\u003d Axis.HORIZONTAL)\n            gl.linkSize(SwingConstants.HORIZONTAL, components);\n        else\n            //axis\u003d\u003dAxis.VERTICAL\n            gl.linkSize(SwingConstants.VERTICAL, components);\n    }\n\n    /**\n     * Disables the components under the specified names.\n     * \u003cp\u003e\n     * Each component must be associated with its name\n     * before this method is applied.\n     */\n    public void disable(String... componentsNames) {\n        for (Component c : namesToComponents.getComponents(componentsNames)) c.setEnabled(false);\n    }\n\n    /**\n     * Finds the agent of the component with the specified name\n     * and returns an interface for adjusting that component.\n     *\n     * @param axis\t\t\tlayout direction\n     * @param componentName\tthe name of the component to be found\n     * @return\t\t\t\tan interface {@code FunctionsOnComponent}\n     * \t\t\t\t\t\tfor adjusting the component\n     */\n    public FunctionsOnComponent getComponent(Axis axis, String componentName) {\n        Agent agent \u003d getAgent(axis, componentName);\n        if (agent \u003d\u003d null)\n            throw new IllegalArgumentException(\"no such component found: \" + componentName);\n        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();\n    }\n\n    /**\n     * Finds the agent of the group which first and last components\n     * have the specified names;\n     * returns an interface for adjusting that group and adding gaps into it.\n     *\n     * @param axis\t\tlayout direction\n     * @param firstName\tthe name of the first component in the group\n     * @param lastName\tthe name of the last component in the group\n     * @return\t\t\tan interface {@code FunctionsOnGroup}\n     * \t\t\t\t\tfor adjusting that group and adding gaps into it\n     */\n    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {\n        Agent agent \u003d getGroupAgent(axis, firstName, lastName);\n        if (agent \u003d\u003d null || !(agent instanceof GroupAgent))\n            throw new IllegalArgumentException(\"no such group found: \u003c\" + firstName + \",\" + lastName + \"\u003e\");\n        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();\n    }\n\n    /**\n     * Finds the agent of the parallel group which first and last components\n     * have the specified names;\n     * returns an interface for adjusting that group and adding gaps into it.\n     *\n     * @param axis\t\tlayout direction\n     * @param firstName\tthe name of the first component in the group\n     * @param lastName\tthe name of the last component in the group\n     * @return\t\t\tan interface {@code FunctionsOnParallelGroup}\n     * \t\t\t\t\tfor adjusting that group and adding gaps into it\n     */\n    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {\n        Agent agent \u003d getParallelGroupAgent(axis, firstName, lastName);\n        if (agent \u003d\u003d null)\n            throw new IllegalArgumentException(\"no such parallel group found: \u003c\" + firstName + \",\" + lastName + \"\u003e\");\n        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();\n    }\n\n    /**\n     * Finds the agent of the sequential group which first and last components\n     * have the specified names;\n     * returns an interface for adjusting that group and adding gaps into it.\n     *\n     * @param axis\t\tlayout direction\n     * @param firstName\tthe name of the first component in the group\n     * @param lastName\tthe name of the last component in the group\n     * @return\t\t\tan interface {@code FunctionsOnSequentialGroup}\n     * \t\t\t\t\tfor adjusting that group and adding gaps into it\n     */\n    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {\n        Agent agent \u003d getSequentialGroupAgent(axis, firstName, lastName);\n        if (agent \u003d\u003d null)\n            throw new IllegalArgumentException(\"No such sequential group found: \u003c\" + firstName + \",\" + lastName + \"\u003e.\");\n        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();\n    }\n\n    /**\n     * Returns the agent of the top level sequential group\n     * under the specified layout direction.\n     *\n     * @param axis\tlayout direction\n     * @return\t\tthe agent of the top level sequential group\n     * \t\t\t\tunder the specified layout direction\n     */\n    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {\n        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();\n    }\n\n    /**\n     * Returns the agent of the component with the specified name\n     * under the specified layout direction.\n     *\n     * @param axis\tlayout direction\n     * @param name\tthe name of the component to be found\n     * @return\t\tthe corresponding agent\n     */\n    private Agent getAgent(Axis axis, String name) {\n        return getTopAgent(axis).findDependingComponentByName(name);\n    }\n\n    /**\n     * Returns the agent of the group with the specified first and last names\n     * under the specified layout direction.\n     *\n     * @param axis\t\tlayout direction\n     * @param firstName\tthe name of the first component in the group\n     * @param lastName\tthe name of the last component in the group\n     * @return\t\t\tthe agent of the corresponding group\n     */\n    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName) {\n        return getTopAgent(axis).findDependingGroupByNames(firstName, lastName);\n    }\n\n    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName) {\n        return getTopAgent(axis).findDependingSequentialGroupByNames(firstName, lastName);\n    }\n\n    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName) {\n        return getTopAgent(axis).findDependingParallelGroupByNames(firstName, lastName);\n    }\n\n    /**\n     * Returns (a reference to) the top agent\n     * for the specified layout direction.\n     *\n     * @param axis\tlayout direction\n     * @return\t\tthe corresponding top agent\n     */\n    private TopSequentialGroupAgent getTopAgent(Axis axis) {\n        return axis \u003d\u003d Axis.HORIZONTAL ? horizontalLayoutAgent : verticalLayoutAgent;\n    }\n\n    /**\n     * Places the components into the container\n     * according to the scheme and to all additional preferences.\n     */\n    public void engineer() {\n        horizontalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);\n        verticalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);\n        if (autoBaselineAlignment)\n            makeTextFieldsBaselineIn(verticalLayoutAgent);\n        creatorAndAdder \u003d new GroupCreatorAndElementAdderClass();\n        gl.setHorizontalGroup(horizontalLayoutAgent.groupContent(creatorAndAdder));\n        gl.setVerticalGroup(verticalLayoutAgent.groupContent(creatorAndAdder));\n    }\n\n    /**\n     * If the specified group is parallel,\n     * contains directly a component of type {@code JTextField},\n     * and does not contain other groups with components,\n     * then this method makes the alignment of the group {@code Baseline}.\n     * \u003cp\u003e\n     * In the case of a group having subgroups with components\n     * this method passes the call to that subgroups.\n     * \u003cp\u003e\n     * As a result of applying this method,\n     * all parallel groups having TextFields (but having no subgroups)\n     * will be aligned along baselines.\n     */\n    private void makeTextFieldsBaselineIn(GroupAgent group) {\n        boolean containsGroups \u003d false;\n        //the group must be baseline aligned\n        boolean containsTextfields \u003d false;\n        boolean isParallel \u003d group instanceof ParallelGroupAgent;\n        for (Agent child : group.getChildren()) {\n            if (child instanceof GroupAgent \u0026\u0026 ((GroupAgent) child).getFirstName() !\u003d null) {\n                //child is a group with components.\n                makeTextFieldsBaselineIn((GroupAgent) child);\n                containsGroups \u003d true;\n            } else if (child instanceof ComponentAgent \u0026\u0026 isParallel \u0026\u0026 !containsGroups) {\n                ComponentAgent agent \u003d (ComponentAgent) child;\n                Component comp \u003d namesToComponents.compMap.get(agent.getFirstName());\n                if (comp instanceof JTextField)\n                    containsTextfields \u003d true;\n            }\n        }\n        if (containsTextfields) {\n            ParallelGroupSettings settings \u003d ((ParallelGroupAgent) group).getSettings();\n            if (settings.contentAlignment \u003d\u003d null)\n                settings.contentAlignment \u003d Alignment.BASELINE;\n        }\n    }\n\n    /**\n     * Outputs the groups hierarchy.\n     */\n    public void printGroupStructure() {\n        new GroupPrinter().printTopGroupsStructure();\n    }\n\n    /**\n     * Encapsulates the \"names of components - to - components\" mapping\n     * and the corresponding methods of access and modification.\n     */\n    private class NamesToComponents {\n\n        /**\n         * Holds the association between the names of the components on\n         * the scheme and the corresponding components.\n         */\n        private HashMap\u003cString, Component\u003e compMap \u003d new HashMap\u003cString, Component\u003e();\n\n        public NamesToComponents() {\n        }\n\n        @SuppressWarnings(\"unused\")\n        public boolean contains(String name) {\n            return compMap.containsKey(name);\n        }\n\n        @SuppressWarnings(\"unused\")\n        public boolean contains(Component component) {\n            return compMap.containsValue(component);\n        }\n\n        public void put(String name, Component component) {\n            if (name \u003d\u003d null || component \u003d\u003d null || !scheme.containsComponentName(name) || compMap.put(name, component) !\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate a component\" + \" with the name \\\"\" + name + \"\\\"\");\n        }\n\n        /**\n         * Returns the component associated with the specified name.\n         *\n         * @param name\tthe name of the component to return\n         *\n         * @return\t\tthe component associated with the specified name\n         */\n        public Component getComponent(String name) {\n            if (name \u003d\u003d null)\n                throw new IllegalArgumentException(\"No name specified\");\n            Component result \u003d compMap.get(name);\n            if (result \u003d\u003d null)\n                throw new IllegalArgumentException(\"cannot find a component\" + \" with the specified name \\\"\" + name + \"\\\"\");\n            return result;\n        }\n\n        /**\n         * Returns the components associated with the specified names.\n         *\n         * @param names\tthe names of the components to return\n         *\n         * @return\t\tthe components associated with the specified names\n         */\n        public Component[] getComponents(String... names) {\n            int l \u003d names.length;\n            Component[] components \u003d new Component[l];\n            for (int i \u003d 0; i \u003c l; i++) components[i] \u003d getComponent(names[i]);\n            return components;\n        }\n    }\n\n    /**\n     * Declares the method of possessing the gap agent\n     * by a temporary gap agent.\n     */\n    public interface TemporaryGapsToGaps {\n\n        /**\n         * Returns the gap agent associated with the specified\n         * temporary gap agent.\n         */\n        public Agent gap(TemporaryGapAgent temp);\n    }\n\n    /**\n     * Encapsulates the \"names of the gaps - to - agents of these gaps\" mapping\n     * and the corresponding methods of access and modification.\n     */\n    private class NamesToGapAgents implements TemporaryGapsToGaps {\n\n        /**\n         * Holds the association between the gaps denotations\n         * on the scheme and the corresponding gap types.\n         * \u003cp\u003e\n         * The gaps (which can be preferred or simple) are represented\n         * by instances of {@code Agent}, which is a superclass\n         * for both {@code PreferredGapAgent} and {@code GapAgent}.\n         */\n        private HashMap\u003cString, Agent\u003e gapMap \u003d new HashMap\u003cString, Agent\u003e();\n\n        public NamesToGapAgents() {\n            safePut(\".\", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));\n            safePut(\"..\", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));\n        }\n\n        public void put(String name, GapAgent agent) {\n            if (name \u003d\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate a gap with a null name.\");\n            if (agent \u003d\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate null agents.\");\n            if (!scheme.containsGapName(name))\n                return;\n            /*throw new IllegalArgumentException(\n\t\t\t\t\t\"The gap name \" + name + \" not found on the scheme.\");*/\n            safePut(name, agent);\n        }\n\n        protected void safePut(String name, GapAgent agent) {\n            gapMap.put(name, agent);\n        }\n\n        public void put(String name, PreferredGapAgent agent) {\n            if (name \u003d\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate a gap with a null name.\");\n            if (agent \u003d\u003d null)\n                throw new IllegalArgumentException(\"Cannot associate null agents.\");\n            if (!scheme.containsGapName(name))\n                return;\n            /*throw new IllegalArgumentException(\n\t\t\t\t\t\"The gap name \" + name + \" not found on the scheme.\");*/\n            safePut(name, agent);\n        }\n\n        protected void safePut(String name, PreferredGapAgent agent) {\n            gapMap.put(name, agent);\n        }\n\n        /**\n         * Returns the gap agent associated with the specified name.\n         */\n        public Agent gap(String name) {\n            if (name \u003d\u003d null)\n                throw new IllegalArgumentException(\"No name specified\");\n            Agent result \u003d gapMap.get(name);\n            if (result \u003d\u003d null)\n                throw new IllegalArgumentException(\"cannot find a gap denoted by \\\"\" + name + \"\\\"\");\n            return result;\n        }\n\n        /**\n         * Returns the gap agent associated with the specified\n         * temporary gap agent.\n         */\n        public Agent gap(TemporaryGapAgent temp) {\n            return gap(temp.getDenotation());\n        }\n    }\n\n    /**\n     * An adapter for such functions of the {@code GroupLayout}\n     * as creating new groups and adding groups and components to groups.\n     */\n    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {\n\n        /**\n         * Creates and returns a new {@code SequentialGroup}.\n         */\n        public SequentialGroup createSequentialGroup() {\n            return gl.createSequentialGroup();\n        }\n\n        /**\n         * Creates and returns a new {@code ParallelGroup}\n         * with the specified settings.\n         */\n        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {\n            if (settings.contentAlignment !\u003d null)\n                if (settings.resizable !\u003d null)\n                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);\n                else\n                    //(resizable \u003d\u003d null)\n                    return gl.createParallelGroup(settings.contentAlignment);\n            else //(settings.contentAlignment \u003d\u003d null)\n            if (settings.resizable !\u003d null)\n                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);\n            else\n                return gl.createParallelGroup();\n        }\n\n        /**\n         * Adds the component having the specified {@code compName}\n         * to the specified {@code group},\n         * applies to it the specified {@code settings}.\n         */\n        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {\n            if (settings.alignmentWithRespectToParent !\u003d null)\n                //It seems that we must add to a parallel group.\n                if (group instanceof ParallelGroup)\n                    //Really, to a parallel.\n                    if (settings.sizes !\u003d null) {\n                        Sizes sizes \u003d settings.sizes;\n                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);\n                    } else\n                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);\n                else\n                    //Parallel group not found.\n                    throw new IllegalArgumentException(\"components can be aligned in parallel groups only\");\n            else //Alignment not specified.\n            if (settings.sizes !\u003d null) {\n                Sizes sizes \u003d settings.sizes;\n                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);\n            } else\n                //Even sizes aren\u0027t specified.\n                group.addComponent(namesToComponents.getComponent(compName));\n        }\n\n        /**\n         * Adds the specified {@code group} with the specified {@code settings}\n         * to another group {@code parentGroup}.\n         */\n        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {\n            if (settings.alignmentWithRespectToParent !\u003d null)\n                if (parentGroup instanceof ParallelGroup)\n                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);\n                else\n                    throw new IllegalArgumentException(\"content can be aligned in parallel groups only\");\n            parentGroup.addGroup(group);\n        }\n    }\n\n    /**\n     * Provides output of the created groups\u0027 structure.\n     * \u003cp\u003e\n     * Is maintained for debugging purposes.\n     */\n    public class GroupPrinter {\n\n        /**\n         * Outputs the both directions top groups structures.\n         */\n        public void printTopGroupsStructure() {\n            Axis axis;\n            axis \u003d Axis.HORIZONTAL;\n            System.out.println(\"\\nTop \" + axis.toString().toUpperCase() + \" group structure.\");\n            printTopGroupStructure(axis);\n            System.out.println(\"\\n-----------------------------\\n\");\n            axis \u003d Axis.VERTICAL;\n            System.out.println(\"Top \" + axis.toString().toUpperCase() + \" group structure.\");\n            printTopGroupStructure(axis);\n        }\n\n        /**\n         * Outputs the specified direction top group structure.\n         */\n        public void printTopGroupStructure(Axis axis) {\n            printGroupStructure(getTopAgent(axis));\n        }\n\n        /**\n         * Outputs the specified group structure.\n         */\n        public void printGroupStructure(GroupAgent group) {\n            System.out.println();\n            System.out.println(\"Elements of \" + group.toString() + \":\");\n            List\u003cAgent\u003e childrenAgents \u003d group.getChildren();\n            for (Agent child : childrenAgents) System.out.println(child.toString());\n            for (Agent child : childrenAgents) if (child instanceof GroupAgent)\n                printGroupStructure((GroupAgent) child);\n        }\n    }\n}\n",
    "package": "glengineer",
    "classname": "GroupLayoutEngineer",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_4Test.java",
    "test_prompt": "// GroupLayoutEngineer_4Test.java\npackage glengineer;\n\nimport glengineer.agents.*;\nimport glengineer.agents.setters.*;\nimport glengineer.agents.settings.*;\nimport glengineer.blocks.*;\nimport java.util.*;\nimport java.awt.Component;\nimport java.awt.Container;\nimport javax.swing.*;\nimport javax.swing.GroupLayout.*;\nimport javax.swing.LayoutStyle.ComponentPlacement;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GroupLayoutEngineer}.\n* It contains ten unit test cases for the {@link GroupLayoutEngineer#getTopSequentialGroup(Axis)} method.\n*/\nclass GroupLayoutEngineer_4Test {",
    "method_signature": "getTopSequentialGroup(Axis)",
    "suffix": "4"
  },
  {
    "numberTests": "ten",
    "original_code": "// ParallelGroupAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.setters.FunctionsOnGroup;\r\nimport glengineer.agents.setters.FunctionsOnParallelGroup;\r\nimport glengineer.agents.setters.FunctionsOnParallelGroupAndElement;\r\nimport glengineer.agents.settings.ParallelGroupSettings;\r\nimport java.util.Iterator;\r\nimport javax.swing.GroupLayout.Alignment;\r\nimport javax.swing.GroupLayout.ParallelGroup;\r\n\r\n/**\r\n * �����, �������������� ������������ ������.\r\n */\r\npublic class ParallelGroupAgent extends GroupAgent {\r\n\r\n    public ParallelGroupAgent() {\r\n        settings \u003d new ParallelGroupSettings();\r\n    }\r\n\r\n    public ParallelGroupSettings getSettings() {\r\n        return (ParallelGroupSettings) settings;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether all of the elements of this parallel group agent\r\n     * are gaps.\r\n     */\r\n    public boolean containsGapsOnly() {\r\n        for (Agent child : childrenAgents) if (!child.isGap())\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Removes all gaps from this parallel group.\r\n     */\r\n    public void removeAllGaps() {\r\n        Iterator\u003cAgent\u003e i \u003d childrenAgents.iterator();\r\n        while (i.hasNext()) if (i.next().isGap())\r\n            i.remove();\r\n    }\r\n\r\n    /**\r\n     * Returns the gap of the type contained in this parallel group\r\n     * or null if this group has no gaps.\r\n     * If the gaps possess different types, throws a runtime exception.\r\n     * \u003cp\u003e\r\n     * After calling this method this parallel group,\r\n     * which typically consists of gaps only,\r\n     * can be replaced by the gap returned by this method.\r\n     */\r\n    public Agent getGapsType() {\r\n        Iterator\u003cAgent\u003e i \u003d childrenAgents.iterator();\r\n        Agent firstGapFound \u003d null;\r\n        Agent next;\r\n        while (i.hasNext()) {\r\n            next \u003d i.next();\r\n            if (!next.isGap())\r\n                continue;\r\n            if (firstGapFound \u003d\u003d null)\r\n                firstGapFound \u003d next;\r\n            else //the first gap has been already found.\r\n            if (next !\u003d firstGapFound)\r\n                throw new IllegalArgumentException(\"A parallel group consists of gaps only \" + \"but the gaps have different types.\");\r\n        }\r\n        return firstGapFound;\r\n    }\r\n\r\n    /**\r\n     * ���������� �������������� ���������� � ����� ������������ ������\r\n     * � ���������� �.\r\n     *\r\n     * @param creatorAndAdder\t��������� ��� �������� �����\r\n     * \t\t\t\t\t\t\t� ���������� � ��� �����������\r\n     * @return\t\t\t\t\t������, ������������ �� ���������������\r\n     * \t\t\t\t\t\t\t�����������.\r\n     */\r\n    public ParallelGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {\r\n        ParallelGroup result \u003d creatorAndAdder.createParallelGroup(getSettings());\r\n        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);\r\n        return result;\r\n    }\r\n\r\n    public FunctionsOnGroup getFunctionsOnGroupImplemenation() {\r\n        return getFunctionsOnParallelGroupImplemenation();\r\n    }\r\n\r\n    public FunctionsOnParallelGroup getFunctionsOnParallelGroupImplemenation() {\r\n        return new FunctionsOnParallelGroupImplemenation();\r\n    }\r\n\r\n    private class FunctionsOnParallelGroupImplemenation implements FunctionsOnParallelGroup {\r\n\r\n        /**\r\n         * ������������� ������ ������������ ����������� ������������ ������.\r\n         *\r\n         * @param alignment\t������ ������������\r\n         */\r\n        public void setContentAlignment(Alignment alignment) {\r\n            ParallelGroupAgent.this.getSettings().contentAlignment \u003d alignment;\r\n        }\r\n\r\n        /**\r\n         * Determines the {@code resize} behavior of the {@code ParallelGroup}.\r\n         *\r\n         * @param resizable\t{@code true} if the group is resizable;\r\n         * \t\t\t\t\tif the group is not resizable\r\n         * \t\t\t\t\tthe preferred size is used for\r\n         * \t\t\t\t\tthe minimum and maximum size of the group.\r\n         */\r\n        public void setResizable(boolean resizable) {\r\n            ParallelGroupAgent.this.getSettings().resizable \u003d resizable;\r\n        }\r\n\r\n        /**\r\n         * ������� ����� \"���������������� �����\" ������������ ������\r\n         * ��������� � ��������� ���������.\r\n         * \u003cp\u003e\r\n         * ���������� ��������� {@code FunctionsOnParallelGroupAndElement}\r\n         * ��������� ������������ �������� � ������������ ������.\r\n         *\r\n         * @param componentName\t�������� �������� ����������\r\n         * @return\t\t\t\t���������\r\n         * \t\t\t\t\t\t{@code FunctionsOnParallelGroupAndElement}\r\n         * \t\t\t\t\t\t��������� ������������ ��������\r\n         */\r\n        public FunctionsOnParallelGroupAndElement getComponent(String componentName) {\r\n            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getComponent(componentName));\r\n        }\r\n\r\n        /**\r\n         * ������� ����� \"���������������� �����\" ������������ ������\r\n         * ��������� � ���������� ���������� ������� � ���������� �����������.\r\n         * \u003cp\u003e\r\n         * ���������� ��������� {@code FunctionsOnParallelGroupAndElement}\r\n         * ��������� ������������ �������� � ������������ ������.\r\n         *\r\n         * @param firstName\t�������� ������� ���������� ������� ������\r\n         * @param lastName\t�������� ���������� ���������� ������� ������\r\n         * @return\t\t\t���������\r\n         * \t\t\t\t\t{@code FunctionsOnParallelGroupAndElement}\r\n         * \t\t\t\t\t��������� ������������ ��������\r\n         */\r\n        public FunctionsOnParallelGroupAndElement getGroup(String firstName, String lastName) {\r\n            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getGroup(firstName, lastName));\r\n        }\r\n    }\r\n\r\n    private static class FunctionsOnParallelGroupAndElementImplementation extends GroupAgent.FunctionsOnGroupAndElementImplementation implements FunctionsOnParallelGroupAndElement {\r\n\r\n        public FunctionsOnParallelGroupAndElementImplementation(GroupAgent parent, Agent element) {\r\n            super(parent, element);\r\n        }\r\n\r\n        /**\r\n         * Assigns the specified alignment of the element {@code elementAgent}\r\n         * in the parallel group {@code parentAgent}.\r\n         */\r\n        public void setAlignmentWithinParent(Alignment alignment) {\r\n            elementAgent.settings.alignmentWithRespectToParent \u003d alignment;\r\n        }\r\n    }\r\n\r\n    public String toString() {\r\n        return \"parallel group \u003c\" + getFirstName() + \",\" + getLastName() + \"\u003e\";\r\n    }\r\n}\r\n",
    "package": "glengineer.agents",
    "classname": "ParallelGroupAgent",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgent_0Test.java",
    "test_prompt": "// ParallelGroupAgent_0Test.java\npackage glengineer.agents;\n\nimport glengineer.agents.setters.FunctionsOnGroup;\nimport glengineer.agents.setters.FunctionsOnParallelGroup;\nimport glengineer.agents.setters.FunctionsOnParallelGroupAndElement;\nimport glengineer.agents.settings.ParallelGroupSettings;\nimport java.util.Iterator;\nimport javax.swing.GroupLayout.Alignment;\nimport javax.swing.GroupLayout.ParallelGroup;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParallelGroupAgent}.\n* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.\n*/\nclass ParallelGroupAgent_0Test {",
    "method_signature": "containsGapsOnly()",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// ParallelGroupAgent.java\npackage glengineer.agents;\r\n\r\nimport glengineer.agents.setters.FunctionsOnGroup;\r\nimport glengineer.agents.setters.FunctionsOnParallelGroup;\r\nimport glengineer.agents.setters.FunctionsOnParallelGroupAndElement;\r\nimport glengineer.agents.settings.ParallelGroupSettings;\r\nimport java.util.Iterator;\r\nimport javax.swing.GroupLayout.Alignment;\r\nimport javax.swing.GroupLayout.ParallelGroup;\r\n\r\n/**\r\n * �����, �������������� ������������ ������.\r\n */\r\npublic class ParallelGroupAgent extends GroupAgent {\r\n\r\n    public ParallelGroupAgent() {\r\n        settings \u003d new ParallelGroupSettings();\r\n    }\r\n\r\n    public ParallelGroupSettings getSettings() {\r\n        return (ParallelGroupSettings) settings;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether all of the elements of this parallel group agent\r\n     * are gaps.\r\n     */\r\n    public boolean containsGapsOnly() {\r\n        for (Agent child : childrenAgents) if (!child.isGap())\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Removes all gaps from this parallel group.\r\n     */\r\n    public void removeAllGaps() {\r\n        Iterator\u003cAgent\u003e i \u003d childrenAgents.iterator();\r\n        while (i.hasNext()) if (i.next().isGap())\r\n            i.remove();\r\n    }\r\n\r\n    /**\r\n     * Returns the gap of the type contained in this parallel group\r\n     * or null if this group has no gaps.\r\n     * If the gaps possess different types, throws a runtime exception.\r\n     * \u003cp\u003e\r\n     * After calling this method this parallel group,\r\n     * which typically consists of gaps only,\r\n     * can be replaced by the gap returned by this method.\r\n     */\r\n    public Agent getGapsType() {\r\n        Iterator\u003cAgent\u003e i \u003d childrenAgents.iterator();\r\n        Agent firstGapFound \u003d null;\r\n        Agent next;\r\n        while (i.hasNext()) {\r\n            next \u003d i.next();\r\n            if (!next.isGap())\r\n                continue;\r\n            if (firstGapFound \u003d\u003d null)\r\n                firstGapFound \u003d next;\r\n            else //the first gap has been already found.\r\n            if (next !\u003d firstGapFound)\r\n                throw new IllegalArgumentException(\"A parallel group consists of gaps only \" + \"but the gaps have different types.\");\r\n        }\r\n        return firstGapFound;\r\n    }\r\n\r\n    /**\r\n     * ���������� �������������� ���������� � ����� ������������ ������\r\n     * � ���������� �.\r\n     *\r\n     * @param creatorAndAdder\t��������� ��� �������� �����\r\n     * \t\t\t\t\t\t\t� ���������� � ��� �����������\r\n     * @return\t\t\t\t\t������, ������������ �� ���������������\r\n     * \t\t\t\t\t\t\t�����������.\r\n     */\r\n    public ParallelGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {\r\n        ParallelGroup result \u003d creatorAndAdder.createParallelGroup(getSettings());\r\n        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);\r\n        return result;\r\n    }\r\n\r\n    public FunctionsOnGroup getFunctionsOnGroupImplemenation() {\r\n        return getFunctionsOnParallelGroupImplemenation();\r\n    }\r\n\r\n    public FunctionsOnParallelGroup getFunctionsOnParallelGroupImplemenation() {\r\n        return new FunctionsOnParallelGroupImplemenation();\r\n    }\r\n\r\n    private class FunctionsOnParallelGroupImplemenation implements FunctionsOnParallelGroup {\r\n\r\n        /**\r\n         * ������������� ������ ������������ ����������� ������������ ������.\r\n         *\r\n         * @param alignment\t������ ������������\r\n         */\r\n        public void setContentAlignment(Alignment alignment) {\r\n            ParallelGroupAgent.this.getSettings().contentAlignment \u003d alignment;\r\n        }\r\n\r\n        /**\r\n         * Determines the {@code resize} behavior of the {@code ParallelGroup}.\r\n         *\r\n         * @param resizable\t{@code true} if the group is resizable;\r\n         * \t\t\t\t\tif the group is not resizable\r\n         * \t\t\t\t\tthe preferred size is used for\r\n         * \t\t\t\t\tthe minimum and maximum size of the group.\r\n         */\r\n        public void setResizable(boolean resizable) {\r\n            ParallelGroupAgent.this.getSettings().resizable \u003d resizable;\r\n        }\r\n\r\n        /**\r\n         * ������� ����� \"���������������� �����\" ������������ ������\r\n         * ��������� � ��������� ���������.\r\n         * \u003cp\u003e\r\n         * ���������� ��������� {@code FunctionsOnParallelGroupAndElement}\r\n         * ��������� ������������ �������� � ������������ ������.\r\n         *\r\n         * @param componentName\t�������� �������� ����������\r\n         * @return\t\t\t\t���������\r\n         * \t\t\t\t\t\t{@code FunctionsOnParallelGroupAndElement}\r\n         * \t\t\t\t\t\t��������� ������������ ��������\r\n         */\r\n        public FunctionsOnParallelGroupAndElement getComponent(String componentName) {\r\n            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getComponent(componentName));\r\n        }\r\n\r\n        /**\r\n         * ������� ����� \"���������������� �����\" ������������ ������\r\n         * ��������� � ���������� ���������� ������� � ���������� �����������.\r\n         * \u003cp\u003e\r\n         * ���������� ��������� {@code FunctionsOnParallelGroupAndElement}\r\n         * ��������� ������������ �������� � ������������ ������.\r\n         *\r\n         * @param firstName\t�������� ������� ���������� ������� ������\r\n         * @param lastName\t�������� ���������� ���������� ������� ������\r\n         * @return\t\t\t���������\r\n         * \t\t\t\t\t{@code FunctionsOnParallelGroupAndElement}\r\n         * \t\t\t\t\t��������� ������������ ��������\r\n         */\r\n        public FunctionsOnParallelGroupAndElement getGroup(String firstName, String lastName) {\r\n            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getGroup(firstName, lastName));\r\n        }\r\n    }\r\n\r\n    private static class FunctionsOnParallelGroupAndElementImplementation extends GroupAgent.FunctionsOnGroupAndElementImplementation implements FunctionsOnParallelGroupAndElement {\r\n\r\n        public FunctionsOnParallelGroupAndElementImplementation(GroupAgent parent, Agent element) {\r\n            super(parent, element);\r\n        }\r\n\r\n        /**\r\n         * Assigns the specified alignment of the element {@code elementAgent}\r\n         * in the parallel group {@code parentAgent}.\r\n         */\r\n        public void setAlignmentWithinParent(Alignment alignment) {\r\n            elementAgent.settings.alignmentWithRespectToParent \u003d alignment;\r\n        }\r\n    }\r\n\r\n    public String toString() {\r\n        return \"parallel group \u003c\" + getFirstName() + \",\" + getLastName() + \"\u003e\";\r\n    }\r\n}\r\n",
    "package": "glengineer.agents",
    "classname": "ParallelGroupAgent",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgent_1Test.java",
    "test_prompt": "// ParallelGroupAgent_1Test.java\npackage glengineer.agents;\n\nimport glengineer.agents.setters.FunctionsOnGroup;\nimport glengineer.agents.setters.FunctionsOnParallelGroup;\nimport glengineer.agents.setters.FunctionsOnParallelGroupAndElement;\nimport glengineer.agents.settings.ParallelGroupSettings;\nimport java.util.Iterator;\nimport javax.swing.GroupLayout.Alignment;\nimport javax.swing.GroupLayout.ParallelGroup;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParallelGroupAgent}.\n* It contains ten unit test cases for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.\n*/\nclass ParallelGroupAgent_1Test {",
    "method_signature": "groupContent(GroupCreatorAndElementAdder)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// SequentialGroupAgent.java\npackage glengineer.agents;\r\n\r\nimport java.util.ListIterator;\r\nimport glengineer.agents.setters.*;\r\nimport javax.swing.GroupLayout;\r\nimport javax.swing.LayoutStyle;\r\nimport javax.swing.GroupLayout.*;\r\n\r\n/**\r\n * �����, �������������� ���������������� ������.\r\n */\r\npublic class SequentialGroupAgent extends GroupAgent {\r\n\r\n    /**\r\n     * ���������� �������������� ���������� � ����� ���������������� ������\r\n     * � ���������� �.\r\n     *\r\n     * @param creatorAndAdder\t��������� ��� �������� �����\r\n     * \t\t\t\t\t\t\t� ���������� � ��� �����������\r\n     * @return\t\t\t\t\t������, ������������ �� ���������������\r\n     * \t\t\t\t\t\t\t�����������.\r\n     */\r\n    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {\r\n        SequentialGroup result \u003d creatorAndAdder.createSequentialGroup();\r\n        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);\r\n        return result;\r\n    }\r\n\r\n    public FunctionsOnGroup getFunctionsOnGroupImplemenation() {\r\n        return getFunctionsOnSequentialGroupImplemenation();\r\n    }\r\n\r\n    public FunctionsOnSequentialGroup getFunctionsOnSequentialGroupImplemenation() {\r\n        return new FunctionsOnSequentialGroupImplemenation();\r\n    }\r\n\r\n    protected class FunctionsOnSequentialGroupImplemenation implements FunctionsOnSequentialGroup {\r\n\r\n        public FunctionsOnSequentialGroupAndElement getComponent(String name) {\r\n            return new FunctionsOnSequentialGroupAndElementImplementation(SequentialGroupAgent.this, SequentialGroupAgent.this.getComponent(name));\r\n        }\r\n\r\n        public FunctionsOnSequentialGroupAndElement getGroup(String firstName, String lastName) {\r\n            return new FunctionsOnSequentialGroupAndElementImplementation(SequentialGroupAgent.this, SequentialGroupAgent.this.getGroup(firstName, lastName));\r\n        }\r\n    }\r\n\r\n    private static class FunctionsOnSequentialGroupAndElementImplementation extends GroupAgent.FunctionsOnGroupAndElementImplementation implements FunctionsOnSequentialGroupAndElement {\r\n\r\n        public FunctionsOnSequentialGroupAndElementImplementation(GroupAgent parent, Agent element) {\r\n            super(parent, element);\r\n        }\r\n\r\n        private SequentialGroupAgent getParentGroupAgent() {\r\n            return (SequentialGroupAgent) parentGroupAgent;\r\n        }\r\n\r\n        /**\r\n         * ��������� ����� ��������� ������������ ������\r\n         *  \"���������\" ����������.\r\n         */\r\n        public void addPrecedingRelatedGap() {\r\n            addPrecedingRelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);\r\n        }\r\n\r\n        /**\r\n         * ��������� ����� ��������� ������������ ������\r\n         *  \"�����������\" ����������.\r\n         */\r\n        public void addPrecedingUnrelatedGap() {\r\n            addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);\r\n        }\r\n\r\n        /**\r\n         * ��������� ����� �������� ������������ ������\r\n         *  \"���������\" ����������.\r\n         */\r\n        public void addFollowingRelatedGap() {\r\n            addFollowingRelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);\r\n        }\r\n\r\n        /**\r\n         * ��������� ����� �������� ������������ ������\r\n         *  \"�����������\" ����������.\r\n         */\r\n        public void addFollowingUnrelatedGap() {\r\n            addFollowingUnrelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);\r\n        }\r\n\r\n        /**\r\n         * ��������� � ������������ ������ ����� � ���������\r\n         *  \"���������\" ���������� � ������������� ���������� ��� ����\r\n         *  �������������� � ������������ �������.\r\n         */\r\n        public void addPrecedingRelatedGap(int pref, int max) {\r\n            getParentGroupAgent().addPreferredGapBefore(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, pref, max), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * ��������� � ������������ ������ ����� � ���������\r\n         *  \"�����������\" ���������� � ������������� ���������� ��� ����\r\n         *  �������������� � ������������ �������.\r\n         */\r\n        public void addPrecedingUnrelatedGap(int pref, int max) {\r\n            getParentGroupAgent().addPreferredGapBefore(new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED, pref, max), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * ��������� � ������������ ������ ����� � ��������\r\n         *  \"���������\" ���������� � ������������� ���������� ��� ����\r\n         *  �������������� � ������������ �������.\r\n         */\r\n        public void addFollowingRelatedGap(int pref, int max) {\r\n            getParentGroupAgent().addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, pref, max), elementAgent);\r\n        }\r\n\r\n        /**\r\n         * ��������� � ������������ ������ ����� � ��������\r\n         *  \"�����������\" ���������� � ������������� ���������� ��� ����\r\n         *  �������������� � ������������ �������.\r\n         */\r\n        public void addFollowingUnrelatedGap(int pref, int max) {\r\n            getParentGroupAgent().addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED, pref, max), elementAgent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Finds the specified element in the list of\r\n     * this sequential group\u0027s children and inserts\r\n     * the specified preferred gap into that list before that element.\r\n     */\r\n    public void addPreferredGapBefore(PreferredGapAgent gap, Agent element) {\r\n        if (childrenAgents.isEmpty()) {\r\n            childrenAgents.add(gap);\r\n            return;\r\n        }\r\n        ListIterator\u003cAgent\u003e iter \u003d childrenAgents.listIterator();\r\n        while (iter.hasNext()) if (iter.next().equals(element)) {\r\n            iter.previous();\r\n            iter.add(gap);\r\n            return;\r\n        }\r\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + toString() + \" not found\");\r\n    }\r\n\r\n    /**\r\n     * Finds the specified element in the list of\r\n     * this sequential group\u0027s children and inserts\r\n     * the specified preferred gap into that list after that element.\r\n     */\r\n    public void addPreferredGapAfter(PreferredGapAgent gap, Agent element) {\r\n        if (childrenAgents.isEmpty()) {\r\n            childrenAgents.add(gap);\r\n            return;\r\n        }\r\n        ListIterator\u003cAgent\u003e iter \u003d childrenAgents.listIterator();\r\n        while (iter.hasNext()) if (iter.next().equals(element)) {\r\n            iter.add(gap);\r\n            return;\r\n        }\r\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + toString() + \" not found\");\r\n    }\r\n\r\n    public String toString() {\r\n        return \"sequential group \u003c\" + getFirstName() + \",\" + getLastName() + \"\u003e\";\r\n    }\r\n}\r\n",
    "package": "glengineer.agents",
    "classname": "SequentialGroupAgent",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/agents/SequentialGroupAgent.java",
    "test_prompt": "// SequentialGroupAgentTest.java\npackage glengineer.agents;\n\nimport java.util.ListIterator;\nimport glengineer.agents.setters.*;\nimport javax.swing.GroupLayout;\nimport javax.swing.LayoutStyle;\nimport javax.swing.GroupLayout.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SequentialGroupAgent}.\n* It contains ten unit test cases for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.\n*/\nclass SequentialGroupAgentTest {",
    "method_signature": "groupContent(GroupCreatorAndElementAdder)",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// TopSequentialGroupAgent.java\npackage glengineer.agents;\r\n\r\nimport javax.swing.GroupLayout.SequentialGroup;\r\nimport glengineer.agents.setters.*;\r\n\r\n/**\r\n * �����, �������������� ���������������� ������ �������� ������.\r\n * \u003cp\u003e\r\n * ��������� ��������� {@code FunctionsOnTopSequentialGroup}\r\n * ���������� �������������� ������������ �����������\r\n * � ������ � � ����� ���������������� ������ �������� ������.\r\n */\r\npublic class TopSequentialGroupAgent extends SequentialGroupAgent {\r\n\r\n    /**\r\n     * �����, �������������� ������������ ���������� � ������ ������.\r\n     */\r\n    private ContainerGapAgent precedingContainerGap;\r\n\r\n    /**\r\n     * �����, �������������� ������������ ���������� � ����� ������.\r\n     */\r\n    private ContainerGapAgent followingContainerGap;\r\n\r\n    /**\r\n     * ���������� �������������� ���������� � ����� ���������������� ������,\r\n     * ��������, ���� ����, ������������ ���������� � ������ � � �����,\r\n     * � ���������� ���������� ������.\r\n     * \u003cp\u003e\r\n     * ����������� ����� {@code TopSequentialGroupAgent.groupContent()},\r\n     * �������� ������ � ������������� ������������.\r\n     *\r\n     * @param creatorAndAdder\t��������� ��� �������� �����\r\n     * \t\t\t\t\t\t\t� ���������� � ��� �����������\r\n     * @return\t\t\t\t\t������, ������������ �� ���������������\r\n     * \t\t\t\t\t\t\t�����������.\r\n     */\r\n    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {\r\n        SequentialGroup result \u003d creatorAndAdder.createSequentialGroup();\r\n        if (precedingContainerGap !\u003d null)\r\n            precedingContainerGap.addOneselfToGroup(result);\r\n        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);\r\n        if (followingContainerGap !\u003d null)\r\n            followingContainerGap.addOneselfToGroup(result);\r\n        return result;\r\n    }\r\n\r\n    public FunctionsOnGroup getFunctionsOnGroupImplemenation() {\r\n        return getFunctionsOnTopSequentialGroupImplemenation();\r\n    }\r\n\r\n    public FunctionsOnSequentialGroup getFunctionsOnSequentialGroupImplemenation() {\r\n        return getFunctionsOnTopSequentialGroupImplemenation();\r\n    }\r\n\r\n    public FunctionsOnTopSequentialGroup getFunctionsOnTopSequentialGroupImplemenation() {\r\n        return new FunctionsOnTopSequentialGroupImplemenation();\r\n    }\r\n\r\n    private class FunctionsOnTopSequentialGroupImplemenation extends SequentialGroupAgent.FunctionsOnSequentialGroupImplemenation implements FunctionsOnTopSequentialGroup {\r\n\r\n        /**\r\n         * ��������� ������������ ����������\r\n         * � ������ ���������������� ������ �������� ������.\r\n         */\r\n        public void addPrecedingContainerGap() {\r\n            precedingContainerGap \u003d new ContainerGapAgent();\r\n        }\r\n\r\n        /**\r\n         * ��������� ������������ ���������� � ���������� ����������� �������\r\n         * � ������ ���������������� ������ �������� ������.\r\n         */\r\n        public void addPrecedingContainerGap(int pref, int max) {\r\n            precedingContainerGap \u003d new ContainerGapAgent(pref, max);\r\n        }\r\n\r\n        /**\r\n         * ��������� ������������ ����������\r\n         * � ����� ���������������� ������ �������� ������.\r\n         */\r\n        public void addFollowingContainerGap() {\r\n            followingContainerGap \u003d new ContainerGapAgent();\r\n        }\r\n\r\n        /**\r\n         * ��������� ������������ ���������� � ���������� ����������� �������\r\n         * � ����� ���������������� ������ �������� ������.\r\n         */\r\n        public void addFollowingContainerGap(int pref, int max) {\r\n            followingContainerGap \u003d new ContainerGapAgent(pref, max);\r\n        }\r\n\r\n        public void addBothContainerGaps() {\r\n            addPrecedingContainerGap();\r\n            addFollowingContainerGap();\r\n        }\r\n\r\n        public void addBothContainerGaps(int pref, int max) {\r\n            addPrecedingContainerGap(pref, max);\r\n            addFollowingContainerGap(pref, max);\r\n        }\r\n    }\r\n}\r\n",
    "package": "glengineer.agents",
    "classname": "TopSequentialGroupAgent",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/agents/TopSequentialGroupAgent.java",
    "test_prompt": "// TopSequentialGroupAgentTest.java\npackage glengineer.agents;\n\nimport javax.swing.GroupLayout.SequentialGroup;\nimport glengineer.agents.setters.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TopSequentialGroupAgent}.\n* It contains ten unit test cases for the {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.\n*/\nclass TopSequentialGroupAgentTest {",
    "method_signature": "groupContent(GroupCreatorAndElementAdder)",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// VWordPosition.java\npackage glengineer.positions;\r\n\r\nimport glengineer.blocks.Block;\r\nimport glengineer.blocks.CharTable;\r\n\r\n/**\r\n * Encapsulates the position (start and end coordinates)\r\n * of a word lying vertically on the scheme.\r\n */\r\npublic class VWordPosition extends WordPosition implements Comparable\u003cVWordPosition\u003e {\r\n\r\n    /**\r\n     * The horizontal coordinate of the word.\r\n     */\r\n    public final int x;\r\n\r\n    /**\r\n     * The vertical coordinate of the word start.\r\n     */\r\n    public final int y1;\r\n\r\n    /**\r\n     * The vertical coordinate of the word end + 1.\r\n     */\r\n    public final int y2;\r\n\r\n    public VWordPosition(int x, int y1, int y2) {\r\n        if (y1 \u003e y2)\r\n            throw new IllegalArgumentException(\"wrong word position parameters\");\r\n        this.x \u003d x;\r\n        this.y1 \u003d y1;\r\n        this.y2 \u003d y2;\r\n    }\r\n\r\n    public VWordPosition(CharPosition start, int y2) {\r\n        this(start.x, start.y, y2);\r\n    }\r\n\r\n    public VWordPosition(int y, CharPosition end) {\r\n        this(end.x, y, end.y);\r\n    }\r\n\r\n    public VWordPosition(Block block) {\r\n        this(block.getPos1(), block.getPos2().x);\r\n    }\r\n\r\n    /**\r\n     * Creates a trivial word position\r\n     * which begins and ends at the specified character position.\r\n     */\r\n    public VWordPosition(CharPosition cp) {\r\n        this(cp.x, cp.y, cp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the beginning of this word.\r\n     */\r\n    public CharPosition1 getStart() {\r\n        return new CharPosition1(x, y1);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the ending of this word (exclusive).\r\n     */\r\n    public CharPosition2 getEnd() {\r\n        return new CharPosition2(x, y2);\r\n    }\r\n\r\n    public int getHeight() {\r\n        return y2 - y1;\r\n    }\r\n\r\n    public boolean equals(WordPosition wp) {\r\n        if (!(wp instanceof VWordPosition))\r\n            return false;\r\n        VWordPosition hwp \u003d (VWordPosition) wp;\r\n        return hwp.x \u003d\u003d x \u0026\u0026 hwp.y1 \u003d\u003d y1 \u0026\u0026 hwp.y2 \u003d\u003d y2;\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return y1 \u003e\u003d y2;\r\n    }\r\n\r\n    public boolean contains(int x, int y) {\r\n        return x \u003d\u003d this.x \u0026\u0026 y1 \u003c\u003d y \u0026\u0026 y \u003c y2;\r\n    }\r\n\r\n    public boolean liesIn(CharTable ct) {\r\n        return x \u003e\u003d ct.x1 \u0026\u0026 x \u003c ct.x2 \u0026\u0026 y1 \u003e\u003d ct.y1 \u0026\u0026 y2 \u003c\u003d ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether this word position intersects the specified char table.\r\n     */\r\n    public boolean intersects(CharTable ct) {\r\n        return ct.x1 \u003c\u003d x \u0026\u0026 x \u003c ct.x2 \u0026\u0026 ct.y1 \u003c y2 \u0026\u0026 y1 \u003c ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Returns the height of the intersection of this line\r\n     * with the specified block\r\n     * or \u003ccode\u003e0\u003c/code\u003e if they are not intersected.\r\n     */\r\n    public int getLengthInsideOf(Block block) {\r\n        int height \u003d Math.min(y2, block.y2) - Math.max(y1, block.y1);\r\n        return Math.max(height, 0);\r\n    }\r\n\r\n    /**\r\n     * Compares this vertical position with the specified one\r\n     * according to their x-coordinates.\r\n     */\r\n    public int compareTo(VWordPosition vLine) {\r\n        int xx \u003d vLine.x;\r\n        if (x \u003c xx)\r\n            return -1;\r\n        else if (x \u003d\u003d xx)\r\n            return 0;\r\n        else\r\n            return +1;\r\n    }\r\n\r\n    public String toString() {\r\n        return \"vertical(\" + x + \";\" + y1 + \",\" + y2 + \")\";\r\n    }\r\n\r\n    /**\r\n     * Returns the text at this position on the specified char table.\r\n     *\r\n     * The call is dispatched back to the specified char table\r\n     * informing it about the concrete word position type.\r\n     *\r\n     * @param ct\tthe char table from which the text must be read.\r\n     *\r\n     * @return\t\tthe text at this position on the specified char table.\r\n     */\r\n    public String textAt(CharTable ct) {\r\n        return ct.textAt(this);\r\n    }\r\n}\r\n",
    "package": "glengineer.positions",
    "classname": "VWordPosition",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/positions/VWordPosition_6Test.java",
    "test_prompt": "// VWordPosition_6Test.java\npackage glengineer.positions;\n\nimport glengineer.blocks.Block;\nimport glengineer.blocks.CharTable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VWordPosition}.\n* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.\n*/\nclass VWordPosition_6Test {",
    "method_signature": "textAt(CharTable)",
    "suffix": "6"
  },
  {
    "numberTests": "ten",
    "original_code": "// HWordPosition.java\npackage glengineer.positions;\r\n\r\nimport glengineer.blocks.Block;\r\nimport glengineer.blocks.CharTable;\r\n\r\n/**\r\n * Encapsulates the position (start and end coordinates)\r\n * of a word lying horizontally on the scheme.\r\n */\r\npublic class HWordPosition extends WordPosition {\r\n\r\n    /**\r\n     * The horizontal coordinate of the word start.\r\n     */\r\n    public final int x1;\r\n\r\n    /**\r\n     * The horizontal coordinate of the word end + 1.\r\n     */\r\n    public final int x2;\r\n\r\n    /**\r\n     * The vertical coordinate of the word.\r\n     */\r\n    public final int y;\r\n\r\n    public HWordPosition(int x1, int x2, int y) {\r\n        if (x1 \u003e x2)\r\n            throw new IllegalArgumentException(\"wrong word position parameters\");\r\n        this.x1 \u003d x1;\r\n        this.x2 \u003d x2;\r\n        this.y \u003d y;\r\n    }\r\n\r\n    public HWordPosition(CharPosition start, int x2) {\r\n        this(start.x, x2, start.y);\r\n    }\r\n\r\n    public HWordPosition(int x1, CharPosition end) {\r\n        this(x1, end.x, end.y);\r\n    }\r\n\r\n    /**\r\n     * The word position is initialized\r\n     * representing the upper line of the specified block.\r\n     */\r\n    public HWordPosition(Block block) {\r\n        this(block.getPos1(), block.getPos2().x);\r\n    }\r\n\r\n    /**\r\n     * Creates a trivial word position\r\n     * which begins and ends at the specified character position.\r\n     */\r\n    public HWordPosition(CharPosition cp) {\r\n        this(cp.x, cp.x, cp.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the beginning of this word.\r\n     */\r\n    public CharPosition1 getStart() {\r\n        return new CharPosition1(x1, y);\r\n    }\r\n\r\n    /**\r\n     * Returns the coordinates of the ending of this word (exclusive).\r\n     */\r\n    public CharPosition2 getEnd() {\r\n        return new CharPosition2(x2, y);\r\n    }\r\n\r\n    public int getWidth() {\r\n        return x2 - x1;\r\n    }\r\n\r\n    public boolean equals(WordPosition wp) {\r\n        if (!(wp instanceof HWordPosition))\r\n            return false;\r\n        HWordPosition hwp \u003d (HWordPosition) wp;\r\n        return hwp.x1 \u003d\u003d x1 \u0026\u0026 hwp.x2 \u003d\u003d x2 \u0026\u0026 hwp.y \u003d\u003d y;\r\n    }\r\n\r\n    public boolean isTrivial() {\r\n        return x1 \u003e\u003d x2;\r\n    }\r\n\r\n    public boolean contains(int x, int y) {\r\n        return y \u003d\u003d this.y \u0026\u0026 x1 \u003c\u003d x \u0026\u0026 x \u003c x2;\r\n    }\r\n\r\n    public boolean liesIn(CharTable ct) {\r\n        return x1 \u003e\u003d ct.x1 \u0026\u0026 x2 \u003c\u003d ct.x2 \u0026\u0026 y \u003e\u003d ct.y1 \u0026\u0026 y \u003c ct.y2;\r\n    }\r\n\r\n    /**\r\n     * Verifies whether this word position intersects the specified char table.\r\n     */\r\n    public boolean intersects(CharTable ct) {\r\n        return ct.y1 \u003c\u003d y \u0026\u0026 y \u003c ct.y2 \u0026\u0026 ct.x1 \u003c x2 \u0026\u0026 x1 \u003c ct.x2;\r\n    }\r\n\r\n    /**\r\n     * Returns the width of the intersection of this line\r\n     * with the specified block\r\n     * or \u003ccode\u003e0\u003c/code\u003e if they are not intersected.\r\n     */\r\n    public int getLengthInsideOf(Block block) {\r\n        int width \u003d Math.min(x2, block.x2) - Math.max(x1, block.x1);\r\n        return Math.max(width, 0);\r\n    }\r\n\r\n    public String toString() {\r\n        return \"horizontal(\" + x1 + \",\" + x2 + \";\" + y + \")\";\r\n    }\r\n\r\n    /**\r\n     * Returns the text at this position on the specified char table.\r\n     *\r\n     * The call is dispatched back to the specified char table\r\n     * informing it about the concrete word position type.\r\n     *\r\n     * @param ct\tthe char table from which the text must be read.\r\n     *\r\n     * @return\t\tthe text at this position on the specified char table.\r\n     */\r\n    public String textAt(CharTable ct) {\r\n        return ct.textAt(this);\r\n    }\r\n}\r\n",
    "package": "glengineer.positions",
    "classname": "HWordPosition",
    "id": "/EvoSuiteBenchmark/original/40_glengineer/src/main/java/glengineer/positions/HWordPosition_5Test.java",
    "test_prompt": "// HWordPosition_5Test.java\npackage glengineer.positions;\n\nimport glengineer.blocks.Block;\nimport glengineer.blocks.CharTable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HWordPosition}.\n* It contains ten unit test cases for the {@link HWordPosition#textAt(CharTable)} method.\n*/\nclass HWordPosition_5Test {",
    "method_signature": "textAt(CharTable)",
    "suffix": "5"
  }
]