[
  {
    "numberTests": "ten",
    "original_code": "// LinearAxisScale.java\n/*\n*   LinearAxisScale  -- Provides linear axis scaling for plot axes.\n*\n*   Copyright (C) 2000-2002 by Joseph A. Huwaldt \u003cjhuwaldt@knology.net\u003e.\n*   All rights reserved.\n*   \n*   This library is free software; you can redistribute it and/or\n*   modify it under the terms of the GNU Library General Public\n*   License as published by the Free Software Foundation; either\n*   version 2 of the License, or (at your option) any later version.\n*   \n*   This library is distributed in the hope that it will be useful,\n*   but WITHOUT ANY WARRANTY; without even the implied warranty of\n*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n*   Library General Public License for more details.\n**/\npackage jahuwaldt.plot;\n\n/**\n *  \u003cp\u003e This object provides linear scaling for plot axes.\n *  \u003c/p\u003e\n *\n *  \u003cp\u003e  Modified by:  Joseph A. Huwaldt  \u003c/p\u003e\n *\n *  @author  Joseph A. Huwaldt   Date:  September 13, 2000\n *  @version January 10, 2001\n */\npublic class LinearAxisScale extends Object implements PlotAxisScale {\n\n    //\tDebug flag.\n    private static final boolean DEBUG \u003d false;\n\n    /**\n     *  The transformation function used to scale the data\n     *  plotted against this axis.\n     *  This axis uses a linear scaling function:  f(a) \u003d a.\n     */\n    public final double func(double a) {\n        return a;\n    }\n\n    /**\n     *  Method that returns the default lower bounds for\n     *  this axis scale.  Returns -1.0.\n     */\n    public double lowerBounds() {\n        return -1.0;\n    }\n\n    /**\n     *  Method that returns the default upper bounds for\n     *  this axis scale.  Returns 1.0.\n     */\n    public double upperBounds() {\n        return 1.0;\n    }\n\n    /**\n     *  Method that returns an AxisLimitData object that contains\n     *  the preferred axis limits and tick mark spacing for the\n     *  specified range of data values for this linear axis scale.\n     *\n     *  @param  aLB  The lower bounds of the data plotted on this axis.\n     *  @param  aUB  The upper bounds of the data plotted on this axis.\n     */\n    public AxisLimitData findGoodLimits(double aLB, double aUB) {\n        //\tThe lower limit and tick mark spacing being calculated.\n        double s \u003d 0., r \u003d 0.;\n        //\tMake sure we don\u0027t have a degenerate case.\n        if (Math.abs(aUB - aLB) \u003c\u003d 0.000001) {\n            if (aUB \u003e 0.) {\n                aUB \u003d 2. * aUB;\n                aLB \u003d 0.;\n            } else if (aLB \u003c 0) {\n                aLB \u003d 2. * aLB;\n                aUB \u003d 0.;\n            }\n            if (Math.abs(aUB - aLB) \u003c\u003d 0.000001) {\n                aLB \u003d lowerBounds();\n                aUB \u003d upperBounds();\n            }\n        }\n        if (DEBUG) {\n            System.out.println(\"In findGoodLimits()...\");\n            System.out.println(\"   aLB \u003d \" + aLB + \", aUB \u003d \" + aUB);\n        }\n        //\tObject used to return results.\n        AxisLimitData limData \u003d new AxisLimitData();\n        boolean done \u003d false;\n        while (!done) {\n            done \u003d true;\n            double ub \u003d aUB;\n            double lb \u003d aLB;\n            double delta \u003d ub - lb;\n            //\tScale up by s, a power of 10, so range (delta) exceeds 1.\n            s \u003d 1.;\n            while (delta * s \u003c 10.) s *\u003d 10.;\n            //\tFind power of 10 quantum, r, such that delta/10 \u003c\u003d r \u003c delta.\n            r \u003d 1. / s;\n            while (10. * r \u003c delta) r *\u003d 10.;\n            //\tSet r\u003d(1,2,5)*10**n so that 3-5 quanta cover range.\n            if (r \u003e\u003d delta / 2.)\n                r /\u003d 2.;\n            else if (r \u003c delta / 5.)\n                r *\u003d 2.;\n            limData.ub \u003d modceil(ub, r);\n            limData.lb \u003d modfloor(lb, r);\n            //\tIf lower bound is \u003c\u003d r and \u003e 0, then repeat.\n            if (limData.lb \u003c\u003d r \u0026\u0026 limData.lb \u003e 0.) {\n                aLB \u003d 0.;\n                done \u003d false;\n                //\tIf upper bound \u003e\u003d -r and \u003c 0, then repeat.\n            } else if (limData.ub \u003e\u003d -r \u0026\u0026 limData.ub \u003c 0.) {\n                aUB \u003d 0.;\n                done \u003d false;\n            }\n        }\n        //\tSave off tick mark spacing.\n        limData.quantum \u003d r;\n        if (DEBUG) {\n            System.out.println(\"    limData.lb \u003d \" + limData.lb + \", limData.ub \u003d \" + limData.ub + \", limData.quantum \u003d \" + limData.quantum);\n        }\n        return limData;\n    }\n\n    /**\n     *  Find the position and size (in screen coordinates) of tick\n     *  marks for a given axis scale.\n     *\n     *  @param  quantum   Tick mark step size for the axis using this scale.\n     *  @param  aLB       Lower bounds of axis using this scale.\n     *  @param  aUB       Upper bounds of axis using this scale.\n     *  @param  xA        Scaling coefficient for this axis.\n     *  @param  xB        Scaling coefficient for this axis.\n     *  @return An TickMarkData object containing the tick mark positions, lengths,\n     *          and data values at each tick mark.\n     */\n    public TickMarkData calcTickMarks(double quantum, double aLB, double aUB, double xA, double xB) {\n        double xl \u003d 0;\n        double xu \u003d 0;\n        double q \u003d quantum;\n        if (q \u003e 0.) {\n            xl \u003d modfloor(aLB, q);\n            xu \u003d modfloor(aUB - q / 10., q / 5.) + q / 10.;\n        } else {\n            xl \u003d modfloor(aUB, q);\n            xu \u003d modfloor(aLB + q / 10., q / 5.) - q / 10.;\n        }\n        //\tDetermine the number of tick marks.\n        int xn \u003d (int) ((xu - xl) / (Math.abs(quantum) / 5.));\n        if (DEBUG) {\n            System.out.println(\"In calcTickMarks()...\");\n            System.out.println(\"    quantum \u003d \" + quantum + \", aLB \u003d \" + aLB + \", aUB \u003d \" + aUB);\n            System.out.println(\"    xA \u003d \" + xA + \", xB \u003d \" + xB);\n            System.out.println(\"    xl \u003d \" + xl + \", xu \u003d \" + xu);\n            System.out.println(\"    xn \u003d \" + xn);\n        }\n        //\tAllocate memory for tick mark arrays.\n        int[] mark \u003d new int[xn];\n        int[] lmark \u003d new int[xn];\n        float[] markValue \u003d new float[xn];\n        xn \u003d 0;\n        int i \u003d 0;\n        for (double x \u003d xl; x \u003c\u003d xu; x +\u003d Math.abs(quantum) / 5., ++i) {\n            //\tBounds check.\n            if (q \u003e 0.)\n                if (x \u003c\u003d aLB || x \u003e\u003d aUB)\n                    continue;\n            if (q \u003c 0.)\n                if (x \u003e\u003d aLB || x \u003c\u003d aUB)\n                    continue;\n            //\tStore tick mark.\n            mark[xn] \u003d (int) (func(x) * xA + xB);\n            markValue[xn] \u003d (float) x;\n            if (i % 5 !\u003d 0)\n                //\tMinor tick mark.\n                lmark[xn++] \u003d PlotAxis.kTick;\n            else\n                //\tMajor tick mark.\n                lmark[xn++] \u003d 3 * PlotAxis.kTick;\n        }\n        if (DEBUG) {\n            System.out.println(\"Tick mark values:\");\n            int length \u003d markValue.length;\n            for (i \u003d 0; i \u003c length; ++i) System.out.print(\"   \" + markValue[i]);\n            System.out.println();\n        }\n        //\tCreate a tick mark data object and pass it out.\n        TickMarkData data \u003d new TickMarkData();\n        data.mark \u003d mark;\n        data.lmark \u003d lmark;\n        data.markValue \u003d markValue;\n        return data;\n    }\n\n    /**\n     *  Adjust the upper and lower axis bounds, if necissary, to allow\n     *  room for error bars on the specified data point.  New bounds\n     *  returned in \"output\" object.\n     *\n     *  @param datum  The data point we are bounds checking.\n     *  @param aUB    The current upper bounds.\n     *  @param aLB    The current lower bounds.\n     *  @param output An AxisLimitData structure for passing the new upper and\n     *                lower bounds to the calling routine.\n     */\n    public void adjustForErrorBars(PlotDatum datum, double aUB, double aLB, AxisLimitData output) {\n        double temp \u003d datum.getYError();\n        aLB \u003d Math.min(aLB, datum.y - temp);\n        aUB \u003d Math.max(aUB, datum.y + temp);\n        output.lb \u003d aLB;\n        output.ub \u003d aUB;\n    }\n\n    private double modceil(double f, double t) {\n        t \u003d Math.abs(t);\n        return (Math.ceil(f / t) * t);\n    }\n\n    private double modfloor(double f, double t) {\n        t \u003d Math.abs(t);\n        return (Math.floor(f / t) * t);\n    }\n}\n",
    "package": "jahuwaldt.plot",
    "classname": "LinearAxisScale",
    "id": "/EvoSuiteBenchmark/original/29_apbsmem/src/main/java/jahuwaldt/plot/LinearAxisScale_1Test.java",
    "test_prompt": "// LinearAxisScale_1Test.java\npackage jahuwaldt.plot;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LinearAxisScale}.\n* It contains ten unit test cases for the {@link LinearAxisScale#lowerBounds()} method.\n*/\nclass LinearAxisScale_1Test {",
    "method_signature": "lowerBounds()",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// LinearAxisScale.java\n/*\n*   LinearAxisScale  -- Provides linear axis scaling for plot axes.\n*\n*   Copyright (C) 2000-2002 by Joseph A. Huwaldt \u003cjhuwaldt@knology.net\u003e.\n*   All rights reserved.\n*   \n*   This library is free software; you can redistribute it and/or\n*   modify it under the terms of the GNU Library General Public\n*   License as published by the Free Software Foundation; either\n*   version 2 of the License, or (at your option) any later version.\n*   \n*   This library is distributed in the hope that it will be useful,\n*   but WITHOUT ANY WARRANTY; without even the implied warranty of\n*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n*   Library General Public License for more details.\n**/\npackage jahuwaldt.plot;\n\n/**\n *  \u003cp\u003e This object provides linear scaling for plot axes.\n *  \u003c/p\u003e\n *\n *  \u003cp\u003e  Modified by:  Joseph A. Huwaldt  \u003c/p\u003e\n *\n *  @author  Joseph A. Huwaldt   Date:  September 13, 2000\n *  @version January 10, 2001\n */\npublic class LinearAxisScale extends Object implements PlotAxisScale {\n\n    //\tDebug flag.\n    private static final boolean DEBUG \u003d false;\n\n    /**\n     *  The transformation function used to scale the data\n     *  plotted against this axis.\n     *  This axis uses a linear scaling function:  f(a) \u003d a.\n     */\n    public final double func(double a) {\n        return a;\n    }\n\n    /**\n     *  Method that returns the default lower bounds for\n     *  this axis scale.  Returns -1.0.\n     */\n    public double lowerBounds() {\n        return -1.0;\n    }\n\n    /**\n     *  Method that returns the default upper bounds for\n     *  this axis scale.  Returns 1.0.\n     */\n    public double upperBounds() {\n        return 1.0;\n    }\n\n    /**\n     *  Method that returns an AxisLimitData object that contains\n     *  the preferred axis limits and tick mark spacing for the\n     *  specified range of data values for this linear axis scale.\n     *\n     *  @param  aLB  The lower bounds of the data plotted on this axis.\n     *  @param  aUB  The upper bounds of the data plotted on this axis.\n     */\n    public AxisLimitData findGoodLimits(double aLB, double aUB) {\n        //\tThe lower limit and tick mark spacing being calculated.\n        double s \u003d 0., r \u003d 0.;\n        //\tMake sure we don\u0027t have a degenerate case.\n        if (Math.abs(aUB - aLB) \u003c\u003d 0.000001) {\n            if (aUB \u003e 0.) {\n                aUB \u003d 2. * aUB;\n                aLB \u003d 0.;\n            } else if (aLB \u003c 0) {\n                aLB \u003d 2. * aLB;\n                aUB \u003d 0.;\n            }\n            if (Math.abs(aUB - aLB) \u003c\u003d 0.000001) {\n                aLB \u003d lowerBounds();\n                aUB \u003d upperBounds();\n            }\n        }\n        if (DEBUG) {\n            System.out.println(\"In findGoodLimits()...\");\n            System.out.println(\"   aLB \u003d \" + aLB + \", aUB \u003d \" + aUB);\n        }\n        //\tObject used to return results.\n        AxisLimitData limData \u003d new AxisLimitData();\n        boolean done \u003d false;\n        while (!done) {\n            done \u003d true;\n            double ub \u003d aUB;\n            double lb \u003d aLB;\n            double delta \u003d ub - lb;\n            //\tScale up by s, a power of 10, so range (delta) exceeds 1.\n            s \u003d 1.;\n            while (delta * s \u003c 10.) s *\u003d 10.;\n            //\tFind power of 10 quantum, r, such that delta/10 \u003c\u003d r \u003c delta.\n            r \u003d 1. / s;\n            while (10. * r \u003c delta) r *\u003d 10.;\n            //\tSet r\u003d(1,2,5)*10**n so that 3-5 quanta cover range.\n            if (r \u003e\u003d delta / 2.)\n                r /\u003d 2.;\n            else if (r \u003c delta / 5.)\n                r *\u003d 2.;\n            limData.ub \u003d modceil(ub, r);\n            limData.lb \u003d modfloor(lb, r);\n            //\tIf lower bound is \u003c\u003d r and \u003e 0, then repeat.\n            if (limData.lb \u003c\u003d r \u0026\u0026 limData.lb \u003e 0.) {\n                aLB \u003d 0.;\n                done \u003d false;\n                //\tIf upper bound \u003e\u003d -r and \u003c 0, then repeat.\n            } else if (limData.ub \u003e\u003d -r \u0026\u0026 limData.ub \u003c 0.) {\n                aUB \u003d 0.;\n                done \u003d false;\n            }\n        }\n        //\tSave off tick mark spacing.\n        limData.quantum \u003d r;\n        if (DEBUG) {\n            System.out.println(\"    limData.lb \u003d \" + limData.lb + \", limData.ub \u003d \" + limData.ub + \", limData.quantum \u003d \" + limData.quantum);\n        }\n        return limData;\n    }\n\n    /**\n     *  Find the position and size (in screen coordinates) of tick\n     *  marks for a given axis scale.\n     *\n     *  @param  quantum   Tick mark step size for the axis using this scale.\n     *  @param  aLB       Lower bounds of axis using this scale.\n     *  @param  aUB       Upper bounds of axis using this scale.\n     *  @param  xA        Scaling coefficient for this axis.\n     *  @param  xB        Scaling coefficient for this axis.\n     *  @return An TickMarkData object containing the tick mark positions, lengths,\n     *          and data values at each tick mark.\n     */\n    public TickMarkData calcTickMarks(double quantum, double aLB, double aUB, double xA, double xB) {\n        double xl \u003d 0;\n        double xu \u003d 0;\n        double q \u003d quantum;\n        if (q \u003e 0.) {\n            xl \u003d modfloor(aLB, q);\n            xu \u003d modfloor(aUB - q / 10., q / 5.) + q / 10.;\n        } else {\n            xl \u003d modfloor(aUB, q);\n            xu \u003d modfloor(aLB + q / 10., q / 5.) - q / 10.;\n        }\n        //\tDetermine the number of tick marks.\n        int xn \u003d (int) ((xu - xl) / (Math.abs(quantum) / 5.));\n        if (DEBUG) {\n            System.out.println(\"In calcTickMarks()...\");\n            System.out.println(\"    quantum \u003d \" + quantum + \", aLB \u003d \" + aLB + \", aUB \u003d \" + aUB);\n            System.out.println(\"    xA \u003d \" + xA + \", xB \u003d \" + xB);\n            System.out.println(\"    xl \u003d \" + xl + \", xu \u003d \" + xu);\n            System.out.println(\"    xn \u003d \" + xn);\n        }\n        //\tAllocate memory for tick mark arrays.\n        int[] mark \u003d new int[xn];\n        int[] lmark \u003d new int[xn];\n        float[] markValue \u003d new float[xn];\n        xn \u003d 0;\n        int i \u003d 0;\n        for (double x \u003d xl; x \u003c\u003d xu; x +\u003d Math.abs(quantum) / 5., ++i) {\n            //\tBounds check.\n            if (q \u003e 0.)\n                if (x \u003c\u003d aLB || x \u003e\u003d aUB)\n                    continue;\n            if (q \u003c 0.)\n                if (x \u003e\u003d aLB || x \u003c\u003d aUB)\n                    continue;\n            //\tStore tick mark.\n            mark[xn] \u003d (int) (func(x) * xA + xB);\n            markValue[xn] \u003d (float) x;\n            if (i % 5 !\u003d 0)\n                //\tMinor tick mark.\n                lmark[xn++] \u003d PlotAxis.kTick;\n            else\n                //\tMajor tick mark.\n                lmark[xn++] \u003d 3 * PlotAxis.kTick;\n        }\n        if (DEBUG) {\n            System.out.println(\"Tick mark values:\");\n            int length \u003d markValue.length;\n            for (i \u003d 0; i \u003c length; ++i) System.out.print(\"   \" + markValue[i]);\n            System.out.println();\n        }\n        //\tCreate a tick mark data object and pass it out.\n        TickMarkData data \u003d new TickMarkData();\n        data.mark \u003d mark;\n        data.lmark \u003d lmark;\n        data.markValue \u003d markValue;\n        return data;\n    }\n\n    /**\n     *  Adjust the upper and lower axis bounds, if necissary, to allow\n     *  room for error bars on the specified data point.  New bounds\n     *  returned in \"output\" object.\n     *\n     *  @param datum  The data point we are bounds checking.\n     *  @param aUB    The current upper bounds.\n     *  @param aLB    The current lower bounds.\n     *  @param output An AxisLimitData structure for passing the new upper and\n     *                lower bounds to the calling routine.\n     */\n    public void adjustForErrorBars(PlotDatum datum, double aUB, double aLB, AxisLimitData output) {\n        double temp \u003d datum.getYError();\n        aLB \u003d Math.min(aLB, datum.y - temp);\n        aUB \u003d Math.max(aUB, datum.y + temp);\n        output.lb \u003d aLB;\n        output.ub \u003d aUB;\n    }\n\n    private double modceil(double f, double t) {\n        t \u003d Math.abs(t);\n        return (Math.ceil(f / t) * t);\n    }\n\n    private double modfloor(double f, double t) {\n        t \u003d Math.abs(t);\n        return (Math.floor(f / t) * t);\n    }\n}\n",
    "package": "jahuwaldt.plot",
    "classname": "LinearAxisScale",
    "id": "/EvoSuiteBenchmark/original/29_apbsmem/src/main/java/jahuwaldt/plot/LinearAxisScale_2Test.java",
    "test_prompt": "// LinearAxisScale_2Test.java\npackage jahuwaldt.plot;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LinearAxisScale}.\n* It contains ten unit test cases for the {@link LinearAxisScale#upperBounds()} method.\n*/\nclass LinearAxisScale_2Test {",
    "method_signature": "upperBounds()",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// LinearAxisScale.java\n/*\n*   LinearAxisScale  -- Provides linear axis scaling for plot axes.\n*\n*   Copyright (C) 2000-2002 by Joseph A. Huwaldt \u003cjhuwaldt@knology.net\u003e.\n*   All rights reserved.\n*   \n*   This library is free software; you can redistribute it and/or\n*   modify it under the terms of the GNU Library General Public\n*   License as published by the Free Software Foundation; either\n*   version 2 of the License, or (at your option) any later version.\n*   \n*   This library is distributed in the hope that it will be useful,\n*   but WITHOUT ANY WARRANTY; without even the implied warranty of\n*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n*   Library General Public License for more details.\n**/\npackage jahuwaldt.plot;\n\n/**\n *  \u003cp\u003e This object provides linear scaling for plot axes.\n *  \u003c/p\u003e\n *\n *  \u003cp\u003e  Modified by:  Joseph A. Huwaldt  \u003c/p\u003e\n *\n *  @author  Joseph A. Huwaldt   Date:  September 13, 2000\n *  @version January 10, 2001\n */\npublic class LinearAxisScale extends Object implements PlotAxisScale {\n\n    //\tDebug flag.\n    private static final boolean DEBUG \u003d false;\n\n    /**\n     *  The transformation function used to scale the data\n     *  plotted against this axis.\n     *  This axis uses a linear scaling function:  f(a) \u003d a.\n     */\n    public final double func(double a) {\n        return a;\n    }\n\n    /**\n     *  Method that returns the default lower bounds for\n     *  this axis scale.  Returns -1.0.\n     */\n    public double lowerBounds() {\n        return -1.0;\n    }\n\n    /**\n     *  Method that returns the default upper bounds for\n     *  this axis scale.  Returns 1.0.\n     */\n    public double upperBounds() {\n        return 1.0;\n    }\n\n    /**\n     *  Method that returns an AxisLimitData object that contains\n     *  the preferred axis limits and tick mark spacing for the\n     *  specified range of data values for this linear axis scale.\n     *\n     *  @param  aLB  The lower bounds of the data plotted on this axis.\n     *  @param  aUB  The upper bounds of the data plotted on this axis.\n     */\n    public AxisLimitData findGoodLimits(double aLB, double aUB) {\n        //\tThe lower limit and tick mark spacing being calculated.\n        double s \u003d 0., r \u003d 0.;\n        //\tMake sure we don\u0027t have a degenerate case.\n        if (Math.abs(aUB - aLB) \u003c\u003d 0.000001) {\n            if (aUB \u003e 0.) {\n                aUB \u003d 2. * aUB;\n                aLB \u003d 0.;\n            } else if (aLB \u003c 0) {\n                aLB \u003d 2. * aLB;\n                aUB \u003d 0.;\n            }\n            if (Math.abs(aUB - aLB) \u003c\u003d 0.000001) {\n                aLB \u003d lowerBounds();\n                aUB \u003d upperBounds();\n            }\n        }\n        if (DEBUG) {\n            System.out.println(\"In findGoodLimits()...\");\n            System.out.println(\"   aLB \u003d \" + aLB + \", aUB \u003d \" + aUB);\n        }\n        //\tObject used to return results.\n        AxisLimitData limData \u003d new AxisLimitData();\n        boolean done \u003d false;\n        while (!done) {\n            done \u003d true;\n            double ub \u003d aUB;\n            double lb \u003d aLB;\n            double delta \u003d ub - lb;\n            //\tScale up by s, a power of 10, so range (delta) exceeds 1.\n            s \u003d 1.;\n            while (delta * s \u003c 10.) s *\u003d 10.;\n            //\tFind power of 10 quantum, r, such that delta/10 \u003c\u003d r \u003c delta.\n            r \u003d 1. / s;\n            while (10. * r \u003c delta) r *\u003d 10.;\n            //\tSet r\u003d(1,2,5)*10**n so that 3-5 quanta cover range.\n            if (r \u003e\u003d delta / 2.)\n                r /\u003d 2.;\n            else if (r \u003c delta / 5.)\n                r *\u003d 2.;\n            limData.ub \u003d modceil(ub, r);\n            limData.lb \u003d modfloor(lb, r);\n            //\tIf lower bound is \u003c\u003d r and \u003e 0, then repeat.\n            if (limData.lb \u003c\u003d r \u0026\u0026 limData.lb \u003e 0.) {\n                aLB \u003d 0.;\n                done \u003d false;\n                //\tIf upper bound \u003e\u003d -r and \u003c 0, then repeat.\n            } else if (limData.ub \u003e\u003d -r \u0026\u0026 limData.ub \u003c 0.) {\n                aUB \u003d 0.;\n                done \u003d false;\n            }\n        }\n        //\tSave off tick mark spacing.\n        limData.quantum \u003d r;\n        if (DEBUG) {\n            System.out.println(\"    limData.lb \u003d \" + limData.lb + \", limData.ub \u003d \" + limData.ub + \", limData.quantum \u003d \" + limData.quantum);\n        }\n        return limData;\n    }\n\n    /**\n     *  Find the position and size (in screen coordinates) of tick\n     *  marks for a given axis scale.\n     *\n     *  @param  quantum   Tick mark step size for the axis using this scale.\n     *  @param  aLB       Lower bounds of axis using this scale.\n     *  @param  aUB       Upper bounds of axis using this scale.\n     *  @param  xA        Scaling coefficient for this axis.\n     *  @param  xB        Scaling coefficient for this axis.\n     *  @return An TickMarkData object containing the tick mark positions, lengths,\n     *          and data values at each tick mark.\n     */\n    public TickMarkData calcTickMarks(double quantum, double aLB, double aUB, double xA, double xB) {\n        double xl \u003d 0;\n        double xu \u003d 0;\n        double q \u003d quantum;\n        if (q \u003e 0.) {\n            xl \u003d modfloor(aLB, q);\n            xu \u003d modfloor(aUB - q / 10., q / 5.) + q / 10.;\n        } else {\n            xl \u003d modfloor(aUB, q);\n            xu \u003d modfloor(aLB + q / 10., q / 5.) - q / 10.;\n        }\n        //\tDetermine the number of tick marks.\n        int xn \u003d (int) ((xu - xl) / (Math.abs(quantum) / 5.));\n        if (DEBUG) {\n            System.out.println(\"In calcTickMarks()...\");\n            System.out.println(\"    quantum \u003d \" + quantum + \", aLB \u003d \" + aLB + \", aUB \u003d \" + aUB);\n            System.out.println(\"    xA \u003d \" + xA + \", xB \u003d \" + xB);\n            System.out.println(\"    xl \u003d \" + xl + \", xu \u003d \" + xu);\n            System.out.println(\"    xn \u003d \" + xn);\n        }\n        //\tAllocate memory for tick mark arrays.\n        int[] mark \u003d new int[xn];\n        int[] lmark \u003d new int[xn];\n        float[] markValue \u003d new float[xn];\n        xn \u003d 0;\n        int i \u003d 0;\n        for (double x \u003d xl; x \u003c\u003d xu; x +\u003d Math.abs(quantum) / 5., ++i) {\n            //\tBounds check.\n            if (q \u003e 0.)\n                if (x \u003c\u003d aLB || x \u003e\u003d aUB)\n                    continue;\n            if (q \u003c 0.)\n                if (x \u003e\u003d aLB || x \u003c\u003d aUB)\n                    continue;\n            //\tStore tick mark.\n            mark[xn] \u003d (int) (func(x) * xA + xB);\n            markValue[xn] \u003d (float) x;\n            if (i % 5 !\u003d 0)\n                //\tMinor tick mark.\n                lmark[xn++] \u003d PlotAxis.kTick;\n            else\n                //\tMajor tick mark.\n                lmark[xn++] \u003d 3 * PlotAxis.kTick;\n        }\n        if (DEBUG) {\n            System.out.println(\"Tick mark values:\");\n            int length \u003d markValue.length;\n            for (i \u003d 0; i \u003c length; ++i) System.out.print(\"   \" + markValue[i]);\n            System.out.println();\n        }\n        //\tCreate a tick mark data object and pass it out.\n        TickMarkData data \u003d new TickMarkData();\n        data.mark \u003d mark;\n        data.lmark \u003d lmark;\n        data.markValue \u003d markValue;\n        return data;\n    }\n\n    /**\n     *  Adjust the upper and lower axis bounds, if necissary, to allow\n     *  room for error bars on the specified data point.  New bounds\n     *  returned in \"output\" object.\n     *\n     *  @param datum  The data point we are bounds checking.\n     *  @param aUB    The current upper bounds.\n     *  @param aLB    The current lower bounds.\n     *  @param output An AxisLimitData structure for passing the new upper and\n     *                lower bounds to the calling routine.\n     */\n    public void adjustForErrorBars(PlotDatum datum, double aUB, double aLB, AxisLimitData output) {\n        double temp \u003d datum.getYError();\n        aLB \u003d Math.min(aLB, datum.y - temp);\n        aUB \u003d Math.max(aUB, datum.y + temp);\n        output.lb \u003d aLB;\n        output.ub \u003d aUB;\n    }\n\n    private double modceil(double f, double t) {\n        t \u003d Math.abs(t);\n        return (Math.ceil(f / t) * t);\n    }\n\n    private double modfloor(double f, double t) {\n        t \u003d Math.abs(t);\n        return (Math.floor(f / t) * t);\n    }\n}\n",
    "package": "jahuwaldt.plot",
    "classname": "LinearAxisScale",
    "id": "/EvoSuiteBenchmark/original/29_apbsmem/src/main/java/jahuwaldt/plot/LinearAxisScale_3Test.java",
    "test_prompt": "// LinearAxisScale_3Test.java\npackage jahuwaldt.plot;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LinearAxisScale}.\n* It contains ten unit test cases for the {@link LinearAxisScale#findGoodLimits(double, double)} method.\n*/\nclass LinearAxisScale_3Test {",
    "method_signature": "findGoodLimits(double, double)",
    "suffix": "3"
  },
  {
    "numberTests": "ten",
    "original_code": "// LinearAxisScale.java\n/*\n*   LinearAxisScale  -- Provides linear axis scaling for plot axes.\n*\n*   Copyright (C) 2000-2002 by Joseph A. Huwaldt \u003cjhuwaldt@knology.net\u003e.\n*   All rights reserved.\n*   \n*   This library is free software; you can redistribute it and/or\n*   modify it under the terms of the GNU Library General Public\n*   License as published by the Free Software Foundation; either\n*   version 2 of the License, or (at your option) any later version.\n*   \n*   This library is distributed in the hope that it will be useful,\n*   but WITHOUT ANY WARRANTY; without even the implied warranty of\n*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n*   Library General Public License for more details.\n**/\npackage jahuwaldt.plot;\n\n/**\n *  \u003cp\u003e This object provides linear scaling for plot axes.\n *  \u003c/p\u003e\n *\n *  \u003cp\u003e  Modified by:  Joseph A. Huwaldt  \u003c/p\u003e\n *\n *  @author  Joseph A. Huwaldt   Date:  September 13, 2000\n *  @version January 10, 2001\n */\npublic class LinearAxisScale extends Object implements PlotAxisScale {\n\n    //\tDebug flag.\n    private static final boolean DEBUG \u003d false;\n\n    /**\n     *  The transformation function used to scale the data\n     *  plotted against this axis.\n     *  This axis uses a linear scaling function:  f(a) \u003d a.\n     */\n    public final double func(double a) {\n        return a;\n    }\n\n    /**\n     *  Method that returns the default lower bounds for\n     *  this axis scale.  Returns -1.0.\n     */\n    public double lowerBounds() {\n        return -1.0;\n    }\n\n    /**\n     *  Method that returns the default upper bounds for\n     *  this axis scale.  Returns 1.0.\n     */\n    public double upperBounds() {\n        return 1.0;\n    }\n\n    /**\n     *  Method that returns an AxisLimitData object that contains\n     *  the preferred axis limits and tick mark spacing for the\n     *  specified range of data values for this linear axis scale.\n     *\n     *  @param  aLB  The lower bounds of the data plotted on this axis.\n     *  @param  aUB  The upper bounds of the data plotted on this axis.\n     */\n    public AxisLimitData findGoodLimits(double aLB, double aUB) {\n        //\tThe lower limit and tick mark spacing being calculated.\n        double s \u003d 0., r \u003d 0.;\n        //\tMake sure we don\u0027t have a degenerate case.\n        if (Math.abs(aUB - aLB) \u003c\u003d 0.000001) {\n            if (aUB \u003e 0.) {\n                aUB \u003d 2. * aUB;\n                aLB \u003d 0.;\n            } else if (aLB \u003c 0) {\n                aLB \u003d 2. * aLB;\n                aUB \u003d 0.;\n            }\n            if (Math.abs(aUB - aLB) \u003c\u003d 0.000001) {\n                aLB \u003d lowerBounds();\n                aUB \u003d upperBounds();\n            }\n        }\n        if (DEBUG) {\n            System.out.println(\"In findGoodLimits()...\");\n            System.out.println(\"   aLB \u003d \" + aLB + \", aUB \u003d \" + aUB);\n        }\n        //\tObject used to return results.\n        AxisLimitData limData \u003d new AxisLimitData();\n        boolean done \u003d false;\n        while (!done) {\n            done \u003d true;\n            double ub \u003d aUB;\n            double lb \u003d aLB;\n            double delta \u003d ub - lb;\n            //\tScale up by s, a power of 10, so range (delta) exceeds 1.\n            s \u003d 1.;\n            while (delta * s \u003c 10.) s *\u003d 10.;\n            //\tFind power of 10 quantum, r, such that delta/10 \u003c\u003d r \u003c delta.\n            r \u003d 1. / s;\n            while (10. * r \u003c delta) r *\u003d 10.;\n            //\tSet r\u003d(1,2,5)*10**n so that 3-5 quanta cover range.\n            if (r \u003e\u003d delta / 2.)\n                r /\u003d 2.;\n            else if (r \u003c delta / 5.)\n                r *\u003d 2.;\n            limData.ub \u003d modceil(ub, r);\n            limData.lb \u003d modfloor(lb, r);\n            //\tIf lower bound is \u003c\u003d r and \u003e 0, then repeat.\n            if (limData.lb \u003c\u003d r \u0026\u0026 limData.lb \u003e 0.) {\n                aLB \u003d 0.;\n                done \u003d false;\n                //\tIf upper bound \u003e\u003d -r and \u003c 0, then repeat.\n            } else if (limData.ub \u003e\u003d -r \u0026\u0026 limData.ub \u003c 0.) {\n                aUB \u003d 0.;\n                done \u003d false;\n            }\n        }\n        //\tSave off tick mark spacing.\n        limData.quantum \u003d r;\n        if (DEBUG) {\n            System.out.println(\"    limData.lb \u003d \" + limData.lb + \", limData.ub \u003d \" + limData.ub + \", limData.quantum \u003d \" + limData.quantum);\n        }\n        return limData;\n    }\n\n    /**\n     *  Find the position and size (in screen coordinates) of tick\n     *  marks for a given axis scale.\n     *\n     *  @param  quantum   Tick mark step size for the axis using this scale.\n     *  @param  aLB       Lower bounds of axis using this scale.\n     *  @param  aUB       Upper bounds of axis using this scale.\n     *  @param  xA        Scaling coefficient for this axis.\n     *  @param  xB        Scaling coefficient for this axis.\n     *  @return An TickMarkData object containing the tick mark positions, lengths,\n     *          and data values at each tick mark.\n     */\n    public TickMarkData calcTickMarks(double quantum, double aLB, double aUB, double xA, double xB) {\n        double xl \u003d 0;\n        double xu \u003d 0;\n        double q \u003d quantum;\n        if (q \u003e 0.) {\n            xl \u003d modfloor(aLB, q);\n            xu \u003d modfloor(aUB - q / 10., q / 5.) + q / 10.;\n        } else {\n            xl \u003d modfloor(aUB, q);\n            xu \u003d modfloor(aLB + q / 10., q / 5.) - q / 10.;\n        }\n        //\tDetermine the number of tick marks.\n        int xn \u003d (int) ((xu - xl) / (Math.abs(quantum) / 5.));\n        if (DEBUG) {\n            System.out.println(\"In calcTickMarks()...\");\n            System.out.println(\"    quantum \u003d \" + quantum + \", aLB \u003d \" + aLB + \", aUB \u003d \" + aUB);\n            System.out.println(\"    xA \u003d \" + xA + \", xB \u003d \" + xB);\n            System.out.println(\"    xl \u003d \" + xl + \", xu \u003d \" + xu);\n            System.out.println(\"    xn \u003d \" + xn);\n        }\n        //\tAllocate memory for tick mark arrays.\n        int[] mark \u003d new int[xn];\n        int[] lmark \u003d new int[xn];\n        float[] markValue \u003d new float[xn];\n        xn \u003d 0;\n        int i \u003d 0;\n        for (double x \u003d xl; x \u003c\u003d xu; x +\u003d Math.abs(quantum) / 5., ++i) {\n            //\tBounds check.\n            if (q \u003e 0.)\n                if (x \u003c\u003d aLB || x \u003e\u003d aUB)\n                    continue;\n            if (q \u003c 0.)\n                if (x \u003e\u003d aLB || x \u003c\u003d aUB)\n                    continue;\n            //\tStore tick mark.\n            mark[xn] \u003d (int) (func(x) * xA + xB);\n            markValue[xn] \u003d (float) x;\n            if (i % 5 !\u003d 0)\n                //\tMinor tick mark.\n                lmark[xn++] \u003d PlotAxis.kTick;\n            else\n                //\tMajor tick mark.\n                lmark[xn++] \u003d 3 * PlotAxis.kTick;\n        }\n        if (DEBUG) {\n            System.out.println(\"Tick mark values:\");\n            int length \u003d markValue.length;\n            for (i \u003d 0; i \u003c length; ++i) System.out.print(\"   \" + markValue[i]);\n            System.out.println();\n        }\n        //\tCreate a tick mark data object and pass it out.\n        TickMarkData data \u003d new TickMarkData();\n        data.mark \u003d mark;\n        data.lmark \u003d lmark;\n        data.markValue \u003d markValue;\n        return data;\n    }\n\n    /**\n     *  Adjust the upper and lower axis bounds, if necissary, to allow\n     *  room for error bars on the specified data point.  New bounds\n     *  returned in \"output\" object.\n     *\n     *  @param datum  The data point we are bounds checking.\n     *  @param aUB    The current upper bounds.\n     *  @param aLB    The current lower bounds.\n     *  @param output An AxisLimitData structure for passing the new upper and\n     *                lower bounds to the calling routine.\n     */\n    public void adjustForErrorBars(PlotDatum datum, double aUB, double aLB, AxisLimitData output) {\n        double temp \u003d datum.getYError();\n        aLB \u003d Math.min(aLB, datum.y - temp);\n        aUB \u003d Math.max(aUB, datum.y + temp);\n        output.lb \u003d aLB;\n        output.ub \u003d aUB;\n    }\n\n    private double modceil(double f, double t) {\n        t \u003d Math.abs(t);\n        return (Math.ceil(f / t) * t);\n    }\n\n    private double modfloor(double f, double t) {\n        t \u003d Math.abs(t);\n        return (Math.floor(f / t) * t);\n    }\n}\n",
    "package": "jahuwaldt.plot",
    "classname": "LinearAxisScale",
    "id": "/EvoSuiteBenchmark/original/29_apbsmem/src/main/java/jahuwaldt/plot/LinearAxisScale_4Test.java",
    "test_prompt": "// LinearAxisScale_4Test.java\npackage jahuwaldt.plot;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LinearAxisScale}.\n* It contains ten unit test cases for the {@link LinearAxisScale#calcTickMarks(double, double, double, double, double)} method.\n*/\nclass LinearAxisScale_4Test {",
    "method_signature": "calcTickMarks(double, double, double, double, double)",
    "suffix": "4"
  },
  {
    "numberTests": "ten",
    "original_code": "// PlotRun.java\n/*\n*   PlotRun  -- Container for a list of plot data points.\n*\n*   Copyright (C) 2000-2002 by Joseph A. Huwaldt \u003cjhuwaldt@knology.net\u003e.\n*   All rights reserved.\n*   \n*   This library is free software; you can redistribute it and/or\n*   modify it under the terms of the GNU Library General Public\n*   License as published by the Free Software Foundation; either\n*   version 2 of the License, or (at your option) any later version.\n*   \n*   This library is distributed in the hope that it will be useful,\n*   but WITHOUT ANY WARRANTY; without even the implied warranty of\n*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n*   Library General Public License for more details.\n**/\npackage jahuwaldt.plot;\n\nimport java.awt.Color;\nimport java.util.*;\n\n/**\n *  \u003cp\u003e This class represents a single run of data in a plot.\n *      A run is an array or list of PlotDatum objects.\n *  \u003c/p\u003e\n *\n *  \u003cp\u003e  Modified by:  Joseph A. Huwaldt  \u003c/p\u003e\n *\n *  @author  Joseph A. Huwaldt   Date:  September 13, 2000\n *  @version December 12, 2000\n */\npublic class PlotRun extends AbstractList implements Cloneable, java.io.Serializable {\n\n    /**\n     *  The plot datum objects are stored in an ArrayList.\n     */\n    private List data \u003d new ArrayList();\n\n    //-------------------------------------------------------------------------\n    /**\n     *  Create an empty run that contains no data.\n     */\n    public PlotRun() {\n    }\n\n    /**\n     *  Create a run that contains the specified array of PlotDatum objects.\n     *\n     *  @param run  An array of PlotDatum objects that make up a run of data\n     *              to be plotted.\n     */\n    public PlotRun(PlotDatum[] run) {\n        int length \u003d run.length;\n        for (int i \u003d 0; i \u003c length; ++i) data.add(run[i]);\n    }\n\n    /**\n     *  Create a run from a set of Java arrays for the X \u0026 Y data.\n     *\n     *  @param  xArr  An array containing the X coordinates of the data points\n     *                to be plotted.\n     *  @param  yArr  An array containing the Y coordinates of the data points\n     *                to be plotted.\n     *  @param  connectFlg  Set to true to have the points in the X \u0026 Y arrays\n     *                      connected by a line, false for them to not be connected.\n     *  @param  symbol      The plot symbol to use for the plotted points.\n     *\n     *  @throws NullPointerException if either array is null.\n     *  @throws ArrayIndexOutOfBoundsException if the X and Y arrays are not the\n     *          same length.\n     */\n    public PlotRun(double[] xArr, double[] yArr, boolean connectFlg, PlotSymbol symbol) {\n        if (xArr \u003d\u003d null || yArr \u003d\u003d null)\n            throw new NullPointerException();\n        int length \u003d xArr.length;\n        if (yArr.length !\u003d length)\n            throw new ArrayIndexOutOfBoundsException();\n        for (int i \u003d 0; i \u003c length; ++i) {\n            data.add(new PlotDatum(xArr[i], yArr[i], connectFlg, symbol));\n        }\n    }\n\n    /**\n     *  Create a run that contains the PlotDatum objects in the specified\n     *  Collection.\n     *\n     *  @param data  An Collection containing PlotDatum objects.\n     */\n    public PlotRun(Collection run) {\n        if (run instanceof PlotRun)\n            data.addAll(run);\n        else {\n            for (Iterator i \u003d run.iterator(); i.hasNext(); ) {\n                Object obj \u003d i.next();\n                if (obj instanceof PlotDatum)\n                    data.add(obj);\n            }\n        }\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     *  Return the minimum X value of the data contained in this run.\n     */\n    public double getMinX() {\n        double min \u003d Double.MAX_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            min \u003d Math.min(min, datum.x);\n        }\n        return min;\n    }\n\n    /**\n     *  Return the maximum X value of the data contained in this run.\n     */\n    public double getMaxX() {\n        double max \u003d Double.MIN_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            max \u003d Math.max(max, datum.x);\n        }\n        return max;\n    }\n\n    /**\n     *  Return the minimum Y value of the data contained in this run.\n     */\n    public double getMinY() {\n        double min \u003d Double.MAX_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            min \u003d Math.min(min, datum.y);\n        }\n        return min;\n    }\n\n    /**\n     *  Return the maximum Y value of the data contained in this run.\n     */\n    public double getMaxY() {\n        double max \u003d Double.MIN_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            max \u003d Math.max(max, datum.y);\n        }\n        return max;\n    }\n\n    /**\n     *  Use this method to change the plot symbol used by all\n     *  the plot data points in this run.\n     */\n    public void setPlotSymbol(PlotSymbol symbol) {\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            datum.setPlotSymbol(symbol);\n        }\n    }\n\n    /**\n     *  Use this method to change the line color used by all\n     *  the plot data points in this run.\n     */\n    public void setLineColor(Color color) {\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            datum.setLineColor(color);\n        }\n    }\n\n    //**** Methods required to implement AbstractList  ******\n    /**\n     *  Returns the number of PlotDatum objects in this run.\n     *\n     *  @return The number of plot data objects in this run.\n     */\n    public int size() {\n        return data.size();\n    }\n\n    /**\n     *  Returns the PlotDatum object at the specified position\n     *  in this run.\n     *\n     *  @param   index  The index of the plot data object to return.\n     *  @return  The PlotDatum object at the specified position\n     *           in this run.\n     */\n    public Object get(int index) {\n        return data.get(index);\n    }\n\n    /**\n     *  Replaces the plot data element at the specified position\n     *  in this run with the specified datum.\n     *\n     *  @param   index   The index of the data element to replace.\n     *  @param   element The datum to be stored a the specified position.\n     *  @return  The datum previously at the specified position in this run.\n     *  @throws  ClassCastException - if the specified element is not a\n     *                                PlotDatum type object.\n     */\n    public Object set(int index, Object element) {\n        PlotDatum obj \u003d (PlotDatum) element;\n        return data.set(index, element);\n    }\n\n    /**\n     *  Inserts the specified plot data element at the specified\n     *  position in this run.  Shifts the plot data element\n     *  currently at that position (if any) and any subsequent\n     *  data elements to the right (adds one to their indices).\n     *\n     *  @param  index   Index at which the specified datum is to be\n     *                  inserted.\n     *  @param  element PlotDatum object to be inserted.\n     *  @throws ClassCastException - if the specified element is not a\n     *                               PlotDatum type object.\n     */\n    public void add(int index, Object element) {\n        PlotDatum obj \u003d (PlotDatum) element;\n        data.add(index, element);\n    }\n\n    /**\n     *  Remove the plot data object at the specified position in\n     *  this run.  Shifts any subsequent data elements\n     *  to the left (subtracts one from their indices).  Returns the\n     *  data element that was removed from this run.\n     *\n     *  @param   index  The index of the plot data element to remove.\n     *  @return  The PlotDatum object previously at the specified position.\n     */\n    public Object remove(int index) {\n        return data.remove(index);\n    }\n\n    /**\n     *  Removes all the plot data elements from this run.\n     *  The run will be empty after this call returns\n     *  (unless it throws an exception).\n     */\n    public void clear() {\n        data.clear();\n    }\n\n    /**\n     *  Return an enumeration of all the plot data elements in\n     *  this run.\n     *\n     *  @return An interation of all the PlotDatum objects in this run.\n     */\n    public Iterator iterator() {\n        return data.iterator();\n    }\n\n    /**\n     *  Make a copy of this PlotRun object.\n     *\n     *  @return  Returns a clone of this object.\n     */\n    public Object clone() {\n        PlotRun newObject \u003d null;\n        try {\n            // Make a shallow copy of this object.\n            newObject \u003d (PlotRun) super.clone();\n            // Now clone the data points attached to this run.\n            newObject.data \u003d new ArrayList();\n            int size \u003d this.data.size();\n            for (int i \u003d 0; i \u003c size; ++i) {\n                Object datum \u003d ((PlotDatum) this.data.get(i)).clone();\n                newObject.data.add(datum);\n            }\n        } catch (CloneNotSupportedException e) {\n            // Can\u0027t happen.\n            e.printStackTrace();\n        }\n        // Output the newly cloned object.\n        return newObject;\n    }\n}\n",
    "package": "jahuwaldt.plot",
    "classname": "PlotRun",
    "id": "/EvoSuiteBenchmark/original/29_apbsmem/src/main/java/jahuwaldt/plot/PlotRun_0Test.java",
    "test_prompt": "// PlotRun_0Test.java\npackage jahuwaldt.plot;\n\nimport java.awt.Color;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PlotRun}.\n* It contains ten unit test cases for the {@link PlotRun#size()} method.\n*/\nclass PlotRun_0Test {",
    "method_signature": "size()",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// PlotRun.java\n/*\n*   PlotRun  -- Container for a list of plot data points.\n*\n*   Copyright (C) 2000-2002 by Joseph A. Huwaldt \u003cjhuwaldt@knology.net\u003e.\n*   All rights reserved.\n*   \n*   This library is free software; you can redistribute it and/or\n*   modify it under the terms of the GNU Library General Public\n*   License as published by the Free Software Foundation; either\n*   version 2 of the License, or (at your option) any later version.\n*   \n*   This library is distributed in the hope that it will be useful,\n*   but WITHOUT ANY WARRANTY; without even the implied warranty of\n*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n*   Library General Public License for more details.\n**/\npackage jahuwaldt.plot;\n\nimport java.awt.Color;\nimport java.util.*;\n\n/**\n *  \u003cp\u003e This class represents a single run of data in a plot.\n *      A run is an array or list of PlotDatum objects.\n *  \u003c/p\u003e\n *\n *  \u003cp\u003e  Modified by:  Joseph A. Huwaldt  \u003c/p\u003e\n *\n *  @author  Joseph A. Huwaldt   Date:  September 13, 2000\n *  @version December 12, 2000\n */\npublic class PlotRun extends AbstractList implements Cloneable, java.io.Serializable {\n\n    /**\n     *  The plot datum objects are stored in an ArrayList.\n     */\n    private List data \u003d new ArrayList();\n\n    //-------------------------------------------------------------------------\n    /**\n     *  Create an empty run that contains no data.\n     */\n    public PlotRun() {\n    }\n\n    /**\n     *  Create a run that contains the specified array of PlotDatum objects.\n     *\n     *  @param run  An array of PlotDatum objects that make up a run of data\n     *              to be plotted.\n     */\n    public PlotRun(PlotDatum[] run) {\n        int length \u003d run.length;\n        for (int i \u003d 0; i \u003c length; ++i) data.add(run[i]);\n    }\n\n    /**\n     *  Create a run from a set of Java arrays for the X \u0026 Y data.\n     *\n     *  @param  xArr  An array containing the X coordinates of the data points\n     *                to be plotted.\n     *  @param  yArr  An array containing the Y coordinates of the data points\n     *                to be plotted.\n     *  @param  connectFlg  Set to true to have the points in the X \u0026 Y arrays\n     *                      connected by a line, false for them to not be connected.\n     *  @param  symbol      The plot symbol to use for the plotted points.\n     *\n     *  @throws NullPointerException if either array is null.\n     *  @throws ArrayIndexOutOfBoundsException if the X and Y arrays are not the\n     *          same length.\n     */\n    public PlotRun(double[] xArr, double[] yArr, boolean connectFlg, PlotSymbol symbol) {\n        if (xArr \u003d\u003d null || yArr \u003d\u003d null)\n            throw new NullPointerException();\n        int length \u003d xArr.length;\n        if (yArr.length !\u003d length)\n            throw new ArrayIndexOutOfBoundsException();\n        for (int i \u003d 0; i \u003c length; ++i) {\n            data.add(new PlotDatum(xArr[i], yArr[i], connectFlg, symbol));\n        }\n    }\n\n    /**\n     *  Create a run that contains the PlotDatum objects in the specified\n     *  Collection.\n     *\n     *  @param data  An Collection containing PlotDatum objects.\n     */\n    public PlotRun(Collection run) {\n        if (run instanceof PlotRun)\n            data.addAll(run);\n        else {\n            for (Iterator i \u003d run.iterator(); i.hasNext(); ) {\n                Object obj \u003d i.next();\n                if (obj instanceof PlotDatum)\n                    data.add(obj);\n            }\n        }\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     *  Return the minimum X value of the data contained in this run.\n     */\n    public double getMinX() {\n        double min \u003d Double.MAX_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            min \u003d Math.min(min, datum.x);\n        }\n        return min;\n    }\n\n    /**\n     *  Return the maximum X value of the data contained in this run.\n     */\n    public double getMaxX() {\n        double max \u003d Double.MIN_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            max \u003d Math.max(max, datum.x);\n        }\n        return max;\n    }\n\n    /**\n     *  Return the minimum Y value of the data contained in this run.\n     */\n    public double getMinY() {\n        double min \u003d Double.MAX_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            min \u003d Math.min(min, datum.y);\n        }\n        return min;\n    }\n\n    /**\n     *  Return the maximum Y value of the data contained in this run.\n     */\n    public double getMaxY() {\n        double max \u003d Double.MIN_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            max \u003d Math.max(max, datum.y);\n        }\n        return max;\n    }\n\n    /**\n     *  Use this method to change the plot symbol used by all\n     *  the plot data points in this run.\n     */\n    public void setPlotSymbol(PlotSymbol symbol) {\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            datum.setPlotSymbol(symbol);\n        }\n    }\n\n    /**\n     *  Use this method to change the line color used by all\n     *  the plot data points in this run.\n     */\n    public void setLineColor(Color color) {\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            datum.setLineColor(color);\n        }\n    }\n\n    //**** Methods required to implement AbstractList  ******\n    /**\n     *  Returns the number of PlotDatum objects in this run.\n     *\n     *  @return The number of plot data objects in this run.\n     */\n    public int size() {\n        return data.size();\n    }\n\n    /**\n     *  Returns the PlotDatum object at the specified position\n     *  in this run.\n     *\n     *  @param   index  The index of the plot data object to return.\n     *  @return  The PlotDatum object at the specified position\n     *           in this run.\n     */\n    public Object get(int index) {\n        return data.get(index);\n    }\n\n    /**\n     *  Replaces the plot data element at the specified position\n     *  in this run with the specified datum.\n     *\n     *  @param   index   The index of the data element to replace.\n     *  @param   element The datum to be stored a the specified position.\n     *  @return  The datum previously at the specified position in this run.\n     *  @throws  ClassCastException - if the specified element is not a\n     *                                PlotDatum type object.\n     */\n    public Object set(int index, Object element) {\n        PlotDatum obj \u003d (PlotDatum) element;\n        return data.set(index, element);\n    }\n\n    /**\n     *  Inserts the specified plot data element at the specified\n     *  position in this run.  Shifts the plot data element\n     *  currently at that position (if any) and any subsequent\n     *  data elements to the right (adds one to their indices).\n     *\n     *  @param  index   Index at which the specified datum is to be\n     *                  inserted.\n     *  @param  element PlotDatum object to be inserted.\n     *  @throws ClassCastException - if the specified element is not a\n     *                               PlotDatum type object.\n     */\n    public void add(int index, Object element) {\n        PlotDatum obj \u003d (PlotDatum) element;\n        data.add(index, element);\n    }\n\n    /**\n     *  Remove the plot data object at the specified position in\n     *  this run.  Shifts any subsequent data elements\n     *  to the left (subtracts one from their indices).  Returns the\n     *  data element that was removed from this run.\n     *\n     *  @param   index  The index of the plot data element to remove.\n     *  @return  The PlotDatum object previously at the specified position.\n     */\n    public Object remove(int index) {\n        return data.remove(index);\n    }\n\n    /**\n     *  Removes all the plot data elements from this run.\n     *  The run will be empty after this call returns\n     *  (unless it throws an exception).\n     */\n    public void clear() {\n        data.clear();\n    }\n\n    /**\n     *  Return an enumeration of all the plot data elements in\n     *  this run.\n     *\n     *  @return An interation of all the PlotDatum objects in this run.\n     */\n    public Iterator iterator() {\n        return data.iterator();\n    }\n\n    /**\n     *  Make a copy of this PlotRun object.\n     *\n     *  @return  Returns a clone of this object.\n     */\n    public Object clone() {\n        PlotRun newObject \u003d null;\n        try {\n            // Make a shallow copy of this object.\n            newObject \u003d (PlotRun) super.clone();\n            // Now clone the data points attached to this run.\n            newObject.data \u003d new ArrayList();\n            int size \u003d this.data.size();\n            for (int i \u003d 0; i \u003c size; ++i) {\n                Object datum \u003d ((PlotDatum) this.data.get(i)).clone();\n                newObject.data.add(datum);\n            }\n        } catch (CloneNotSupportedException e) {\n            // Can\u0027t happen.\n            e.printStackTrace();\n        }\n        // Output the newly cloned object.\n        return newObject;\n    }\n}\n",
    "package": "jahuwaldt.plot",
    "classname": "PlotRun",
    "id": "/EvoSuiteBenchmark/original/29_apbsmem/src/main/java/jahuwaldt/plot/PlotRun_1Test.java",
    "test_prompt": "// PlotRun_1Test.java\npackage jahuwaldt.plot;\n\nimport java.awt.Color;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PlotRun}.\n* It contains ten unit test cases for the {@link PlotRun#get(int)} method.\n*/\nclass PlotRun_1Test {",
    "method_signature": "get(int)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// PlotRun.java\n/*\n*   PlotRun  -- Container for a list of plot data points.\n*\n*   Copyright (C) 2000-2002 by Joseph A. Huwaldt \u003cjhuwaldt@knology.net\u003e.\n*   All rights reserved.\n*   \n*   This library is free software; you can redistribute it and/or\n*   modify it under the terms of the GNU Library General Public\n*   License as published by the Free Software Foundation; either\n*   version 2 of the License, or (at your option) any later version.\n*   \n*   This library is distributed in the hope that it will be useful,\n*   but WITHOUT ANY WARRANTY; without even the implied warranty of\n*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n*   Library General Public License for more details.\n**/\npackage jahuwaldt.plot;\n\nimport java.awt.Color;\nimport java.util.*;\n\n/**\n *  \u003cp\u003e This class represents a single run of data in a plot.\n *      A run is an array or list of PlotDatum objects.\n *  \u003c/p\u003e\n *\n *  \u003cp\u003e  Modified by:  Joseph A. Huwaldt  \u003c/p\u003e\n *\n *  @author  Joseph A. Huwaldt   Date:  September 13, 2000\n *  @version December 12, 2000\n */\npublic class PlotRun extends AbstractList implements Cloneable, java.io.Serializable {\n\n    /**\n     *  The plot datum objects are stored in an ArrayList.\n     */\n    private List data \u003d new ArrayList();\n\n    //-------------------------------------------------------------------------\n    /**\n     *  Create an empty run that contains no data.\n     */\n    public PlotRun() {\n    }\n\n    /**\n     *  Create a run that contains the specified array of PlotDatum objects.\n     *\n     *  @param run  An array of PlotDatum objects that make up a run of data\n     *              to be plotted.\n     */\n    public PlotRun(PlotDatum[] run) {\n        int length \u003d run.length;\n        for (int i \u003d 0; i \u003c length; ++i) data.add(run[i]);\n    }\n\n    /**\n     *  Create a run from a set of Java arrays for the X \u0026 Y data.\n     *\n     *  @param  xArr  An array containing the X coordinates of the data points\n     *                to be plotted.\n     *  @param  yArr  An array containing the Y coordinates of the data points\n     *                to be plotted.\n     *  @param  connectFlg  Set to true to have the points in the X \u0026 Y arrays\n     *                      connected by a line, false for them to not be connected.\n     *  @param  symbol      The plot symbol to use for the plotted points.\n     *\n     *  @throws NullPointerException if either array is null.\n     *  @throws ArrayIndexOutOfBoundsException if the X and Y arrays are not the\n     *          same length.\n     */\n    public PlotRun(double[] xArr, double[] yArr, boolean connectFlg, PlotSymbol symbol) {\n        if (xArr \u003d\u003d null || yArr \u003d\u003d null)\n            throw new NullPointerException();\n        int length \u003d xArr.length;\n        if (yArr.length !\u003d length)\n            throw new ArrayIndexOutOfBoundsException();\n        for (int i \u003d 0; i \u003c length; ++i) {\n            data.add(new PlotDatum(xArr[i], yArr[i], connectFlg, symbol));\n        }\n    }\n\n    /**\n     *  Create a run that contains the PlotDatum objects in the specified\n     *  Collection.\n     *\n     *  @param data  An Collection containing PlotDatum objects.\n     */\n    public PlotRun(Collection run) {\n        if (run instanceof PlotRun)\n            data.addAll(run);\n        else {\n            for (Iterator i \u003d run.iterator(); i.hasNext(); ) {\n                Object obj \u003d i.next();\n                if (obj instanceof PlotDatum)\n                    data.add(obj);\n            }\n        }\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     *  Return the minimum X value of the data contained in this run.\n     */\n    public double getMinX() {\n        double min \u003d Double.MAX_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            min \u003d Math.min(min, datum.x);\n        }\n        return min;\n    }\n\n    /**\n     *  Return the maximum X value of the data contained in this run.\n     */\n    public double getMaxX() {\n        double max \u003d Double.MIN_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            max \u003d Math.max(max, datum.x);\n        }\n        return max;\n    }\n\n    /**\n     *  Return the minimum Y value of the data contained in this run.\n     */\n    public double getMinY() {\n        double min \u003d Double.MAX_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            min \u003d Math.min(min, datum.y);\n        }\n        return min;\n    }\n\n    /**\n     *  Return the maximum Y value of the data contained in this run.\n     */\n    public double getMaxY() {\n        double max \u003d Double.MIN_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            max \u003d Math.max(max, datum.y);\n        }\n        return max;\n    }\n\n    /**\n     *  Use this method to change the plot symbol used by all\n     *  the plot data points in this run.\n     */\n    public void setPlotSymbol(PlotSymbol symbol) {\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            datum.setPlotSymbol(symbol);\n        }\n    }\n\n    /**\n     *  Use this method to change the line color used by all\n     *  the plot data points in this run.\n     */\n    public void setLineColor(Color color) {\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            datum.setLineColor(color);\n        }\n    }\n\n    //**** Methods required to implement AbstractList  ******\n    /**\n     *  Returns the number of PlotDatum objects in this run.\n     *\n     *  @return The number of plot data objects in this run.\n     */\n    public int size() {\n        return data.size();\n    }\n\n    /**\n     *  Returns the PlotDatum object at the specified position\n     *  in this run.\n     *\n     *  @param   index  The index of the plot data object to return.\n     *  @return  The PlotDatum object at the specified position\n     *           in this run.\n     */\n    public Object get(int index) {\n        return data.get(index);\n    }\n\n    /**\n     *  Replaces the plot data element at the specified position\n     *  in this run with the specified datum.\n     *\n     *  @param   index   The index of the data element to replace.\n     *  @param   element The datum to be stored a the specified position.\n     *  @return  The datum previously at the specified position in this run.\n     *  @throws  ClassCastException - if the specified element is not a\n     *                                PlotDatum type object.\n     */\n    public Object set(int index, Object element) {\n        PlotDatum obj \u003d (PlotDatum) element;\n        return data.set(index, element);\n    }\n\n    /**\n     *  Inserts the specified plot data element at the specified\n     *  position in this run.  Shifts the plot data element\n     *  currently at that position (if any) and any subsequent\n     *  data elements to the right (adds one to their indices).\n     *\n     *  @param  index   Index at which the specified datum is to be\n     *                  inserted.\n     *  @param  element PlotDatum object to be inserted.\n     *  @throws ClassCastException - if the specified element is not a\n     *                               PlotDatum type object.\n     */\n    public void add(int index, Object element) {\n        PlotDatum obj \u003d (PlotDatum) element;\n        data.add(index, element);\n    }\n\n    /**\n     *  Remove the plot data object at the specified position in\n     *  this run.  Shifts any subsequent data elements\n     *  to the left (subtracts one from their indices).  Returns the\n     *  data element that was removed from this run.\n     *\n     *  @param   index  The index of the plot data element to remove.\n     *  @return  The PlotDatum object previously at the specified position.\n     */\n    public Object remove(int index) {\n        return data.remove(index);\n    }\n\n    /**\n     *  Removes all the plot data elements from this run.\n     *  The run will be empty after this call returns\n     *  (unless it throws an exception).\n     */\n    public void clear() {\n        data.clear();\n    }\n\n    /**\n     *  Return an enumeration of all the plot data elements in\n     *  this run.\n     *\n     *  @return An interation of all the PlotDatum objects in this run.\n     */\n    public Iterator iterator() {\n        return data.iterator();\n    }\n\n    /**\n     *  Make a copy of this PlotRun object.\n     *\n     *  @return  Returns a clone of this object.\n     */\n    public Object clone() {\n        PlotRun newObject \u003d null;\n        try {\n            // Make a shallow copy of this object.\n            newObject \u003d (PlotRun) super.clone();\n            // Now clone the data points attached to this run.\n            newObject.data \u003d new ArrayList();\n            int size \u003d this.data.size();\n            for (int i \u003d 0; i \u003c size; ++i) {\n                Object datum \u003d ((PlotDatum) this.data.get(i)).clone();\n                newObject.data.add(datum);\n            }\n        } catch (CloneNotSupportedException e) {\n            // Can\u0027t happen.\n            e.printStackTrace();\n        }\n        // Output the newly cloned object.\n        return newObject;\n    }\n}\n",
    "package": "jahuwaldt.plot",
    "classname": "PlotRun",
    "id": "/EvoSuiteBenchmark/original/29_apbsmem/src/main/java/jahuwaldt/plot/PlotRun_2Test.java",
    "test_prompt": "// PlotRun_2Test.java\npackage jahuwaldt.plot;\n\nimport java.awt.Color;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PlotRun}.\n* It contains ten unit test cases for the {@link PlotRun#remove(int)} method.\n*/\nclass PlotRun_2Test {",
    "method_signature": "remove(int)",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// PlotRun.java\n/*\n*   PlotRun  -- Container for a list of plot data points.\n*\n*   Copyright (C) 2000-2002 by Joseph A. Huwaldt \u003cjhuwaldt@knology.net\u003e.\n*   All rights reserved.\n*   \n*   This library is free software; you can redistribute it and/or\n*   modify it under the terms of the GNU Library General Public\n*   License as published by the Free Software Foundation; either\n*   version 2 of the License, or (at your option) any later version.\n*   \n*   This library is distributed in the hope that it will be useful,\n*   but WITHOUT ANY WARRANTY; without even the implied warranty of\n*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n*   Library General Public License for more details.\n**/\npackage jahuwaldt.plot;\n\nimport java.awt.Color;\nimport java.util.*;\n\n/**\n *  \u003cp\u003e This class represents a single run of data in a plot.\n *      A run is an array or list of PlotDatum objects.\n *  \u003c/p\u003e\n *\n *  \u003cp\u003e  Modified by:  Joseph A. Huwaldt  \u003c/p\u003e\n *\n *  @author  Joseph A. Huwaldt   Date:  September 13, 2000\n *  @version December 12, 2000\n */\npublic class PlotRun extends AbstractList implements Cloneable, java.io.Serializable {\n\n    /**\n     *  The plot datum objects are stored in an ArrayList.\n     */\n    private List data \u003d new ArrayList();\n\n    //-------------------------------------------------------------------------\n    /**\n     *  Create an empty run that contains no data.\n     */\n    public PlotRun() {\n    }\n\n    /**\n     *  Create a run that contains the specified array of PlotDatum objects.\n     *\n     *  @param run  An array of PlotDatum objects that make up a run of data\n     *              to be plotted.\n     */\n    public PlotRun(PlotDatum[] run) {\n        int length \u003d run.length;\n        for (int i \u003d 0; i \u003c length; ++i) data.add(run[i]);\n    }\n\n    /**\n     *  Create a run from a set of Java arrays for the X \u0026 Y data.\n     *\n     *  @param  xArr  An array containing the X coordinates of the data points\n     *                to be plotted.\n     *  @param  yArr  An array containing the Y coordinates of the data points\n     *                to be plotted.\n     *  @param  connectFlg  Set to true to have the points in the X \u0026 Y arrays\n     *                      connected by a line, false for them to not be connected.\n     *  @param  symbol      The plot symbol to use for the plotted points.\n     *\n     *  @throws NullPointerException if either array is null.\n     *  @throws ArrayIndexOutOfBoundsException if the X and Y arrays are not the\n     *          same length.\n     */\n    public PlotRun(double[] xArr, double[] yArr, boolean connectFlg, PlotSymbol symbol) {\n        if (xArr \u003d\u003d null || yArr \u003d\u003d null)\n            throw new NullPointerException();\n        int length \u003d xArr.length;\n        if (yArr.length !\u003d length)\n            throw new ArrayIndexOutOfBoundsException();\n        for (int i \u003d 0; i \u003c length; ++i) {\n            data.add(new PlotDatum(xArr[i], yArr[i], connectFlg, symbol));\n        }\n    }\n\n    /**\n     *  Create a run that contains the PlotDatum objects in the specified\n     *  Collection.\n     *\n     *  @param data  An Collection containing PlotDatum objects.\n     */\n    public PlotRun(Collection run) {\n        if (run instanceof PlotRun)\n            data.addAll(run);\n        else {\n            for (Iterator i \u003d run.iterator(); i.hasNext(); ) {\n                Object obj \u003d i.next();\n                if (obj instanceof PlotDatum)\n                    data.add(obj);\n            }\n        }\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     *  Return the minimum X value of the data contained in this run.\n     */\n    public double getMinX() {\n        double min \u003d Double.MAX_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            min \u003d Math.min(min, datum.x);\n        }\n        return min;\n    }\n\n    /**\n     *  Return the maximum X value of the data contained in this run.\n     */\n    public double getMaxX() {\n        double max \u003d Double.MIN_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            max \u003d Math.max(max, datum.x);\n        }\n        return max;\n    }\n\n    /**\n     *  Return the minimum Y value of the data contained in this run.\n     */\n    public double getMinY() {\n        double min \u003d Double.MAX_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            min \u003d Math.min(min, datum.y);\n        }\n        return min;\n    }\n\n    /**\n     *  Return the maximum Y value of the data contained in this run.\n     */\n    public double getMaxY() {\n        double max \u003d Double.MIN_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            max \u003d Math.max(max, datum.y);\n        }\n        return max;\n    }\n\n    /**\n     *  Use this method to change the plot symbol used by all\n     *  the plot data points in this run.\n     */\n    public void setPlotSymbol(PlotSymbol symbol) {\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            datum.setPlotSymbol(symbol);\n        }\n    }\n\n    /**\n     *  Use this method to change the line color used by all\n     *  the plot data points in this run.\n     */\n    public void setLineColor(Color color) {\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotDatum datum \u003d (PlotDatum) i.next();\n            datum.setLineColor(color);\n        }\n    }\n\n    //**** Methods required to implement AbstractList  ******\n    /**\n     *  Returns the number of PlotDatum objects in this run.\n     *\n     *  @return The number of plot data objects in this run.\n     */\n    public int size() {\n        return data.size();\n    }\n\n    /**\n     *  Returns the PlotDatum object at the specified position\n     *  in this run.\n     *\n     *  @param   index  The index of the plot data object to return.\n     *  @return  The PlotDatum object at the specified position\n     *           in this run.\n     */\n    public Object get(int index) {\n        return data.get(index);\n    }\n\n    /**\n     *  Replaces the plot data element at the specified position\n     *  in this run with the specified datum.\n     *\n     *  @param   index   The index of the data element to replace.\n     *  @param   element The datum to be stored a the specified position.\n     *  @return  The datum previously at the specified position in this run.\n     *  @throws  ClassCastException - if the specified element is not a\n     *                                PlotDatum type object.\n     */\n    public Object set(int index, Object element) {\n        PlotDatum obj \u003d (PlotDatum) element;\n        return data.set(index, element);\n    }\n\n    /**\n     *  Inserts the specified plot data element at the specified\n     *  position in this run.  Shifts the plot data element\n     *  currently at that position (if any) and any subsequent\n     *  data elements to the right (adds one to their indices).\n     *\n     *  @param  index   Index at which the specified datum is to be\n     *                  inserted.\n     *  @param  element PlotDatum object to be inserted.\n     *  @throws ClassCastException - if the specified element is not a\n     *                               PlotDatum type object.\n     */\n    public void add(int index, Object element) {\n        PlotDatum obj \u003d (PlotDatum) element;\n        data.add(index, element);\n    }\n\n    /**\n     *  Remove the plot data object at the specified position in\n     *  this run.  Shifts any subsequent data elements\n     *  to the left (subtracts one from their indices).  Returns the\n     *  data element that was removed from this run.\n     *\n     *  @param   index  The index of the plot data element to remove.\n     *  @return  The PlotDatum object previously at the specified position.\n     */\n    public Object remove(int index) {\n        return data.remove(index);\n    }\n\n    /**\n     *  Removes all the plot data elements from this run.\n     *  The run will be empty after this call returns\n     *  (unless it throws an exception).\n     */\n    public void clear() {\n        data.clear();\n    }\n\n    /**\n     *  Return an enumeration of all the plot data elements in\n     *  this run.\n     *\n     *  @return An interation of all the PlotDatum objects in this run.\n     */\n    public Iterator iterator() {\n        return data.iterator();\n    }\n\n    /**\n     *  Make a copy of this PlotRun object.\n     *\n     *  @return  Returns a clone of this object.\n     */\n    public Object clone() {\n        PlotRun newObject \u003d null;\n        try {\n            // Make a shallow copy of this object.\n            newObject \u003d (PlotRun) super.clone();\n            // Now clone the data points attached to this run.\n            newObject.data \u003d new ArrayList();\n            int size \u003d this.data.size();\n            for (int i \u003d 0; i \u003c size; ++i) {\n                Object datum \u003d ((PlotDatum) this.data.get(i)).clone();\n                newObject.data.add(datum);\n            }\n        } catch (CloneNotSupportedException e) {\n            // Can\u0027t happen.\n            e.printStackTrace();\n        }\n        // Output the newly cloned object.\n        return newObject;\n    }\n}\n",
    "package": "jahuwaldt.plot",
    "classname": "PlotRun",
    "id": "/EvoSuiteBenchmark/original/29_apbsmem/src/main/java/jahuwaldt/plot/PlotRun_3Test.java",
    "test_prompt": "// PlotRun_3Test.java\npackage jahuwaldt.plot;\n\nimport java.awt.Color;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PlotRun}.\n* It contains ten unit test cases for the {@link PlotRun#iterator()} method.\n*/\nclass PlotRun_3Test {",
    "method_signature": "iterator()",
    "suffix": "3"
  },
  {
    "numberTests": "ten",
    "original_code": "// PlotRunList.java\n/*\n*   PlotRunList  -- Container for a list of runs to be plotted.\n*\n*   Copyright (C) 2000-2002 by Joseph A. Huwaldt \u003cjhuwaldt@knology.net\u003e.\n*   All rights reserved.\n*   \n*   This library is free software; you can redistribute it and/or\n*   modify it under the terms of the GNU Library General Public\n*   License as published by the Free Software Foundation; either\n*   version 2 of the License, or (at your option) any later version.\n*   \n*   This library is distributed in the hope that it will be useful,\n*   but WITHOUT ANY WARRANTY; without even the implied warranty of\n*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n*   Library General Public License for more details.\n**/\npackage jahuwaldt.plot;\n\nimport java.awt.Color;\nimport java.util.*;\n\n/**\n *  \u003cp\u003e This class represents a list of runs of data in a plot.\n *      A run is an array or list of PlotDatum objects.  A run\n *      list is an array or list of runs.\n *  \u003c/p\u003e\n *\n *  \u003cp\u003e  Modified by:  Joseph A. Huwaldt  \u003c/p\u003e\n *\n *  @author  Joseph A. Huwaldt   Date:  September 13, 2000\n *  @version November 20, 2000\n */\npublic class PlotRunList extends AbstractList implements Cloneable, java.io.Serializable {\n\n    /**\n     *  The run objects are stored in an ArrayList.\n     */\n    private List data \u003d new ArrayList();\n\n    //-------------------------------------------------------------------------\n    /**\n     *  Create an empty run list that contains no runs.\n     */\n    public PlotRunList() {\n    }\n\n    /**\n     *  Create a run list that contains the specified\n     *  array of PlotRun objects.\n     *\n     *  @param run  An array of PlotRun objects that make up a list\n     *              of runs to be plotted.\n     */\n    public PlotRunList(PlotRun[] runArr) {\n        int length \u003d runArr.length;\n        for (int i \u003d 0; i \u003c length; ++i) data.add(runArr[i]);\n    }\n\n    /**\n     *  Create a runlist  that contains the PlotRun objects in the specified\n     *  Collection.\n     *\n     *  @param data  An Collection containing PlotRun objects.\n     */\n    public PlotRunList(Collection runs) {\n        if (runs instanceof PlotRunList)\n            data.addAll(runs);\n        else {\n            for (Iterator i \u003d runs.iterator(); i.hasNext(); ) {\n                Object obj \u003d i.next();\n                if (obj instanceof PlotRun)\n                    data.add(obj);\n            }\n        }\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     *  Return the minimum X value of the data contained in this\n     *  run list.\n     */\n    public double getMinX() {\n        double min \u003d Double.MAX_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            min \u003d Math.min(min, run.getMinX());\n        }\n        return min;\n    }\n\n    /**\n     *  Return the maximum X value of the data contained in this\n     *  run list.\n     */\n    public double getMaxX() {\n        double max \u003d Double.MIN_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            max \u003d Math.max(max, run.getMaxX());\n        }\n        return max;\n    }\n\n    /**\n     *  Return the minimum Y value of the data contained in this\n     *  run list.\n     */\n    public double getMinY() {\n        double min \u003d Double.MAX_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            min \u003d Math.min(min, run.getMinY());\n        }\n        return min;\n    }\n\n    /**\n     *  Return the maximum Y value of the data contained in this\n     *  run list.\n     */\n    public double getMaxY() {\n        double max \u003d Double.MIN_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            max \u003d Math.max(max, run.getMaxY());\n        }\n        return max;\n    }\n\n    /**\n     *  Use this method to change the plot symbol used by all\n     *  the plot data points in all the runs in this run list.\n     */\n    public void setPlotSymbol(PlotSymbol symbol) {\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            run.setPlotSymbol(symbol);\n        }\n    }\n\n    /**\n     *  Use this method to change the line color used by all\n     *  the plot data points in all the runs in this run list.\n     */\n    public void setLineColor(Color color) {\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            run.setLineColor(color);\n        }\n    }\n\n    //**** Methods required to implement AbstractList  ******\n    /**\n     *  Returns the number of PlotRun objects in this run list.\n     *\n     *  @return The number of plot run objects in this run list.\n     */\n    public int size() {\n        return data.size();\n    }\n\n    /**\n     *  Returns the PlotRun object at the specified position\n     *  in this run list.\n     *\n     *  @param   index  The index of the plot run object to return.\n     *  @return  The PlotRun object at the specified position\n     *           in this run.\n     */\n    public Object get(int index) {\n        return data.get(index);\n    }\n\n    /**\n     *  Replaces the plot run element at the specified position\n     *  in this run list with the specified run.\n     *\n     *  @param   index   The index of the data run to replace.\n     *  @param   element The run to be stored a the specified position.\n     *  @return  The run previously at the specified position in this list.\n     *  @throws  ClassCastException - if the specified element is not a\n     *                                PlotRun type object.\n     */\n    public Object set(int index, Object element) {\n        PlotRun obj \u003d (PlotRun) element;\n        return data.set(index, element);\n    }\n\n    /**\n     *  Inserts the specified plot run element at the specified\n     *  position in this run list.  Shifts the plot run element\n     *  currently at that position (if any) and any subsequent\n     *  runs to the right (adds one to their indices).\n     *\n     *  @param  index   Index at which the specified run is to be\n     *                  inserted.\n     *  @param  element PlotRun object to be inserted.\n     *  @throws ClassCastException - if the specified element is not a\n     *                               PlotRun type object.\n     */\n    public void add(int index, Object element) {\n        PlotRun obj \u003d (PlotRun) element;\n        data.add(index, element);\n    }\n\n    /**\n     *  Remove the plot run object at the specified position in\n     *  this run list.  Shifts any subsequent run elements\n     *  to the left (subtracts one from their indices).  Returns the\n     *  run element that was removed from this run list.\n     *\n     *  @param   index  The index of the plot run element to remove.\n     *  @return  The PlotRun object previously at the specified position.\n     */\n    public Object remove(int index) {\n        return data.remove(index);\n    }\n\n    /**\n     *  Removes all the plot run elements from this run list.\n     *  The run list will be empty after this call returns\n     *  (unless it throws an exception).\n     */\n    public void clear() {\n        data.clear();\n    }\n\n    /**\n     *  Return an enumeration of all the plot run elements in\n     *  this run list.\n     *\n     *  @return An interation of all the PlotRun objects in this list.\n     */\n    public Iterator iterator() {\n        return data.iterator();\n    }\n\n    /**\n     *  Make a copy of this PlotRunList object.\n     *\n     *  @return  Returns a clone of this object.\n     */\n    public Object clone() {\n        PlotRunList newObject \u003d null;\n        try {\n            // Make a shallow copy of this object.\n            newObject \u003d (PlotRunList) super.clone();\n            // Now clone the runs attached to this list.\n            newObject.data \u003d new ArrayList();\n            int size \u003d this.data.size();\n            for (int i \u003d 0; i \u003c size; ++i) {\n                Object run \u003d ((PlotRun) this.data.get(i)).clone();\n                newObject.data.add(run);\n            }\n        } catch (CloneNotSupportedException e) {\n            // Can\u0027t happen.\n            e.printStackTrace();\n        }\n        // Output the newly cloned object.\n        return newObject;\n    }\n}\n",
    "package": "jahuwaldt.plot",
    "classname": "PlotRunList",
    "id": "/EvoSuiteBenchmark/original/29_apbsmem/src/main/java/jahuwaldt/plot/PlotRunList_0Test.java",
    "test_prompt": "// PlotRunList_0Test.java\npackage jahuwaldt.plot;\n\nimport java.awt.Color;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PlotRunList}.\n* It contains ten unit test cases for the {@link PlotRunList#size()} method.\n*/\nclass PlotRunList_0Test {",
    "method_signature": "size()",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// PlotRunList.java\n/*\n*   PlotRunList  -- Container for a list of runs to be plotted.\n*\n*   Copyright (C) 2000-2002 by Joseph A. Huwaldt \u003cjhuwaldt@knology.net\u003e.\n*   All rights reserved.\n*   \n*   This library is free software; you can redistribute it and/or\n*   modify it under the terms of the GNU Library General Public\n*   License as published by the Free Software Foundation; either\n*   version 2 of the License, or (at your option) any later version.\n*   \n*   This library is distributed in the hope that it will be useful,\n*   but WITHOUT ANY WARRANTY; without even the implied warranty of\n*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n*   Library General Public License for more details.\n**/\npackage jahuwaldt.plot;\n\nimport java.awt.Color;\nimport java.util.*;\n\n/**\n *  \u003cp\u003e This class represents a list of runs of data in a plot.\n *      A run is an array or list of PlotDatum objects.  A run\n *      list is an array or list of runs.\n *  \u003c/p\u003e\n *\n *  \u003cp\u003e  Modified by:  Joseph A. Huwaldt  \u003c/p\u003e\n *\n *  @author  Joseph A. Huwaldt   Date:  September 13, 2000\n *  @version November 20, 2000\n */\npublic class PlotRunList extends AbstractList implements Cloneable, java.io.Serializable {\n\n    /**\n     *  The run objects are stored in an ArrayList.\n     */\n    private List data \u003d new ArrayList();\n\n    //-------------------------------------------------------------------------\n    /**\n     *  Create an empty run list that contains no runs.\n     */\n    public PlotRunList() {\n    }\n\n    /**\n     *  Create a run list that contains the specified\n     *  array of PlotRun objects.\n     *\n     *  @param run  An array of PlotRun objects that make up a list\n     *              of runs to be plotted.\n     */\n    public PlotRunList(PlotRun[] runArr) {\n        int length \u003d runArr.length;\n        for (int i \u003d 0; i \u003c length; ++i) data.add(runArr[i]);\n    }\n\n    /**\n     *  Create a runlist  that contains the PlotRun objects in the specified\n     *  Collection.\n     *\n     *  @param data  An Collection containing PlotRun objects.\n     */\n    public PlotRunList(Collection runs) {\n        if (runs instanceof PlotRunList)\n            data.addAll(runs);\n        else {\n            for (Iterator i \u003d runs.iterator(); i.hasNext(); ) {\n                Object obj \u003d i.next();\n                if (obj instanceof PlotRun)\n                    data.add(obj);\n            }\n        }\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     *  Return the minimum X value of the data contained in this\n     *  run list.\n     */\n    public double getMinX() {\n        double min \u003d Double.MAX_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            min \u003d Math.min(min, run.getMinX());\n        }\n        return min;\n    }\n\n    /**\n     *  Return the maximum X value of the data contained in this\n     *  run list.\n     */\n    public double getMaxX() {\n        double max \u003d Double.MIN_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            max \u003d Math.max(max, run.getMaxX());\n        }\n        return max;\n    }\n\n    /**\n     *  Return the minimum Y value of the data contained in this\n     *  run list.\n     */\n    public double getMinY() {\n        double min \u003d Double.MAX_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            min \u003d Math.min(min, run.getMinY());\n        }\n        return min;\n    }\n\n    /**\n     *  Return the maximum Y value of the data contained in this\n     *  run list.\n     */\n    public double getMaxY() {\n        double max \u003d Double.MIN_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            max \u003d Math.max(max, run.getMaxY());\n        }\n        return max;\n    }\n\n    /**\n     *  Use this method to change the plot symbol used by all\n     *  the plot data points in all the runs in this run list.\n     */\n    public void setPlotSymbol(PlotSymbol symbol) {\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            run.setPlotSymbol(symbol);\n        }\n    }\n\n    /**\n     *  Use this method to change the line color used by all\n     *  the plot data points in all the runs in this run list.\n     */\n    public void setLineColor(Color color) {\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            run.setLineColor(color);\n        }\n    }\n\n    //**** Methods required to implement AbstractList  ******\n    /**\n     *  Returns the number of PlotRun objects in this run list.\n     *\n     *  @return The number of plot run objects in this run list.\n     */\n    public int size() {\n        return data.size();\n    }\n\n    /**\n     *  Returns the PlotRun object at the specified position\n     *  in this run list.\n     *\n     *  @param   index  The index of the plot run object to return.\n     *  @return  The PlotRun object at the specified position\n     *           in this run.\n     */\n    public Object get(int index) {\n        return data.get(index);\n    }\n\n    /**\n     *  Replaces the plot run element at the specified position\n     *  in this run list with the specified run.\n     *\n     *  @param   index   The index of the data run to replace.\n     *  @param   element The run to be stored a the specified position.\n     *  @return  The run previously at the specified position in this list.\n     *  @throws  ClassCastException - if the specified element is not a\n     *                                PlotRun type object.\n     */\n    public Object set(int index, Object element) {\n        PlotRun obj \u003d (PlotRun) element;\n        return data.set(index, element);\n    }\n\n    /**\n     *  Inserts the specified plot run element at the specified\n     *  position in this run list.  Shifts the plot run element\n     *  currently at that position (if any) and any subsequent\n     *  runs to the right (adds one to their indices).\n     *\n     *  @param  index   Index at which the specified run is to be\n     *                  inserted.\n     *  @param  element PlotRun object to be inserted.\n     *  @throws ClassCastException - if the specified element is not a\n     *                               PlotRun type object.\n     */\n    public void add(int index, Object element) {\n        PlotRun obj \u003d (PlotRun) element;\n        data.add(index, element);\n    }\n\n    /**\n     *  Remove the plot run object at the specified position in\n     *  this run list.  Shifts any subsequent run elements\n     *  to the left (subtracts one from their indices).  Returns the\n     *  run element that was removed from this run list.\n     *\n     *  @param   index  The index of the plot run element to remove.\n     *  @return  The PlotRun object previously at the specified position.\n     */\n    public Object remove(int index) {\n        return data.remove(index);\n    }\n\n    /**\n     *  Removes all the plot run elements from this run list.\n     *  The run list will be empty after this call returns\n     *  (unless it throws an exception).\n     */\n    public void clear() {\n        data.clear();\n    }\n\n    /**\n     *  Return an enumeration of all the plot run elements in\n     *  this run list.\n     *\n     *  @return An interation of all the PlotRun objects in this list.\n     */\n    public Iterator iterator() {\n        return data.iterator();\n    }\n\n    /**\n     *  Make a copy of this PlotRunList object.\n     *\n     *  @return  Returns a clone of this object.\n     */\n    public Object clone() {\n        PlotRunList newObject \u003d null;\n        try {\n            // Make a shallow copy of this object.\n            newObject \u003d (PlotRunList) super.clone();\n            // Now clone the runs attached to this list.\n            newObject.data \u003d new ArrayList();\n            int size \u003d this.data.size();\n            for (int i \u003d 0; i \u003c size; ++i) {\n                Object run \u003d ((PlotRun) this.data.get(i)).clone();\n                newObject.data.add(run);\n            }\n        } catch (CloneNotSupportedException e) {\n            // Can\u0027t happen.\n            e.printStackTrace();\n        }\n        // Output the newly cloned object.\n        return newObject;\n    }\n}\n",
    "package": "jahuwaldt.plot",
    "classname": "PlotRunList",
    "id": "/EvoSuiteBenchmark/original/29_apbsmem/src/main/java/jahuwaldt/plot/PlotRunList_1Test.java",
    "test_prompt": "// PlotRunList_1Test.java\npackage jahuwaldt.plot;\n\nimport java.awt.Color;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PlotRunList}.\n* It contains ten unit test cases for the {@link PlotRunList#get(int)} method.\n*/\nclass PlotRunList_1Test {",
    "method_signature": "get(int)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// PlotRunList.java\n/*\n*   PlotRunList  -- Container for a list of runs to be plotted.\n*\n*   Copyright (C) 2000-2002 by Joseph A. Huwaldt \u003cjhuwaldt@knology.net\u003e.\n*   All rights reserved.\n*   \n*   This library is free software; you can redistribute it and/or\n*   modify it under the terms of the GNU Library General Public\n*   License as published by the Free Software Foundation; either\n*   version 2 of the License, or (at your option) any later version.\n*   \n*   This library is distributed in the hope that it will be useful,\n*   but WITHOUT ANY WARRANTY; without even the implied warranty of\n*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n*   Library General Public License for more details.\n**/\npackage jahuwaldt.plot;\n\nimport java.awt.Color;\nimport java.util.*;\n\n/**\n *  \u003cp\u003e This class represents a list of runs of data in a plot.\n *      A run is an array or list of PlotDatum objects.  A run\n *      list is an array or list of runs.\n *  \u003c/p\u003e\n *\n *  \u003cp\u003e  Modified by:  Joseph A. Huwaldt  \u003c/p\u003e\n *\n *  @author  Joseph A. Huwaldt   Date:  September 13, 2000\n *  @version November 20, 2000\n */\npublic class PlotRunList extends AbstractList implements Cloneable, java.io.Serializable {\n\n    /**\n     *  The run objects are stored in an ArrayList.\n     */\n    private List data \u003d new ArrayList();\n\n    //-------------------------------------------------------------------------\n    /**\n     *  Create an empty run list that contains no runs.\n     */\n    public PlotRunList() {\n    }\n\n    /**\n     *  Create a run list that contains the specified\n     *  array of PlotRun objects.\n     *\n     *  @param run  An array of PlotRun objects that make up a list\n     *              of runs to be plotted.\n     */\n    public PlotRunList(PlotRun[] runArr) {\n        int length \u003d runArr.length;\n        for (int i \u003d 0; i \u003c length; ++i) data.add(runArr[i]);\n    }\n\n    /**\n     *  Create a runlist  that contains the PlotRun objects in the specified\n     *  Collection.\n     *\n     *  @param data  An Collection containing PlotRun objects.\n     */\n    public PlotRunList(Collection runs) {\n        if (runs instanceof PlotRunList)\n            data.addAll(runs);\n        else {\n            for (Iterator i \u003d runs.iterator(); i.hasNext(); ) {\n                Object obj \u003d i.next();\n                if (obj instanceof PlotRun)\n                    data.add(obj);\n            }\n        }\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     *  Return the minimum X value of the data contained in this\n     *  run list.\n     */\n    public double getMinX() {\n        double min \u003d Double.MAX_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            min \u003d Math.min(min, run.getMinX());\n        }\n        return min;\n    }\n\n    /**\n     *  Return the maximum X value of the data contained in this\n     *  run list.\n     */\n    public double getMaxX() {\n        double max \u003d Double.MIN_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            max \u003d Math.max(max, run.getMaxX());\n        }\n        return max;\n    }\n\n    /**\n     *  Return the minimum Y value of the data contained in this\n     *  run list.\n     */\n    public double getMinY() {\n        double min \u003d Double.MAX_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            min \u003d Math.min(min, run.getMinY());\n        }\n        return min;\n    }\n\n    /**\n     *  Return the maximum Y value of the data contained in this\n     *  run list.\n     */\n    public double getMaxY() {\n        double max \u003d Double.MIN_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            max \u003d Math.max(max, run.getMaxY());\n        }\n        return max;\n    }\n\n    /**\n     *  Use this method to change the plot symbol used by all\n     *  the plot data points in all the runs in this run list.\n     */\n    public void setPlotSymbol(PlotSymbol symbol) {\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            run.setPlotSymbol(symbol);\n        }\n    }\n\n    /**\n     *  Use this method to change the line color used by all\n     *  the plot data points in all the runs in this run list.\n     */\n    public void setLineColor(Color color) {\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            run.setLineColor(color);\n        }\n    }\n\n    //**** Methods required to implement AbstractList  ******\n    /**\n     *  Returns the number of PlotRun objects in this run list.\n     *\n     *  @return The number of plot run objects in this run list.\n     */\n    public int size() {\n        return data.size();\n    }\n\n    /**\n     *  Returns the PlotRun object at the specified position\n     *  in this run list.\n     *\n     *  @param   index  The index of the plot run object to return.\n     *  @return  The PlotRun object at the specified position\n     *           in this run.\n     */\n    public Object get(int index) {\n        return data.get(index);\n    }\n\n    /**\n     *  Replaces the plot run element at the specified position\n     *  in this run list with the specified run.\n     *\n     *  @param   index   The index of the data run to replace.\n     *  @param   element The run to be stored a the specified position.\n     *  @return  The run previously at the specified position in this list.\n     *  @throws  ClassCastException - if the specified element is not a\n     *                                PlotRun type object.\n     */\n    public Object set(int index, Object element) {\n        PlotRun obj \u003d (PlotRun) element;\n        return data.set(index, element);\n    }\n\n    /**\n     *  Inserts the specified plot run element at the specified\n     *  position in this run list.  Shifts the plot run element\n     *  currently at that position (if any) and any subsequent\n     *  runs to the right (adds one to their indices).\n     *\n     *  @param  index   Index at which the specified run is to be\n     *                  inserted.\n     *  @param  element PlotRun object to be inserted.\n     *  @throws ClassCastException - if the specified element is not a\n     *                               PlotRun type object.\n     */\n    public void add(int index, Object element) {\n        PlotRun obj \u003d (PlotRun) element;\n        data.add(index, element);\n    }\n\n    /**\n     *  Remove the plot run object at the specified position in\n     *  this run list.  Shifts any subsequent run elements\n     *  to the left (subtracts one from their indices).  Returns the\n     *  run element that was removed from this run list.\n     *\n     *  @param   index  The index of the plot run element to remove.\n     *  @return  The PlotRun object previously at the specified position.\n     */\n    public Object remove(int index) {\n        return data.remove(index);\n    }\n\n    /**\n     *  Removes all the plot run elements from this run list.\n     *  The run list will be empty after this call returns\n     *  (unless it throws an exception).\n     */\n    public void clear() {\n        data.clear();\n    }\n\n    /**\n     *  Return an enumeration of all the plot run elements in\n     *  this run list.\n     *\n     *  @return An interation of all the PlotRun objects in this list.\n     */\n    public Iterator iterator() {\n        return data.iterator();\n    }\n\n    /**\n     *  Make a copy of this PlotRunList object.\n     *\n     *  @return  Returns a clone of this object.\n     */\n    public Object clone() {\n        PlotRunList newObject \u003d null;\n        try {\n            // Make a shallow copy of this object.\n            newObject \u003d (PlotRunList) super.clone();\n            // Now clone the runs attached to this list.\n            newObject.data \u003d new ArrayList();\n            int size \u003d this.data.size();\n            for (int i \u003d 0; i \u003c size; ++i) {\n                Object run \u003d ((PlotRun) this.data.get(i)).clone();\n                newObject.data.add(run);\n            }\n        } catch (CloneNotSupportedException e) {\n            // Can\u0027t happen.\n            e.printStackTrace();\n        }\n        // Output the newly cloned object.\n        return newObject;\n    }\n}\n",
    "package": "jahuwaldt.plot",
    "classname": "PlotRunList",
    "id": "/EvoSuiteBenchmark/original/29_apbsmem/src/main/java/jahuwaldt/plot/PlotRunList_2Test.java",
    "test_prompt": "// PlotRunList_2Test.java\npackage jahuwaldt.plot;\n\nimport java.awt.Color;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PlotRunList}.\n* It contains ten unit test cases for the {@link PlotRunList#remove(int)} method.\n*/\nclass PlotRunList_2Test {",
    "method_signature": "remove(int)",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// PlotRunList.java\n/*\n*   PlotRunList  -- Container for a list of runs to be plotted.\n*\n*   Copyright (C) 2000-2002 by Joseph A. Huwaldt \u003cjhuwaldt@knology.net\u003e.\n*   All rights reserved.\n*   \n*   This library is free software; you can redistribute it and/or\n*   modify it under the terms of the GNU Library General Public\n*   License as published by the Free Software Foundation; either\n*   version 2 of the License, or (at your option) any later version.\n*   \n*   This library is distributed in the hope that it will be useful,\n*   but WITHOUT ANY WARRANTY; without even the implied warranty of\n*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n*   Library General Public License for more details.\n**/\npackage jahuwaldt.plot;\n\nimport java.awt.Color;\nimport java.util.*;\n\n/**\n *  \u003cp\u003e This class represents a list of runs of data in a plot.\n *      A run is an array or list of PlotDatum objects.  A run\n *      list is an array or list of runs.\n *  \u003c/p\u003e\n *\n *  \u003cp\u003e  Modified by:  Joseph A. Huwaldt  \u003c/p\u003e\n *\n *  @author  Joseph A. Huwaldt   Date:  September 13, 2000\n *  @version November 20, 2000\n */\npublic class PlotRunList extends AbstractList implements Cloneable, java.io.Serializable {\n\n    /**\n     *  The run objects are stored in an ArrayList.\n     */\n    private List data \u003d new ArrayList();\n\n    //-------------------------------------------------------------------------\n    /**\n     *  Create an empty run list that contains no runs.\n     */\n    public PlotRunList() {\n    }\n\n    /**\n     *  Create a run list that contains the specified\n     *  array of PlotRun objects.\n     *\n     *  @param run  An array of PlotRun objects that make up a list\n     *              of runs to be plotted.\n     */\n    public PlotRunList(PlotRun[] runArr) {\n        int length \u003d runArr.length;\n        for (int i \u003d 0; i \u003c length; ++i) data.add(runArr[i]);\n    }\n\n    /**\n     *  Create a runlist  that contains the PlotRun objects in the specified\n     *  Collection.\n     *\n     *  @param data  An Collection containing PlotRun objects.\n     */\n    public PlotRunList(Collection runs) {\n        if (runs instanceof PlotRunList)\n            data.addAll(runs);\n        else {\n            for (Iterator i \u003d runs.iterator(); i.hasNext(); ) {\n                Object obj \u003d i.next();\n                if (obj instanceof PlotRun)\n                    data.add(obj);\n            }\n        }\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     *  Return the minimum X value of the data contained in this\n     *  run list.\n     */\n    public double getMinX() {\n        double min \u003d Double.MAX_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            min \u003d Math.min(min, run.getMinX());\n        }\n        return min;\n    }\n\n    /**\n     *  Return the maximum X value of the data contained in this\n     *  run list.\n     */\n    public double getMaxX() {\n        double max \u003d Double.MIN_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            max \u003d Math.max(max, run.getMaxX());\n        }\n        return max;\n    }\n\n    /**\n     *  Return the minimum Y value of the data contained in this\n     *  run list.\n     */\n    public double getMinY() {\n        double min \u003d Double.MAX_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            min \u003d Math.min(min, run.getMinY());\n        }\n        return min;\n    }\n\n    /**\n     *  Return the maximum Y value of the data contained in this\n     *  run list.\n     */\n    public double getMaxY() {\n        double max \u003d Double.MIN_VALUE;\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            max \u003d Math.max(max, run.getMaxY());\n        }\n        return max;\n    }\n\n    /**\n     *  Use this method to change the plot symbol used by all\n     *  the plot data points in all the runs in this run list.\n     */\n    public void setPlotSymbol(PlotSymbol symbol) {\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            run.setPlotSymbol(symbol);\n        }\n    }\n\n    /**\n     *  Use this method to change the line color used by all\n     *  the plot data points in all the runs in this run list.\n     */\n    public void setLineColor(Color color) {\n        for (Iterator i \u003d data.iterator(); i.hasNext(); ) {\n            PlotRun run \u003d (PlotRun) i.next();\n            run.setLineColor(color);\n        }\n    }\n\n    //**** Methods required to implement AbstractList  ******\n    /**\n     *  Returns the number of PlotRun objects in this run list.\n     *\n     *  @return The number of plot run objects in this run list.\n     */\n    public int size() {\n        return data.size();\n    }\n\n    /**\n     *  Returns the PlotRun object at the specified position\n     *  in this run list.\n     *\n     *  @param   index  The index of the plot run object to return.\n     *  @return  The PlotRun object at the specified position\n     *           in this run.\n     */\n    public Object get(int index) {\n        return data.get(index);\n    }\n\n    /**\n     *  Replaces the plot run element at the specified position\n     *  in this run list with the specified run.\n     *\n     *  @param   index   The index of the data run to replace.\n     *  @param   element The run to be stored a the specified position.\n     *  @return  The run previously at the specified position in this list.\n     *  @throws  ClassCastException - if the specified element is not a\n     *                                PlotRun type object.\n     */\n    public Object set(int index, Object element) {\n        PlotRun obj \u003d (PlotRun) element;\n        return data.set(index, element);\n    }\n\n    /**\n     *  Inserts the specified plot run element at the specified\n     *  position in this run list.  Shifts the plot run element\n     *  currently at that position (if any) and any subsequent\n     *  runs to the right (adds one to their indices).\n     *\n     *  @param  index   Index at which the specified run is to be\n     *                  inserted.\n     *  @param  element PlotRun object to be inserted.\n     *  @throws ClassCastException - if the specified element is not a\n     *                               PlotRun type object.\n     */\n    public void add(int index, Object element) {\n        PlotRun obj \u003d (PlotRun) element;\n        data.add(index, element);\n    }\n\n    /**\n     *  Remove the plot run object at the specified position in\n     *  this run list.  Shifts any subsequent run elements\n     *  to the left (subtracts one from their indices).  Returns the\n     *  run element that was removed from this run list.\n     *\n     *  @param   index  The index of the plot run element to remove.\n     *  @return  The PlotRun object previously at the specified position.\n     */\n    public Object remove(int index) {\n        return data.remove(index);\n    }\n\n    /**\n     *  Removes all the plot run elements from this run list.\n     *  The run list will be empty after this call returns\n     *  (unless it throws an exception).\n     */\n    public void clear() {\n        data.clear();\n    }\n\n    /**\n     *  Return an enumeration of all the plot run elements in\n     *  this run list.\n     *\n     *  @return An interation of all the PlotRun objects in this list.\n     */\n    public Iterator iterator() {\n        return data.iterator();\n    }\n\n    /**\n     *  Make a copy of this PlotRunList object.\n     *\n     *  @return  Returns a clone of this object.\n     */\n    public Object clone() {\n        PlotRunList newObject \u003d null;\n        try {\n            // Make a shallow copy of this object.\n            newObject \u003d (PlotRunList) super.clone();\n            // Now clone the runs attached to this list.\n            newObject.data \u003d new ArrayList();\n            int size \u003d this.data.size();\n            for (int i \u003d 0; i \u003c size; ++i) {\n                Object run \u003d ((PlotRun) this.data.get(i)).clone();\n                newObject.data.add(run);\n            }\n        } catch (CloneNotSupportedException e) {\n            // Can\u0027t happen.\n            e.printStackTrace();\n        }\n        // Output the newly cloned object.\n        return newObject;\n    }\n}\n",
    "package": "jahuwaldt.plot",
    "classname": "PlotRunList",
    "id": "/EvoSuiteBenchmark/original/29_apbsmem/src/main/java/jahuwaldt/plot/PlotRunList_3Test.java",
    "test_prompt": "// PlotRunList_3Test.java\npackage jahuwaldt.plot;\n\nimport java.awt.Color;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PlotRunList}.\n* It contains ten unit test cases for the {@link PlotRunList#iterator()} method.\n*/\nclass PlotRunList_3Test {",
    "method_signature": "iterator()",
    "suffix": "3"
  },
  {
    "numberTests": "ten",
    "original_code": "// ContourGenerator.java\n/*\n*   ContourGenerator  -- Used to generate 2D contour paths from gridded 3D data.\n*\n*   Copyright (C) 2000-2002 by Joseph A. Huwaldt \u003cjhuwaldt@knology.net\u003e.\n*   All rights reserved.\n*   \n*   This library is free software; you can redistribute it and/or\n*   modify it under the terms of the GNU Library General Public\n*   License as published by the Free Software Foundation; either\n*   version 2 of the License, or (at your option) any later version.\n*   \n*   This library is distributed in the hope that it will be useful,\n*   but WITHOUT ANY WARRANTY; without even the implied warranty of\n*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n*   Library General Public License for more details.\n**/\npackage jahuwaldt.plot;\n\nimport java.util.*;\n\n/**\n *  \u003cp\u003e An object used to generate a list of contour lines\n *      or paths from a set of gridded three dimensional data.\n *  \u003c/p\u003e\n *\n *  \u003cp\u003e Based on contour_plot.c from NeXTcontour1.4 by Thomas H. Pulliam,\n *      pulliam@rft29.nas.nasa.gov, MS 202A-1 NASA Ames Research Center,\n *      Moffett Field, CA 94035.\n *      I don\u0027t know how the original Fortran code looked like or where it came from,\n *      other than that NeXTcontour1.4 is based on Pieter Bunings\u0027 PLOT3D package\n *      for Computational Fluid Dynamics.\n *  \u003c/p\u003e\n *\n *  \u003cp\u003e Ported from C to Java by Joseph A. Huwaldt, November 16, 2000.  \u003c/p\u003e\n *\n *  \u003cp\u003e  Modified by:  Joseph A. Huwaldt  \u003c/p\u003e\n *\n *  @author  Joseph A. Huwaldt   Date:  November 11, 2000\n *  @version November 23, 2000\n */\npublic class ContourGenerator {\n\n    //\tDebug flag.\n    private static final boolean DEBUG \u003d false;\n\n    //\tError messages.\n    private static final String kCancelMsg \u003d \"Method ContourGenerator.getContours() canceled by user.\";\n\n    private static final String kInconsistantArrMsg \u003d \"Inconsistant array sizes.\";\n\n    private static final String kArrSizeMsg \u003d \"Data arrays must have more than one row or column.\";\n\n    private static final String kNegLogDataMsg \u003d \"Function data must be \u003e 0 for logarithmic intervals.\";\n\n    //\tPath buffer size.\n    private static final int kBufSize \u003d 1000;\n\n    //\tThe minimum number of points allowed in a contour path.\n    private static final int kMinNumPoints \u003d 3;\n\n    //\tA list of contour paths.\n    private List pathList \u003d new ArrayList();\n\n    //\tA flag to indicate that the contours have been computed or not.\n    private boolean cCalculated \u003d false;\n\n    //\tData arrays used for generating the contours.\n    private double[][] xArray, yArray, funcArray;\n\n    //\tData arrays used when generating contours for 1D X \u0026 Y arrays.\n    private double[] xArr1D, yArr1D;\n\n    //\tArray of contour attributes, one for each contour level.\n    private ContourAttrib[] cAttr;\n\n    //\tThe fraction of the task that is completed.\n    private float fracComplete \u003d 0;\n\n    /**\n     *  Used to indicate that the user wishes to cancel the calculation\n     *  of contours.\n     */\n    private boolean isCanceled \u003d false;\n\n    //\tVariables in the original FORTRAN program.\n    private double[] pathbufxt, pathbufyt;\n\n    private int[] pathbufia;\n\n    //\tlnstrt\u003d1 indicates starting a new line.\n    private int lnstrt;\n\n    private int ignext;\n\n    //\tCurrent contour level index.\n    private int icont;\n\n    //\tThe current contour level.\n    private double cont;\n\n    //\ti \u0026 j start and end index values.\n    private int iss, iee, jss, jee;\n\n    //\tima tells which boundary region we are on.\n    private int ima;\n\n    //\tIndex to last element in the IA list.\n    private int iae;\n\n    private int ibeg, jbeg;\n\n    //\tIndexes into data arrays.\n    private int gi, gj;\n\n    //\tData value at i,j in data array.\n    private double fij;\n\n    //\tIndicates current direction.\n    private int idir;\n\n    //\tNumber of points in current contour line.\n    private int np \u003d 0;\n\n    //\tStarting point of a contour line.\n    private double wx \u003d 0, wy \u003d 0;\n\n    /**\n     *  Construct a ContourGenerator object using the specified data arrays\n     *  and the specified attribute array.  This constructor allows you\n     *  to use data on an uneven X, Y grid.\n     *\n     *  @param  xArr   2D array containing the grid x coordinate data.\n     *  @param  yArr   2D array containing the grid y coordinate data.\n     *  @param  fArr   2D array containing the grid function (z) data.\n     *  @param  cAttr  Array containing attributes of the contour levels.\n     */\n    public ContourGenerator(double[][] xArr, double[][] yArr, double[][] fArr, ContourAttrib[] cAttr) {\n        //\tMake sure input data is reasonable.\n        if (yArr.length !\u003d xArr.length || yArr.length !\u003d fArr.length)\n            throw new IllegalArgumentException(kInconsistantArrMsg);\n        if (yArr[0].length !\u003d xArr[0].length || yArr[0].length !\u003d fArr[0].length)\n            throw new IllegalArgumentException(kInconsistantArrMsg);\n        if (xArr.length \u003c\u003d 1 || xArr[0].length \u003c\u003d 1)\n            throw new IllegalArgumentException(kArrSizeMsg);\n        this.cAttr \u003d cAttr;\n        xArray \u003d xArr;\n        yArray \u003d yArr;\n        funcArray \u003d fArr;\n    }\n\n    /**\n     *  Construct a ContourGenerator object using the specified data arrays\n     *  and the specified attribute array.  This constructor allows you\n     *  to use data on an evenly spaced grid where \"X\" values are invarient\n     *  with \"Y\" and \"Y\" values are invarient with \"X\".  This often occures\n     *  where the data is on an evenly spaced cartesian grid.\n     *\n     *  @param  xArr   1D array containing the grid x coordinate data.\n     *  @param  yArr   1D array containing the grid y coordinate data.\n     *  @param  fArr   2D array containing the grid function (z) data.\n     *  @param  cAttr  Array containing attributes of the contour levels.\n     */\n    public ContourGenerator(double[] xArr, double[] yArr, double[][] fArr, ContourAttrib[] cAttr) {\n        //\tMake sure input data is reasonable.\n        if (yArr.length !\u003d fArr.length || xArr.length !\u003d fArr[0].length)\n            throw new IllegalArgumentException(kInconsistantArrMsg);\n        if (xArr.length \u003c\u003d 1)\n            throw new IllegalArgumentException(kArrSizeMsg);\n        this.cAttr \u003d cAttr;\n        xArr1D \u003d xArr;\n        yArr1D \u003d yArr;\n        funcArray \u003d fArr;\n    }\n\n    /**\n     *  Construct a ContourGenerator object using the specified data arrays.\n     *  Contour attributes, including the interval, are generated\n     *  automatically.  This constructor allows you to use data on an\n     *  uneven X, Y grid.\n     *\n     *  @param  xArr   2D array containing the grid x coordinate data.\n     *  @param  yArr   2D array containing the grid y coordinate data.\n     *  @param  fArr   2D array containing the grid function (z) data.\n     *  @param  nc     The number of contour levels to generate.\n     *  @param  logInterval  Uses a logarithmic contour interval if true, and\n     *                       uses a linear interval if false.\n     */\n    public ContourGenerator(double[][] xArr, double[][] yArr, double[][] fArr, int nc, boolean logInterval) {\n        //\tMake sure input data is reasonable.\n        if (yArr.length !\u003d xArr.length || yArr.length !\u003d fArr.length)\n            throw new IllegalArgumentException(kInconsistantArrMsg);\n        if (yArr[0].length !\u003d xArr[0].length || yArr[0].length !\u003d fArr[0].length)\n            throw new IllegalArgumentException(kInconsistantArrMsg);\n        if (xArr.length \u003c\u003d 1 || xArr[0].length \u003c\u003d 1)\n            throw new IllegalArgumentException(kArrSizeMsg);\n        xArray \u003d xArr;\n        yArray \u003d yArr;\n        funcArray \u003d fArr;\n        if (logInterval)\n            findLogIntervals(nc);\n        else\n            findLinearIntervals(nc);\n    }\n\n    /**\n     *  Construct a ContourGenerator object using the specified data arrays.\n     *  Contour attributes, including the interval, are generated\n     *  automatically.  This constructor allows you\n     *  to use data on an evenly spaced grid where \"X\" values are invarient\n     *  with \"Y\" and \"Y\" values are invarient with \"X\".  This often occures\n     *  where the data is on an evenly spaced cartesian grid.\n     *\n     *  @param  xArr   1D array containing the grid x coordinate data.\n     *  @param  yArr   1D array containing the grid y coordinate data.\n     *  @param  fArr   2D array containing the grid function (z) data.\n     *  @param  nc     The number of contour levels to generate.\n     *  @param  logInterval  Uses a logarithmic contour interval if true, and\n     *                       uses a linear interval if false.\n     */\n    public ContourGenerator(double[] xArr, double[] yArr, double[][] fArr, int nc, boolean logInterval) {\n        //\tMake sure input data is reasonable.\n        if (yArr.length !\u003d fArr.length || xArr.length !\u003d fArr[0].length)\n            throw new IllegalArgumentException(kInconsistantArrMsg);\n        if (xArr.length \u003c\u003d 1)\n            throw new IllegalArgumentException(kArrSizeMsg);\n        xArr1D \u003d xArr;\n        yArr1D \u003d yArr;\n        funcArray \u003d fArr;\n        if (logInterval)\n            findLogIntervals(nc);\n        else\n            findLinearIntervals(nc);\n    }\n\n    /**\n     *  Generate the contour paths and return them as an array\n     *  of ContourPath objects. If there is a lot of data, this method\n     *  method may take a long time, so be patient.  Progress can be\n     *  checked from another thread by calling \"getProgress()\".\n     *\n     *  @return An array of contour path objects.\n     *  @throws InterruptedException if the user cancels this process\n     *          (by calling \"cancel()\" from another thread).\n     */\n    public ContourPath[] getContours() throws InterruptedException {\n        if (!cCalculated) {\n            isCanceled \u003d false;\n            pathList.clear();\n            //\tGo off an compute the contour paths.\n            computeContours();\n            //\tNow turn loose all our data arrays to be garbage collected.\n            cAttr \u003d null;\n            xArray \u003d yArray \u003d funcArray \u003d null;\n            xArr1D \u003d yArr1D \u003d null;\n            //\tSet our \"done\" flags.\n            cCalculated \u003d true;\n            fracComplete \u003d 1;\n        }\n        //\tTurn our pathList into an array and return the array.\n        int size \u003d pathList.size();\n        ContourPath[] arr \u003d new ContourPath[size];\n        for (int i \u003d 0; i \u003c size; ++i) arr[i] \u003d (ContourPath) pathList.get(i);\n        return arr;\n    }\n\n    /**\n     *  Returns true if the contour generation process is done.  False if it is not.\n     */\n    public boolean done() {\n        return cCalculated;\n    }\n\n    /**\n     *  Call this method to cancel the generation of contours.\n     */\n    public void cancel() {\n        isCanceled \u003d true;\n    }\n\n    /**\n     *  Returns the progress of the currently executing contour generation\n     *  process: 0.0 (just starting) to 1.0 (done).\n     */\n    public float getProgress() {\n        return fracComplete;\n    }\n\n    /**\n     *  Find contour intervals that are linearly spaced through the data.\n     */\n    private void findLinearIntervals(int nc) {\n        //\tFind min and max Z values.\n        double zMin \u003d Double.MAX_VALUE;\n        double zMax \u003d -zMin;\n        int ni \u003d funcArray.length;\n        for (int i \u003d 0; i \u003c ni; ++i) {\n            int nj \u003d funcArray[i].length;\n            for (int j \u003d 0; j \u003c nj; ++j) {\n                double zVal \u003d funcArray[i][j];\n                zMin \u003d Math.min(zMin, zVal);\n                zMax \u003d Math.max(zMax, zVal);\n            }\n        }\n        //\tAllocate memory for contour attribute array.\n        cAttr \u003d new ContourAttrib[nc];\n        //\tDetermine contour levels.\n        double delta \u003d (zMax - zMin) / (nc + 1);\n        for (int i \u003d 0; i \u003c nc; i++) {\n            cAttr[i] \u003d new ContourAttrib(zMin + (i + 1) * delta);\n            if (DEBUG)\n                System.out.println(\"level[\" + i + \"] \u003d \" + (zMin + (i + 1) * delta));\n        }\n    }\n\n    /**\n     *  Find contour intervals that are logarithmically spaced through the data.\n     */\n    private void findLogIntervals(int nc) {\n        //\tFind min and max Z values.\n        double zMin \u003d Double.MAX_VALUE;\n        double zMax \u003d -zMin;\n        int ni \u003d funcArray.length;\n        for (int i \u003d 0; i \u003c ni; ++i) {\n            int nj \u003d funcArray[i].length;\n            for (int j \u003d 0; j \u003c nj; ++j) {\n                double zVal \u003d funcArray[i][j];\n                zMin \u003d Math.min(zMin, zVal);\n                zMax \u003d Math.max(zMax, zVal);\n            }\n        }\n        if (zMin \u003c 0)\n            throw new IllegalArgumentException(kNegLogDataMsg);\n        //\tAllocate memory for contour attribute array.\n        cAttr \u003d new ContourAttrib[nc];\n        //\tDetermine contour levels.\n        double temp \u003d Math.log(zMin);\n        double delta \u003d (Math.log(zMax) - temp) / (nc + 1);\n        for (int i \u003d 0; i \u003c nc; i++) cAttr[i] \u003d new ContourAttrib(Math.exp(temp + (i + 1) * delta));\n    }\n\n    /**\n     *  Computes contour lines for gridded data and stores information about\n     *  those contours.  The result of this routine is a list of contour lines\n     *  or paths.\n     */\n    private void computeContours() throws InterruptedException {\n        //\tNumber of contour levels.\n        int ncont \u003d cAttr.length;\n        //\tFind the number of data points in \"I\" and \"J\" directions.\n        int nx \u003d 0, ny \u003d 0;\n        if (xArray !\u003d null) {\n            ny \u003d xArray.length;\n            nx \u003d xArray[0].length;\n        } else {\n            nx \u003d xArr1D.length;\n            ny \u003d yArr1D.length;\n        }\n        //\tAllocate temporary storage space for path buffers.\n        pathbufxt \u003d new double[kBufSize];\n        pathbufyt \u003d new double[kBufSize];\n        pathbufia \u003d new int[kBufSize * 3];\n        //\tlnstrt\u003d1 (line start) means we\u0027re starting a new line.\n        lnstrt \u003d 1;\n        ignext \u003d 0;\n        //\tLoop through each contour level.\n        for (icont \u003d 0; icont \u003c ncont; ++icont) {\n            //\tCheck to see if the user has canceled.\n            if (isCanceled)\n                throw new InterruptedException(kCancelMsg);\n            //\tBegin working on this contour level.\n            cont \u003d cAttr[icont].getLevel();\n            iss \u003d 1;\n            iee \u003d nx;\n            jss \u003d 1;\n            jee \u003d ny;\n            boolean subDivFlg \u003d false;\n            /*L110*/\n            do {\n                //\tFind where function increases through the contour level.\n                FlagContourPassings();\n                boolean L10flg \u003d false;\n                /*L210*/\n                do {\n                    if (!L10flg) {\n                        /*\tSearch along the boundaries for contour line starts.\n\t\t\t\t\t\t*\tIMA tells which boundary of the region we\u0027re on.\n\t\t\t\t\t\t*/\n                        ima \u003d 1;\n                        ibeg \u003d iss - 1;\n                        jbeg \u003d jss;\n                    }\n                    /*L6*/\n                    imaLoop: do {\n                        if (!L10flg) {\n                            boolean imb \u003d false;\n                            boolean doneFlg \u003d false;\n                            do {\n                                switch(ima) {\n                                    case 1:\n                                        ++ibeg;\n                                        if (ibeg \u003d\u003d iee)\n                                            ima \u003d 2;\n                                        break;\n                                    case 2:\n                                        ++jbeg;\n                                        if (jbeg \u003d\u003d jee)\n                                            ima \u003d 3;\n                                        break;\n                                    case 3:\n                                        --ibeg;\n                                        if (ibeg \u003d\u003d iss)\n                                            ima \u003d 4;\n                                        break;\n                                    case 4:\n                                        --jbeg;\n                                        if (jbeg \u003d\u003d jss)\n                                            ima \u003d 5;\n                                        break;\n                                    case 5:\n                                        continue imaLoop;\n                                }\n                                if (funcArray[jbeg - 1][ibeg - 1] \u003c\u003d cont) {\n                                    imb \u003d true;\n                                    doneFlg \u003d false;\n                                } else if (imb \u003d\u003d true)\n                                    doneFlg \u003d true;\n                            } while (!doneFlg);\n                            //\tGot a start point.\n                            //\tx index of starting point.\n                            gi \u003d ibeg;\n                            //\ty index of starting point.\n                            gj \u003d jbeg;\n                            //\tz value of starting point.\n                            fij \u003d funcArray[jbeg - 1][ibeg - 1];\n                            //\tRound the corner if necessary.\n                            /*\tLook different directions to see which way the contour line\n\t\t\t\t\t\t\t*\twent:\n\t\t\t\t\t\t\t*\t\t\t  4\n\t\t\t\t\t\t\t*\t\t\t1-|-3\n\t\t\t\t\t\t\t*\t\t\t  2\n\t\t\t\t\t\t\t*/\n                            switch(ima) {\n                                case 1:\n                                    Routine_L21();\n                                    break;\n                                case 2:\n                                    if (gj !\u003d jss) {\n                                        if (!Routine_L31())\n                                            Routine_L21();\n                                    } else\n                                        Routine_L21();\n                                    break;\n                                case 3:\n                                    if (gi !\u003d iee) {\n                                        if (!Routine_L41())\n                                            Routine_L21();\n                                    } else {\n                                        if (!Routine_L31())\n                                            Routine_L21();\n                                    }\n                                    break;\n                                case 4:\n                                    if (gj !\u003d jee) {\n                                        if (!Routine_L51())\n                                            Routine_L21();\n                                    } else {\n                                        if (!Routine_L41())\n                                            Routine_L21();\n                                    }\n                                    break;\n                                case 5:\n                                    if (!Routine_L51())\n                                        Routine_L21();\n                                    break;\n                            }\n                        }\n                        //\tend if(!L10flg)\n                        //\tThis is the end of a contour line.  After this, we\u0027ll start a\n                        //\tnew line.\n                        L10flg \u003d false;\n                        //\tContour line start flag.\n                        lnstrt \u003d 1;\n                        /*L90*/\n                        ignext \u003d 0;\n                        accumContour(np, icont, pathbufxt, pathbufyt, cAttr[icont]);\n                        //\tIf we\u0027re not done looking along the boundaries,\n                        //\tgo look there some more.\n                    } while (ima !\u003d 5);\n                    //\tOtherwise, get the next start out of IA.\n                    /*L91*/\n                    if (iae !\u003d 0) {\n                        int ntmp3 \u003d iae;\n                        for (int iia \u003d 1; iia \u003c\u003d ntmp3; ++iia) {\n                            if (pathbufia[iia - 1] !\u003d 0) {\n                                //\tThis is how we start in the middle of the region, using IA.\n                                gi \u003d pathbufia[iia - 1] / 1000;\n                                gj \u003d pathbufia[iia - 1] - gi * 1000;\n                                fij \u003d funcArray[gj - 1][gi - 1];\n                                pathbufia[iia - 1] \u003d 0;\n                                Routine_L21();\n                                L10flg \u003d true;\n                                break;\n                            }\n                        }\n                    }\n                } while (L10flg);\n                /*\tAnd if there are no more of these, we\u0027re done with this region.\n\t\t\t\t*   If we\u0027ve subdivided, update the region pointers and go back for more.\n\t\t\t\t*/\n                subDivFlg \u003d false;\n                if (iee \u003d\u003d nx) {\n                    if (jee !\u003d ny) {\n                        jss \u003d jee;\n                        jee \u003d ny;\n                        subDivFlg \u003d true;\n                    }\n                } else {\n                    iss \u003d iee;\n                    iee \u003d nx;\n                    subDivFlg \u003d true;\n                }\n            } while (subDivFlg);\n            //\tUpdate progress information.\n            fracComplete \u003d (float) (icont + 1) / (float) (ncont);\n            //\tLoop back for the next contour level.\n        }\n        // Next icont\n        //\tTurn loose temporary arrays used to generate contours.\n        pathbufxt \u003d null;\n        pathbufyt \u003d null;\n        pathbufia \u003d null;\n    }\n\n    /**\n     *  Flag points in IA where the the function increases through the contour\n     *  level, not including the boundaries.  This is so we have a list of at least\n     *  one point on each contour line that doesn\u0027t intersect a boundary.\n     */\n    private void FlagContourPassings() {\n        iae \u003d 0;\n        int ntmp2 \u003d jee - 1;\n        for (int j \u003d jss + 1; j \u003c\u003d ntmp2; ++j) {\n            boolean imb \u003d false;\n            int iaend \u003d iae;\n            int ntmp3 \u003d iee;\n            for (int i \u003d iss; i \u003c\u003d ntmp3; ++i) {\n                if (funcArray[j - 1][i - 1] \u003c\u003d cont)\n                    imb \u003d true;\n                else if (imb \u003d\u003d true) {\n                    ++iae;\n                    pathbufia[iae - 1] \u003d i * 1000 + j;\n                    imb \u003d false;\n                    /*  Check if the IA array is full.  If so, the subdividing\n\t\t\t\t\t*   algorithm goes like this:  if we\u0027ve marked at least one\n\t\t\t\t\t*   J row, drop back to the last completed J and call that\n\t\t\t\t\t*   the region.  If we haven\u0027t even finished one J row, our\n\t\t\t\t\t*   region just extends to this I location.\n\t\t\t\t\t*/\n                    if (iae \u003d\u003d kBufSize * 3) {\n                        if (j \u003e jss + 1) {\n                            iae \u003d iaend;\n                            jee \u003d j;\n                        } else {\n                            //\tCompute minimum.\n                            jee \u003d Math.min(j + 1, jee);\n                            iee \u003d i;\n                        }\n                        //\tBreak out of i \u0026 j loops.\n                        return;\n                    }\n                }\n            }\n            //\tNext i\n        }\n        //\tNext j\n    }\n\n    /**\n     *  This function represents the block of code in the original\n     *  FORTRAN program that comes after line 21.\n     */\n    private void Routine_L21() {\n        while (true) {\n            --gi;\n            if (gi \u003c iss)\n                //\tGoto L90.\n                return;\n            idir \u003d 1;\n            if (funcArray[gj - 1][gi - 1] \u003c\u003d cont) {\n                //\tWipe this point out of IA if it\u0027s in the list.\n                /*L52*/\n                if (iae !\u003d 0) {\n                    int ij \u003d gi * 1000 + gj + 1000;\n                    int ntmp3 \u003d iae;\n                    for (int iia \u003d 1; iia \u003c\u003d ntmp3; ++iia) {\n                        if (pathbufia[iia - 1] \u003d\u003d ij) {\n                            pathbufia[iia - 1] \u003d 0;\n                            break;\n                        }\n                    }\n                }\n                doInterpolation();\n                //\tGoto L90.\n                return;\n            }\n            fij \u003d funcArray[gj - 1][gi - 1];\n            //\tGoto L90\n            if (Routine_L31())\n                return;\n        }\n    }\n\n    /**\n     *  This function represents the block of code in the original\n     *  FORTRAN program that comes after line 31.\n     */\n    private boolean Routine_L31() {\n        --gj;\n        if (gj \u003c jss)\n            return true;\n        idir \u003d 2;\n        if (funcArray[gj - 1][gi - 1] \u003c\u003d cont) {\n            doInterpolation();\n            return true;\n        }\n        fij \u003d funcArray[gj - 1][gi - 1];\n        return (Routine_L41());\n    }\n\n    /**\n     *  This function represents the block of code in the original\n     *  FORTRAN program that comes after line 41.\n     */\n    private boolean Routine_L41() {\n        ++gi;\n        if (gi \u003e iee)\n            return true;\n        idir \u003d 3;\n        if (funcArray[gj - 1][gi - 1] \u003c\u003d cont) {\n            doInterpolation();\n            return true;\n        }\n        fij \u003d funcArray[gj - 1][gi - 1];\n        return (Routine_L51());\n    }\n\n    /**\n     *  This function represents the block of code in the original\n     *  FORTRAN program that comes after line 51.\n     */\n    private boolean Routine_L51() {\n        ++gj;\n        idir \u003d 4;\n        if (gj \u003e jee)\n            return true;\n        if (funcArray[gj - 1][gi - 1] \u003c\u003d cont) {\n            doInterpolation();\n            return true;\n        }\n        fij \u003d funcArray[gj - 1][gi - 1];\n        return false;\n    }\n\n    /**\n     *  Do interpolation for X, Y coordinates.\n     *\n     *  This function represents the block of code in the original\n     *  FORTRAN program that comes after line 60.\n     */\n    private void doInterpolation() {\n        //\tDo interpolation for X,Y coordinates.\n        double func \u003d funcArray[gj - 1][gi - 1];\n        double xyf \u003d (cont - func) / (fij - func);\n        /*  This tests for a contour point coinciding with a grid point.  In this case\n\t\t *  the contour routine comes up with the same physical coordinate twice.  If\n\t\t *  If we don\u0027t trap it, it can (in some cases significantly) increase the\n\t\t *  number of points in a contour line.  Also, if this happens on the first\n\t\t *  point in a line, the second point could be misinterpreted as the end of a\n\t\t *   (circling) contour line.\n\t\t */\n        if (xyf \u003d\u003d 0)\n            ++ignext;\n        double wxx \u003d 0, wyy \u003d 0;\n        double xVal \u003d 0, yVal \u003d 0;\n        if (xArray !\u003d null) {\n            //\tWe have 2D arrays for the X \u0026 Y grid points.\n            xVal \u003d xArray[gj - 1][gi - 1];\n            yVal \u003d yArray[gj - 1][gi - 1];\n            switch(idir) {\n                case //\tEast\n                1:\n                    wxx \u003d xVal + xyf * (xArray[gj - 1][gi + 1 - 1] - xVal);\n                    wyy \u003d yVal + xyf * (yArray[gj - 1][gi + 1 - 1] - yVal);\n                    break;\n                case //\tNorth\n                2:\n                    wxx \u003d xVal + xyf * (xArray[gj + 1 - 1][gi - 1] - xVal);\n                    wyy \u003d yVal + xyf * (yArray[gj + 1 - 1][gi - 1] - yVal);\n                    break;\n                case //\tWest\n                3:\n                    wxx \u003d xVal + xyf * (xArray[gj - 1][gi - 1 - 1] - xVal);\n                    wyy \u003d yVal + xyf * (yArray[gj - 1][gi - 1 - 1] - yVal);\n                    break;\n                case //\tSouth\n                4:\n                    wxx \u003d xVal + xyf * (xArray[gj - 1 - 1][gi - 1] - xVal);\n                    wyy \u003d yVal + xyf * (yArray[gj - 1 - 1][gi - 1] - yVal);\n                    break;\n            }\n        } else {\n            //\tWe have 1D arrays for the X \u0026 Y grid points.\n            xVal \u003d xArr1D[gi - 1];\n            yVal \u003d yArr1D[gj - 1];\n            switch(idir) {\n                case //\tEast\n                1:\n                    wxx \u003d xVal + xyf * (xArr1D[gi + 1 - 1] - xVal);\n                    wyy \u003d yVal;\n                    break;\n                case //\tNorth\n                2:\n                    wxx \u003d xVal;\n                    wyy \u003d yVal + xyf * (yArr1D[gj + 1 - 1] - yVal);\n                    break;\n                case //\tWest\n                3:\n                    wxx \u003d xVal + xyf * (xArr1D[gi - 1 - 1] - xVal);\n                    wyy \u003d yVal;\n                    break;\n                case //\tSouth\n                4:\n                    wxx \u003d xVal;\n                    wyy \u003d yVal + xyf * (yArr1D[gj - 1 - 1] - yVal);\n                    break;\n            }\n        }\n        if (DEBUG) {\n            System.out.println(\"i, j \u003d \" + gi + \",\" + gj);\n            System.out.println(\"cont \u003d \" + (float) cont + \",  fij \u003d \" + (float) fij + \",  func \u003d \" + (float) func + \",  xyf \u003d \" + (float) xyf);\n            System.out.println(\"xVal \u003d \" + (float) xVal + \",  yVal \u003d \" + (float) yVal);\n            System.out.println(\"wxx \u003d \" + (float) wxx + \",  wyy \u003d \" + (float) wyy);\n        }\n        //\tFigure out what to do with this point.\n        if (lnstrt \u003d\u003d 1) {\n            //\tThis is the 1st point in the contour line.\n            np \u003d 1;\n            pathbufxt[np - 1] \u003d wxx;\n            pathbufyt[np - 1] \u003d wyy;\n            //\tSave starting point as wx, wy.\n            wx \u003d wxx;\n            wy \u003d wyy;\n            //\tClear the first point flag, we\u0027ve got one now.\n            lnstrt \u003d 0;\n        } else {\n            boolean skipFlg \u003d false;\n            //\tSecond point and after comes here.\n            //\tAdd a point to this line.  Check for duplicate point first.\n            if (ignext \u003d\u003d 2) {\n                if (wxx \u003d\u003d pathbufxt[np - 1] \u0026\u0026 wyy \u003d\u003d pathbufyt[np - 1]) {\n                    ignext \u003d 0;\n                    skipFlg \u003d true;\n                } else\n                    ignext \u003d 1;\n            }\n            if (!skipFlg) {\n                //\tIncrement # of points in contour.\n                ++np;\n                pathbufxt[np - 1] \u003d wxx;\n                pathbufyt[np - 1] \u003d wyy;\n                //\tSee if the temporary array xt, yt are full.\n                if (np \u003d\u003d kBufSize) {\n                    accumContour(np, icont, pathbufxt, pathbufyt, cAttr[icont]);\n                    //\tLast point becomes 1st point to continue.\n                    pathbufxt[0] \u003d pathbufxt[np - 1];\n                    pathbufyt[0] \u003d pathbufyt[np - 1];\n                    np \u003d 1;\n                }\n                //\tCheck to see if we\u0027re back to the intial point.\n                if (wxx \u003d\u003d wx \u0026\u0026 wyy \u003d\u003d wy)\n                    return;\n            }\n        }\n        //\tSearch for the next point on this line.\n        /*L67*/\n        switch(idir) {\n            case 1:\n                ++gi;\n                if (!Routine_L51())\n                    Routine_L21();\n                break;\n            case 2:\n                ++gj;\n                Routine_L21();\n                break;\n            case 3:\n                --gi;\n                if (!Routine_L31())\n                    Routine_L21();\n                break;\n            case 4:\n                --gj;\n                if (!Routine_L41())\n                    Routine_L21();\n                break;\n        }\n        return;\n    }\n\n    /**\n     *  Accumulate contour paths, as they are generated, into\n     *  an overall list of contours.\n     *\n     *  @param  np      The number of points in the contour path buffers.\n     *  @param  icont   The index to the current contour level.\n     *  @param  x,y     Buffers containing x \u0026 y coordinates of contour points.\n     *  @param  cAttr   The attributes for this particular contour level.\n     */\n    private void accumContour(int np, int icont, double[] x, double[] y, ContourAttrib cAttr) {\n        //\tTo few points for a contour line.\n        if (np \u003c kMinNumPoints)\n            return;\n        //\tCopy over coordinate points from buffers to their own arrays.\n        double[] xArr \u003d new double[np];\n        double[] yArr \u003d new double[np];\n        System.arraycopy(x, 0, xArr, 0, np);\n        System.arraycopy(y, 0, yArr, 0, np);\n        //\tCreate a new contour path and add it to the list.\n        ContourPath path \u003d new ContourPath(cAttr, icont, xArr, yArr);\n        pathList.add(path);\n    }\n}\n",
    "package": "jahuwaldt.plot",
    "classname": "ContourGenerator",
    "id": "/EvoSuiteBenchmark/original/29_apbsmem/src/main/java/jahuwaldt/plot/ContourGenerator.java",
    "test_prompt": "// ContourGeneratorTest.java\npackage jahuwaldt.plot;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ContourGenerator}.\n* It contains ten unit test cases for the {@link ContourGenerator#done()} method.\n*/\nclass ContourGeneratorTest {",
    "method_signature": "done()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// PlotDatum.java\n/*\n*   PlotDatum  -- Represents a single data point on a 2D plot.\n*\n*   Copyright (C) 2000-2002 by Joseph A. Huwaldt \u003cjhuwaldt@knology.net\u003e.\n*   All rights reserved.\n*   \n*   This library is free software; you can redistribute it and/or\n*   modify it under the terms of the GNU Library General Public\n*   License as published by the Free Software Foundation; either\n*   version 2 of the License, or (at your option) any later version.\n*   \n*   This library is distributed in the hope that it will be useful,\n*   but WITHOUT ANY WARRANTY; without even the implied warranty of\n*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n*   Library General Public License for more details.\n**/\npackage jahuwaldt.plot;\n\nimport java.awt.Color;\n\n/**\n *  \u003cp\u003e This class represents a single data point on a plot\n *      and includes all the information required by each point.\n *  \u003c/p\u003e\n *\n *  \u003cp\u003e  Modified by:  Joseph A. Huwaldt  \u003c/p\u003e\n *\n *  @author  Joseph A. Huwaldt   Date:  June 1, 2000\n *  @version November 20, 2000\n */\npublic class PlotDatum extends Object implements Cloneable, java.io.Serializable {\n\n    /**\n     *  The X and Y coordinate points for this datum.\n     */\n    public double x, y;\n\n    /**\n     *  The error on the Y value.\n     */\n    private double yErr;\n\n    /**\n     *  A flag that indicates if there is an error bar.\n     */\n    private boolean errBarFlg \u003d false;\n\n    /**\n     *  Flag that indicates if this point connects to the previous point.\n     */\n    private boolean conFlg;\n\n    /**\n     *  The line type for the line connecting this point to the previous point.\n     *  This is not yet implemented!  Waiting until I learn Java2D.\n     */\n    //\tprivate int lineMode;\n    /**\n     *  The line color used to connect this point to the previous one.\n     */\n    private Color lineColor \u003d Color.black;\n\n    /**\n     *  The plot symbol used by this datum.\n     */\n    private PlotSymbol symbol \u003d null;\n\n    //-------------------------------------------------------------------------\n    /**\n     *  Create a new datum (plot coordinate point) given the specified\n     *  X and Y values.  This datum will, by default, have no error bar.\n     *\n     *  @param xValue  The X coordinate value for this datum point.\n     *  @param yValue  The Y coordinate value for this datum point.\n     *  @param connected  A flag that indicates that this datum is connected\n     *                    to the previous one if true, no line is drawn\n     *                    to the previous datum if false.\n     */\n    public PlotDatum(double xValue, double yValue, boolean connected) {\n        super();\n        x \u003d xValue;\n        y \u003d yValue;\n        conFlg \u003d connected;\n    }\n\n    /**\n     *  Create a new datum (plot coordinate point) given the specified\n     *  X and Y values and the given plot symbol.  This datum will, by\n     *  default, have no error bar.\n     *\n     *  @param xValue  The X coordinate value for this datum point.\n     *  @param yValue  The Y coordinate value for this datum point.\n     *  @param connected  A flag that indicates that this datum is connected\n     *                    to the previous one if true, no line is drawn\n     *                    to the previous datum if false.\n     *  @param  symbol  The plot symbol to be used for this data point.\n     */\n    public PlotDatum(double xValue, double yValue, boolean connected, PlotSymbol symbol) {\n        super();\n        x \u003d xValue;\n        y \u003d yValue;\n        conFlg \u003d connected;\n        this.symbol \u003d symbol;\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     *  Return the X coordinate value of this point.\n     */\n    public double getX() {\n        return x;\n    }\n\n    /**\n     *  Return the Y coordinate value of this point.\n     */\n    public double getY() {\n        return y;\n    }\n\n    /**\n     *  Set the X coordinate value of this point.\n     */\n    public void setX(double value) {\n        x \u003d value;\n    }\n\n    /**\n     *  Set the Y coordinate value of this point.\n     */\n    public void setY(double value) {\n        y \u003d value;\n    }\n\n    /**\n     *  Set the error on Y value.\n     */\n    public void setYError(double err) {\n        yErr \u003d err;\n        if (yErr \u003d\u003d 0.)\n            errBarFlg \u003d false;\n        else\n            errBarFlg \u003d true;\n    }\n\n    /**\n     *  Get the error on Y value.\n     */\n    public double getYError() {\n        return yErr;\n    }\n\n    /**\n     *  Returns true if this data point has an error bar.\n     */\n    public boolean hasErrorBar() {\n        return errBarFlg;\n    }\n\n    /**\n     *  Set if this datum is connected to the previous one by a line or not.\n     */\n    public void setConnected(boolean flag) {\n        conFlg \u003d flag;\n    }\n\n    /**\n     *  Return true if this datum is connected to the previous one by a line\n     *  and false if it is not.\n     */\n    public boolean connected() {\n        return conFlg;\n    }\n\n    /**\n     *  Set the plot symbol used for this datum.\n     */\n    public void setPlotSymbol(PlotSymbol symbol) {\n        this.symbol \u003d symbol;\n    }\n\n    /**\n     *  Returns a reference to the plot symbol used by\n     *  this datum.\n     */\n    public PlotSymbol getPlotSymbol() {\n        return symbol;\n    }\n\n    /**\n     *  Set the color used for the line connecting this datum\n     *  to the previous one.  If null is passed, the line is\n     *  drawn in black.\n     */\n    public void setLineColor(Color color) {\n        if (color !\u003d null)\n            lineColor \u003d color;\n        else\n            lineColor \u003d Color.black;\n    }\n\n    /**\n     *  Return the color to be used for drawing the line\n     *  connecting this datum to the previous.\n     */\n    public Color getLineColor() {\n        return lineColor;\n    }\n\n    /**\n     *  Make a copy of this PlotDatum object.\n     *\n     *  @return  Returns a clone of this object.\n     */\n    public Object clone() {\n        PlotDatum newObject \u003d null;\n        try {\n            // Make a shallow copy of this object.\n            newObject \u003d (PlotDatum) super.clone();\n            // Clone this object\u0027s data structures.\n            if (this.symbol !\u003d null)\n                newObject.symbol \u003d (PlotSymbol) this.symbol.clone();\n        } catch (CloneNotSupportedException e) {\n            // Can\u0027t happen.\n            e.printStackTrace();\n        }\n        // Output the newly cloned object.\n        return newObject;\n    }\n}\n",
    "package": "jahuwaldt.plot",
    "classname": "PlotDatum",
    "id": "/EvoSuiteBenchmark/original/29_apbsmem/src/main/java/jahuwaldt/plot/PlotDatum_0Test.java",
    "test_prompt": "// PlotDatum_0Test.java\npackage jahuwaldt.plot;\n\nimport java.awt.Color;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PlotDatum}.\n* It contains ten unit test cases for the {@link PlotDatum#hasErrorBar()} method.\n*/\nclass PlotDatum_0Test {",
    "method_signature": "hasErrorBar()",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// PlotDatum.java\n/*\n*   PlotDatum  -- Represents a single data point on a 2D plot.\n*\n*   Copyright (C) 2000-2002 by Joseph A. Huwaldt \u003cjhuwaldt@knology.net\u003e.\n*   All rights reserved.\n*   \n*   This library is free software; you can redistribute it and/or\n*   modify it under the terms of the GNU Library General Public\n*   License as published by the Free Software Foundation; either\n*   version 2 of the License, or (at your option) any later version.\n*   \n*   This library is distributed in the hope that it will be useful,\n*   but WITHOUT ANY WARRANTY; without even the implied warranty of\n*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n*   Library General Public License for more details.\n**/\npackage jahuwaldt.plot;\n\nimport java.awt.Color;\n\n/**\n *  \u003cp\u003e This class represents a single data point on a plot\n *      and includes all the information required by each point.\n *  \u003c/p\u003e\n *\n *  \u003cp\u003e  Modified by:  Joseph A. Huwaldt  \u003c/p\u003e\n *\n *  @author  Joseph A. Huwaldt   Date:  June 1, 2000\n *  @version November 20, 2000\n */\npublic class PlotDatum extends Object implements Cloneable, java.io.Serializable {\n\n    /**\n     *  The X and Y coordinate points for this datum.\n     */\n    public double x, y;\n\n    /**\n     *  The error on the Y value.\n     */\n    private double yErr;\n\n    /**\n     *  A flag that indicates if there is an error bar.\n     */\n    private boolean errBarFlg \u003d false;\n\n    /**\n     *  Flag that indicates if this point connects to the previous point.\n     */\n    private boolean conFlg;\n\n    /**\n     *  The line type for the line connecting this point to the previous point.\n     *  This is not yet implemented!  Waiting until I learn Java2D.\n     */\n    //\tprivate int lineMode;\n    /**\n     *  The line color used to connect this point to the previous one.\n     */\n    private Color lineColor \u003d Color.black;\n\n    /**\n     *  The plot symbol used by this datum.\n     */\n    private PlotSymbol symbol \u003d null;\n\n    //-------------------------------------------------------------------------\n    /**\n     *  Create a new datum (plot coordinate point) given the specified\n     *  X and Y values.  This datum will, by default, have no error bar.\n     *\n     *  @param xValue  The X coordinate value for this datum point.\n     *  @param yValue  The Y coordinate value for this datum point.\n     *  @param connected  A flag that indicates that this datum is connected\n     *                    to the previous one if true, no line is drawn\n     *                    to the previous datum if false.\n     */\n    public PlotDatum(double xValue, double yValue, boolean connected) {\n        super();\n        x \u003d xValue;\n        y \u003d yValue;\n        conFlg \u003d connected;\n    }\n\n    /**\n     *  Create a new datum (plot coordinate point) given the specified\n     *  X and Y values and the given plot symbol.  This datum will, by\n     *  default, have no error bar.\n     *\n     *  @param xValue  The X coordinate value for this datum point.\n     *  @param yValue  The Y coordinate value for this datum point.\n     *  @param connected  A flag that indicates that this datum is connected\n     *                    to the previous one if true, no line is drawn\n     *                    to the previous datum if false.\n     *  @param  symbol  The plot symbol to be used for this data point.\n     */\n    public PlotDatum(double xValue, double yValue, boolean connected, PlotSymbol symbol) {\n        super();\n        x \u003d xValue;\n        y \u003d yValue;\n        conFlg \u003d connected;\n        this.symbol \u003d symbol;\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     *  Return the X coordinate value of this point.\n     */\n    public double getX() {\n        return x;\n    }\n\n    /**\n     *  Return the Y coordinate value of this point.\n     */\n    public double getY() {\n        return y;\n    }\n\n    /**\n     *  Set the X coordinate value of this point.\n     */\n    public void setX(double value) {\n        x \u003d value;\n    }\n\n    /**\n     *  Set the Y coordinate value of this point.\n     */\n    public void setY(double value) {\n        y \u003d value;\n    }\n\n    /**\n     *  Set the error on Y value.\n     */\n    public void setYError(double err) {\n        yErr \u003d err;\n        if (yErr \u003d\u003d 0.)\n            errBarFlg \u003d false;\n        else\n            errBarFlg \u003d true;\n    }\n\n    /**\n     *  Get the error on Y value.\n     */\n    public double getYError() {\n        return yErr;\n    }\n\n    /**\n     *  Returns true if this data point has an error bar.\n     */\n    public boolean hasErrorBar() {\n        return errBarFlg;\n    }\n\n    /**\n     *  Set if this datum is connected to the previous one by a line or not.\n     */\n    public void setConnected(boolean flag) {\n        conFlg \u003d flag;\n    }\n\n    /**\n     *  Return true if this datum is connected to the previous one by a line\n     *  and false if it is not.\n     */\n    public boolean connected() {\n        return conFlg;\n    }\n\n    /**\n     *  Set the plot symbol used for this datum.\n     */\n    public void setPlotSymbol(PlotSymbol symbol) {\n        this.symbol \u003d symbol;\n    }\n\n    /**\n     *  Returns a reference to the plot symbol used by\n     *  this datum.\n     */\n    public PlotSymbol getPlotSymbol() {\n        return symbol;\n    }\n\n    /**\n     *  Set the color used for the line connecting this datum\n     *  to the previous one.  If null is passed, the line is\n     *  drawn in black.\n     */\n    public void setLineColor(Color color) {\n        if (color !\u003d null)\n            lineColor \u003d color;\n        else\n            lineColor \u003d Color.black;\n    }\n\n    /**\n     *  Return the color to be used for drawing the line\n     *  connecting this datum to the previous.\n     */\n    public Color getLineColor() {\n        return lineColor;\n    }\n\n    /**\n     *  Make a copy of this PlotDatum object.\n     *\n     *  @return  Returns a clone of this object.\n     */\n    public Object clone() {\n        PlotDatum newObject \u003d null;\n        try {\n            // Make a shallow copy of this object.\n            newObject \u003d (PlotDatum) super.clone();\n            // Clone this object\u0027s data structures.\n            if (this.symbol !\u003d null)\n                newObject.symbol \u003d (PlotSymbol) this.symbol.clone();\n        } catch (CloneNotSupportedException e) {\n            // Can\u0027t happen.\n            e.printStackTrace();\n        }\n        // Output the newly cloned object.\n        return newObject;\n    }\n}\n",
    "package": "jahuwaldt.plot",
    "classname": "PlotDatum",
    "id": "/EvoSuiteBenchmark/original/29_apbsmem/src/main/java/jahuwaldt/plot/PlotDatum_1Test.java",
    "test_prompt": "// PlotDatum_1Test.java\npackage jahuwaldt.plot;\n\nimport java.awt.Color;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PlotDatum}.\n* It contains ten unit test cases for the {@link PlotDatum#connected()} method.\n*/\nclass PlotDatum_1Test {",
    "method_signature": "connected()",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// FileEditor.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage apbs_mem_gui;\n\n/**\n * @author keithc\n */\nimport java.io.*;\nimport java.util.Scanner;\nimport java.text.*;\n\npublic class FileEditor {\n\n    /**\n     * Extract energy from the final APBS output file.\n     * @param filename Path to APBS output file.\n     * @return String array of total energies in kilojoules, kilocalories and k_BT\n     */\n    public String[] getEnergy(String filename) {\n        //returns [0] energy in kJ/mol, then [1] is in kcal/mol\n        File temp \u003d new File(filename);\n        String[] energies \u003d new String[3];\n        if (!temp.exists())\n            return null;\n        else {\n            NumberFormat formatter \u003d new DecimalFormat(\"0.####E0\");\n            double finalenergy \u003d 0;\n            try {\n                Scanner fScan \u003d new Scanner(new FileInputStream(filename));\n                String nextline;\n                //tells whether solvated or reference\n                boolean solvated \u003d true;\n                while (fScan.hasNextLine()) {\n                    nextline \u003d fScan.nextLine();\n                    if (nextline.contains(\"elec name solvated\")) {\n                        solvated \u003d true;\n                    } else if (nextline.contains(\"elec name reference\")) {\n                        solvated \u003d false;\n                    } else if (nextline.contains(\"Global net ELEC energy \") \u0026\u0026 solvated) {\n                        //if found energy and its in solvated\n                        System.out.println(nextline);\n                        if (nextline.contains(\"+\")) {\n                            //if its time 10^positive int\n                            finalenergy \u003d toDoublePos(nextline);\n                        } else {\n                            //if its time 10^negative int\n                            finalenergy \u003d toDoubleNeg(nextline);\n                        }\n                    }\n                }\n            } catch (Exception e1) {\n                e1.printStackTrace();\n            }\n            energies[0] \u003d formatter.format(finalenergy) + \" kJ/mol\";\n            energies[1] \u003d formatter.format(finalenergy * 0.239) + \" kcal/mol\";\n            energies[2] \u003d formatter.format(finalenergy * 0.4035) + \" kT\";\n            return energies;\n        }\n    }\n\n    /**\n     * Extract the energy from a calculation that has summed the component atom energies\n     * rather than simply taking the total. (pull_comps.c)\n     * @param filename Path to the file written by pull_comps with the energy sum.\n     * @return a double array of the total energy of each calculation (up to 6 calculations if there are 3 focus levels).\n     */\n    public double[] getCompEnergy(String filename) {\n        File temp \u003d new File(filename);\n        if (!temp.exists())\n            return null;\n        else {\n            double[] finalenergy \u003d new double[6];\n            int i \u003d 0;\n            try {\n                Scanner fScan \u003d new Scanner(new FileInputStream(filename));\n                String nextline;\n                double D;\n                while (fScan.hasNextLine()) {\n                    nextline \u003d fScan.nextLine();\n                    System.out.println(nextline);\n                    if (!nextline.equals(\"\")) {\n                        if (nextline.contains(\"+\")) {\n                            //if its time 10^positive int\n                            D \u003d Double.parseDouble(nextline.substring(0, (nextline.lastIndexOf(\"+\") - 1)));\n                            D *\u003d Math.pow(10, Double.parseDouble(nextline.substring(nextline.indexOf(\"+\") + 1)));\n                            //  /(temperature*0.008314472); // convert to kT\n                            finalenergy[i] \u003d D;\n                        } else {\n                            //if its time 10^negative int\n                            D \u003d Double.parseDouble(nextline.substring(0, (nextline.lastIndexOf(\"-\") - 1)));\n                            D *\u003d Math.pow(10, Double.parseDouble(nextline.substring(nextline.lastIndexOf(\"-\"))));\n                            //  /(temperature*0.008314472);\n                            finalenergy[i] \u003d D;\n                        }\n                        i++;\n                    }\n                }\n            } catch (Exception e1) {\n                e1.printStackTrace();\n            }\n            return finalenergy;\n        }\n    }\n\n    private double toDoublePos(String theDouble) {\n        double D;\n        D \u003d Double.parseDouble(theDouble.substring((theDouble.indexOf(\"Global net ELEC energy \") + 25), (theDouble.lastIndexOf(\"+\") - 1)));\n        return (D *\u003d Math.pow(10, Double.parseDouble(theDouble.substring((theDouble.indexOf(\"+\") + 1), theDouble.indexOf(\" kJ\")))));\n    }\n\n    private double toDoubleNeg(String theDouble) {\n        double D;\n        D \u003d Double.parseDouble(theDouble.substring((theDouble.indexOf(\"Global net ELEC energy \") + 25), (theDouble.lastIndexOf(\"-\") - 1)));\n        return (D *\u003d Math.pow(10, Double.parseDouble(theDouble.substring(theDouble.lastIndexOf(\"-\"), theDouble.indexOf(\" kJ\")))));\n    }\n}\n",
    "package": "apbs_mem_gui",
    "classname": "FileEditor",
    "id": "/EvoSuiteBenchmark/original/29_apbsmem/src/main/java/apbs_mem_gui/FileEditor_0Test.java",
    "test_prompt": "// FileEditor_0Test.java\npackage apbs_mem_gui;\n\n/**\n * @author keithc\n */\nimport java.io.*;\nimport java.util.Scanner;\nimport java.text.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileEditor}.\n* It contains ten unit test cases for the {@link FileEditor#getEnergy(String)} method.\n*/\nclass FileEditor_0Test {",
    "method_signature": "getEnergy(String)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// FileEditor.java\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage apbs_mem_gui;\n\n/**\n * @author keithc\n */\nimport java.io.*;\nimport java.util.Scanner;\nimport java.text.*;\n\npublic class FileEditor {\n\n    /**\n     * Extract energy from the final APBS output file.\n     * @param filename Path to APBS output file.\n     * @return String array of total energies in kilojoules, kilocalories and k_BT\n     */\n    public String[] getEnergy(String filename) {\n        //returns [0] energy in kJ/mol, then [1] is in kcal/mol\n        File temp \u003d new File(filename);\n        String[] energies \u003d new String[3];\n        if (!temp.exists())\n            return null;\n        else {\n            NumberFormat formatter \u003d new DecimalFormat(\"0.####E0\");\n            double finalenergy \u003d 0;\n            try {\n                Scanner fScan \u003d new Scanner(new FileInputStream(filename));\n                String nextline;\n                //tells whether solvated or reference\n                boolean solvated \u003d true;\n                while (fScan.hasNextLine()) {\n                    nextline \u003d fScan.nextLine();\n                    if (nextline.contains(\"elec name solvated\")) {\n                        solvated \u003d true;\n                    } else if (nextline.contains(\"elec name reference\")) {\n                        solvated \u003d false;\n                    } else if (nextline.contains(\"Global net ELEC energy \") \u0026\u0026 solvated) {\n                        //if found energy and its in solvated\n                        System.out.println(nextline);\n                        if (nextline.contains(\"+\")) {\n                            //if its time 10^positive int\n                            finalenergy \u003d toDoublePos(nextline);\n                        } else {\n                            //if its time 10^negative int\n                            finalenergy \u003d toDoubleNeg(nextline);\n                        }\n                    }\n                }\n            } catch (Exception e1) {\n                e1.printStackTrace();\n            }\n            energies[0] \u003d formatter.format(finalenergy) + \" kJ/mol\";\n            energies[1] \u003d formatter.format(finalenergy * 0.239) + \" kcal/mol\";\n            energies[2] \u003d formatter.format(finalenergy * 0.4035) + \" kT\";\n            return energies;\n        }\n    }\n\n    /**\n     * Extract the energy from a calculation that has summed the component atom energies\n     * rather than simply taking the total. (pull_comps.c)\n     * @param filename Path to the file written by pull_comps with the energy sum.\n     * @return a double array of the total energy of each calculation (up to 6 calculations if there are 3 focus levels).\n     */\n    public double[] getCompEnergy(String filename) {\n        File temp \u003d new File(filename);\n        if (!temp.exists())\n            return null;\n        else {\n            double[] finalenergy \u003d new double[6];\n            int i \u003d 0;\n            try {\n                Scanner fScan \u003d new Scanner(new FileInputStream(filename));\n                String nextline;\n                double D;\n                while (fScan.hasNextLine()) {\n                    nextline \u003d fScan.nextLine();\n                    System.out.println(nextline);\n                    if (!nextline.equals(\"\")) {\n                        if (nextline.contains(\"+\")) {\n                            //if its time 10^positive int\n                            D \u003d Double.parseDouble(nextline.substring(0, (nextline.lastIndexOf(\"+\") - 1)));\n                            D *\u003d Math.pow(10, Double.parseDouble(nextline.substring(nextline.indexOf(\"+\") + 1)));\n                            //  /(temperature*0.008314472); // convert to kT\n                            finalenergy[i] \u003d D;\n                        } else {\n                            //if its time 10^negative int\n                            D \u003d Double.parseDouble(nextline.substring(0, (nextline.lastIndexOf(\"-\") - 1)));\n                            D *\u003d Math.pow(10, Double.parseDouble(nextline.substring(nextline.lastIndexOf(\"-\"))));\n                            //  /(temperature*0.008314472);\n                            finalenergy[i] \u003d D;\n                        }\n                        i++;\n                    }\n                }\n            } catch (Exception e1) {\n                e1.printStackTrace();\n            }\n            return finalenergy;\n        }\n    }\n\n    private double toDoublePos(String theDouble) {\n        double D;\n        D \u003d Double.parseDouble(theDouble.substring((theDouble.indexOf(\"Global net ELEC energy \") + 25), (theDouble.lastIndexOf(\"+\") - 1)));\n        return (D *\u003d Math.pow(10, Double.parseDouble(theDouble.substring((theDouble.indexOf(\"+\") + 1), theDouble.indexOf(\" kJ\")))));\n    }\n\n    private double toDoubleNeg(String theDouble) {\n        double D;\n        D \u003d Double.parseDouble(theDouble.substring((theDouble.indexOf(\"Global net ELEC energy \") + 25), (theDouble.lastIndexOf(\"-\") - 1)));\n        return (D *\u003d Math.pow(10, Double.parseDouble(theDouble.substring(theDouble.lastIndexOf(\"-\"), theDouble.indexOf(\" kJ\")))));\n    }\n}\n",
    "package": "apbs_mem_gui",
    "classname": "FileEditor",
    "id": "/EvoSuiteBenchmark/original/29_apbsmem/src/main/java/apbs_mem_gui/FileEditor_1Test.java",
    "test_prompt": "// FileEditor_1Test.java\npackage apbs_mem_gui;\n\n/**\n * @author keithc\n */\nimport java.io.*;\nimport java.util.Scanner;\nimport java.text.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileEditor}.\n* It contains ten unit test cases for the {@link FileEditor#getCompEnergy(String)} method.\n*/\nclass FileEditor_1Test {",
    "method_signature": "getCompEnergy(String)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// Main.java\npackage apbs_mem_gui;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport java.io.*;\nimport com.jgoodies.forms.layout.*;\nimport com.jgoodies.forms.builder.*;\nimport org.jmol.api.JmolViewer;\nimport org.jmol.api.JmolAdapter;\nimport org.jmol.popup.JmolPopup;\n\n/**\n * @author Keith Callenberg, Gabriel de Forest\n */\npublic class Main {\n\n    private JMenuBar mainBar;\n\n    private JMenu fileMenu, focusMenu, helpMenu;\n\n    private JMenuItem save, open, exit, about, readme;\n\n    private ButtonGroup focusbuttons;\n\n    private JRadioButtonMenuItem setFocus0, setFocus1, setFocus2;\n\n    protected int maxfocus \u003d 0, pb \u003d 0;\n\n    private JPanel lpane, rpane;\n\n    private Container mainPane;\n\n    GridBagConstraints gbc \u003d new GridBagConstraints();\n\n    private JButton Run, PQRBrowse1, PQRBrowse2, Preview, RedrawPot;\n\n    protected JCheckBox drawPot;\n\n    protected JFormattedTextField pqrFile1, pqrFile2, gridDimx, gridDimy, gridDimz, gridLen1a, gridLen2a, gridLen3a, gridLen1b, gridLen2b, gridLen3b, gridLen1c, gridLen2c, gridLen3c, countIon1Charge, countIon1Con, countIon1Sz, countIon2Charge, countIon2Con, countIon2Sz, proteinDi, solventDi, membraneDi, srad, sdens, temp, zmem, Lmem, idie, geoFactor1, geoFactor2, geoFactor3, potential, potcontour;\n\n    protected javax.swing.JProgressBar pBar;\n\n    protected javax.swing.JComboBox solMethodCombo, boundaryCondCombo, calcTypeCombo, centerCombo, contourCombo;\n\n    InFile inFile;\n\n    Exec exec \u003d new Exec();\n\n    FileEditor file \u003d new FileEditor();\n\n    //keeps track of whether or not file has been changed\n    boolean hasbeenchanged \u003d true;\n\n    //is file already loaded/saved?\n    boolean file_loaded \u003d false;\n\n    double[] finalenergy, memv;\n\n    File ofile;\n\n    String outfilename;\n\n    String[] theEnergy, ctypes;\n\n    Scanner fScan;\n\n    PrintWriter outFile;\n\n    private JFrame theWindow \u003d new JFrame();\n\n    protected JmolViewer viewer;\n\n    private JmolAdapter adapter;\n\n    private JmolPopup jmolPopup;\n\n    private static double version \u003d 1.04;\n\n    private JDialog aboutdialog, helpdialog;\n\n    private static Main m;\n\n    /**\n     * Main class that includes the GUI components\n     */\n    public Main() {\n        inFile \u003d new InFile();\n        theWindow \u003d new JFrame(\"APBSmem \" + version);\n        theWindow.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        mainPane \u003d theWindow.getContentPane();\n        Run \u003d new JButton(\"Run\");\n        PQRBrowse1 \u003d new JButton(\"Browse\");\n        PQRBrowse2 \u003d new JButton(\"Browse\");\n        PQRBrowse2.setEnabled(false);\n        Preview \u003d new JButton(\"Preview\");\n        mainBar \u003d new JMenuBar();\n        theWindow.setJMenuBar(mainBar);\n        RedrawPot \u003d new JButton(\"Redraw\");\n        RedrawPot.setEnabled(false);\n        fileMenu \u003d new JMenu(\"File\");\n        open \u003d new JMenuItem(\"Open\");\n        save \u003d new JMenuItem(\"Save\");\n        exit \u003d new JMenuItem(\"Exit\");\n        helpMenu \u003d new JMenu(\"Help\");\n        readme \u003d new JMenuItem(\"Readme\");\n        about \u003d new JMenuItem(\"About\");\n        //helpMenu.add(readme);\n        helpMenu.add(about);\n        fileMenu.add(open);\n        fileMenu.add(save);\n        fileMenu.add(exit);\n        focusMenu \u003d new JMenu(\"Focus\");\n        setFocus0 \u003d new JRadioButtonMenuItem(\"No focus\");\n        setFocus1 \u003d new JRadioButtonMenuItem(\"1 focus level\");\n        setFocus2 \u003d new JRadioButtonMenuItem(\"2 focus levels\");\n        setFocus0.setSelected(true);\n        focusbuttons \u003d new ButtonGroup();\n        focusbuttons.add(setFocus0);\n        focusbuttons.add(setFocus1);\n        focusbuttons.add(setFocus2);\n        focusMenu.add(setFocus0);\n        focusMenu.add(setFocus1);\n        focusMenu.add(setFocus2);\n        mainBar.add(fileMenu);\n        mainBar.add(focusMenu);\n        mainBar.add(helpMenu);\n        ctypes \u003d new String[] { \"Protein solvation\", \"Ion solvation\", \"Gating charge\" };\n        pBar \u003d new javax.swing.JProgressBar();\n        pBar.setStringPainted(true);\n        pb \u003d 0;\n        gridDimx \u003d new JFormattedTextField(new Integer(97));\n        gridDimx.setToolTipText(\"Grid dimension X\");\n        gridDimy \u003d new JFormattedTextField(new Integer(97));\n        gridDimy.setToolTipText(\"Grid dimension Y\");\n        gridDimz \u003d new JFormattedTextField(new Integer(97));\n        gridDimz.setToolTipText(\"Grid dimension Z\");\n        gridLen1a \u003d new JFormattedTextField(new Double(300));\n        gridLen1a.setToolTipText(\"Grid length X\");\n        gridLen2a \u003d new JFormattedTextField(new Double(300));\n        gridLen2a.setToolTipText(\"Grid length Y\");\n        gridLen3a \u003d new JFormattedTextField(new Double(300));\n        gridLen3a.setToolTipText(\"Grid length Z\");\n        gridLen1b \u003d new JFormattedTextField(new Double(200));\n        gridLen1b.setToolTipText(\"Grid length X\");\n        gridLen2b \u003d new JFormattedTextField(new Double(200));\n        gridLen2b.setToolTipText(\"Grid length Y\");\n        gridLen3b \u003d new JFormattedTextField(new Double(200));\n        gridLen3b.setToolTipText(\"Grid length Z\");\n        gridLen1c \u003d new JFormattedTextField(new Double(100));\n        gridLen1c.setToolTipText(\"Grid length X\");\n        gridLen2c \u003d new JFormattedTextField(new Double(100));\n        gridLen2c.setToolTipText(\"Grid length Y\");\n        gridLen3c \u003d new JFormattedTextField(new Double(100));\n        gridLen3c.setToolTipText(\"Grid length Z\");\n        setFocus1Enable(false);\n        setFocus2Enable(false);\n        countIon1Charge \u003d new JFormattedTextField(new Double(1.0));\n        countIon1Charge.setToolTipText(\"Ion 1 CHARGE\");\n        countIon1Con \u003d new JFormattedTextField(new Double(0.1));\n        countIon1Con.setToolTipText(\"Ion 1 CONCENTRATION\");\n        countIon1Sz \u003d new JFormattedTextField(new Double(2.0));\n        countIon1Sz.setToolTipText(\"Ion 1 RADIUS\");\n        countIon2Charge \u003d new JFormattedTextField(new Double(-1.0));\n        countIon2Charge.setToolTipText(\"Ion 2 CHARGE\");\n        countIon2Con \u003d new JFormattedTextField(new Double(0.1));\n        countIon2Con.setToolTipText(\"Ion 2 CONCENTRATION\");\n        countIon2Sz \u003d new JFormattedTextField(new Double(2.0));\n        countIon2Sz.setToolTipText(\"Ion 2 RADIUS\");\n        proteinDi \u003d new JFormattedTextField(new Double(2.0));\n        solventDi \u003d new JFormattedTextField(new Double(80.0));\n        membraneDi \u003d new JFormattedTextField(new Double(2.0));\n        pqrFile1 \u003d new JFormattedTextField(new String(\"\"));\n        pqrFile1.setColumns(16);\n        pqrFile2 \u003d new JFormattedTextField(new String(\"\"));\n        pqrFile2.setColumns(16);\n        pqrFile2.setEnabled(false);\n        srad \u003d new JFormattedTextField(new Double(1.4));\n        sdens \u003d new JFormattedTextField(new Double(10.0));\n        temp \u003d new JFormattedTextField(new Double(298.15));\n        temp.setToolTipText(\"Temperature in Kelvin\");\n        zmem \u003d new JFormattedTextField(new Double(-20.0));\n        zmem.setToolTipText(\"Protein position in membrane in Angstroms\");\n        Lmem \u003d new JFormattedTextField(new Double(40));\n        Lmem.setToolTipText(\"Membrane length in Angstroms\");\n        idie \u003d new JFormattedTextField(new Double(80));\n        geoFactor1 \u003d new JFormattedTextField(new Double(0.0));\n        geoFactor1.setToolTipText(\"Exclusion radius in Angstroms\");\n        geoFactor2 \u003d new JFormattedTextField(new Double(0.0));\n        geoFactor2.setToolTipText(\"Exclusion radius in Angstroms\");\n        geoFactor3 \u003d new JFormattedTextField(new Double(0.0));\n        geoFactor3.setToolTipText(\"Thickness in Angstroms\");\n        drawPot \u003d new JCheckBox(\"Draw potential\");\n        potcontour \u003d new JFormattedTextField(\"2\");\n        potcontour.setToolTipText(\"Isocontour to draw electrostatic potential (+/-)\");\n        potcontour.setEnabled(false);\n        potential \u003d new JFormattedTextField(\"50\");\n        potential.setColumns(5);\n        potential.setToolTipText(\"Membrane potential in mV\");\n        potential.setEnabled(false);\n        solMethodCombo \u003d new javax.swing.JComboBox();\n        solMethodCombo.setModel(new javax.swing.DefaultComboBoxModel(new String[] { \"lpbe\", \"npbe\" }));\n        solMethodCombo.setToolTipText(\"Linearized or Non-linearized Poisson Boltzmann\");\n        calcTypeCombo \u003d new javax.swing.JComboBox();\n        calcTypeCombo.setModel(new javax.swing.DefaultComboBoxModel(ctypes));\n        boundaryCondCombo \u003d new javax.swing.JComboBox();\n        boundaryCondCombo.setModel(new javax.swing.DefaultComboBoxModel(new String[] { \"Zero\", \"SDH\", \"MDH\", \"Focus\", \"Membrane potential\" }));\n        centerCombo \u003d new javax.swing.JComboBox();\n        centerCombo.setModel(new javax.swing.DefaultComboBoxModel(new String[] { \"Origin\", \"Molecule 1\" }));\n        contourCombo \u003d new javax.swing.JComboBox();\n        contourCombo.setModel(new javax.swing.DefaultComboBoxModel(new String[] { \"Membrane-Protein\", \"Protein-Solvent\" }));\n        fileInHandler fhandler \u003d new fileInHandler();\n        menuHandler menuhandler \u003d new menuHandler();\n        boundaryCondCombo.addActionListener(fhandler);\n        centerCombo.addActionListener(fhandler);\n        calcTypeCombo.addActionListener(fhandler);\n        pqrFile1.addActionListener(fhandler);\n        pqrFile2.addActionListener(fhandler);\n        gridDimx.addActionListener(fhandler);\n        gridDimy.addActionListener(fhandler);\n        gridDimz.addActionListener(fhandler);\n        gridLen1a.addActionListener(fhandler);\n        gridLen2a.addActionListener(fhandler);\n        gridLen3a.addActionListener(fhandler);\n        countIon1Charge.addActionListener(fhandler);\n        countIon1Con.addActionListener(fhandler);\n        countIon1Sz.addActionListener(fhandler);\n        countIon2Charge.addActionListener(fhandler);\n        countIon2Con.addActionListener(fhandler);\n        countIon2Sz.addActionListener(fhandler);\n        proteinDi.addActionListener(fhandler);\n        solventDi.addActionListener(fhandler);\n        membraneDi.addActionListener(fhandler);\n        Run.addActionListener(fhandler);\n        PQRBrowse1.addActionListener(fhandler);\n        PQRBrowse2.addActionListener(fhandler);\n        Preview.addActionListener(fhandler);\n        drawPot.addActionListener(fhandler);\n        RedrawPot.addActionListener(fhandler);\n        setFocus0.addActionListener(menuhandler);\n        setFocus1.addActionListener(menuhandler);\n        setFocus2.addActionListener(menuhandler);\n        open.addActionListener(menuhandler);\n        save.addActionListener(menuhandler);\n        exit.addActionListener(menuhandler);\n        about.addActionListener(menuhandler);\n        readme.addActionListener(menuhandler);\n        lpane \u003d new JPanel();\n        JmolPanel jmolPanel \u003d new JmolPanel();\n        aboutdialog \u003d new SimpleAboutDialog(new JFrame());\n        helpdialog \u003d new SimpleHelpDialog(new JFrame());\n        FormLayout layout \u003d new FormLayout(//columns\n        \"right:pref, 4dlu, pref, 4dlu, pref, 4dlu, pref, 4dlu, pref\", \"pref, 2dlu, pref, 2dlu, pref, 2dlu, pref, 2dlu, pref, 2dlu,\" + \"pref, 2dlu, pref, 2dlu, pref, 2dlu, pref, 2dlu, pref, 2dlu,\" + \"pref, 2dlu, pref, 2dlu, pref, 2dlu, pref, 2dlu, pref, 2dlu,\" + \"pref, 2dlu, pref, 2dlu, pref, 2dlu, pref, 2dlu, pref, 2dlu,\" + //rows\n        \"pref, 2dlu, pref, 2dlu, pref, 2dlu, pref, 2dlu, pref\");\n        PanelBuilder builder \u003d new PanelBuilder(layout);\n        builder.setDefaultDialogBorder();\n        lpane.setLayout(layout);\n        CellConstraints cc \u003d new CellConstraints();\n        builder.add(new JLabel(\"Calculation type\"), cc.xy(1, 1));\n        builder.add(calcTypeCombo, cc.xyw(3, 1, 5));\n        builder.add(new JLabel(\"PQR File 1\"), cc.xy(1, 3));\n        builder.add(pqrFile1, cc.xyw(3, 3, 3));\n        builder.add(PQRBrowse1, cc.xy(7, 3));\n        builder.add(new JLabel(\"PQR File 2\"), cc.xy(1, 5));\n        builder.add(pqrFile2, cc.xyw(3, 5, 3));\n        builder.add(PQRBrowse2, cc.xy(7, 5));\n        builder.add(new JLabel(\"Grid dimensions\"), cc.xy(1, 7));\n        builder.add(gridDimx, cc.xy(3, 7));\n        builder.add(gridDimy, cc.xy(5, 7));\n        builder.add(gridDimz, cc.xy(7, 7));\n        builder.add(new JLabel(\"Grid lengths\"), cc.xy(1, 9));\n        builder.add(gridLen1a, cc.xy(3, 9));\n        builder.add(gridLen2a, cc.xy(5, 9));\n        builder.add(gridLen3a, cc.xy(7, 9));\n        builder.add(new JLabel(\"\"), cc.xy(1, 11));\n        builder.add(gridLen1b, cc.xy(3, 11));\n        builder.add(gridLen2b, cc.xy(5, 11));\n        builder.add(gridLen3b, cc.xy(7, 11));\n        builder.add(new JLabel(\"\"), cc.xy(1, 13));\n        builder.add(gridLen1c, cc.xy(3, 13));\n        builder.add(gridLen2c, cc.xy(5, 13));\n        builder.add(gridLen3c, cc.xy(7, 13));\n        builder.add(new JLabel(\"Counter-ions\"), cc.xy(1, 15));\n        builder.add(countIon1Charge, cc.xy(3, 15));\n        builder.add(countIon1Con, cc.xy(5, 15));\n        builder.add(countIon1Sz, cc.xy(7, 15));\n        builder.add(countIon2Charge, cc.xy(3, 17));\n        builder.add(countIon2Con, cc.xy(5, 17));\n        builder.add(countIon2Sz, cc.xy(7, 17));\n        builder.addSeparator(\"Dielectric constants\", cc.xyw(1, 21, 7));\n        builder.add(new JLabel(\"Protein\"), cc.xy(1, 23));\n        builder.add(proteinDi, cc.xy(3, 23));\n        builder.add(new JLabel(\"Solvent\"), cc.xy(5, 23));\n        builder.add(solventDi, cc.xy(7, 23));\n        builder.add(new JLabel(\"Membrane\"), cc.xy(1, 25));\n        builder.add(membraneDi, cc.xy(3, 25));\n        builder.add(new JLabel(\"Head group\"), cc.xy(5, 25));\n        builder.add(idie, cc.xy(7, 25));\n        builder.addSeparator(\"Geometry settings\", cc.xyw(1, 27, 7));\n        builder.add(new JLabel(\"Membrane thickness\"), cc.xy(1, 29));\n        builder.add(Lmem, cc.xy(3, 29));\n        builder.add(new JLabel(\"Upper exclusion\"), cc.xy(5, 29));\n        builder.add(geoFactor1, cc.xy(7, 29));\n        builder.add(new JLabel(\"Head group thickness\"), cc.xy(1, 31));\n        builder.add(geoFactor3, cc.xy(3, 31));\n        builder.add(new JLabel(\"Lower exclusion\"), cc.xy(5, 31));\n        builder.add(geoFactor2, cc.xy(7, 31));\n        builder.add(new JLabel(\"Membrane bottom z-pos\"), cc.xy(1, 33));\n        builder.add(zmem, cc.xy(3, 33));\n        builder.addSeparator(\"Other parameters\", cc.xyw(1, 35, 7));\n        builder.add(new JLabel(\"Solution method\"), cc.xy(1, 37));\n        builder.add(solMethodCombo, cc.xy(3, 37));\n        builder.add(new JLabel(\"Temperature\"), cc.xy(5, 37));\n        builder.add(temp, cc.xy(7, 37));\n        builder.add(new JLabel(\"Boundary conditions\"), cc.xy(1, 39));\n        builder.add(boundaryCondCombo, cc.xy(3, 39));\n        builder.add(new JLabel(\"Membrane potential\"), cc.xy(5, 39));\n        builder.add(potential, cc.xy(7, 39));\n        builder.add(new JLabel(\"Solvent radius\"), cc.xy(1, 41));\n        builder.add(srad, cc.xy(3, 41));\n        builder.add(new JLabel(\"Sphere density\"), cc.xy(5, 41));\n        builder.add(sdens, cc.xy(7, 41));\n        builder.add(new JLabel(\"Isosurface contour\"), cc.xy(1, 43));\n        builder.add(contourCombo, cc.xy(3, 43));\n        builder.add(new JLabel(\"Grid center\"), cc.xy(5, 43));\n        builder.add(centerCombo, cc.xy(7, 43));\n        builder.add(drawPot, cc.xy(3, 45));\n        builder.add(potcontour, cc.xy(5, 45));\n        builder.add(RedrawPot, cc.xy(7, 45));\n        builder.add(new JLabel(\"\"), cc.xy(1, 47));\n        builder.add(Preview, cc.xy(3, 47));\n        builder.add(Run, cc.xy(5, 47));\n        JSplitPane sp \u003d new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, builder.getPanel(), null);\n        sp.setOneTouchExpandable(true);\n        sp.setBorder(null);\n        mainPane.add(sp, BorderLayout.CENTER);\n        JPanel bottom \u003d new JPanel();\n        bottom.setLayout(new BorderLayout());\n        bottom.add(pBar, BorderLayout.WEST);\n        mainPane.add(bottom, BorderLayout.SOUTH);\n        viewer \u003d jmolPanel.getViewer();\n        viewer.evalString(\"zap;frank off;\");\n        File logo \u003d new File(\"apbsmem.jvxl\");\n        if (logo.exists())\n            viewer.evalString(\"isoSurface \\\"apbsmem.jvxl\\\";zoom 200;\");\n        theWindow.pack();\n        jmolPanel.setPreferredSize(new Dimension(300, 300));\n        sp.setRightComponent(jmolPanel);\n        theWindow.pack();\n        theWindow.setVisible(true);\n        dependencyCheck();\n    }\n\n    /**\n     * Driver method\n     * @param args No command-line arguments are necessary\n     */\n    public static void main(String[] args) {\n        m \u003d new Main();\n    }\n\n    private class menuHandler implements ActionListener {\n\n        public void actionPerformed(ActionEvent e) {\n            if (e.getSource() \u003d\u003d setFocus0) {\n                setMaxFocus(0);\n            }\n            if (e.getSource() \u003d\u003d setFocus1) {\n                setMaxFocus(1);\n            }\n            if (e.getSource() \u003d\u003d setFocus2) {\n                setMaxFocus(2);\n            } else if (e.getSource() \u003d\u003d about) {\n                aboutdialog.show();\n            } else if (e.getSource() \u003d\u003d readme) {\n                helpdialog.show();\n            } else //opens a *.in file that has between 0 and 2 focus\n            if (e.getSource() \u003d\u003d open) {\n                if (OpenFile()) {\n                    //if got the file successfully and (dont save)\n                    try {\n                        fScan \u003d new Scanner(new FileInputStream(ofile));\n                    } catch (Exception e1) {\n                        System.out.println(e1.getMessage());\n                    }\n                    //assume protein solvation unless we see \u003e1 pqr or memv parameters\n                    calcTypeCombo.setSelectedIndex(0);\n                    StringBuffer theData \u003d new StringBuffer();\n                    int loadfocus \u003d -1;\n                    String nextline;\n                    while (fScan.hasNextLine()) {\n                        nextline \u003d fScan.nextLine();\n                        if (nextline.contains(\"elec name\")) {\n                            if (loadfocus \u003e -1 \u0026\u0026 nextline.endsWith(\"0\"))\n                                // we only want to load one section so we stop if we see a new section\n                                break;\n                            else\n                                loadfocus++;\n                        } else if (nextline.contains(\"end\")) {\n                            //if done with loading a focus level\n                            //save current data regardless. first focus it wont really do anything\n                            SaveData();\n                            maxfocus \u003d loadfocus;\n                            String temp \u003d theData.toString();\n                            String[] data \u003d temp.split(\"\\n\");\n                            //then load up data to the new focus\n                            LoadData(data, loadfocus);\n                            //finally, reset the data for the next focus\n                            theData \u003d new StringBuffer();\n                        } else {\n                            theData.append(nextline + \"\\n\");\n                        }\n                    }\n                    fScan.close();\n                    setMaxFocus(maxfocus);\n                }\n            } else if (e.getSource() \u003d\u003d save) {\n                if (SaveData() \u0026\u0026 SaveDialog(\"Save settings to file\")) {\n                    //if it was able to save the data\n                    //save all data to file (true \u003d first run)\n                    SaveToFile(true);\n                    //file has not been changed since\n                    hasbeenchanged \u003d false;\n                }\n            } else if (e.getSource() \u003d\u003d exit) {\n                if (hasbeenchanged) {\n                    int answer;\n                    if (file_loaded) {\n                        answer \u003d JOptionPane.showConfirmDialog(null, \"Do you want to save changes to \" + ofile.getName() + \"?\", \"\", JOptionPane.YES_NO_OPTION);\n                    } else {\n                        answer \u003d JOptionPane.showConfirmDialog(null, \"Do you want to save your settings?\", \"\", JOptionPane.YES_NO_OPTION);\n                    }\n                    if (answer \u003d\u003d JOptionPane.YES_OPTION) {\n                        if (!file_loaded) {\n                            SaveDialog(\"Save settings to file\");\n                        }\n                        SaveToFile(true);\n                    }\n                }\n                File curdir \u003d new File(\".\");\n                deleteFiles(curdir.getPath(), \".dx\");\n                System.exit(0);\n            }\n        }\n    }\n\n    private class fileInHandler implements ActionListener {\n\n        public void actionPerformed(ActionEvent e) {\n            if (e.getSource() \u003d\u003d Preview) {\n                if (pqrFile1.getText() \u003d\u003d \"\") {\n                    JOptionPane.showMessageDialog(null, \"Please select the PQR file\", \"Error\", JOptionPane.PLAIN_MESSAGE);\n                    return;\n                } else {\n                    File tfile \u003d new File(pqrFile1.getText());\n                    if (!tfile.exists()) {\n                        JOptionPane.showMessageDialog(null, \"PQR file not found\", \"Error\", JOptionPane.PLAIN_MESSAGE);\n                        return;\n                    }\n                }\n                Integer t1 \u003d Integer.parseInt(gridDimx.getText());\n                Integer t2 \u003d Integer.parseInt(gridDimy.getText());\n                Integer t3 \u003d Integer.parseInt(gridDimz.getText());\n                gridDimx.setText(\"65\");\n                gridDimy.setText(\"65\");\n                gridDimz.setText(\"65\");\n                SaveData();\n                ofile \u003d new File(\"./preview_temp\");\n                if (calcTypeCombo.getSelectedIndex() \u003d\u003d 1) {\n                    //ION SOLVATION\n                    if (!pqrFile2.getText().equals(\"\")) {\n                        //Load the ION too!\n                        viewer.evalString(\"load APPEND \\\"\" + pqrFile2.getText() + \"\\\"\");\n                        viewer.evalString(\"frame *;cpk off;wireframe off;cartoon on;color green;select 2.0;color purple;spacefill 100%\");\n                    }\n                }\n                Thread pT \u003d new Thread(new Run(m, inFile, ofile, viewer, pBar, drawPot.isSelected(), potcontour.getText(), true));\n                pT.start();\n                ofile.delete();\n                gridDimx.setText(t1.toString());\n                gridDimy.setText(t2.toString());\n                gridDimz.setText(t3.toString());\n                pBar.setValue(0);\n            } else if (e.getSource() \u003d\u003d Run) {\n                if (pqrFile1.getText().equals(\"\")) {\n                    JOptionPane.showMessageDialog(null, \"Please select the PQR file for the protein.\", \"Error\", JOptionPane.PLAIN_MESSAGE);\n                    return;\n                } else {\n                    File tfile1 \u003d new File(pqrFile1.getText());\n                    if (!tfile1.exists()) {\n                        System.out.println(\"Protein PQR file not found.\");\n                        return;\n                    }\n                }\n                System.out.println(\"Focus: \" + maxfocus + \" \" + inFile.getMaxfocus());\n                //clean up files from a previous run - this should not be needed at some point\n                File curdir \u003d new File(\".\");\n                deleteFiles(curdir.getPath(), \".dx\");\n                if (SaveData() \u0026\u0026 SaveDialog(\"Enter a name for the output directory before running\")) {\n                    if (calcTypeCombo.getSelectedIndex() \u003d\u003d 1) {\n                        //ION SOLVATION - create concatenation file of ion + protein\n                        //Load the ION too!\n                        viewer.evalString(\"load FILES \\\"\" + pqrFile1.getText() + \"\\\" \\\"\" + pqrFile2.getText() + \"\\\"\");\n                        try {\n                            BufferedWriter prot1 \u003d new BufferedWriter(new FileWriter(pqrFile1.getText() + \".withion.pqr\", false));\n                            BufferedReader in1 \u003d new BufferedReader(new FileReader(pqrFile1.getText()));\n                            BufferedReader in2 \u003d new BufferedReader(new FileReader(pqrFile2.getText()));\n                            String inputline;\n                            while ((inputline \u003d in1.readLine()) !\u003d null) {\n                                prot1.write(inputline);\n                                prot1.newLine();\n                            }\n                            while ((inputline \u003d in2.readLine()) !\u003d null) {\n                                prot1.write(inputline);\n                                prot1.newLine();\n                            }\n                            prot1.flush();\n                            prot1.close();\n                            in1.close();\n                            in2.close();\n                        } catch (Exception e1) {\n                            System.out.println(e1);\n                        }\n                        inFile.setMol3(pqrFile1.getText() + \".withion.pqr\");\n                        //Load the ION too!\n                        viewer.evalString(\"load APPEND \\\"\" + pqrFile2.getText() + \"\\\"\");\n                        viewer.evalString(\"frame *;cpk off;wireframe off;cartoons on;color green;select 2.0;color purple;spacefill 100%\");\n                    } else if (calcTypeCombo.getSelectedIndex() \u003d\u003d 2) {\n                        //GATING CHARGE - turn charges off for dummy calculation\n                        exec.callChargeOff(pqrFile1.getText());\n                        exec.callChargeOff(pqrFile2.getText());\n                    }\n                    Thread t1 \u003d new Thread(new Run(m, inFile, ofile, viewer, pBar, drawPot.isSelected(), potcontour.getText(), false));\n                    t1.start();\n                    if (drawPot.isEnabled()) {\n                        RedrawPot.setEnabled(true);\n                    }\n                }\n                pBar.setValue(0);\n            } else if (e.getSource() \u003d\u003d PQRBrowse1) {\n                final JFileChooser fc \u003d new JFileChooser(new File(\".\"));\n                fc.setAcceptAllFileFilterUsed(false);\n                EFileFilter filter \u003d new EFileFilter(\"pqr\");\n                filter.setDescription(\"PQR files\");\n                fc.addChoosableFileFilter(filter);\n                int returnVal \u003d fc.showOpenDialog(theWindow);\n                if (returnVal \u003d\u003d JFileChooser.APPROVE_OPTION) {\n                    pqrFile1.setText(fc.getSelectedFile().getPath());\n                    viewer.openFile(pqrFile1.getText());\n                }\n            } else if (e.getSource() \u003d\u003d PQRBrowse2) {\n                final JFileChooser fc \u003d new JFileChooser(new File(\".\"));\n                fc.setAcceptAllFileFilterUsed(false);\n                EFileFilter filter \u003d new EFileFilter(\"pqr\");\n                filter.setDescription(\"PQR files\");\n                fc.addChoosableFileFilter(filter);\n                int returnVal \u003d fc.showOpenDialog(theWindow);\n                if (returnVal \u003d\u003d JFileChooser.APPROVE_OPTION) {\n                    pqrFile2.setText(fc.getSelectedFile().getPath());\n                    // viewer.openFile(pqrFile2.getText());\n                }\n            } else if (e.getSource() \u003d\u003d boundaryCondCombo) {\n                if (calcTypeCombo.getSelectedIndex() \u003d\u003d 2) {\n                    boundaryCondCombo.setSelectedIndex(4);\n                    potential.setEnabled(true);\n                } else {\n                    if (boundaryCondCombo.getSelectedIndex() \u003d\u003d 4) {\n                        boundaryCondCombo.setSelectedIndex(0);\n                        potential.setEnabled(false);\n                    }\n                    if (boundaryCondCombo.getSelectedIndex() \u003d\u003d 3 \u0026\u0026 maxfocus \u003d\u003d 0) {\n                        String temp;\n                        Object[] choices \u003d { \"0\", \"1\", \"2\" };\n                        temp \u003d (String) JOptionPane.showInputDialog(null, \"How many focus levels do you want to set?\", \"Focus levels\", JOptionPane.QUESTION_MESSAGE, null, choices, choices[0]);\n                        setMaxFocus(Integer.parseInt(temp));\n                    }\n                }\n            } else if (e.getSource() \u003d\u003d calcTypeCombo) {\n                if (calcTypeCombo.getSelectedIndex() \u003d\u003d 0) {\n                    //PROTEIN SOLVATION\n                    pqrFile2.setEnabled(false);\n                    PQRBrowse2.setEnabled(false);\n                    pqrFile1.setToolTipText(\"PQR file of protein in membrane\");\n                    if (boundaryCondCombo.getSelectedIndex() \u003d\u003d 4) {\n                        boundaryCondCombo.setSelectedIndex(0);\n                    }\n                } else if (calcTypeCombo.getSelectedIndex() \u003d\u003d 1) {\n                    //ION SOLVATION\n                    pqrFile2.setEnabled(true);\n                    PQRBrowse2.setEnabled(true);\n                    pqrFile1.setToolTipText(\"PQR file of protein\");\n                    pqrFile2.setToolTipText(\"PQR file of ion only\");\n                    if (boundaryCondCombo.getSelectedIndex() \u003d\u003d 4) {\n                        boundaryCondCombo.setSelectedIndex(0);\n                    }\n                } else {\n                    //GATING CHARGE\n                    pqrFile2.setEnabled(true);\n                    PQRBrowse2.setEnabled(true);\n                    pqrFile1.setToolTipText(\"PQR file of gating conformation 1\");\n                    pqrFile2.setToolTipText(\"PQR file of gating conformation 2\");\n                    boundaryCondCombo.setSelectedIndex(4);\n                    potential.setEnabled(true);\n                }\n            } else if (e.getSource() \u003d\u003d drawPot) {\n                potcontour.setEnabled(drawPot.isSelected());\n            } else if (e.getSource() \u003d\u003d RedrawPot) {\n                viewer.evalString(\"isosurface delete\");\n                if (drawPot.isSelected()) {\n                    viewer.evalString(\"isosurface \" + getIsocontour() + \" \\\"dielx_\" + (maxfocus + 1) + \"m.dx\\\"; color isosurface white translucent\");\n                    viewer.evalString(\"isosurface potpos \" + potcontour.getText() + \" \\\"pot_1.dx\\\"; color isoSurface red translucent\");\n                    viewer.evalString(\"isosurface potneg -\" + potcontour.getText() + \" \\\"pot_1.dx\\\"; color isoSurface blue translucent\");\n                }\n            }\n        }\n    }\n\n    ///end fileInHandler\n    public Double getIsocontour() {\n        //protein-membrane dielectric\n        if (contourCombo.getSelectedIndex() \u003d\u003d 0) {\n            if (Double.valueOf(inFile.getMdie()) \u003c Double.valueOf(inFile.getProteinDi())) {\n                return Double.valueOf(inFile.getMdie()) + 0.001;\n            } else {\n                return Double.valueOf(inFile.getProteinDi()) + 0.001;\n            }\n        } else //protein-solvent boundary\n        {\n            if (Double.valueOf(inFile.getProteinDi()) \u003c Double.valueOf(inFile.getSolventDi())) {\n                return Double.valueOf(inFile.getProteinDi()) + 0.001;\n            } else {\n                return Double.valueOf(inFile.getSolventDi()) + 0.001;\n            }\n        }\n    }\n\n    /**\n     * Change the number of focus levels to use in the calculation\n     * @param mf The new number of focus levels. Current options are 0, 1, or 2.\n     */\n    public void setMaxFocus(int mf) {\n        maxfocus \u003d mf;\n        inFile.setMaxFocus(mf);\n        if (maxfocus \u003d\u003d 0) {\n            if (boundaryCondCombo.getSelectedIndex() \u003d\u003d 3)\n                boundaryCondCombo.setSelectedIndex(0);\n            setFocus1Enable(false);\n            setFocus2Enable(false);\n            setFocus0.setSelected(true);\n        } else if (maxfocus \u003d\u003d 1) {\n            boundaryCondCombo.setSelectedIndex(3);\n            setFocus1Enable(true);\n            setFocus2Enable(false);\n            setFocus1.setSelected(true);\n        } else {\n            boundaryCondCombo.setSelectedIndex(3);\n            setFocus1Enable(true);\n            setFocus2Enable(true);\n            setFocus2.setSelected(true);\n        }\n    }\n\n    /**\n     * Enable or disable text input fields for the level 1 focusing.\n     * @param v flag to enable (if true) or disable (if false) the focus level 1.\n     */\n    public void setFocus1Enable(boolean v) {\n        gridLen1b.setEnabled(v);\n        gridLen2b.setEnabled(v);\n        gridLen3b.setEnabled(v);\n    }\n\n    /**\n     * Enable or disable text input fields for the level 2 focusing.\n     * @param v flag to enable (if true) or disable (if false) the focus level 2.\n     */\n    public void setFocus2Enable(boolean v) {\n        gridLen1c.setEnabled(v);\n        gridLen2c.setEnabled(v);\n        gridLen3c.setEnabled(v);\n    }\n\n    /**\n     * Save the parameters stored in the inFile object to a file.\n     * @param firstcall True if the file to be written is the \"dummy\" file\n     * before the real calculation, otherwise false.\n     */\n    public void SaveToFile(boolean firstcall) {\n        if (ofile !\u003d null) {\n            try {\n                if (firstcall) {\n                    File outFile2 \u003d new File(ofile.getPath() + \".dummy.in\");\n                    outFile2.delete();\n                    outFile \u003d new PrintWriter(new FileOutputStream(outFile2));\n                    System.out.println(\"HEY: \" + outFile2.getPath());\n                } else {\n                    File outFile2 \u003d new File(ofile.getPath() + \".solv.in\");\n                    outFile2.delete();\n                    outFile \u003d new PrintWriter(new FileOutputStream(outFile2));\n                }\n            } catch (Exception e1) {\n                System.out.println(\"SaveToFile exception: \" + e1.toString());\n            }\n            //store data in temporary string\n            String tempIn \u003d inFile.toString(firstcall);\n            //split data by each new line\n            String[] tempInSplit \u003d tempIn.split(\"\\n\");\n            for (int i \u003d 0; i \u003c tempInSplit.length; i++) {\n                //print data one line at a time\n                outFile.println(tempInSplit[i]);\n            }\n            outFile.close();\n        }\n    }\n\n    /**\n     * Store the current GUI text field values in the inFile object.\n     * @return True if the operation was succesful, false otherwise.\n     */\n    public boolean SaveData() {\n        if (pqrFile1.getText().equals(\"\") || pqrFile1.getText() \u003d\u003d null || gridDimx.getText().equals(\"\") || gridDimx.getText() \u003d\u003d null || gridDimy.getText().equals(\"\") || gridDimy.getText() \u003d\u003d null || gridDimz.getText().equals(\"\") || gridDimz.getText() \u003d\u003d null || gridLen1a.getText().equals(\"\") || gridLen1a.getText() \u003d\u003d null || gridLen2a.getText().equals(\"\") || gridLen2a.getText() \u003d\u003d null || gridLen3a.getText().equals(\"\") || gridLen3a.getText() \u003d\u003d null || countIon1Charge.getText().equals(\"\") || countIon1Charge.getText() \u003d\u003d null || countIon1Con.getText().equals(\"\") || countIon1Con.getText() \u003d\u003d null || countIon1Sz.getText().equals(\"\") || countIon1Sz.getText() \u003d\u003d null || countIon2Charge.getText().equals(\"\") || countIon2Charge.getText() \u003d\u003d null || countIon2Con.getText().equals(\"\") || countIon2Con.getText() \u003d\u003d null || countIon2Sz.getText().equals(\"\") || countIon2Sz.getText() \u003d\u003d null || proteinDi.getText().equals(\"\") || proteinDi.getText() \u003d\u003d null || solventDi.getText().equals(\"\") || solventDi.getText() \u003d\u003d null || srad.getText().equals(\"\") || srad.getText() \u003d\u003d null || sdens.getText().equals(\"\") || sdens.getText() \u003d\u003d null || temp.getText().equals(\"\") || temp.getText() \u003d\u003d null) {\n            if (maxfocus \u003e 0 \u0026\u0026 (gridLen1b.getText().equals(\"\") || gridLen1b.getText() \u003d\u003d null || gridLen2b.getText().equals(\"\") || gridLen2b.getText() \u003d\u003d null || gridLen3b.getText().equals(\"\") || gridLen3b.getText() \u003d\u003d null)) {\n                if (maxfocus \u003e 1 \u0026\u0026 (gridLen1c.getText().equals(\"\") || gridLen1c.getText() \u003d\u003d null || gridLen2c.getText().equals(\"\") || gridLen2c.getText() \u003d\u003d null || gridLen3c.getText().equals(\"\") || gridLen3c.getText() \u003d\u003d null)) {\n                    if (file_loaded) {\n                        //if you arent opening it and it fails then fail\n                        JOptionPane.showMessageDialog(null, \"Fill in all values first\", \"\", JOptionPane.ERROR_MESSAGE);\n                        return false;\n                    }\n                }\n            }\n        }\n        //otherwise save data\n        inFile.setMol1(pqrFile1.getText());\n        inFile.setMol2(pqrFile2.getText());\n        inFile.setDime(new String(gridDimx.getText() + \" \" + gridDimy.getText() + \" \" + gridDimz.getText()));\n        inFile.setGlen(new String(gridLen1a.getText() + \" \" + gridLen2a.getText() + \" \" + gridLen3a.getText()), 0);\n        if (maxfocus \u003e 0) {\n            inFile.setGlen(new String(gridLen1b.getText() + \" \" + gridLen2b.getText() + \" \" + gridLen3b.getText()), 1);\n        }\n        if (maxfocus \u003d\u003d 2) {\n            inFile.setGlen(new String(gridLen1c.getText() + \" \" + gridLen2c.getText() + \" \" + gridLen3c.getText()), 2);\n        }\n        inFile.setIon1Charge(countIon1Charge.getText());\n        inFile.setIon1Conc(countIon1Con.getText());\n        inFile.setIon1Radius(countIon1Sz.getText());\n        inFile.setIon2Charge(countIon2Charge.getText());\n        inFile.setIon2Conc(countIon2Con.getText());\n        inFile.setIon2Radius(countIon2Sz.getText());\n        inFile.setProteinDi(new String(proteinDi.getText()));\n        inFile.setSolventDi(new String(solventDi.getText()));\n        inFile.setSrad(srad.getText());\n        inFile.setSdens(sdens.getText());\n        inFile.setTemp(temp.getText());\n        inFile.setType(calcTypeCombo.getSelectedIndex());\n        inFile.setPotential(potential.getText());\n        inFile.setLmem(Lmem.getText());\n        inFile.setZmem(zmem.getText());\n        inFile.setMdie(membraneDi.getText());\n        inFile.setIdie(idie.getText());\n        inFile.setGeo1(geoFactor1.getText());\n        inFile.setGeo2(geoFactor2.getText());\n        inFile.setGeo3(geoFactor3.getText());\n        inFile.setDrawPot(drawPot.isSelected());\n        if (boundaryCondCombo.getSelectedIndex() \u003d\u003d 2) {\n            inFile.setBoundCond(new String(\"mdh\"));\n        } else if (boundaryCondCombo.getSelectedIndex() \u003d\u003d 1) {\n            inFile.setBoundCond(new String(\"sdh\"));\n        } else if (boundaryCondCombo.getSelectedIndex() \u003d\u003d 0) {\n            inFile.setBoundCond(new String(\"zero\"));\n        }\n        if (solMethodCombo.getSelectedIndex() \u003d\u003d 1) {\n            inFile.setSolMethod(new String(\"npbe\"));\n        } else if (solMethodCombo.getSelectedIndex() \u003d\u003d 0) {\n            inFile.setSolMethod(new String(\"lpbe\"));\n        }\n        if (centerCombo.getSelectedIndex() \u003d\u003d 0) {\n            inFile.setCenter(new String(\"0 0 0\"));\n        } else if (centerCombo.getSelectedIndex() \u003d\u003d 1) {\n            inFile.setCenter(new String(\"mol 1\"));\n        }\n        return true;\n    }\n\n    /**\n     * Load parameters from an APBS input file into the GUI.\n     * @param thedata APBS input file read into a string array by lines.\n     * @param loadfocus the focus level for which to load the parameters.\n     */\n    private void LoadData(String[] thedata, int loadfocus) {\n        //take in the first ion as #1\n        boolean countion1 \u003d true;\n        for (int i \u003d 0; i \u003c thedata.length; i++) {\n            if (thedata[i].contains(\"mol pqr \")) {\n                if (thedata[i - 1].contains(\"mol pqr \")) {\n                    if (thedata[i - 2].contains(\"mol pqr \")) {\n                        // there are 3 files so it must be ion solvation\n                        calcTypeCombo.setSelectedIndex(1);\n                    } else {\n                        // there are 2 files so it must be gating charge\n                        String f_temp \u003d thedata[i].substring((thedata[i].indexOf(\"mol pqr \") + 8), thedata[i].length());\n                        if (f_temp.startsWith(\"\\\"\"))\n                            f_temp \u003d f_temp.substring(1, f_temp.length() - 1);\n                        pqrFile2.setText(f_temp);\n                        calcTypeCombo.setSelectedIndex(2);\n                    }\n                } else {\n                    String f_temp \u003d thedata[i].substring((thedata[i].indexOf(\"mol pqr \") + 8), thedata[i].length());\n                    if (f_temp.startsWith(\"\\\"\"))\n                        f_temp \u003d f_temp.substring(1, f_temp.length() - 1);\n                    pqrFile1.setText(f_temp);\n                    viewer.openFile(pqrFile1.getText());\n                }\n            } else if (thedata[i].contains(\"dime \")) {\n                String[] tempdime \u003d thedata[i].substring((thedata[i].indexOf(\"dime \") + 5), thedata[i].length()).split(\" \");\n                //if data isnt empty, set the data, else set it to blank\n                if (tempdime.length \u003e 0) {\n                    gridDimx.setText(tempdime[0]);\n                } else {\n                    gridDimx.setText(\"\");\n                }\n                if (tempdime.length \u003e 1) {\n                    gridDimy.setText(tempdime[1]);\n                } else {\n                    gridDimy.setText(\"\");\n                }\n                if (tempdime.length \u003e 2) {\n                    gridDimz.setText(tempdime[2]);\n                } else {\n                    gridDimz.setText(\"\");\n                }\n            } else if (thedata[i].contains(\"glen \")) {\n                String[] tempglen \u003d thedata[i].substring((thedata[i].indexOf(\"glen \") + 5), thedata[i].length()).split(\" \");\n                //if data isnt empty     set the data                  else  set it to blank\n                if (loadfocus \u003d\u003d 0) {\n                    if (tempglen.length \u003e 0) {\n                        gridLen1a.setText(tempglen[0]);\n                    } else {\n                        gridLen1a.setText(\"\");\n                    }\n                    if (tempglen.length \u003e 1) {\n                        gridLen2a.setText(tempglen[1]);\n                    } else {\n                        gridLen2a.setText(\"\");\n                    }\n                    if (tempglen.length \u003e 2) {\n                        gridLen3a.setText(tempglen[2]);\n                    } else {\n                        gridLen3a.setText(\"\");\n                    }\n                } else if (loadfocus \u003d\u003d 1) {\n                    if (tempglen.length \u003e 0) {\n                        gridLen1b.setText(tempglen[0]);\n                    } else {\n                        gridLen1b.setText(\"\");\n                    }\n                    if (tempglen.length \u003e 1) {\n                        gridLen2b.setText(tempglen[1]);\n                    } else {\n                        gridLen2b.setText(\"\");\n                    }\n                    if (tempglen.length \u003e 2) {\n                        gridLen3b.setText(tempglen[2]);\n                    } else {\n                        gridLen3b.setText(\"\");\n                    }\n                } else {\n                    if (tempglen.length \u003e 0) {\n                        gridLen1c.setText(tempglen[0]);\n                    } else {\n                        gridLen1c.setText(\"\");\n                    }\n                    if (tempglen.length \u003e 1) {\n                        gridLen2c.setText(tempglen[1]);\n                    } else {\n                        gridLen2c.setText(\"\");\n                    }\n                    if (tempglen.length \u003e 2) {\n                        gridLen3c.setText(tempglen[2]);\n                    } else {\n                        gridLen3c.setText(\"\");\n                    }\n                }\n            } else if (thedata[i].contains(\"ion \")) {\n                String[] tempion \u003d thedata[i].substring((thedata[i].indexOf(\"ion \") + 4), thedata[i].length()).split(\" \");\n                if (countion1) {\n                    if (tempion.length \u003e 0) {\n                        countIon1Charge.setText(tempion[0]);\n                    } else {\n                        countIon1Charge.setText(\"\");\n                    }\n                    if (tempion.length \u003e 1) {\n                        countIon1Con.setText(tempion[1]);\n                    } else {\n                        countIon1Con.setText(\"\");\n                    }\n                    if (tempion.length \u003e 2) {\n                        countIon1Sz.setText(tempion[2]);\n                    } else {\n                        countIon1Sz.setText(\"\");\n                    }\n                    countion1 \u003d false;\n                } else {\n                    if (tempion.length \u003e 0) {\n                        countIon2Charge.setText(tempion[0]);\n                    } else {\n                        countIon2Charge.setText(\"\");\n                    }\n                    if (tempion.length \u003e 1) {\n                        countIon2Con.setText(tempion[1]);\n                    } else {\n                        countIon2Con.setText(\"\");\n                    }\n                    if (tempion.length \u003e 2) {\n                        countIon2Sz.setText(tempion[2]);\n                    } else {\n                        countIon2Sz.setText(\"\");\n                    }\n                }\n            } else if (thedata[i].contains(\"pdie \")) {\n                proteinDi.setText(thedata[i].substring((thedata[i].indexOf(\"pdie \") + 5), thedata[i].length()));\n            } else if (thedata[i].contains(\"sdie \")) {\n                solventDi.setText(thedata[i].substring((thedata[i].indexOf(\"sdie \") + 5), thedata[i].length()));\n            } else if (thedata[i].contains(\"srad \")) {\n                srad.setText(thedata[i].substring((thedata[i].indexOf(\"srad \") + 5), thedata[i].length()));\n            } else if (thedata[i].contains(\"sdens \")) {\n                sdens.setText(thedata[i].substring((thedata[i].indexOf(\"sdens \") + 6), thedata[i].length()));\n            } else if (thedata[i].contains(\"temp \")) {\n                temp.setText(thedata[i].substring((thedata[i].indexOf(\"temp \") + 5), thedata[i].length()));\n            } else if (thedata[i].contains(\"mdie \")) {\n                membraneDi.setText(thedata[i].substring((thedata[i].indexOf(\"mdie \") + 5), thedata[i].length()));\n            } else if (thedata[i].contains(\"zmem \")) {\n                zmem.setText(thedata[i].substring((thedata[i].indexOf(\"zmem \") + 5), thedata[i].length()));\n            } else if (thedata[i].contains(\"lmem \")) {\n                Lmem.setText(thedata[i].substring((thedata[i].indexOf(\"lmem \") + 5), thedata[i].length()));\n            } else if (thedata[i].contains(\"memv \")) {\n                potential.setText(thedata[i].substring((thedata[i].indexOf(\"memv \") + 5), thedata[i].length()));\n            } else if (thedata[i].contains(\"idie \")) {\n                idie.setText(thedata[i].substring((thedata[i].indexOf(\"idie \") + 5), thedata[i].length()));\n            } else if (thedata[i].contains(\"geo1 \")) {\n                System.out.println(thedata[i]);\n                geoFactor1.setText(thedata[i].substring((thedata[i].indexOf(\"geo1 \") + 5), thedata[i].length()));\n            } else if (thedata[i].contains(\"geo2 \")) {\n                geoFactor2.setText(thedata[i].substring((thedata[i].indexOf(\"geo2 \") + 5), thedata[i].length()));\n            } else if (thedata[i].contains(\"geo3 \")) {\n                geoFactor3.setText(thedata[i].substring((thedata[i].indexOf(\"geo3 \") + 5), thedata[i].length()));\n            } else if (thedata[i].contains(\"gcent \")) {\n                String loadctr \u003d (thedata[i].substring((thedata[i].indexOf(\"gcent \") + 6), thedata[i].length()));\n                if (loadctr.equals(\"0 0 0\")) {\n                    centerCombo.setSelectedIndex(0);\n                } else if (loadctr.equals(\"mol 1\")) {\n                    centerCombo.setSelectedIndex(1);\n                }\n            } else if (thedata[i].contains(\"lpbe\")) {\n                solMethodCombo.setSelectedIndex(0);\n            } else if (thedata[i].contains(\"npbe\")) {\n                solMethodCombo.setSelectedIndex(1);\n            } else if (thedata[i].contains(\"bcfl \")) {\n                String loadbcfl \u003d thedata[i].substring((thedata[i].indexOf(\"bcfl \") + 5), thedata[i].length());\n                if (loadbcfl.equals(\"zero\")) {\n                    boundaryCondCombo.setSelectedIndex(0);\n                } else if (loadbcfl.equals(\"sdh\")) {\n                    boundaryCondCombo.setSelectedIndex(1);\n                } else if (loadbcfl.equals(\"mdh\")) {\n                    boundaryCondCombo.setSelectedIndex(2);\n                } else if (loadbcfl.equals(\"focus\")) {\n                    boundaryCondCombo.setSelectedIndex(3);\n                } else if (loadbcfl.equals(\"memv\")) {\n                    boundaryCondCombo.setSelectedIndex(4);\n                }\n            }\n        }\n    }\n\n    /**\n     * Simple method for logging debug output to file.\n     * @param msg String to write to file for debug purposes.\n     */\n    protected void log(String msg) {\n        if (true) {\n            try {\n                outFile \u003d new PrintWriter(new FileOutputStream(new File(ofile.getPath() + \".log\"), true));\n            } catch (Exception e1) {\n                System.out.print(e1.toString());\n            }\n            outFile.println(msg);\n            outFile.close();\n        }\n    }\n\n    /**\n     * Locate a file from the filesystem via the JFileChooser.\n     * @return True if the file was successfully selected, otherwise false.\n     */\n    private boolean OpenFile() {\n        File currentDir \u003d new File(\".\");\n        final JFileChooser fc \u003d new JFileChooser(currentDir);\n        int returnVal \u003d fc.showOpenDialog(theWindow);\n        if (returnVal \u003d\u003d JFileChooser.APPROVE_OPTION) {\n            ofile \u003d fc.getSelectedFile();\n            //we now have a familiar file\n            file_loaded \u003d true;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Select a location and name for saving a file.\n     * @param savetitle title for the JFileChooser window.\n     * @return True if a file path was successfully chosen, otherwise false.\n     */\n    private boolean SaveDialog(String savetitle) {\n        File currentDir \u003d new File(\".\");\n        final JFileChooser fc \u003d new JFileChooser(currentDir);\n        fc.setDialogTitle(savetitle);\n        int returnVal \u003d fc.showSaveDialog(theWindow);\n        if (returnVal \u003d\u003d JFileChooser.APPROVE_OPTION) {\n            ofile \u003d fc.getSelectedFile();\n            ofile.mkdir();\n            log(ofile.getParent() + \"/\" + ofile.getName() + \"/\" + ofile.getName());\n            ofile \u003d new File(ofile.getParent() + \"/\" + ofile.getName() + \"/\" + ofile.getName());\n            file_loaded \u003d true;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Delete a list of temporary files based on extension.\n     * @param directory Path to the directory that contains the files.\n     * @param extension File extension of the files that will be deleted.\n     */\n    private void deleteFiles(String directory, String extension) {\n        ExtensionFilter filter \u003d new ExtensionFilter(extension);\n        File dir \u003d new File(directory);\n        String[] list \u003d dir.list(filter);\n        File todelete;\n        if (list.length \u003d\u003d 0)\n            return;\n        System.out.println(\"Cleaning up current working directory...\");\n        for (int i \u003d 0; i \u003c list.length; i++) {\n            todelete \u003d new File(directory, list[i]);\n            System.out.println(todelete + \"  deleted: \" + todelete.delete());\n        }\n    }\n\n    /**\n     * Copy files based on extension\n     * @param src Path to source directory.\n     * @param dst Path to destination directory.\n     * @param extension Extension of files to be copied.\n     */\n    public void copyFiles(String src, String dst, String extension) {\n        ExtensionFilter filter \u003d new ExtensionFilter(extension);\n        File dir \u003d new File(src);\n        File[] list \u003d dir.listFiles(filter);\n        if (list.length \u003d\u003d 0)\n            return;\n        try {\n            for (int i \u003d 0; i \u003c list.length; i++) {\n                InputStream in \u003d new FileInputStream(list[i]);\n                OutputStream out \u003d new FileOutputStream(new File(dst + \"/\" + list[i].getName()));\n                byte[] buf \u003d new byte[1024];\n                int len \u003d 0;\n                while ((len \u003d in.read(buf)) \u003e 0) {\n                    out.write(buf, 0, len);\n                }\n                in.close();\n                out.close();\n                System.out.print(list[i].getPath() + \" copied to \" + dst);\n            }\n        } catch (Exception fe) {\n            System.out.println(fe);\n        }\n    }\n\n    private void dependencyCheck() {\n        String dependencyError \u003d \"\";\n        //First check to make sure the commandline utilities are available\n        File[] requiredFiles \u003d new File[3];\n        String osExt \u003d \"\";\n        //Add the .exe extension when running on windows\n        if (System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n            osExt \u003d \".exe\";\n        }\n        requiredFiles[0] \u003d new File(\"draw_membrane4\" + osExt);\n        requiredFiles[1] \u003d new File(\"pull_comps\" + osExt);\n        requiredFiles[2] \u003d new File(\"total_charge_off_2\" + osExt);\n        //make sure the commandline util files exist\n        for (File i : requiredFiles) {\n            if (!i.exists()) {\n                dependencyError +\u003d i.getName() + \" was not found in your APBSmem directory.\\n\";\n            }\n        }\n        //Now check to make sure APBS is installed and available\n        try {\n            ProcessBuilder pb \u003d new ProcessBuilder();\n            if (System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n                pb \u003d new ProcessBuilder(\"apbs.exe\", \"--version\");\n            } else {\n                pb \u003d new ProcessBuilder(\"apbs\", \"--version\");\n            }\n            Process pp \u003d pb.start();\n            int exitVal \u003d pp.waitFor();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.out.println(e.getMessage());\n            dependencyError +\u003d \"Could not run APBS. Make sure it is installed and located on your path.\\n\";\n        }\n        if (!dependencyError.equals(\"\")) {\n            JOptionPane.showMessageDialog(null, \"One or more errors were found during startup:\\n\" + dependencyError + \"\\nFor more information please see the APBSmem manual.\", \"Error\", JOptionPane.ERROR_MESSAGE);\n        }\n    }\n\n    /**\n     */\n    public class ExtensionFilter implements FilenameFilter {\n\n        private String extension;\n\n        /**\n         * @param extension\n         */\n        public ExtensionFilter(String extension) {\n            this.extension \u003d extension;\n        }\n\n        public boolean accept(File dir, String name) {\n            return (name.endsWith(extension));\n        }\n    }\n\n    /**\n     */\n    public class SimpleAboutDialog extends JDialog {\n\n        /**\n         * A basic dialog for describing details of the software and providing contact information.\n         * @param parent The APBSmem main JFrame window.\n         */\n        public SimpleAboutDialog(JFrame parent) {\n            super(parent, \"About APBSmem\", true);\n            Box b \u003d Box.createVerticalBox();\n            b.add(Box.createGlue());\n            b.add(new JLabel(\"APBSmem v\" + version));\n            b.add(new JLabel(\"Grabe Lab\"));\n            b.add(new JLabel(\"University of Pittsburgh\"));\n            b.add(new JLabel(\"http://mgrabe1.bio.pitt.edu/apbsmem/\"));\n            b.add(Box.createGlue());\n            getContentPane().add(b, \"Center\");\n            JPanel p2 \u003d new JPanel();\n            JButton ok \u003d new JButton(\"OK\");\n            p2.add(ok);\n            getContentPane().add(p2, \"South\");\n            ok.addActionListener(new ActionListener() {\n\n                public void actionPerformed(ActionEvent evt) {\n                    setVisible(false);\n                }\n            });\n            setSize(300, 200);\n        }\n    }\n\n    public class SimpleHelpDialog extends JDialog {\n\n        /**\n         * A basic dialog for describing details of the software and providing contact information.\n         * @param parent The APBSmem main JFrame window.\n         */\n        public SimpleHelpDialog(JFrame parent) {\n            super(parent, \"APBSmem Help\", true);\n            JScrollPane jsp \u003d new JScrollPane();\n            try {\n                JEditorPane jep \u003d new JEditorPane(\"http://mgrabe1.bio.pitt.edu/apbsmem/\");\n                jep.setEditable(false);\n                jsp.getViewport().add(jep, BorderLayout.CENTER);\n            } catch (Exception e) {\n                System.out.println(\"couldnt load editorpane\");\n            }\n            JButton ok \u003d new JButton(\"OK\");\n            jsp.validate();\n            jsp.add(ok);\n            getContentPane().add(jsp, \"South\");\n            ok.addActionListener(new ActionListener() {\n\n                public void actionPerformed(ActionEvent evt) {\n                    setVisible(false);\n                }\n            });\n            setSize(300, 200);\n        }\n    }\n}\n",
    "package": "apbs_mem_gui",
    "classname": "Main",
    "id": "/EvoSuiteBenchmark/original/29_apbsmem/src/main/java/apbs_mem_gui/Main.java",
    "test_prompt": "// MainTest.java\npackage apbs_mem_gui;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport java.io.*;\nimport com.jgoodies.forms.layout.*;\nimport com.jgoodies.forms.builder.*;\nimport org.jmol.api.JmolViewer;\nimport org.jmol.api.JmolAdapter;\nimport org.jmol.popup.JmolPopup;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Main}.\n* It contains ten unit test cases for the {@link Main#SaveData()} method.\n*/\nclass MainTest {",
    "method_signature": "SaveData()",
    "suffix": ""
  }
]