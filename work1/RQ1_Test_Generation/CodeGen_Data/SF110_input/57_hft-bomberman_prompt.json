[
  {
    "numberTests": "ten",
    "original_code": "// ExplosionBounds.java\npackage server;\r\n\r\nimport java.awt.Point;\r\n\r\n/**\r\n * This class is used by the server to define the bounds of a bomb explosion.\r\n * It contains four integer fields indicating the min/max pixel value\r\n * in the given direction that is affected by the explosion. It further offers\r\n * a method to test if a given point lies within the defined bounds.\r\n *\r\n * @author Steffen\r\n */\r\npublic class ExplosionBounds {\r\n\r\n    private int up;\r\n\r\n    private int down;\r\n\r\n    private int right;\r\n\r\n    private int left;\r\n\r\n    /**\r\n     * Creates a new ExplosionBounds object. The four integer parameters define\r\n     * the min/max pixel value in the given direction.\r\n     *\r\n     * @param up\r\n     * @param down\r\n     * @param right\r\n     * @param left\r\n     */\r\n    public ExplosionBounds(int up, int down, int right, int left) {\r\n        super();\r\n        this.up \u003d up;\r\n        this.down \u003d down;\r\n        this.right \u003d right;\r\n        this.left \u003d left;\r\n    }\r\n\r\n    public int getUp() {\r\n        return up;\r\n    }\r\n\r\n    public int getDown() {\r\n        return down;\r\n    }\r\n\r\n    public int getRight() {\r\n        return right;\r\n    }\r\n\r\n    public int getLeft() {\r\n        return left;\r\n    }\r\n\r\n    /**\r\n     * Checks whether the given point lies within the bounds of the explosion.\r\n     *\r\n     * @param p The Point to be checked.\r\n     * @return True if p lies within the bounds, false if not.\r\n     */\r\n    public boolean contain(Point p) {\r\n        if (up \u003c\u003d p.y \u0026\u0026 down \u003e\u003d p.y \u0026\u0026 right \u003e\u003d p.x \u0026\u0026 left \u003c\u003d p.x) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n",
    "package": "server",
    "classname": "ExplosionBounds",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/server/ExplosionBounds.java",
    "test_prompt": "// ExplosionBoundsTest.java\npackage server;\n\nimport java.awt.Point;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ExplosionBounds}.\n* It contains ten unit test cases for the {@link ExplosionBounds#contain(Point)} method.\n*/\nclass ExplosionBoundsTest {",
    "method_signature": "contain(Point)",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// BomberServer.java\npackage server;\n\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport messages.Message;\nimport messages.global.GlobalServerMsg;\nimport messages.global.SessionDetailsMsg;\nimport messages.global.SessionListMsg;\nimport org.apache.log4j.Logger;\nimport org.hsqldb.Server;\nimport org.hsqldb.jdbc.jdbcDataSource;\nimport common.Constants;\n\n/**\n * This is the main server class. It is responsible for accepting connections\n * from clients and starting new games/session.\n *\n * @author Steffen, Bj�rn, Daniel\n */\npublic class BomberServer {\n\n    private static final Logger logger \u003d Logger.getLogger(BomberServer.class);\n\n    /**\n     * The BomberServer singleton.\n     */\n    private static BomberServer bomberServer;\n\n    /**\n     * The ServerSocket on which connections are accepted.\n     */\n    private ServerSocket srvSocket;\n\n    /**\n     * The sessions currently running on this on this server. key: session name,\n     * value: corresponding session object\n     */\n    private HashMap\u003cString, ServerGameSession\u003e gameSessions \u003d new HashMap\u003cString, ServerGameSession\u003e();\n\n    /**\n     * Contains all the clients who are currently in the global lobby.\n     */\n    private Vector\u003cClientInfo\u003e globalClients \u003d new Vector\u003cClientInfo\u003e();\n\n    /**\n     * Contains all the clients who are currently connected to the Server.\n     */\n    private Vector\u003cClientInfo\u003e allClients \u003d new Vector\u003cClientInfo\u003e();\n\n    private static int port \u003d Constants.DEFAULT_SERVER_PORT;\n\n    private ServerGameSession newSession;\n\n    /**\n     * Private constructor. Creates a new BomberServer. Use the\n     * getInstance-method to obtain the BomberServer singleton.\n     */\n    private BomberServer() {\n        startDB();\n        try {\n            srvSocket \u003d new ServerSocket(port);\n        } catch (IOException e) {\n            logger.fatal(\"Couldn\u0027t create ServerSocket\", e);\n        }\n    }\n\n    private void startDB() {\n        String[] options \u003d new String[] { \"-database.0\", \"hsqldb/datenbank\", \"-dbname.0\", \"datenbank\" };\n        Server.main(options);\n    }\n\n    /**\n     * Main method. One optional parameter may be specified, which will be\n     * interpreted as the port number the server accepts client connections on.\n     *\n     * @param args\n     */\n    public static void main(String[] args) {\n        // try to read user-defined port if specified\n        if (args.length \u003e 0) {\n            try {\n                port \u003d Integer.valueOf(args[0]);\n            } catch (NumberFormatException e) {\n                logger.warn(\"Incorrect server port specified! Using default...\");\n            }\n        }\n        logger.info(\"Starting server on port: \" + port);\n        BomberServer bomberSrv \u003d getInstance();\n        bomberSrv.waitForClients();\n    }\n\n    /**\n     * Accepts incoming client connections.\n     */\n    public void waitForClients() {\n        new Thread() {\n\n            public void run() {\n                logger.info(\"Waiting for players...\");\n                while (!isInterrupted()) {\n                    Socket clientSocket;\n                    try {\n                        clientSocket \u003d srvSocket.accept();\n                        ClientInfo clientInfo \u003d new ClientInfo(clientSocket);\n                        addClientToGlobal(clientInfo);\n                        addClient(clientInfo);\n                    } catch (IOException e) {\n                        logger.fatal(\"Couldn\u0027t accept connection on ServerSocket\", e);\n                    }\n                }\n            }\n        }.start();\n    }\n\n    /**\n     * Creates a new GameSession.\n     *\n     * @param name\n     * @param totalRounds\n     * @return The newly created GameSession-object, null if the session name\n     *         was already taken\n     */\n    public ServerGameSession createSession(String name, List\u003cString\u003e maps, ImageIcon mapPreview, int nrOfPlayers, int totalRounds) {\n        if (gameSessions.containsKey(name)) {\n            return null;\n        } else {\n            newSession \u003d new ServerGameSession(name, maps, mapPreview, nrOfPlayers, totalRounds);\n            gameSessions.put(name, newSession);\n            newSession.broadcastMsg(new SessionListMsg());\n            broadcastSessionList();\n            return newSession;\n        }\n    }\n\n    /**\n     * Creates a SessionListMsg from all open sessions and\n     * sends it to all clients.\n     */\n    private void broadcastSessionList() {\n        SessionListMsg response \u003d new SessionListMsg();\n        for (ServerGameSession session : getGameSessions()) {\n            // a session has at least one player in it (hacky)\n            int nrOfPlayers \u003d 1;\n            if (session.getCurrentNrOfPlayers() !\u003d 0) {\n                nrOfPlayers \u003d session.getCurrentNrOfPlayers();\n            }\n            SessionDetailsMsg sessionInfo \u003d new SessionDetailsMsg(session.getName(), session.getMaps(), session.getPreview(), session.getTotalNrOfPlayers(), nrOfPlayers, session.getTotalRounds());\n            response.addSessionInfo(sessionInfo);\n        }\n        multicastMsg(response, null);\n    }\n\n    /**\n     * Sends the message to all clients except the original sender itself.\n     *\n     * @param msg\n     *            The message to be sent.\n     * @param sender\n     *            The original sender of the msg.\n     */\n    public void multicastMsg(Message msg, ClientInfo sender) {\n        for (ClientInfo participant : globalClients) {\n            if (participant !\u003d sender) {\n                participant.sendMsg(msg);\n            }\n        }\n    }\n\n    /**\n     * Broadcasts a message to all connected clients.\n     *\n     * @param msg\n     *            The message to be sent.\n     */\n    public void broadcastMsg(Message msg) {\n        for (ClientInfo client : globalClients) {\n            client.sendMsg(msg);\n        }\n    }\n\n    /**\n     * this will exit the server\n     *\n     * @author Bj�rn\n     */\n    public void stopServer() {\n        closeDB();\n        logger.info(\"Server stopped\");\n        System.exit(0);\n    }\n\n    // shutdown database\n    public static void closeDB() {\n        jdbcDataSource dataSource \u003d setupDataSource();\n        try {\n            Connection connection \u003d dataSource.getConnection();\n            Statement statement \u003d connection.createStatement();\n            statement.execute(\"SHUTDOWN\");\n            statement.close();\n            connection.close();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static jdbcDataSource setupDataSource() {\n        jdbcDataSource dataSource \u003d new jdbcDataSource();\n        dataSource.setDatabase(\"jdbc:hsqldb:hsql://localhost/datenbank\");\n        dataSource.setUser(\"sa\");\n        dataSource.setPassword(\"\");\n        return dataSource;\n    }\n\n    /**\n     * Removes the client whose ClientInfo object is passed as a parameter from\n     * the global area. As a result this client will no longer receive global\n     * messages.\n     *\n     * @param clientInfo\n     */\n    public void removeClientFromGlobal(ClientInfo clientInfo) {\n        globalClients.remove(clientInfo);\n    }\n\n    public void addClientToGlobal(ClientInfo clientInfo) {\n        globalClients.add(clientInfo);\n    }\n\n    /**\n     * Removes a client\n     *\n     * @param clientInfo\n     */\n    public void removeClient(ClientInfo clientInfo) {\n        allClients.remove(clientInfo);\n    }\n\n    public void addClient(ClientInfo clientInfo) {\n        allClients.add(clientInfo);\n    }\n\n    /**\n     * Static factory method.\n     *\n     * @return The BomberServer Singleton\n     */\n    public static BomberServer getInstance() {\n        if (bomberServer \u003d\u003d null) {\n            bomberServer \u003d new BomberServer();\n        }\n        return bomberServer;\n    }\n\n    public Collection\u003cServerGameSession\u003e getGameSessions() {\n        return gameSessions.values();\n    }\n\n    public ServerGameSession getGameSession(String name) {\n        return gameSessions.get(name);\n    }\n\n    public void removeSession(String name) {\n        gameSessions.remove(name);\n        newSession.broadcastMsg(new SessionListMsg());\n    }\n\n    public Vector\u003cClientInfo\u003e getClients() {\n        return allClients;\n    }\n}\n",
    "package": "server",
    "classname": "BomberServer",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/server/BomberServer_1Test.java",
    "test_prompt": "// BomberServer_1Test.java\npackage server;\n\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport messages.Message;\nimport messages.global.GlobalServerMsg;\nimport messages.global.SessionDetailsMsg;\nimport messages.global.SessionListMsg;\nimport org.apache.log4j.Logger;\nimport org.hsqldb.Server;\nimport org.hsqldb.jdbc.jdbcDataSource;\nimport common.Constants;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BomberServer}.\n* It contains ten unit test cases for the {@link BomberServer#getInstance()} method.\n*/\nclass BomberServer_1Test {",
    "method_signature": "getInstance()",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// ServerBomb.java\npackage server;\r\n\r\nimport java.awt.Point;\r\nimport java.awt.Rectangle;\r\nimport java.util.Collection;\r\nimport java.util.Vector;\r\nimport messages.round.BombExplodedMsg;\r\nimport org.apache.log4j.Logger;\r\nimport common.Bomb;\r\nimport common.Constants;\r\nimport common.GameObject;\r\nimport common.Player;\r\nimport common.PowerUp;\r\nimport common.Tile;\r\nimport db.DBException;\r\nimport db.DBGameUser;\r\nimport db.DBServiceFactory;\r\n\r\n/**\r\n * The Bomb Object of the Server. This Bomb ticks some times and then exploded.\r\n * Then it detects the player and the tile hits.\r\n *\r\n * @author Bj�rn, Steffen, Daniel\r\n */\r\npublic class ServerBomb extends Bomb {\r\n\r\n    /**\r\n     * The negated number of frames rendered after an explosion\r\n     */\r\n    private static final int POST_EXPLOSION_FRAMES \u003d -40;\r\n\r\n    private static final Logger logger \u003d Logger.getLogger(ServerBomb.class);\r\n\r\n    private int tickTime \u003d 2500;\r\n\r\n    private int tickFrames \u003d tickTime / 16;\r\n\r\n    private ServerGameSession session;\r\n\r\n    private boolean hasAlreadyExploded;\r\n\r\n    private ExplosionBounds bounds;\r\n\r\n    private boolean explodesrightnow \u003d false;\r\n\r\n    public ServerBomb(Point position, ServerGameSession session) {\r\n        super(position);\r\n        this.session \u003d session;\r\n    }\r\n\r\n    @Override\r\n    protected synchronized void move() {\r\n    }\r\n\r\n    @Override\r\n    public synchronized void updateMovement(Point targetPosition) {\r\n        position.setLocation(targetPosition);\r\n    }\r\n\r\n    /**\r\n     * Handles the explosion and the hit-detection of the bomb\r\n     *\r\n     * @return\r\n     */\r\n    public void explode(Collection\u003cGameObject\u003e gameObjects) {\r\n        logger.info(\"Bomb exploded: \" + id);\r\n        bounds \u003d getExplosionBounds(gameObjects);\r\n        explodesrightnow \u003d true;\r\n        determineHits(gameObjects);\r\n        hasAlreadyExploded \u003d true;\r\n    }\r\n\r\n    private void determineHits(Collection\u003cGameObject\u003e gameObjects) {\r\n        Vector\u003cInteger\u003e playerHits \u003d new Vector\u003cInteger\u003e();\r\n        Vector\u003cInteger\u003e tileHits \u003d new Vector\u003cInteger\u003e();\r\n        Vector\u003cInteger\u003e powerupHits \u003d new Vector\u003cInteger\u003e();\r\n        for (GameObject gameObject : gameObjects) {\r\n            // hit players?\r\n            if (Player.class.isInstance(gameObject)) {\r\n                Player player \u003d (Player) gameObject;\r\n                if (bounds.contain(player.getPosition()) \u0026\u0026 this.checkHit(gameObject)) {\r\n                    int playerid \u003d player.getId();\r\n                    logger.info(\"exploded and check for hits \" + explodesrightnow);\r\n                    if (explodesrightnow \u003d\u003d true) {\r\n                        if (getPlanterId() \u003d\u003d playerid) {\r\n                            logger.info(playerid + \" killed himself \" + getPlanterId());\r\n                            session.getCurrentRound().addRoundScore(getPlanterId(), -1);\r\n                        } else {\r\n                            logger.info(playerid + \" scored one \" + getPlanterId());\r\n                            session.getCurrentRound().addRoundScore(getPlanterId(), 1);\r\n                        }\r\n                    }\r\n                    logger.info(\"Hit player: \" + gameObject.getId() + \" at \" + gameObject.getPosition());\r\n                    playerHits.add(gameObject.getId());\r\n                    gameObject.setInactive();\r\n                }\r\n            }\r\n            // hit tiles?\r\n            if (Tile.class.isInstance(gameObject)) {\r\n                Tile t \u003d (Tile) gameObject;\r\n                if (t.isBombable()) {\r\n                    if (this.checkHit(t) \u0026\u0026 bounds.contain(t.getPosition())) {\r\n                        logger.info(\"Hit tile: \" + t.getId() + \" at \" + t.getPosition().x + \", \" + t.getPosition().y);\r\n                        tileHits.add(t.getId());\r\n                        t.setInactive();\r\n                    }\r\n                }\r\n            }\r\n            // hit powerups?\r\n            if (ServerPowerUp.class.isInstance(gameObject)) {\r\n                ServerPowerUp powerUp \u003d (ServerPowerUp) gameObject;\r\n                if (!powerUp.isVisible() \u0026\u0026 powerUp.isActive()) {\r\n                    if (this.checkHit(powerUp) \u0026\u0026 bounds.contain(powerUp.getPosition())) {\r\n                        logger.info(\"Hit powerup: \" + powerUp.getId() + \" at \" + powerUp.getPosition().x + \", \" + powerUp.getPosition().y);\r\n                        powerUp.setVisible();\r\n                        powerupHits.add(powerUp.getId());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (tickFrames \u003d\u003d POST_EXPLOSION_FRAMES) {\r\n            active \u003d false;\r\n        }\r\n        // msg is only sent the first time or if somebody ran into the explosion\r\n        if (!hasAlreadyExploded || !(playerHits.isEmpty() \u0026\u0026 tileHits.isEmpty())) {\r\n            BombExplodedMsg msg \u003d new BombExplodedMsg(this.getId(), playerHits, tileHits, powerupHits, hasAlreadyExploded);\r\n            msg.setExplosionBounds(bounds);\r\n            session.broadcastMsg(msg);\r\n        }\r\n    }\r\n\r\n    private ExplosionBounds getExplosionBounds(Collection\u003cGameObject\u003e gameObjects) {\r\n        int distance \u003d (diameter * Constants.TILE_BORDER) / 2;\r\n        int top, bottom, left, right;\r\n        top \u003d position.y - distance;\r\n        bottom \u003d position.y + distance;\r\n        left \u003d position.x - distance;\r\n        right \u003d position.x + distance;\r\n        for (GameObject gameObject : gameObjects) {\r\n            if (Tile.class.isInstance(gameObject)) {\r\n                Tile t \u003d (Tile) gameObject;\r\n                // if (!t.isBombable()) {\r\n                Point pos \u003d t.getPosition();\r\n                Point p \u003d new Point(pos.x, pos.y);\r\n                if (getVerticalHitBox().contains(p)) {\r\n                    int y \u003d p.y - position.y;\r\n                    if (y \u003c 0) {\r\n                        top \u003d Math.max(top, p.y);\r\n                    } else {\r\n                        bottom \u003d Math.min(bottom, p.y);\r\n                    }\r\n                }\r\n                if (getHorizontalHitBox().contains(p)) {\r\n                    int x \u003d p.x - position.x;\r\n                    if (x \u003e 0) {\r\n                        right \u003d Math.min(right, p.x);\r\n                    } else {\r\n                        left \u003d Math.max(left, p.x);\r\n                    }\r\n                }\r\n                // }\r\n            }\r\n        }\r\n        logger.info(\"Explosion bounds: \");\r\n        logger.info(\"top: \" + top);\r\n        logger.info(\"bottom: \" + bottom);\r\n        logger.info(\"left: \" + left);\r\n        logger.info(\"right: \" + right);\r\n        return new ExplosionBounds(top, bottom, right, left);\r\n    }\r\n\r\n    /**\r\n     * Returns the vertical hitbox of the bomb\r\n     *\r\n     * @return\r\n     */\r\n    private Rectangle getVerticalHitBox() {\r\n        int x \u003d position.getLocation().x - (Constants.TILE_BORDER / 2);\r\n        int y \u003d position.getLocation().y - ((diameter * Constants.TILE_BORDER) / 2);\r\n        Rectangle rectangle \u003d new Rectangle(x + 5, y, Constants.EXPLOSION_WIDTH, diameter * Constants.EXPLOSION_LENGTH - 1);\r\n        return rectangle;\r\n    }\r\n\r\n    /**\r\n     * Returns the horizontal hitbox of the bomb\r\n     *\r\n     * @return\r\n     */\r\n    private Rectangle getHorizontalHitBox() {\r\n        int x \u003d position.getLocation().x - ((diameter * Constants.TILE_BORDER) / 2);\r\n        int y \u003d position.getLocation().y - (Constants.TILE_BORDER / 2);\r\n        Rectangle rectangle \u003d new Rectangle(x, y + 5, diameter * Constants.EXPLOSION_LENGTH - 1, Constants.EXPLOSION_WIDTH);\r\n        return rectangle;\r\n    }\r\n\r\n    @Override\r\n    public void updateWithCollisionCheck(Collection\u003cGameObject\u003e gameObjects) {\r\n        super.updateWithCollisionCheck(gameObjects);\r\n        if (stopped) {\r\n            if (tick()) {\r\n                explode(gameObjects);\r\n            } else if (tickFrames \u003e POST_EXPLOSION_FRAMES \u0026\u0026 tickFrames \u003c 0) {\r\n                // detect if a player ran into the explosion afterwards\r\n                // (explosion\r\n                // rendering\r\n                // lasts 8 frames)\r\n                determineHits(gameObjects);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * handles the tick of the bomb\r\n     *\r\n     * @return\r\n     */\r\n    public boolean tick() {\r\n        this.tickFrames--;\r\n        if (tickFrames \u003d\u003d 0) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * check if a gameObject is hit by the bomb\r\n     *\r\n     * @param gameObject\r\n     * @return\r\n     */\r\n    private boolean checkHit(GameObject gameObject) {\r\n        Rectangle[] rects \u003d new Rectangle[] { this.getHorizontalHitBox(), this.getVerticalHitBox() };\r\n        for (Rectangle rect : rects) {\r\n            if (this.id !\u003d gameObject.getId()) {\r\n                if (rect.intersects(gameObject.getCollisionRectangle())) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n",
    "package": "server",
    "classname": "ServerBomb",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/server/ServerBomb.java",
    "test_prompt": "// ServerBombTest.java\npackage server;\n\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.util.Collection;\nimport java.util.Vector;\nimport messages.round.BombExplodedMsg;\nimport org.apache.log4j.Logger;\nimport common.Bomb;\nimport common.Constants;\nimport common.GameObject;\nimport common.Player;\nimport common.PowerUp;\nimport common.Tile;\nimport db.DBException;\nimport db.DBGameUser;\nimport db.DBServiceFactory;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServerBomb}.\n* It contains ten unit test cases for the {@link ServerBomb#tick()} method.\n*/\nclass ServerBombTest {",
    "method_signature": "tick()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// StopServer.java\npackage server;\r\n\r\nimport java.io.IOException;\r\nimport java.io.ObjectOutputStream;\r\nimport java.net.Socket;\r\nimport messages.Message;\r\nimport messages.global.StopServerMsg;\r\n\r\n/**\r\n * Sends a Message to the Server, that he should closed\r\n *\r\n * @author Bj�rn\r\n */\r\npublic class StopServer {\r\n\r\n    private ObjectOutputStream out;\r\n\r\n    private Socket server;\r\n\r\n    private String serverName \u003d \"193.196.141.182\";\r\n\r\n    private int serverPort \u003d 6666;\r\n\r\n    /**\r\n     * sends a message\r\n     *\r\n     * @param msg\r\n     */\r\n    public void sendMsg(Message msg) {\r\n        try {\r\n            out.writeObject(msg);\r\n        } catch (IOException e) {\r\n            // TODO Auto-generated catch block\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect to the Server\r\n     */\r\n    public boolean connectToSrv() {\r\n        try {\r\n            //System.out.println(\"Connecting...\");\r\n            System.out.println(\"Establishing a connection \");\r\n            server \u003d new Socket(serverName, serverPort);\r\n            out \u003d new ObjectOutputStream(server.getOutputStream());\r\n            System.out.println(\"connected to \" + serverName);\r\n            return true;\r\n        } catch (IOException e) {\r\n            // TODO Auto-generated catch block\r\n            // e.printStackTrace();\r\n            System.out.println(\"Connection failed\");\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect to the server, and send the message\r\n     *\r\n     * @param stop\r\n     */\r\n    public void callingStopServer(StopServer stop) {\r\n        if (stop.connectToSrv()) {\r\n            System.out.println(\"stopping Server...\");\r\n            StopServerMsg msg \u003d new StopServerMsg();\r\n            stop.sendMsg(msg);\r\n            System.out.println(\"Server stopped\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param args\r\n     */\r\n    public static void main(String[] args) {\r\n        StopServer stop \u003d new StopServer();\r\n        stop.callingStopServer(stop);\r\n    }\r\n}\r\n",
    "package": "server",
    "classname": "StopServer",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/server/StopServer.java",
    "test_prompt": "// StopServerTest.java\npackage server;\n\nimport java.io.IOException;\nimport java.io.ObjectOutputStream;\nimport java.net.Socket;\nimport messages.Message;\nimport messages.global.StopServerMsg;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StopServer}.\n* It contains ten unit test cases for the {@link StopServer#connectToSrv()} method.\n*/\nclass StopServerTest {",
    "method_signature": "connectToSrv()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// Map.java\npackage common;\r\n\r\nimport java.awt.Point;\r\nimport java.io.Serializable;\r\nimport java.util.Date;\r\nimport java.util.Iterator;\r\nimport java.util.NoSuchElementException;\r\nimport java.util.Vector;\r\n\r\n/**\r\n * Map-Class with all information needed for map use of iterators tile-iterator:\r\n * for(Tile tile : map) - powerup-iterator: for(PowerUp powerup :\r\n * map.powerupiterator)\r\n *\r\n * @author christian\r\n */\r\npublic class Map implements Iterable\u003cTile\u003e, Serializable {\r\n\r\n    private static final long serialVersionUID \u003d 1L;\r\n\r\n    // flags if tiles, powerups and startpoints need to be read and set\r\n    private boolean settiles \u003d true;\r\n\r\n    private boolean setpowerups \u003d true;\r\n\r\n    private boolean setstartpoints \u003d true;\r\n\r\n    // 2 dimensional game board\r\n    private Object[][] MapGrid;\r\n\r\n    private Vector\u003cPowerUp\u003e Powerups \u003d new Vector\u003cPowerUp\u003e();\r\n\r\n    private Point[] StartPoint;\r\n\r\n    private Point area;\r\n\r\n    private String name;\r\n\r\n    private String imageSet;\r\n\r\n    private String version;\r\n\r\n    private String author;\r\n\r\n    private Date date;\r\n\r\n    private int difficulty;\r\n\r\n    private int maxPlayers;\r\n\r\n    private String filePath;\r\n\r\n    private int itemId \u003d 0;\r\n\r\n    // iterator for powerups\r\n    public Map.PowerUpIterator powerupiterator;\r\n\r\n    /**\r\n     * creates map-object with empty Tile objects\r\n     *\r\n     * @param xmlFile -\r\n     *            path to xml file\r\n     */\r\n    public Map(String xmlFile) {\r\n        mapInit(xmlFile);\r\n    }\r\n\r\n    /**\r\n     * creates map-object with or without Tile objects\r\n     *\r\n     * @param xmlFile -\r\n     *            path to xml file\r\n     * @param info -\r\n     *            Boolean (noTile) if tiles should be read (false) or not (true)\r\n     */\r\n    public Map(String xmlFile, boolean settiles, boolean setpowerups, boolean setstartpoints) {\r\n        this.settiles \u003d settiles;\r\n        this.setpowerups \u003d setpowerups;\r\n        this.setstartpoints \u003d setstartpoints;\r\n        mapInit(xmlFile);\r\n    }\r\n\r\n    /**\r\n     * initiate map and create MapReader Object\r\n     *\r\n     * @param xmlFile\r\n     */\r\n    private void mapInit(String xmlFile) {\r\n        // create Map-Reader an read xml into map\r\n        MapReader xml \u003d new MapReader(xmlFile);\r\n        // get map dimensions\r\n        area \u003d xml.getArea();\r\n        // MapXMLReader writes read properties to map-object\r\n        xml.setMapProperies(this);\r\n        // Tiles +++++++++++++++++++++++++++++++++++++++++++++++++++\r\n        // create map grid with \"empty\" objects if settiles is true\r\n        if (settiles) {\r\n            MapGrid \u003d new Object[area.x][area.y];\r\n            for (int i \u003d 0; i \u003c area.x; i++) {\r\n                for (int j \u003d 0; j \u003c area.y; j++) {\r\n                    Tile tile \u003d new Tile(new Point((area.x * Constants.TILE_BORDER), (area.y * Constants.TILE_BORDER)));\r\n                    MapGrid[i][j] \u003d tile;\r\n                }\r\n            }\r\n            // overwrite specific tiles from xml to map\r\n            xml.setTiles(this);\r\n            // sets tile to wall if type not set\r\n            for (Tile tile : this) {\r\n                if (tile.getType() \u003d\u003d null) {\r\n                    tile.setType(\"wall\");\r\n                }\r\n                tile.setId(itemId++);\r\n            }\r\n        }\r\n        // Powerups ++++++++++++++++++++++++++++++++++++++++++++++++\r\n        // create map grid with \"empty\" powerup objects if setpowerups is true\r\n        if (setpowerups) {\r\n            powerupiterator \u003d new PowerUpIterator();\r\n            // overwrite specific powerups from xml to map\r\n            xml.setPowerups(this);\r\n        }\r\n        // Starpoints ++++++++++++++++++++++++++++++++++++++++++++++++\r\n        // set start points to map\r\n        if (setstartpoints) {\r\n            xml.setStartPoints(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * overwrite specific MapTile at Index x, y\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     * @param tile -\r\n     *            MapTile object\r\n     */\r\n    public void setTileByIndex(int x, int y, Tile tile) {\r\n        MapGrid[x][y] \u003d tile;\r\n    }\r\n\r\n    /**\r\n     * return MapTile object at Index x, y\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     * @return MapTile object\r\n     */\r\n    public Tile getTileByIndex(int x, int y) {\r\n        return (Tile) MapGrid[x][y];\r\n    }\r\n\r\n    /**\r\n     * overwrite specific MapTile at Position x, y\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     * @param tile -\r\n     *            MapTile object\r\n     */\r\n    public void setTile(int x, int y, Tile tile) {\r\n        MapGrid[(int) Math.floor((double) x / Constants.TILE_BORDER)][(int) Math.floor((double) y / Constants.TILE_BORDER)] \u003d tile;\r\n    }\r\n\r\n    /**\r\n     * return MapTile object at Position x, y\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     * @return MapTile object\r\n     */\r\n    public Tile getTile(int x, int y) {\r\n        return (Tile) MapGrid[(int) Math.floor((double) x / Constants.TILE_BORDER)][(int) Math.floor((double) y / Constants.TILE_BORDER)];\r\n    }\r\n\r\n    /**\r\n     * Resets a tile to \"empty\" tile at specific position\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     */\r\n    public void resetTileByIndex(int x, int y) {\r\n        MapGrid[x][y] \u003d new Tile(new Point(x * Constants.TILE_BORDER, y * Constants.TILE_BORDER));\r\n    }\r\n\r\n    /**\r\n     * Resets a tile to \"empty\" tile at specific coordinates\r\n     *\r\n     * @param x -\r\n     *            coordinates of horizontal tile\r\n     * @param y -\r\n     *            coordinates of vertical tile\r\n     */\r\n    public void resetTile(int x, int y) {\r\n        MapGrid[(int) Math.floor((double) x / Constants.TILE_BORDER)][(int) Math.floor((double) y / Constants.TILE_BORDER)] \u003d new Tile(new Point(x, y));\r\n    }\r\n\r\n    /**\r\n     * overwrite specific PowerUp at Index x, y\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     * @param tile -\r\n     *            PoweUp object\r\n     */\r\n    public void addPowerup(PowerUp powerup) {\r\n        powerup.setId(itemId++);\r\n        Powerups.addElement(powerup);\r\n    }\r\n\r\n    /**\r\n     * retrieves a Vector with all PowerUps\r\n     *\r\n     * @return\r\n     */\r\n    public Vector\u003cPowerUp\u003e getPowerups() {\r\n        return this.Powerups;\r\n    }\r\n\r\n    // Getters and Setter for map properties\r\n    /**\r\n     * sets a bunch of properties to map\r\n     *\r\n     * @param mapName -\r\n     *            Name of map\r\n     * @param mapVersion -\r\n     *            Version of map\r\n     * @param mapAuthor -\r\n     *            Name of author\r\n     * @param mapDate -\r\n     *            Date of map\r\n     * @param mapDifficulty -\r\n     *            Difficulty of map\r\n     * @param mapImageSet -\r\n     *            Default image set\r\n     * @param mapMaxPlayers -\r\n     *            Number of max players\r\n     * @param mapFilePath -\r\n     *            path to map xml file\r\n     */\r\n    public void setProperties(String mapName, String mapVersion, String mapAuthor, Date mapDate, int mapDifficulty, String mapImageSet, int mapMaxPlayers, String mapFilePath) {\r\n        this.name \u003d mapName;\r\n        this.version \u003d mapVersion;\r\n        this.author \u003d mapAuthor;\r\n        this.date \u003d mapDate;\r\n        this.difficulty \u003d mapDifficulty;\r\n        this.imageSet \u003d mapImageSet;\r\n        this.maxPlayers \u003d mapMaxPlayers;\r\n        this.filePath \u003d mapFilePath;\r\n    }\r\n\r\n    public String getImageSet() {\r\n        return imageSet;\r\n    }\r\n\r\n    public String getVersion() {\r\n        return version;\r\n    }\r\n\r\n    public String getAuthor() {\r\n        return author;\r\n    }\r\n\r\n    public Date getDate() {\r\n        return date;\r\n    }\r\n\r\n    public int getDifficulty() {\r\n        return difficulty;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public int getMaxPlayers() {\r\n        return maxPlayers;\r\n    }\r\n\r\n    public String getFilePath() {\r\n        return filePath;\r\n    }\r\n\r\n    /**\r\n     * sets measures of map\r\n     *\r\n     * @param x -\r\n     *            number of horizontal fields\r\n     * @param y -\r\n     *            number of vertical fields\r\n     */\r\n    public void setArea(int x, int y) {\r\n        Point area \u003d new Point();\r\n        area.x \u003d x;\r\n        area.y \u003d y;\r\n        this.area \u003d area;\r\n    }\r\n\r\n    /**\r\n     * retrieve measures of map, number of horizontal and vertical fields\r\n     *\r\n     * @return\r\n     */\r\n    public Point getArea() {\r\n        return this.area;\r\n    }\r\n\r\n    /**\r\n     * sets the start-point-position to map\r\n     *\r\n     * @param StPo -\r\n     *            array of start-point-positions\r\n     */\r\n    public void setStartPoints(Point[] StPo) {\r\n        this.StartPoint \u003d StPo;\r\n    }\r\n\r\n    /**\r\n     * gets array of start-point positions (not coordinates)\r\n     *\r\n     * @return\r\n     */\r\n    public Point[] getStartPoints() {\r\n        return this.StartPoint;\r\n    }\r\n\r\n    /**\r\n     * gets start-point-coordinates of player no. if not set, return coordinates\r\n     * of field 1/1\r\n     *\r\n     * @param playerNo -\r\n     *            number of player\r\n     * @return Point with coordinates\r\n     */\r\n    public Point getStartPoint(int playerNo) {\r\n        // startpoint for player is not set, default 1/1\r\n        if (playerNo \u003e StartPoint.length) {\r\n            return new Point(1 * Constants.TILE_BORDER + Constants.TILE_BORDER / 2, // field\r\n            1 * Constants.TILE_BORDER + Constants.TILE_BORDER / 2);\r\n            // 1/1\r\n        } else {\r\n            Point retPoint \u003d StartPoint[(playerNo - 1)];\r\n            retPoint.x \u003d retPoint.x * Constants.TILE_BORDER + 20;\r\n            retPoint.y \u003d retPoint.y * Constants.TILE_BORDER + 20;\r\n            return retPoint;\r\n        }\r\n    }\r\n\r\n    /*\r\n\t * (non-Javadoc)\r\n\t * \r\n\t * @see java.lang.Iterable#iterator()\r\n\t */\r\n    @Override\r\n    public Iterator\u003cTile\u003e iterator() {\r\n        return new Iterator\u003cTile\u003e() {\r\n\r\n            private int idx \u003d 0;\r\n\r\n            int width \u003d MapGrid.length;\r\n\r\n            int height \u003d MapGrid[0].length;\r\n\r\n            private int size \u003d width * height;\r\n\r\n            @Override\r\n            public boolean hasNext() {\r\n                return idx \u003c size;\r\n            }\r\n\r\n            @Override\r\n            public Tile next() {\r\n                if (!hasNext()) {\r\n                    throw new NoSuchElementException();\r\n                }\r\n                Tile tile \u003d (Tile) MapGrid[idx % width][idx / width];\r\n                idx++;\r\n                return tile;\r\n            }\r\n\r\n            @Override\r\n            public void remove() {\r\n                throw new UnsupportedOperationException();\r\n            }\r\n        };\r\n    }\r\n\r\n    /*\r\n\t * (non-Javadoc)\r\n\t * \r\n\t * @see java.lang.Iterable#iterator()\r\n\t */\r\n    /**\r\n     * iterator for PowerUp Objects in map\r\n     *\r\n     * @author christian\r\n     */\r\n    public class PowerUpIterator implements Iterable\u003cPowerUp\u003e, Serializable {\r\n\r\n        private static final long serialVersionUID \u003d 1L;\r\n\r\n        @Override\r\n        public Iterator\u003cPowerUp\u003e iterator() {\r\n            return Powerups.iterator();\r\n        }\r\n    }\r\n}\r\n",
    "package": "common",
    "classname": "Map",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/Map_0Test.java",
    "test_prompt": "// Map_0Test.java\npackage common;\n\nimport java.awt.Point;\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Map}.\n* It contains ten unit test cases for the {@link Map#getTileByIndex(int, int)} method.\n*/\nclass Map_0Test {",
    "method_signature": "getTileByIndex(int, int)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// Map.java\npackage common;\r\n\r\nimport java.awt.Point;\r\nimport java.io.Serializable;\r\nimport java.util.Date;\r\nimport java.util.Iterator;\r\nimport java.util.NoSuchElementException;\r\nimport java.util.Vector;\r\n\r\n/**\r\n * Map-Class with all information needed for map use of iterators tile-iterator:\r\n * for(Tile tile : map) - powerup-iterator: for(PowerUp powerup :\r\n * map.powerupiterator)\r\n *\r\n * @author christian\r\n */\r\npublic class Map implements Iterable\u003cTile\u003e, Serializable {\r\n\r\n    private static final long serialVersionUID \u003d 1L;\r\n\r\n    // flags if tiles, powerups and startpoints need to be read and set\r\n    private boolean settiles \u003d true;\r\n\r\n    private boolean setpowerups \u003d true;\r\n\r\n    private boolean setstartpoints \u003d true;\r\n\r\n    // 2 dimensional game board\r\n    private Object[][] MapGrid;\r\n\r\n    private Vector\u003cPowerUp\u003e Powerups \u003d new Vector\u003cPowerUp\u003e();\r\n\r\n    private Point[] StartPoint;\r\n\r\n    private Point area;\r\n\r\n    private String name;\r\n\r\n    private String imageSet;\r\n\r\n    private String version;\r\n\r\n    private String author;\r\n\r\n    private Date date;\r\n\r\n    private int difficulty;\r\n\r\n    private int maxPlayers;\r\n\r\n    private String filePath;\r\n\r\n    private int itemId \u003d 0;\r\n\r\n    // iterator for powerups\r\n    public Map.PowerUpIterator powerupiterator;\r\n\r\n    /**\r\n     * creates map-object with empty Tile objects\r\n     *\r\n     * @param xmlFile -\r\n     *            path to xml file\r\n     */\r\n    public Map(String xmlFile) {\r\n        mapInit(xmlFile);\r\n    }\r\n\r\n    /**\r\n     * creates map-object with or without Tile objects\r\n     *\r\n     * @param xmlFile -\r\n     *            path to xml file\r\n     * @param info -\r\n     *            Boolean (noTile) if tiles should be read (false) or not (true)\r\n     */\r\n    public Map(String xmlFile, boolean settiles, boolean setpowerups, boolean setstartpoints) {\r\n        this.settiles \u003d settiles;\r\n        this.setpowerups \u003d setpowerups;\r\n        this.setstartpoints \u003d setstartpoints;\r\n        mapInit(xmlFile);\r\n    }\r\n\r\n    /**\r\n     * initiate map and create MapReader Object\r\n     *\r\n     * @param xmlFile\r\n     */\r\n    private void mapInit(String xmlFile) {\r\n        // create Map-Reader an read xml into map\r\n        MapReader xml \u003d new MapReader(xmlFile);\r\n        // get map dimensions\r\n        area \u003d xml.getArea();\r\n        // MapXMLReader writes read properties to map-object\r\n        xml.setMapProperies(this);\r\n        // Tiles +++++++++++++++++++++++++++++++++++++++++++++++++++\r\n        // create map grid with \"empty\" objects if settiles is true\r\n        if (settiles) {\r\n            MapGrid \u003d new Object[area.x][area.y];\r\n            for (int i \u003d 0; i \u003c area.x; i++) {\r\n                for (int j \u003d 0; j \u003c area.y; j++) {\r\n                    Tile tile \u003d new Tile(new Point((area.x * Constants.TILE_BORDER), (area.y * Constants.TILE_BORDER)));\r\n                    MapGrid[i][j] \u003d tile;\r\n                }\r\n            }\r\n            // overwrite specific tiles from xml to map\r\n            xml.setTiles(this);\r\n            // sets tile to wall if type not set\r\n            for (Tile tile : this) {\r\n                if (tile.getType() \u003d\u003d null) {\r\n                    tile.setType(\"wall\");\r\n                }\r\n                tile.setId(itemId++);\r\n            }\r\n        }\r\n        // Powerups ++++++++++++++++++++++++++++++++++++++++++++++++\r\n        // create map grid with \"empty\" powerup objects if setpowerups is true\r\n        if (setpowerups) {\r\n            powerupiterator \u003d new PowerUpIterator();\r\n            // overwrite specific powerups from xml to map\r\n            xml.setPowerups(this);\r\n        }\r\n        // Starpoints ++++++++++++++++++++++++++++++++++++++++++++++++\r\n        // set start points to map\r\n        if (setstartpoints) {\r\n            xml.setStartPoints(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * overwrite specific MapTile at Index x, y\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     * @param tile -\r\n     *            MapTile object\r\n     */\r\n    public void setTileByIndex(int x, int y, Tile tile) {\r\n        MapGrid[x][y] \u003d tile;\r\n    }\r\n\r\n    /**\r\n     * return MapTile object at Index x, y\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     * @return MapTile object\r\n     */\r\n    public Tile getTileByIndex(int x, int y) {\r\n        return (Tile) MapGrid[x][y];\r\n    }\r\n\r\n    /**\r\n     * overwrite specific MapTile at Position x, y\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     * @param tile -\r\n     *            MapTile object\r\n     */\r\n    public void setTile(int x, int y, Tile tile) {\r\n        MapGrid[(int) Math.floor((double) x / Constants.TILE_BORDER)][(int) Math.floor((double) y / Constants.TILE_BORDER)] \u003d tile;\r\n    }\r\n\r\n    /**\r\n     * return MapTile object at Position x, y\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     * @return MapTile object\r\n     */\r\n    public Tile getTile(int x, int y) {\r\n        return (Tile) MapGrid[(int) Math.floor((double) x / Constants.TILE_BORDER)][(int) Math.floor((double) y / Constants.TILE_BORDER)];\r\n    }\r\n\r\n    /**\r\n     * Resets a tile to \"empty\" tile at specific position\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     */\r\n    public void resetTileByIndex(int x, int y) {\r\n        MapGrid[x][y] \u003d new Tile(new Point(x * Constants.TILE_BORDER, y * Constants.TILE_BORDER));\r\n    }\r\n\r\n    /**\r\n     * Resets a tile to \"empty\" tile at specific coordinates\r\n     *\r\n     * @param x -\r\n     *            coordinates of horizontal tile\r\n     * @param y -\r\n     *            coordinates of vertical tile\r\n     */\r\n    public void resetTile(int x, int y) {\r\n        MapGrid[(int) Math.floor((double) x / Constants.TILE_BORDER)][(int) Math.floor((double) y / Constants.TILE_BORDER)] \u003d new Tile(new Point(x, y));\r\n    }\r\n\r\n    /**\r\n     * overwrite specific PowerUp at Index x, y\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     * @param tile -\r\n     *            PoweUp object\r\n     */\r\n    public void addPowerup(PowerUp powerup) {\r\n        powerup.setId(itemId++);\r\n        Powerups.addElement(powerup);\r\n    }\r\n\r\n    /**\r\n     * retrieves a Vector with all PowerUps\r\n     *\r\n     * @return\r\n     */\r\n    public Vector\u003cPowerUp\u003e getPowerups() {\r\n        return this.Powerups;\r\n    }\r\n\r\n    // Getters and Setter for map properties\r\n    /**\r\n     * sets a bunch of properties to map\r\n     *\r\n     * @param mapName -\r\n     *            Name of map\r\n     * @param mapVersion -\r\n     *            Version of map\r\n     * @param mapAuthor -\r\n     *            Name of author\r\n     * @param mapDate -\r\n     *            Date of map\r\n     * @param mapDifficulty -\r\n     *            Difficulty of map\r\n     * @param mapImageSet -\r\n     *            Default image set\r\n     * @param mapMaxPlayers -\r\n     *            Number of max players\r\n     * @param mapFilePath -\r\n     *            path to map xml file\r\n     */\r\n    public void setProperties(String mapName, String mapVersion, String mapAuthor, Date mapDate, int mapDifficulty, String mapImageSet, int mapMaxPlayers, String mapFilePath) {\r\n        this.name \u003d mapName;\r\n        this.version \u003d mapVersion;\r\n        this.author \u003d mapAuthor;\r\n        this.date \u003d mapDate;\r\n        this.difficulty \u003d mapDifficulty;\r\n        this.imageSet \u003d mapImageSet;\r\n        this.maxPlayers \u003d mapMaxPlayers;\r\n        this.filePath \u003d mapFilePath;\r\n    }\r\n\r\n    public String getImageSet() {\r\n        return imageSet;\r\n    }\r\n\r\n    public String getVersion() {\r\n        return version;\r\n    }\r\n\r\n    public String getAuthor() {\r\n        return author;\r\n    }\r\n\r\n    public Date getDate() {\r\n        return date;\r\n    }\r\n\r\n    public int getDifficulty() {\r\n        return difficulty;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public int getMaxPlayers() {\r\n        return maxPlayers;\r\n    }\r\n\r\n    public String getFilePath() {\r\n        return filePath;\r\n    }\r\n\r\n    /**\r\n     * sets measures of map\r\n     *\r\n     * @param x -\r\n     *            number of horizontal fields\r\n     * @param y -\r\n     *            number of vertical fields\r\n     */\r\n    public void setArea(int x, int y) {\r\n        Point area \u003d new Point();\r\n        area.x \u003d x;\r\n        area.y \u003d y;\r\n        this.area \u003d area;\r\n    }\r\n\r\n    /**\r\n     * retrieve measures of map, number of horizontal and vertical fields\r\n     *\r\n     * @return\r\n     */\r\n    public Point getArea() {\r\n        return this.area;\r\n    }\r\n\r\n    /**\r\n     * sets the start-point-position to map\r\n     *\r\n     * @param StPo -\r\n     *            array of start-point-positions\r\n     */\r\n    public void setStartPoints(Point[] StPo) {\r\n        this.StartPoint \u003d StPo;\r\n    }\r\n\r\n    /**\r\n     * gets array of start-point positions (not coordinates)\r\n     *\r\n     * @return\r\n     */\r\n    public Point[] getStartPoints() {\r\n        return this.StartPoint;\r\n    }\r\n\r\n    /**\r\n     * gets start-point-coordinates of player no. if not set, return coordinates\r\n     * of field 1/1\r\n     *\r\n     * @param playerNo -\r\n     *            number of player\r\n     * @return Point with coordinates\r\n     */\r\n    public Point getStartPoint(int playerNo) {\r\n        // startpoint for player is not set, default 1/1\r\n        if (playerNo \u003e StartPoint.length) {\r\n            return new Point(1 * Constants.TILE_BORDER + Constants.TILE_BORDER / 2, // field\r\n            1 * Constants.TILE_BORDER + Constants.TILE_BORDER / 2);\r\n            // 1/1\r\n        } else {\r\n            Point retPoint \u003d StartPoint[(playerNo - 1)];\r\n            retPoint.x \u003d retPoint.x * Constants.TILE_BORDER + 20;\r\n            retPoint.y \u003d retPoint.y * Constants.TILE_BORDER + 20;\r\n            return retPoint;\r\n        }\r\n    }\r\n\r\n    /*\r\n\t * (non-Javadoc)\r\n\t * \r\n\t * @see java.lang.Iterable#iterator()\r\n\t */\r\n    @Override\r\n    public Iterator\u003cTile\u003e iterator() {\r\n        return new Iterator\u003cTile\u003e() {\r\n\r\n            private int idx \u003d 0;\r\n\r\n            int width \u003d MapGrid.length;\r\n\r\n            int height \u003d MapGrid[0].length;\r\n\r\n            private int size \u003d width * height;\r\n\r\n            @Override\r\n            public boolean hasNext() {\r\n                return idx \u003c size;\r\n            }\r\n\r\n            @Override\r\n            public Tile next() {\r\n                if (!hasNext()) {\r\n                    throw new NoSuchElementException();\r\n                }\r\n                Tile tile \u003d (Tile) MapGrid[idx % width][idx / width];\r\n                idx++;\r\n                return tile;\r\n            }\r\n\r\n            @Override\r\n            public void remove() {\r\n                throw new UnsupportedOperationException();\r\n            }\r\n        };\r\n    }\r\n\r\n    /*\r\n\t * (non-Javadoc)\r\n\t * \r\n\t * @see java.lang.Iterable#iterator()\r\n\t */\r\n    /**\r\n     * iterator for PowerUp Objects in map\r\n     *\r\n     * @author christian\r\n     */\r\n    public class PowerUpIterator implements Iterable\u003cPowerUp\u003e, Serializable {\r\n\r\n        private static final long serialVersionUID \u003d 1L;\r\n\r\n        @Override\r\n        public Iterator\u003cPowerUp\u003e iterator() {\r\n            return Powerups.iterator();\r\n        }\r\n    }\r\n}\r\n",
    "package": "common",
    "classname": "Map",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/Map_1Test.java",
    "test_prompt": "// Map_1Test.java\npackage common;\n\nimport java.awt.Point;\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Map}.\n* It contains ten unit test cases for the {@link Map#getTile(int, int)} method.\n*/\nclass Map_1Test {",
    "method_signature": "getTile(int, int)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// Map.java\npackage common;\r\n\r\nimport java.awt.Point;\r\nimport java.io.Serializable;\r\nimport java.util.Date;\r\nimport java.util.Iterator;\r\nimport java.util.NoSuchElementException;\r\nimport java.util.Vector;\r\n\r\n/**\r\n * Map-Class with all information needed for map use of iterators tile-iterator:\r\n * for(Tile tile : map) - powerup-iterator: for(PowerUp powerup :\r\n * map.powerupiterator)\r\n *\r\n * @author christian\r\n */\r\npublic class Map implements Iterable\u003cTile\u003e, Serializable {\r\n\r\n    private static final long serialVersionUID \u003d 1L;\r\n\r\n    // flags if tiles, powerups and startpoints need to be read and set\r\n    private boolean settiles \u003d true;\r\n\r\n    private boolean setpowerups \u003d true;\r\n\r\n    private boolean setstartpoints \u003d true;\r\n\r\n    // 2 dimensional game board\r\n    private Object[][] MapGrid;\r\n\r\n    private Vector\u003cPowerUp\u003e Powerups \u003d new Vector\u003cPowerUp\u003e();\r\n\r\n    private Point[] StartPoint;\r\n\r\n    private Point area;\r\n\r\n    private String name;\r\n\r\n    private String imageSet;\r\n\r\n    private String version;\r\n\r\n    private String author;\r\n\r\n    private Date date;\r\n\r\n    private int difficulty;\r\n\r\n    private int maxPlayers;\r\n\r\n    private String filePath;\r\n\r\n    private int itemId \u003d 0;\r\n\r\n    // iterator for powerups\r\n    public Map.PowerUpIterator powerupiterator;\r\n\r\n    /**\r\n     * creates map-object with empty Tile objects\r\n     *\r\n     * @param xmlFile -\r\n     *            path to xml file\r\n     */\r\n    public Map(String xmlFile) {\r\n        mapInit(xmlFile);\r\n    }\r\n\r\n    /**\r\n     * creates map-object with or without Tile objects\r\n     *\r\n     * @param xmlFile -\r\n     *            path to xml file\r\n     * @param info -\r\n     *            Boolean (noTile) if tiles should be read (false) or not (true)\r\n     */\r\n    public Map(String xmlFile, boolean settiles, boolean setpowerups, boolean setstartpoints) {\r\n        this.settiles \u003d settiles;\r\n        this.setpowerups \u003d setpowerups;\r\n        this.setstartpoints \u003d setstartpoints;\r\n        mapInit(xmlFile);\r\n    }\r\n\r\n    /**\r\n     * initiate map and create MapReader Object\r\n     *\r\n     * @param xmlFile\r\n     */\r\n    private void mapInit(String xmlFile) {\r\n        // create Map-Reader an read xml into map\r\n        MapReader xml \u003d new MapReader(xmlFile);\r\n        // get map dimensions\r\n        area \u003d xml.getArea();\r\n        // MapXMLReader writes read properties to map-object\r\n        xml.setMapProperies(this);\r\n        // Tiles +++++++++++++++++++++++++++++++++++++++++++++++++++\r\n        // create map grid with \"empty\" objects if settiles is true\r\n        if (settiles) {\r\n            MapGrid \u003d new Object[area.x][area.y];\r\n            for (int i \u003d 0; i \u003c area.x; i++) {\r\n                for (int j \u003d 0; j \u003c area.y; j++) {\r\n                    Tile tile \u003d new Tile(new Point((area.x * Constants.TILE_BORDER), (area.y * Constants.TILE_BORDER)));\r\n                    MapGrid[i][j] \u003d tile;\r\n                }\r\n            }\r\n            // overwrite specific tiles from xml to map\r\n            xml.setTiles(this);\r\n            // sets tile to wall if type not set\r\n            for (Tile tile : this) {\r\n                if (tile.getType() \u003d\u003d null) {\r\n                    tile.setType(\"wall\");\r\n                }\r\n                tile.setId(itemId++);\r\n            }\r\n        }\r\n        // Powerups ++++++++++++++++++++++++++++++++++++++++++++++++\r\n        // create map grid with \"empty\" powerup objects if setpowerups is true\r\n        if (setpowerups) {\r\n            powerupiterator \u003d new PowerUpIterator();\r\n            // overwrite specific powerups from xml to map\r\n            xml.setPowerups(this);\r\n        }\r\n        // Starpoints ++++++++++++++++++++++++++++++++++++++++++++++++\r\n        // set start points to map\r\n        if (setstartpoints) {\r\n            xml.setStartPoints(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * overwrite specific MapTile at Index x, y\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     * @param tile -\r\n     *            MapTile object\r\n     */\r\n    public void setTileByIndex(int x, int y, Tile tile) {\r\n        MapGrid[x][y] \u003d tile;\r\n    }\r\n\r\n    /**\r\n     * return MapTile object at Index x, y\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     * @return MapTile object\r\n     */\r\n    public Tile getTileByIndex(int x, int y) {\r\n        return (Tile) MapGrid[x][y];\r\n    }\r\n\r\n    /**\r\n     * overwrite specific MapTile at Position x, y\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     * @param tile -\r\n     *            MapTile object\r\n     */\r\n    public void setTile(int x, int y, Tile tile) {\r\n        MapGrid[(int) Math.floor((double) x / Constants.TILE_BORDER)][(int) Math.floor((double) y / Constants.TILE_BORDER)] \u003d tile;\r\n    }\r\n\r\n    /**\r\n     * return MapTile object at Position x, y\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     * @return MapTile object\r\n     */\r\n    public Tile getTile(int x, int y) {\r\n        return (Tile) MapGrid[(int) Math.floor((double) x / Constants.TILE_BORDER)][(int) Math.floor((double) y / Constants.TILE_BORDER)];\r\n    }\r\n\r\n    /**\r\n     * Resets a tile to \"empty\" tile at specific position\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     */\r\n    public void resetTileByIndex(int x, int y) {\r\n        MapGrid[x][y] \u003d new Tile(new Point(x * Constants.TILE_BORDER, y * Constants.TILE_BORDER));\r\n    }\r\n\r\n    /**\r\n     * Resets a tile to \"empty\" tile at specific coordinates\r\n     *\r\n     * @param x -\r\n     *            coordinates of horizontal tile\r\n     * @param y -\r\n     *            coordinates of vertical tile\r\n     */\r\n    public void resetTile(int x, int y) {\r\n        MapGrid[(int) Math.floor((double) x / Constants.TILE_BORDER)][(int) Math.floor((double) y / Constants.TILE_BORDER)] \u003d new Tile(new Point(x, y));\r\n    }\r\n\r\n    /**\r\n     * overwrite specific PowerUp at Index x, y\r\n     *\r\n     * @param x -\r\n     *            number of horizontal tile\r\n     * @param y -\r\n     *            number of vertical tile\r\n     * @param tile -\r\n     *            PoweUp object\r\n     */\r\n    public void addPowerup(PowerUp powerup) {\r\n        powerup.setId(itemId++);\r\n        Powerups.addElement(powerup);\r\n    }\r\n\r\n    /**\r\n     * retrieves a Vector with all PowerUps\r\n     *\r\n     * @return\r\n     */\r\n    public Vector\u003cPowerUp\u003e getPowerups() {\r\n        return this.Powerups;\r\n    }\r\n\r\n    // Getters and Setter for map properties\r\n    /**\r\n     * sets a bunch of properties to map\r\n     *\r\n     * @param mapName -\r\n     *            Name of map\r\n     * @param mapVersion -\r\n     *            Version of map\r\n     * @param mapAuthor -\r\n     *            Name of author\r\n     * @param mapDate -\r\n     *            Date of map\r\n     * @param mapDifficulty -\r\n     *            Difficulty of map\r\n     * @param mapImageSet -\r\n     *            Default image set\r\n     * @param mapMaxPlayers -\r\n     *            Number of max players\r\n     * @param mapFilePath -\r\n     *            path to map xml file\r\n     */\r\n    public void setProperties(String mapName, String mapVersion, String mapAuthor, Date mapDate, int mapDifficulty, String mapImageSet, int mapMaxPlayers, String mapFilePath) {\r\n        this.name \u003d mapName;\r\n        this.version \u003d mapVersion;\r\n        this.author \u003d mapAuthor;\r\n        this.date \u003d mapDate;\r\n        this.difficulty \u003d mapDifficulty;\r\n        this.imageSet \u003d mapImageSet;\r\n        this.maxPlayers \u003d mapMaxPlayers;\r\n        this.filePath \u003d mapFilePath;\r\n    }\r\n\r\n    public String getImageSet() {\r\n        return imageSet;\r\n    }\r\n\r\n    public String getVersion() {\r\n        return version;\r\n    }\r\n\r\n    public String getAuthor() {\r\n        return author;\r\n    }\r\n\r\n    public Date getDate() {\r\n        return date;\r\n    }\r\n\r\n    public int getDifficulty() {\r\n        return difficulty;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public int getMaxPlayers() {\r\n        return maxPlayers;\r\n    }\r\n\r\n    public String getFilePath() {\r\n        return filePath;\r\n    }\r\n\r\n    /**\r\n     * sets measures of map\r\n     *\r\n     * @param x -\r\n     *            number of horizontal fields\r\n     * @param y -\r\n     *            number of vertical fields\r\n     */\r\n    public void setArea(int x, int y) {\r\n        Point area \u003d new Point();\r\n        area.x \u003d x;\r\n        area.y \u003d y;\r\n        this.area \u003d area;\r\n    }\r\n\r\n    /**\r\n     * retrieve measures of map, number of horizontal and vertical fields\r\n     *\r\n     * @return\r\n     */\r\n    public Point getArea() {\r\n        return this.area;\r\n    }\r\n\r\n    /**\r\n     * sets the start-point-position to map\r\n     *\r\n     * @param StPo -\r\n     *            array of start-point-positions\r\n     */\r\n    public void setStartPoints(Point[] StPo) {\r\n        this.StartPoint \u003d StPo;\r\n    }\r\n\r\n    /**\r\n     * gets array of start-point positions (not coordinates)\r\n     *\r\n     * @return\r\n     */\r\n    public Point[] getStartPoints() {\r\n        return this.StartPoint;\r\n    }\r\n\r\n    /**\r\n     * gets start-point-coordinates of player no. if not set, return coordinates\r\n     * of field 1/1\r\n     *\r\n     * @param playerNo -\r\n     *            number of player\r\n     * @return Point with coordinates\r\n     */\r\n    public Point getStartPoint(int playerNo) {\r\n        // startpoint for player is not set, default 1/1\r\n        if (playerNo \u003e StartPoint.length) {\r\n            return new Point(1 * Constants.TILE_BORDER + Constants.TILE_BORDER / 2, // field\r\n            1 * Constants.TILE_BORDER + Constants.TILE_BORDER / 2);\r\n            // 1/1\r\n        } else {\r\n            Point retPoint \u003d StartPoint[(playerNo - 1)];\r\n            retPoint.x \u003d retPoint.x * Constants.TILE_BORDER + 20;\r\n            retPoint.y \u003d retPoint.y * Constants.TILE_BORDER + 20;\r\n            return retPoint;\r\n        }\r\n    }\r\n\r\n    /*\r\n\t * (non-Javadoc)\r\n\t * \r\n\t * @see java.lang.Iterable#iterator()\r\n\t */\r\n    @Override\r\n    public Iterator\u003cTile\u003e iterator() {\r\n        return new Iterator\u003cTile\u003e() {\r\n\r\n            private int idx \u003d 0;\r\n\r\n            int width \u003d MapGrid.length;\r\n\r\n            int height \u003d MapGrid[0].length;\r\n\r\n            private int size \u003d width * height;\r\n\r\n            @Override\r\n            public boolean hasNext() {\r\n                return idx \u003c size;\r\n            }\r\n\r\n            @Override\r\n            public Tile next() {\r\n                if (!hasNext()) {\r\n                    throw new NoSuchElementException();\r\n                }\r\n                Tile tile \u003d (Tile) MapGrid[idx % width][idx / width];\r\n                idx++;\r\n                return tile;\r\n            }\r\n\r\n            @Override\r\n            public void remove() {\r\n                throw new UnsupportedOperationException();\r\n            }\r\n        };\r\n    }\r\n\r\n    /*\r\n\t * (non-Javadoc)\r\n\t * \r\n\t * @see java.lang.Iterable#iterator()\r\n\t */\r\n    /**\r\n     * iterator for PowerUp Objects in map\r\n     *\r\n     * @author christian\r\n     */\r\n    public class PowerUpIterator implements Iterable\u003cPowerUp\u003e, Serializable {\r\n\r\n        private static final long serialVersionUID \u003d 1L;\r\n\r\n        @Override\r\n        public Iterator\u003cPowerUp\u003e iterator() {\r\n            return Powerups.iterator();\r\n        }\r\n    }\r\n}\r\n",
    "package": "common",
    "classname": "Map",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/Map_2Test.java",
    "test_prompt": "// Map_2Test.java\npackage common;\n\nimport java.awt.Point;\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Vector;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Map}.\n* It contains ten unit test cases for the {@link Map#getStartPoint(int)} method.\n*/\nclass Map_2Test {",
    "method_signature": "getStartPoint(int)",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// ResourceService.java\n/**\r\n */\r\npackage common;\r\n\r\nimport java.awt.Image;\r\nimport java.awt.image.BufferedImage;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport javax.imageio.ImageIO;\r\nimport javax.swing.ImageIcon;\r\n\r\n/**\r\n * This is an utility class that offers functionality to load resources that are\r\n * located in the classpath. This is used to load resources like images and sound files\r\n * from the client jar file.\r\n *\r\n * @author andi\r\n */\r\npublic class ResourceService {\r\n\r\n    /**\r\n     * Loads the {@link Image} that is located at the specified path.\r\n     * @param path The location of the image within the classpath.\r\n     * @return The loaded {@link Image} or null if there was an IOException while trying\r\n     * to read the image from a stream.\r\n     */\r\n    public static Image getImage(String path) {\r\n        BufferedImage image;\r\n        try {\r\n            image \u003d ImageIO.read(getInputStream(path));\r\n        } catch (IOException e) {\r\n            image \u003d null;\r\n        }\r\n        return image;\r\n    }\r\n\r\n    /**\r\n     * Loads the {@link ImageIcon} that is located at the specified path.\r\n     * @param path The location of the image within the classpath.\r\n     * @return The loaded {@link ImageIcon}\r\n     */\r\n    public static ImageIcon getImageIcon(String path) {\r\n        return new ImageIcon(getImage(path));\r\n    }\r\n\r\n    /**\r\n     * Creates a connection to the resource that is located at the specified\r\n     * path via an {@link InputStream}.\r\n     * @param path The location of the resource within the classpath.\r\n     * @return The {@link InputStream} that points the requested resource.\r\n     */\r\n    public static InputStream getInputStream(String path) {\r\n        InputStream resourceAsStream \u003d ResourceService.class.getResourceAsStream(path);\r\n        if (resourceAsStream \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"No such resource: \" + path);\r\n        }\r\n        return resourceAsStream;\r\n    }\r\n}\r\n",
    "package": "common",
    "classname": "ResourceService",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/ResourceService_0Test.java",
    "test_prompt": "// ResourceService_0Test.java\npackage common;\n\nimport java.awt.Image;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport javax.imageio.ImageIO;\nimport javax.swing.ImageIcon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ResourceService}.\n* It contains ten unit test cases for the {@link ResourceService#getImage(String)} method.\n*/\nclass ResourceService_0Test {",
    "method_signature": "getImage(String)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// ResourceService.java\n/**\r\n */\r\npackage common;\r\n\r\nimport java.awt.Image;\r\nimport java.awt.image.BufferedImage;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport javax.imageio.ImageIO;\r\nimport javax.swing.ImageIcon;\r\n\r\n/**\r\n * This is an utility class that offers functionality to load resources that are\r\n * located in the classpath. This is used to load resources like images and sound files\r\n * from the client jar file.\r\n *\r\n * @author andi\r\n */\r\npublic class ResourceService {\r\n\r\n    /**\r\n     * Loads the {@link Image} that is located at the specified path.\r\n     * @param path The location of the image within the classpath.\r\n     * @return The loaded {@link Image} or null if there was an IOException while trying\r\n     * to read the image from a stream.\r\n     */\r\n    public static Image getImage(String path) {\r\n        BufferedImage image;\r\n        try {\r\n            image \u003d ImageIO.read(getInputStream(path));\r\n        } catch (IOException e) {\r\n            image \u003d null;\r\n        }\r\n        return image;\r\n    }\r\n\r\n    /**\r\n     * Loads the {@link ImageIcon} that is located at the specified path.\r\n     * @param path The location of the image within the classpath.\r\n     * @return The loaded {@link ImageIcon}\r\n     */\r\n    public static ImageIcon getImageIcon(String path) {\r\n        return new ImageIcon(getImage(path));\r\n    }\r\n\r\n    /**\r\n     * Creates a connection to the resource that is located at the specified\r\n     * path via an {@link InputStream}.\r\n     * @param path The location of the resource within the classpath.\r\n     * @return The {@link InputStream} that points the requested resource.\r\n     */\r\n    public static InputStream getInputStream(String path) {\r\n        InputStream resourceAsStream \u003d ResourceService.class.getResourceAsStream(path);\r\n        if (resourceAsStream \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"No such resource: \" + path);\r\n        }\r\n        return resourceAsStream;\r\n    }\r\n}\r\n",
    "package": "common",
    "classname": "ResourceService",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/ResourceService_1Test.java",
    "test_prompt": "// ResourceService_1Test.java\npackage common;\n\nimport java.awt.Image;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport javax.imageio.ImageIO;\nimport javax.swing.ImageIcon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ResourceService}.\n* It contains ten unit test cases for the {@link ResourceService#getImageIcon(String)} method.\n*/\nclass ResourceService_1Test {",
    "method_signature": "getImageIcon(String)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// ResourceService.java\n/**\r\n */\r\npackage common;\r\n\r\nimport java.awt.Image;\r\nimport java.awt.image.BufferedImage;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport javax.imageio.ImageIO;\r\nimport javax.swing.ImageIcon;\r\n\r\n/**\r\n * This is an utility class that offers functionality to load resources that are\r\n * located in the classpath. This is used to load resources like images and sound files\r\n * from the client jar file.\r\n *\r\n * @author andi\r\n */\r\npublic class ResourceService {\r\n\r\n    /**\r\n     * Loads the {@link Image} that is located at the specified path.\r\n     * @param path The location of the image within the classpath.\r\n     * @return The loaded {@link Image} or null if there was an IOException while trying\r\n     * to read the image from a stream.\r\n     */\r\n    public static Image getImage(String path) {\r\n        BufferedImage image;\r\n        try {\r\n            image \u003d ImageIO.read(getInputStream(path));\r\n        } catch (IOException e) {\r\n            image \u003d null;\r\n        }\r\n        return image;\r\n    }\r\n\r\n    /**\r\n     * Loads the {@link ImageIcon} that is located at the specified path.\r\n     * @param path The location of the image within the classpath.\r\n     * @return The loaded {@link ImageIcon}\r\n     */\r\n    public static ImageIcon getImageIcon(String path) {\r\n        return new ImageIcon(getImage(path));\r\n    }\r\n\r\n    /**\r\n     * Creates a connection to the resource that is located at the specified\r\n     * path via an {@link InputStream}.\r\n     * @param path The location of the resource within the classpath.\r\n     * @return The {@link InputStream} that points the requested resource.\r\n     */\r\n    public static InputStream getInputStream(String path) {\r\n        InputStream resourceAsStream \u003d ResourceService.class.getResourceAsStream(path);\r\n        if (resourceAsStream \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"No such resource: \" + path);\r\n        }\r\n        return resourceAsStream;\r\n    }\r\n}\r\n",
    "package": "common",
    "classname": "ResourceService",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/ResourceService_2Test.java",
    "test_prompt": "// ResourceService_2Test.java\npackage common;\n\nimport java.awt.Image;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport javax.imageio.ImageIO;\nimport javax.swing.ImageIcon;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ResourceService}.\n* It contains ten unit test cases for the {@link ResourceService#getInputStream(String)} method.\n*/\nclass ResourceService_2Test {",
    "method_signature": "getInputStream(String)",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// MapPreview.java\npackage common;\r\n\r\nimport java.awt.Color;\r\nimport java.awt.Graphics;\r\nimport java.awt.Image;\r\nimport java.awt.Point;\r\nimport java.awt.geom.AffineTransform;\r\nimport java.awt.image.AffineTransformOp;\r\nimport java.awt.image.BufferedImage;\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.util.Vector;\r\nimport javax.imageio.ImageIO;\r\nimport javax.swing.ImageIcon;\r\nimport org.apache.log4j.Logger;\r\n\r\n/**\r\n * create a ImageIcon Map Preview of a map object\r\n *\r\n * usage example: MapPreview mp \u003d new MapPreview(map); mp.setImageSet(\"desert\");\r\n * (optional) ImageIcon ii \u003d mp.getMapPreview(150); !!\r\n *\r\n * @author christian\r\n */\r\npublic class MapPreview {\r\n\r\n    private String mapImageSet;\r\n\r\n    private Point mapArea;\r\n\r\n    private ImageIcon mapPreviewIcon;\r\n\r\n    private BufferedImage mapPreview;\r\n\r\n    private Map mapMap;\r\n\r\n    private String mapFile;\r\n\r\n    // map tile Images, for caching purposes\r\n    private static Image TILE_WALL_IMAGE;\r\n\r\n    private static Image TILE_STONE_IMAGE;\r\n\r\n    private static final Logger logger \u003d Logger.getLogger(MapPreview.class);\r\n\r\n    /**\r\n     * class for creating map Preview of Map map\r\n     *\r\n     * @param map -\r\n     *            map for which preview should be created\r\n     */\r\n    public MapPreview(Map map) {\r\n        mapMap \u003d map;\r\n        mapImageSet \u003d map.getImageSet();\r\n        mapArea \u003d map.getArea();\r\n        mapFile \u003d map.getFilePath();\r\n    }\r\n\r\n    /**\r\n     * set imageSet, overrides default map imageSet\r\n     *\r\n     * @param imageSet -\r\n     *            String, imageSet (-folder)\r\n     */\r\n    public void setImageSet(String imageSet) {\r\n        this.mapImageSet \u003d imageSet;\r\n    }\r\n\r\n    /**\r\n     * returns preview of current map\r\n     *\r\n     * @param previewWidth -\r\n     *            Width of preview. Proportions are constrained\r\n     * @return BufferedImage with map preview\r\n     */\r\n    public ImageIcon getMapPreview(int previewWidth) {\r\n        // check if file is available, file name is identical to\r\n        // xml file with appended .png\r\n        File checkFile \u003d new File(mapFile + \"_\" + mapImageSet + \".png\");\r\n        if (checkFile.exists()) {\r\n            logger.info(\"Loading map preview: \" + checkFile.getName());\r\n            BufferedImage mapPreview;\r\n            try {\r\n                mapPreview \u003d ImageIO.read(new File(mapFile + \"_\" + mapImageSet + \".png\"));\r\n                mapPreviewIcon \u003d new ImageIcon();\r\n                mapPreviewIcon.setImage((Image) mapPreview);\r\n            } catch (IOException e) {\r\n                logger.error(e);\r\n            }\r\n        } else {\r\n            // image not found, create it\r\n            logger.info(\"Creating map preview: \" + checkFile.getName());\r\n            // preload images\r\n            TILE_WALL_IMAGE \u003d LoadImage(\"wall\");\r\n            TILE_STONE_IMAGE \u003d LoadImage(\"stone\");\r\n            mapPreviewIcon \u003d new ImageIcon();\r\n            mapPreview \u003d new BufferedImage(mapArea.x * Constants.TILE_BORDER, mapArea.y * Constants.TILE_BORDER, BufferedImage.TYPE_INT_RGB);\r\n            // draw map to BufferedImage\r\n            drawMap();\r\n            try {\r\n                ImageIO.write(scale(mapPreview, previewWidth), \"png\", checkFile);\r\n            } catch (Exception e) {\r\n                logger.error(\"Caught in getMapPreview(): \" + e);\r\n            }\r\n            // return / resize and return\r\n            if (previewWidth \u003d\u003d (mapArea.x * Constants.TILE_BORDER)) {\r\n                mapPreviewIcon.setImage((Image) mapPreview);\r\n            } else {\r\n                mapPreviewIcon.setImage((Image) scale(mapPreview, previewWidth));\r\n            }\r\n        }\r\n        return mapPreviewIcon;\r\n    }\r\n\r\n    /**\r\n     * draws all map tiles to Graphics object\r\n     */\r\n    private void drawMap() {\r\n        logger.info(\"draw mapPreview...\");\r\n        Graphics g \u003d mapPreview.getGraphics();\r\n        g.setColor(Color.white);\r\n        g.fillRect(0, 0, 800, 600);\r\n        for (Tile tile : mapMap) {\r\n            drawTile(g, tile.getPosition(), tile.getType(), true);\r\n        }\r\n        g.dispose();\r\n    }\r\n\r\n    /**\r\n     * method for scaling/resizing BufferedImages to target width\r\n     *\r\n     * @param bi -\r\n     *            BufferedImage\r\n     * @param targetWidth -\r\n     *            target width of resized image\r\n     * @return BufferedImage - with map preview\r\n     */\r\n    private BufferedImage scale(BufferedImage bi, int targetWidth) {\r\n        // calculate scale-factor\r\n        double scaleFactor \u003d (double) targetWidth / (double) bi.getWidth();\r\n        logger.info(\"resize map preview to width: \" + targetWidth);\r\n        AffineTransform tx \u003d new AffineTransform();\r\n        tx.scale(scaleFactor, scaleFactor);\r\n        AffineTransformOp op \u003d new AffineTransformOp(tx, AffineTransformOp.TYPE_NEAREST_NEIGHBOR);\r\n        return op.filter(bi, null);\r\n    }\r\n\r\n    /**\r\n     * loads an image-file into an Image object\r\n     *\r\n     * @param fileName -\r\n     *            String, name of file, w/o path and ending\r\n     * @return Image\r\n     */\r\n    public Image LoadImage(String fileName) {\r\n        Image image \u003d null;\r\n        try {\r\n            image \u003d ImageIO.read(new File(\"resources/gfx/map/\" + mapImageSet + \"/\" + fileName + \".png\"));\r\n        } catch (IOException e) {\r\n            logger.error(e.toString());\r\n        }\r\n        return image;\r\n    }\r\n\r\n    /**\r\n     * draws tile at specific position\r\n     *\r\n     * @param g2d -\r\n     *            Graphics2D object\r\n     * @param position -\r\n     *            Point, coordinates\r\n     * @param fileName -\r\n     *            String, name of file, w/o path and ending\r\n     * @param middle -\r\n     *            is the position of element set to middle, correct the upper\r\n     *            left coordinate\r\n     */\r\n    public void drawTile(Graphics g, Point position, String fileName, Boolean middle) {\r\n        Image image;\r\n        int posCorrection \u003d 0;\r\n        if (middle) {\r\n            posCorrection \u003d Constants.TILE_BORDER / 2;\r\n        }\r\n        // use cached image or load image\r\n        if (fileName.equals(\"wall\")) {\r\n            image \u003d TILE_WALL_IMAGE;\r\n        } else if (fileName.equals(\"stone\")) {\r\n            image \u003d TILE_STONE_IMAGE;\r\n        } else {\r\n            image \u003d LoadImage(fileName);\r\n        }\r\n        g.drawImage(image, position.x - posCorrection, position.y - posCorrection, null);\r\n    }\r\n}\r\n",
    "package": "common",
    "classname": "MapPreview",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/MapPreview_0Test.java",
    "test_prompt": "// MapPreview_0Test.java\npackage common;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Image;\nimport java.awt.Point;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.AffineTransformOp;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Vector;\nimport javax.imageio.ImageIO;\nimport javax.swing.ImageIcon;\nimport org.apache.log4j.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MapPreview}.\n* It contains ten unit test cases for the {@link MapPreview#getMapPreview(int)} method.\n*/\nclass MapPreview_0Test {",
    "method_signature": "getMapPreview(int)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// XmlFunctions.java\npackage common;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport javax.xml.parsers.DocumentBuilder;\r\nimport javax.xml.parsers.DocumentBuilderFactory;\r\nimport javax.xml.parsers.ParserConfigurationException;\r\nimport javax.xml.transform.Result;\r\nimport javax.xml.transform.Source;\r\nimport javax.xml.transform.Transformer;\r\nimport javax.xml.transform.TransformerConfigurationException;\r\nimport javax.xml.transform.TransformerException;\r\nimport javax.xml.transform.TransformerFactory;\r\nimport javax.xml.transform.dom.DOMSource;\r\nimport javax.xml.transform.stream.StreamResult;\r\nimport javax.xml.xpath.XPath;\r\nimport javax.xml.xpath.XPathConstants;\r\nimport javax.xml.xpath.XPathExpression;\r\nimport javax.xml.xpath.XPathExpressionException;\r\nimport javax.xml.xpath.XPathFactory;\r\nimport org.apache.log4j.Logger;\r\nimport org.w3c.dom.Document;\r\nimport org.w3c.dom.Node;\r\nimport org.w3c.dom.NodeList;\r\nimport org.xml.sax.SAXException;\r\n\r\n/**\r\n * basic functions for reading and writing xml files\r\n *\r\n * @author christian\r\n */\r\npublic class XmlFunctions {\r\n\r\n    private static final Logger logger \u003d Logger.getLogger(XmlFunctions.class);\r\n\r\n    Document xml;\r\n\r\n    String fileName;\r\n\r\n    /**\r\n     * constructor\r\n     *\r\n     * @param XmlFileName -\r\n     *            path to xml file\r\n     */\r\n    public XmlFunctions(String XmlFileName) {\r\n        this.fileName \u003d XmlFileName;\r\n        openXmlFile(fileName);\r\n    }\r\n\r\n    /**\r\n     * sets value to specific xml node and saves the xml file\r\n     *\r\n     * @param element -\r\n     *            name of xml element\r\n     * @param value -\r\n     *            String, value to be set\r\n     */\r\n    public void setXmlValue(String xmlPath, String value) {\r\n        Node node \u003d findXmlNode(xmlPath);\r\n        node.setTextContent(value);\r\n        // (re)write xml file\r\n        writeXmlFile();\r\n    }\r\n\r\n    /**\r\n     * returns value of specific xml element\r\n     *\r\n     * @param XmlPath -\r\n     *            element path (XPath)\r\n     * @return String with value of element\r\n     */\r\n    public String getXmlValue(String XmlPath) {\r\n        Node node \u003d findXmlNode(XmlPath);\r\n        return node.getTextContent();\r\n    }\r\n\r\n    /**\r\n     * reads a xml file into a Document object\r\n     *\r\n     * @param fileName -\r\n     *            path to xml file\r\n     */\r\n    private void openXmlFile(String fileName) {\r\n        try {\r\n            DocumentBuilder builder \u003d DocumentBuilderFactory.newInstance().newDocumentBuilder();\r\n            xml \u003d builder.parse(new File(fileName));\r\n        } catch (SAXException ex) {\r\n            logger.error(ex);\r\n        } catch (IOException ex) {\r\n            logger.error(ex);\r\n        } catch (ParserConfigurationException ex) {\r\n            logger.error(ex);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * finds a xml node in the Document object and returns it\r\n     *\r\n     * @param XmlPath -\r\n     *            element path (XPath)\r\n     * @return Node - found node\r\n     */\r\n    private Node findXmlNode(String XmlPath) {\r\n        Node node \u003d null;\r\n        try {\r\n            XPath xpath \u003d XPathFactory.newInstance().newXPath();\r\n            XPathExpression expr \u003d xpath.compile(XmlPath);\r\n            Object result \u003d expr.evaluate(xml, XPathConstants.NODE);\r\n            node \u003d (Node) result;\r\n            if (node \u003d\u003d null) {\r\n                logger.error(\"Node: \" + XmlPath + \" nicht gefunden.\");\r\n            }\r\n        } catch (XPathExpressionException ex) {\r\n            logger.error(ex);\r\n        }\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * returns a list of nodes matching to the element name\r\n     *\r\n     * @param NodeName -\r\n     *            name of element(s)\r\n     * @return NodeList with found nodes\r\n     */\r\n    public NodeList findXmlNodes(String NodeName) {\r\n        try {\r\n            XPath xpath \u003d XPathFactory.newInstance().newXPath();\r\n            XPathExpression expr \u003d xpath.compile(NodeName);\r\n            Object result \u003d expr.evaluate(xml, XPathConstants.NODESET);\r\n            return (NodeList) result;\r\n        } catch (XPathExpressionException ex) {\r\n            logger.error(ex);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * writes global Document object xml (back) into xml file\r\n     */\r\n    private void writeXmlFile() {\r\n        try {\r\n            // Prepare the DOM document for writing\r\n            Source source \u003d new DOMSource(xml);\r\n            // Prepare the output file\r\n            File xmlFile \u003d new File(fileName);\r\n            Result result \u003d new StreamResult(xmlFile);\r\n            // Write the DOM document to the file\r\n            Transformer xformer \u003d TransformerFactory.newInstance().newTransformer();\r\n            xformer.transform(source, result);\r\n        } catch (TransformerConfigurationException e) {\r\n            logger.error(e);\r\n        } catch (TransformerException e) {\r\n            logger.error(e);\r\n        }\r\n    }\r\n}\r\n",
    "package": "common",
    "classname": "XmlFunctions",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/XmlFunctions_0Test.java",
    "test_prompt": "// XmlFunctions_0Test.java\npackage common;\n\nimport java.io.File;\nimport java.io.IOException;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport org.apache.log4j.Logger;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XmlFunctions}.\n* It contains ten unit test cases for the {@link XmlFunctions#getXmlValue(String)} method.\n*/\nclass XmlFunctions_0Test {",
    "method_signature": "getXmlValue(String)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// XmlFunctions.java\npackage common;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport javax.xml.parsers.DocumentBuilder;\r\nimport javax.xml.parsers.DocumentBuilderFactory;\r\nimport javax.xml.parsers.ParserConfigurationException;\r\nimport javax.xml.transform.Result;\r\nimport javax.xml.transform.Source;\r\nimport javax.xml.transform.Transformer;\r\nimport javax.xml.transform.TransformerConfigurationException;\r\nimport javax.xml.transform.TransformerException;\r\nimport javax.xml.transform.TransformerFactory;\r\nimport javax.xml.transform.dom.DOMSource;\r\nimport javax.xml.transform.stream.StreamResult;\r\nimport javax.xml.xpath.XPath;\r\nimport javax.xml.xpath.XPathConstants;\r\nimport javax.xml.xpath.XPathExpression;\r\nimport javax.xml.xpath.XPathExpressionException;\r\nimport javax.xml.xpath.XPathFactory;\r\nimport org.apache.log4j.Logger;\r\nimport org.w3c.dom.Document;\r\nimport org.w3c.dom.Node;\r\nimport org.w3c.dom.NodeList;\r\nimport org.xml.sax.SAXException;\r\n\r\n/**\r\n * basic functions for reading and writing xml files\r\n *\r\n * @author christian\r\n */\r\npublic class XmlFunctions {\r\n\r\n    private static final Logger logger \u003d Logger.getLogger(XmlFunctions.class);\r\n\r\n    Document xml;\r\n\r\n    String fileName;\r\n\r\n    /**\r\n     * constructor\r\n     *\r\n     * @param XmlFileName -\r\n     *            path to xml file\r\n     */\r\n    public XmlFunctions(String XmlFileName) {\r\n        this.fileName \u003d XmlFileName;\r\n        openXmlFile(fileName);\r\n    }\r\n\r\n    /**\r\n     * sets value to specific xml node and saves the xml file\r\n     *\r\n     * @param element -\r\n     *            name of xml element\r\n     * @param value -\r\n     *            String, value to be set\r\n     */\r\n    public void setXmlValue(String xmlPath, String value) {\r\n        Node node \u003d findXmlNode(xmlPath);\r\n        node.setTextContent(value);\r\n        // (re)write xml file\r\n        writeXmlFile();\r\n    }\r\n\r\n    /**\r\n     * returns value of specific xml element\r\n     *\r\n     * @param XmlPath -\r\n     *            element path (XPath)\r\n     * @return String with value of element\r\n     */\r\n    public String getXmlValue(String XmlPath) {\r\n        Node node \u003d findXmlNode(XmlPath);\r\n        return node.getTextContent();\r\n    }\r\n\r\n    /**\r\n     * reads a xml file into a Document object\r\n     *\r\n     * @param fileName -\r\n     *            path to xml file\r\n     */\r\n    private void openXmlFile(String fileName) {\r\n        try {\r\n            DocumentBuilder builder \u003d DocumentBuilderFactory.newInstance().newDocumentBuilder();\r\n            xml \u003d builder.parse(new File(fileName));\r\n        } catch (SAXException ex) {\r\n            logger.error(ex);\r\n        } catch (IOException ex) {\r\n            logger.error(ex);\r\n        } catch (ParserConfigurationException ex) {\r\n            logger.error(ex);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * finds a xml node in the Document object and returns it\r\n     *\r\n     * @param XmlPath -\r\n     *            element path (XPath)\r\n     * @return Node - found node\r\n     */\r\n    private Node findXmlNode(String XmlPath) {\r\n        Node node \u003d null;\r\n        try {\r\n            XPath xpath \u003d XPathFactory.newInstance().newXPath();\r\n            XPathExpression expr \u003d xpath.compile(XmlPath);\r\n            Object result \u003d expr.evaluate(xml, XPathConstants.NODE);\r\n            node \u003d (Node) result;\r\n            if (node \u003d\u003d null) {\r\n                logger.error(\"Node: \" + XmlPath + \" nicht gefunden.\");\r\n            }\r\n        } catch (XPathExpressionException ex) {\r\n            logger.error(ex);\r\n        }\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * returns a list of nodes matching to the element name\r\n     *\r\n     * @param NodeName -\r\n     *            name of element(s)\r\n     * @return NodeList with found nodes\r\n     */\r\n    public NodeList findXmlNodes(String NodeName) {\r\n        try {\r\n            XPath xpath \u003d XPathFactory.newInstance().newXPath();\r\n            XPathExpression expr \u003d xpath.compile(NodeName);\r\n            Object result \u003d expr.evaluate(xml, XPathConstants.NODESET);\r\n            return (NodeList) result;\r\n        } catch (XPathExpressionException ex) {\r\n            logger.error(ex);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * writes global Document object xml (back) into xml file\r\n     */\r\n    private void writeXmlFile() {\r\n        try {\r\n            // Prepare the DOM document for writing\r\n            Source source \u003d new DOMSource(xml);\r\n            // Prepare the output file\r\n            File xmlFile \u003d new File(fileName);\r\n            Result result \u003d new StreamResult(xmlFile);\r\n            // Write the DOM document to the file\r\n            Transformer xformer \u003d TransformerFactory.newInstance().newTransformer();\r\n            xformer.transform(source, result);\r\n        } catch (TransformerConfigurationException e) {\r\n            logger.error(e);\r\n        } catch (TransformerException e) {\r\n            logger.error(e);\r\n        }\r\n    }\r\n}\r\n",
    "package": "common",
    "classname": "XmlFunctions",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/XmlFunctions_1Test.java",
    "test_prompt": "// XmlFunctions_1Test.java\npackage common;\n\nimport java.io.File;\nimport java.io.IOException;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport org.apache.log4j.Logger;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XmlFunctions}.\n* It contains ten unit test cases for the {@link XmlFunctions#findXmlNodes(String)} method.\n*/\nclass XmlFunctions_1Test {",
    "method_signature": "findXmlNodes(String)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// MapReader.java\npackage common;\n\nimport org.apache.log4j.Logger;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport java.awt.Point;\nimport javax.xml.xpath.*;\nimport java.util.Date;\n\n/**\n * Loads a XML-file and write read properties, tiles and start points to\n * map-object\n *\n * @author christian\n */\npublic class MapReader {\n\n    private XmlFunctions xmlFunctions;\n\n    private String mapFilePath;\n\n    private static final Logger logger \u003d Logger.getLogger(MapReader.class);\n\n    /**\n     * constructor\n     *\n     * @param mapFile -\n     *            Path to XML-file with map information\n     */\n    public MapReader(String mapFile) {\n        this.mapFilePath \u003d mapFile;\n        xmlFunctions \u003d new XmlFunctions(mapFile);\n    }\n\n    /**\n     * Returns a specific value in a group of nodes using XPath expressions\n     *\n     * @param node -\n     *            node(set) in which value should be searched\n     * @param XMLPath -\n     *            XPath expression\n     * @return String - found value\n     */\n    public String getXMLValue(Node node, String XMLPath) {\n        try {\n            // todo: exception wenn feld leer\n            XPath xpath \u003d XPathFactory.newInstance().newXPath();\n            XPathExpression expr \u003d xpath.compile(XMLPath);\n            Object result \u003d expr.evaluate(node, XPathConstants.NODE);\n            Node foundNode \u003d (Node) result;\n            return foundNode.getNodeValue();\n        } catch (XPathExpressionException ex) {\n            logger.error(ex);\n        }\n        return new String();\n    }\n\n    /**\n     * Sets read properties to map-object using the setter-methods of map-object\n     *\n     * @param map -\n     *            Map object\n     */\n    public void setMapProperies(Map map) {\n        map.setArea(Integer.parseInt(xmlFunctions.getXmlValue(\"/map/area/x/text()\")), Integer.parseInt(xmlFunctions.getXmlValue(\"/map/area/y/text()\")));\n        map.setProperties(xmlFunctions.getXmlValue(\"/map/name/text()\"), xmlFunctions.getXmlValue(\"/map/version/text()\"), xmlFunctions.getXmlValue(\"/map/author/text()\"), new Date(), Integer.parseInt(xmlFunctions.getXmlValue(\"/map/difficulty/text()\")), xmlFunctions.getXmlValue(\"/map/imageset/text()\"), Integer.parseInt(xmlFunctions.getXmlValue(\"/map/maxplayers/text()\")), this.mapFilePath);\n    }\n\n    /**\n     * sets the specific tiles to map object\n     *\n     * @param map\n     */\n    public void setTiles(Map map) {\n        logger.info(\"Setting map tiles...\");\n        // retrieve List of field-nodes\n        int MapX \u003d 0, MapY \u003d 0;\n        String Type \u003d new String();\n        Boolean accessible \u003d false, bombable \u003d false;\n        Tile tile;\n        Node childNode;\n        NodeList nodes \u003d xmlFunctions.findXmlNodes(\"//fields/field\");\n        // read and create tiles\n        for (int i \u003d 0; i \u003c nodes.getLength(); i++) {\n            // run through all child nodes to collect information\n            for (childNode \u003d nodes.item(i).getFirstChild(); childNode !\u003d null; childNode \u003d childNode.getNextSibling()) {\n                if (childNode.getNodeName().equals(\"x\")) {\n                    MapX \u003d Integer.parseInt(childNode.getTextContent());\n                } else if (childNode.getNodeName().equals(\"y\")) {\n                    MapY \u003d Integer.parseInt(childNode.getTextContent());\n                } else if (childNode.getNodeName().equals(\"type\")) {\n                    Type \u003d childNode.getTextContent();\n                } else if (childNode.getNodeName().equals(\"accessible\")) {\n                    accessible \u003d Boolean.valueOf(childNode.getTextContent());\n                } else if (childNode.getNodeName().equals(\"bombable\")) {\n                    bombable \u003d Boolean.valueOf(childNode.getTextContent());\n                } else {\n                    // irrelevant entry\n                    continue;\n                }\n            }\n            tile \u003d new Tile(new Point(MapX * Constants.TILE_BORDER + Constants.TILE_BORDER / 2, MapY * Constants.TILE_BORDER + Constants.TILE_BORDER / 2));\n            tile.setProperties(Type, accessible, bombable);\n            // assign tile to MapGrid, by position/index\n            map.setTileByIndex(MapX, MapY, tile);\n            // autoWall, if flag \u003d 1 and position 0/0\n            if (MapX \u003d\u003d 0 \u0026\u0026 MapY \u003d\u003d 0 \u0026\u0026 Integer.parseInt(xmlFunctions.getXmlValue(\"/map/autowall/text()\")) \u003d\u003d 1) {\n                logger.info(\"Autowall ausf�hren...\");\n                autoWall(map, getXMLValue((Node) nodes.item(i), \"type/text()\"));\n            }\n        }\n    }\n\n    public void setPowerups(Map map) {\n        logger.info(\"Setting powerups...\");\n        // retrieve List of powerup-nodes\n        PowerUp powerup;\n        String Type \u003d new String();\n        int MapX \u003d 0, MapY \u003d 0;\n        Node childNode;\n        NodeList nodes \u003d xmlFunctions.findXmlNodes(\"//powerups/powerup\");\n        // read and create tiles\n        for (int i \u003d 0; i \u003c nodes.getLength(); i++) {\n            // run through all child nodes to collect information\n            for (childNode \u003d nodes.item(i).getFirstChild(); childNode !\u003d null; childNode \u003d childNode.getNextSibling()) {\n                if (childNode.getNodeName().equals(\"x\")) {\n                    MapX \u003d Integer.parseInt(childNode.getTextContent());\n                } else if (childNode.getNodeName().equals(\"y\")) {\n                    MapY \u003d Integer.parseInt(childNode.getTextContent());\n                } else if (childNode.getNodeName().equals(\"type\")) {\n                    Type \u003d childNode.getTextContent();\n                } else {\n                    // irrelevant entry\n                    continue;\n                }\n            }\n            powerup \u003d new PowerUp(new Point(MapX * Constants.TILE_BORDER + Constants.TILE_BORDER / 2, MapY * Constants.TILE_BORDER + Constants.TILE_BORDER / 2));\n            powerup.setType(Type);\n            // assign powerup to MapGrid, by position/index\n            map.addPowerup(powerup);\n        }\n    }\n\n    /**\n     * automatically sets wall on the border of map set\n     *\n     * @param map\n     */\n    public void autoWall(Map map, String Type) {\n        Tile tile;\n        Point size \u003d map.getArea();\n        for (int k \u003d 0; k \u003c size.x; k++) {\n            for (int j \u003d 0; j \u003c size.y; j++) {\n                if (k \u003d\u003d 0 || k \u003d\u003d (size.x - 1) || j \u003d\u003d 0 || j \u003d\u003d (size.y - 1)) {\n                    tile \u003d new Tile(new Point(k * Constants.TILE_BORDER + Constants.TILE_BORDER / 2, j * Constants.TILE_BORDER + Constants.TILE_BORDER / 2));\n                    tile.setType(Type);\n                    tile.setAccessible(false);\n                    tile.setBombable(false);\n                    map.setTileByIndex(k, j, tile);\n                } else {\n                    continue;\n                }\n            }\n        }\n    }\n\n    /**\n     * sets the start-points in map object. start points are read from xml\n     *\n     * @param map\n     */\n    public void setStartPoints(Map map) {\n        int MapX, MapY;\n        Point[] StartPoints;\n        NodeList nodes \u003d xmlFunctions.findXmlNodes(\"//startpoints/start\");\n        logger.info(nodes.getLength() + \" Startpunkte gefunden\");\n        StartPoints \u003d new Point[nodes.getLength()];\n        for (int i \u003d 0; i \u003c nodes.getLength(); i++) {\n            // read and create start points\n            // Player \u003d Integer.parseInt(getXMLValue((Node) nodes.item(i),\n            // \"player/text()\"));\n            MapX \u003d Integer.parseInt(getXMLValue((Node) nodes.item(i), \"x/text()\"));\n            MapY \u003d Integer.parseInt(getXMLValue((Node) nodes.item(i), \"y/text()\"));\n            StartPoints[i] \u003d new Point(MapX, MapY);\n        }\n        map.setStartPoints(StartPoints);\n    }\n\n    /**\n     * gets area of map\n     *\n     * @return Point with x and y dimension/number of tiles\n     */\n    public Point getArea() {\n        Point area \u003d new Point();\n        area.x \u003d Integer.parseInt(xmlFunctions.getXmlValue(\"/map/area/x/text()\"));\n        area.y \u003d Integer.parseInt(xmlFunctions.getXmlValue(\"/map/area/y/text()\"));\n        return area;\n    }\n}\n",
    "package": "common",
    "classname": "MapReader",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/MapReader.java",
    "test_prompt": "// MapReaderTest.java\npackage common;\n\nimport org.apache.log4j.Logger;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport java.awt.Point;\nimport javax.xml.xpath.*;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MapReader}.\n* It contains ten unit test cases for the {@link MapReader#getXMLValue(Node, String)} method.\n*/\nclass MapReaderTest {",
    "method_signature": "getXMLValue(Node, String)",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// MapFilesLister.java\npackage common;\r\n\r\nimport java.io.File;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.Vector;\r\nimport org.apache.log4j.Logger;\r\nimport messages.global.MapInfo;\r\n\r\n/**\r\n * class for listing maps and returning map information\r\n *\r\n * @author christian\r\n */\r\npublic class MapFilesLister {\r\n\r\n    private static final Logger logger \u003d Logger.getLogger(MapFilesLister.class);\r\n\r\n    public MapFilesLister() {\r\n    }\r\n\r\n    /**\r\n     * reads directory and returns a list of found xml-files\r\n     *\r\n     * @param dir -\r\n     *            directory to be searched in\r\n     * @return Vector\u003cFile\u003e\r\n     */\r\n    public Vector\u003cFile\u003e ListMaps(String dir) {\r\n        // open map folder\r\n        logger.info(\"Read map directory: \" + dir + \"...\");\r\n        File mapDir \u003d new File(dir);\r\n        File[] mapDirFiles \u003d mapDir.listFiles();\r\n        Vector\u003cFile\u003e foundFiles \u003d new Vector\u003cFile\u003e();\r\n        // open directories in map folder\r\n        for (int i \u003d 0; i \u003c mapDirFiles.length; i++) {\r\n            if (mapDirFiles[i].isFile() \u0026\u0026 mapDirFiles[i].toString().endsWith(\".xml\")) {\r\n                logger.info(\"XML: \" + mapDirFiles[i]);\r\n                foundFiles.add(mapDirFiles[i]);\r\n            }\r\n        }\r\n        return foundFiles;\r\n    }\r\n\r\n    /**\r\n     * retrieve list of MapInfo objects\r\n     *\r\n     * @return\r\n     */\r\n    public List\u003cMapInfo\u003e getMapInfoList() {\r\n        // clear map previews\r\n        clearPreviews();\r\n        List\u003cMapInfo\u003e maps \u003d new LinkedList\u003cMapInfo\u003e();\r\n        // read map directory\r\n        Vector\u003cFile\u003e mapFiles \u003d ListMaps(Constants.MAP_PATH);\r\n        for (File mapFile : mapFiles) {\r\n            // get map, just the tiles, no start points and powerups\r\n            Map map \u003d new Map(mapFile.getAbsolutePath(), true, false, false);\r\n            MapPreview mapPreview \u003d new MapPreview(map);\r\n            MapInfo mapInfo \u003d new MapInfo(mapFile.getName(), map.getName(), map.getMaxPlayers());\r\n            // creates or reads map preview with 300px width\r\n            mapInfo.setPreview(mapPreview.getMapPreview(300));\r\n            maps.add(mapInfo);\r\n        }\r\n        return maps;\r\n    }\r\n\r\n    /**\r\n     * clears unused or obsolete map preview files\r\n     */\r\n    public void clearPreviews() {\r\n        String dir \u003d Constants.MAP_PATH;\r\n        logger.info(\"Clear map-previews in directory: \" + dir + \"...\");\r\n        File mapDir \u003d new File(dir);\r\n        File[] mapDirPreviews \u003d mapDir.listFiles();\r\n        // list files in map directory\r\n        for (int i \u003d 0; i \u003c mapDirPreviews.length; i++) {\r\n            if (mapDirPreviews[i].isFile() \u0026\u0026 mapDirPreviews[i].toString().endsWith(\".png\")) {\r\n                // check if map xml is newer than preview\r\n                File mapFileName \u003d new File(mapDirPreviews[i].getPath().replaceAll(\"_[a-z]+.png$\", \"\"));\r\n                // does map still exist\r\n                if (!mapFileName.exists()) {\r\n                    mapDirPreviews[i].delete();\r\n                    logger.info(\"Preview: \" + mapDirPreviews[i] + \" deleted because corresponding map doesn\u0027t exists.\");\r\n                } else {\r\n                    // is preview older than map\r\n                    long mapDate \u003d mapFileName.lastModified();\r\n                    if (mapDate \u003e mapDirPreviews[i].lastModified()) {\r\n                        mapDirPreviews[i].delete();\r\n                        logger.info(\"Preview: \" + mapDirPreviews[i] + \" deleted because it was older than the map itself\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n",
    "package": "common",
    "classname": "MapFilesLister",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/MapFilesLister.java",
    "test_prompt": "// MapFilesListerTest.java\npackage common;\n\nimport java.io.File;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Vector;\nimport org.apache.log4j.Logger;\nimport messages.global.MapInfo;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MapFilesLister}.\n* It contains ten unit test cases for the {@link MapFilesLister#ListMaps(String)} method.\n*/\nclass MapFilesListerTest {",
    "method_signature": "ListMaps(String)",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// GameModel.java\npackage common;\r\n\r\nimport java.awt.Point;\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.Vector;\r\nimport java.util.Map.Entry;\r\nimport messages.round.RoundTimeOverMsg;\r\nimport org.apache.log4j.Logger;\r\n\r\n/**\r\n * @author Steffen, Andi, Bj�rn\r\n */\r\npublic class GameModel {\r\n\r\n    protected HashMap\u003cInteger, GameObject\u003e gameObjects \u003d new HashMap\u003cInteger, GameObject\u003e();\r\n\r\n    protected Vector\u003cPlayer\u003e players \u003d new Vector\u003cPlayer\u003e();\r\n\r\n    protected long time \u003d Constants.time;\r\n\r\n    protected static final Logger logger \u003d Logger.getLogger(GameModel.class);\r\n\r\n    public void update() {\r\n        synchronized (gameObjects) {\r\n            HashMap\u003cInteger, GameObject\u003e inactiveObjects \u003d new HashMap\u003cInteger, GameObject\u003e();\r\n            for (Entry\u003cInteger, GameObject\u003e entry : gameObjects.entrySet()) {\r\n                GameObject gameObject \u003d entry.getValue();\r\n                if (gameObject.isActive()) {\r\n                    gameObject.updateWithCollisionCheck(gameObjects.values());\r\n                }\r\n            }\r\n            for (Entry\u003cInteger, GameObject\u003e entry : gameObjects.entrySet()) {\r\n                if (!entry.getValue().isActive()) {\r\n                    inactiveObjects.put(entry.getKey(), entry.getValue());\r\n                }\r\n            }\r\n            // remove inactive objects now\r\n            for (Entry\u003cInteger, GameObject\u003e entry : inactiveObjects.entrySet()) {\r\n                logger.info(\"Removing game object: \" + entry.getKey());\r\n                gameObjects.remove(entry.getKey());\r\n                if (Player.class.isInstance(entry.getValue())) {\r\n                    logger.info(\"Removing player: \" + entry.getKey());\r\n                    players.remove(entry.getValue());\r\n                }\r\n            }\r\n            inactiveObjects \u003d null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the game is over and if yes returns the gameObjectId of the\r\n     * winner.\r\n     *\r\n     * @return -1 if game still running, 0 in case of a tie, gameObjectId of the\r\n     *         winner in all other cases\r\n     */\r\n    public int checkForWinner() {\r\n        if (players.size() \u003c 2) {\r\n            // 0 means it\u0027s a tie (all remaining players got\r\n            int winnerId \u003d 0;\r\n            // killed by the same bomb)\r\n            if (players.size() \u003d\u003d 1) {\r\n                // only the winner is left\r\n                winnerId \u003d players.get(0).getId();\r\n            }\r\n            return winnerId;\r\n        } else {\r\n            // game still running\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param arg0\r\n     * @return\r\n     * @see java.util.Vector#add(java.lang.Object)\r\n     */\r\n    public void addGameObject(int id, GameObject newGameObject) {\r\n        synchronized (gameObjects) {\r\n            this.gameObjects.put(id, newGameObject);\r\n            if (Player.class.isInstance(newGameObject)) {\r\n                players.add((Player) newGameObject);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param id\r\n     * @return\r\n     */\r\n    public GameObject getGameObjectById(int id) {\r\n        return gameObjects.get(id);\r\n    }\r\n\r\n    public void snapToGrid(Bomb bomb) {\r\n        Point pos \u003d bomb.getPosition();\r\n        int newX \u003d (pos.x / 40) * 40 + 20;\r\n        int newY \u003d (pos.y / 40) * 40 + 20;\r\n        pos.setLocation(newX, newY);\r\n    }\r\n\r\n    /**\r\n     * Returns the actual time of this GameModel.\r\n     *\r\n     * @return long - actual time\r\n     */\r\n    public long getTime() {\r\n        return time;\r\n    }\r\n\r\n    /**\r\n     * Sets the time of this GameModel.\r\n     *\r\n     * @param time\r\n     *            the time, which should be set\r\n     */\r\n    public void setTime(long time) {\r\n        this.time \u003d time;\r\n    }\r\n\r\n    public Vector\u003cPlayer\u003e getPlayers() {\r\n        return players;\r\n    }\r\n}\r\n",
    "package": "common",
    "classname": "GameModel",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/common/GameModel_0Test.java",
    "test_prompt": "// GameModel_0Test.java\npackage common;\n\nimport java.awt.Point;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Vector;\nimport java.util.Map.Entry;\nimport messages.round.RoundTimeOverMsg;\nimport org.apache.log4j.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GameModel}.\n* It contains ten unit test cases for the {@link GameModel#checkForWinner()} method.\n*/\nclass GameModel_0Test {",
    "method_signature": "checkForWinner()",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// ClientProperties.java\npackage client;\r\n\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport org.apache.log4j.Logger;\r\nimport common.Constants;\r\nimport common.XmlFunctions;\r\n\r\n/**\r\n * reads and writes properties to xml-file\r\n * properties file is saved to user directory\r\n *\r\n * @author christian\r\n */\r\npublic class ClientProperties {\r\n\r\n    private XmlFunctions xmlFunctions;\r\n\r\n    // is set to true if file can not be copied or\r\n    // found in user directory\r\n    // if set to true, class is ignoring invocations\r\n    private boolean fileError \u003d false;\r\n\r\n    private static final Logger logger \u003d Logger.getLogger(ClientProperties.class);\r\n\r\n    /**\r\n     * constructor, opens file for reading if exists\r\n     *\r\n     * @param fileName -\r\n     *            Name to xml file\r\n     */\r\n    public ClientProperties(String fileName) {\r\n        CheckPropertiesFile(fileName);\r\n        if (!fileError) {\r\n            xmlFunctions \u003d new XmlFunctions(fileName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * checks if local properties file is present, if not tries to copy empty\r\n     * file to location. If this fails, flag fileError is set to true and read\r\n     * or write access is bypassed\r\n     *\r\n     * @param fileName -\r\n     *            name of file\r\n     */\r\n    private void CheckPropertiesFile(String fileName) {\r\n        // properties file on users file system\r\n        File checkFile \u003d new File(fileName);\r\n        if (!checkFile.exists()) {\r\n            logger.info(\"File fubarman_properties.xml was not found in user directory. Try to copy default file...\");\r\n            InputStream defaultFile \u003d common.ResourceService.getInputStream(Constants.PROPERTIES_DEFAULTFILE);\r\n            if (!fileCopy(defaultFile, checkFile)) {\r\n                logger.error(\"File fubarman_properties.xml could not be copied to user directory. Properties disabled.\");\r\n                this.fileError \u003d true;\r\n            } else {\r\n                logger.info(\"File fubarman_properties.xml was successfully copied to user directory.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get property value by element-name returns empty string if fileError is\r\n     * true\r\n     *\r\n     * @param element -\r\n     *            Name of element\r\n     * @return String - value\r\n     */\r\n    public String getProperty(String element) {\r\n        if (!fileError) {\r\n            String XmlPath \u003d \"//\" + element;\r\n            return xmlFunctions.getXmlValue(XmlPath);\r\n        } else {\r\n            return new String(\"\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * (over)writes value of specific element\r\n     * does nothing if fileError is true\r\n     *\r\n     * @param element -\r\n     *            Name of element\r\n     * @param value -\r\n     *            new value\r\n     */\r\n    public void setProperty(String element, String value) {\r\n        if (!fileError) {\r\n            String XmlPath \u003d \"//\" + element;\r\n            xmlFunctions.setXmlValue(XmlPath, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * copies a file from a to b\r\n     * used InputStream as provided from ResourceService class as\r\n     * source and File as destination\r\n     *\r\n     * @param sourceFile -\r\n     *            InputStream - File which should be copied\r\n     * @param destFile -\r\n     *            destination where file should be copied to\r\n     * @return boolean - true if successfully copied, otherwise false\r\n     */\r\n    public static boolean fileCopy(InputStream sourceFile, File destFile) {\r\n        try {\r\n            InputStream in \u003d sourceFile;\r\n            FileOutputStream out \u003d new FileOutputStream(destFile);\r\n            byte[] buf \u003d new byte[4096];\r\n            int len;\r\n            while ((len \u003d in.read(buf)) \u003e 0) out.write(buf, 0, len);\r\n            out.close();\r\n            in.close();\r\n        } catch (IOException e) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n",
    "package": "client",
    "classname": "ClientProperties",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/client/ClientProperties_0Test.java",
    "test_prompt": "// ClientProperties_0Test.java\npackage client;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport org.apache.log4j.Logger;\nimport common.Constants;\nimport common.XmlFunctions;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClientProperties}.\n* It contains ten unit test cases for the {@link ClientProperties#getProperty(String)} method.\n*/\nclass ClientProperties_0Test {",
    "method_signature": "getProperty(String)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// ClientProperties.java\npackage client;\r\n\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport org.apache.log4j.Logger;\r\nimport common.Constants;\r\nimport common.XmlFunctions;\r\n\r\n/**\r\n * reads and writes properties to xml-file\r\n * properties file is saved to user directory\r\n *\r\n * @author christian\r\n */\r\npublic class ClientProperties {\r\n\r\n    private XmlFunctions xmlFunctions;\r\n\r\n    // is set to true if file can not be copied or\r\n    // found in user directory\r\n    // if set to true, class is ignoring invocations\r\n    private boolean fileError \u003d false;\r\n\r\n    private static final Logger logger \u003d Logger.getLogger(ClientProperties.class);\r\n\r\n    /**\r\n     * constructor, opens file for reading if exists\r\n     *\r\n     * @param fileName -\r\n     *            Name to xml file\r\n     */\r\n    public ClientProperties(String fileName) {\r\n        CheckPropertiesFile(fileName);\r\n        if (!fileError) {\r\n            xmlFunctions \u003d new XmlFunctions(fileName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * checks if local properties file is present, if not tries to copy empty\r\n     * file to location. If this fails, flag fileError is set to true and read\r\n     * or write access is bypassed\r\n     *\r\n     * @param fileName -\r\n     *            name of file\r\n     */\r\n    private void CheckPropertiesFile(String fileName) {\r\n        // properties file on users file system\r\n        File checkFile \u003d new File(fileName);\r\n        if (!checkFile.exists()) {\r\n            logger.info(\"File fubarman_properties.xml was not found in user directory. Try to copy default file...\");\r\n            InputStream defaultFile \u003d common.ResourceService.getInputStream(Constants.PROPERTIES_DEFAULTFILE);\r\n            if (!fileCopy(defaultFile, checkFile)) {\r\n                logger.error(\"File fubarman_properties.xml could not be copied to user directory. Properties disabled.\");\r\n                this.fileError \u003d true;\r\n            } else {\r\n                logger.info(\"File fubarman_properties.xml was successfully copied to user directory.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get property value by element-name returns empty string if fileError is\r\n     * true\r\n     *\r\n     * @param element -\r\n     *            Name of element\r\n     * @return String - value\r\n     */\r\n    public String getProperty(String element) {\r\n        if (!fileError) {\r\n            String XmlPath \u003d \"//\" + element;\r\n            return xmlFunctions.getXmlValue(XmlPath);\r\n        } else {\r\n            return new String(\"\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * (over)writes value of specific element\r\n     * does nothing if fileError is true\r\n     *\r\n     * @param element -\r\n     *            Name of element\r\n     * @param value -\r\n     *            new value\r\n     */\r\n    public void setProperty(String element, String value) {\r\n        if (!fileError) {\r\n            String XmlPath \u003d \"//\" + element;\r\n            xmlFunctions.setXmlValue(XmlPath, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * copies a file from a to b\r\n     * used InputStream as provided from ResourceService class as\r\n     * source and File as destination\r\n     *\r\n     * @param sourceFile -\r\n     *            InputStream - File which should be copied\r\n     * @param destFile -\r\n     *            destination where file should be copied to\r\n     * @return boolean - true if successfully copied, otherwise false\r\n     */\r\n    public static boolean fileCopy(InputStream sourceFile, File destFile) {\r\n        try {\r\n            InputStream in \u003d sourceFile;\r\n            FileOutputStream out \u003d new FileOutputStream(destFile);\r\n            byte[] buf \u003d new byte[4096];\r\n            int len;\r\n            while ((len \u003d in.read(buf)) \u003e 0) out.write(buf, 0, len);\r\n            out.close();\r\n            in.close();\r\n        } catch (IOException e) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n",
    "package": "client",
    "classname": "ClientProperties",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/client/ClientProperties_1Test.java",
    "test_prompt": "// ClientProperties_1Test.java\npackage client;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport org.apache.log4j.Logger;\nimport common.Constants;\nimport common.XmlFunctions;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClientProperties}.\n* It contains ten unit test cases for the {@link ClientProperties#fileCopy(InputStream, File)} method.\n*/\nclass ClientProperties_1Test {",
    "method_signature": "fileCopy(InputStream, File)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// ClientPlayer.java\n/**\r\n */\r\npackage client;\r\n\r\nimport java.awt.Point;\r\nimport org.apache.log4j.Logger;\r\nimport sound.SoundPlayer;\r\nimport common.Actor;\r\nimport common.Constants;\r\nimport common.Player;\r\n\r\n/**\r\n * The client specific implemetation of a Player. This implementation will\r\n * notify any number of registered observers about changes to their state.\r\n *\r\n * @author Andi, Bj�rn\r\n */\r\npublic class ClientPlayer extends Player {\r\n\r\n    private boolean bowlBombs \u003d false;\r\n\r\n    private Logger logger \u003d Logger.getLogger(ClientPlayer.class);\r\n\r\n    private int bombsPlanted \u003d 0;\r\n\r\n    private int bombDiameter \u003d Constants.BOMB_DIAMETER;\r\n\r\n    private int maxBombs \u003d Constants.MIN_BOMBS;\r\n\r\n    private long lastPlant;\r\n\r\n    /**\r\n     * Creates a new ClientPlayer that starts on a fixed position.\r\n     *\r\n     * @param position\r\n     *            The starting location for this player.\r\n     */\r\n    public ClientPlayer(Point position, int id) {\r\n        super(position);\r\n        this.id \u003d id;\r\n    }\r\n\r\n    /*\r\n\t * (non-Javadoc)\r\n\t * \r\n\t * @see common.Actor#preUpdate()\r\n\t */\r\n    @Override\r\n    protected void preUpdate() {\r\n        // if (!moveVector.equals(previousMoveVector)) {\r\n        setChanged();\r\n        // }\r\n    }\r\n\r\n    /**\r\n     * Plants a bomb on the battlefield. The bomb will be located at the current\r\n     * position. If the user can bowl bombs the bomb get a moveVector. This will\r\n     * trigger a notification for the observers.\r\n     */\r\n    public void plantBomb() {\r\n        long time \u003d System.currentTimeMillis();\r\n        if ((bombsPlanted \u003e\u003d maxBombs) || (time - lastPlant \u003c 100)) {\r\n            return;\r\n        }\r\n        lastPlant \u003d time;\r\n        setChanged();\r\n        Point posClone \u003d (Point) getPosition().clone();\r\n        ClientBomb bomb \u003d new ClientBomb(posClone, this);\r\n        bomb.setId(BomberClient.getInstance().getNextId());\r\n        bomb.setDiameter(bombDiameter);\r\n        bomb.setRemote(false);\r\n        Point moveVec \u003d new Point(0, 0);\r\n        if (bowlBombs) {\r\n            bomb.setStopped(false);\r\n            if (getDirection() \u003d\u003d 1) {\r\n                moveVec.y \u003d -Actor.MOVE_DELTA * speed;\r\n            } else if (getDirection() \u003d\u003d 2) {\r\n                moveVec.y \u003d Actor.MOVE_DELTA * speed;\r\n            } else if (getDirection() \u003d\u003d 3) {\r\n                moveVec.x \u003d -Actor.MOVE_DELTA * speed;\r\n            } else if (getDirection() \u003d\u003d 4) {\r\n                moveVec.x \u003d Actor.MOVE_DELTA * speed;\r\n            }\r\n        } else {\r\n            bomb.setStopped(true);\r\n        }\r\n        bomb.setMoveVector(moveVec);\r\n        bombsThatSpawnedOnMe.add(bomb);\r\n        notifyObservers(bomb);\r\n        SoundPlayer.getInstance().bWerfen();\r\n        /*\r\n\t\t * This needs synchronization to prevent lost updates. A lost update\r\n\t\t * could occur when another thread changes the bombsPlanted variable\r\n\t\t * between the read/write operation of the increment.\r\n\t\t */\r\n        synchronized (this) {\r\n            bombsPlanted \u003d bombsPlanted + 1;\r\n        }\r\n    }\r\n\r\n    /*\r\n\t * (non-Javadoc)\r\n\t * \r\n\t * @see common.Player#die()\r\n\t */\r\n    @Override\r\n    public void die() {\r\n        super.die();\r\n        SoundPlayer.getInstance().stirbt();\r\n        logger.info(\"#\" + getId() + \" died\");\r\n    }\r\n\r\n    /**\r\n     * Increases the maximum number of bombs this player can plant by one. If\r\n     * the player can already plant MAX_BOMDS bombs, this method will do\r\n     * nothing.\r\n     */\r\n    public void increaseMaxBombs() {\r\n        if (maxBombs \u003c Constants.MAX_BOMBS) {\r\n            maxBombs \u003d maxBombs + 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the maximum number of bombs this player can plant by one.\r\n     */\r\n    public void resetMaxBombs() {\r\n        maxBombs \u003d Constants.MIN_BOMBS;\r\n    }\r\n\r\n    /**\r\n     * Notifies this player that a previously planted bomb has exploded. This\r\n     * will decrease the count of currently planted bombs.\r\n     */\r\n    public void plantedBombExploded() {\r\n        /*\r\n\t\t * This needs synchronization to prevent lost updates. A lost update\r\n\t\t * could occur when another thread changes the bombsPlanted variable\r\n\t\t * between the read/write operation of the decrement.\r\n\t\t */\r\n        synchronized (this) {\r\n            bombsPlanted \u003d bombsPlanted - 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Increases the diameter of the bomb, that this player can plant.\r\n     */\r\n    public void increaseBombDiameter() {\r\n        bombDiameter +\u003d 2;\r\n    }\r\n\r\n    /**\r\n     * Resets the diameter of the bomb, that this player can plant.\r\n     */\r\n    public void resetBombDiameter() {\r\n        bombDiameter \u003d Constants.BOMB_DIAMETER;\r\n    }\r\n\r\n    /**\r\n     * Sets, that player can bowl bombs\r\n     */\r\n    public void setBowlBombs() {\r\n        bowlBombs \u003d true;\r\n    }\r\n\r\n    /**\r\n     * Sets, that player can\u0027t bowl bombs\r\n     */\r\n    public void resetBowlBombs() {\r\n        bowlBombs \u003d false;\r\n    }\r\n\r\n    /**\r\n     * Returns weather the player can bowl bombs\r\n     *\r\n     * @return boolean can bowl bombs\r\n     */\r\n    public boolean canBowlBombs() {\r\n        return bowlBombs;\r\n    }\r\n}\r\n",
    "package": "client",
    "classname": "ClientPlayer",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/client/ClientPlayer.java",
    "test_prompt": "// ClientPlayerTest.java\npackage client;\n\nimport java.awt.Point;\nimport org.apache.log4j.Logger;\nimport sound.SoundPlayer;\nimport common.Actor;\nimport common.Constants;\nimport common.Player;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClientPlayer}.\n* It contains ten unit test cases for the {@link ClientPlayer#canBowlBombs()} method.\n*/\nclass ClientPlayerTest {",
    "method_signature": "canBowlBombs()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// ClientGameRound.java\n/**\r\n */\r\npackage client;\r\n\r\nimport java.awt.Point;\r\nimport java.util.HashMap;\r\nimport java.util.Observable;\r\nimport java.util.Observer;\r\nimport java.util.Vector;\r\nimport org.apache.log4j.Logger;\r\nimport client.controller.LocalControl;\r\nimport client.gui.StartFrame;\r\nimport client.network.ForwardingObserver;\r\nimport client.view.BombView;\r\nimport client.view.GameCanvas;\r\nimport client.view.GameView;\r\nimport client.view.GfxFactory;\r\nimport client.view.OffGamePainter;\r\nimport client.view.PlayerView;\r\nimport client.view.PowerUpView;\r\nimport client.view.StatusView;\r\nimport client.view.TileView;\r\nimport common.Bomb;\r\nimport common.Constants;\r\nimport common.GameModel;\r\nimport common.GameObject;\r\nimport common.GameRound;\r\nimport common.Map;\r\nimport common.Player;\r\nimport common.PowerUp;\r\nimport common.Tile;\r\n\r\n/**\r\n * Represents a game on the client side. This class serves as a connection\r\n * between the model, view and game loop.\r\n *\r\n * @author Andi, Bj�rn\r\n */\r\npublic class ClientGameRound extends GameRound implements Observer {\r\n\r\n    /**\r\n     * The GameModel instance for this game.\r\n     */\r\n    private GameModel model;\r\n\r\n    /**\r\n     * The GameView instance for this game.\r\n     */\r\n    private GameView view;\r\n\r\n    /**\r\n     * The GameLoop instance for this game.\r\n     */\r\n    private ClientGameLoop gameLoop;\r\n\r\n    /**\r\n     * The GfxFactory instance for this game.\r\n     */\r\n    private GfxFactory gfxFactory;\r\n\r\n    private static final Logger logger \u003d Logger.getLogger(ClientGameRound.class);\r\n\r\n    private Player localPlayer;\r\n\r\n    private final ClientGameSession session;\r\n\r\n    private Thread offGamePainter;\r\n\r\n    private final GameCanvas gameCanvas;\r\n\r\n    private ForwardingObserver forwardingObserver;\r\n\r\n    /**\r\n     * Creates a new game that will be painted on the passed GameCanvas object.\r\n     * When this constructor finishes, all necessary game objects will be\r\n     * initialized, but they will lack player and map objects.\r\n     *\r\n     * @param gameCanvas\r\n     *            The canvas that will be used for painting the view.\r\n     */\r\n    public ClientGameRound(ClientGameSession session, GameCanvas gameCanvas) {\r\n        this.session \u003d session;\r\n        this.gameCanvas \u003d gameCanvas;\r\n        model \u003d new GameModel();\r\n        view \u003d new GameView(gameCanvas);\r\n        gameLoop \u003d new ClientGameLoop(this, model, view);\r\n        gfxFactory \u003d new GfxFactory();\r\n        forwardingObserver \u003d new ForwardingObserver(BomberClient.getInstance(), this);\r\n        offGamePainter \u003d new OffGamePainter(view);\r\n        offGamePainter.start();\r\n    }\r\n\r\n    /**\r\n     * Adds a player to the game. Adds the player object to GameModel and\r\n     * creates a view object for the player and adds it to the GameView.\r\n     *\r\n     * @param player\r\n     *            The player to add to this game.\r\n     */\r\n    public void addPlayer(int id, ClientPlayer player) {\r\n        player.addObserver(this);\r\n        if (id \u003d\u003d session.getId()) {\r\n            player.addObserver(forwardingObserver);\r\n            StatusView statusView \u003d new StatusView(player, gfxFactory);\r\n            view.addGameObjectView(statusView);\r\n        }\r\n        model.addGameObject(id, player);\r\n        view.addGameObjectView(new PlayerView(player, gfxFactory));\r\n    }\r\n\r\n    public void addBomb(int id, Bomb bomb) {\r\n        if (model.getGameObjectById(id) !\u003d null) {\r\n            return;\r\n        }\r\n        bomb.addObserver(forwardingObserver);\r\n        model.addGameObject(id, bomb);\r\n        view.addGameObjectView(new BombView(bomb, gfxFactory));\r\n    }\r\n\r\n    /**\r\n     * Sets the map for this game. All tiles that are contained in the map are\r\n     * added to the GameModel. For every tile a TileView is created and added to\r\n     * the GameView.\r\n     *\r\n     * @param map\u003d\r\n     *            The map that will be used in this game.\r\n     */\r\n    public void setMap(Map map) {\r\n        Vector\u003cTile\u003e tiles \u003d new Vector\u003cTile\u003e();\r\n        String imageSet \u003d map.getImageSet();\r\n        for (Tile tile : map) {\r\n            model.addGameObject(tile.getId(), tile);\r\n            tiles.add(tile);\r\n            gfxFactory.setTileSet(map.getImageSet());\r\n            view.addGameObjectView(new TileView(tile, gfxFactory));\r\n        }\r\n        for (PowerUp powerUp : map.powerupiterator) {\r\n            model.addGameObject(powerUp.getId(), powerUp);\r\n            view.addGameObjectView(new PowerUpView(powerUp, gfxFactory));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts this game by creating a new thread and running the game loop in\r\n     * it.\r\n     */\r\n    public void start() {\r\n        offGamePainter.interrupt();\r\n        gameLoop.start();\r\n    }\r\n\r\n    /**\r\n     * Set the local control for this game. This control will be used to move\r\n     * the local player on the screen.\r\n     *\r\n     * @param localControl\r\n     *            The local control to use.\r\n     */\r\n    public void setLocalControl(LocalControl localControl) {\r\n        gameLoop.setLocalControl(localControl);\r\n    }\r\n\r\n    /**\r\n     * Called when an observable has changed. Usages:\r\n     * \u003cul\u003e\r\n     * \u003cli\u003ePlayer plants a bomb\r\n     * \u003c/ul\u003e\r\n     *\r\n     * @see java.util.Observer#update(java.util.Observable, java.lang.Object)\r\n     */\r\n    @Override\r\n    public void update(Observable o, Object arg) {\r\n    }\r\n\r\n    /**\r\n     * Searches and returns a GameObject by its id.\r\n     *\r\n     * @param id\r\n     *            The id of the GameObject that should be returned.\r\n     * @return The matching GameObject or null if the id is unknown.\r\n     */\r\n    public GameObject getGameObjectById(int id) {\r\n        return model.getGameObjectById(id);\r\n    }\r\n\r\n    /**\r\n     * Updates the countdown for this GameRound. Visual and acoustic\r\n     * notifications will be triggered.\r\n     *\r\n     * @param countdown\r\n     *            The current countdown.\r\n     */\r\n    public void countdown(int countdown) {\r\n        String overlayText;\r\n        if (countdown \u003d\u003d 0) {\r\n            overlayText \u003d \"\";\r\n        } else {\r\n            overlayText \u003d String.valueOf(countdown);\r\n        }\r\n        view.setOverlayText(overlayText);\r\n    }\r\n\r\n    /**\r\n     * @param player\r\n     */\r\n    public void setLocalPlayer(Player localPlayer) {\r\n        this.localPlayer \u003d localPlayer;\r\n        LocalControl lControl \u003d new LocalControl(localPlayer);\r\n        gameCanvas.addKeyListener(lControl);\r\n        gameLoop.setLocalControl(lControl);\r\n    }\r\n\r\n    /**\r\n     * Finishes this game round by calculating the score and notifying the\r\n     * session that the round has ended.\r\n     *\r\n     * @see common.GameRound#doPostRoundProcessing()\r\n     */\r\n    @Override\r\n    public void doPostRoundProcessing() {\r\n        setTime(Constants.time);\r\n        logger.info(\"in ClientGameRound#doPostRoundProcessing()\");\r\n        StartFrame.getInstance().removeChatMessageSession();\r\n        session.doPostRoundProcessing();\r\n    }\r\n\r\n    /**\r\n     * Snaps the location of the given bomb to the next intersection on the\r\n     * grid.\r\n     *\r\n     * @param bomb\r\n     *            The bomb that should be relocated on the grid.\r\n     */\r\n    public void snapToGrid(Bomb bomb) {\r\n        model.snapToGrid(bomb);\r\n    }\r\n\r\n    /**\r\n     * Sets the status of the round. This is used to inform the user about\r\n     * what\u0027s happening.\r\n     *\r\n     * @param string\r\n     *            The string that will be displayed to the user.\r\n     */\r\n    public void setStatus(String string) {\r\n        view.setOverlayText(string);\r\n    }\r\n\r\n    /**\r\n     * End the game round. The action will stop but the game will still be\r\n     * painted on the canvas.\r\n     */\r\n    public void endRound() {\r\n    }\r\n\r\n    /**\r\n     * Terminate this round. This will stop the rendering of the game.\r\n     */\r\n    public void terminateRound() {\r\n        try {\r\n            gameLoop.interrupt();\r\n            view.resetGfx();\r\n            session.doPostSessionProcessing();\r\n            logger.info(\"interrupted game loop\");\r\n        } catch (RuntimeException e) {\r\n            // whatever...\r\n            logger.info(\"game loop already interrupted\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the actual time of this GameRound.\r\n     *\r\n     * @return long - actual time\r\n     */\r\n    public long getTime() {\r\n        return model.getTime();\r\n    }\r\n\r\n    /**\r\n     * Sets the time of this GameRound.\r\n     *\r\n     * @param time\r\n     *            the time, which should be set\r\n     */\r\n    public void setTime(long time) {\r\n        model.setTime(time);\r\n    }\r\n\r\n    /**\r\n     * {@inheritDoc}\r\n     */\r\n    @Override\r\n    public void createNewTile(Point point, int id, String type, boolean bombable, boolean accessible, boolean active) {\r\n        Tile t \u003d new Tile(point);\r\n        t.setId(id);\r\n        t.setBombable(bombable);\r\n        if (active) {\r\n            t.setActive();\r\n        } else {\r\n            t.setInactive();\r\n        }\r\n        t.setType(type);\r\n        t.setAccessible(accessible);\r\n        t.setVisible();\r\n        model.addGameObject(t.getId(), t);\r\n        view.addGameObjectView(new TileView(t, gfxFactory));\r\n    }\r\n\r\n    public void toggleDisplayNames() {\r\n        view.toggleDisplayNames();\r\n    }\r\n\r\n    public void setRoundScore(HashMap\u003cString, Integer\u003e rndscore) {\r\n        StartFrame.getInstance().updateRoundScoreData(rndscore);\r\n    }\r\n}\r\n",
    "package": "client",
    "classname": "ClientGameRound",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/client/ClientGameRound.java",
    "test_prompt": "// ClientGameRoundTest.java\npackage client;\n\nimport java.awt.Point;\nimport java.util.HashMap;\nimport java.util.Observable;\nimport java.util.Observer;\nimport java.util.Vector;\nimport org.apache.log4j.Logger;\nimport client.controller.LocalControl;\nimport client.gui.StartFrame;\nimport client.network.ForwardingObserver;\nimport client.view.BombView;\nimport client.view.GameCanvas;\nimport client.view.GameView;\nimport client.view.GfxFactory;\nimport client.view.OffGamePainter;\nimport client.view.PlayerView;\nimport client.view.PowerUpView;\nimport client.view.StatusView;\nimport client.view.TileView;\nimport common.Bomb;\nimport common.Constants;\nimport common.GameModel;\nimport common.GameObject;\nimport common.GameRound;\nimport common.Map;\nimport common.Player;\nimport common.PowerUp;\nimport common.Tile;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClientGameRound}.\n* It contains ten unit test cases for the {@link ClientGameRound#getGameObjectById(int)} method.\n*/\nclass ClientGameRoundTest {",
    "method_signature": "getGameObjectById(int)",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// BomberClient.java\npackage client;\r\n\r\nimport java.io.IOException;\r\nimport java.net.Socket;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Observable;\r\nimport java.util.Vector;\r\nimport javax.swing.ImageIcon;\r\nimport messages.Message;\r\nimport messages.global.InfoRequestMsg;\r\nimport messages.global.JoinSessionMsg;\r\nimport messages.global.MapInfo;\r\nimport messages.global.SessionDetailsMsg;\r\nimport messages.round.ClientQuitRunningSessionMsg;\r\nimport org.apache.log4j.Logger;\r\nimport client.gui.StartFrame;\r\nimport client.network.ClientMsgReceiver;\r\nimport client.network.ClientMsgSender;\r\n\r\n/**\r\n * This is central client class. It is responsible for globally scoped messages\r\n * and the creation of sessions.\r\n *\r\n * @author andi\r\n */\r\npublic class BomberClient extends Observable {\r\n\r\n    // for logging\r\n    private static Logger logger \u003d Logger.getLogger(BomberClient.class);\r\n\r\n    /**\r\n     * The socket that is used to communicate with the server.\r\n     */\r\n    public Socket server;\r\n\r\n    /**\r\n     * The ip address of the server.\r\n     */\r\n    private String serverName \u003d \"localhost\";\r\n\r\n    /**\r\n     * The port on the server to connect to.\r\n     */\r\n    private int serverPort \u003d 6666;\r\n\r\n    /**\r\n     * The name of the player that is running this client.\r\n     */\r\n    private String playerName;\r\n\r\n    private ClientMsgReceiver msgReceiver;\r\n\r\n    private ClientMsgSender msgSender;\r\n\r\n    /**\r\n     * The id offset of this client. Generated ids will be in the range from\r\n     * idOffset to idOffset + 1000000.\r\n     */\r\n    private int idOffset \u003d -1;\r\n\r\n    /**\r\n     * Singleton instance\r\n     */\r\n    private static BomberClient instance;\r\n\r\n    /**\r\n     * The currently used (and sole) session.\r\n     */\r\n    private ClientGameSession currentSession;\r\n\r\n    /**\r\n     * A list of sessions that are running on the server.\r\n     */\r\n    private Vector\u003cSessionDetailsMsg\u003e availableSessions \u003d new Vector\u003cSessionDetailsMsg\u003e();\r\n\r\n    /**\r\n     * A list of maps that are availbale on the server.\r\n     */\r\n    private Vector\u003cMapInfo\u003e availableMaps;\r\n\r\n    private ClientGameSession requestedSession;\r\n\r\n    /**\r\n     * @return The current game session.\r\n     */\r\n    public ClientGameSession getCurrentSession() {\r\n        return currentSession;\r\n    }\r\n\r\n    /**\r\n     * Creates a new BomberClient. Use getInstance() to aquire an instance.\r\n     *\r\n     * @param playerName\r\n     *            The name of the player on this client.\r\n     */\r\n    private BomberClient(String playerName) {\r\n        this.playerName \u003d playerName;\r\n        availableMaps \u003d new Vector\u003cMapInfo\u003e();\r\n    }\r\n\r\n    /**\r\n     * Returns the singleton.\r\n     *\r\n     * @return The only BomberClient instance.\r\n     */\r\n    public static BomberClient getInstance() {\r\n        if (instance \u003d\u003d null) {\r\n            logger.info(\"Creating BomberClient singleton instance\");\r\n            instance \u003d new BomberClient(\"client\");\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * Tries to connect to the server.\r\n     *\r\n     * @throws RuntimeException\r\n     *             Thrown when the connection attempt was not successful.\r\n     */\r\n    public boolean connectToSrv() {\r\n        try {\r\n            //System.out.println(\"Connecting...\");\r\n            logger.info(\"Establishing a connection \");\r\n            server \u003d new Socket(serverName, serverPort);\r\n            msgSender \u003d new ClientMsgSender(server);\r\n            msgSender.start();\r\n            msgReceiver \u003d new ClientMsgReceiver(server, BomberClient.this);\r\n            msgReceiver.start();\r\n            msgSender.sendMsg(new InfoRequestMsg(InfoRequestMsg.GET_SESSION_LIST));\r\n            logger.info(\"connected to \" + serverName);\r\n            return true;\r\n        } catch (IOException e) {\r\n            // TODO Auto-generated catch block\r\n            // e.printStackTrace();\r\n            logger.info(\"Connection failed\");\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sends a message to the server. The passed object will be serialized and\r\n     * transmitted to the server.\r\n     *\r\n     * @param msg\r\n     *            The message to send.\r\n     */\r\n    public void sendMsg(Message msg) {\r\n        msgSender.sendMsg(msg);\r\n    }\r\n\r\n    /**\r\n     * Creates a new id that is guaranteed to be unique for this class.\r\n     *\r\n     * @return The next valid id for this class.\r\n     */\r\n    public int getNextId() {\r\n        return ++idOffset;\r\n    }\r\n\r\n    /**\r\n     * Sets the id offset.\r\n     *\r\n     * @param idOffset\r\n     *            to set\r\n     */\r\n    public void setIdOffset(int idOffset) {\r\n        this.idOffset \u003d idOffset;\r\n    }\r\n\r\n    /**\r\n     * Sets the current session.\r\n     *\r\n     * @param The\r\n     *            ClientGameSession to set.\r\n     */\r\n    public void setCurrentSession(ClientGameSession currentSession) {\r\n        this.currentSession \u003d currentSession;\r\n    }\r\n\r\n    /**\r\n     * Create a new session on the server. The given arguments are rolled up\r\n     * into a SessionDetailsMsg and sent to the server.\r\n     *\r\n     * @param name\r\n     *            The name for the new session.\r\n     * @param maps\r\n     *            A list of map names that will be used for this session\r\n     * @param totalPlayers\r\n     *            The total number of players.\r\n     * @param rounds\r\n     *            The number of rounds to play.\r\n     */\r\n    public void createSession(String name, List\u003cString\u003e maps, ImageIcon mapPreview, int totalPlayers, int rounds) {\r\n        SessionDetailsMsg sessionDetailsMsg \u003d new SessionDetailsMsg(name, maps, mapPreview, totalPlayers, totalPlayers, rounds);\r\n        this.requestedSession \u003d new ClientGameSession(name, maps, mapPreview, totalPlayers, rounds, idOffset);\r\n        msgSender.sendMsg(sessionDetailsMsg);\r\n    }\r\n\r\n    public void openSession() {\r\n        requestedSession.setIdOffset(idOffset);\r\n        setCurrentSession(requestedSession);\r\n        logger.info(\"opened session: \" + currentSession.getName());\r\n    }\r\n\r\n    /**\r\n     * Requests a list of active sessions on the server.\r\n     */\r\n    public void requestSessionList() {\r\n        InfoRequestMsg sessionRequest \u003d new InfoRequestMsg(InfoRequestMsg.GET_SESSION_LIST);\r\n        sendMsg(sessionRequest);\r\n    }\r\n\r\n    /**\r\n     * Requests a list of available maps from the server.\r\n     */\r\n    public void requestMapList() {\r\n        InfoRequestMsg mapRequest \u003d new InfoRequestMsg(InfoRequestMsg.GET_MAP_LIST);\r\n        sendMsg(mapRequest);\r\n    }\r\n\r\n    /**\r\n     * Returns a list of active sessions on the server. Invoke\r\n     * requestSessionList() to update this list.\r\n     *\r\n     * @return\r\n     */\r\n    public Vector\u003cSessionDetailsMsg\u003e getAvailableSessions() {\r\n        return availableSessions;\r\n    }\r\n\r\n    /**\r\n     * @param sessionInfos\r\n     */\r\n    public void setAvailableSessions(Vector\u003cSessionDetailsMsg\u003e sessionInfos) {\r\n        availableSessions.clear();\r\n        availableSessions.addAll(sessionInfos);\r\n        // TODO observer\r\n        StartFrame.getInstance().setAvailableSessions(availableSessions);\r\n    }\r\n\r\n    /**\r\n     * @param maps\r\n     */\r\n    public void setAvailableMaps(List\u003cMapInfo\u003e maps) {\r\n        availableMaps.clear();\r\n        availableMaps.addAll(maps);\r\n        // TODO observer\r\n        StartFrame.getInstance().setAvailableMaps(availableMaps);\r\n    }\r\n\r\n    /**\r\n     * @return the availableMaps\r\n     */\r\n    public Vector\u003cMapInfo\u003e getAvailableMaps() {\r\n        return availableMaps;\r\n    }\r\n\r\n    /**\r\n     * Creates a session from the details specified in the given\r\n     * SessionDetailMsg.\r\n     *\r\n     * @param session\r\n     *            The session to open on this client.\r\n     */\r\n    public void createSession(SessionDetailsMsg sessionDetails) {\r\n        ClientGameSession session \u003d new ClientGameSession(sessionDetails.getGameName(), sessionDetails.getMaps(), sessionDetails.getPreview(), sessionDetails.getNrOfPlayers(), sessionDetails.getTotalRounds(), idOffset);\r\n        requestedSession \u003d session;\r\n        JoinSessionMsg joinMsg \u003d new JoinSessionMsg(session.getName(), playerName);\r\n        msgSender.sendMsg(joinMsg);\r\n    }\r\n\r\n    /**\r\n     * Sets the server-name\r\n     *\r\n     * @author Bj�rn\r\n     */\r\n    public void setServerName(String serverName) {\r\n        this.serverName \u003d serverName;\r\n    }\r\n\r\n    /**\r\n     * Sets the server-port\r\n     *\r\n     * @author Bj�rn\r\n     */\r\n    public void setServerPort(int serverPort) {\r\n        this.serverPort \u003d serverPort;\r\n    }\r\n\r\n    /**\r\n     * @param sender\r\n     * @param msg\r\n     */\r\n    public void addChatGlobal(String sender, String msg) {\r\n        logger.info(\"omg asd rofl\");\r\n        StartFrame.getInstance().addChatMessageGlobal(sender, msg);\r\n    }\r\n\r\n    /**\r\n     * @param sender\r\n     * @param msg\r\n     */\r\n    public void addChatSession(String sender, String msg) {\r\n        StartFrame.getInstance().addChatMessageSession(sender, msg);\r\n    }\r\n\r\n    public void discardSessionRequest() {\r\n        requestedSession \u003d null;\r\n    }\r\n\r\n    /**\r\n     * Closes the current session.\r\n     */\r\n    public void closeSession() {\r\n        // TODO session highscore presentation\r\n        currentSession \u003d null;\r\n        StartFrame sFrame \u003d StartFrame.getInstance();\r\n        sFrame.showGlobalLobby();\r\n    }\r\n\r\n    /**\r\n     * Closes the current session.\r\n     */\r\n    public void closeSessionAndShowHighscores() {\r\n        // TODO session highscore presentation\r\n        currentSession \u003d null;\r\n        StartFrame sFrame \u003d StartFrame.getInstance();\r\n        sFrame.showHighscoreLobby();\r\n    }\r\n\r\n    /**\r\n     * Leave the current session.\r\n     */\r\n    public void leaveSession() {\r\n        if (currentSession !\u003d null) {\r\n            currentSession.leave();\r\n        }\r\n        currentSession \u003d null;\r\n        StartFrame sFrame \u003d StartFrame.getInstance();\r\n        sFrame.showGlobalLobby();\r\n    }\r\n\r\n    public void closeConnection() {\r\n        msgReceiver.closeConnection();\r\n    }\r\n\r\n    public String getPlayerName() {\r\n        return playerName;\r\n    }\r\n\r\n    public void setPlayerName(String playerName) {\r\n        this.playerName \u003d playerName;\r\n    }\r\n\r\n    public void requestGlobalScore() {\r\n        msgSender.sendMsg(new InfoRequestMsg(InfoRequestMsg.GET_OVERALL_SCORE));\r\n    }\r\n\r\n    public void setGlobalscores(ArrayList scores) {\r\n        StartFrame.getInstance().setGlobalScore(scores);\r\n    }\r\n\r\n    public void setRoundScore(HashMap\u003cString, Integer\u003e rndscore) {\r\n        logger.info(\"setting round score\");\r\n        StartFrame.getInstance().updateRoundScoreData(rndscore);\r\n    }\r\n\r\n    public void setSessionScore(HashMap\u003cString, Integer\u003e rndscore) {\r\n        logger.info(\"setting session score\");\r\n        StartFrame.getInstance().updateSessionScoreData(rndscore);\r\n    }\r\n\r\n    /**\r\n     * @param i\r\n     */\r\n    public void quitRunningSession(int playerId) {\r\n        getCurrentSession().getCurrentRound().terminateRound();\r\n        sendMsg(new ClientQuitRunningSessionMsg(playerId));\r\n        currentSession \u003d null;\r\n        StartFrame.getInstance().showGlobalLobby();\r\n    }\r\n}\r\n",
    "package": "client",
    "classname": "BomberClient",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/client/BomberClient_0Test.java",
    "test_prompt": "// BomberClient_0Test.java\npackage client;\n\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Observable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport messages.Message;\nimport messages.global.InfoRequestMsg;\nimport messages.global.JoinSessionMsg;\nimport messages.global.MapInfo;\nimport messages.global.SessionDetailsMsg;\nimport messages.round.ClientQuitRunningSessionMsg;\nimport org.apache.log4j.Logger;\nimport client.gui.StartFrame;\nimport client.network.ClientMsgReceiver;\nimport client.network.ClientMsgSender;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BomberClient}.\n* It contains ten unit test cases for the {@link BomberClient#getInstance()} method.\n*/\nclass BomberClient_0Test {",
    "method_signature": "getInstance()",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// BomberClient.java\npackage client;\r\n\r\nimport java.io.IOException;\r\nimport java.net.Socket;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Observable;\r\nimport java.util.Vector;\r\nimport javax.swing.ImageIcon;\r\nimport messages.Message;\r\nimport messages.global.InfoRequestMsg;\r\nimport messages.global.JoinSessionMsg;\r\nimport messages.global.MapInfo;\r\nimport messages.global.SessionDetailsMsg;\r\nimport messages.round.ClientQuitRunningSessionMsg;\r\nimport org.apache.log4j.Logger;\r\nimport client.gui.StartFrame;\r\nimport client.network.ClientMsgReceiver;\r\nimport client.network.ClientMsgSender;\r\n\r\n/**\r\n * This is central client class. It is responsible for globally scoped messages\r\n * and the creation of sessions.\r\n *\r\n * @author andi\r\n */\r\npublic class BomberClient extends Observable {\r\n\r\n    // for logging\r\n    private static Logger logger \u003d Logger.getLogger(BomberClient.class);\r\n\r\n    /**\r\n     * The socket that is used to communicate with the server.\r\n     */\r\n    public Socket server;\r\n\r\n    /**\r\n     * The ip address of the server.\r\n     */\r\n    private String serverName \u003d \"localhost\";\r\n\r\n    /**\r\n     * The port on the server to connect to.\r\n     */\r\n    private int serverPort \u003d 6666;\r\n\r\n    /**\r\n     * The name of the player that is running this client.\r\n     */\r\n    private String playerName;\r\n\r\n    private ClientMsgReceiver msgReceiver;\r\n\r\n    private ClientMsgSender msgSender;\r\n\r\n    /**\r\n     * The id offset of this client. Generated ids will be in the range from\r\n     * idOffset to idOffset + 1000000.\r\n     */\r\n    private int idOffset \u003d -1;\r\n\r\n    /**\r\n     * Singleton instance\r\n     */\r\n    private static BomberClient instance;\r\n\r\n    /**\r\n     * The currently used (and sole) session.\r\n     */\r\n    private ClientGameSession currentSession;\r\n\r\n    /**\r\n     * A list of sessions that are running on the server.\r\n     */\r\n    private Vector\u003cSessionDetailsMsg\u003e availableSessions \u003d new Vector\u003cSessionDetailsMsg\u003e();\r\n\r\n    /**\r\n     * A list of maps that are availbale on the server.\r\n     */\r\n    private Vector\u003cMapInfo\u003e availableMaps;\r\n\r\n    private ClientGameSession requestedSession;\r\n\r\n    /**\r\n     * @return The current game session.\r\n     */\r\n    public ClientGameSession getCurrentSession() {\r\n        return currentSession;\r\n    }\r\n\r\n    /**\r\n     * Creates a new BomberClient. Use getInstance() to aquire an instance.\r\n     *\r\n     * @param playerName\r\n     *            The name of the player on this client.\r\n     */\r\n    private BomberClient(String playerName) {\r\n        this.playerName \u003d playerName;\r\n        availableMaps \u003d new Vector\u003cMapInfo\u003e();\r\n    }\r\n\r\n    /**\r\n     * Returns the singleton.\r\n     *\r\n     * @return The only BomberClient instance.\r\n     */\r\n    public static BomberClient getInstance() {\r\n        if (instance \u003d\u003d null) {\r\n            logger.info(\"Creating BomberClient singleton instance\");\r\n            instance \u003d new BomberClient(\"client\");\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * Tries to connect to the server.\r\n     *\r\n     * @throws RuntimeException\r\n     *             Thrown when the connection attempt was not successful.\r\n     */\r\n    public boolean connectToSrv() {\r\n        try {\r\n            //System.out.println(\"Connecting...\");\r\n            logger.info(\"Establishing a connection \");\r\n            server \u003d new Socket(serverName, serverPort);\r\n            msgSender \u003d new ClientMsgSender(server);\r\n            msgSender.start();\r\n            msgReceiver \u003d new ClientMsgReceiver(server, BomberClient.this);\r\n            msgReceiver.start();\r\n            msgSender.sendMsg(new InfoRequestMsg(InfoRequestMsg.GET_SESSION_LIST));\r\n            logger.info(\"connected to \" + serverName);\r\n            return true;\r\n        } catch (IOException e) {\r\n            // TODO Auto-generated catch block\r\n            // e.printStackTrace();\r\n            logger.info(\"Connection failed\");\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sends a message to the server. The passed object will be serialized and\r\n     * transmitted to the server.\r\n     *\r\n     * @param msg\r\n     *            The message to send.\r\n     */\r\n    public void sendMsg(Message msg) {\r\n        msgSender.sendMsg(msg);\r\n    }\r\n\r\n    /**\r\n     * Creates a new id that is guaranteed to be unique for this class.\r\n     *\r\n     * @return The next valid id for this class.\r\n     */\r\n    public int getNextId() {\r\n        return ++idOffset;\r\n    }\r\n\r\n    /**\r\n     * Sets the id offset.\r\n     *\r\n     * @param idOffset\r\n     *            to set\r\n     */\r\n    public void setIdOffset(int idOffset) {\r\n        this.idOffset \u003d idOffset;\r\n    }\r\n\r\n    /**\r\n     * Sets the current session.\r\n     *\r\n     * @param The\r\n     *            ClientGameSession to set.\r\n     */\r\n    public void setCurrentSession(ClientGameSession currentSession) {\r\n        this.currentSession \u003d currentSession;\r\n    }\r\n\r\n    /**\r\n     * Create a new session on the server. The given arguments are rolled up\r\n     * into a SessionDetailsMsg and sent to the server.\r\n     *\r\n     * @param name\r\n     *            The name for the new session.\r\n     * @param maps\r\n     *            A list of map names that will be used for this session\r\n     * @param totalPlayers\r\n     *            The total number of players.\r\n     * @param rounds\r\n     *            The number of rounds to play.\r\n     */\r\n    public void createSession(String name, List\u003cString\u003e maps, ImageIcon mapPreview, int totalPlayers, int rounds) {\r\n        SessionDetailsMsg sessionDetailsMsg \u003d new SessionDetailsMsg(name, maps, mapPreview, totalPlayers, totalPlayers, rounds);\r\n        this.requestedSession \u003d new ClientGameSession(name, maps, mapPreview, totalPlayers, rounds, idOffset);\r\n        msgSender.sendMsg(sessionDetailsMsg);\r\n    }\r\n\r\n    public void openSession() {\r\n        requestedSession.setIdOffset(idOffset);\r\n        setCurrentSession(requestedSession);\r\n        logger.info(\"opened session: \" + currentSession.getName());\r\n    }\r\n\r\n    /**\r\n     * Requests a list of active sessions on the server.\r\n     */\r\n    public void requestSessionList() {\r\n        InfoRequestMsg sessionRequest \u003d new InfoRequestMsg(InfoRequestMsg.GET_SESSION_LIST);\r\n        sendMsg(sessionRequest);\r\n    }\r\n\r\n    /**\r\n     * Requests a list of available maps from the server.\r\n     */\r\n    public void requestMapList() {\r\n        InfoRequestMsg mapRequest \u003d new InfoRequestMsg(InfoRequestMsg.GET_MAP_LIST);\r\n        sendMsg(mapRequest);\r\n    }\r\n\r\n    /**\r\n     * Returns a list of active sessions on the server. Invoke\r\n     * requestSessionList() to update this list.\r\n     *\r\n     * @return\r\n     */\r\n    public Vector\u003cSessionDetailsMsg\u003e getAvailableSessions() {\r\n        return availableSessions;\r\n    }\r\n\r\n    /**\r\n     * @param sessionInfos\r\n     */\r\n    public void setAvailableSessions(Vector\u003cSessionDetailsMsg\u003e sessionInfos) {\r\n        availableSessions.clear();\r\n        availableSessions.addAll(sessionInfos);\r\n        // TODO observer\r\n        StartFrame.getInstance().setAvailableSessions(availableSessions);\r\n    }\r\n\r\n    /**\r\n     * @param maps\r\n     */\r\n    public void setAvailableMaps(List\u003cMapInfo\u003e maps) {\r\n        availableMaps.clear();\r\n        availableMaps.addAll(maps);\r\n        // TODO observer\r\n        StartFrame.getInstance().setAvailableMaps(availableMaps);\r\n    }\r\n\r\n    /**\r\n     * @return the availableMaps\r\n     */\r\n    public Vector\u003cMapInfo\u003e getAvailableMaps() {\r\n        return availableMaps;\r\n    }\r\n\r\n    /**\r\n     * Creates a session from the details specified in the given\r\n     * SessionDetailMsg.\r\n     *\r\n     * @param session\r\n     *            The session to open on this client.\r\n     */\r\n    public void createSession(SessionDetailsMsg sessionDetails) {\r\n        ClientGameSession session \u003d new ClientGameSession(sessionDetails.getGameName(), sessionDetails.getMaps(), sessionDetails.getPreview(), sessionDetails.getNrOfPlayers(), sessionDetails.getTotalRounds(), idOffset);\r\n        requestedSession \u003d session;\r\n        JoinSessionMsg joinMsg \u003d new JoinSessionMsg(session.getName(), playerName);\r\n        msgSender.sendMsg(joinMsg);\r\n    }\r\n\r\n    /**\r\n     * Sets the server-name\r\n     *\r\n     * @author Bj�rn\r\n     */\r\n    public void setServerName(String serverName) {\r\n        this.serverName \u003d serverName;\r\n    }\r\n\r\n    /**\r\n     * Sets the server-port\r\n     *\r\n     * @author Bj�rn\r\n     */\r\n    public void setServerPort(int serverPort) {\r\n        this.serverPort \u003d serverPort;\r\n    }\r\n\r\n    /**\r\n     * @param sender\r\n     * @param msg\r\n     */\r\n    public void addChatGlobal(String sender, String msg) {\r\n        logger.info(\"omg asd rofl\");\r\n        StartFrame.getInstance().addChatMessageGlobal(sender, msg);\r\n    }\r\n\r\n    /**\r\n     * @param sender\r\n     * @param msg\r\n     */\r\n    public void addChatSession(String sender, String msg) {\r\n        StartFrame.getInstance().addChatMessageSession(sender, msg);\r\n    }\r\n\r\n    public void discardSessionRequest() {\r\n        requestedSession \u003d null;\r\n    }\r\n\r\n    /**\r\n     * Closes the current session.\r\n     */\r\n    public void closeSession() {\r\n        // TODO session highscore presentation\r\n        currentSession \u003d null;\r\n        StartFrame sFrame \u003d StartFrame.getInstance();\r\n        sFrame.showGlobalLobby();\r\n    }\r\n\r\n    /**\r\n     * Closes the current session.\r\n     */\r\n    public void closeSessionAndShowHighscores() {\r\n        // TODO session highscore presentation\r\n        currentSession \u003d null;\r\n        StartFrame sFrame \u003d StartFrame.getInstance();\r\n        sFrame.showHighscoreLobby();\r\n    }\r\n\r\n    /**\r\n     * Leave the current session.\r\n     */\r\n    public void leaveSession() {\r\n        if (currentSession !\u003d null) {\r\n            currentSession.leave();\r\n        }\r\n        currentSession \u003d null;\r\n        StartFrame sFrame \u003d StartFrame.getInstance();\r\n        sFrame.showGlobalLobby();\r\n    }\r\n\r\n    public void closeConnection() {\r\n        msgReceiver.closeConnection();\r\n    }\r\n\r\n    public String getPlayerName() {\r\n        return playerName;\r\n    }\r\n\r\n    public void setPlayerName(String playerName) {\r\n        this.playerName \u003d playerName;\r\n    }\r\n\r\n    public void requestGlobalScore() {\r\n        msgSender.sendMsg(new InfoRequestMsg(InfoRequestMsg.GET_OVERALL_SCORE));\r\n    }\r\n\r\n    public void setGlobalscores(ArrayList scores) {\r\n        StartFrame.getInstance().setGlobalScore(scores);\r\n    }\r\n\r\n    public void setRoundScore(HashMap\u003cString, Integer\u003e rndscore) {\r\n        logger.info(\"setting round score\");\r\n        StartFrame.getInstance().updateRoundScoreData(rndscore);\r\n    }\r\n\r\n    public void setSessionScore(HashMap\u003cString, Integer\u003e rndscore) {\r\n        logger.info(\"setting session score\");\r\n        StartFrame.getInstance().updateSessionScoreData(rndscore);\r\n    }\r\n\r\n    /**\r\n     * @param i\r\n     */\r\n    public void quitRunningSession(int playerId) {\r\n        getCurrentSession().getCurrentRound().terminateRound();\r\n        sendMsg(new ClientQuitRunningSessionMsg(playerId));\r\n        currentSession \u003d null;\r\n        StartFrame.getInstance().showGlobalLobby();\r\n    }\r\n}\r\n",
    "package": "client",
    "classname": "BomberClient",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/client/BomberClient_1Test.java",
    "test_prompt": "// BomberClient_1Test.java\npackage client;\n\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Observable;\nimport java.util.Vector;\nimport javax.swing.ImageIcon;\nimport messages.Message;\nimport messages.global.InfoRequestMsg;\nimport messages.global.JoinSessionMsg;\nimport messages.global.MapInfo;\nimport messages.global.SessionDetailsMsg;\nimport messages.round.ClientQuitRunningSessionMsg;\nimport org.apache.log4j.Logger;\nimport client.gui.StartFrame;\nimport client.network.ClientMsgReceiver;\nimport client.network.ClientMsgSender;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BomberClient}.\n* It contains ten unit test cases for the {@link BomberClient#connectToSrv()} method.\n*/\nclass BomberClient_1Test {",
    "method_signature": "connectToSrv()",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// GfxFactory.java\npackage client.view;\n\nimport java.awt.Image;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport javax.imageio.ImageIO;\nimport org.apache.log4j.Logger;\nimport common.ResourceService;\n\n/**\n * @author Andreas Glauner\n * @autor Adam Kozielski\n */\npublic class GfxFactory {\n\n    private HashMap\u003cInteger, Image\u003e wallImageCache;\n\n    private HashMap\u003cString, Image\u003e tileImageCache;\n\n    private HashMap\u003cString, Image\u003e powerUpImageCache;\n\n    private HashMap\u003cString, Image\u003e o;\n\n    private HashMap\u003cInteger, Image\u003e[] playerImageCache;\n\n    private HashMap\u003cInteger, Image\u003e[] bombImageCache;\n\n    private HashMap\u003cInteger, Integer\u003e idTranslator;\n\n    private HashMap\u003cInteger, Image\u003e[] explosionImageCache;\n\n    private ExplosionGfxFactory explosionGfxFactory;\n\n    private int currentId \u003d 1;\n\n    private static String basePath \u003d \"/gfx\";\n\n    private String tileSet \u003d \"ice\";\n\n    private Logger logger \u003d Logger.getLogger(GfxFactory.class);\n\n    public GfxFactory() {\n        wallImageCache \u003d new HashMap\u003cInteger, Image\u003e();\n        playerImageCache \u003d new HashMap[9];\n        for (int i \u003d 0; i \u003c 9; i++) {\n            playerImageCache[i] \u003d new HashMap\u003cInteger, Image\u003e();\n        }\n        bombImageCache \u003d new HashMap[9];\n        for (int i \u003d 0; i \u003c 9; i++) {\n            bombImageCache[i] \u003d new HashMap\u003cInteger, Image\u003e();\n        }\n        explosionImageCache \u003d new HashMap[9];\n        for (int i \u003d 0; i \u003c 9; i++) {\n            explosionImageCache[i] \u003d new HashMap\u003cInteger, Image\u003e();\n        }\n        idTranslator \u003d new HashMap\u003cInteger, Integer\u003e();\n        explosionGfxFactory \u003d new ExplosionGfxFactory();\n        tileImageCache \u003d new HashMap\u003cString, Image\u003e();\n        powerUpImageCache \u003d new HashMap\u003cString, Image\u003e();\n    }\n\n    /**\n     * @param id The player id.\n     * @param state\n     * @return\n     */\n    public Image getPlayerImage(int id, int state) {\n        int key \u003d translateId(id);\n        if (!playerImageCache[key].containsKey(state)) {\n            playerImageCache[key].put(state, loadImage((basePath + \"/player/\" + key + \"/\" + state + \".png\")));\n        }\n        return playerImageCache[key].get(state);\n    }\n\n    public Image getTileImage(String type) {\n        if (!tileImageCache.keySet().contains(type)) {\n            String path \u003d \"/gfx/map/\" + tileSet + \"/\" + type + \".png\";\n            tileImageCache.put(type, loadImage(path));\n        }\n        return tileImageCache.get(type);\n    }\n\n    private int translateId(int id) {\n        if (!idTranslator.containsKey(id)) {\n            idTranslator.put(id, currentId);\n            currentId \u003d currentId + 1;\n        }\n        return idTranslator.get(id);\n    }\n\n    private Image loadImage(String path) {\n        return ResourceService.getImage(path);\n    }\n\n    /**\n     * @param id The planter\u0027s id.\n     * @return\n     */\n    public Image getBombImage(int id) {\n        int key \u003d translateId(id);\n        if (!bombImageCache[key].containsKey(0)) {\n            bombImageCache[key].put(0, loadImage(basePath + \"/player/\" + key + \"/bomb.png\"));\n        }\n        return bombImageCache[key].get(0);\n    }\n\n    /**\n     * @param id The planter\u0027s id.\n     * @return\n     */\n    public Image getBombImage(int id, int state) {\n        int key \u003d translateId(id);\n        if (!bombImageCache[key].containsKey(state)) {\n            bombImageCache[key].put(state, loadImage(basePath + \"/player/\" + key + \"/bomb\" + state + \".png\"));\n        }\n        return bombImageCache[key].get(state);\n    }\n\n    public Image getExplosionImage(int diameter, int id) {\n        int key \u003d translateId(id);\n        if (!explosionImageCache[key].containsKey(diameter)) {\n            explosionImageCache[key].put(diameter, explosionGfxFactory.getExplosionImage(diameter, translateId(id)));\n        }\n        return explosionImageCache[key].get(diameter);\n    }\n\n    public void setTileSet(String tileSet) {\n        this.tileSet \u003d tileSet;\n    }\n\n    public Image getWallImage(int state) {\n        if (!wallImageCache.containsKey(state)) {\n            wallImageCache.put(state, loadImage(basePath + \"/map/\" + tileSet + \"/wall\" + state + \".png\"));\n        }\n        return wallImageCache.get(state);\n    }\n\n    /**\n     * Power up image loading\n     * @param type A String value describing the type of powerUp\n     *  *\n     */\n    public Image getPowerUpImage(String type) {\n        if (!powerUpImageCache.keySet().contains(type)) {\n            String path \u003d \"/gfx/powerUps/\" + type + \".png\";\n            powerUpImageCache.put(type, loadImage(path));\n        }\n        return powerUpImageCache.get(type);\n    }\n}\n",
    "package": "client.view",
    "classname": "GfxFactory",
    "id": "/EvoSuiteBenchmark/original/57_hft-bomberman/src/main/java/client/view/GfxFactory_6Test.java",
    "test_prompt": "// GfxFactory_6Test.java\npackage client.view;\n\nimport java.awt.Image;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport javax.imageio.ImageIO;\nimport org.apache.log4j.Logger;\nimport common.ResourceService;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GfxFactory}.\n* It contains ten unit test cases for the {@link GfxFactory#getPowerUpImage(String)} method.\n*/\nclass GfxFactory_6Test {",
    "method_signature": "getPowerUpImage(String)",
    "suffix": "6"
  }
]