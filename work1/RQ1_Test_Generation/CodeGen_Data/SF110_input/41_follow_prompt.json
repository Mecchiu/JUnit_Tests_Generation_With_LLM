[
  {
    "numberTests": "ten",
    "original_code": "// EnumeratedProperties.java\n/* \nCopyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n\nThis file is part of Follow (http://follow.sf.net).\n\nFollow is free software; you can redistribute it and/or modify\nit under the terms of version 2 of the GNU General Public\nLicense as published by the Free Software Foundation.\n\nFollow is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Follow; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\npackage ghm.follow.config;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Extension of {@link java.util.Properties} which allows one to specify property values which are\n * Lists of Strings.\n *\n * @author \u003ca href\u003d\"mailto:greghmerrill@yahoo.com\"\u003eGreg Merrill\u003c/a\u003e\n */\npublic class EnumeratedProperties extends Properties {\n\n    /**\n     * Returns the List value of the property with the supplied key. Note that one can call\n     * getEnumeratedProperty() for a given key successfully if and only if setEnumeratedProperty()\n     * for that key was called some time beforehand. All members of the list returned will be\n     * Strings.\n     *\n     * @param key\n     *            lookup of the enumerated property to be retrieved.\n     * @return list containing String values\n     */\n    public List\u003cString\u003e getEnumeratedProperty(String key) {\n        ArrayList\u003cString\u003e values \u003d new ArrayList\u003cString\u003e();\n        int i \u003d 0;\n        String value;\n        while ((value \u003d this.getProperty(key + delimiter + i++)) !\u003d null) {\n            values.add(value);\n        }\n        return values;\n    }\n\n    /**\n     * Assigns the supplied array of String values to the supplied key.\n     *\n     * @param key\n     *            property lookup\n     * @param values\n     *            values to be associated with the property lookup\n     */\n    public void setEnumeratedProperty(String key, List\u003cString\u003e values) {\n        int i \u003d 0;\n        for (; i \u003c values.size(); i++) {\n            setProperty(key + delimiter + i, values.get(i));\n        }\n        while (getProperty(key + delimiter + i) !\u003d null) {\n            remove(key + delimiter + i);\n            i++;\n        }\n    }\n\n    /**\n     * Delimiter between property name \u0026 list member index\n     */\n    protected static char delimiter \u003d \u0027.\u0027;\n}\n",
    "package": "ghm.follow.config",
    "classname": "EnumeratedProperties",
    "id": "/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/config/EnumeratedProperties.java",
    "test_prompt": "// EnumeratedPropertiesTest.java\npackage ghm.follow.config;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EnumeratedProperties}.\n* It contains ten unit test cases for the {@link EnumeratedProperties#getEnumeratedProperty(String)} method.\n*/\nclass EnumeratedPropertiesTest {",
    "method_signature": "getEnumeratedProperty(String)",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// JTextPaneDestination.java\n/* \n Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n\n This file is part of Follow (http://follow.sf.net).\n\n Follow is free software; you can redistribute it and/or modify\n it under the terms of version 2 of the GNU General Public\n License as published by the Free Software Foundation.\n\n Follow is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Follow; if not, write to the Free Software\n Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\npackage ghm.follow.io;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JTextPane;\nimport javax.swing.text.BadLocationException;\n\n/**\n * Implementation of {@link OutputDestination} which appends Strings to a {@link JTextPane}.\n *\n * @see OutputDestination\n * @see JTextPane\n * @author \u003ca href\u003d\"mailto:carl.hall@gmail.com\"\u003eCarl Hall\u003c/a\u003e\n */\npublic class JTextPaneDestination implements OutputDestination {\n\n    private Logger log \u003d Logger.getLogger(JTextPaneDestination.class.getName());\n\n    protected JTextPane jTextPane;\n\n    protected boolean autoPositionCaret;\n\n    /**\n     * Construct a new JTextPaneDestination.\n     *\n     * @param jTextPane\n     *            text will be appended to this text area\n     * @param autoPositionCaret\n     *            if true, caret will be automatically moved to the bottom of the text area when\n     *            text is appended\n     */\n    public JTextPaneDestination(JTextPane jTextPane, boolean autoPositionCaret) {\n        this.jTextPane \u003d jTextPane;\n        this.autoPositionCaret \u003d autoPositionCaret;\n    }\n\n    public JTextPane getJTextPane() {\n        return jTextPane;\n    }\n\n    public void setJTextArea(JTextPane jTextPane) {\n        this.jTextPane \u003d jTextPane;\n    }\n\n    /**\n     * Add a filtered view to this destination. Filtered views show only a subset of the total\n     * output based on filter conditions.\n     *\n     * @since 1.8.0\n     */\n    public void addFilteredView() {\n    }\n\n    /**\n     * Remove a filtered view\n     *\n     * @since 1.8.0\n     */\n    public void removeFilteredView() {\n    }\n\n    /**\n     * @return whether caret will be automatically moved to the bottom of the text area when text is\n     *         appended\n     */\n    public boolean autoPositionCaret() {\n        return autoPositionCaret;\n    }\n\n    /**\n     * @param autoPositionCaret\n     *            if true, caret will be automatically moved to the bottom of the text area when\n     *            text is appended\n     */\n    public void setAutoPositionCaret(boolean autoPositionCaret) {\n        this.autoPositionCaret \u003d autoPositionCaret;\n    }\n\n    public void print(String s) {\n        try {\n            jTextPane.getDocument().insertString(jTextPane.getDocument().getLength(), s, null);\n            if (autoPositionCaret) {\n                jTextPane.setCaretPosition(jTextPane.getDocument().getLength());\n            }\n        } catch (BadLocationException e) {\n            // just ignore, nothing we can do\n            log.log(Level.SEVERE, \"BadLocationException in JTextPaneDestination\", e);\n        }\n    }\n\n    public void clear() {\n        jTextPane.setText(\"\");\n        if (autoPositionCaret) {\n            jTextPane.setCaretPosition(0);\n        }\n    }\n}\n",
    "package": "ghm.follow.io",
    "classname": "JTextPaneDestination",
    "id": "/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/io/JTextPaneDestination.java",
    "test_prompt": "// JTextPaneDestinationTest.java\npackage ghm.follow.io;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JTextPane;\nimport javax.swing.text.BadLocationException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JTextPaneDestination}.\n* It contains ten unit test cases for the {@link JTextPaneDestination#autoPositionCaret()} method.\n*/\nclass JTextPaneDestinationTest {",
    "method_signature": "autoPositionCaret()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// JTextComponentDestination.java\n/* \n Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n\n This file is part of Follow (http://follow.sf.net).\n\n Follow is free software; you can redistribute it and/or modify\n it under the terms of version 2 of the GNU General Public\n License as published by the Free Software Foundation.\n\n Follow is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Follow; if not, write to the Free Software\n Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\npackage ghm.follow.io;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.JTextComponent;\n\n/**\n * Implementation of {@link OutputDestination} which appends Strings to a {@link JTextComponent}.\n *\n * @see OutputDestination\n * @see JTextCompnent\n * @author \u003ca href\u003d\"mailto:carl.hall@gmail.com\"\u003eCarl Hall\u003c/a\u003e\n */\npublic class JTextComponentDestination extends FilterableOutputDestination {\n\n    private static final Logger LOG \u003d Logger.getLogger(JTextComponentDestination.class.getName());\n\n    protected JTextComponent comp;\n\n    protected boolean autoPositionCaret;\n\n    /**\n     * Construct a new JTextCompnentDestination.\n     *\n     * @param jTextPane\n     *            text will be appended to this text area\n     * @param autoPositionCaret\n     *            if true, caret will be automatically moved to the bottom of the text area when\n     *            text is appended\n     */\n    public JTextComponentDestination(JTextComponent comp, boolean autoPositionCaret) {\n        this.comp \u003d comp;\n        this.autoPositionCaret \u003d autoPositionCaret;\n    }\n\n    public JTextComponent getJTextComponent() {\n        return comp;\n    }\n\n    public void setJTextComponent(JTextComponent comp) {\n        this.comp \u003d comp;\n    }\n\n    /**\n     * Add a filtered view to this destination. Filtered views show only a subset of the total\n     * output based on filter conditions.\n     *\n     * @since 1.8.0\n     */\n    public void addFilteredView() {\n    }\n\n    /**\n     * Remove a filtered view\n     *\n     * @since 1.8.0\n     */\n    public void removeFilteredView() {\n    }\n\n    /**\n     * @return whether caret will be automatically moved to the bottom of the text area when text is\n     *         appended\n     */\n    public boolean autoPositionCaret() {\n        return autoPositionCaret;\n    }\n\n    /**\n     * @param autoPositionCaret\n     *            if true, caret will be automatically moved to the bottom of the text area when\n     *            text is appended\n     */\n    public void setAutoPositionCaret(boolean autoPositionCaret) {\n        this.autoPositionCaret \u003d autoPositionCaret;\n    }\n\n    public void handlePrint(String s) {\n        try {\n            comp.getDocument().insertString(comp.getDocument().getLength(), s, null);\n            if (autoPositionCaret) {\n                comp.setCaretPosition(comp.getDocument().getLength());\n            }\n        } catch (BadLocationException e) {\n            // just ignore, nothing we can do\n            LOG.log(Level.SEVERE, \"BadLocationException in JTextComponentDestination\", e);\n        }\n    }\n\n    public void clear() {\n        comp.setText(\"\");\n        if (autoPositionCaret) {\n            comp.setCaretPosition(0);\n        }\n    }\n}\n",
    "package": "ghm.follow.io",
    "classname": "JTextComponentDestination",
    "id": "/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/io/JTextComponentDestination.java",
    "test_prompt": "// JTextComponentDestinationTest.java\npackage ghm.follow.io;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.JTextComponent;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JTextComponentDestination}.\n* It contains ten unit test cases for the {@link JTextComponentDestination#autoPositionCaret()} method.\n*/\nclass JTextComponentDestinationTest {",
    "method_signature": "autoPositionCaret()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// SearchableTextPane.java\npackage ghm.follow.search;\n\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Font;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JTextArea;\nimport javax.swing.plaf.ComponentUI;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\nimport javax.swing.text.Element;\nimport javax.swing.text.Utilities;\nimport javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;\n\npublic class SearchableTextPane extends JTextArea {\n\n    private Logger log \u003d Logger.getLogger(SearchableTextPane.class.getName());\n\n    private int lastSearchPos \u003d -1;\n\n    private String lastSearchTerm;\n\n    private final DefaultHighlightPainter wordPainter \u003d new DefaultHighlightPainter(Color.YELLOW);\n\n    public SearchableTextPane(Font font, int tabSize) {\n        // set the display font\n        setFont(font);\n        setTabSize(tabSize);\n    }\n\n    /**\n     * Override this to keep the text from wrapping and to make the viewable area as wide as the\n     * tabbed pane\n     */\n    public boolean getScrollableTracksViewportWidth() {\n        Component parent \u003d getParent();\n        ComponentUI ui \u003d getUI();\n        return parent !\u003d null ? (ui.getPreferredSize(this).width \u003c\u003d parent.getSize().width) : true;\n    }\n\n    /**\n     * Highlight \u003ccode\u003eterm\u003c/code\u003e wherever it is found in the view. Also highlights the entire\n     * line on which the term is found.\n     *\n     * @param term\n     * @param caseSensitive\n     * @param useRegularExpression\n     * @return\n     */\n    public List\u003cLineResult\u003e highlight(String term, int flags) {\n        List\u003cLineResult\u003e lineResults \u003d new ArrayList\u003cLineResult\u003e();\n        // Remove all old highlights\n        removeHighlights();\n        // Search for pattern\n        if ((term !\u003d null) \u0026\u0026 (term.length() \u003e 0)) {\n            // look for instances of the term in the text\n            try {\n                Document doc \u003d getDocument();\n                String text \u003d doc.getText(0, doc.getLength());\n                List\u003cWordResult\u003e searchResults \u003d new SearchEngine(flags).search(term, text);\n                lineResults \u003d convertWords2Lines(searchResults);\n                for (LineResult lineResult : lineResults) {\n                    List\u003cWordResult\u003e wordResults \u003d lineResult.getWordResults();\n                    for (WordResult wordResult : wordResults) {\n                        // highlight the searched term\n                        int wordStart \u003d wordResult.start;\n                        int wordEnd \u003d wordResult.end;\n                        addHighlight(wordStart, wordEnd - wordStart);\n                        Thread.yield();\n                    }\n                }\n            } catch (BadLocationException e) {\n                log.log(Level.SEVERE, \"BadLocationException in SearchableTextPane\", e);\n                lineResults \u003d new ArrayList\u003cLineResult\u003e();\n            }\n        }\n        return lineResults;\n    }\n\n    /**\n     * Highlight a piece of text in the document\n     *\n     * @param start\n     * @param wordEnd\n     * @param highlighter\n     */\n    private void addHighlight(int start, int length) throws BadLocationException {\n        getHighlighter().addHighlight(start, start + length, wordPainter);\n    }\n\n    /**\n     * Removes highlights from text area\n     */\n    public void removeHighlights() {\n        getHighlighter().removeAllHighlights();\n    }\n\n    /**\n     * Searches for a term. If the term provided matches the last searched term, the last found\n     * position is used as a starting point.\u003cbr\u003e\n     * \u003cbr\u003e\n     * Developer note: this method isn\u0027t currently used.\n     *\n     * @param term\n     *            The string for which to search.\n     * @return The position where the term was found.\u003cbr\u003e\n     *         If the term is null, empty or not found, -1 is returned.\n     */\n    public int search(String term) {\n        if (term !\u003d null \u0026\u0026 term.length() \u003e 0) {\n            if (term.equals(lastSearchTerm)) {\n                // assume to start at the beginning\n                int pos \u003d 0;\n                // if there is a previous search position, start there plus the\n                // length\n                // of the last term so that last term again isn\u0027t found again\n                if (lastSearchPos !\u003d -1) {\n                    pos \u003d lastSearchPos + lastSearchTerm.length();\n                }\n                lastSearchPos \u003d search(lastSearchTerm, pos);\n            } else {\n                lastSearchPos \u003d search(term, 0);\n            }\n        }\n        // remember the term if it was found\n        if (lastSearchPos \u003d\u003d -1) {\n            lastSearchTerm \u003d null;\n        } else {\n            lastSearchTerm \u003d term;\n        }\n        return lastSearchPos;\n    }\n\n    /**\n     * Searches for a term at the given starting position.\u003cbr\u003e\n     * \u003cbr\u003e\n     * Developer note: this method isn\u0027t currently used.\n     *\n     * @param term\n     *            The string for which to search.\n     * @param startPos\n     *            Where to start.\n     * @return The position where the term was found.\u003cbr\u003e\n     *         If the term is null, empty or not found, -1 is returned.\n     */\n    public int search(String term, int startPos) {\n        int pos \u003d 0;\n        try {\n            Document doc \u003d getDocument();\n            String text \u003d doc.getText(0, doc.getLength());\n            // Search for pattern\n            pos \u003d text.indexOf(term, startPos);\n        } catch (BadLocationException e) {\n            // just return -1;\n            log.log(Level.WARNING, \"BadLocationException in SearchableTextPane\", e);\n            pos \u003d -1;\n        }\n        return pos;\n    }\n\n    /**\n     * Converts word results from search into line results\n     *\n     * @param words\n     * @return\n     */\n    private List\u003cLineResult\u003e convertWords2Lines(List\u003cWordResult\u003e words) throws BadLocationException {\n        ArrayList\u003cLineResult\u003e lines \u003d new ArrayList\u003cLineResult\u003e();\n        LineResult tempLine \u003d null;\n        int lastLine \u003d -1;\n        for (WordResult word : words) {\n            int line \u003d getLineOfOffset(word.start);\n            if (line !\u003d lastLine) {\n                if (tempLine !\u003d null) {\n                    lines.add(tempLine);\n                }\n                Element elem \u003d Utilities.getParagraphElement(this, word.start);\n                int lineStart \u003d elem.getStartOffset();\n                int lineEnd \u003d elem.getEndOffset();\n                tempLine \u003d new LineResult(line, lineStart, lineEnd);\n            }\n            updateWordResult(word, tempLine);\n            lastLine \u003d line;\n            // allow other things to happen in case the search takes a while\n            Thread.yield();\n        }\n        if (tempLine !\u003d null) {\n            lines.add(tempLine);\n        }\n        return lines;\n    }\n\n    /**\n     * Adds word result to line result and updates line information\n     *\n     * @param wordResult\n     * @param lineResult\n     */\n    private void updateWordResult(WordResult wordResult, LineResult lineResult) throws BadLocationException {\n        lineResult.addWord(wordResult);\n        // increase by 1 because offset starts at 0.\n        // 1 is clearer to the user since most people don\u0027t start counting\n        // at 0\n        int line \u003d getLineOfOffset(wordResult.start);\n        wordResult.parent.lineNumber \u003d line + 1;\n        int lineOffset \u003d getLineStartOffset(line);\n        wordResult.setLineOffset(lineOffset);\n    }\n}\n",
    "package": "ghm.follow.search",
    "classname": "SearchableTextPane",
    "id": "/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/search/SearchableTextPane_1Test.java",
    "test_prompt": "// SearchableTextPane_1Test.java\npackage ghm.follow.search;\n\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Font;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JTextArea;\nimport javax.swing.plaf.ComponentUI;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\nimport javax.swing.text.Element;\nimport javax.swing.text.Utilities;\nimport javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchableTextPane}.\n* It contains ten unit test cases for the {@link SearchableTextPane#search(String)} method.\n*/\nclass SearchableTextPane_1Test {",
    "method_signature": "search(String)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// SearchableTextPane.java\npackage ghm.follow.search;\n\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Font;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JTextArea;\nimport javax.swing.plaf.ComponentUI;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\nimport javax.swing.text.Element;\nimport javax.swing.text.Utilities;\nimport javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;\n\npublic class SearchableTextPane extends JTextArea {\n\n    private Logger log \u003d Logger.getLogger(SearchableTextPane.class.getName());\n\n    private int lastSearchPos \u003d -1;\n\n    private String lastSearchTerm;\n\n    private final DefaultHighlightPainter wordPainter \u003d new DefaultHighlightPainter(Color.YELLOW);\n\n    public SearchableTextPane(Font font, int tabSize) {\n        // set the display font\n        setFont(font);\n        setTabSize(tabSize);\n    }\n\n    /**\n     * Override this to keep the text from wrapping and to make the viewable area as wide as the\n     * tabbed pane\n     */\n    public boolean getScrollableTracksViewportWidth() {\n        Component parent \u003d getParent();\n        ComponentUI ui \u003d getUI();\n        return parent !\u003d null ? (ui.getPreferredSize(this).width \u003c\u003d parent.getSize().width) : true;\n    }\n\n    /**\n     * Highlight \u003ccode\u003eterm\u003c/code\u003e wherever it is found in the view. Also highlights the entire\n     * line on which the term is found.\n     *\n     * @param term\n     * @param caseSensitive\n     * @param useRegularExpression\n     * @return\n     */\n    public List\u003cLineResult\u003e highlight(String term, int flags) {\n        List\u003cLineResult\u003e lineResults \u003d new ArrayList\u003cLineResult\u003e();\n        // Remove all old highlights\n        removeHighlights();\n        // Search for pattern\n        if ((term !\u003d null) \u0026\u0026 (term.length() \u003e 0)) {\n            // look for instances of the term in the text\n            try {\n                Document doc \u003d getDocument();\n                String text \u003d doc.getText(0, doc.getLength());\n                List\u003cWordResult\u003e searchResults \u003d new SearchEngine(flags).search(term, text);\n                lineResults \u003d convertWords2Lines(searchResults);\n                for (LineResult lineResult : lineResults) {\n                    List\u003cWordResult\u003e wordResults \u003d lineResult.getWordResults();\n                    for (WordResult wordResult : wordResults) {\n                        // highlight the searched term\n                        int wordStart \u003d wordResult.start;\n                        int wordEnd \u003d wordResult.end;\n                        addHighlight(wordStart, wordEnd - wordStart);\n                        Thread.yield();\n                    }\n                }\n            } catch (BadLocationException e) {\n                log.log(Level.SEVERE, \"BadLocationException in SearchableTextPane\", e);\n                lineResults \u003d new ArrayList\u003cLineResult\u003e();\n            }\n        }\n        return lineResults;\n    }\n\n    /**\n     * Highlight a piece of text in the document\n     *\n     * @param start\n     * @param wordEnd\n     * @param highlighter\n     */\n    private void addHighlight(int start, int length) throws BadLocationException {\n        getHighlighter().addHighlight(start, start + length, wordPainter);\n    }\n\n    /**\n     * Removes highlights from text area\n     */\n    public void removeHighlights() {\n        getHighlighter().removeAllHighlights();\n    }\n\n    /**\n     * Searches for a term. If the term provided matches the last searched term, the last found\n     * position is used as a starting point.\u003cbr\u003e\n     * \u003cbr\u003e\n     * Developer note: this method isn\u0027t currently used.\n     *\n     * @param term\n     *            The string for which to search.\n     * @return The position where the term was found.\u003cbr\u003e\n     *         If the term is null, empty or not found, -1 is returned.\n     */\n    public int search(String term) {\n        if (term !\u003d null \u0026\u0026 term.length() \u003e 0) {\n            if (term.equals(lastSearchTerm)) {\n                // assume to start at the beginning\n                int pos \u003d 0;\n                // if there is a previous search position, start there plus the\n                // length\n                // of the last term so that last term again isn\u0027t found again\n                if (lastSearchPos !\u003d -1) {\n                    pos \u003d lastSearchPos + lastSearchTerm.length();\n                }\n                lastSearchPos \u003d search(lastSearchTerm, pos);\n            } else {\n                lastSearchPos \u003d search(term, 0);\n            }\n        }\n        // remember the term if it was found\n        if (lastSearchPos \u003d\u003d -1) {\n            lastSearchTerm \u003d null;\n        } else {\n            lastSearchTerm \u003d term;\n        }\n        return lastSearchPos;\n    }\n\n    /**\n     * Searches for a term at the given starting position.\u003cbr\u003e\n     * \u003cbr\u003e\n     * Developer note: this method isn\u0027t currently used.\n     *\n     * @param term\n     *            The string for which to search.\n     * @param startPos\n     *            Where to start.\n     * @return The position where the term was found.\u003cbr\u003e\n     *         If the term is null, empty or not found, -1 is returned.\n     */\n    public int search(String term, int startPos) {\n        int pos \u003d 0;\n        try {\n            Document doc \u003d getDocument();\n            String text \u003d doc.getText(0, doc.getLength());\n            // Search for pattern\n            pos \u003d text.indexOf(term, startPos);\n        } catch (BadLocationException e) {\n            // just return -1;\n            log.log(Level.WARNING, \"BadLocationException in SearchableTextPane\", e);\n            pos \u003d -1;\n        }\n        return pos;\n    }\n\n    /**\n     * Converts word results from search into line results\n     *\n     * @param words\n     * @return\n     */\n    private List\u003cLineResult\u003e convertWords2Lines(List\u003cWordResult\u003e words) throws BadLocationException {\n        ArrayList\u003cLineResult\u003e lines \u003d new ArrayList\u003cLineResult\u003e();\n        LineResult tempLine \u003d null;\n        int lastLine \u003d -1;\n        for (WordResult word : words) {\n            int line \u003d getLineOfOffset(word.start);\n            if (line !\u003d lastLine) {\n                if (tempLine !\u003d null) {\n                    lines.add(tempLine);\n                }\n                Element elem \u003d Utilities.getParagraphElement(this, word.start);\n                int lineStart \u003d elem.getStartOffset();\n                int lineEnd \u003d elem.getEndOffset();\n                tempLine \u003d new LineResult(line, lineStart, lineEnd);\n            }\n            updateWordResult(word, tempLine);\n            lastLine \u003d line;\n            // allow other things to happen in case the search takes a while\n            Thread.yield();\n        }\n        if (tempLine !\u003d null) {\n            lines.add(tempLine);\n        }\n        return lines;\n    }\n\n    /**\n     * Adds word result to line result and updates line information\n     *\n     * @param wordResult\n     * @param lineResult\n     */\n    private void updateWordResult(WordResult wordResult, LineResult lineResult) throws BadLocationException {\n        lineResult.addWord(wordResult);\n        // increase by 1 because offset starts at 0.\n        // 1 is clearer to the user since most people don\u0027t start counting\n        // at 0\n        int line \u003d getLineOfOffset(wordResult.start);\n        wordResult.parent.lineNumber \u003d line + 1;\n        int lineOffset \u003d getLineStartOffset(line);\n        wordResult.setLineOffset(lineOffset);\n    }\n}\n",
    "package": "ghm.follow.search",
    "classname": "SearchableTextPane",
    "id": "/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/search/SearchableTextPane_2Test.java",
    "test_prompt": "// SearchableTextPane_2Test.java\npackage ghm.follow.search;\n\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Font;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JTextArea;\nimport javax.swing.plaf.ComponentUI;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\nimport javax.swing.text.Element;\nimport javax.swing.text.Utilities;\nimport javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SearchableTextPane}.\n* It contains ten unit test cases for the {@link SearchableTextPane#search(String, int)} method.\n*/\nclass SearchableTextPane_2Test {",
    "method_signature": "search(String, int)",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// FileFollowingPane.java\n/* \n Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n\n This file is part of Follow (http://follow.sf.net).\n\n Follow is free software; you can redistribute it and/or modify\n it under the terms of version 2 of the GNU General Public\n License as published by the Free Software Foundation.\n\n Follow is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with Follow; if not, write to the Free Software\n Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\npackage ghm.follow.gui;\n\nimport ghm.follow.FileFollower;\nimport ghm.follow.io.JTextComponentDestination;\nimport ghm.follow.io.OutputDestination;\nimport ghm.follow.search.SearchableTextPane;\nimport java.awt.Font;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JScrollPane;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\n\n/**\n * A component which allows one to view a text file to which information is being asynchronously\n * appended.\n *\n * @author \u003ca href\u003d\"mailto:greghmerrill@yahoo.com\"\u003eGreg Merrill\u003c/a\u003e\n */\npublic class FileFollowingPane extends JScrollPane {\n\n    private Logger log \u003d Logger.getLogger(FileFollowingPane.class.getName());\n\n    /**\n     * FileFollower used to print to this component\n     */\n    protected FileFollower fileFollower;\n\n    /**\n     * Text area into which followed file\u0027s contents are printed\n     */\n    protected SearchableTextPane textArea;\n\n    /**\n     * OutputDestination used w/FileFollower\n     */\n    protected JTextComponentDestination destination;\n\n    /**\n     * @param file\n     *            text file to be followed\n     * @param bufferSize\n     *            size of the character buffer inside the FileFollower used to follow the supplied\n     *            file\n     * @param latency\n     *            latency of the FileFollower used to follow the supplied file\n     */\n    public FileFollowingPane(File file, int bufferSize, int latency, boolean autoPositionCaret, Font font, int tabSize) {\n        textArea \u003d new SearchableTextPane(font, tabSize);\n        textArea.setEditable(false);\n        textArea.setUI(new LineTextUI());\n        destination \u003d new JTextComponentDestination(textArea, autoPositionCaret);\n        fileFollower \u003d new FileFollower(file, bufferSize, latency, new OutputDestination[] { destination });\n        add(textArea);\n        setViewportView(textArea);\n    }\n\n    /**\n     * Returns the text area to which the followed file\u0027s contents are being printed.\n     *\n     * @return text area containing followed file\u0027s contents\n     */\n    public SearchableTextPane getTextPane() {\n        return textArea;\n    }\n\n    /**\n     * Returns whether caret is automatically repositioned to the end of the text area when text is\n     * appended to the followed file\n     *\n     * @return whether caret is automatically repositioned on append\n     */\n    public boolean autoPositionCaret() {\n        return destination.autoPositionCaret();\n    }\n\n    /**\n     * Sets whether caret is automatically repositioned to the end of the text area when text is\n     * appended to the followed file\n     *\n     * @param value\n     *            whether caret is automatically repositioned on append\n     */\n    public void setAutoPositionCaret(boolean value) {\n        destination.setAutoPositionCaret(value);\n    }\n\n    /**\n     * Returns the FileFollower which is being used to print information in this component.\n     *\n     * @return FileFollower used by this component\n     */\n    public FileFollower getFileFollower() {\n        return fileFollower;\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().getFollowedFile()\n     */\n    public File getFollowedFile() {\n        return fileFollower.getFollowedFile();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().start()\n     */\n    public void startFollowing() {\n        fileFollower.start();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().stop()\n     */\n    public void stopFollowing() {\n        fileFollower.stop();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().restart()\n     */\n    public void restartFollowing() {\n        fileFollower.restart();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().pause()\n     */\n    public void pauseFollowing() {\n        fileFollower.pause();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().unpause()\n     */\n    public void unpauseFollowing() {\n        fileFollower.unpause();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().isPaused()\n     *\n     * @return\n     */\n    public boolean isFollowingPaused() {\n        return fileFollower.isPaused();\n    }\n\n    /**\n     * Convenience method; equivalent to calling getFileFollower().stopAndWait()\n     */\n    public void stopFollowingAndWait() throws InterruptedException {\n        fileFollower.stopAndWait();\n    }\n\n    /**\n     * Convenience method; equivalent to called getFileFollower().isBeingFollowed()\n     *\n     * @return\n     */\n    public boolean isFollowing() {\n        return fileFollower.isBeingFollowed();\n    }\n\n    /**\n     * Clears the contents of this FileFollowingPane synchronously.\n     */\n    public void clear() throws IOException {\n        if (fileFollower.getFollowedFile().length() \u003d\u003d 0L) {\n            return;\n        }\n        synchronized (fileFollower) {\n            try {\n                fileFollower.stopAndWait();\n            } catch (InterruptedException interruptedException) {\n                // Handle this better later\n                log.log(Level.SEVERE, \"InterrupedException in FileFollowingPane\", interruptedException);\n            }\n            // This has the effect of clearing the contents of the followed file\n            BufferedOutputStream bos \u003d new BufferedOutputStream(new FileOutputStream(fileFollower.getFollowedFile()));\n            bos.close();\n            // Update textarea contents to reflect freshly cleared file\n            Document doc \u003d textArea.getDocument();\n            try {\n                doc.remove(0, doc.getLength());\n            } catch (BadLocationException e) {\n                // Handle this better later\n                log.log(Level.WARNING, \"BadLocationException in FileFolloingPane\", e);\n            }\n            fileFollower.start();\n        }\n    }\n}\n",
    "package": "ghm.follow.gui",
    "classname": "FileFollowingPane",
    "id": "/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/gui/FileFollowingPane.java",
    "test_prompt": "// FileFollowingPaneTest.java\npackage ghm.follow.gui;\n\nimport ghm.follow.FileFollower;\nimport ghm.follow.io.JTextComponentDestination;\nimport ghm.follow.io.OutputDestination;\nimport ghm.follow.search.SearchableTextPane;\nimport java.awt.Font;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JScrollPane;\nimport javax.swing.text.BadLocationException;\nimport javax.swing.text.Document;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileFollowingPane}.\n* It contains ten unit test cases for the {@link FileFollowingPane#autoPositionCaret()} method.\n*/\nclass FileFollowingPaneTest {",
    "method_signature": "autoPositionCaret()",
    "suffix": ""
  },
  {
    "numberTests": "ten",
    "original_code": "// FileFollower.java\n/*\n * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n * \n * This file is part of Follow (http://follow.sf.net).\n * \n * Follow is free software; you can redistribute it and/or modify it under the\n * terms of version 2 of the GNU General Public License as published by the Free\n * Software Foundation.\n * \n * Follow is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License along with\n * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\n * Suite 330, Boston, MA 02111-1307 USA\n */\npackage ghm.follow;\n\nimport ghm.follow.io.OutputDestination;\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Instances of this class \u0027follow\u0027 a particular text file, assmebling that\n * file\u0027s characters into Strings and sending them to instances of\n * {@link OutputDestination}. The name and behavior of this class are inspired\n * by the \u0027-f\u0027 (follow) flag of the UNIX command \u0027tail\u0027.\n *\n * @see OutputDestination\n * @author \u003ca href\u003d\"mailto:greghmerrill@yahoo.com\"\u003eGreg Merrill\u003c/a\u003e\n */\npublic class FileFollower {\n\n    /**\n     * Constructs a new FileFollower; invoking this constructor does\n     * \u003cem\u003enot\u003c/em\u003e cause the new object to begin following the supplied file.\n     * In order to begin following, one must call {@link #start()}.\n     *\n     * @param file\n     *            file to be followed\n     * @param bufferSize\n     *            number of chars to be read each time the file is accessed\n     * @param latency\n     *            each time a FileFollower\u0027s running thread encounters the end\n     *            of the file in its stream, it will rest for this many\n     *            milliseconds before checking to see if there are any more\n     *            bytes in the file\n     * @param initialOutputDestinations\n     *            an initial array of OutputDestinations which will be used when\n     *            printing the contents of the file (this array may be\n     *            \u003ctt\u003enull\u003c/tt\u003e)\n     */\n    public FileFollower(File file, int bufferSize, int latency, OutputDestination[] initialOutputDestinations) {\n        this.file \u003d file;\n        this.bufferSize \u003d bufferSize;\n        this.latency \u003d latency;\n        int initOutputDestsSize \u003d (initialOutputDestinations !\u003d null) ? initialOutputDestinations.length : 0;\n        outputDestinations \u003d new ArrayList\u003cOutputDestination\u003e(initOutputDestsSize);\n        for (int i \u003d 0; i \u003c initOutputDestsSize; i++) {\n            outputDestinations.add(initialOutputDestinations[i]);\n        }\n    }\n\n    /**\n     * Identical to {@link #FileFollower(File, int, int, OutputDestination[])},\n     * except that a default buffer size (32,768 characters) and latency (1000\n     * milliseconds) are used.\n     *\n     * @see #FileFollower(File, int, int, OutputDestination[])\n     */\n    public FileFollower(File file, OutputDestination[] initialOutputDestinations) {\n        // Initial buffer size pilfered from org.gjt.sp.jedit.Buffer. I\u0027m not\n        // sure whether this is a truly optimal buffer size.\n        this(// Don\u0027t change without updating docs!\n        file, // Don\u0027t change without updating docs!\n        32768, // Don\u0027t change without updating docs!\n        1000, initialOutputDestinations);\n    }\n\n    /**\n     * Cause this FileFollower to spawn a thread which will follow the file\n     * supplied in the constructor and send its contents to all of the\n     * FileFollower\u0027s OutputDestinations.\u003cbr\u003e\n     * \u003cbr\u003e\n     * If this FileFollower is running but paused, this method equates to\n     * calling unpause().\n     */\n    public synchronized void start() {\n        if (continueRunning \u0026\u0026 paused) {\n            unpause();\n        } else {\n            continueRunning \u003d true;\n            paused \u003d false;\n            runnerThread \u003d new Thread(new Runner(), getFollowedFile().getName());\n            runnerThread.start();\n        }\n    }\n\n    public synchronized void pause() {\n        paused \u003d true;\n    }\n\n    public synchronized void unpause() {\n        paused \u003d false;\n    }\n\n    public synchronized void restart() {\n        needsRestart \u003d true;\n        runnerThread.interrupt();\n    }\n\n    /**\n     * Cause this FileFollower to stop following the file supplied in the\n     * constructor after it flushes the characters it\u0027s currently reading to all\n     * its OutputDestinations.\n     */\n    public synchronized void stop() {\n        continueRunning \u003d false;\n        runnerThread.interrupt();\n    }\n\n    /**\n     * Like {@link #stop()}, but this method will not exit until the thread\n     * which is following the file has finished executing (i.e., stop\n     * synchronously).\n     */\n    public synchronized void stopAndWait() throws InterruptedException {\n        stop();\n        while (runnerThread.isAlive()) {\n            Thread.yield();\n        }\n    }\n\n    /**\n     * Send the supplied string to all OutputDestinations\n     *\n     * @param s\n     */\n    private synchronized void print(String s) {\n        for (OutputDestination out : outputDestinations) {\n            out.print(s);\n        }\n    }\n\n    /**\n     * Clear all OutputDestinations\n     */\n    private synchronized void clear() {\n        for (OutputDestination out : outputDestinations) {\n            out.clear();\n        }\n    }\n\n    /**\n     * Add another OutputDestination to which the followed file\u0027s contents\n     * should be printed.\n     *\n     * @param outputDestination\n     *            OutputDestination to be added\n     */\n    public boolean addOutputDestination(OutputDestination outputDestination) {\n        return outputDestinations.add(outputDestination);\n    }\n\n    /**\n     * Remove the supplied OutputDestination from the list of OutputDestinations\n     * to which the followed file\u0027s contents should be printed.\n     *\n     * @param outputDestination\n     *            OutputDestination to be removed\n     */\n    public boolean removeOutputDestination(OutputDestination outputDestination) {\n        return outputDestinations.remove(outputDestination);\n    }\n\n    /**\n     * Returns the List which maintains all OutputDestinations for this\n     * FileFollower.\n     *\n     * @return contains all OutputDestinations for this FileFollower\n     */\n    public List\u003cOutputDestination\u003e getOutputDestinations() {\n        return outputDestinations;\n    }\n\n    /**\n     * Returns the file which is being followed by this FileFollower\n     *\n     * @return file being followed\n     */\n    public File getFollowedFile() {\n        return file;\n    }\n\n    /**\n     * Returns the following state of a file\n     *\n     * @return true if being followed, false if not being followed\n     */\n    public boolean isBeingFollowed() {\n        return continueRunning;\n    }\n\n    /**\n     * Returns the pause state of the follower.\n     *\n     * @return true if paused, false otherwise\n     */\n    public boolean isPaused() {\n        return paused;\n    }\n\n    /**\n     * Returns the size of the character buffer used to read characters from the\n     * followed file. Each time the file is accessed, this buffer is filled.\n     *\n     * @return size of the character buffer\n     */\n    public int getBufferSize() {\n        return bufferSize;\n    }\n\n    /**\n     * Sets the size of the character buffer used to read characters from the\n     * followed file. Increasing buffer size will improve efficiency but\n     * increase the amount of memory used by the FileFollower.\u003cbr\u003e\n     * \u003cem\u003eNOTE:\u003c/em\u003e Setting this value will \u003cem\u003enot\u003c/em\u003e cause a running\n     * FileFollower to immediately begin reading characters into a buffer of the\n     * newly specified size. You must stop \u0026 restart the FileFollower in order\n     * for changes to take effect.\n     *\n     * @param bufferSize\n     *            size of the character buffer\n     */\n    public void setBufferSize(int bufferSize) {\n        this.bufferSize \u003d bufferSize;\n    }\n\n    /**\n     * Returns the time (in milliseconds) which a FileFollower spends sleeping\n     * each time it encounters the end of the followed file.\n     *\n     * @return latency, in milliseconds\n     */\n    public int getLatency() {\n        return latency;\n    }\n\n    /**\n     * Sets the time (in milliseconds) which a FileFollower spends sleeping each\n     * time it encounters the end of the followed file. Note that extremely low\n     * latency values may cause thrashing between the FileFollower\u0027s running\n     * thread and other threads in an application. A change in this value will\n     * be reflected the next time the FileFollower\u0027s running thread sleeps.\n     *\n     * @param latency\n     *            latency, in milliseconds\n     */\n    public void setLatency(int latency) {\n        this.latency \u003d latency;\n    }\n\n    protected int bufferSize;\n\n    protected int latency;\n\n    protected File file;\n\n    protected List\u003cOutputDestination\u003e outputDestinations;\n\n    protected boolean continueRunning;\n\n    protected boolean needsRestart;\n\n    protected Thread runnerThread;\n\n    protected boolean paused;\n\n    /**\n     * Instances of this class are used to run a thread which follows a\n     * FileFollower\u0027s file and sends prints its contents to OutputDestinations.\n     * This class should only handle the gathering of data from the followed\n     * file. Actually writing to the output destinations is handled by the outer\n     * class (FileFollower).\n     */\n    class Runner implements Runnable {\n\n        private Logger log \u003d Logger.getLogger(Runner.class.getName());\n\n        public void run() {\n            log.finer(\"entering FileFollower.run()\");\n            while (continueRunning) {\n                runAction();\n            }\n            log.finer(\"exiting FileFollower.run()\");\n        }\n\n        protected void runAction() {\n            try {\n                clear();\n                long fileSize \u003d file.length();\n                byte[] byteArray \u003d new byte[bufferSize];\n                int numBytesRead;\n                long lastActivityTime \u003d file.lastModified();\n                // create some stream readers to handle the file\n                FileInputStream fis \u003d new FileInputStream(file);\n                BufferedInputStream bis \u003d new BufferedInputStream(fis);\n                // start at the beginning of the file\n                long startingPoint \u003d 0;\n                // if the file size is bigger than the buffer size, skip to the\n                // end of the file if not performing a restart\n                if (fileSize \u003e bufferSize) {\n                    startingPoint \u003d fileSize - bufferSize;\n                }\n                // reset the restart flag\n                needsRestart \u003d false;\n                log.finer(\"Starting point: \" + startingPoint + \"; Last activity: \" + lastActivityTime);\n                bis.skip(startingPoint);\n                while (continueRunning \u0026\u0026 !needsRestart) {\n                    if (!paused) {\n                        lastActivityTime \u003d System.currentTimeMillis();\n                        numBytesRead \u003d bis.read(byteArray, 0, byteArray.length);\n                        boolean dataWasFound \u003d (numBytesRead \u003e 0);\n                        log.finer(\"Bytes read: \" + numBytesRead + \"; dataWasFound: \" + dataWasFound);\n                        // if data was found, print it and log activity time\n                        if (dataWasFound) {\n                            String output \u003d new String(byteArray, 0, numBytesRead);\n                            // print the output to the listeners\n                            print(output);\n                        } else // no data found so check the file and restart if needed\n                        {\n                            // check if the file handle has become stale (file\n                            // was modified, but no data was read).\n                            boolean fileExists \u003d file.exists();\n                            // removed check for 0 length because a file could\n                            // change by being cleared out\n                            // \u0026\u0026 (file_.length() \u003e 0);\n                            boolean fileHasChanged \u003d file.lastModified() \u003e lastActivityTime;\n                            if (fileExists \u0026\u0026 fileHasChanged) {\n                                log.finer(\"Needs restart [fileExists\u003d\" + fileExists + \"; fileHasChanged\u003d\" + fileHasChanged + \"]\");\n                                needsRestart \u003d true;\n                            }\n                        }\n                        boolean allDataRead \u003d (numBytesRead \u003c byteArray.length);\n                        if (allDataRead \u0026\u0026 !needsRestart) {\n                            log.finer(\"Sleeping for \" + latency + \"ms [allDataRead:\" + allDataRead + \"; needsRestart:\" + needsRestart + \"]\");\n                            sleep();\n                        }\n                    } else {\n                        log.finer(\"Runner paused.\");\n                        sleep();\n                    }\n                }\n                log.finer(\"exiting Runner.runAction [continueRunning\u003d\" + continueRunning + \"; needsRestart\u003d\" + needsRestart + \"]\");\n                bis.close();\n                fis.close();\n            } catch (IOException e) {\n                log.log(Level.SEVERE, \"IOException while following file\", e);\n            }\n        }\n\n        private void sleep() {\n            try {\n                Thread.sleep(latency);\n            } catch (InterruptedException e) {\n                // Interrupt may be thrown manually by stop()\n                log.finer(\"DIED IN MY SLEEP\");\n            }\n        }\n    }\n\n    /**\n     * Line separator, retrieved from System properties \u0026 stored statically.\n     */\n    protected static final String lineSeparator \u003d System.getProperty(\"line.separator\");\n}\n",
    "package": "ghm.follow",
    "classname": "FileFollower",
    "id": "/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/FileFollower_0Test.java",
    "test_prompt": "// FileFollower_0Test.java\npackage ghm.follow;\n\nimport ghm.follow.io.OutputDestination;\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileFollower}.\n* It contains ten unit test cases for the {@link FileFollower#addOutputDestination(OutputDestination)} method.\n*/\nclass FileFollower_0Test {",
    "method_signature": "addOutputDestination(OutputDestination)",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// FileFollower.java\n/*\n * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n * \n * This file is part of Follow (http://follow.sf.net).\n * \n * Follow is free software; you can redistribute it and/or modify it under the\n * terms of version 2 of the GNU General Public License as published by the Free\n * Software Foundation.\n * \n * Follow is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License along with\n * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\n * Suite 330, Boston, MA 02111-1307 USA\n */\npackage ghm.follow;\n\nimport ghm.follow.io.OutputDestination;\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Instances of this class \u0027follow\u0027 a particular text file, assmebling that\n * file\u0027s characters into Strings and sending them to instances of\n * {@link OutputDestination}. The name and behavior of this class are inspired\n * by the \u0027-f\u0027 (follow) flag of the UNIX command \u0027tail\u0027.\n *\n * @see OutputDestination\n * @author \u003ca href\u003d\"mailto:greghmerrill@yahoo.com\"\u003eGreg Merrill\u003c/a\u003e\n */\npublic class FileFollower {\n\n    /**\n     * Constructs a new FileFollower; invoking this constructor does\n     * \u003cem\u003enot\u003c/em\u003e cause the new object to begin following the supplied file.\n     * In order to begin following, one must call {@link #start()}.\n     *\n     * @param file\n     *            file to be followed\n     * @param bufferSize\n     *            number of chars to be read each time the file is accessed\n     * @param latency\n     *            each time a FileFollower\u0027s running thread encounters the end\n     *            of the file in its stream, it will rest for this many\n     *            milliseconds before checking to see if there are any more\n     *            bytes in the file\n     * @param initialOutputDestinations\n     *            an initial array of OutputDestinations which will be used when\n     *            printing the contents of the file (this array may be\n     *            \u003ctt\u003enull\u003c/tt\u003e)\n     */\n    public FileFollower(File file, int bufferSize, int latency, OutputDestination[] initialOutputDestinations) {\n        this.file \u003d file;\n        this.bufferSize \u003d bufferSize;\n        this.latency \u003d latency;\n        int initOutputDestsSize \u003d (initialOutputDestinations !\u003d null) ? initialOutputDestinations.length : 0;\n        outputDestinations \u003d new ArrayList\u003cOutputDestination\u003e(initOutputDestsSize);\n        for (int i \u003d 0; i \u003c initOutputDestsSize; i++) {\n            outputDestinations.add(initialOutputDestinations[i]);\n        }\n    }\n\n    /**\n     * Identical to {@link #FileFollower(File, int, int, OutputDestination[])},\n     * except that a default buffer size (32,768 characters) and latency (1000\n     * milliseconds) are used.\n     *\n     * @see #FileFollower(File, int, int, OutputDestination[])\n     */\n    public FileFollower(File file, OutputDestination[] initialOutputDestinations) {\n        // Initial buffer size pilfered from org.gjt.sp.jedit.Buffer. I\u0027m not\n        // sure whether this is a truly optimal buffer size.\n        this(// Don\u0027t change without updating docs!\n        file, // Don\u0027t change without updating docs!\n        32768, // Don\u0027t change without updating docs!\n        1000, initialOutputDestinations);\n    }\n\n    /**\n     * Cause this FileFollower to spawn a thread which will follow the file\n     * supplied in the constructor and send its contents to all of the\n     * FileFollower\u0027s OutputDestinations.\u003cbr\u003e\n     * \u003cbr\u003e\n     * If this FileFollower is running but paused, this method equates to\n     * calling unpause().\n     */\n    public synchronized void start() {\n        if (continueRunning \u0026\u0026 paused) {\n            unpause();\n        } else {\n            continueRunning \u003d true;\n            paused \u003d false;\n            runnerThread \u003d new Thread(new Runner(), getFollowedFile().getName());\n            runnerThread.start();\n        }\n    }\n\n    public synchronized void pause() {\n        paused \u003d true;\n    }\n\n    public synchronized void unpause() {\n        paused \u003d false;\n    }\n\n    public synchronized void restart() {\n        needsRestart \u003d true;\n        runnerThread.interrupt();\n    }\n\n    /**\n     * Cause this FileFollower to stop following the file supplied in the\n     * constructor after it flushes the characters it\u0027s currently reading to all\n     * its OutputDestinations.\n     */\n    public synchronized void stop() {\n        continueRunning \u003d false;\n        runnerThread.interrupt();\n    }\n\n    /**\n     * Like {@link #stop()}, but this method will not exit until the thread\n     * which is following the file has finished executing (i.e., stop\n     * synchronously).\n     */\n    public synchronized void stopAndWait() throws InterruptedException {\n        stop();\n        while (runnerThread.isAlive()) {\n            Thread.yield();\n        }\n    }\n\n    /**\n     * Send the supplied string to all OutputDestinations\n     *\n     * @param s\n     */\n    private synchronized void print(String s) {\n        for (OutputDestination out : outputDestinations) {\n            out.print(s);\n        }\n    }\n\n    /**\n     * Clear all OutputDestinations\n     */\n    private synchronized void clear() {\n        for (OutputDestination out : outputDestinations) {\n            out.clear();\n        }\n    }\n\n    /**\n     * Add another OutputDestination to which the followed file\u0027s contents\n     * should be printed.\n     *\n     * @param outputDestination\n     *            OutputDestination to be added\n     */\n    public boolean addOutputDestination(OutputDestination outputDestination) {\n        return outputDestinations.add(outputDestination);\n    }\n\n    /**\n     * Remove the supplied OutputDestination from the list of OutputDestinations\n     * to which the followed file\u0027s contents should be printed.\n     *\n     * @param outputDestination\n     *            OutputDestination to be removed\n     */\n    public boolean removeOutputDestination(OutputDestination outputDestination) {\n        return outputDestinations.remove(outputDestination);\n    }\n\n    /**\n     * Returns the List which maintains all OutputDestinations for this\n     * FileFollower.\n     *\n     * @return contains all OutputDestinations for this FileFollower\n     */\n    public List\u003cOutputDestination\u003e getOutputDestinations() {\n        return outputDestinations;\n    }\n\n    /**\n     * Returns the file which is being followed by this FileFollower\n     *\n     * @return file being followed\n     */\n    public File getFollowedFile() {\n        return file;\n    }\n\n    /**\n     * Returns the following state of a file\n     *\n     * @return true if being followed, false if not being followed\n     */\n    public boolean isBeingFollowed() {\n        return continueRunning;\n    }\n\n    /**\n     * Returns the pause state of the follower.\n     *\n     * @return true if paused, false otherwise\n     */\n    public boolean isPaused() {\n        return paused;\n    }\n\n    /**\n     * Returns the size of the character buffer used to read characters from the\n     * followed file. Each time the file is accessed, this buffer is filled.\n     *\n     * @return size of the character buffer\n     */\n    public int getBufferSize() {\n        return bufferSize;\n    }\n\n    /**\n     * Sets the size of the character buffer used to read characters from the\n     * followed file. Increasing buffer size will improve efficiency but\n     * increase the amount of memory used by the FileFollower.\u003cbr\u003e\n     * \u003cem\u003eNOTE:\u003c/em\u003e Setting this value will \u003cem\u003enot\u003c/em\u003e cause a running\n     * FileFollower to immediately begin reading characters into a buffer of the\n     * newly specified size. You must stop \u0026 restart the FileFollower in order\n     * for changes to take effect.\n     *\n     * @param bufferSize\n     *            size of the character buffer\n     */\n    public void setBufferSize(int bufferSize) {\n        this.bufferSize \u003d bufferSize;\n    }\n\n    /**\n     * Returns the time (in milliseconds) which a FileFollower spends sleeping\n     * each time it encounters the end of the followed file.\n     *\n     * @return latency, in milliseconds\n     */\n    public int getLatency() {\n        return latency;\n    }\n\n    /**\n     * Sets the time (in milliseconds) which a FileFollower spends sleeping each\n     * time it encounters the end of the followed file. Note that extremely low\n     * latency values may cause thrashing between the FileFollower\u0027s running\n     * thread and other threads in an application. A change in this value will\n     * be reflected the next time the FileFollower\u0027s running thread sleeps.\n     *\n     * @param latency\n     *            latency, in milliseconds\n     */\n    public void setLatency(int latency) {\n        this.latency \u003d latency;\n    }\n\n    protected int bufferSize;\n\n    protected int latency;\n\n    protected File file;\n\n    protected List\u003cOutputDestination\u003e outputDestinations;\n\n    protected boolean continueRunning;\n\n    protected boolean needsRestart;\n\n    protected Thread runnerThread;\n\n    protected boolean paused;\n\n    /**\n     * Instances of this class are used to run a thread which follows a\n     * FileFollower\u0027s file and sends prints its contents to OutputDestinations.\n     * This class should only handle the gathering of data from the followed\n     * file. Actually writing to the output destinations is handled by the outer\n     * class (FileFollower).\n     */\n    class Runner implements Runnable {\n\n        private Logger log \u003d Logger.getLogger(Runner.class.getName());\n\n        public void run() {\n            log.finer(\"entering FileFollower.run()\");\n            while (continueRunning) {\n                runAction();\n            }\n            log.finer(\"exiting FileFollower.run()\");\n        }\n\n        protected void runAction() {\n            try {\n                clear();\n                long fileSize \u003d file.length();\n                byte[] byteArray \u003d new byte[bufferSize];\n                int numBytesRead;\n                long lastActivityTime \u003d file.lastModified();\n                // create some stream readers to handle the file\n                FileInputStream fis \u003d new FileInputStream(file);\n                BufferedInputStream bis \u003d new BufferedInputStream(fis);\n                // start at the beginning of the file\n                long startingPoint \u003d 0;\n                // if the file size is bigger than the buffer size, skip to the\n                // end of the file if not performing a restart\n                if (fileSize \u003e bufferSize) {\n                    startingPoint \u003d fileSize - bufferSize;\n                }\n                // reset the restart flag\n                needsRestart \u003d false;\n                log.finer(\"Starting point: \" + startingPoint + \"; Last activity: \" + lastActivityTime);\n                bis.skip(startingPoint);\n                while (continueRunning \u0026\u0026 !needsRestart) {\n                    if (!paused) {\n                        lastActivityTime \u003d System.currentTimeMillis();\n                        numBytesRead \u003d bis.read(byteArray, 0, byteArray.length);\n                        boolean dataWasFound \u003d (numBytesRead \u003e 0);\n                        log.finer(\"Bytes read: \" + numBytesRead + \"; dataWasFound: \" + dataWasFound);\n                        // if data was found, print it and log activity time\n                        if (dataWasFound) {\n                            String output \u003d new String(byteArray, 0, numBytesRead);\n                            // print the output to the listeners\n                            print(output);\n                        } else // no data found so check the file and restart if needed\n                        {\n                            // check if the file handle has become stale (file\n                            // was modified, but no data was read).\n                            boolean fileExists \u003d file.exists();\n                            // removed check for 0 length because a file could\n                            // change by being cleared out\n                            // \u0026\u0026 (file_.length() \u003e 0);\n                            boolean fileHasChanged \u003d file.lastModified() \u003e lastActivityTime;\n                            if (fileExists \u0026\u0026 fileHasChanged) {\n                                log.finer(\"Needs restart [fileExists\u003d\" + fileExists + \"; fileHasChanged\u003d\" + fileHasChanged + \"]\");\n                                needsRestart \u003d true;\n                            }\n                        }\n                        boolean allDataRead \u003d (numBytesRead \u003c byteArray.length);\n                        if (allDataRead \u0026\u0026 !needsRestart) {\n                            log.finer(\"Sleeping for \" + latency + \"ms [allDataRead:\" + allDataRead + \"; needsRestart:\" + needsRestart + \"]\");\n                            sleep();\n                        }\n                    } else {\n                        log.finer(\"Runner paused.\");\n                        sleep();\n                    }\n                }\n                log.finer(\"exiting Runner.runAction [continueRunning\u003d\" + continueRunning + \"; needsRestart\u003d\" + needsRestart + \"]\");\n                bis.close();\n                fis.close();\n            } catch (IOException e) {\n                log.log(Level.SEVERE, \"IOException while following file\", e);\n            }\n        }\n\n        private void sleep() {\n            try {\n                Thread.sleep(latency);\n            } catch (InterruptedException e) {\n                // Interrupt may be thrown manually by stop()\n                log.finer(\"DIED IN MY SLEEP\");\n            }\n        }\n    }\n\n    /**\n     * Line separator, retrieved from System properties \u0026 stored statically.\n     */\n    protected static final String lineSeparator \u003d System.getProperty(\"line.separator\");\n}\n",
    "package": "ghm.follow",
    "classname": "FileFollower",
    "id": "/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/FileFollower_1Test.java",
    "test_prompt": "// FileFollower_1Test.java\npackage ghm.follow;\n\nimport ghm.follow.io.OutputDestination;\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileFollower}.\n* It contains ten unit test cases for the {@link FileFollower#removeOutputDestination(OutputDestination)} method.\n*/\nclass FileFollower_1Test {",
    "method_signature": "removeOutputDestination(OutputDestination)",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// FollowApp.java\n/*\n * Copyright (C) 2000-2003 Greg Merrill (greghmerrill@yahoo.com)\n * \n * This file is part of Follow (http://follow.sf.net).\n * \n * Follow is free software; you can redistribute it and/or modify it under the\n * terms of version 2 of the GNU General Public License as published by the Free\n * Software Foundation.\n * \n * Follow is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License along with\n * Follow; if not, write to the Free Software Foundation, Inc., 59 Temple Place,\n * Suite 330, Boston, MA 02111-1307 USA\n */\npackage ghm.follow;\n\nimport ghm.follow.config.Configure;\nimport ghm.follow.config.FollowAppAttributes;\nimport ghm.follow.event.WindowTracker;\nimport ghm.follow.gui.About;\nimport ghm.follow.gui.Clear;\nimport ghm.follow.gui.ClearAll;\nimport ghm.follow.gui.Close;\nimport ghm.follow.gui.Debug;\nimport ghm.follow.gui.Delete;\nimport ghm.follow.gui.DeleteAll;\nimport ghm.follow.gui.DndFileOpener;\nimport ghm.follow.gui.Edit;\nimport ghm.follow.gui.Exit;\nimport ghm.follow.gui.FileFollowingPane;\nimport ghm.follow.gui.FollowAppAction;\nimport ghm.follow.gui.Menu;\nimport ghm.follow.gui.ComponentBuilder;\nimport ghm.follow.gui.Open;\nimport ghm.follow.gui.Pause;\nimport ghm.follow.gui.PopupMenu;\nimport ghm.follow.gui.Reset;\nimport ghm.follow.gui.StartupStatus;\nimport ghm.follow.gui.TabbedPane;\nimport ghm.follow.gui.ToolBar;\nimport ghm.follow.gui.FollowAppAction.ActionContext;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport ghm.follow.search.SearchableTextPane;\nimport ghm.follow.systemInterface.DefaultSystemInterface;\nimport ghm.follow.systemInterface.SystemInterface;\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.Window;\nimport java.awt.dnd.DropTarget;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.URL;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport javax.swing.ImageIcon;\nimport javax.swing.JFrame;\nimport javax.swing.JMenuBar;\nimport javax.swing.JTabbedPane;\nimport javax.swing.SwingUtilities;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * This class\u0027 main() method is the entry point into the Follow application.\n *\n * @see #main(String[])\n * @author \u003ca href\u003d\"mailto:greghmerrill@yahoo.com\"\u003eGreg Merrill\u003c/a\u003e\n */\npublic class FollowApp {\n\n    public static final String FILE_SEPARATOR \u003d System.getProperty(\"file.separator\");\n\n    public static final String MESSAGE_LINE_SEPARATOR \u003d \"\\n\";\n\n    public static final boolean DEBUG \u003d Boolean.getBoolean(\"follow.debug\");\n\n    public static boolean HAS_SOLARIS_BUG \u003d false;\n\n    private static Logger LOG \u003d Logger.getLogger(FollowApp.class.getName());\n\n    private int currentCursor \u003d Cursor.DEFAULT_CURSOR;\n\n    private Cursor defaultCursor;\n\n    private Cursor waitCursor;\n\n    private Map\u003cFile, FileFollowingPane\u003e fileToFollowingPaneMap \u003d new HashMap\u003cFile, FileFollowingPane\u003e();\n\n    private JTabbedPane tabbedPane;\n\n    private ToolBar toolBar;\n\n    private PopupMenu popupMenu;\n\n    private Menu recentFilesMenu;\n\n    private MouseListener rightClickListener;\n\n    private HashMap\u003cString, FollowAppAction\u003e actions \u003d new HashMap\u003cString, FollowAppAction\u003e();\n\n    private SystemInterface systemInterface;\n\n    private StartupStatus startupStatus;\n\n    private FollowAppAttributes attributes;\n\n    private static FollowApp instance;\n\n    private static ResourceBundle resources \u003d ResourceBundle.getBundle(\"ghm.follow.FollowAppResourceBundle\");\n\n    private JFrame frame;\n\n    // We should remove this hack once JDK 1.4 gets wide adoption on Solaris.\n    static {\n        boolean isSolaris \u003d \"SunOS\".equals(System.getProperty(\"os.name\"));\n        if (isSolaris) {\n            String version \u003d System.getProperty(\"java.version\");\n            if ((version !\u003d null) \u0026\u0026 version.startsWith(\"1.\")) {\n                String substring \u003d version.substring(2, 3);\n                try {\n                    int minor \u003d Integer.parseInt(substring);\n                    if (minor \u003c 4) {\n                        HAS_SOLARIS_BUG \u003d true;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // Nothing else to do.\n                }\n            }\n        }\n    }\n\n    /**\n     * @param fileNames\n     *            names of files to be opened\n     */\n    FollowApp(List\u003cString\u003e fileNames) throws IOException, InterruptedException, InvocationTargetException {\n        this(fileNames, null);\n    }\n\n    FollowApp(List\u003cString\u003e filenames, File propertyFile) throws IOException, InterruptedException, InvocationTargetException {\n        // Create \u0026 show startup status window\n        startupStatus \u003d new StartupStatus(resources);\n        centerWindowInScreen(startupStatus);\n        startupStatus.pack();\n        SwingUtilities.invokeAndWait(new Runnable() {\n\n            public void run() {\n                startupStatus.setVisible(true);\n            }\n        });\n        // Ghastly workaround for bug in Font construction, in review by\n        // Sun with review id 108683.\n        GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n        SwingUtilities.invokeAndWait(new Runnable() {\n\n            public void run() {\n                startupStatus.markDone(startupStatus.LOAD_SYSTEM_FONTS);\n            }\n        });\n        // create frame first. the close operation is handled in WindowTracker\n        frame \u003d new JFrame(getResourceString(\"frame.title\"));\n        // load the attributes\n        attributes \u003d new FollowAppAttributes(propertyFile);\n        // add listeners to update the recent files list\n        RecentFileListener rfl \u003d new RecentFileListener();\n        attributes.addPropertyChangeListener(FollowAppAttributes.RECENT_FILES_KEY, rfl);\n        attributes.addPropertyChangeListener(FollowAppAttributes.RECENT_FILES_MAX_KEY, rfl);\n        // load the actions referenced in the application\n        loadActions();\n        // initialize SystemInterface\n        systemInterface \u003d new DefaultSystemInterface(this);\n        // initialize menubar\n        JMenuBar jMenuBar \u003d ComponentBuilder.buildMenuBar(resources, getActions());\n        // set the recent files menu to local variable so it can be updated\n        // easily\n        recentFilesMenu \u003d ComponentBuilder.recentFilesMenu;\n        // fake an event to get the menu setup initially\n        rfl.propertyChange(null);\n        // initialize popupMenu\n        popupMenu \u003d ComponentBuilder.buildPopupMenu(getActions());\n        // initialize toolbar\n        toolBar \u003d ComponentBuilder.buildToolBar(getActions());\n        // initialize tabbedPane, but wait to open files until after frame\n        // initialization\n        tabbedPane \u003d new TabbedPane(attributes);\n        enableDragAndDrop(tabbedPane);\n        // initialize frame\n        initFrame(jMenuBar);\n        // This is an ugly hack. It seems like JFrame.setLocation() is buggy\n        // on Solaris jdk versions before 1.4\n        if (HAS_SOLARIS_BUG) {\n            frame.setLocation(50, 50);\n        } else {\n            frame.setLocation(attributes.getX(), attributes.getY());\n        }\n        // track window close events. WindowTracker handles the close operation\n        frame.addWindowListener(new WindowTracker(attributes, tabbedPane, systemInterface));\n        enableDragAndDrop(frame);\n        // Open files from attributes; this is done after the frame is complete\n        // and all components have been added to it to make sure that the frame\n        // can be shown absolutely as soon as possible. If we put this code\n        // before frame creation (as in v1.0), frame creation may take longer\n        // because there are more threads (spawned in the course of open())\n        // contending for processor time.\n        List\u003cFile\u003e files \u003d attributes.getFollowedFiles();\n        StringBuffer nonexistentFilesBuffer \u003d null;\n        int nonexistentFileCount \u003d 0;\n        for (File file : files) {\n            try {\n                openFile(file);\n            } catch (FileNotFoundException e) {\n                // This file has been deleted since the previous execution.\n                // Remove it from the list of followed files\n                attributes.removeFollowedFile(file);\n                nonexistentFileCount++;\n                if (nonexistentFilesBuffer \u003d\u003d null) {\n                    nonexistentFilesBuffer \u003d new StringBuffer(file.getAbsolutePath());\n                } else {\n                    nonexistentFilesBuffer.append(file.getAbsolutePath());\n                }\n                nonexistentFilesBuffer.append(MESSAGE_LINE_SEPARATOR);\n            }\n        }\n        // open files from the command line\n        for (String filename : filenames) {\n            try {\n                openFile(new File(filename));\n            } catch (FileNotFoundException e) {\n                String msg \u003d MessageFormat.format(getResourceString(\"message.cmdLineFileNotFound.text\"), new Object[] { filename });\n                LOG.info(msg);\n            }\n        }\n        if (nonexistentFileCount \u003e 0) {\n            // Alert the user of the fact that one or more files have been\n            // deleted since the previous execution\n            String text \u003d getResourceString(\"message.filesDeletedSinceLastExecution.text\");\n            String message \u003d MessageFormat.format(text, new Object[] { nonexistentFileCount, nonexistentFilesBuffer.toString() });\n            // String title \u003d\n            // getResourceString(\"message.filesDeletedSinceLastExecution.title\");\n            // JOptionPane.showMessageDialog(frame_, message, title,\n            // JOptionPane.WARNING_MESSAGE);\n            LOG.info(message);\n        }\n        int tabCount \u003d tabbedPane.getTabCount();\n        if (tabCount \u003e 0) {\n            if (tabCount \u003e attributes.getSelectedTabIndex()) {\n                tabbedPane.setSelectedIndex(attributes.getSelectedTabIndex());\n            } else {\n                tabbedPane.setSelectedIndex(0);\n            }\n        }\n    }\n\n    /**\n     * Close the current tab\n     */\n    public void closeFile() {\n        FileFollowingPane fileFollowingPane \u003d getSelectedFileFollowingPane();\n        int tab \u003d tabbedPane.getSelectedIndex();\n        if (tab \u003e\u003d 0) {\n            tabbedPane.removeTabAt(tab);\n            disableDragAndDrop(fileFollowingPane.getTextPane());\n            attributes.removeFollowedFile(fileFollowingPane.getFollowedFile());\n            fileFollowingPane.stopFollowing();\n            fileToFollowingPaneMap.remove(fileFollowingPane.getFollowedFile());\n        }\n        updateActions();\n    }\n\n    /**\n     * Get a string from the resource bundle. Convenience method to shorten and\n     * centralize this common call\n     *\n     * @param key\n     * @return The value of key in the resource bundle. null if the key is not\n     *         found.\n     */\n    public static String getResourceString(String key) {\n        String value \u003d null;\n        try {\n            value \u003d resources.getString(key);\n        } catch (MissingResourceException mre) {\n            LOG.warning(mre.getMessage());\n        }\n        return value;\n    }\n\n    /**\n     * Gets an image icon from the resource path.\n     *\n     * @param clazz\n     *            The class to use as an entry point to the resource path. Image\n     *            path should be relative to this class.\n     * @param iconNameKey\n     *            The resource key name where the image is defined.\n     * @return An image icon based on the URL generated from the value of\n     *         iconNameKey. null if no URL can be found.\n     */\n    public static ImageIcon getIcon(Class\u003c?\u003e clazz, String iconNameKey) {\n        String filename \u003d getResourceString(iconNameKey);\n        URL url \u003d clazz.getResource(filename);\n        LOG.finer(\"Class: \" + clazz + \", iconNameKey: \" + iconNameKey);\n        LOG.finer(\"filename: \" + filename);\n        LOG.finer(\"url: \" + url);\n        ImageIcon icon \u003d null;\n        if (url !\u003d null) {\n            icon \u003d new ImageIcon(url);\n            LOG.finer(\"errored: \" + (java.awt.MediaTracker.ERRORED \u003d\u003d icon.getImageLoadStatus()));\n        }\n        return icon;\n    }\n\n    /**\n     * Loads the actions used in the application\n     *\n     * @throws IOException\n     */\n    private void loadActions() throws IOException {\n        // initialize actions\n        putAction(Open.NAME, new Open(this));\n        putAction(Close.NAME, new Close(this));\n        putAction(Edit.NAME, new Edit(this));\n        putAction(Exit.NAME, new Exit(this));\n        putAction(Top.NAME, new Top(this));\n        putAction(Bottom.NAME, new Bottom(this));\n        putAction(Clear.NAME, new Clear(this));\n        putAction(ClearAll.NAME, new ClearAll(this));\n        putAction(Delete.NAME, new Delete(this));\n        putAction(DeleteAll.NAME, new DeleteAll(this));\n        putAction(Configure.NAME, new Configure(this));\n        putAction(About.NAME, new About(this));\n        if (DEBUG) {\n            putAction(Debug.NAME, new Debug(this));\n        }\n        putAction(Pause.NAME, new Pause(this));\n        putAction(NextTab.NAME, new NextTab(this));\n        putAction(PreviousTab.NAME, new PreviousTab(this));\n        putAction(Find.NAME, new Find(this));\n        putAction(ClearHighlights.NAME, new ClearHighlights(this));\n        putAction(ClearAllHighlights.NAME, new ClearAllHighlights(this));\n        putAction(Reset.NAME, new Reset(this));\n    }\n\n    /**\n     * @param jMenuBar\n     */\n    private void initFrame(JMenuBar jMenuBar) {\n        frame.setJMenuBar(jMenuBar);\n        frame.getContentPane().add(toolBar, BorderLayout.NORTH);\n        frame.getContentPane().add(tabbedPane, BorderLayout.CENTER);\n        frame.setSize(attributes.getWidth(), attributes.getHeight());\n    }\n\n    public void show() {\n        frame.setVisible(true);\n    }\n\n    public FollowAppAction getAction(String name) {\n        return actions.get(name);\n    }\n\n    /**\n     * Get all actions associated to the application\n     *\n     * @return\n     */\n    public HashMap\u003cString, FollowAppAction\u003e getActions() {\n        return actions;\n    }\n\n    /**\n     * Set an action to the action map of the application.\n     *\n     * @param name\n     *            The key to set the action to.\n     * @param action\n     *            The action to create an association for.\n     */\n    public void putAction(String name, FollowAppAction action) {\n        if (FollowAppAction.ActionContext.APP \u003d\u003d action.getContext())\n            action.setEnabled(true);\n        else\n            action.setEnabled(false);\n        actions.put(name, action);\n    }\n\n    public void openFile(File file) throws FileNotFoundException {\n        openFile(file, attributes.autoScroll());\n    }\n\n    /**\n     * Warning: This method should be called only from (1) the FollowApp\n     * initializer (before any components are realized) or (2) from the event\n     * dispatching thread.\n     */\n    void openFile(File file, boolean startFollowing) throws FileNotFoundException {\n        if (file \u003d\u003d null) {\n            throw new FileNotFoundException(\"file is null.\");\n        }\n        if (!file.exists()) {\n            throw new FileNotFoundException(file.getName() + \" not found.\");\n        }\n        FileFollowingPane fileFollowingPane \u003d (FileFollowingPane) fileToFollowingPaneMap.get(file);\n        if (fileFollowingPane !\u003d null) {\n            // File is already open; merely select its tab\n            tabbedPane.setSelectedComponent(fileFollowingPane);\n        } else {\n            fileFollowingPane \u003d new FileFollowingPane(file, attributes.getBufferSize(), attributes.getLatency(), attributes.autoScroll(), attributes.getFont(), attributes.getTabSize());\n            SearchableTextPane ffpTextPane \u003d fileFollowingPane.getTextPane();\n            enableDragAndDrop(ffpTextPane);\n            fileFollowingPane.setSize(frame.getSize());\n            ffpTextPane.setFont(attributes.getFont());\n            ffpTextPane.addMouseListener(getRightClickListener());\n            fileToFollowingPaneMap.put(file, fileFollowingPane);\n            if (startFollowing) {\n                fileFollowingPane.startFollowing();\n            }\n            tabbedPane.addTab(file.getName(), null, fileFollowingPane, file.getAbsolutePath());\n            int tabCount \u003d tabbedPane.getTabCount();\n            if (tabCount \u003c 10) {\n                // KeyEvent.VK_1 through KeyEvent.VK_9 is represented by the\n                // ascii characters 1-9 (49-57)\n                int index \u003d tabCount - 1;\n                tabbedPane.setMnemonicAt(index, index + ((int) \u00271\u0027));\n            }\n            tabbedPane.setSelectedIndex(tabCount - 1);\n            // add a listener to set the pause icon correctly\n            fileFollowingPane.addComponentListener(new ComponentAdapter() {\n\n                public void componentShown(ComponentEvent e) {\n                    FileFollowingPane ffp \u003d (FileFollowingPane) e.getSource();\n                    Pause pause \u003d (Pause) getAction(Pause.NAME);\n                    pause.setIconByState(ffp.isFollowingPaused());\n                }\n            });\n            // add the file to history\n            attributes.addFollowedFile(file);\n            attributes.addRecentFile(file);\n            updateActions();\n        }\n    }\n\n    private void updateActions() {\n        int tabCount \u003d tabbedPane.getTabCount();\n        for (FollowAppAction a : actions.values()) {\n            if (tabCount \u003c\u003d 1 \u0026\u0026 a.getContext() \u003d\u003d ActionContext.MULTI_FILE)\n                a.setEnabled(false);\n            else if (tabCount \u003d\u003d 0 \u0026\u0026 a.getContext() \u003d\u003d ActionContext.SINGLE_FILE)\n                a.setEnabled(false);\n            else\n                a.setEnabled(true);\n        }\n    }\n\n    /**\n     * Warning: This method should be called only from the event dispatching\n     * thread.\n     *\n     * @param cursorType\n     *            may be Cursor.DEFAULT_CURSOR or Cursor.WAIT_CURSOR\n     */\n    public void setCursor(int cursorType) {\n        if (cursorType \u003d\u003d currentCursor) {\n            return;\n        }\n        switch(cursorType) {\n            case Cursor.DEFAULT_CURSOR:\n                if (defaultCursor \u003d\u003d null) {\n                    defaultCursor \u003d Cursor.getDefaultCursor();\n                }\n                frame.setCursor(defaultCursor);\n                break;\n            case Cursor.WAIT_CURSOR:\n                if (waitCursor \u003d\u003d null) {\n                    waitCursor \u003d Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR);\n                }\n                frame.setCursor(waitCursor);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Supported cursors are Cursor.DEFAULT_CURSOR and Cursor.WAIT_CURSOR\");\n        }\n        currentCursor \u003d cursorType;\n    }\n\n    // Lazy initializer for the right-click listener which invokes a popup menu\n    private MouseListener getRightClickListener() {\n        if (rightClickListener \u003d\u003d null) {\n            rightClickListener \u003d new MouseAdapter() {\n\n                public void mouseReleased(MouseEvent e) {\n                    if (SwingUtilities.isRightMouseButton(e)) {\n                        Component source \u003d e.getComponent();\n                        popupMenu.show(source, e.getX(), e.getY());\n                    }\n                }\n            };\n        }\n        return rightClickListener;\n    }\n\n    public void enableDragAndDrop(Component c) {\n        // Invoking this constructor automatically sets the component\u0027s drop\n        // target\n        new DropTarget(c, new DndFileOpener(this));\n    }\n\n    public void disableDragAndDrop(Component c) {\n        c.setDropTarget(null);\n    }\n\n    public FileFollowingPane getSelectedFileFollowingPane() {\n        return (FileFollowingPane) tabbedPane.getSelectedComponent();\n    }\n\n    public List\u003cFileFollowingPane\u003e getAllFileFollowingPanes() {\n        int tabCount \u003d tabbedPane.getTabCount();\n        List\u003cFileFollowingPane\u003e allFileFollowingPanes \u003d new ArrayList\u003cFileFollowingPane\u003e();\n        for (int i \u003d 0; i \u003c tabCount; i++) {\n            allFileFollowingPanes.add((FileFollowingPane) tabbedPane.getComponentAt(i));\n        }\n        return allFileFollowingPanes;\n    }\n\n    public FollowAppAttributes getAttributes() {\n        return attributes;\n    }\n\n    public Map\u003cFile, FileFollowingPane\u003e getFileToFollowingPaneMap() {\n        return fileToFollowingPaneMap;\n    }\n\n    public JFrame getFrame() {\n        return frame;\n    }\n\n    public static FollowApp getInstance() {\n        return instance;\n    }\n\n    public SystemInterface getSystemInterface() {\n        return systemInterface;\n    }\n\n    public void setSystemInterface(SystemInterface systemInterface) {\n        this.systemInterface \u003d systemInterface;\n    }\n\n    public JTabbedPane getTabbedPane() {\n        return tabbedPane;\n    }\n\n    public static void centerWindowInScreen(Window window) {\n        Dimension screenSize \u003d window.getToolkit().getScreenSize();\n        Dimension windowSize \u003d window.getPreferredSize();\n        window.setLocation((int) (screenSize.getWidth() / 2 - windowSize.getWidth() / 2), (int) (screenSize.getHeight() / 2 - windowSize.getHeight() / 2));\n    }\n\n    /**\n     * Invoke this method to start the Follow application. If any command-line\n     * arguments are passed in, they are assume to be filenames and are opened\n     * in the Follow application\n     *\n     * @param args\n     *            files to be opened\n     */\n    public static void main(String[] args) {\n        try {\n            ArrayList\u003cString\u003e fileNames \u003d new ArrayList\u003cString\u003e();\n            File propFile \u003d null;\n            for (int i \u003d 0; i \u003c args.length; i++) {\n                if (args[i].startsWith(\"-\")) {\n                    if (\"-propFile\".equalsIgnoreCase(args[i])) {\n                        propFile \u003d new File(args[++i]);\n                    }\n                } else {\n                    fileNames.add(args[i]);\n                }\n            }\n            instance \u003d new FollowApp(fileNames, propFile);\n            SwingUtilities.invokeAndWait(new Runnable() {\n\n                public void run() {\n                    // ensure all widgets inited before opening files\n                    instance.show();\n                    instance.startupStatus.markDone(instance.startupStatus.CREATE_WIDGETS);\n                }\n            });\n            instance.startupStatus.dispose();\n            // commented code below so that windows follow based on setting in\n            // preferences which is set on the pane when the file is opened\n            // for (int i\u003d0; i \u003c instance_.tabbedPane_.getTabCount(); i++) {\n            // ((FileFollowingPane)instance_.tabbedPane_.getComponentAt(i)).startFollowing();\n            // }\n        } catch (Throwable t) {\n            LOG.log(Level.SEVERE, \"Unhandled exception\", t);\n            System.exit(-1);\n        }\n    }\n\n    private class RecentFileListener implements PropertyChangeListener {\n\n        public void propertyChange(PropertyChangeEvent evt) {\n            if (recentFilesMenu !\u003d null) {\n                recentFilesMenu.removeAll();\n                List\u003cFile\u003e recentFiles \u003d attributes.getRecentFiles();\n                // descend down the list to order files by last opened\n                for (int i \u003d recentFiles.size() - 1; i \u003e\u003d 0; i--) {\n                    // have to use FollowApp.this because \u0027this\u0027 is now the\n                    // context of\n                    // the inner class\n                    recentFilesMenu.add(new Open(FollowApp.this, recentFiles.get(i)));\n                }\n            }\n        }\n    }\n}\n",
    "package": "ghm.follow",
    "classname": "FollowApp",
    "id": "/EvoSuiteBenchmark/original/41_follow/src/main/java/ghm/follow/FollowApp_1Test.java",
    "test_prompt": "// FollowApp_1Test.java\npackage ghm.follow;\n\nimport ghm.follow.config.Configure;\nimport ghm.follow.config.FollowAppAttributes;\nimport ghm.follow.event.WindowTracker;\nimport ghm.follow.gui.About;\nimport ghm.follow.gui.Clear;\nimport ghm.follow.gui.ClearAll;\nimport ghm.follow.gui.Close;\nimport ghm.follow.gui.Debug;\nimport ghm.follow.gui.Delete;\nimport ghm.follow.gui.DeleteAll;\nimport ghm.follow.gui.DndFileOpener;\nimport ghm.follow.gui.Edit;\nimport ghm.follow.gui.Exit;\nimport ghm.follow.gui.FileFollowingPane;\nimport ghm.follow.gui.FollowAppAction;\nimport ghm.follow.gui.Menu;\nimport ghm.follow.gui.ComponentBuilder;\nimport ghm.follow.gui.Open;\nimport ghm.follow.gui.Pause;\nimport ghm.follow.gui.PopupMenu;\nimport ghm.follow.gui.Reset;\nimport ghm.follow.gui.StartupStatus;\nimport ghm.follow.gui.TabbedPane;\nimport ghm.follow.gui.ToolBar;\nimport ghm.follow.gui.FollowAppAction.ActionContext;\nimport ghm.follow.nav.Bottom;\nimport ghm.follow.nav.NextTab;\nimport ghm.follow.nav.PreviousTab;\nimport ghm.follow.nav.Top;\nimport ghm.follow.search.ClearAllHighlights;\nimport ghm.follow.search.ClearHighlights;\nimport ghm.follow.search.Find;\nimport ghm.follow.search.SearchableTextPane;\nimport ghm.follow.systemInterface.DefaultSystemInterface;\nimport ghm.follow.systemInterface.SystemInterface;\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.Window;\nimport java.awt.dnd.DropTarget;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.beans.PropertyChangeEvent;\nimport java.beans.PropertyChangeListener;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.URL;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport javax.swing.ImageIcon;\nimport javax.swing.JFrame;\nimport javax.swing.JMenuBar;\nimport javax.swing.JTabbedPane;\nimport javax.swing.SwingUtilities;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FollowApp}.\n* It contains ten unit test cases for the {@link FollowApp#getIcon(Class, String)} method.\n*/\nclass FollowApp_1Test {",
    "method_signature": "getIcon(Class, String)",
    "suffix": "1"
  }
]